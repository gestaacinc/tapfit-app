function FE(t,e){for(var n=0;n<e.length;n++){const r=e[n];if(typeof r!="string"&&!Array.isArray(r)){for(const s in r)if(s!=="default"&&!(s in t)){const o=Object.getOwnPropertyDescriptor(r,s);o&&Object.defineProperty(t,s,o.get?o:{enumerable:!0,get:()=>r[s]})}}}return Object.freeze(Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const i of o.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&r(i)}).observe(document,{childList:!0,subtree:!0});function n(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function r(s){if(s.ep)return;s.ep=!0;const o=n(s);fetch(s.href,o)}})();var Pc=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Af(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}function rL(t){if(Object.prototype.hasOwnProperty.call(t,"__esModule"))return t;var e=t.default;if(typeof e=="function"){var n=function r(){return this instanceof r?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};n.prototype=e.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(t).forEach(function(r){var s=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(n,r,s.get?s:{enumerable:!0,get:function(){return t[r]}})}),n}var t1={exports:{}},ph={},n1={exports:{}},xt={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var jk;function sL(){if(jk)return xt;jk=1;var t=Symbol.for("react.element"),e=Symbol.for("react.portal"),n=Symbol.for("react.fragment"),r=Symbol.for("react.strict_mode"),s=Symbol.for("react.profiler"),o=Symbol.for("react.provider"),i=Symbol.for("react.context"),a=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),c=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),f=Symbol.iterator;function p(q){return q===null||typeof q!="object"?null:(q=f&&q[f]||q["@@iterator"],typeof q=="function"?q:null)}var g={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},y=Object.assign,x={};function w(q,ue,we){this.props=q,this.context=ue,this.refs=x,this.updater=we||g}w.prototype.isReactComponent={},w.prototype.setState=function(q,ue){if(typeof q!="object"&&typeof q!="function"&&q!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,q,ue,"setState")},w.prototype.forceUpdate=function(q){this.updater.enqueueForceUpdate(this,q,"forceUpdate")};function S(){}S.prototype=w.prototype;function $(q,ue,we){this.props=q,this.context=ue,this.refs=x,this.updater=we||g}var I=$.prototype=new S;I.constructor=$,y(I,w.prototype),I.isPureReactComponent=!0;var R=Array.isArray,_=Object.prototype.hasOwnProperty,O={current:null},F={key:!0,ref:!0,__self:!0,__source:!0};function B(q,ue,we){var Ge,et={},tt=null,Tt=null;if(ue!=null)for(Ge in ue.ref!==void 0&&(Tt=ue.ref),ue.key!==void 0&&(tt=""+ue.key),ue)_.call(ue,Ge)&&!F.hasOwnProperty(Ge)&&(et[Ge]=ue[Ge]);var dt=arguments.length-2;if(dt===1)et.children=we;else if(1<dt){for(var vt=Array(dt),rn=0;rn<dt;rn++)vt[rn]=arguments[rn+2];et.children=vt}if(q&&q.defaultProps)for(Ge in dt=q.defaultProps,dt)et[Ge]===void 0&&(et[Ge]=dt[Ge]);return{$$typeof:t,type:q,key:tt,ref:Tt,props:et,_owner:O.current}}function M(q,ue){return{$$typeof:t,type:q.type,key:ue,ref:q.ref,props:q.props,_owner:q._owner}}function V(q){return typeof q=="object"&&q!==null&&q.$$typeof===t}function P(q){var ue={"=":"=0",":":"=2"};return"$"+q.replace(/[=:]/g,function(we){return ue[we]})}var re=/\/+/g;function ie(q,ue){return typeof q=="object"&&q!==null&&q.key!=null?P(""+q.key):ue.toString(36)}function me(q,ue,we,Ge,et){var tt=typeof q;(tt==="undefined"||tt==="boolean")&&(q=null);var Tt=!1;if(q===null)Tt=!0;else switch(tt){case"string":case"number":Tt=!0;break;case"object":switch(q.$$typeof){case t:case e:Tt=!0}}if(Tt)return Tt=q,et=et(Tt),q=Ge===""?"."+ie(Tt,0):Ge,R(et)?(we="",q!=null&&(we=q.replace(re,"$&/")+"/"),me(et,ue,we,"",function(rn){return rn})):et!=null&&(V(et)&&(et=M(et,we+(!et.key||Tt&&Tt.key===et.key?"":(""+et.key).replace(re,"$&/")+"/")+q)),ue.push(et)),1;if(Tt=0,Ge=Ge===""?".":Ge+":",R(q))for(var dt=0;dt<q.length;dt++){tt=q[dt];var vt=Ge+ie(tt,dt);Tt+=me(tt,ue,we,vt,et)}else if(vt=p(q),typeof vt=="function")for(q=vt.call(q),dt=0;!(tt=q.next()).done;)tt=tt.value,vt=Ge+ie(tt,dt++),Tt+=me(tt,ue,we,vt,et);else if(tt==="object")throw ue=String(q),Error("Objects are not valid as a React child (found: "+(ue==="[object Object]"?"object with keys {"+Object.keys(q).join(", ")+"}":ue)+"). If you meant to render a collection of children, use an array instead.");return Tt}function ge(q,ue,we){if(q==null)return q;var Ge=[],et=0;return me(q,Ge,"","",function(tt){return ue.call(we,tt,et++)}),Ge}function ve(q){if(q._status===-1){var ue=q._result;ue=ue(),ue.then(function(we){(q._status===0||q._status===-1)&&(q._status=1,q._result=we)},function(we){(q._status===0||q._status===-1)&&(q._status=2,q._result=we)}),q._status===-1&&(q._status=0,q._result=ue)}if(q._status===1)return q._result.default;throw q._result}var $e={current:null},fe={transition:null},xe={ReactCurrentDispatcher:$e,ReactCurrentBatchConfig:fe,ReactCurrentOwner:O};function ae(){throw Error("act(...) is not supported in production builds of React.")}return xt.Children={map:ge,forEach:function(q,ue,we){ge(q,function(){ue.apply(this,arguments)},we)},count:function(q){var ue=0;return ge(q,function(){ue++}),ue},toArray:function(q){return ge(q,function(ue){return ue})||[]},only:function(q){if(!V(q))throw Error("React.Children.only expected to receive a single React element child.");return q}},xt.Component=w,xt.Fragment=n,xt.Profiler=s,xt.PureComponent=$,xt.StrictMode=r,xt.Suspense=l,xt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=xe,xt.act=ae,xt.cloneElement=function(q,ue,we){if(q==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+q+".");var Ge=y({},q.props),et=q.key,tt=q.ref,Tt=q._owner;if(ue!=null){if(ue.ref!==void 0&&(tt=ue.ref,Tt=O.current),ue.key!==void 0&&(et=""+ue.key),q.type&&q.type.defaultProps)var dt=q.type.defaultProps;for(vt in ue)_.call(ue,vt)&&!F.hasOwnProperty(vt)&&(Ge[vt]=ue[vt]===void 0&&dt!==void 0?dt[vt]:ue[vt])}var vt=arguments.length-2;if(vt===1)Ge.children=we;else if(1<vt){dt=Array(vt);for(var rn=0;rn<vt;rn++)dt[rn]=arguments[rn+2];Ge.children=dt}return{$$typeof:t,type:q.type,key:et,ref:tt,props:Ge,_owner:Tt}},xt.createContext=function(q){return q={$$typeof:i,_currentValue:q,_currentValue2:q,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},q.Provider={$$typeof:o,_context:q},q.Consumer=q},xt.createElement=B,xt.createFactory=function(q){var ue=B.bind(null,q);return ue.type=q,ue},xt.createRef=function(){return{current:null}},xt.forwardRef=function(q){return{$$typeof:a,render:q}},xt.isValidElement=V,xt.lazy=function(q){return{$$typeof:d,_payload:{_status:-1,_result:q},_init:ve}},xt.memo=function(q,ue){return{$$typeof:c,type:q,compare:ue===void 0?null:ue}},xt.startTransition=function(q){var ue=fe.transition;fe.transition={};try{q()}finally{fe.transition=ue}},xt.unstable_act=ae,xt.useCallback=function(q,ue){return $e.current.useCallback(q,ue)},xt.useContext=function(q){return $e.current.useContext(q)},xt.useDebugValue=function(){},xt.useDeferredValue=function(q){return $e.current.useDeferredValue(q)},xt.useEffect=function(q,ue){return $e.current.useEffect(q,ue)},xt.useId=function(){return $e.current.useId()},xt.useImperativeHandle=function(q,ue,we){return $e.current.useImperativeHandle(q,ue,we)},xt.useInsertionEffect=function(q,ue){return $e.current.useInsertionEffect(q,ue)},xt.useLayoutEffect=function(q,ue){return $e.current.useLayoutEffect(q,ue)},xt.useMemo=function(q,ue){return $e.current.useMemo(q,ue)},xt.useReducer=function(q,ue,we){return $e.current.useReducer(q,ue,we)},xt.useRef=function(q){return $e.current.useRef(q)},xt.useState=function(q){return $e.current.useState(q)},xt.useSyncExternalStore=function(q,ue,we){return $e.current.useSyncExternalStore(q,ue,we)},xt.useTransition=function(){return $e.current.useTransition()},xt.version="18.3.1",xt}var Gk;function Wv(){return Gk||(Gk=1,n1.exports=sL()),n1.exports}/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Hk;function oL(){if(Hk)return ph;Hk=1;var t=Wv(),e=Symbol.for("react.element"),n=Symbol.for("react.fragment"),r=Object.prototype.hasOwnProperty,s=t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,o={key:!0,ref:!0,__self:!0,__source:!0};function i(a,l,c){var d,f={},p=null,g=null;c!==void 0&&(p=""+c),l.key!==void 0&&(p=""+l.key),l.ref!==void 0&&(g=l.ref);for(d in l)r.call(l,d)&&!o.hasOwnProperty(d)&&(f[d]=l[d]);if(a&&a.defaultProps)for(d in l=a.defaultProps,l)f[d]===void 0&&(f[d]=l[d]);return{$$typeof:e,type:a,key:p,ref:g,props:f,_owner:s.current}}return ph.Fragment=n,ph.jsx=i,ph.jsxs=i,ph}var Kk;function iL(){return Kk||(Kk=1,t1.exports=oL()),t1.exports}var K=iL(),J=Wv();const sa=Af(J),Xk=FE({__proto__:null,default:sa},[J]);var sm={},r1={exports:{}},as={},s1={exports:{}},o1={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var qk;function aL(){return qk||(qk=1,function(t){function e(fe,xe){var ae=fe.length;fe.push(xe);e:for(;0<ae;){var q=ae-1>>>1,ue=fe[q];if(0<s(ue,xe))fe[q]=xe,fe[ae]=ue,ae=q;else break e}}function n(fe){return fe.length===0?null:fe[0]}function r(fe){if(fe.length===0)return null;var xe=fe[0],ae=fe.pop();if(ae!==xe){fe[0]=ae;e:for(var q=0,ue=fe.length,we=ue>>>1;q<we;){var Ge=2*(q+1)-1,et=fe[Ge],tt=Ge+1,Tt=fe[tt];if(0>s(et,ae))tt<ue&&0>s(Tt,et)?(fe[q]=Tt,fe[tt]=ae,q=tt):(fe[q]=et,fe[Ge]=ae,q=Ge);else if(tt<ue&&0>s(Tt,ae))fe[q]=Tt,fe[tt]=ae,q=tt;else break e}}return xe}function s(fe,xe){var ae=fe.sortIndex-xe.sortIndex;return ae!==0?ae:fe.id-xe.id}if(typeof performance=="object"&&typeof performance.now=="function"){var o=performance;t.unstable_now=function(){return o.now()}}else{var i=Date,a=i.now();t.unstable_now=function(){return i.now()-a}}var l=[],c=[],d=1,f=null,p=3,g=!1,y=!1,x=!1,w=typeof setTimeout=="function"?setTimeout:null,S=typeof clearTimeout=="function"?clearTimeout:null,$=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function I(fe){for(var xe=n(c);xe!==null;){if(xe.callback===null)r(c);else if(xe.startTime<=fe)r(c),xe.sortIndex=xe.expirationTime,e(l,xe);else break;xe=n(c)}}function R(fe){if(x=!1,I(fe),!y)if(n(l)!==null)y=!0,ve(_);else{var xe=n(c);xe!==null&&$e(R,xe.startTime-fe)}}function _(fe,xe){y=!1,x&&(x=!1,S(B),B=-1),g=!0;var ae=p;try{for(I(xe),f=n(l);f!==null&&(!(f.expirationTime>xe)||fe&&!P());){var q=f.callback;if(typeof q=="function"){f.callback=null,p=f.priorityLevel;var ue=q(f.expirationTime<=xe);xe=t.unstable_now(),typeof ue=="function"?f.callback=ue:f===n(l)&&r(l),I(xe)}else r(l);f=n(l)}if(f!==null)var we=!0;else{var Ge=n(c);Ge!==null&&$e(R,Ge.startTime-xe),we=!1}return we}finally{f=null,p=ae,g=!1}}var O=!1,F=null,B=-1,M=5,V=-1;function P(){return!(t.unstable_now()-V<M)}function re(){if(F!==null){var fe=t.unstable_now();V=fe;var xe=!0;try{xe=F(!0,fe)}finally{xe?ie():(O=!1,F=null)}}else O=!1}var ie;if(typeof $=="function")ie=function(){$(re)};else if(typeof MessageChannel<"u"){var me=new MessageChannel,ge=me.port2;me.port1.onmessage=re,ie=function(){ge.postMessage(null)}}else ie=function(){w(re,0)};function ve(fe){F=fe,O||(O=!0,ie())}function $e(fe,xe){B=w(function(){fe(t.unstable_now())},xe)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(fe){fe.callback=null},t.unstable_continueExecution=function(){y||g||(y=!0,ve(_))},t.unstable_forceFrameRate=function(fe){0>fe||125<fe?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):M=0<fe?Math.floor(1e3/fe):5},t.unstable_getCurrentPriorityLevel=function(){return p},t.unstable_getFirstCallbackNode=function(){return n(l)},t.unstable_next=function(fe){switch(p){case 1:case 2:case 3:var xe=3;break;default:xe=p}var ae=p;p=xe;try{return fe()}finally{p=ae}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(fe,xe){switch(fe){case 1:case 2:case 3:case 4:case 5:break;default:fe=3}var ae=p;p=fe;try{return xe()}finally{p=ae}},t.unstable_scheduleCallback=function(fe,xe,ae){var q=t.unstable_now();switch(typeof ae=="object"&&ae!==null?(ae=ae.delay,ae=typeof ae=="number"&&0<ae?q+ae:q):ae=q,fe){case 1:var ue=-1;break;case 2:ue=250;break;case 5:ue=1073741823;break;case 4:ue=1e4;break;default:ue=5e3}return ue=ae+ue,fe={id:d++,callback:xe,priorityLevel:fe,startTime:ae,expirationTime:ue,sortIndex:-1},ae>q?(fe.sortIndex=ae,e(c,fe),n(l)===null&&fe===n(c)&&(x?(S(B),B=-1):x=!0,$e(R,ae-q))):(fe.sortIndex=ue,e(l,fe),y||g||(y=!0,ve(_))),fe},t.unstable_shouldYield=P,t.unstable_wrapCallback=function(fe){var xe=p;return function(){var ae=p;p=xe;try{return fe.apply(this,arguments)}finally{p=ae}}}}(o1)),o1}var Yk;function lL(){return Yk||(Yk=1,s1.exports=aL()),s1.exports}/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Qk;function uL(){if(Qk)return as;Qk=1;var t=Wv(),e=lL();function n(u){for(var h="https://reactjs.org/docs/error-decoder.html?invariant="+u,m=1;m<arguments.length;m++)h+="&args[]="+encodeURIComponent(arguments[m]);return"Minified React error #"+u+"; visit "+h+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var r=new Set,s={};function o(u,h){i(u,h),i(u+"Capture",h)}function i(u,h){for(s[u]=h,u=0;u<h.length;u++)r.add(h[u])}var a=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),l=Object.prototype.hasOwnProperty,c=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,d={},f={};function p(u){return l.call(f,u)?!0:l.call(d,u)?!1:c.test(u)?f[u]=!0:(d[u]=!0,!1)}function g(u,h,m,b){if(m!==null&&m.type===0)return!1;switch(typeof h){case"function":case"symbol":return!0;case"boolean":return b?!1:m!==null?!m.acceptsBooleans:(u=u.toLowerCase().slice(0,5),u!=="data-"&&u!=="aria-");default:return!1}}function y(u,h,m,b){if(h===null||typeof h>"u"||g(u,h,m,b))return!0;if(b)return!1;if(m!==null)switch(m.type){case 3:return!h;case 4:return h===!1;case 5:return isNaN(h);case 6:return isNaN(h)||1>h}return!1}function x(u,h,m,b,C,T,D){this.acceptsBooleans=h===2||h===3||h===4,this.attributeName=b,this.attributeNamespace=C,this.mustUseProperty=m,this.propertyName=u,this.type=h,this.sanitizeURL=T,this.removeEmptyString=D}var w={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(u){w[u]=new x(u,0,!1,u,null,!1,!1)}),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(u){var h=u[0];w[h]=new x(h,1,!1,u[1],null,!1,!1)}),["contentEditable","draggable","spellCheck","value"].forEach(function(u){w[u]=new x(u,2,!1,u.toLowerCase(),null,!1,!1)}),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(u){w[u]=new x(u,2,!1,u,null,!1,!1)}),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(u){w[u]=new x(u,3,!1,u.toLowerCase(),null,!1,!1)}),["checked","multiple","muted","selected"].forEach(function(u){w[u]=new x(u,3,!0,u,null,!1,!1)}),["capture","download"].forEach(function(u){w[u]=new x(u,4,!1,u,null,!1,!1)}),["cols","rows","size","span"].forEach(function(u){w[u]=new x(u,6,!1,u,null,!1,!1)}),["rowSpan","start"].forEach(function(u){w[u]=new x(u,5,!1,u.toLowerCase(),null,!1,!1)});var S=/[\-:]([a-z])/g;function $(u){return u[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(u){var h=u.replace(S,$);w[h]=new x(h,1,!1,u,null,!1,!1)}),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(u){var h=u.replace(S,$);w[h]=new x(h,1,!1,u,"http://www.w3.org/1999/xlink",!1,!1)}),["xml:base","xml:lang","xml:space"].forEach(function(u){var h=u.replace(S,$);w[h]=new x(h,1,!1,u,"http://www.w3.org/XML/1998/namespace",!1,!1)}),["tabIndex","crossOrigin"].forEach(function(u){w[u]=new x(u,1,!1,u.toLowerCase(),null,!1,!1)}),w.xlinkHref=new x("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach(function(u){w[u]=new x(u,1,!1,u.toLowerCase(),null,!0,!0)});function I(u,h,m,b){var C=w.hasOwnProperty(h)?w[h]:null;(C!==null?C.type!==0:b||!(2<h.length)||h[0]!=="o"&&h[0]!=="O"||h[1]!=="n"&&h[1]!=="N")&&(y(h,m,C,b)&&(m=null),b||C===null?p(h)&&(m===null?u.removeAttribute(h):u.setAttribute(h,""+m)):C.mustUseProperty?u[C.propertyName]=m===null?C.type===3?!1:"":m:(h=C.attributeName,b=C.attributeNamespace,m===null?u.removeAttribute(h):(C=C.type,m=C===3||C===4&&m===!0?"":""+m,b?u.setAttributeNS(b,h,m):u.setAttribute(h,m))))}var R=t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,_=Symbol.for("react.element"),O=Symbol.for("react.portal"),F=Symbol.for("react.fragment"),B=Symbol.for("react.strict_mode"),M=Symbol.for("react.profiler"),V=Symbol.for("react.provider"),P=Symbol.for("react.context"),re=Symbol.for("react.forward_ref"),ie=Symbol.for("react.suspense"),me=Symbol.for("react.suspense_list"),ge=Symbol.for("react.memo"),ve=Symbol.for("react.lazy"),$e=Symbol.for("react.offscreen"),fe=Symbol.iterator;function xe(u){return u===null||typeof u!="object"?null:(u=fe&&u[fe]||u["@@iterator"],typeof u=="function"?u:null)}var ae=Object.assign,q;function ue(u){if(q===void 0)try{throw Error()}catch(m){var h=m.stack.trim().match(/\n( *(at )?)/);q=h&&h[1]||""}return`
`+q+u}var we=!1;function Ge(u,h){if(!u||we)return"";we=!0;var m=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(h)if(h=function(){throw Error()},Object.defineProperty(h.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(h,[])}catch(de){var b=de}Reflect.construct(u,[],h)}else{try{h.call()}catch(de){b=de}u.call(h.prototype)}else{try{throw Error()}catch(de){b=de}u()}}catch(de){if(de&&b&&typeof de.stack=="string"){for(var C=de.stack.split(`
`),T=b.stack.split(`
`),D=C.length-1,H=T.length-1;1<=D&&0<=H&&C[D]!==T[H];)H--;for(;1<=D&&0<=H;D--,H--)if(C[D]!==T[H]){if(D!==1||H!==1)do if(D--,H--,0>H||C[D]!==T[H]){var Q=`
`+C[D].replace(" at new "," at ");return u.displayName&&Q.includes("<anonymous>")&&(Q=Q.replace("<anonymous>",u.displayName)),Q}while(1<=D&&0<=H);break}}}finally{we=!1,Error.prepareStackTrace=m}return(u=u?u.displayName||u.name:"")?ue(u):""}function et(u){switch(u.tag){case 5:return ue(u.type);case 16:return ue("Lazy");case 13:return ue("Suspense");case 19:return ue("SuspenseList");case 0:case 2:case 15:return u=Ge(u.type,!1),u;case 11:return u=Ge(u.type.render,!1),u;case 1:return u=Ge(u.type,!0),u;default:return""}}function tt(u){if(u==null)return null;if(typeof u=="function")return u.displayName||u.name||null;if(typeof u=="string")return u;switch(u){case F:return"Fragment";case O:return"Portal";case M:return"Profiler";case B:return"StrictMode";case ie:return"Suspense";case me:return"SuspenseList"}if(typeof u=="object")switch(u.$$typeof){case P:return(u.displayName||"Context")+".Consumer";case V:return(u._context.displayName||"Context")+".Provider";case re:var h=u.render;return u=u.displayName,u||(u=h.displayName||h.name||"",u=u!==""?"ForwardRef("+u+")":"ForwardRef"),u;case ge:return h=u.displayName||null,h!==null?h:tt(u.type)||"Memo";case ve:h=u._payload,u=u._init;try{return tt(u(h))}catch{}}return null}function Tt(u){var h=u.type;switch(u.tag){case 24:return"Cache";case 9:return(h.displayName||"Context")+".Consumer";case 10:return(h._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return u=h.render,u=u.displayName||u.name||"",h.displayName||(u!==""?"ForwardRef("+u+")":"ForwardRef");case 7:return"Fragment";case 5:return h;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return tt(h);case 8:return h===B?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof h=="function")return h.displayName||h.name||null;if(typeof h=="string")return h}return null}function dt(u){switch(typeof u){case"boolean":case"number":case"string":case"undefined":return u;case"object":return u;default:return""}}function vt(u){var h=u.type;return(u=u.nodeName)&&u.toLowerCase()==="input"&&(h==="checkbox"||h==="radio")}function rn(u){var h=vt(u)?"checked":"value",m=Object.getOwnPropertyDescriptor(u.constructor.prototype,h),b=""+u[h];if(!u.hasOwnProperty(h)&&typeof m<"u"&&typeof m.get=="function"&&typeof m.set=="function"){var C=m.get,T=m.set;return Object.defineProperty(u,h,{configurable:!0,get:function(){return C.call(this)},set:function(D){b=""+D,T.call(this,D)}}),Object.defineProperty(u,h,{enumerable:m.enumerable}),{getValue:function(){return b},setValue:function(D){b=""+D},stopTracking:function(){u._valueTracker=null,delete u[h]}}}}function Rr(u){u._valueTracker||(u._valueTracker=rn(u))}function ki(u){if(!u)return!1;var h=u._valueTracker;if(!h)return!0;var m=h.getValue(),b="";return u&&(b=vt(u)?u.checked?"true":"false":u.value),u=b,u!==m?(h.setValue(u),!0):!1}function zt(u){if(u=u||(typeof document<"u"?document:void 0),typeof u>"u")return null;try{return u.activeElement||u.body}catch{return u.body}}function sn(u,h){var m=h.checked;return ae({},h,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:m??u._wrapperState.initialChecked})}function _r(u,h){var m=h.defaultValue==null?"":h.defaultValue,b=h.checked!=null?h.checked:h.defaultChecked;m=dt(h.value!=null?h.value:m),u._wrapperState={initialChecked:b,initialValue:m,controlled:h.type==="checkbox"||h.type==="radio"?h.checked!=null:h.value!=null}}function Vo(u,h){h=h.checked,h!=null&&I(u,"checked",h,!1)}function Ia(u,h){Vo(u,h);var m=dt(h.value),b=h.type;if(m!=null)b==="number"?(m===0&&u.value===""||u.value!=m)&&(u.value=""+m):u.value!==""+m&&(u.value=""+m);else if(b==="submit"||b==="reset"){u.removeAttribute("value");return}h.hasOwnProperty("value")?Na(u,h.type,m):h.hasOwnProperty("defaultValue")&&Na(u,h.type,dt(h.defaultValue)),h.checked==null&&h.defaultChecked!=null&&(u.defaultChecked=!!h.defaultChecked)}function El(u,h,m){if(h.hasOwnProperty("value")||h.hasOwnProperty("defaultValue")){var b=h.type;if(!(b!=="submit"&&b!=="reset"||h.value!==void 0&&h.value!==null))return;h=""+u._wrapperState.initialValue,m||h===u.value||(u.value=h),u.defaultValue=h}m=u.name,m!==""&&(u.name=""),u.defaultChecked=!!u._wrapperState.initialChecked,m!==""&&(u.name=m)}function Na(u,h,m){(h!=="number"||zt(u.ownerDocument)!==u)&&(m==null?u.defaultValue=""+u._wrapperState.initialValue:u.defaultValue!==""+m&&(u.defaultValue=""+m))}var bs=Array.isArray;function ws(u,h,m,b){if(u=u.options,h){h={};for(var C=0;C<m.length;C++)h["$"+m[C]]=!0;for(m=0;m<u.length;m++)C=h.hasOwnProperty("$"+u[m].value),u[m].selected!==C&&(u[m].selected=C),C&&b&&(u[m].defaultSelected=!0)}else{for(m=""+dt(m),h=null,C=0;C<u.length;C++){if(u[C].value===m){u[C].selected=!0,b&&(u[C].defaultSelected=!0);return}h!==null||u[C].disabled||(h=u[C])}h!==null&&(h.selected=!0)}}function zs(u,h){if(h.dangerouslySetInnerHTML!=null)throw Error(n(91));return ae({},h,{value:void 0,defaultValue:void 0,children:""+u._wrapperState.initialValue})}function Xr(u,h){var m=h.value;if(m==null){if(m=h.children,h=h.defaultValue,m!=null){if(h!=null)throw Error(n(92));if(bs(m)){if(1<m.length)throw Error(n(93));m=m[0]}h=m}h==null&&(h=""),m=h}u._wrapperState={initialValue:dt(m)}}function Ss(u,h){var m=dt(h.value),b=dt(h.defaultValue);m!=null&&(m=""+m,m!==u.value&&(u.value=m),h.defaultValue==null&&u.defaultValue!==m&&(u.defaultValue=m)),b!=null&&(u.defaultValue=""+b)}function Ea(u){var h=u.textContent;h===u._wrapperState.initialValue&&h!==""&&h!==null&&(u.value=h)}function Ti(u){switch(u){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Ii(u,h){return u==null||u==="http://www.w3.org/1999/xhtml"?Ti(h):u==="http://www.w3.org/2000/svg"&&h==="foreignObject"?"http://www.w3.org/1999/xhtml":u}var go,Ra=function(u){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(h,m,b,C){MSApp.execUnsafeLocalFunction(function(){return u(h,m,b,C)})}:u}(function(u,h){if(u.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in u)u.innerHTML=h;else{for(go=go||document.createElement("div"),go.innerHTML="<svg>"+h.valueOf().toString()+"</svg>",h=go.firstChild;u.firstChild;)u.removeChild(u.firstChild);for(;h.firstChild;)u.appendChild(h.firstChild)}});function Wo(u,h){if(h){var m=u.firstChild;if(m&&m===u.lastChild&&m.nodeType===3){m.nodeValue=h;return}}u.textContent=h}var yo={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Rl=["Webkit","ms","Moz","O"];Object.keys(yo).forEach(function(u){Rl.forEach(function(h){h=h+u.charAt(0).toUpperCase()+u.substring(1),yo[h]=yo[u]})});function Uo(u,h,m){return h==null||typeof h=="boolean"||h===""?"":m||typeof h!="number"||h===0||yo.hasOwnProperty(u)&&yo[u]?(""+h).trim():h+"px"}function _a(u,h){u=u.style;for(var m in h)if(h.hasOwnProperty(m)){var b=m.indexOf("--")===0,C=Uo(m,h[m],b);m==="float"&&(m="cssFloat"),b?u.setProperty(m,C):u[m]=C}}var Bs=ae({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function jo(u,h){if(h){if(Bs[u]&&(h.children!=null||h.dangerouslySetInnerHTML!=null))throw Error(n(137,u));if(h.dangerouslySetInnerHTML!=null){if(h.children!=null)throw Error(n(60));if(typeof h.dangerouslySetInnerHTML!="object"||!("__html"in h.dangerouslySetInnerHTML))throw Error(n(61))}if(h.style!=null&&typeof h.style!="object")throw Error(n(62))}}function Pa(u,h){if(u.indexOf("-")===-1)return typeof h.is=="string";switch(u){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Go=null;function Cs(u){return u=u.target||u.srcElement||window,u.correspondingUseElement&&(u=u.correspondingUseElement),u.nodeType===3?u.parentNode:u}var Ms=null,Pr=null,xo=null;function qr(u){if(u=Jd(u)){if(typeof Ms!="function")throw Error(n(280));var h=u.stateNode;h&&(h=vp(h),Ms(u.stateNode,u.type,h))}}function _l(u){Pr?xo?xo.push(u):xo=[u]:Pr=u}function Vs(){if(Pr){var u=Pr,h=xo;if(xo=Pr=null,qr(u),h)for(u=0;u<h.length;u++)qr(h[u])}}function Aa(u,h){return u(h)}function Pl(){}var Ho=!1;function Jn(u,h,m){if(Ho)return u(h,m);Ho=!0;try{return Aa(u,h,m)}finally{Ho=!1,(Pr!==null||xo!==null)&&(Pl(),Vs())}}function Ni(u,h){var m=u.stateNode;if(m===null)return null;var b=vp(m);if(b===null)return null;m=b[h];e:switch(h){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(b=!b.disabled)||(u=u.type,b=!(u==="button"||u==="input"||u==="select"||u==="textarea")),u=!b;break e;default:u=!1}if(u)return null;if(m&&typeof m!="function")throw Error(n(231,h,typeof m));return m}var Ws=!1;if(a)try{var Ei={};Object.defineProperty(Ei,"passive",{get:function(){Ws=!0}}),window.addEventListener("test",Ei,Ei),window.removeEventListener("test",Ei,Ei)}catch{Ws=!1}function $s(u,h,m,b,C,T,D,H,Q){var de=Array.prototype.slice.call(arguments,3);try{h.apply(m,de)}catch(Se){this.onError(Se)}}var Ar=!1,Yr=null,Xt=!1,dr=null,Al={onError:function(u){Ar=!0,Yr=u}};function zd(u,h,m,b,C,T,D,H,Q){Ar=!1,Yr=null,$s.apply(Al,arguments)}function Da(u,h,m,b,C,T,D,H,Q){if(zd.apply(this,arguments),Ar){if(Ar){var de=Yr;Ar=!1,Yr=null}else throw Error(n(198));Xt||(Xt=!0,dr=de)}}function Bn(u){var h=u,m=u;if(u.alternate)for(;h.return;)h=h.return;else{u=h;do h=u,(h.flags&4098)!==0&&(m=h.return),u=h.return;while(u)}return h.tag===3?m:null}function Ri(u){if(u.tag===13){var h=u.memoizedState;if(h===null&&(u=u.alternate,u!==null&&(h=u.memoizedState)),h!==null)return h.dehydrated}return null}function Ko(u){if(Bn(u)!==u)throw Error(n(188))}function qu(u){var h=u.alternate;if(!h){if(h=Bn(u),h===null)throw Error(n(188));return h!==u?null:u}for(var m=u,b=h;;){var C=m.return;if(C===null)break;var T=C.alternate;if(T===null){if(b=C.return,b!==null){m=b;continue}break}if(C.child===T.child){for(T=C.child;T;){if(T===m)return Ko(C),u;if(T===b)return Ko(C),h;T=T.sibling}throw Error(n(188))}if(m.return!==b.return)m=C,b=T;else{for(var D=!1,H=C.child;H;){if(H===m){D=!0,m=C,b=T;break}if(H===b){D=!0,b=C,m=T;break}H=H.sibling}if(!D){for(H=T.child;H;){if(H===m){D=!0,m=T,b=C;break}if(H===b){D=!0,b=T,m=C;break}H=H.sibling}if(!D)throw Error(n(189))}}if(m.alternate!==b)throw Error(n(190))}if(m.tag!==3)throw Error(n(188));return m.stateNode.current===m?u:h}function Oa(u){return u=qu(u),u!==null?Fa(u):null}function Fa(u){if(u.tag===5||u.tag===6)return u;for(u=u.child;u!==null;){var h=Fa(u);if(h!==null)return h;u=u.sibling}return null}var Dl=e.unstable_scheduleCallback,Mn=e.unstable_cancelCallback,Qr=e.unstable_shouldYield,Us=e.unstable_requestPaint,Ut=e.unstable_now,Ol=e.unstable_getCurrentPriorityLevel,vo=e.unstable_ImmediatePriority,_i=e.unstable_UserBlockingPriority,er=e.unstable_NormalPriority,Yu=e.unstable_LowPriority,Pi=e.unstable_IdlePriority,Vn=null,tr=null;function Bd(u){if(tr&&typeof tr.onCommitFiberRoot=="function")try{tr.onCommitFiberRoot(Vn,u,void 0,(u.current.flags&128)===128)}catch{}}var hr=Math.clz32?Math.clz32:Vd,Fl=Math.log,Md=Math.LN2;function Vd(u){return u>>>=0,u===0?32:31-(Fl(u)/Md|0)|0}var Ai=64,Di=4194304;function Xo(u){switch(u&-u){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return u&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return u&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return u}}function Oi(u,h){var m=u.pendingLanes;if(m===0)return 0;var b=0,C=u.suspendedLanes,T=u.pingedLanes,D=m&268435455;if(D!==0){var H=D&~C;H!==0?b=Xo(H):(T&=D,T!==0&&(b=Xo(T)))}else D=m&~C,D!==0?b=Xo(D):T!==0&&(b=Xo(T));if(b===0)return 0;if(h!==0&&h!==b&&(h&C)===0&&(C=b&-b,T=h&-h,C>=T||C===16&&(T&4194240)!==0))return h;if((b&4)!==0&&(b|=m&16),h=u.entangledLanes,h!==0)for(u=u.entanglements,h&=b;0<h;)m=31-hr(h),C=1<<m,b|=u[m],h&=~C;return b}function wn(u,h){switch(u){case 1:case 2:case 4:return h+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return h+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function La(u,h){for(var m=u.suspendedLanes,b=u.pingedLanes,C=u.expirationTimes,T=u.pendingLanes;0<T;){var D=31-hr(T),H=1<<D,Q=C[D];Q===-1?((H&m)===0||(H&b)!==0)&&(C[D]=wn(H,h)):Q<=h&&(u.expiredLanes|=H),T&=~H}}function za(u){return u=u.pendingLanes&-1073741825,u!==0?u:u&1073741824?1073741824:0}function Fi(){var u=Ai;return Ai<<=1,(Ai&4194240)===0&&(Ai=64),u}function Li(u){for(var h=[],m=0;31>m;m++)h.push(u);return h}function qo(u,h,m){u.pendingLanes|=h,h!==536870912&&(u.suspendedLanes=0,u.pingedLanes=0),u=u.eventTimes,h=31-hr(h),u[h]=m}function Wd(u,h){var m=u.pendingLanes&~h;u.pendingLanes=h,u.suspendedLanes=0,u.pingedLanes=0,u.expiredLanes&=h,u.mutableReadLanes&=h,u.entangledLanes&=h,h=u.entanglements;var b=u.eventTimes;for(u=u.expirationTimes;0<m;){var C=31-hr(m),T=1<<C;h[C]=0,b[C]=-1,u[C]=-1,m&=~T}}function Ll(u,h){var m=u.entangledLanes|=h;for(u=u.entanglements;m;){var b=31-hr(m),C=1<<b;C&h|u[b]&h&&(u[b]|=h),m&=~C}}var St=0;function zl(u){return u&=-u,1<u?4<u?(u&268435455)!==0?16:536870912:4:1}var zi,Ba,Bi,Yo,Qu,Bl=!1,bo=[],Zr=null,fr=null,Wn=null,Mi=new Map,Qo=new Map,Jr=[],Zu="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function es(u,h){switch(u){case"focusin":case"focusout":Zr=null;break;case"dragenter":case"dragleave":fr=null;break;case"mouseover":case"mouseout":Wn=null;break;case"pointerover":case"pointerout":Mi.delete(h.pointerId);break;case"gotpointercapture":case"lostpointercapture":Qo.delete(h.pointerId)}}function ts(u,h,m,b,C,T){return u===null||u.nativeEvent!==T?(u={blockedOn:h,domEventName:m,eventSystemFlags:b,nativeEvent:T,targetContainers:[C]},h!==null&&(h=Jd(h),h!==null&&Ba(h)),u):(u.eventSystemFlags|=b,h=u.targetContainers,C!==null&&h.indexOf(C)===-1&&h.push(C),u)}function Ju(u,h,m,b,C){switch(h){case"focusin":return Zr=ts(Zr,u,h,m,b,C),!0;case"dragenter":return fr=ts(fr,u,h,m,b,C),!0;case"mouseover":return Wn=ts(Wn,u,h,m,b,C),!0;case"pointerover":var T=C.pointerId;return Mi.set(T,ts(Mi.get(T)||null,u,h,m,b,C)),!0;case"gotpointercapture":return T=C.pointerId,Qo.set(T,ts(Qo.get(T)||null,u,h,m,b,C)),!0}return!1}function wo(u){var h=Gl(u.target);if(h!==null){var m=Bn(h);if(m!==null){if(h=m.tag,h===13){if(h=Ri(m),h!==null){u.blockedOn=h,Qu(u.priority,function(){Bi(m)});return}}else if(h===3&&m.stateNode.current.memoizedState.isDehydrated){u.blockedOn=m.tag===3?m.stateNode.containerInfo:null;return}}}u.blockedOn=null}function Un(u){if(u.blockedOn!==null)return!1;for(var h=u.targetContainers;0<h.length;){var m=It(u.domEventName,u.eventSystemFlags,h[0],u.nativeEvent);if(m===null){m=u.nativeEvent;var b=new m.constructor(m.type,m);Go=b,m.target.dispatchEvent(b),Go=null}else return h=Jd(m),h!==null&&Ba(h),u.blockedOn=m,!1;h.shift()}return!0}function Ml(u,h,m){Un(u)&&m.delete(h)}function Ud(){Bl=!1,Zr!==null&&Un(Zr)&&(Zr=null),fr!==null&&Un(fr)&&(fr=null),Wn!==null&&Un(Wn)&&(Wn=null),Mi.forEach(Ml),Qo.forEach(Ml)}function Zo(u,h){u.blockedOn===h&&(u.blockedOn=null,Bl||(Bl=!0,e.unstable_scheduleCallback(e.unstable_NormalPriority,Ud)))}function So(u){function h(C){return Zo(C,u)}if(0<bo.length){Zo(bo[0],u);for(var m=1;m<bo.length;m++){var b=bo[m];b.blockedOn===u&&(b.blockedOn=null)}}for(Zr!==null&&Zo(Zr,u),fr!==null&&Zo(fr,u),Wn!==null&&Zo(Wn,u),Mi.forEach(h),Qo.forEach(h),m=0;m<Jr.length;m++)b=Jr[m],b.blockedOn===u&&(b.blockedOn=null);for(;0<Jr.length&&(m=Jr[0],m.blockedOn===null);)wo(m),m.blockedOn===null&&Jr.shift()}var js=R.ReactCurrentBatchConfig,U=!0;function ee(u,h,m,b){var C=St,T=js.transition;js.transition=null;try{St=1,Fe(u,h,m,b)}finally{St=C,js.transition=T}}function he(u,h,m,b){var C=St,T=js.transition;js.transition=null;try{St=4,Fe(u,h,m,b)}finally{St=C,js.transition=T}}function Fe(u,h,m,b){if(U){var C=It(u,h,m,b);if(C===null)Gy(u,h,b,ht,m),es(u,b);else if(Ju(C,u,h,m,b))b.stopPropagation();else if(es(u,b),h&4&&-1<Zu.indexOf(u)){for(;C!==null;){var T=Jd(C);if(T!==null&&zi(T),T=It(u,h,m,b),T===null&&Gy(u,h,b,ht,m),T===C)break;C=T}C!==null&&b.stopPropagation()}else Gy(u,h,b,null,m)}}var ht=null;function It(u,h,m,b){if(ht=null,u=Cs(b),u=Gl(u),u!==null)if(h=Bn(u),h===null)u=null;else if(m=h.tag,m===13){if(u=Ri(h),u!==null)return u;u=null}else if(m===3){if(h.stateNode.current.memoizedState.isDehydrated)return h.tag===3?h.stateNode.containerInfo:null;u=null}else h!==u&&(u=null);return ht=u,null}function Nt(u){switch(u){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Ol()){case vo:return 1;case _i:return 4;case er:case Yu:return 16;case Pi:return 536870912;default:return 16}default:return 16}}var at=null,_t=null,jn=null;function Gn(){if(jn)return jn;var u,h=_t,m=h.length,b,C="value"in at?at.value:at.textContent,T=C.length;for(u=0;u<m&&h[u]===C[u];u++);var D=m-u;for(b=1;b<=D&&h[m-b]===C[T-b];b++);return jn=C.slice(u,1<b?1-b:void 0)}function Dr(u){var h=u.keyCode;return"charCode"in u?(u=u.charCode,u===0&&h===13&&(u=13)):u=h,u===10&&(u=13),32<=u||u===13?u:0}function Co(){return!0}function Ma(){return!1}function Rn(u){function h(m,b,C,T,D){this._reactName=m,this._targetInst=C,this.type=b,this.nativeEvent=T,this.target=D,this.currentTarget=null;for(var H in u)u.hasOwnProperty(H)&&(m=u[H],this[H]=m?m(T):T[H]);return this.isDefaultPrevented=(T.defaultPrevented!=null?T.defaultPrevented:T.returnValue===!1)?Co:Ma,this.isPropagationStopped=Ma,this}return ae(h.prototype,{preventDefault:function(){this.defaultPrevented=!0;var m=this.nativeEvent;m&&(m.preventDefault?m.preventDefault():typeof m.returnValue!="unknown"&&(m.returnValue=!1),this.isDefaultPrevented=Co)},stopPropagation:function(){var m=this.nativeEvent;m&&(m.stopPropagation?m.stopPropagation():typeof m.cancelBubble!="unknown"&&(m.cancelBubble=!0),this.isPropagationStopped=Co)},persist:function(){},isPersistent:Co}),h}var Va={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(u){return u.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},jd=Rn(Va),Vi=ae({},Va,{view:0,detail:0}),Gd=Rn(Vi),ec,Hd,Vl,tc=ae({},Vi,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:k,button:0,buttons:0,relatedTarget:function(u){return u.relatedTarget===void 0?u.fromElement===u.srcElement?u.toElement:u.fromElement:u.relatedTarget},movementX:function(u){return"movementX"in u?u.movementX:(u!==Vl&&(Vl&&u.type==="mousemove"?(ec=u.screenX-Vl.screenX,Hd=u.screenY-Vl.screenY):Hd=ec=0,Vl=u),ec)},movementY:function(u){return"movementY"in u?u.movementY:Hd}}),op=Rn(tc),ip=ae({},tc,{dataTransfer:0}),Ny=Rn(ip),Ey=ae({},Vi,{relatedTarget:0}),Wl=Rn(Ey),Ry=ae({},Va,{animationName:0,elapsedTime:0,pseudoElement:0}),_y=Rn(Ry),Py=ae({},Va,{clipboardData:function(u){return"clipboardData"in u?u.clipboardData:window.clipboardData}}),nc=Rn(Py),Ay=ae({},Va,{data:0}),ap=Rn(Ay),Dy={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},lp={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},up={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function v(u){var h=this.nativeEvent;return h.getModifierState?h.getModifierState(u):(u=up[u])?!!h[u]:!1}function k(){return v}var E=ae({},Vi,{key:function(u){if(u.key){var h=Dy[u.key]||u.key;if(h!=="Unidentified")return h}return u.type==="keypress"?(u=Dr(u),u===13?"Enter":String.fromCharCode(u)):u.type==="keydown"||u.type==="keyup"?lp[u.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:k,charCode:function(u){return u.type==="keypress"?Dr(u):0},keyCode:function(u){return u.type==="keydown"||u.type==="keyup"?u.keyCode:0},which:function(u){return u.type==="keypress"?Dr(u):u.type==="keydown"||u.type==="keyup"?u.keyCode:0}}),A=Rn(E),W=ae({},tc,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),G=Rn(W),j=ae({},Vi,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:k}),Z=Rn(j),ce=ae({},Va,{propertyName:0,elapsedTime:0,pseudoElement:0}),Ce=Rn(ce),_e=ae({},tc,{deltaX:function(u){return"deltaX"in u?u.deltaX:"wheelDeltaX"in u?-u.wheelDeltaX:0},deltaY:function(u){return"deltaY"in u?u.deltaY:"wheelDeltaY"in u?-u.wheelDeltaY:"wheelDelta"in u?-u.wheelDelta:0},deltaZ:0,deltaMode:0}),Ze=Rn(_e),He=[9,13,27,32],Ae=a&&"CompositionEvent"in window,Ke=null;a&&"documentMode"in document&&(Ke=document.documentMode);var ft=a&&"TextEvent"in window&&!Ke,qt=a&&(!Ae||Ke&&8<Ke&&11>=Ke),jt=" ",Tn=!1;function Or(u,h){switch(u){case"keyup":return He.indexOf(h.keyCode)!==-1;case"keydown":return h.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function nr(u){return u=u.detail,typeof u=="object"&&"data"in u?u.data:null}var yt=!1;function _n(u,h){switch(u){case"compositionend":return nr(h);case"keypress":return h.which!==32?null:(Tn=!0,jt);case"textInput":return u=h.data,u===jt&&Tn?null:u;default:return null}}function Jo(u,h){if(yt)return u==="compositionend"||!Ae&&Or(u,h)?(u=Gn(),jn=_t=at=null,yt=!1,u):null;switch(u){case"paste":return null;case"keypress":if(!(h.ctrlKey||h.altKey||h.metaKey)||h.ctrlKey&&h.altKey){if(h.char&&1<h.char.length)return h.char;if(h.which)return String.fromCharCode(h.which)}return null;case"compositionend":return qt&&h.locale!=="ko"?null:h.data;default:return null}}var Oy={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function cp(u){var h=u&&u.nodeName&&u.nodeName.toLowerCase();return h==="input"?!!Oy[u.type]:h==="textarea"}function dp(u,h,m,b){_l(b),h=gp(h,"onChange"),0<h.length&&(m=new jd("onChange","change",null,m,b),u.push({event:m,listeners:h}))}var Ul=null,jl=null;function rc(u){i$(u,0)}function hp(u){var h=lc(u);if(ki(h))return u}function s4(u,h){if(u==="change")return h}var UC=!1;if(a){var Fy;if(a){var Ly="oninput"in document;if(!Ly){var jC=document.createElement("div");jC.setAttribute("oninput","return;"),Ly=typeof jC.oninput=="function"}Fy=Ly}else Fy=!1;UC=Fy&&(!document.documentMode||9<document.documentMode)}function GC(){Ul&&(Ul.detachEvent("onpropertychange",HC),jl=Ul=null)}function HC(u){if(u.propertyName==="value"&&hp(jl)){var h=[];dp(h,jl,u,Cs(u)),Jn(rc,h)}}function o4(u,h,m){u==="focusin"?(GC(),Ul=h,jl=m,Ul.attachEvent("onpropertychange",HC)):u==="focusout"&&GC()}function i4(u){if(u==="selectionchange"||u==="keyup"||u==="keydown")return hp(jl)}function a4(u,h){if(u==="click")return hp(h)}function l4(u,h){if(u==="input"||u==="change")return hp(h)}function u4(u,h){return u===h&&(u!==0||1/u===1/h)||u!==u&&h!==h}var $o=typeof Object.is=="function"?Object.is:u4;function Kd(u,h){if($o(u,h))return!0;if(typeof u!="object"||u===null||typeof h!="object"||h===null)return!1;var m=Object.keys(u),b=Object.keys(h);if(m.length!==b.length)return!1;for(b=0;b<m.length;b++){var C=m[b];if(!l.call(h,C)||!$o(u[C],h[C]))return!1}return!0}function KC(u){for(;u&&u.firstChild;)u=u.firstChild;return u}function XC(u,h){var m=KC(u);u=0;for(var b;m;){if(m.nodeType===3){if(b=u+m.textContent.length,u<=h&&b>=h)return{node:m,offset:h-u};u=b}e:{for(;m;){if(m.nextSibling){m=m.nextSibling;break e}m=m.parentNode}m=void 0}m=KC(m)}}function qC(u,h){return u&&h?u===h?!0:u&&u.nodeType===3?!1:h&&h.nodeType===3?qC(u,h.parentNode):"contains"in u?u.contains(h):u.compareDocumentPosition?!!(u.compareDocumentPosition(h)&16):!1:!1}function YC(){for(var u=window,h=zt();h instanceof u.HTMLIFrameElement;){try{var m=typeof h.contentWindow.location.href=="string"}catch{m=!1}if(m)u=h.contentWindow;else break;h=zt(u.document)}return h}function zy(u){var h=u&&u.nodeName&&u.nodeName.toLowerCase();return h&&(h==="input"&&(u.type==="text"||u.type==="search"||u.type==="tel"||u.type==="url"||u.type==="password")||h==="textarea"||u.contentEditable==="true")}function c4(u){var h=YC(),m=u.focusedElem,b=u.selectionRange;if(h!==m&&m&&m.ownerDocument&&qC(m.ownerDocument.documentElement,m)){if(b!==null&&zy(m)){if(h=b.start,u=b.end,u===void 0&&(u=h),"selectionStart"in m)m.selectionStart=h,m.selectionEnd=Math.min(u,m.value.length);else if(u=(h=m.ownerDocument||document)&&h.defaultView||window,u.getSelection){u=u.getSelection();var C=m.textContent.length,T=Math.min(b.start,C);b=b.end===void 0?T:Math.min(b.end,C),!u.extend&&T>b&&(C=b,b=T,T=C),C=XC(m,T);var D=XC(m,b);C&&D&&(u.rangeCount!==1||u.anchorNode!==C.node||u.anchorOffset!==C.offset||u.focusNode!==D.node||u.focusOffset!==D.offset)&&(h=h.createRange(),h.setStart(C.node,C.offset),u.removeAllRanges(),T>b?(u.addRange(h),u.extend(D.node,D.offset)):(h.setEnd(D.node,D.offset),u.addRange(h)))}}for(h=[],u=m;u=u.parentNode;)u.nodeType===1&&h.push({element:u,left:u.scrollLeft,top:u.scrollTop});for(typeof m.focus=="function"&&m.focus(),m=0;m<h.length;m++)u=h[m],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}}var d4=a&&"documentMode"in document&&11>=document.documentMode,sc=null,By=null,Xd=null,My=!1;function QC(u,h,m){var b=m.window===m?m.document:m.nodeType===9?m:m.ownerDocument;My||sc==null||sc!==zt(b)||(b=sc,"selectionStart"in b&&zy(b)?b={start:b.selectionStart,end:b.selectionEnd}:(b=(b.ownerDocument&&b.ownerDocument.defaultView||window).getSelection(),b={anchorNode:b.anchorNode,anchorOffset:b.anchorOffset,focusNode:b.focusNode,focusOffset:b.focusOffset}),Xd&&Kd(Xd,b)||(Xd=b,b=gp(By,"onSelect"),0<b.length&&(h=new jd("onSelect","select",null,h,m),u.push({event:h,listeners:b}),h.target=sc)))}function fp(u,h){var m={};return m[u.toLowerCase()]=h.toLowerCase(),m["Webkit"+u]="webkit"+h,m["Moz"+u]="moz"+h,m}var oc={animationend:fp("Animation","AnimationEnd"),animationiteration:fp("Animation","AnimationIteration"),animationstart:fp("Animation","AnimationStart"),transitionend:fp("Transition","TransitionEnd")},Vy={},ZC={};a&&(ZC=document.createElement("div").style,"AnimationEvent"in window||(delete oc.animationend.animation,delete oc.animationiteration.animation,delete oc.animationstart.animation),"TransitionEvent"in window||delete oc.transitionend.transition);function pp(u){if(Vy[u])return Vy[u];if(!oc[u])return u;var h=oc[u],m;for(m in h)if(h.hasOwnProperty(m)&&m in ZC)return Vy[u]=h[m];return u}var JC=pp("animationend"),e$=pp("animationiteration"),t$=pp("animationstart"),n$=pp("transitionend"),r$=new Map,s$="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Wa(u,h){r$.set(u,h),o(h,[u])}for(var Wy=0;Wy<s$.length;Wy++){var Uy=s$[Wy],h4=Uy.toLowerCase(),f4=Uy[0].toUpperCase()+Uy.slice(1);Wa(h4,"on"+f4)}Wa(JC,"onAnimationEnd"),Wa(e$,"onAnimationIteration"),Wa(t$,"onAnimationStart"),Wa("dblclick","onDoubleClick"),Wa("focusin","onFocus"),Wa("focusout","onBlur"),Wa(n$,"onTransitionEnd"),i("onMouseEnter",["mouseout","mouseover"]),i("onMouseLeave",["mouseout","mouseover"]),i("onPointerEnter",["pointerout","pointerover"]),i("onPointerLeave",["pointerout","pointerover"]),o("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),o("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),o("onBeforeInput",["compositionend","keypress","textInput","paste"]),o("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),o("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),o("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var qd="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),p4=new Set("cancel close invalid load scroll toggle".split(" ").concat(qd));function o$(u,h,m){var b=u.type||"unknown-event";u.currentTarget=m,Da(b,h,void 0,u),u.currentTarget=null}function i$(u,h){h=(h&4)!==0;for(var m=0;m<u.length;m++){var b=u[m],C=b.event;b=b.listeners;e:{var T=void 0;if(h)for(var D=b.length-1;0<=D;D--){var H=b[D],Q=H.instance,de=H.currentTarget;if(H=H.listener,Q!==T&&C.isPropagationStopped())break e;o$(C,H,de),T=Q}else for(D=0;D<b.length;D++){if(H=b[D],Q=H.instance,de=H.currentTarget,H=H.listener,Q!==T&&C.isPropagationStopped())break e;o$(C,H,de),T=Q}}}if(Xt)throw u=dr,Xt=!1,dr=null,u}function on(u,h){var m=h[Qy];m===void 0&&(m=h[Qy]=new Set);var b=u+"__bubble";m.has(b)||(a$(h,u,2,!1),m.add(b))}function jy(u,h,m){var b=0;h&&(b|=4),a$(m,u,b,h)}var mp="_reactListening"+Math.random().toString(36).slice(2);function Yd(u){if(!u[mp]){u[mp]=!0,r.forEach(function(m){m!=="selectionchange"&&(p4.has(m)||jy(m,!1,u),jy(m,!0,u))});var h=u.nodeType===9?u:u.ownerDocument;h===null||h[mp]||(h[mp]=!0,jy("selectionchange",!1,h))}}function a$(u,h,m,b){switch(Nt(h)){case 1:var C=ee;break;case 4:C=he;break;default:C=Fe}m=C.bind(null,h,m,u),C=void 0,!Ws||h!=="touchstart"&&h!=="touchmove"&&h!=="wheel"||(C=!0),b?C!==void 0?u.addEventListener(h,m,{capture:!0,passive:C}):u.addEventListener(h,m,!0):C!==void 0?u.addEventListener(h,m,{passive:C}):u.addEventListener(h,m,!1)}function Gy(u,h,m,b,C){var T=b;if((h&1)===0&&(h&2)===0&&b!==null)e:for(;;){if(b===null)return;var D=b.tag;if(D===3||D===4){var H=b.stateNode.containerInfo;if(H===C||H.nodeType===8&&H.parentNode===C)break;if(D===4)for(D=b.return;D!==null;){var Q=D.tag;if((Q===3||Q===4)&&(Q=D.stateNode.containerInfo,Q===C||Q.nodeType===8&&Q.parentNode===C))return;D=D.return}for(;H!==null;){if(D=Gl(H),D===null)return;if(Q=D.tag,Q===5||Q===6){b=T=D;continue e}H=H.parentNode}}b=b.return}Jn(function(){var de=T,Se=Cs(m),ke=[];e:{var be=r$.get(u);if(be!==void 0){var Le=jd,Me=u;switch(u){case"keypress":if(Dr(m)===0)break e;case"keydown":case"keyup":Le=A;break;case"focusin":Me="focus",Le=Wl;break;case"focusout":Me="blur",Le=Wl;break;case"beforeblur":case"afterblur":Le=Wl;break;case"click":if(m.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":Le=op;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":Le=Ny;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":Le=Z;break;case JC:case e$:case t$:Le=_y;break;case n$:Le=Ce;break;case"scroll":Le=Gd;break;case"wheel":Le=Ze;break;case"copy":case"cut":case"paste":Le=nc;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":Le=G}var Ue=(h&4)!==0,Sn=!Ue&&u==="scroll",oe=Ue?be!==null?be+"Capture":null:be;Ue=[];for(var te=de,le;te!==null;){le=te;var Ie=le.stateNode;if(le.tag===5&&Ie!==null&&(le=Ie,oe!==null&&(Ie=Ni(te,oe),Ie!=null&&Ue.push(Qd(te,Ie,le)))),Sn)break;te=te.return}0<Ue.length&&(be=new Le(be,Me,null,m,Se),ke.push({event:be,listeners:Ue}))}}if((h&7)===0){e:{if(be=u==="mouseover"||u==="pointerover",Le=u==="mouseout"||u==="pointerout",be&&m!==Go&&(Me=m.relatedTarget||m.fromElement)&&(Gl(Me)||Me[Wi]))break e;if((Le||be)&&(be=Se.window===Se?Se:(be=Se.ownerDocument)?be.defaultView||be.parentWindow:window,Le?(Me=m.relatedTarget||m.toElement,Le=de,Me=Me?Gl(Me):null,Me!==null&&(Sn=Bn(Me),Me!==Sn||Me.tag!==5&&Me.tag!==6)&&(Me=null)):(Le=null,Me=de),Le!==Me)){if(Ue=op,Ie="onMouseLeave",oe="onMouseEnter",te="mouse",(u==="pointerout"||u==="pointerover")&&(Ue=G,Ie="onPointerLeave",oe="onPointerEnter",te="pointer"),Sn=Le==null?be:lc(Le),le=Me==null?be:lc(Me),be=new Ue(Ie,te+"leave",Le,m,Se),be.target=Sn,be.relatedTarget=le,Ie=null,Gl(Se)===de&&(Ue=new Ue(oe,te+"enter",Me,m,Se),Ue.target=le,Ue.relatedTarget=Sn,Ie=Ue),Sn=Ie,Le&&Me)t:{for(Ue=Le,oe=Me,te=0,le=Ue;le;le=ic(le))te++;for(le=0,Ie=oe;Ie;Ie=ic(Ie))le++;for(;0<te-le;)Ue=ic(Ue),te--;for(;0<le-te;)oe=ic(oe),le--;for(;te--;){if(Ue===oe||oe!==null&&Ue===oe.alternate)break t;Ue=ic(Ue),oe=ic(oe)}Ue=null}else Ue=null;Le!==null&&l$(ke,be,Le,Ue,!1),Me!==null&&Sn!==null&&l$(ke,Sn,Me,Ue,!0)}}e:{if(be=de?lc(de):window,Le=be.nodeName&&be.nodeName.toLowerCase(),Le==="select"||Le==="input"&&be.type==="file")var je=s4;else if(cp(be))if(UC)je=l4;else{je=i4;var Xe=o4}else(Le=be.nodeName)&&Le.toLowerCase()==="input"&&(be.type==="checkbox"||be.type==="radio")&&(je=a4);if(je&&(je=je(u,de))){dp(ke,je,m,Se);break e}Xe&&Xe(u,be,de),u==="focusout"&&(Xe=be._wrapperState)&&Xe.controlled&&be.type==="number"&&Na(be,"number",be.value)}switch(Xe=de?lc(de):window,u){case"focusin":(cp(Xe)||Xe.contentEditable==="true")&&(sc=Xe,By=de,Xd=null);break;case"focusout":Xd=By=sc=null;break;case"mousedown":My=!0;break;case"contextmenu":case"mouseup":case"dragend":My=!1,QC(ke,m,Se);break;case"selectionchange":if(d4)break;case"keydown":case"keyup":QC(ke,m,Se)}var qe;if(Ae)e:{switch(u){case"compositionstart":var st="onCompositionStart";break e;case"compositionend":st="onCompositionEnd";break e;case"compositionupdate":st="onCompositionUpdate";break e}st=void 0}else yt?Or(u,m)&&(st="onCompositionEnd"):u==="keydown"&&m.keyCode===229&&(st="onCompositionStart");st&&(qt&&m.locale!=="ko"&&(yt||st!=="onCompositionStart"?st==="onCompositionEnd"&&yt&&(qe=Gn()):(at=Se,_t="value"in at?at.value:at.textContent,yt=!0)),Xe=gp(de,st),0<Xe.length&&(st=new ap(st,u,null,m,Se),ke.push({event:st,listeners:Xe}),qe?st.data=qe:(qe=nr(m),qe!==null&&(st.data=qe)))),(qe=ft?_n(u,m):Jo(u,m))&&(de=gp(de,"onBeforeInput"),0<de.length&&(Se=new ap("onBeforeInput","beforeinput",null,m,Se),ke.push({event:Se,listeners:de}),Se.data=qe))}i$(ke,h)})}function Qd(u,h,m){return{instance:u,listener:h,currentTarget:m}}function gp(u,h){for(var m=h+"Capture",b=[];u!==null;){var C=u,T=C.stateNode;C.tag===5&&T!==null&&(C=T,T=Ni(u,m),T!=null&&b.unshift(Qd(u,T,C)),T=Ni(u,h),T!=null&&b.push(Qd(u,T,C))),u=u.return}return b}function ic(u){if(u===null)return null;do u=u.return;while(u&&u.tag!==5);return u||null}function l$(u,h,m,b,C){for(var T=h._reactName,D=[];m!==null&&m!==b;){var H=m,Q=H.alternate,de=H.stateNode;if(Q!==null&&Q===b)break;H.tag===5&&de!==null&&(H=de,C?(Q=Ni(m,T),Q!=null&&D.unshift(Qd(m,Q,H))):C||(Q=Ni(m,T),Q!=null&&D.push(Qd(m,Q,H)))),m=m.return}D.length!==0&&u.push({event:h,listeners:D})}var m4=/\r\n?/g,g4=/\u0000|\uFFFD/g;function u$(u){return(typeof u=="string"?u:""+u).replace(m4,`
`).replace(g4,"")}function yp(u,h,m){if(h=u$(h),u$(u)!==h&&m)throw Error(n(425))}function xp(){}var Hy=null,Ky=null;function Xy(u,h){return u==="textarea"||u==="noscript"||typeof h.children=="string"||typeof h.children=="number"||typeof h.dangerouslySetInnerHTML=="object"&&h.dangerouslySetInnerHTML!==null&&h.dangerouslySetInnerHTML.__html!=null}var qy=typeof setTimeout=="function"?setTimeout:void 0,y4=typeof clearTimeout=="function"?clearTimeout:void 0,c$=typeof Promise=="function"?Promise:void 0,x4=typeof queueMicrotask=="function"?queueMicrotask:typeof c$<"u"?function(u){return c$.resolve(null).then(u).catch(v4)}:qy;function v4(u){setTimeout(function(){throw u})}function Yy(u,h){var m=h,b=0;do{var C=m.nextSibling;if(u.removeChild(m),C&&C.nodeType===8)if(m=C.data,m==="/$"){if(b===0){u.removeChild(C),So(h);return}b--}else m!=="$"&&m!=="$?"&&m!=="$!"||b++;m=C}while(m);So(h)}function Ua(u){for(;u!=null;u=u.nextSibling){var h=u.nodeType;if(h===1||h===3)break;if(h===8){if(h=u.data,h==="$"||h==="$!"||h==="$?")break;if(h==="/$")return null}}return u}function d$(u){u=u.previousSibling;for(var h=0;u;){if(u.nodeType===8){var m=u.data;if(m==="$"||m==="$!"||m==="$?"){if(h===0)return u;h--}else m==="/$"&&h++}u=u.previousSibling}return null}var ac=Math.random().toString(36).slice(2),ei="__reactFiber$"+ac,Zd="__reactProps$"+ac,Wi="__reactContainer$"+ac,Qy="__reactEvents$"+ac,b4="__reactListeners$"+ac,w4="__reactHandles$"+ac;function Gl(u){var h=u[ei];if(h)return h;for(var m=u.parentNode;m;){if(h=m[Wi]||m[ei]){if(m=h.alternate,h.child!==null||m!==null&&m.child!==null)for(u=d$(u);u!==null;){if(m=u[ei])return m;u=d$(u)}return h}u=m,m=u.parentNode}return null}function Jd(u){return u=u[ei]||u[Wi],!u||u.tag!==5&&u.tag!==6&&u.tag!==13&&u.tag!==3?null:u}function lc(u){if(u.tag===5||u.tag===6)return u.stateNode;throw Error(n(33))}function vp(u){return u[Zd]||null}var Zy=[],uc=-1;function ja(u){return{current:u}}function an(u){0>uc||(u.current=Zy[uc],Zy[uc]=null,uc--)}function Jt(u,h){uc++,Zy[uc]=u.current,u.current=h}var Ga={},pr=ja(Ga),ns=ja(!1),Hl=Ga;function cc(u,h){var m=u.type.contextTypes;if(!m)return Ga;var b=u.stateNode;if(b&&b.__reactInternalMemoizedUnmaskedChildContext===h)return b.__reactInternalMemoizedMaskedChildContext;var C={},T;for(T in m)C[T]=h[T];return b&&(u=u.stateNode,u.__reactInternalMemoizedUnmaskedChildContext=h,u.__reactInternalMemoizedMaskedChildContext=C),C}function rs(u){return u=u.childContextTypes,u!=null}function bp(){an(ns),an(pr)}function h$(u,h,m){if(pr.current!==Ga)throw Error(n(168));Jt(pr,h),Jt(ns,m)}function f$(u,h,m){var b=u.stateNode;if(h=h.childContextTypes,typeof b.getChildContext!="function")return m;b=b.getChildContext();for(var C in b)if(!(C in h))throw Error(n(108,Tt(u)||"Unknown",C));return ae({},m,b)}function wp(u){return u=(u=u.stateNode)&&u.__reactInternalMemoizedMergedChildContext||Ga,Hl=pr.current,Jt(pr,u),Jt(ns,ns.current),!0}function p$(u,h,m){var b=u.stateNode;if(!b)throw Error(n(169));m?(u=f$(u,h,Hl),b.__reactInternalMemoizedMergedChildContext=u,an(ns),an(pr),Jt(pr,u)):an(ns),Jt(ns,m)}var Ui=null,Sp=!1,Jy=!1;function m$(u){Ui===null?Ui=[u]:Ui.push(u)}function S4(u){Sp=!0,m$(u)}function Ha(){if(!Jy&&Ui!==null){Jy=!0;var u=0,h=St;try{var m=Ui;for(St=1;u<m.length;u++){var b=m[u];do b=b(!0);while(b!==null)}Ui=null,Sp=!1}catch(C){throw Ui!==null&&(Ui=Ui.slice(u+1)),Dl(vo,Ha),C}finally{St=h,Jy=!1}}return null}var dc=[],hc=0,Cp=null,$p=0,Gs=[],Hs=0,Kl=null,ji=1,Gi="";function Xl(u,h){dc[hc++]=$p,dc[hc++]=Cp,Cp=u,$p=h}function g$(u,h,m){Gs[Hs++]=ji,Gs[Hs++]=Gi,Gs[Hs++]=Kl,Kl=u;var b=ji;u=Gi;var C=32-hr(b)-1;b&=~(1<<C),m+=1;var T=32-hr(h)+C;if(30<T){var D=C-C%5;T=(b&(1<<D)-1).toString(32),b>>=D,C-=D,ji=1<<32-hr(h)+C|m<<C|b,Gi=T+u}else ji=1<<T|m<<C|b,Gi=u}function e0(u){u.return!==null&&(Xl(u,1),g$(u,1,0))}function t0(u){for(;u===Cp;)Cp=dc[--hc],dc[hc]=null,$p=dc[--hc],dc[hc]=null;for(;u===Kl;)Kl=Gs[--Hs],Gs[Hs]=null,Gi=Gs[--Hs],Gs[Hs]=null,ji=Gs[--Hs],Gs[Hs]=null}var ks=null,Ts=null,un=!1,ko=null;function y$(u,h){var m=Ys(5,null,null,0);m.elementType="DELETED",m.stateNode=h,m.return=u,h=u.deletions,h===null?(u.deletions=[m],u.flags|=16):h.push(m)}function x$(u,h){switch(u.tag){case 5:var m=u.type;return h=h.nodeType!==1||m.toLowerCase()!==h.nodeName.toLowerCase()?null:h,h!==null?(u.stateNode=h,ks=u,Ts=Ua(h.firstChild),!0):!1;case 6:return h=u.pendingProps===""||h.nodeType!==3?null:h,h!==null?(u.stateNode=h,ks=u,Ts=null,!0):!1;case 13:return h=h.nodeType!==8?null:h,h!==null?(m=Kl!==null?{id:ji,overflow:Gi}:null,u.memoizedState={dehydrated:h,treeContext:m,retryLane:1073741824},m=Ys(18,null,null,0),m.stateNode=h,m.return=u,u.child=m,ks=u,Ts=null,!0):!1;default:return!1}}function n0(u){return(u.mode&1)!==0&&(u.flags&128)===0}function r0(u){if(un){var h=Ts;if(h){var m=h;if(!x$(u,h)){if(n0(u))throw Error(n(418));h=Ua(m.nextSibling);var b=ks;h&&x$(u,h)?y$(b,m):(u.flags=u.flags&-4097|2,un=!1,ks=u)}}else{if(n0(u))throw Error(n(418));u.flags=u.flags&-4097|2,un=!1,ks=u}}}function v$(u){for(u=u.return;u!==null&&u.tag!==5&&u.tag!==3&&u.tag!==13;)u=u.return;ks=u}function kp(u){if(u!==ks)return!1;if(!un)return v$(u),un=!0,!1;var h;if((h=u.tag!==3)&&!(h=u.tag!==5)&&(h=u.type,h=h!=="head"&&h!=="body"&&!Xy(u.type,u.memoizedProps)),h&&(h=Ts)){if(n0(u))throw b$(),Error(n(418));for(;h;)y$(u,h),h=Ua(h.nextSibling)}if(v$(u),u.tag===13){if(u=u.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(n(317));e:{for(u=u.nextSibling,h=0;u;){if(u.nodeType===8){var m=u.data;if(m==="/$"){if(h===0){Ts=Ua(u.nextSibling);break e}h--}else m!=="$"&&m!=="$!"&&m!=="$?"||h++}u=u.nextSibling}Ts=null}}else Ts=ks?Ua(u.stateNode.nextSibling):null;return!0}function b$(){for(var u=Ts;u;)u=Ua(u.nextSibling)}function fc(){Ts=ks=null,un=!1}function s0(u){ko===null?ko=[u]:ko.push(u)}var C4=R.ReactCurrentBatchConfig;function eh(u,h,m){if(u=m.ref,u!==null&&typeof u!="function"&&typeof u!="object"){if(m._owner){if(m=m._owner,m){if(m.tag!==1)throw Error(n(309));var b=m.stateNode}if(!b)throw Error(n(147,u));var C=b,T=""+u;return h!==null&&h.ref!==null&&typeof h.ref=="function"&&h.ref._stringRef===T?h.ref:(h=function(D){var H=C.refs;D===null?delete H[T]:H[T]=D},h._stringRef=T,h)}if(typeof u!="string")throw Error(n(284));if(!m._owner)throw Error(n(290,u))}return u}function Tp(u,h){throw u=Object.prototype.toString.call(h),Error(n(31,u==="[object Object]"?"object with keys {"+Object.keys(h).join(", ")+"}":u))}function w$(u){var h=u._init;return h(u._payload)}function S$(u){function h(oe,te){if(u){var le=oe.deletions;le===null?(oe.deletions=[te],oe.flags|=16):le.push(te)}}function m(oe,te){if(!u)return null;for(;te!==null;)h(oe,te),te=te.sibling;return null}function b(oe,te){for(oe=new Map;te!==null;)te.key!==null?oe.set(te.key,te):oe.set(te.index,te),te=te.sibling;return oe}function C(oe,te){return oe=el(oe,te),oe.index=0,oe.sibling=null,oe}function T(oe,te,le){return oe.index=le,u?(le=oe.alternate,le!==null?(le=le.index,le<te?(oe.flags|=2,te):le):(oe.flags|=2,te)):(oe.flags|=1048576,te)}function D(oe){return u&&oe.alternate===null&&(oe.flags|=2),oe}function H(oe,te,le,Ie){return te===null||te.tag!==6?(te=q0(le,oe.mode,Ie),te.return=oe,te):(te=C(te,le),te.return=oe,te)}function Q(oe,te,le,Ie){var je=le.type;return je===F?Se(oe,te,le.props.children,Ie,le.key):te!==null&&(te.elementType===je||typeof je=="object"&&je!==null&&je.$$typeof===ve&&w$(je)===te.type)?(Ie=C(te,le.props),Ie.ref=eh(oe,te,le),Ie.return=oe,Ie):(Ie=Yp(le.type,le.key,le.props,null,oe.mode,Ie),Ie.ref=eh(oe,te,le),Ie.return=oe,Ie)}function de(oe,te,le,Ie){return te===null||te.tag!==4||te.stateNode.containerInfo!==le.containerInfo||te.stateNode.implementation!==le.implementation?(te=Y0(le,oe.mode,Ie),te.return=oe,te):(te=C(te,le.children||[]),te.return=oe,te)}function Se(oe,te,le,Ie,je){return te===null||te.tag!==7?(te=nu(le,oe.mode,Ie,je),te.return=oe,te):(te=C(te,le),te.return=oe,te)}function ke(oe,te,le){if(typeof te=="string"&&te!==""||typeof te=="number")return te=q0(""+te,oe.mode,le),te.return=oe,te;if(typeof te=="object"&&te!==null){switch(te.$$typeof){case _:return le=Yp(te.type,te.key,te.props,null,oe.mode,le),le.ref=eh(oe,null,te),le.return=oe,le;case O:return te=Y0(te,oe.mode,le),te.return=oe,te;case ve:var Ie=te._init;return ke(oe,Ie(te._payload),le)}if(bs(te)||xe(te))return te=nu(te,oe.mode,le,null),te.return=oe,te;Tp(oe,te)}return null}function be(oe,te,le,Ie){var je=te!==null?te.key:null;if(typeof le=="string"&&le!==""||typeof le=="number")return je!==null?null:H(oe,te,""+le,Ie);if(typeof le=="object"&&le!==null){switch(le.$$typeof){case _:return le.key===je?Q(oe,te,le,Ie):null;case O:return le.key===je?de(oe,te,le,Ie):null;case ve:return je=le._init,be(oe,te,je(le._payload),Ie)}if(bs(le)||xe(le))return je!==null?null:Se(oe,te,le,Ie,null);Tp(oe,le)}return null}function Le(oe,te,le,Ie,je){if(typeof Ie=="string"&&Ie!==""||typeof Ie=="number")return oe=oe.get(le)||null,H(te,oe,""+Ie,je);if(typeof Ie=="object"&&Ie!==null){switch(Ie.$$typeof){case _:return oe=oe.get(Ie.key===null?le:Ie.key)||null,Q(te,oe,Ie,je);case O:return oe=oe.get(Ie.key===null?le:Ie.key)||null,de(te,oe,Ie,je);case ve:var Xe=Ie._init;return Le(oe,te,le,Xe(Ie._payload),je)}if(bs(Ie)||xe(Ie))return oe=oe.get(le)||null,Se(te,oe,Ie,je,null);Tp(te,Ie)}return null}function Me(oe,te,le,Ie){for(var je=null,Xe=null,qe=te,st=te=0,Xn=null;qe!==null&&st<le.length;st++){qe.index>st?(Xn=qe,qe=null):Xn=qe.sibling;var Rt=be(oe,qe,le[st],Ie);if(Rt===null){qe===null&&(qe=Xn);break}u&&qe&&Rt.alternate===null&&h(oe,qe),te=T(Rt,te,st),Xe===null?je=Rt:Xe.sibling=Rt,Xe=Rt,qe=Xn}if(st===le.length)return m(oe,qe),un&&Xl(oe,st),je;if(qe===null){for(;st<le.length;st++)qe=ke(oe,le[st],Ie),qe!==null&&(te=T(qe,te,st),Xe===null?je=qe:Xe.sibling=qe,Xe=qe);return un&&Xl(oe,st),je}for(qe=b(oe,qe);st<le.length;st++)Xn=Le(qe,oe,st,le[st],Ie),Xn!==null&&(u&&Xn.alternate!==null&&qe.delete(Xn.key===null?st:Xn.key),te=T(Xn,te,st),Xe===null?je=Xn:Xe.sibling=Xn,Xe=Xn);return u&&qe.forEach(function(tl){return h(oe,tl)}),un&&Xl(oe,st),je}function Ue(oe,te,le,Ie){var je=xe(le);if(typeof je!="function")throw Error(n(150));if(le=je.call(le),le==null)throw Error(n(151));for(var Xe=je=null,qe=te,st=te=0,Xn=null,Rt=le.next();qe!==null&&!Rt.done;st++,Rt=le.next()){qe.index>st?(Xn=qe,qe=null):Xn=qe.sibling;var tl=be(oe,qe,Rt.value,Ie);if(tl===null){qe===null&&(qe=Xn);break}u&&qe&&tl.alternate===null&&h(oe,qe),te=T(tl,te,st),Xe===null?je=tl:Xe.sibling=tl,Xe=tl,qe=Xn}if(Rt.done)return m(oe,qe),un&&Xl(oe,st),je;if(qe===null){for(;!Rt.done;st++,Rt=le.next())Rt=ke(oe,Rt.value,Ie),Rt!==null&&(te=T(Rt,te,st),Xe===null?je=Rt:Xe.sibling=Rt,Xe=Rt);return un&&Xl(oe,st),je}for(qe=b(oe,qe);!Rt.done;st++,Rt=le.next())Rt=Le(qe,oe,st,Rt.value,Ie),Rt!==null&&(u&&Rt.alternate!==null&&qe.delete(Rt.key===null?st:Rt.key),te=T(Rt,te,st),Xe===null?je=Rt:Xe.sibling=Rt,Xe=Rt);return u&&qe.forEach(function(nL){return h(oe,nL)}),un&&Xl(oe,st),je}function Sn(oe,te,le,Ie){if(typeof le=="object"&&le!==null&&le.type===F&&le.key===null&&(le=le.props.children),typeof le=="object"&&le!==null){switch(le.$$typeof){case _:e:{for(var je=le.key,Xe=te;Xe!==null;){if(Xe.key===je){if(je=le.type,je===F){if(Xe.tag===7){m(oe,Xe.sibling),te=C(Xe,le.props.children),te.return=oe,oe=te;break e}}else if(Xe.elementType===je||typeof je=="object"&&je!==null&&je.$$typeof===ve&&w$(je)===Xe.type){m(oe,Xe.sibling),te=C(Xe,le.props),te.ref=eh(oe,Xe,le),te.return=oe,oe=te;break e}m(oe,Xe);break}else h(oe,Xe);Xe=Xe.sibling}le.type===F?(te=nu(le.props.children,oe.mode,Ie,le.key),te.return=oe,oe=te):(Ie=Yp(le.type,le.key,le.props,null,oe.mode,Ie),Ie.ref=eh(oe,te,le),Ie.return=oe,oe=Ie)}return D(oe);case O:e:{for(Xe=le.key;te!==null;){if(te.key===Xe)if(te.tag===4&&te.stateNode.containerInfo===le.containerInfo&&te.stateNode.implementation===le.implementation){m(oe,te.sibling),te=C(te,le.children||[]),te.return=oe,oe=te;break e}else{m(oe,te);break}else h(oe,te);te=te.sibling}te=Y0(le,oe.mode,Ie),te.return=oe,oe=te}return D(oe);case ve:return Xe=le._init,Sn(oe,te,Xe(le._payload),Ie)}if(bs(le))return Me(oe,te,le,Ie);if(xe(le))return Ue(oe,te,le,Ie);Tp(oe,le)}return typeof le=="string"&&le!==""||typeof le=="number"?(le=""+le,te!==null&&te.tag===6?(m(oe,te.sibling),te=C(te,le),te.return=oe,oe=te):(m(oe,te),te=q0(le,oe.mode,Ie),te.return=oe,oe=te),D(oe)):m(oe,te)}return Sn}var pc=S$(!0),C$=S$(!1),Ip=ja(null),Np=null,mc=null,o0=null;function i0(){o0=mc=Np=null}function a0(u){var h=Ip.current;an(Ip),u._currentValue=h}function l0(u,h,m){for(;u!==null;){var b=u.alternate;if((u.childLanes&h)!==h?(u.childLanes|=h,b!==null&&(b.childLanes|=h)):b!==null&&(b.childLanes&h)!==h&&(b.childLanes|=h),u===m)break;u=u.return}}function gc(u,h){Np=u,o0=mc=null,u=u.dependencies,u!==null&&u.firstContext!==null&&((u.lanes&h)!==0&&(ss=!0),u.firstContext=null)}function Ks(u){var h=u._currentValue;if(o0!==u)if(u={context:u,memoizedValue:h,next:null},mc===null){if(Np===null)throw Error(n(308));mc=u,Np.dependencies={lanes:0,firstContext:u}}else mc=mc.next=u;return h}var ql=null;function u0(u){ql===null?ql=[u]:ql.push(u)}function $$(u,h,m,b){var C=h.interleaved;return C===null?(m.next=m,u0(h)):(m.next=C.next,C.next=m),h.interleaved=m,Hi(u,b)}function Hi(u,h){u.lanes|=h;var m=u.alternate;for(m!==null&&(m.lanes|=h),m=u,u=u.return;u!==null;)u.childLanes|=h,m=u.alternate,m!==null&&(m.childLanes|=h),m=u,u=u.return;return m.tag===3?m.stateNode:null}var Ka=!1;function c0(u){u.updateQueue={baseState:u.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function k$(u,h){u=u.updateQueue,h.updateQueue===u&&(h.updateQueue={baseState:u.baseState,firstBaseUpdate:u.firstBaseUpdate,lastBaseUpdate:u.lastBaseUpdate,shared:u.shared,effects:u.effects})}function Ki(u,h){return{eventTime:u,lane:h,tag:0,payload:null,callback:null,next:null}}function Xa(u,h,m){var b=u.updateQueue;if(b===null)return null;if(b=b.shared,(Et&2)!==0){var C=b.pending;return C===null?h.next=h:(h.next=C.next,C.next=h),b.pending=h,Hi(u,m)}return C=b.interleaved,C===null?(h.next=h,u0(b)):(h.next=C.next,C.next=h),b.interleaved=h,Hi(u,m)}function Ep(u,h,m){if(h=h.updateQueue,h!==null&&(h=h.shared,(m&4194240)!==0)){var b=h.lanes;b&=u.pendingLanes,m|=b,h.lanes=m,Ll(u,m)}}function T$(u,h){var m=u.updateQueue,b=u.alternate;if(b!==null&&(b=b.updateQueue,m===b)){var C=null,T=null;if(m=m.firstBaseUpdate,m!==null){do{var D={eventTime:m.eventTime,lane:m.lane,tag:m.tag,payload:m.payload,callback:m.callback,next:null};T===null?C=T=D:T=T.next=D,m=m.next}while(m!==null);T===null?C=T=h:T=T.next=h}else C=T=h;m={baseState:b.baseState,firstBaseUpdate:C,lastBaseUpdate:T,shared:b.shared,effects:b.effects},u.updateQueue=m;return}u=m.lastBaseUpdate,u===null?m.firstBaseUpdate=h:u.next=h,m.lastBaseUpdate=h}function Rp(u,h,m,b){var C=u.updateQueue;Ka=!1;var T=C.firstBaseUpdate,D=C.lastBaseUpdate,H=C.shared.pending;if(H!==null){C.shared.pending=null;var Q=H,de=Q.next;Q.next=null,D===null?T=de:D.next=de,D=Q;var Se=u.alternate;Se!==null&&(Se=Se.updateQueue,H=Se.lastBaseUpdate,H!==D&&(H===null?Se.firstBaseUpdate=de:H.next=de,Se.lastBaseUpdate=Q))}if(T!==null){var ke=C.baseState;D=0,Se=de=Q=null,H=T;do{var be=H.lane,Le=H.eventTime;if((b&be)===be){Se!==null&&(Se=Se.next={eventTime:Le,lane:0,tag:H.tag,payload:H.payload,callback:H.callback,next:null});e:{var Me=u,Ue=H;switch(be=h,Le=m,Ue.tag){case 1:if(Me=Ue.payload,typeof Me=="function"){ke=Me.call(Le,ke,be);break e}ke=Me;break e;case 3:Me.flags=Me.flags&-65537|128;case 0:if(Me=Ue.payload,be=typeof Me=="function"?Me.call(Le,ke,be):Me,be==null)break e;ke=ae({},ke,be);break e;case 2:Ka=!0}}H.callback!==null&&H.lane!==0&&(u.flags|=64,be=C.effects,be===null?C.effects=[H]:be.push(H))}else Le={eventTime:Le,lane:be,tag:H.tag,payload:H.payload,callback:H.callback,next:null},Se===null?(de=Se=Le,Q=ke):Se=Se.next=Le,D|=be;if(H=H.next,H===null){if(H=C.shared.pending,H===null)break;be=H,H=be.next,be.next=null,C.lastBaseUpdate=be,C.shared.pending=null}}while(!0);if(Se===null&&(Q=ke),C.baseState=Q,C.firstBaseUpdate=de,C.lastBaseUpdate=Se,h=C.shared.interleaved,h!==null){C=h;do D|=C.lane,C=C.next;while(C!==h)}else T===null&&(C.shared.lanes=0);Zl|=D,u.lanes=D,u.memoizedState=ke}}function I$(u,h,m){if(u=h.effects,h.effects=null,u!==null)for(h=0;h<u.length;h++){var b=u[h],C=b.callback;if(C!==null){if(b.callback=null,b=m,typeof C!="function")throw Error(n(191,C));C.call(b)}}}var th={},ti=ja(th),nh=ja(th),rh=ja(th);function Yl(u){if(u===th)throw Error(n(174));return u}function d0(u,h){switch(Jt(rh,h),Jt(nh,u),Jt(ti,th),u=h.nodeType,u){case 9:case 11:h=(h=h.documentElement)?h.namespaceURI:Ii(null,"");break;default:u=u===8?h.parentNode:h,h=u.namespaceURI||null,u=u.tagName,h=Ii(h,u)}an(ti),Jt(ti,h)}function yc(){an(ti),an(nh),an(rh)}function N$(u){Yl(rh.current);var h=Yl(ti.current),m=Ii(h,u.type);h!==m&&(Jt(nh,u),Jt(ti,m))}function h0(u){nh.current===u&&(an(ti),an(nh))}var dn=ja(0);function _p(u){for(var h=u;h!==null;){if(h.tag===13){var m=h.memoizedState;if(m!==null&&(m=m.dehydrated,m===null||m.data==="$?"||m.data==="$!"))return h}else if(h.tag===19&&h.memoizedProps.revealOrder!==void 0){if((h.flags&128)!==0)return h}else if(h.child!==null){h.child.return=h,h=h.child;continue}if(h===u)break;for(;h.sibling===null;){if(h.return===null||h.return===u)return null;h=h.return}h.sibling.return=h.return,h=h.sibling}return null}var f0=[];function p0(){for(var u=0;u<f0.length;u++)f0[u]._workInProgressVersionPrimary=null;f0.length=0}var Pp=R.ReactCurrentDispatcher,m0=R.ReactCurrentBatchConfig,Ql=0,hn=null,Pn=null,Hn=null,Ap=!1,sh=!1,oh=0,$4=0;function mr(){throw Error(n(321))}function g0(u,h){if(h===null)return!1;for(var m=0;m<h.length&&m<u.length;m++)if(!$o(u[m],h[m]))return!1;return!0}function y0(u,h,m,b,C,T){if(Ql=T,hn=h,h.memoizedState=null,h.updateQueue=null,h.lanes=0,Pp.current=u===null||u.memoizedState===null?N4:E4,u=m(b,C),sh){T=0;do{if(sh=!1,oh=0,25<=T)throw Error(n(301));T+=1,Hn=Pn=null,h.updateQueue=null,Pp.current=R4,u=m(b,C)}while(sh)}if(Pp.current=Fp,h=Pn!==null&&Pn.next!==null,Ql=0,Hn=Pn=hn=null,Ap=!1,h)throw Error(n(300));return u}function x0(){var u=oh!==0;return oh=0,u}function ni(){var u={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Hn===null?hn.memoizedState=Hn=u:Hn=Hn.next=u,Hn}function Xs(){if(Pn===null){var u=hn.alternate;u=u!==null?u.memoizedState:null}else u=Pn.next;var h=Hn===null?hn.memoizedState:Hn.next;if(h!==null)Hn=h,Pn=u;else{if(u===null)throw Error(n(310));Pn=u,u={memoizedState:Pn.memoizedState,baseState:Pn.baseState,baseQueue:Pn.baseQueue,queue:Pn.queue,next:null},Hn===null?hn.memoizedState=Hn=u:Hn=Hn.next=u}return Hn}function ih(u,h){return typeof h=="function"?h(u):h}function v0(u){var h=Xs(),m=h.queue;if(m===null)throw Error(n(311));m.lastRenderedReducer=u;var b=Pn,C=b.baseQueue,T=m.pending;if(T!==null){if(C!==null){var D=C.next;C.next=T.next,T.next=D}b.baseQueue=C=T,m.pending=null}if(C!==null){T=C.next,b=b.baseState;var H=D=null,Q=null,de=T;do{var Se=de.lane;if((Ql&Se)===Se)Q!==null&&(Q=Q.next={lane:0,action:de.action,hasEagerState:de.hasEagerState,eagerState:de.eagerState,next:null}),b=de.hasEagerState?de.eagerState:u(b,de.action);else{var ke={lane:Se,action:de.action,hasEagerState:de.hasEagerState,eagerState:de.eagerState,next:null};Q===null?(H=Q=ke,D=b):Q=Q.next=ke,hn.lanes|=Se,Zl|=Se}de=de.next}while(de!==null&&de!==T);Q===null?D=b:Q.next=H,$o(b,h.memoizedState)||(ss=!0),h.memoizedState=b,h.baseState=D,h.baseQueue=Q,m.lastRenderedState=b}if(u=m.interleaved,u!==null){C=u;do T=C.lane,hn.lanes|=T,Zl|=T,C=C.next;while(C!==u)}else C===null&&(m.lanes=0);return[h.memoizedState,m.dispatch]}function b0(u){var h=Xs(),m=h.queue;if(m===null)throw Error(n(311));m.lastRenderedReducer=u;var b=m.dispatch,C=m.pending,T=h.memoizedState;if(C!==null){m.pending=null;var D=C=C.next;do T=u(T,D.action),D=D.next;while(D!==C);$o(T,h.memoizedState)||(ss=!0),h.memoizedState=T,h.baseQueue===null&&(h.baseState=T),m.lastRenderedState=T}return[T,b]}function E$(){}function R$(u,h){var m=hn,b=Xs(),C=h(),T=!$o(b.memoizedState,C);if(T&&(b.memoizedState=C,ss=!0),b=b.queue,w0(A$.bind(null,m,b,u),[u]),b.getSnapshot!==h||T||Hn!==null&&Hn.memoizedState.tag&1){if(m.flags|=2048,ah(9,P$.bind(null,m,b,C,h),void 0,null),Kn===null)throw Error(n(349));(Ql&30)!==0||_$(m,h,C)}return C}function _$(u,h,m){u.flags|=16384,u={getSnapshot:h,value:m},h=hn.updateQueue,h===null?(h={lastEffect:null,stores:null},hn.updateQueue=h,h.stores=[u]):(m=h.stores,m===null?h.stores=[u]:m.push(u))}function P$(u,h,m,b){h.value=m,h.getSnapshot=b,D$(h)&&O$(u)}function A$(u,h,m){return m(function(){D$(h)&&O$(u)})}function D$(u){var h=u.getSnapshot;u=u.value;try{var m=h();return!$o(u,m)}catch{return!0}}function O$(u){var h=Hi(u,1);h!==null&&Eo(h,u,1,-1)}function F$(u){var h=ni();return typeof u=="function"&&(u=u()),h.memoizedState=h.baseState=u,u={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:ih,lastRenderedState:u},h.queue=u,u=u.dispatch=I4.bind(null,hn,u),[h.memoizedState,u]}function ah(u,h,m,b){return u={tag:u,create:h,destroy:m,deps:b,next:null},h=hn.updateQueue,h===null?(h={lastEffect:null,stores:null},hn.updateQueue=h,h.lastEffect=u.next=u):(m=h.lastEffect,m===null?h.lastEffect=u.next=u:(b=m.next,m.next=u,u.next=b,h.lastEffect=u)),u}function L$(){return Xs().memoizedState}function Dp(u,h,m,b){var C=ni();hn.flags|=u,C.memoizedState=ah(1|h,m,void 0,b===void 0?null:b)}function Op(u,h,m,b){var C=Xs();b=b===void 0?null:b;var T=void 0;if(Pn!==null){var D=Pn.memoizedState;if(T=D.destroy,b!==null&&g0(b,D.deps)){C.memoizedState=ah(h,m,T,b);return}}hn.flags|=u,C.memoizedState=ah(1|h,m,T,b)}function z$(u,h){return Dp(8390656,8,u,h)}function w0(u,h){return Op(2048,8,u,h)}function B$(u,h){return Op(4,2,u,h)}function M$(u,h){return Op(4,4,u,h)}function V$(u,h){if(typeof h=="function")return u=u(),h(u),function(){h(null)};if(h!=null)return u=u(),h.current=u,function(){h.current=null}}function W$(u,h,m){return m=m!=null?m.concat([u]):null,Op(4,4,V$.bind(null,h,u),m)}function S0(){}function U$(u,h){var m=Xs();h=h===void 0?null:h;var b=m.memoizedState;return b!==null&&h!==null&&g0(h,b[1])?b[0]:(m.memoizedState=[u,h],u)}function j$(u,h){var m=Xs();h=h===void 0?null:h;var b=m.memoizedState;return b!==null&&h!==null&&g0(h,b[1])?b[0]:(u=u(),m.memoizedState=[u,h],u)}function G$(u,h,m){return(Ql&21)===0?(u.baseState&&(u.baseState=!1,ss=!0),u.memoizedState=m):($o(m,h)||(m=Fi(),hn.lanes|=m,Zl|=m,u.baseState=!0),h)}function k4(u,h){var m=St;St=m!==0&&4>m?m:4,u(!0);var b=m0.transition;m0.transition={};try{u(!1),h()}finally{St=m,m0.transition=b}}function H$(){return Xs().memoizedState}function T4(u,h,m){var b=Za(u);if(m={lane:b,action:m,hasEagerState:!1,eagerState:null,next:null},K$(u))X$(h,m);else if(m=$$(u,h,m,b),m!==null){var C=Lr();Eo(m,u,b,C),q$(m,h,b)}}function I4(u,h,m){var b=Za(u),C={lane:b,action:m,hasEagerState:!1,eagerState:null,next:null};if(K$(u))X$(h,C);else{var T=u.alternate;if(u.lanes===0&&(T===null||T.lanes===0)&&(T=h.lastRenderedReducer,T!==null))try{var D=h.lastRenderedState,H=T(D,m);if(C.hasEagerState=!0,C.eagerState=H,$o(H,D)){var Q=h.interleaved;Q===null?(C.next=C,u0(h)):(C.next=Q.next,Q.next=C),h.interleaved=C;return}}catch{}finally{}m=$$(u,h,C,b),m!==null&&(C=Lr(),Eo(m,u,b,C),q$(m,h,b))}}function K$(u){var h=u.alternate;return u===hn||h!==null&&h===hn}function X$(u,h){sh=Ap=!0;var m=u.pending;m===null?h.next=h:(h.next=m.next,m.next=h),u.pending=h}function q$(u,h,m){if((m&4194240)!==0){var b=h.lanes;b&=u.pendingLanes,m|=b,h.lanes=m,Ll(u,m)}}var Fp={readContext:Ks,useCallback:mr,useContext:mr,useEffect:mr,useImperativeHandle:mr,useInsertionEffect:mr,useLayoutEffect:mr,useMemo:mr,useReducer:mr,useRef:mr,useState:mr,useDebugValue:mr,useDeferredValue:mr,useTransition:mr,useMutableSource:mr,useSyncExternalStore:mr,useId:mr,unstable_isNewReconciler:!1},N4={readContext:Ks,useCallback:function(u,h){return ni().memoizedState=[u,h===void 0?null:h],u},useContext:Ks,useEffect:z$,useImperativeHandle:function(u,h,m){return m=m!=null?m.concat([u]):null,Dp(4194308,4,V$.bind(null,h,u),m)},useLayoutEffect:function(u,h){return Dp(4194308,4,u,h)},useInsertionEffect:function(u,h){return Dp(4,2,u,h)},useMemo:function(u,h){var m=ni();return h=h===void 0?null:h,u=u(),m.memoizedState=[u,h],u},useReducer:function(u,h,m){var b=ni();return h=m!==void 0?m(h):h,b.memoizedState=b.baseState=h,u={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:u,lastRenderedState:h},b.queue=u,u=u.dispatch=T4.bind(null,hn,u),[b.memoizedState,u]},useRef:function(u){var h=ni();return u={current:u},h.memoizedState=u},useState:F$,useDebugValue:S0,useDeferredValue:function(u){return ni().memoizedState=u},useTransition:function(){var u=F$(!1),h=u[0];return u=k4.bind(null,u[1]),ni().memoizedState=u,[h,u]},useMutableSource:function(){},useSyncExternalStore:function(u,h,m){var b=hn,C=ni();if(un){if(m===void 0)throw Error(n(407));m=m()}else{if(m=h(),Kn===null)throw Error(n(349));(Ql&30)!==0||_$(b,h,m)}C.memoizedState=m;var T={value:m,getSnapshot:h};return C.queue=T,z$(A$.bind(null,b,T,u),[u]),b.flags|=2048,ah(9,P$.bind(null,b,T,m,h),void 0,null),m},useId:function(){var u=ni(),h=Kn.identifierPrefix;if(un){var m=Gi,b=ji;m=(b&~(1<<32-hr(b)-1)).toString(32)+m,h=":"+h+"R"+m,m=oh++,0<m&&(h+="H"+m.toString(32)),h+=":"}else m=$4++,h=":"+h+"r"+m.toString(32)+":";return u.memoizedState=h},unstable_isNewReconciler:!1},E4={readContext:Ks,useCallback:U$,useContext:Ks,useEffect:w0,useImperativeHandle:W$,useInsertionEffect:B$,useLayoutEffect:M$,useMemo:j$,useReducer:v0,useRef:L$,useState:function(){return v0(ih)},useDebugValue:S0,useDeferredValue:function(u){var h=Xs();return G$(h,Pn.memoizedState,u)},useTransition:function(){var u=v0(ih)[0],h=Xs().memoizedState;return[u,h]},useMutableSource:E$,useSyncExternalStore:R$,useId:H$,unstable_isNewReconciler:!1},R4={readContext:Ks,useCallback:U$,useContext:Ks,useEffect:w0,useImperativeHandle:W$,useInsertionEffect:B$,useLayoutEffect:M$,useMemo:j$,useReducer:b0,useRef:L$,useState:function(){return b0(ih)},useDebugValue:S0,useDeferredValue:function(u){var h=Xs();return Pn===null?h.memoizedState=u:G$(h,Pn.memoizedState,u)},useTransition:function(){var u=b0(ih)[0],h=Xs().memoizedState;return[u,h]},useMutableSource:E$,useSyncExternalStore:R$,useId:H$,unstable_isNewReconciler:!1};function To(u,h){if(u&&u.defaultProps){h=ae({},h),u=u.defaultProps;for(var m in u)h[m]===void 0&&(h[m]=u[m]);return h}return h}function C0(u,h,m,b){h=u.memoizedState,m=m(b,h),m=m==null?h:ae({},h,m),u.memoizedState=m,u.lanes===0&&(u.updateQueue.baseState=m)}var Lp={isMounted:function(u){return(u=u._reactInternals)?Bn(u)===u:!1},enqueueSetState:function(u,h,m){u=u._reactInternals;var b=Lr(),C=Za(u),T=Ki(b,C);T.payload=h,m!=null&&(T.callback=m),h=Xa(u,T,C),h!==null&&(Eo(h,u,C,b),Ep(h,u,C))},enqueueReplaceState:function(u,h,m){u=u._reactInternals;var b=Lr(),C=Za(u),T=Ki(b,C);T.tag=1,T.payload=h,m!=null&&(T.callback=m),h=Xa(u,T,C),h!==null&&(Eo(h,u,C,b),Ep(h,u,C))},enqueueForceUpdate:function(u,h){u=u._reactInternals;var m=Lr(),b=Za(u),C=Ki(m,b);C.tag=2,h!=null&&(C.callback=h),h=Xa(u,C,b),h!==null&&(Eo(h,u,b,m),Ep(h,u,b))}};function Y$(u,h,m,b,C,T,D){return u=u.stateNode,typeof u.shouldComponentUpdate=="function"?u.shouldComponentUpdate(b,T,D):h.prototype&&h.prototype.isPureReactComponent?!Kd(m,b)||!Kd(C,T):!0}function Q$(u,h,m){var b=!1,C=Ga,T=h.contextType;return typeof T=="object"&&T!==null?T=Ks(T):(C=rs(h)?Hl:pr.current,b=h.contextTypes,T=(b=b!=null)?cc(u,C):Ga),h=new h(m,T),u.memoizedState=h.state!==null&&h.state!==void 0?h.state:null,h.updater=Lp,u.stateNode=h,h._reactInternals=u,b&&(u=u.stateNode,u.__reactInternalMemoizedUnmaskedChildContext=C,u.__reactInternalMemoizedMaskedChildContext=T),h}function Z$(u,h,m,b){u=h.state,typeof h.componentWillReceiveProps=="function"&&h.componentWillReceiveProps(m,b),typeof h.UNSAFE_componentWillReceiveProps=="function"&&h.UNSAFE_componentWillReceiveProps(m,b),h.state!==u&&Lp.enqueueReplaceState(h,h.state,null)}function $0(u,h,m,b){var C=u.stateNode;C.props=m,C.state=u.memoizedState,C.refs={},c0(u);var T=h.contextType;typeof T=="object"&&T!==null?C.context=Ks(T):(T=rs(h)?Hl:pr.current,C.context=cc(u,T)),C.state=u.memoizedState,T=h.getDerivedStateFromProps,typeof T=="function"&&(C0(u,h,T,m),C.state=u.memoizedState),typeof h.getDerivedStateFromProps=="function"||typeof C.getSnapshotBeforeUpdate=="function"||typeof C.UNSAFE_componentWillMount!="function"&&typeof C.componentWillMount!="function"||(h=C.state,typeof C.componentWillMount=="function"&&C.componentWillMount(),typeof C.UNSAFE_componentWillMount=="function"&&C.UNSAFE_componentWillMount(),h!==C.state&&Lp.enqueueReplaceState(C,C.state,null),Rp(u,m,C,b),C.state=u.memoizedState),typeof C.componentDidMount=="function"&&(u.flags|=4194308)}function xc(u,h){try{var m="",b=h;do m+=et(b),b=b.return;while(b);var C=m}catch(T){C=`
Error generating stack: `+T.message+`
`+T.stack}return{value:u,source:h,stack:C,digest:null}}function k0(u,h,m){return{value:u,source:null,stack:m??null,digest:h??null}}function T0(u,h){try{console.error(h.value)}catch(m){setTimeout(function(){throw m})}}var _4=typeof WeakMap=="function"?WeakMap:Map;function J$(u,h,m){m=Ki(-1,m),m.tag=3,m.payload={element:null};var b=h.value;return m.callback=function(){jp||(jp=!0,V0=b),T0(u,h)},m}function ek(u,h,m){m=Ki(-1,m),m.tag=3;var b=u.type.getDerivedStateFromError;if(typeof b=="function"){var C=h.value;m.payload=function(){return b(C)},m.callback=function(){T0(u,h)}}var T=u.stateNode;return T!==null&&typeof T.componentDidCatch=="function"&&(m.callback=function(){T0(u,h),typeof b!="function"&&(Ya===null?Ya=new Set([this]):Ya.add(this));var D=h.stack;this.componentDidCatch(h.value,{componentStack:D!==null?D:""})}),m}function tk(u,h,m){var b=u.pingCache;if(b===null){b=u.pingCache=new _4;var C=new Set;b.set(h,C)}else C=b.get(h),C===void 0&&(C=new Set,b.set(h,C));C.has(m)||(C.add(m),u=G4.bind(null,u,h,m),h.then(u,u))}function nk(u){do{var h;if((h=u.tag===13)&&(h=u.memoizedState,h=h!==null?h.dehydrated!==null:!0),h)return u;u=u.return}while(u!==null);return null}function rk(u,h,m,b,C){return(u.mode&1)===0?(u===h?u.flags|=65536:(u.flags|=128,m.flags|=131072,m.flags&=-52805,m.tag===1&&(m.alternate===null?m.tag=17:(h=Ki(-1,1),h.tag=2,Xa(m,h,1))),m.lanes|=1),u):(u.flags|=65536,u.lanes=C,u)}var P4=R.ReactCurrentOwner,ss=!1;function Fr(u,h,m,b){h.child=u===null?C$(h,null,m,b):pc(h,u.child,m,b)}function sk(u,h,m,b,C){m=m.render;var T=h.ref;return gc(h,C),b=y0(u,h,m,b,T,C),m=x0(),u!==null&&!ss?(h.updateQueue=u.updateQueue,h.flags&=-2053,u.lanes&=~C,Xi(u,h,C)):(un&&m&&e0(h),h.flags|=1,Fr(u,h,b,C),h.child)}function ok(u,h,m,b,C){if(u===null){var T=m.type;return typeof T=="function"&&!X0(T)&&T.defaultProps===void 0&&m.compare===null&&m.defaultProps===void 0?(h.tag=15,h.type=T,ik(u,h,T,b,C)):(u=Yp(m.type,null,b,h,h.mode,C),u.ref=h.ref,u.return=h,h.child=u)}if(T=u.child,(u.lanes&C)===0){var D=T.memoizedProps;if(m=m.compare,m=m!==null?m:Kd,m(D,b)&&u.ref===h.ref)return Xi(u,h,C)}return h.flags|=1,u=el(T,b),u.ref=h.ref,u.return=h,h.child=u}function ik(u,h,m,b,C){if(u!==null){var T=u.memoizedProps;if(Kd(T,b)&&u.ref===h.ref)if(ss=!1,h.pendingProps=b=T,(u.lanes&C)!==0)(u.flags&131072)!==0&&(ss=!0);else return h.lanes=u.lanes,Xi(u,h,C)}return I0(u,h,m,b,C)}function ak(u,h,m){var b=h.pendingProps,C=b.children,T=u!==null?u.memoizedState:null;if(b.mode==="hidden")if((h.mode&1)===0)h.memoizedState={baseLanes:0,cachePool:null,transitions:null},Jt(bc,Is),Is|=m;else{if((m&1073741824)===0)return u=T!==null?T.baseLanes|m:m,h.lanes=h.childLanes=1073741824,h.memoizedState={baseLanes:u,cachePool:null,transitions:null},h.updateQueue=null,Jt(bc,Is),Is|=u,null;h.memoizedState={baseLanes:0,cachePool:null,transitions:null},b=T!==null?T.baseLanes:m,Jt(bc,Is),Is|=b}else T!==null?(b=T.baseLanes|m,h.memoizedState=null):b=m,Jt(bc,Is),Is|=b;return Fr(u,h,C,m),h.child}function lk(u,h){var m=h.ref;(u===null&&m!==null||u!==null&&u.ref!==m)&&(h.flags|=512,h.flags|=2097152)}function I0(u,h,m,b,C){var T=rs(m)?Hl:pr.current;return T=cc(h,T),gc(h,C),m=y0(u,h,m,b,T,C),b=x0(),u!==null&&!ss?(h.updateQueue=u.updateQueue,h.flags&=-2053,u.lanes&=~C,Xi(u,h,C)):(un&&b&&e0(h),h.flags|=1,Fr(u,h,m,C),h.child)}function uk(u,h,m,b,C){if(rs(m)){var T=!0;wp(h)}else T=!1;if(gc(h,C),h.stateNode===null)Bp(u,h),Q$(h,m,b),$0(h,m,b,C),b=!0;else if(u===null){var D=h.stateNode,H=h.memoizedProps;D.props=H;var Q=D.context,de=m.contextType;typeof de=="object"&&de!==null?de=Ks(de):(de=rs(m)?Hl:pr.current,de=cc(h,de));var Se=m.getDerivedStateFromProps,ke=typeof Se=="function"||typeof D.getSnapshotBeforeUpdate=="function";ke||typeof D.UNSAFE_componentWillReceiveProps!="function"&&typeof D.componentWillReceiveProps!="function"||(H!==b||Q!==de)&&Z$(h,D,b,de),Ka=!1;var be=h.memoizedState;D.state=be,Rp(h,b,D,C),Q=h.memoizedState,H!==b||be!==Q||ns.current||Ka?(typeof Se=="function"&&(C0(h,m,Se,b),Q=h.memoizedState),(H=Ka||Y$(h,m,H,b,be,Q,de))?(ke||typeof D.UNSAFE_componentWillMount!="function"&&typeof D.componentWillMount!="function"||(typeof D.componentWillMount=="function"&&D.componentWillMount(),typeof D.UNSAFE_componentWillMount=="function"&&D.UNSAFE_componentWillMount()),typeof D.componentDidMount=="function"&&(h.flags|=4194308)):(typeof D.componentDidMount=="function"&&(h.flags|=4194308),h.memoizedProps=b,h.memoizedState=Q),D.props=b,D.state=Q,D.context=de,b=H):(typeof D.componentDidMount=="function"&&(h.flags|=4194308),b=!1)}else{D=h.stateNode,k$(u,h),H=h.memoizedProps,de=h.type===h.elementType?H:To(h.type,H),D.props=de,ke=h.pendingProps,be=D.context,Q=m.contextType,typeof Q=="object"&&Q!==null?Q=Ks(Q):(Q=rs(m)?Hl:pr.current,Q=cc(h,Q));var Le=m.getDerivedStateFromProps;(Se=typeof Le=="function"||typeof D.getSnapshotBeforeUpdate=="function")||typeof D.UNSAFE_componentWillReceiveProps!="function"&&typeof D.componentWillReceiveProps!="function"||(H!==ke||be!==Q)&&Z$(h,D,b,Q),Ka=!1,be=h.memoizedState,D.state=be,Rp(h,b,D,C);var Me=h.memoizedState;H!==ke||be!==Me||ns.current||Ka?(typeof Le=="function"&&(C0(h,m,Le,b),Me=h.memoizedState),(de=Ka||Y$(h,m,de,b,be,Me,Q)||!1)?(Se||typeof D.UNSAFE_componentWillUpdate!="function"&&typeof D.componentWillUpdate!="function"||(typeof D.componentWillUpdate=="function"&&D.componentWillUpdate(b,Me,Q),typeof D.UNSAFE_componentWillUpdate=="function"&&D.UNSAFE_componentWillUpdate(b,Me,Q)),typeof D.componentDidUpdate=="function"&&(h.flags|=4),typeof D.getSnapshotBeforeUpdate=="function"&&(h.flags|=1024)):(typeof D.componentDidUpdate!="function"||H===u.memoizedProps&&be===u.memoizedState||(h.flags|=4),typeof D.getSnapshotBeforeUpdate!="function"||H===u.memoizedProps&&be===u.memoizedState||(h.flags|=1024),h.memoizedProps=b,h.memoizedState=Me),D.props=b,D.state=Me,D.context=Q,b=de):(typeof D.componentDidUpdate!="function"||H===u.memoizedProps&&be===u.memoizedState||(h.flags|=4),typeof D.getSnapshotBeforeUpdate!="function"||H===u.memoizedProps&&be===u.memoizedState||(h.flags|=1024),b=!1)}return N0(u,h,m,b,T,C)}function N0(u,h,m,b,C,T){lk(u,h);var D=(h.flags&128)!==0;if(!b&&!D)return C&&p$(h,m,!1),Xi(u,h,T);b=h.stateNode,P4.current=h;var H=D&&typeof m.getDerivedStateFromError!="function"?null:b.render();return h.flags|=1,u!==null&&D?(h.child=pc(h,u.child,null,T),h.child=pc(h,null,H,T)):Fr(u,h,H,T),h.memoizedState=b.state,C&&p$(h,m,!0),h.child}function ck(u){var h=u.stateNode;h.pendingContext?h$(u,h.pendingContext,h.pendingContext!==h.context):h.context&&h$(u,h.context,!1),d0(u,h.containerInfo)}function dk(u,h,m,b,C){return fc(),s0(C),h.flags|=256,Fr(u,h,m,b),h.child}var E0={dehydrated:null,treeContext:null,retryLane:0};function R0(u){return{baseLanes:u,cachePool:null,transitions:null}}function hk(u,h,m){var b=h.pendingProps,C=dn.current,T=!1,D=(h.flags&128)!==0,H;if((H=D)||(H=u!==null&&u.memoizedState===null?!1:(C&2)!==0),H?(T=!0,h.flags&=-129):(u===null||u.memoizedState!==null)&&(C|=1),Jt(dn,C&1),u===null)return r0(h),u=h.memoizedState,u!==null&&(u=u.dehydrated,u!==null)?((h.mode&1)===0?h.lanes=1:u.data==="$!"?h.lanes=8:h.lanes=1073741824,null):(D=b.children,u=b.fallback,T?(b=h.mode,T=h.child,D={mode:"hidden",children:D},(b&1)===0&&T!==null?(T.childLanes=0,T.pendingProps=D):T=Qp(D,b,0,null),u=nu(u,b,m,null),T.return=h,u.return=h,T.sibling=u,h.child=T,h.child.memoizedState=R0(m),h.memoizedState=E0,u):_0(h,D));if(C=u.memoizedState,C!==null&&(H=C.dehydrated,H!==null))return A4(u,h,D,b,H,C,m);if(T){T=b.fallback,D=h.mode,C=u.child,H=C.sibling;var Q={mode:"hidden",children:b.children};return(D&1)===0&&h.child!==C?(b=h.child,b.childLanes=0,b.pendingProps=Q,h.deletions=null):(b=el(C,Q),b.subtreeFlags=C.subtreeFlags&14680064),H!==null?T=el(H,T):(T=nu(T,D,m,null),T.flags|=2),T.return=h,b.return=h,b.sibling=T,h.child=b,b=T,T=h.child,D=u.child.memoizedState,D=D===null?R0(m):{baseLanes:D.baseLanes|m,cachePool:null,transitions:D.transitions},T.memoizedState=D,T.childLanes=u.childLanes&~m,h.memoizedState=E0,b}return T=u.child,u=T.sibling,b=el(T,{mode:"visible",children:b.children}),(h.mode&1)===0&&(b.lanes=m),b.return=h,b.sibling=null,u!==null&&(m=h.deletions,m===null?(h.deletions=[u],h.flags|=16):m.push(u)),h.child=b,h.memoizedState=null,b}function _0(u,h){return h=Qp({mode:"visible",children:h},u.mode,0,null),h.return=u,u.child=h}function zp(u,h,m,b){return b!==null&&s0(b),pc(h,u.child,null,m),u=_0(h,h.pendingProps.children),u.flags|=2,h.memoizedState=null,u}function A4(u,h,m,b,C,T,D){if(m)return h.flags&256?(h.flags&=-257,b=k0(Error(n(422))),zp(u,h,D,b)):h.memoizedState!==null?(h.child=u.child,h.flags|=128,null):(T=b.fallback,C=h.mode,b=Qp({mode:"visible",children:b.children},C,0,null),T=nu(T,C,D,null),T.flags|=2,b.return=h,T.return=h,b.sibling=T,h.child=b,(h.mode&1)!==0&&pc(h,u.child,null,D),h.child.memoizedState=R0(D),h.memoizedState=E0,T);if((h.mode&1)===0)return zp(u,h,D,null);if(C.data==="$!"){if(b=C.nextSibling&&C.nextSibling.dataset,b)var H=b.dgst;return b=H,T=Error(n(419)),b=k0(T,b,void 0),zp(u,h,D,b)}if(H=(D&u.childLanes)!==0,ss||H){if(b=Kn,b!==null){switch(D&-D){case 4:C=2;break;case 16:C=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:C=32;break;case 536870912:C=268435456;break;default:C=0}C=(C&(b.suspendedLanes|D))!==0?0:C,C!==0&&C!==T.retryLane&&(T.retryLane=C,Hi(u,C),Eo(b,u,C,-1))}return K0(),b=k0(Error(n(421))),zp(u,h,D,b)}return C.data==="$?"?(h.flags|=128,h.child=u.child,h=H4.bind(null,u),C._reactRetry=h,null):(u=T.treeContext,Ts=Ua(C.nextSibling),ks=h,un=!0,ko=null,u!==null&&(Gs[Hs++]=ji,Gs[Hs++]=Gi,Gs[Hs++]=Kl,ji=u.id,Gi=u.overflow,Kl=h),h=_0(h,b.children),h.flags|=4096,h)}function fk(u,h,m){u.lanes|=h;var b=u.alternate;b!==null&&(b.lanes|=h),l0(u.return,h,m)}function P0(u,h,m,b,C){var T=u.memoizedState;T===null?u.memoizedState={isBackwards:h,rendering:null,renderingStartTime:0,last:b,tail:m,tailMode:C}:(T.isBackwards=h,T.rendering=null,T.renderingStartTime=0,T.last=b,T.tail=m,T.tailMode=C)}function pk(u,h,m){var b=h.pendingProps,C=b.revealOrder,T=b.tail;if(Fr(u,h,b.children,m),b=dn.current,(b&2)!==0)b=b&1|2,h.flags|=128;else{if(u!==null&&(u.flags&128)!==0)e:for(u=h.child;u!==null;){if(u.tag===13)u.memoizedState!==null&&fk(u,m,h);else if(u.tag===19)fk(u,m,h);else if(u.child!==null){u.child.return=u,u=u.child;continue}if(u===h)break e;for(;u.sibling===null;){if(u.return===null||u.return===h)break e;u=u.return}u.sibling.return=u.return,u=u.sibling}b&=1}if(Jt(dn,b),(h.mode&1)===0)h.memoizedState=null;else switch(C){case"forwards":for(m=h.child,C=null;m!==null;)u=m.alternate,u!==null&&_p(u)===null&&(C=m),m=m.sibling;m=C,m===null?(C=h.child,h.child=null):(C=m.sibling,m.sibling=null),P0(h,!1,C,m,T);break;case"backwards":for(m=null,C=h.child,h.child=null;C!==null;){if(u=C.alternate,u!==null&&_p(u)===null){h.child=C;break}u=C.sibling,C.sibling=m,m=C,C=u}P0(h,!0,m,null,T);break;case"together":P0(h,!1,null,null,void 0);break;default:h.memoizedState=null}return h.child}function Bp(u,h){(h.mode&1)===0&&u!==null&&(u.alternate=null,h.alternate=null,h.flags|=2)}function Xi(u,h,m){if(u!==null&&(h.dependencies=u.dependencies),Zl|=h.lanes,(m&h.childLanes)===0)return null;if(u!==null&&h.child!==u.child)throw Error(n(153));if(h.child!==null){for(u=h.child,m=el(u,u.pendingProps),h.child=m,m.return=h;u.sibling!==null;)u=u.sibling,m=m.sibling=el(u,u.pendingProps),m.return=h;m.sibling=null}return h.child}function D4(u,h,m){switch(h.tag){case 3:ck(h),fc();break;case 5:N$(h);break;case 1:rs(h.type)&&wp(h);break;case 4:d0(h,h.stateNode.containerInfo);break;case 10:var b=h.type._context,C=h.memoizedProps.value;Jt(Ip,b._currentValue),b._currentValue=C;break;case 13:if(b=h.memoizedState,b!==null)return b.dehydrated!==null?(Jt(dn,dn.current&1),h.flags|=128,null):(m&h.child.childLanes)!==0?hk(u,h,m):(Jt(dn,dn.current&1),u=Xi(u,h,m),u!==null?u.sibling:null);Jt(dn,dn.current&1);break;case 19:if(b=(m&h.childLanes)!==0,(u.flags&128)!==0){if(b)return pk(u,h,m);h.flags|=128}if(C=h.memoizedState,C!==null&&(C.rendering=null,C.tail=null,C.lastEffect=null),Jt(dn,dn.current),b)break;return null;case 22:case 23:return h.lanes=0,ak(u,h,m)}return Xi(u,h,m)}var mk,A0,gk,yk;mk=function(u,h){for(var m=h.child;m!==null;){if(m.tag===5||m.tag===6)u.appendChild(m.stateNode);else if(m.tag!==4&&m.child!==null){m.child.return=m,m=m.child;continue}if(m===h)break;for(;m.sibling===null;){if(m.return===null||m.return===h)return;m=m.return}m.sibling.return=m.return,m=m.sibling}},A0=function(){},gk=function(u,h,m,b){var C=u.memoizedProps;if(C!==b){u=h.stateNode,Yl(ti.current);var T=null;switch(m){case"input":C=sn(u,C),b=sn(u,b),T=[];break;case"select":C=ae({},C,{value:void 0}),b=ae({},b,{value:void 0}),T=[];break;case"textarea":C=zs(u,C),b=zs(u,b),T=[];break;default:typeof C.onClick!="function"&&typeof b.onClick=="function"&&(u.onclick=xp)}jo(m,b);var D;m=null;for(de in C)if(!b.hasOwnProperty(de)&&C.hasOwnProperty(de)&&C[de]!=null)if(de==="style"){var H=C[de];for(D in H)H.hasOwnProperty(D)&&(m||(m={}),m[D]="")}else de!=="dangerouslySetInnerHTML"&&de!=="children"&&de!=="suppressContentEditableWarning"&&de!=="suppressHydrationWarning"&&de!=="autoFocus"&&(s.hasOwnProperty(de)?T||(T=[]):(T=T||[]).push(de,null));for(de in b){var Q=b[de];if(H=C!=null?C[de]:void 0,b.hasOwnProperty(de)&&Q!==H&&(Q!=null||H!=null))if(de==="style")if(H){for(D in H)!H.hasOwnProperty(D)||Q&&Q.hasOwnProperty(D)||(m||(m={}),m[D]="");for(D in Q)Q.hasOwnProperty(D)&&H[D]!==Q[D]&&(m||(m={}),m[D]=Q[D])}else m||(T||(T=[]),T.push(de,m)),m=Q;else de==="dangerouslySetInnerHTML"?(Q=Q?Q.__html:void 0,H=H?H.__html:void 0,Q!=null&&H!==Q&&(T=T||[]).push(de,Q)):de==="children"?typeof Q!="string"&&typeof Q!="number"||(T=T||[]).push(de,""+Q):de!=="suppressContentEditableWarning"&&de!=="suppressHydrationWarning"&&(s.hasOwnProperty(de)?(Q!=null&&de==="onScroll"&&on("scroll",u),T||H===Q||(T=[])):(T=T||[]).push(de,Q))}m&&(T=T||[]).push("style",m);var de=T;(h.updateQueue=de)&&(h.flags|=4)}},yk=function(u,h,m,b){m!==b&&(h.flags|=4)};function lh(u,h){if(!un)switch(u.tailMode){case"hidden":h=u.tail;for(var m=null;h!==null;)h.alternate!==null&&(m=h),h=h.sibling;m===null?u.tail=null:m.sibling=null;break;case"collapsed":m=u.tail;for(var b=null;m!==null;)m.alternate!==null&&(b=m),m=m.sibling;b===null?h||u.tail===null?u.tail=null:u.tail.sibling=null:b.sibling=null}}function gr(u){var h=u.alternate!==null&&u.alternate.child===u.child,m=0,b=0;if(h)for(var C=u.child;C!==null;)m|=C.lanes|C.childLanes,b|=C.subtreeFlags&14680064,b|=C.flags&14680064,C.return=u,C=C.sibling;else for(C=u.child;C!==null;)m|=C.lanes|C.childLanes,b|=C.subtreeFlags,b|=C.flags,C.return=u,C=C.sibling;return u.subtreeFlags|=b,u.childLanes=m,h}function O4(u,h,m){var b=h.pendingProps;switch(t0(h),h.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return gr(h),null;case 1:return rs(h.type)&&bp(),gr(h),null;case 3:return b=h.stateNode,yc(),an(ns),an(pr),p0(),b.pendingContext&&(b.context=b.pendingContext,b.pendingContext=null),(u===null||u.child===null)&&(kp(h)?h.flags|=4:u===null||u.memoizedState.isDehydrated&&(h.flags&256)===0||(h.flags|=1024,ko!==null&&(j0(ko),ko=null))),A0(u,h),gr(h),null;case 5:h0(h);var C=Yl(rh.current);if(m=h.type,u!==null&&h.stateNode!=null)gk(u,h,m,b,C),u.ref!==h.ref&&(h.flags|=512,h.flags|=2097152);else{if(!b){if(h.stateNode===null)throw Error(n(166));return gr(h),null}if(u=Yl(ti.current),kp(h)){b=h.stateNode,m=h.type;var T=h.memoizedProps;switch(b[ei]=h,b[Zd]=T,u=(h.mode&1)!==0,m){case"dialog":on("cancel",b),on("close",b);break;case"iframe":case"object":case"embed":on("load",b);break;case"video":case"audio":for(C=0;C<qd.length;C++)on(qd[C],b);break;case"source":on("error",b);break;case"img":case"image":case"link":on("error",b),on("load",b);break;case"details":on("toggle",b);break;case"input":_r(b,T),on("invalid",b);break;case"select":b._wrapperState={wasMultiple:!!T.multiple},on("invalid",b);break;case"textarea":Xr(b,T),on("invalid",b)}jo(m,T),C=null;for(var D in T)if(T.hasOwnProperty(D)){var H=T[D];D==="children"?typeof H=="string"?b.textContent!==H&&(T.suppressHydrationWarning!==!0&&yp(b.textContent,H,u),C=["children",H]):typeof H=="number"&&b.textContent!==""+H&&(T.suppressHydrationWarning!==!0&&yp(b.textContent,H,u),C=["children",""+H]):s.hasOwnProperty(D)&&H!=null&&D==="onScroll"&&on("scroll",b)}switch(m){case"input":Rr(b),El(b,T,!0);break;case"textarea":Rr(b),Ea(b);break;case"select":case"option":break;default:typeof T.onClick=="function"&&(b.onclick=xp)}b=C,h.updateQueue=b,b!==null&&(h.flags|=4)}else{D=C.nodeType===9?C:C.ownerDocument,u==="http://www.w3.org/1999/xhtml"&&(u=Ti(m)),u==="http://www.w3.org/1999/xhtml"?m==="script"?(u=D.createElement("div"),u.innerHTML="<script><\/script>",u=u.removeChild(u.firstChild)):typeof b.is=="string"?u=D.createElement(m,{is:b.is}):(u=D.createElement(m),m==="select"&&(D=u,b.multiple?D.multiple=!0:b.size&&(D.size=b.size))):u=D.createElementNS(u,m),u[ei]=h,u[Zd]=b,mk(u,h,!1,!1),h.stateNode=u;e:{switch(D=Pa(m,b),m){case"dialog":on("cancel",u),on("close",u),C=b;break;case"iframe":case"object":case"embed":on("load",u),C=b;break;case"video":case"audio":for(C=0;C<qd.length;C++)on(qd[C],u);C=b;break;case"source":on("error",u),C=b;break;case"img":case"image":case"link":on("error",u),on("load",u),C=b;break;case"details":on("toggle",u),C=b;break;case"input":_r(u,b),C=sn(u,b),on("invalid",u);break;case"option":C=b;break;case"select":u._wrapperState={wasMultiple:!!b.multiple},C=ae({},b,{value:void 0}),on("invalid",u);break;case"textarea":Xr(u,b),C=zs(u,b),on("invalid",u);break;default:C=b}jo(m,C),H=C;for(T in H)if(H.hasOwnProperty(T)){var Q=H[T];T==="style"?_a(u,Q):T==="dangerouslySetInnerHTML"?(Q=Q?Q.__html:void 0,Q!=null&&Ra(u,Q)):T==="children"?typeof Q=="string"?(m!=="textarea"||Q!=="")&&Wo(u,Q):typeof Q=="number"&&Wo(u,""+Q):T!=="suppressContentEditableWarning"&&T!=="suppressHydrationWarning"&&T!=="autoFocus"&&(s.hasOwnProperty(T)?Q!=null&&T==="onScroll"&&on("scroll",u):Q!=null&&I(u,T,Q,D))}switch(m){case"input":Rr(u),El(u,b,!1);break;case"textarea":Rr(u),Ea(u);break;case"option":b.value!=null&&u.setAttribute("value",""+dt(b.value));break;case"select":u.multiple=!!b.multiple,T=b.value,T!=null?ws(u,!!b.multiple,T,!1):b.defaultValue!=null&&ws(u,!!b.multiple,b.defaultValue,!0);break;default:typeof C.onClick=="function"&&(u.onclick=xp)}switch(m){case"button":case"input":case"select":case"textarea":b=!!b.autoFocus;break e;case"img":b=!0;break e;default:b=!1}}b&&(h.flags|=4)}h.ref!==null&&(h.flags|=512,h.flags|=2097152)}return gr(h),null;case 6:if(u&&h.stateNode!=null)yk(u,h,u.memoizedProps,b);else{if(typeof b!="string"&&h.stateNode===null)throw Error(n(166));if(m=Yl(rh.current),Yl(ti.current),kp(h)){if(b=h.stateNode,m=h.memoizedProps,b[ei]=h,(T=b.nodeValue!==m)&&(u=ks,u!==null))switch(u.tag){case 3:yp(b.nodeValue,m,(u.mode&1)!==0);break;case 5:u.memoizedProps.suppressHydrationWarning!==!0&&yp(b.nodeValue,m,(u.mode&1)!==0)}T&&(h.flags|=4)}else b=(m.nodeType===9?m:m.ownerDocument).createTextNode(b),b[ei]=h,h.stateNode=b}return gr(h),null;case 13:if(an(dn),b=h.memoizedState,u===null||u.memoizedState!==null&&u.memoizedState.dehydrated!==null){if(un&&Ts!==null&&(h.mode&1)!==0&&(h.flags&128)===0)b$(),fc(),h.flags|=98560,T=!1;else if(T=kp(h),b!==null&&b.dehydrated!==null){if(u===null){if(!T)throw Error(n(318));if(T=h.memoizedState,T=T!==null?T.dehydrated:null,!T)throw Error(n(317));T[ei]=h}else fc(),(h.flags&128)===0&&(h.memoizedState=null),h.flags|=4;gr(h),T=!1}else ko!==null&&(j0(ko),ko=null),T=!0;if(!T)return h.flags&65536?h:null}return(h.flags&128)!==0?(h.lanes=m,h):(b=b!==null,b!==(u!==null&&u.memoizedState!==null)&&b&&(h.child.flags|=8192,(h.mode&1)!==0&&(u===null||(dn.current&1)!==0?An===0&&(An=3):K0())),h.updateQueue!==null&&(h.flags|=4),gr(h),null);case 4:return yc(),A0(u,h),u===null&&Yd(h.stateNode.containerInfo),gr(h),null;case 10:return a0(h.type._context),gr(h),null;case 17:return rs(h.type)&&bp(),gr(h),null;case 19:if(an(dn),T=h.memoizedState,T===null)return gr(h),null;if(b=(h.flags&128)!==0,D=T.rendering,D===null)if(b)lh(T,!1);else{if(An!==0||u!==null&&(u.flags&128)!==0)for(u=h.child;u!==null;){if(D=_p(u),D!==null){for(h.flags|=128,lh(T,!1),b=D.updateQueue,b!==null&&(h.updateQueue=b,h.flags|=4),h.subtreeFlags=0,b=m,m=h.child;m!==null;)T=m,u=b,T.flags&=14680066,D=T.alternate,D===null?(T.childLanes=0,T.lanes=u,T.child=null,T.subtreeFlags=0,T.memoizedProps=null,T.memoizedState=null,T.updateQueue=null,T.dependencies=null,T.stateNode=null):(T.childLanes=D.childLanes,T.lanes=D.lanes,T.child=D.child,T.subtreeFlags=0,T.deletions=null,T.memoizedProps=D.memoizedProps,T.memoizedState=D.memoizedState,T.updateQueue=D.updateQueue,T.type=D.type,u=D.dependencies,T.dependencies=u===null?null:{lanes:u.lanes,firstContext:u.firstContext}),m=m.sibling;return Jt(dn,dn.current&1|2),h.child}u=u.sibling}T.tail!==null&&Ut()>wc&&(h.flags|=128,b=!0,lh(T,!1),h.lanes=4194304)}else{if(!b)if(u=_p(D),u!==null){if(h.flags|=128,b=!0,m=u.updateQueue,m!==null&&(h.updateQueue=m,h.flags|=4),lh(T,!0),T.tail===null&&T.tailMode==="hidden"&&!D.alternate&&!un)return gr(h),null}else 2*Ut()-T.renderingStartTime>wc&&m!==1073741824&&(h.flags|=128,b=!0,lh(T,!1),h.lanes=4194304);T.isBackwards?(D.sibling=h.child,h.child=D):(m=T.last,m!==null?m.sibling=D:h.child=D,T.last=D)}return T.tail!==null?(h=T.tail,T.rendering=h,T.tail=h.sibling,T.renderingStartTime=Ut(),h.sibling=null,m=dn.current,Jt(dn,b?m&1|2:m&1),h):(gr(h),null);case 22:case 23:return H0(),b=h.memoizedState!==null,u!==null&&u.memoizedState!==null!==b&&(h.flags|=8192),b&&(h.mode&1)!==0?(Is&1073741824)!==0&&(gr(h),h.subtreeFlags&6&&(h.flags|=8192)):gr(h),null;case 24:return null;case 25:return null}throw Error(n(156,h.tag))}function F4(u,h){switch(t0(h),h.tag){case 1:return rs(h.type)&&bp(),u=h.flags,u&65536?(h.flags=u&-65537|128,h):null;case 3:return yc(),an(ns),an(pr),p0(),u=h.flags,(u&65536)!==0&&(u&128)===0?(h.flags=u&-65537|128,h):null;case 5:return h0(h),null;case 13:if(an(dn),u=h.memoizedState,u!==null&&u.dehydrated!==null){if(h.alternate===null)throw Error(n(340));fc()}return u=h.flags,u&65536?(h.flags=u&-65537|128,h):null;case 19:return an(dn),null;case 4:return yc(),null;case 10:return a0(h.type._context),null;case 22:case 23:return H0(),null;case 24:return null;default:return null}}var Mp=!1,yr=!1,L4=typeof WeakSet=="function"?WeakSet:Set,ze=null;function vc(u,h){var m=u.ref;if(m!==null)if(typeof m=="function")try{m(null)}catch(b){xn(u,h,b)}else m.current=null}function D0(u,h,m){try{m()}catch(b){xn(u,h,b)}}var xk=!1;function z4(u,h){if(Hy=U,u=YC(),zy(u)){if("selectionStart"in u)var m={start:u.selectionStart,end:u.selectionEnd};else e:{m=(m=u.ownerDocument)&&m.defaultView||window;var b=m.getSelection&&m.getSelection();if(b&&b.rangeCount!==0){m=b.anchorNode;var C=b.anchorOffset,T=b.focusNode;b=b.focusOffset;try{m.nodeType,T.nodeType}catch{m=null;break e}var D=0,H=-1,Q=-1,de=0,Se=0,ke=u,be=null;t:for(;;){for(var Le;ke!==m||C!==0&&ke.nodeType!==3||(H=D+C),ke!==T||b!==0&&ke.nodeType!==3||(Q=D+b),ke.nodeType===3&&(D+=ke.nodeValue.length),(Le=ke.firstChild)!==null;)be=ke,ke=Le;for(;;){if(ke===u)break t;if(be===m&&++de===C&&(H=D),be===T&&++Se===b&&(Q=D),(Le=ke.nextSibling)!==null)break;ke=be,be=ke.parentNode}ke=Le}m=H===-1||Q===-1?null:{start:H,end:Q}}else m=null}m=m||{start:0,end:0}}else m=null;for(Ky={focusedElem:u,selectionRange:m},U=!1,ze=h;ze!==null;)if(h=ze,u=h.child,(h.subtreeFlags&1028)!==0&&u!==null)u.return=h,ze=u;else for(;ze!==null;){h=ze;try{var Me=h.alternate;if((h.flags&1024)!==0)switch(h.tag){case 0:case 11:case 15:break;case 1:if(Me!==null){var Ue=Me.memoizedProps,Sn=Me.memoizedState,oe=h.stateNode,te=oe.getSnapshotBeforeUpdate(h.elementType===h.type?Ue:To(h.type,Ue),Sn);oe.__reactInternalSnapshotBeforeUpdate=te}break;case 3:var le=h.stateNode.containerInfo;le.nodeType===1?le.textContent="":le.nodeType===9&&le.documentElement&&le.removeChild(le.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(n(163))}}catch(Ie){xn(h,h.return,Ie)}if(u=h.sibling,u!==null){u.return=h.return,ze=u;break}ze=h.return}return Me=xk,xk=!1,Me}function uh(u,h,m){var b=h.updateQueue;if(b=b!==null?b.lastEffect:null,b!==null){var C=b=b.next;do{if((C.tag&u)===u){var T=C.destroy;C.destroy=void 0,T!==void 0&&D0(h,m,T)}C=C.next}while(C!==b)}}function Vp(u,h){if(h=h.updateQueue,h=h!==null?h.lastEffect:null,h!==null){var m=h=h.next;do{if((m.tag&u)===u){var b=m.create;m.destroy=b()}m=m.next}while(m!==h)}}function O0(u){var h=u.ref;if(h!==null){var m=u.stateNode;switch(u.tag){case 5:u=m;break;default:u=m}typeof h=="function"?h(u):h.current=u}}function vk(u){var h=u.alternate;h!==null&&(u.alternate=null,vk(h)),u.child=null,u.deletions=null,u.sibling=null,u.tag===5&&(h=u.stateNode,h!==null&&(delete h[ei],delete h[Zd],delete h[Qy],delete h[b4],delete h[w4])),u.stateNode=null,u.return=null,u.dependencies=null,u.memoizedProps=null,u.memoizedState=null,u.pendingProps=null,u.stateNode=null,u.updateQueue=null}function bk(u){return u.tag===5||u.tag===3||u.tag===4}function wk(u){e:for(;;){for(;u.sibling===null;){if(u.return===null||bk(u.return))return null;u=u.return}for(u.sibling.return=u.return,u=u.sibling;u.tag!==5&&u.tag!==6&&u.tag!==18;){if(u.flags&2||u.child===null||u.tag===4)continue e;u.child.return=u,u=u.child}if(!(u.flags&2))return u.stateNode}}function F0(u,h,m){var b=u.tag;if(b===5||b===6)u=u.stateNode,h?m.nodeType===8?m.parentNode.insertBefore(u,h):m.insertBefore(u,h):(m.nodeType===8?(h=m.parentNode,h.insertBefore(u,m)):(h=m,h.appendChild(u)),m=m._reactRootContainer,m!=null||h.onclick!==null||(h.onclick=xp));else if(b!==4&&(u=u.child,u!==null))for(F0(u,h,m),u=u.sibling;u!==null;)F0(u,h,m),u=u.sibling}function L0(u,h,m){var b=u.tag;if(b===5||b===6)u=u.stateNode,h?m.insertBefore(u,h):m.appendChild(u);else if(b!==4&&(u=u.child,u!==null))for(L0(u,h,m),u=u.sibling;u!==null;)L0(u,h,m),u=u.sibling}var rr=null,Io=!1;function qa(u,h,m){for(m=m.child;m!==null;)Sk(u,h,m),m=m.sibling}function Sk(u,h,m){if(tr&&typeof tr.onCommitFiberUnmount=="function")try{tr.onCommitFiberUnmount(Vn,m)}catch{}switch(m.tag){case 5:yr||vc(m,h);case 6:var b=rr,C=Io;rr=null,qa(u,h,m),rr=b,Io=C,rr!==null&&(Io?(u=rr,m=m.stateNode,u.nodeType===8?u.parentNode.removeChild(m):u.removeChild(m)):rr.removeChild(m.stateNode));break;case 18:rr!==null&&(Io?(u=rr,m=m.stateNode,u.nodeType===8?Yy(u.parentNode,m):u.nodeType===1&&Yy(u,m),So(u)):Yy(rr,m.stateNode));break;case 4:b=rr,C=Io,rr=m.stateNode.containerInfo,Io=!0,qa(u,h,m),rr=b,Io=C;break;case 0:case 11:case 14:case 15:if(!yr&&(b=m.updateQueue,b!==null&&(b=b.lastEffect,b!==null))){C=b=b.next;do{var T=C,D=T.destroy;T=T.tag,D!==void 0&&((T&2)!==0||(T&4)!==0)&&D0(m,h,D),C=C.next}while(C!==b)}qa(u,h,m);break;case 1:if(!yr&&(vc(m,h),b=m.stateNode,typeof b.componentWillUnmount=="function"))try{b.props=m.memoizedProps,b.state=m.memoizedState,b.componentWillUnmount()}catch(H){xn(m,h,H)}qa(u,h,m);break;case 21:qa(u,h,m);break;case 22:m.mode&1?(yr=(b=yr)||m.memoizedState!==null,qa(u,h,m),yr=b):qa(u,h,m);break;default:qa(u,h,m)}}function Ck(u){var h=u.updateQueue;if(h!==null){u.updateQueue=null;var m=u.stateNode;m===null&&(m=u.stateNode=new L4),h.forEach(function(b){var C=K4.bind(null,u,b);m.has(b)||(m.add(b),b.then(C,C))})}}function No(u,h){var m=h.deletions;if(m!==null)for(var b=0;b<m.length;b++){var C=m[b];try{var T=u,D=h,H=D;e:for(;H!==null;){switch(H.tag){case 5:rr=H.stateNode,Io=!1;break e;case 3:rr=H.stateNode.containerInfo,Io=!0;break e;case 4:rr=H.stateNode.containerInfo,Io=!0;break e}H=H.return}if(rr===null)throw Error(n(160));Sk(T,D,C),rr=null,Io=!1;var Q=C.alternate;Q!==null&&(Q.return=null),C.return=null}catch(de){xn(C,h,de)}}if(h.subtreeFlags&12854)for(h=h.child;h!==null;)$k(h,u),h=h.sibling}function $k(u,h){var m=u.alternate,b=u.flags;switch(u.tag){case 0:case 11:case 14:case 15:if(No(h,u),ri(u),b&4){try{uh(3,u,u.return),Vp(3,u)}catch(Ue){xn(u,u.return,Ue)}try{uh(5,u,u.return)}catch(Ue){xn(u,u.return,Ue)}}break;case 1:No(h,u),ri(u),b&512&&m!==null&&vc(m,m.return);break;case 5:if(No(h,u),ri(u),b&512&&m!==null&&vc(m,m.return),u.flags&32){var C=u.stateNode;try{Wo(C,"")}catch(Ue){xn(u,u.return,Ue)}}if(b&4&&(C=u.stateNode,C!=null)){var T=u.memoizedProps,D=m!==null?m.memoizedProps:T,H=u.type,Q=u.updateQueue;if(u.updateQueue=null,Q!==null)try{H==="input"&&T.type==="radio"&&T.name!=null&&Vo(C,T),Pa(H,D);var de=Pa(H,T);for(D=0;D<Q.length;D+=2){var Se=Q[D],ke=Q[D+1];Se==="style"?_a(C,ke):Se==="dangerouslySetInnerHTML"?Ra(C,ke):Se==="children"?Wo(C,ke):I(C,Se,ke,de)}switch(H){case"input":Ia(C,T);break;case"textarea":Ss(C,T);break;case"select":var be=C._wrapperState.wasMultiple;C._wrapperState.wasMultiple=!!T.multiple;var Le=T.value;Le!=null?ws(C,!!T.multiple,Le,!1):be!==!!T.multiple&&(T.defaultValue!=null?ws(C,!!T.multiple,T.defaultValue,!0):ws(C,!!T.multiple,T.multiple?[]:"",!1))}C[Zd]=T}catch(Ue){xn(u,u.return,Ue)}}break;case 6:if(No(h,u),ri(u),b&4){if(u.stateNode===null)throw Error(n(162));C=u.stateNode,T=u.memoizedProps;try{C.nodeValue=T}catch(Ue){xn(u,u.return,Ue)}}break;case 3:if(No(h,u),ri(u),b&4&&m!==null&&m.memoizedState.isDehydrated)try{So(h.containerInfo)}catch(Ue){xn(u,u.return,Ue)}break;case 4:No(h,u),ri(u);break;case 13:No(h,u),ri(u),C=u.child,C.flags&8192&&(T=C.memoizedState!==null,C.stateNode.isHidden=T,!T||C.alternate!==null&&C.alternate.memoizedState!==null||(M0=Ut())),b&4&&Ck(u);break;case 22:if(Se=m!==null&&m.memoizedState!==null,u.mode&1?(yr=(de=yr)||Se,No(h,u),yr=de):No(h,u),ri(u),b&8192){if(de=u.memoizedState!==null,(u.stateNode.isHidden=de)&&!Se&&(u.mode&1)!==0)for(ze=u,Se=u.child;Se!==null;){for(ke=ze=Se;ze!==null;){switch(be=ze,Le=be.child,be.tag){case 0:case 11:case 14:case 15:uh(4,be,be.return);break;case 1:vc(be,be.return);var Me=be.stateNode;if(typeof Me.componentWillUnmount=="function"){b=be,m=be.return;try{h=b,Me.props=h.memoizedProps,Me.state=h.memoizedState,Me.componentWillUnmount()}catch(Ue){xn(b,m,Ue)}}break;case 5:vc(be,be.return);break;case 22:if(be.memoizedState!==null){Ik(ke);continue}}Le!==null?(Le.return=be,ze=Le):Ik(ke)}Se=Se.sibling}e:for(Se=null,ke=u;;){if(ke.tag===5){if(Se===null){Se=ke;try{C=ke.stateNode,de?(T=C.style,typeof T.setProperty=="function"?T.setProperty("display","none","important"):T.display="none"):(H=ke.stateNode,Q=ke.memoizedProps.style,D=Q!=null&&Q.hasOwnProperty("display")?Q.display:null,H.style.display=Uo("display",D))}catch(Ue){xn(u,u.return,Ue)}}}else if(ke.tag===6){if(Se===null)try{ke.stateNode.nodeValue=de?"":ke.memoizedProps}catch(Ue){xn(u,u.return,Ue)}}else if((ke.tag!==22&&ke.tag!==23||ke.memoizedState===null||ke===u)&&ke.child!==null){ke.child.return=ke,ke=ke.child;continue}if(ke===u)break e;for(;ke.sibling===null;){if(ke.return===null||ke.return===u)break e;Se===ke&&(Se=null),ke=ke.return}Se===ke&&(Se=null),ke.sibling.return=ke.return,ke=ke.sibling}}break;case 19:No(h,u),ri(u),b&4&&Ck(u);break;case 21:break;default:No(h,u),ri(u)}}function ri(u){var h=u.flags;if(h&2){try{e:{for(var m=u.return;m!==null;){if(bk(m)){var b=m;break e}m=m.return}throw Error(n(160))}switch(b.tag){case 5:var C=b.stateNode;b.flags&32&&(Wo(C,""),b.flags&=-33);var T=wk(u);L0(u,T,C);break;case 3:case 4:var D=b.stateNode.containerInfo,H=wk(u);F0(u,H,D);break;default:throw Error(n(161))}}catch(Q){xn(u,u.return,Q)}u.flags&=-3}h&4096&&(u.flags&=-4097)}function B4(u,h,m){ze=u,kk(u)}function kk(u,h,m){for(var b=(u.mode&1)!==0;ze!==null;){var C=ze,T=C.child;if(C.tag===22&&b){var D=C.memoizedState!==null||Mp;if(!D){var H=C.alternate,Q=H!==null&&H.memoizedState!==null||yr;H=Mp;var de=yr;if(Mp=D,(yr=Q)&&!de)for(ze=C;ze!==null;)D=ze,Q=D.child,D.tag===22&&D.memoizedState!==null?Nk(C):Q!==null?(Q.return=D,ze=Q):Nk(C);for(;T!==null;)ze=T,kk(T),T=T.sibling;ze=C,Mp=H,yr=de}Tk(u)}else(C.subtreeFlags&8772)!==0&&T!==null?(T.return=C,ze=T):Tk(u)}}function Tk(u){for(;ze!==null;){var h=ze;if((h.flags&8772)!==0){var m=h.alternate;try{if((h.flags&8772)!==0)switch(h.tag){case 0:case 11:case 15:yr||Vp(5,h);break;case 1:var b=h.stateNode;if(h.flags&4&&!yr)if(m===null)b.componentDidMount();else{var C=h.elementType===h.type?m.memoizedProps:To(h.type,m.memoizedProps);b.componentDidUpdate(C,m.memoizedState,b.__reactInternalSnapshotBeforeUpdate)}var T=h.updateQueue;T!==null&&I$(h,T,b);break;case 3:var D=h.updateQueue;if(D!==null){if(m=null,h.child!==null)switch(h.child.tag){case 5:m=h.child.stateNode;break;case 1:m=h.child.stateNode}I$(h,D,m)}break;case 5:var H=h.stateNode;if(m===null&&h.flags&4){m=H;var Q=h.memoizedProps;switch(h.type){case"button":case"input":case"select":case"textarea":Q.autoFocus&&m.focus();break;case"img":Q.src&&(m.src=Q.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(h.memoizedState===null){var de=h.alternate;if(de!==null){var Se=de.memoizedState;if(Se!==null){var ke=Se.dehydrated;ke!==null&&So(ke)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(n(163))}yr||h.flags&512&&O0(h)}catch(be){xn(h,h.return,be)}}if(h===u){ze=null;break}if(m=h.sibling,m!==null){m.return=h.return,ze=m;break}ze=h.return}}function Ik(u){for(;ze!==null;){var h=ze;if(h===u){ze=null;break}var m=h.sibling;if(m!==null){m.return=h.return,ze=m;break}ze=h.return}}function Nk(u){for(;ze!==null;){var h=ze;try{switch(h.tag){case 0:case 11:case 15:var m=h.return;try{Vp(4,h)}catch(Q){xn(h,m,Q)}break;case 1:var b=h.stateNode;if(typeof b.componentDidMount=="function"){var C=h.return;try{b.componentDidMount()}catch(Q){xn(h,C,Q)}}var T=h.return;try{O0(h)}catch(Q){xn(h,T,Q)}break;case 5:var D=h.return;try{O0(h)}catch(Q){xn(h,D,Q)}}}catch(Q){xn(h,h.return,Q)}if(h===u){ze=null;break}var H=h.sibling;if(H!==null){H.return=h.return,ze=H;break}ze=h.return}}var M4=Math.ceil,Wp=R.ReactCurrentDispatcher,z0=R.ReactCurrentOwner,qs=R.ReactCurrentBatchConfig,Et=0,Kn=null,In=null,sr=0,Is=0,bc=ja(0),An=0,ch=null,Zl=0,Up=0,B0=0,dh=null,os=null,M0=0,wc=1/0,qi=null,jp=!1,V0=null,Ya=null,Gp=!1,Qa=null,Hp=0,hh=0,W0=null,Kp=-1,Xp=0;function Lr(){return(Et&6)!==0?Ut():Kp!==-1?Kp:Kp=Ut()}function Za(u){return(u.mode&1)===0?1:(Et&2)!==0&&sr!==0?sr&-sr:C4.transition!==null?(Xp===0&&(Xp=Fi()),Xp):(u=St,u!==0||(u=window.event,u=u===void 0?16:Nt(u.type)),u)}function Eo(u,h,m,b){if(50<hh)throw hh=0,W0=null,Error(n(185));qo(u,m,b),((Et&2)===0||u!==Kn)&&(u===Kn&&((Et&2)===0&&(Up|=m),An===4&&Ja(u,sr)),is(u,b),m===1&&Et===0&&(h.mode&1)===0&&(wc=Ut()+500,Sp&&Ha()))}function is(u,h){var m=u.callbackNode;La(u,h);var b=Oi(u,u===Kn?sr:0);if(b===0)m!==null&&Mn(m),u.callbackNode=null,u.callbackPriority=0;else if(h=b&-b,u.callbackPriority!==h){if(m!=null&&Mn(m),h===1)u.tag===0?S4(Rk.bind(null,u)):m$(Rk.bind(null,u)),x4(function(){(Et&6)===0&&Ha()}),m=null;else{switch(zl(b)){case 1:m=vo;break;case 4:m=_i;break;case 16:m=er;break;case 536870912:m=Pi;break;default:m=er}m=zk(m,Ek.bind(null,u))}u.callbackPriority=h,u.callbackNode=m}}function Ek(u,h){if(Kp=-1,Xp=0,(Et&6)!==0)throw Error(n(327));var m=u.callbackNode;if(Sc()&&u.callbackNode!==m)return null;var b=Oi(u,u===Kn?sr:0);if(b===0)return null;if((b&30)!==0||(b&u.expiredLanes)!==0||h)h=qp(u,b);else{h=b;var C=Et;Et|=2;var T=Pk();(Kn!==u||sr!==h)&&(qi=null,wc=Ut()+500,eu(u,h));do try{U4();break}catch(H){_k(u,H)}while(!0);i0(),Wp.current=T,Et=C,In!==null?h=0:(Kn=null,sr=0,h=An)}if(h!==0){if(h===2&&(C=za(u),C!==0&&(b=C,h=U0(u,C))),h===1)throw m=ch,eu(u,0),Ja(u,b),is(u,Ut()),m;if(h===6)Ja(u,b);else{if(C=u.current.alternate,(b&30)===0&&!V4(C)&&(h=qp(u,b),h===2&&(T=za(u),T!==0&&(b=T,h=U0(u,T))),h===1))throw m=ch,eu(u,0),Ja(u,b),is(u,Ut()),m;switch(u.finishedWork=C,u.finishedLanes=b,h){case 0:case 1:throw Error(n(345));case 2:tu(u,os,qi);break;case 3:if(Ja(u,b),(b&130023424)===b&&(h=M0+500-Ut(),10<h)){if(Oi(u,0)!==0)break;if(C=u.suspendedLanes,(C&b)!==b){Lr(),u.pingedLanes|=u.suspendedLanes&C;break}u.timeoutHandle=qy(tu.bind(null,u,os,qi),h);break}tu(u,os,qi);break;case 4:if(Ja(u,b),(b&4194240)===b)break;for(h=u.eventTimes,C=-1;0<b;){var D=31-hr(b);T=1<<D,D=h[D],D>C&&(C=D),b&=~T}if(b=C,b=Ut()-b,b=(120>b?120:480>b?480:1080>b?1080:1920>b?1920:3e3>b?3e3:4320>b?4320:1960*M4(b/1960))-b,10<b){u.timeoutHandle=qy(tu.bind(null,u,os,qi),b);break}tu(u,os,qi);break;case 5:tu(u,os,qi);break;default:throw Error(n(329))}}}return is(u,Ut()),u.callbackNode===m?Ek.bind(null,u):null}function U0(u,h){var m=dh;return u.current.memoizedState.isDehydrated&&(eu(u,h).flags|=256),u=qp(u,h),u!==2&&(h=os,os=m,h!==null&&j0(h)),u}function j0(u){os===null?os=u:os.push.apply(os,u)}function V4(u){for(var h=u;;){if(h.flags&16384){var m=h.updateQueue;if(m!==null&&(m=m.stores,m!==null))for(var b=0;b<m.length;b++){var C=m[b],T=C.getSnapshot;C=C.value;try{if(!$o(T(),C))return!1}catch{return!1}}}if(m=h.child,h.subtreeFlags&16384&&m!==null)m.return=h,h=m;else{if(h===u)break;for(;h.sibling===null;){if(h.return===null||h.return===u)return!0;h=h.return}h.sibling.return=h.return,h=h.sibling}}return!0}function Ja(u,h){for(h&=~B0,h&=~Up,u.suspendedLanes|=h,u.pingedLanes&=~h,u=u.expirationTimes;0<h;){var m=31-hr(h),b=1<<m;u[m]=-1,h&=~b}}function Rk(u){if((Et&6)!==0)throw Error(n(327));Sc();var h=Oi(u,0);if((h&1)===0)return is(u,Ut()),null;var m=qp(u,h);if(u.tag!==0&&m===2){var b=za(u);b!==0&&(h=b,m=U0(u,b))}if(m===1)throw m=ch,eu(u,0),Ja(u,h),is(u,Ut()),m;if(m===6)throw Error(n(345));return u.finishedWork=u.current.alternate,u.finishedLanes=h,tu(u,os,qi),is(u,Ut()),null}function G0(u,h){var m=Et;Et|=1;try{return u(h)}finally{Et=m,Et===0&&(wc=Ut()+500,Sp&&Ha())}}function Jl(u){Qa!==null&&Qa.tag===0&&(Et&6)===0&&Sc();var h=Et;Et|=1;var m=qs.transition,b=St;try{if(qs.transition=null,St=1,u)return u()}finally{St=b,qs.transition=m,Et=h,(Et&6)===0&&Ha()}}function H0(){Is=bc.current,an(bc)}function eu(u,h){u.finishedWork=null,u.finishedLanes=0;var m=u.timeoutHandle;if(m!==-1&&(u.timeoutHandle=-1,y4(m)),In!==null)for(m=In.return;m!==null;){var b=m;switch(t0(b),b.tag){case 1:b=b.type.childContextTypes,b!=null&&bp();break;case 3:yc(),an(ns),an(pr),p0();break;case 5:h0(b);break;case 4:yc();break;case 13:an(dn);break;case 19:an(dn);break;case 10:a0(b.type._context);break;case 22:case 23:H0()}m=m.return}if(Kn=u,In=u=el(u.current,null),sr=Is=h,An=0,ch=null,B0=Up=Zl=0,os=dh=null,ql!==null){for(h=0;h<ql.length;h++)if(m=ql[h],b=m.interleaved,b!==null){m.interleaved=null;var C=b.next,T=m.pending;if(T!==null){var D=T.next;T.next=C,b.next=D}m.pending=b}ql=null}return u}function _k(u,h){do{var m=In;try{if(i0(),Pp.current=Fp,Ap){for(var b=hn.memoizedState;b!==null;){var C=b.queue;C!==null&&(C.pending=null),b=b.next}Ap=!1}if(Ql=0,Hn=Pn=hn=null,sh=!1,oh=0,z0.current=null,m===null||m.return===null){An=1,ch=h,In=null;break}e:{var T=u,D=m.return,H=m,Q=h;if(h=sr,H.flags|=32768,Q!==null&&typeof Q=="object"&&typeof Q.then=="function"){var de=Q,Se=H,ke=Se.tag;if((Se.mode&1)===0&&(ke===0||ke===11||ke===15)){var be=Se.alternate;be?(Se.updateQueue=be.updateQueue,Se.memoizedState=be.memoizedState,Se.lanes=be.lanes):(Se.updateQueue=null,Se.memoizedState=null)}var Le=nk(D);if(Le!==null){Le.flags&=-257,rk(Le,D,H,T,h),Le.mode&1&&tk(T,de,h),h=Le,Q=de;var Me=h.updateQueue;if(Me===null){var Ue=new Set;Ue.add(Q),h.updateQueue=Ue}else Me.add(Q);break e}else{if((h&1)===0){tk(T,de,h),K0();break e}Q=Error(n(426))}}else if(un&&H.mode&1){var Sn=nk(D);if(Sn!==null){(Sn.flags&65536)===0&&(Sn.flags|=256),rk(Sn,D,H,T,h),s0(xc(Q,H));break e}}T=Q=xc(Q,H),An!==4&&(An=2),dh===null?dh=[T]:dh.push(T),T=D;do{switch(T.tag){case 3:T.flags|=65536,h&=-h,T.lanes|=h;var oe=J$(T,Q,h);T$(T,oe);break e;case 1:H=Q;var te=T.type,le=T.stateNode;if((T.flags&128)===0&&(typeof te.getDerivedStateFromError=="function"||le!==null&&typeof le.componentDidCatch=="function"&&(Ya===null||!Ya.has(le)))){T.flags|=65536,h&=-h,T.lanes|=h;var Ie=ek(T,H,h);T$(T,Ie);break e}}T=T.return}while(T!==null)}Dk(m)}catch(je){h=je,In===m&&m!==null&&(In=m=m.return);continue}break}while(!0)}function Pk(){var u=Wp.current;return Wp.current=Fp,u===null?Fp:u}function K0(){(An===0||An===3||An===2)&&(An=4),Kn===null||(Zl&268435455)===0&&(Up&268435455)===0||Ja(Kn,sr)}function qp(u,h){var m=Et;Et|=2;var b=Pk();(Kn!==u||sr!==h)&&(qi=null,eu(u,h));do try{W4();break}catch(C){_k(u,C)}while(!0);if(i0(),Et=m,Wp.current=b,In!==null)throw Error(n(261));return Kn=null,sr=0,An}function W4(){for(;In!==null;)Ak(In)}function U4(){for(;In!==null&&!Qr();)Ak(In)}function Ak(u){var h=Lk(u.alternate,u,Is);u.memoizedProps=u.pendingProps,h===null?Dk(u):In=h,z0.current=null}function Dk(u){var h=u;do{var m=h.alternate;if(u=h.return,(h.flags&32768)===0){if(m=O4(m,h,Is),m!==null){In=m;return}}else{if(m=F4(m,h),m!==null){m.flags&=32767,In=m;return}if(u!==null)u.flags|=32768,u.subtreeFlags=0,u.deletions=null;else{An=6,In=null;return}}if(h=h.sibling,h!==null){In=h;return}In=h=u}while(h!==null);An===0&&(An=5)}function tu(u,h,m){var b=St,C=qs.transition;try{qs.transition=null,St=1,j4(u,h,m,b)}finally{qs.transition=C,St=b}return null}function j4(u,h,m,b){do Sc();while(Qa!==null);if((Et&6)!==0)throw Error(n(327));m=u.finishedWork;var C=u.finishedLanes;if(m===null)return null;if(u.finishedWork=null,u.finishedLanes=0,m===u.current)throw Error(n(177));u.callbackNode=null,u.callbackPriority=0;var T=m.lanes|m.childLanes;if(Wd(u,T),u===Kn&&(In=Kn=null,sr=0),(m.subtreeFlags&2064)===0&&(m.flags&2064)===0||Gp||(Gp=!0,zk(er,function(){return Sc(),null})),T=(m.flags&15990)!==0,(m.subtreeFlags&15990)!==0||T){T=qs.transition,qs.transition=null;var D=St;St=1;var H=Et;Et|=4,z0.current=null,z4(u,m),$k(m,u),c4(Ky),U=!!Hy,Ky=Hy=null,u.current=m,B4(m),Us(),Et=H,St=D,qs.transition=T}else u.current=m;if(Gp&&(Gp=!1,Qa=u,Hp=C),T=u.pendingLanes,T===0&&(Ya=null),Bd(m.stateNode),is(u,Ut()),h!==null)for(b=u.onRecoverableError,m=0;m<h.length;m++)C=h[m],b(C.value,{componentStack:C.stack,digest:C.digest});if(jp)throw jp=!1,u=V0,V0=null,u;return(Hp&1)!==0&&u.tag!==0&&Sc(),T=u.pendingLanes,(T&1)!==0?u===W0?hh++:(hh=0,W0=u):hh=0,Ha(),null}function Sc(){if(Qa!==null){var u=zl(Hp),h=qs.transition,m=St;try{if(qs.transition=null,St=16>u?16:u,Qa===null)var b=!1;else{if(u=Qa,Qa=null,Hp=0,(Et&6)!==0)throw Error(n(331));var C=Et;for(Et|=4,ze=u.current;ze!==null;){var T=ze,D=T.child;if((ze.flags&16)!==0){var H=T.deletions;if(H!==null){for(var Q=0;Q<H.length;Q++){var de=H[Q];for(ze=de;ze!==null;){var Se=ze;switch(Se.tag){case 0:case 11:case 15:uh(8,Se,T)}var ke=Se.child;if(ke!==null)ke.return=Se,ze=ke;else for(;ze!==null;){Se=ze;var be=Se.sibling,Le=Se.return;if(vk(Se),Se===de){ze=null;break}if(be!==null){be.return=Le,ze=be;break}ze=Le}}}var Me=T.alternate;if(Me!==null){var Ue=Me.child;if(Ue!==null){Me.child=null;do{var Sn=Ue.sibling;Ue.sibling=null,Ue=Sn}while(Ue!==null)}}ze=T}}if((T.subtreeFlags&2064)!==0&&D!==null)D.return=T,ze=D;else e:for(;ze!==null;){if(T=ze,(T.flags&2048)!==0)switch(T.tag){case 0:case 11:case 15:uh(9,T,T.return)}var oe=T.sibling;if(oe!==null){oe.return=T.return,ze=oe;break e}ze=T.return}}var te=u.current;for(ze=te;ze!==null;){D=ze;var le=D.child;if((D.subtreeFlags&2064)!==0&&le!==null)le.return=D,ze=le;else e:for(D=te;ze!==null;){if(H=ze,(H.flags&2048)!==0)try{switch(H.tag){case 0:case 11:case 15:Vp(9,H)}}catch(je){xn(H,H.return,je)}if(H===D){ze=null;break e}var Ie=H.sibling;if(Ie!==null){Ie.return=H.return,ze=Ie;break e}ze=H.return}}if(Et=C,Ha(),tr&&typeof tr.onPostCommitFiberRoot=="function")try{tr.onPostCommitFiberRoot(Vn,u)}catch{}b=!0}return b}finally{St=m,qs.transition=h}}return!1}function Ok(u,h,m){h=xc(m,h),h=J$(u,h,1),u=Xa(u,h,1),h=Lr(),u!==null&&(qo(u,1,h),is(u,h))}function xn(u,h,m){if(u.tag===3)Ok(u,u,m);else for(;h!==null;){if(h.tag===3){Ok(h,u,m);break}else if(h.tag===1){var b=h.stateNode;if(typeof h.type.getDerivedStateFromError=="function"||typeof b.componentDidCatch=="function"&&(Ya===null||!Ya.has(b))){u=xc(m,u),u=ek(h,u,1),h=Xa(h,u,1),u=Lr(),h!==null&&(qo(h,1,u),is(h,u));break}}h=h.return}}function G4(u,h,m){var b=u.pingCache;b!==null&&b.delete(h),h=Lr(),u.pingedLanes|=u.suspendedLanes&m,Kn===u&&(sr&m)===m&&(An===4||An===3&&(sr&130023424)===sr&&500>Ut()-M0?eu(u,0):B0|=m),is(u,h)}function Fk(u,h){h===0&&((u.mode&1)===0?h=1:(h=Di,Di<<=1,(Di&130023424)===0&&(Di=4194304)));var m=Lr();u=Hi(u,h),u!==null&&(qo(u,h,m),is(u,m))}function H4(u){var h=u.memoizedState,m=0;h!==null&&(m=h.retryLane),Fk(u,m)}function K4(u,h){var m=0;switch(u.tag){case 13:var b=u.stateNode,C=u.memoizedState;C!==null&&(m=C.retryLane);break;case 19:b=u.stateNode;break;default:throw Error(n(314))}b!==null&&b.delete(h),Fk(u,m)}var Lk;Lk=function(u,h,m){if(u!==null)if(u.memoizedProps!==h.pendingProps||ns.current)ss=!0;else{if((u.lanes&m)===0&&(h.flags&128)===0)return ss=!1,D4(u,h,m);ss=(u.flags&131072)!==0}else ss=!1,un&&(h.flags&1048576)!==0&&g$(h,$p,h.index);switch(h.lanes=0,h.tag){case 2:var b=h.type;Bp(u,h),u=h.pendingProps;var C=cc(h,pr.current);gc(h,m),C=y0(null,h,b,u,C,m);var T=x0();return h.flags|=1,typeof C=="object"&&C!==null&&typeof C.render=="function"&&C.$$typeof===void 0?(h.tag=1,h.memoizedState=null,h.updateQueue=null,rs(b)?(T=!0,wp(h)):T=!1,h.memoizedState=C.state!==null&&C.state!==void 0?C.state:null,c0(h),C.updater=Lp,h.stateNode=C,C._reactInternals=h,$0(h,b,u,m),h=N0(null,h,b,!0,T,m)):(h.tag=0,un&&T&&e0(h),Fr(null,h,C,m),h=h.child),h;case 16:b=h.elementType;e:{switch(Bp(u,h),u=h.pendingProps,C=b._init,b=C(b._payload),h.type=b,C=h.tag=q4(b),u=To(b,u),C){case 0:h=I0(null,h,b,u,m);break e;case 1:h=uk(null,h,b,u,m);break e;case 11:h=sk(null,h,b,u,m);break e;case 14:h=ok(null,h,b,To(b.type,u),m);break e}throw Error(n(306,b,""))}return h;case 0:return b=h.type,C=h.pendingProps,C=h.elementType===b?C:To(b,C),I0(u,h,b,C,m);case 1:return b=h.type,C=h.pendingProps,C=h.elementType===b?C:To(b,C),uk(u,h,b,C,m);case 3:e:{if(ck(h),u===null)throw Error(n(387));b=h.pendingProps,T=h.memoizedState,C=T.element,k$(u,h),Rp(h,b,null,m);var D=h.memoizedState;if(b=D.element,T.isDehydrated)if(T={element:b,isDehydrated:!1,cache:D.cache,pendingSuspenseBoundaries:D.pendingSuspenseBoundaries,transitions:D.transitions},h.updateQueue.baseState=T,h.memoizedState=T,h.flags&256){C=xc(Error(n(423)),h),h=dk(u,h,b,m,C);break e}else if(b!==C){C=xc(Error(n(424)),h),h=dk(u,h,b,m,C);break e}else for(Ts=Ua(h.stateNode.containerInfo.firstChild),ks=h,un=!0,ko=null,m=C$(h,null,b,m),h.child=m;m;)m.flags=m.flags&-3|4096,m=m.sibling;else{if(fc(),b===C){h=Xi(u,h,m);break e}Fr(u,h,b,m)}h=h.child}return h;case 5:return N$(h),u===null&&r0(h),b=h.type,C=h.pendingProps,T=u!==null?u.memoizedProps:null,D=C.children,Xy(b,C)?D=null:T!==null&&Xy(b,T)&&(h.flags|=32),lk(u,h),Fr(u,h,D,m),h.child;case 6:return u===null&&r0(h),null;case 13:return hk(u,h,m);case 4:return d0(h,h.stateNode.containerInfo),b=h.pendingProps,u===null?h.child=pc(h,null,b,m):Fr(u,h,b,m),h.child;case 11:return b=h.type,C=h.pendingProps,C=h.elementType===b?C:To(b,C),sk(u,h,b,C,m);case 7:return Fr(u,h,h.pendingProps,m),h.child;case 8:return Fr(u,h,h.pendingProps.children,m),h.child;case 12:return Fr(u,h,h.pendingProps.children,m),h.child;case 10:e:{if(b=h.type._context,C=h.pendingProps,T=h.memoizedProps,D=C.value,Jt(Ip,b._currentValue),b._currentValue=D,T!==null)if($o(T.value,D)){if(T.children===C.children&&!ns.current){h=Xi(u,h,m);break e}}else for(T=h.child,T!==null&&(T.return=h);T!==null;){var H=T.dependencies;if(H!==null){D=T.child;for(var Q=H.firstContext;Q!==null;){if(Q.context===b){if(T.tag===1){Q=Ki(-1,m&-m),Q.tag=2;var de=T.updateQueue;if(de!==null){de=de.shared;var Se=de.pending;Se===null?Q.next=Q:(Q.next=Se.next,Se.next=Q),de.pending=Q}}T.lanes|=m,Q=T.alternate,Q!==null&&(Q.lanes|=m),l0(T.return,m,h),H.lanes|=m;break}Q=Q.next}}else if(T.tag===10)D=T.type===h.type?null:T.child;else if(T.tag===18){if(D=T.return,D===null)throw Error(n(341));D.lanes|=m,H=D.alternate,H!==null&&(H.lanes|=m),l0(D,m,h),D=T.sibling}else D=T.child;if(D!==null)D.return=T;else for(D=T;D!==null;){if(D===h){D=null;break}if(T=D.sibling,T!==null){T.return=D.return,D=T;break}D=D.return}T=D}Fr(u,h,C.children,m),h=h.child}return h;case 9:return C=h.type,b=h.pendingProps.children,gc(h,m),C=Ks(C),b=b(C),h.flags|=1,Fr(u,h,b,m),h.child;case 14:return b=h.type,C=To(b,h.pendingProps),C=To(b.type,C),ok(u,h,b,C,m);case 15:return ik(u,h,h.type,h.pendingProps,m);case 17:return b=h.type,C=h.pendingProps,C=h.elementType===b?C:To(b,C),Bp(u,h),h.tag=1,rs(b)?(u=!0,wp(h)):u=!1,gc(h,m),Q$(h,b,C),$0(h,b,C,m),N0(null,h,b,!0,u,m);case 19:return pk(u,h,m);case 22:return ak(u,h,m)}throw Error(n(156,h.tag))};function zk(u,h){return Dl(u,h)}function X4(u,h,m,b){this.tag=u,this.key=m,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=h,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=b,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ys(u,h,m,b){return new X4(u,h,m,b)}function X0(u){return u=u.prototype,!(!u||!u.isReactComponent)}function q4(u){if(typeof u=="function")return X0(u)?1:0;if(u!=null){if(u=u.$$typeof,u===re)return 11;if(u===ge)return 14}return 2}function el(u,h){var m=u.alternate;return m===null?(m=Ys(u.tag,h,u.key,u.mode),m.elementType=u.elementType,m.type=u.type,m.stateNode=u.stateNode,m.alternate=u,u.alternate=m):(m.pendingProps=h,m.type=u.type,m.flags=0,m.subtreeFlags=0,m.deletions=null),m.flags=u.flags&14680064,m.childLanes=u.childLanes,m.lanes=u.lanes,m.child=u.child,m.memoizedProps=u.memoizedProps,m.memoizedState=u.memoizedState,m.updateQueue=u.updateQueue,h=u.dependencies,m.dependencies=h===null?null:{lanes:h.lanes,firstContext:h.firstContext},m.sibling=u.sibling,m.index=u.index,m.ref=u.ref,m}function Yp(u,h,m,b,C,T){var D=2;if(b=u,typeof u=="function")X0(u)&&(D=1);else if(typeof u=="string")D=5;else e:switch(u){case F:return nu(m.children,C,T,h);case B:D=8,C|=8;break;case M:return u=Ys(12,m,h,C|2),u.elementType=M,u.lanes=T,u;case ie:return u=Ys(13,m,h,C),u.elementType=ie,u.lanes=T,u;case me:return u=Ys(19,m,h,C),u.elementType=me,u.lanes=T,u;case $e:return Qp(m,C,T,h);default:if(typeof u=="object"&&u!==null)switch(u.$$typeof){case V:D=10;break e;case P:D=9;break e;case re:D=11;break e;case ge:D=14;break e;case ve:D=16,b=null;break e}throw Error(n(130,u==null?u:typeof u,""))}return h=Ys(D,m,h,C),h.elementType=u,h.type=b,h.lanes=T,h}function nu(u,h,m,b){return u=Ys(7,u,b,h),u.lanes=m,u}function Qp(u,h,m,b){return u=Ys(22,u,b,h),u.elementType=$e,u.lanes=m,u.stateNode={isHidden:!1},u}function q0(u,h,m){return u=Ys(6,u,null,h),u.lanes=m,u}function Y0(u,h,m){return h=Ys(4,u.children!==null?u.children:[],u.key,h),h.lanes=m,h.stateNode={containerInfo:u.containerInfo,pendingChildren:null,implementation:u.implementation},h}function Y4(u,h,m,b,C){this.tag=h,this.containerInfo=u,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=Li(0),this.expirationTimes=Li(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Li(0),this.identifierPrefix=b,this.onRecoverableError=C,this.mutableSourceEagerHydrationData=null}function Q0(u,h,m,b,C,T,D,H,Q){return u=new Y4(u,h,m,H,Q),h===1?(h=1,T===!0&&(h|=8)):h=0,T=Ys(3,null,null,h),u.current=T,T.stateNode=u,T.memoizedState={element:b,isDehydrated:m,cache:null,transitions:null,pendingSuspenseBoundaries:null},c0(T),u}function Q4(u,h,m){var b=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:O,key:b==null?null:""+b,children:u,containerInfo:h,implementation:m}}function Bk(u){if(!u)return Ga;u=u._reactInternals;e:{if(Bn(u)!==u||u.tag!==1)throw Error(n(170));var h=u;do{switch(h.tag){case 3:h=h.stateNode.context;break e;case 1:if(rs(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break e}}h=h.return}while(h!==null);throw Error(n(171))}if(u.tag===1){var m=u.type;if(rs(m))return f$(u,m,h)}return h}function Mk(u,h,m,b,C,T,D,H,Q){return u=Q0(m,b,!0,u,C,T,D,H,Q),u.context=Bk(null),m=u.current,b=Lr(),C=Za(m),T=Ki(b,C),T.callback=h??null,Xa(m,T,C),u.current.lanes=C,qo(u,C,b),is(u,b),u}function Zp(u,h,m,b){var C=h.current,T=Lr(),D=Za(C);return m=Bk(m),h.context===null?h.context=m:h.pendingContext=m,h=Ki(T,D),h.payload={element:u},b=b===void 0?null:b,b!==null&&(h.callback=b),u=Xa(C,h,D),u!==null&&(Eo(u,C,D,T),Ep(u,C,D)),D}function Jp(u){if(u=u.current,!u.child)return null;switch(u.child.tag){case 5:return u.child.stateNode;default:return u.child.stateNode}}function Vk(u,h){if(u=u.memoizedState,u!==null&&u.dehydrated!==null){var m=u.retryLane;u.retryLane=m!==0&&m<h?m:h}}function Z0(u,h){Vk(u,h),(u=u.alternate)&&Vk(u,h)}function Z4(){return null}var Wk=typeof reportError=="function"?reportError:function(u){console.error(u)};function J0(u){this._internalRoot=u}em.prototype.render=J0.prototype.render=function(u){var h=this._internalRoot;if(h===null)throw Error(n(409));Zp(u,h,null,null)},em.prototype.unmount=J0.prototype.unmount=function(){var u=this._internalRoot;if(u!==null){this._internalRoot=null;var h=u.containerInfo;Jl(function(){Zp(null,u,null,null)}),h[Wi]=null}};function em(u){this._internalRoot=u}em.prototype.unstable_scheduleHydration=function(u){if(u){var h=Yo();u={blockedOn:null,target:u,priority:h};for(var m=0;m<Jr.length&&h!==0&&h<Jr[m].priority;m++);Jr.splice(m,0,u),m===0&&wo(u)}};function e1(u){return!(!u||u.nodeType!==1&&u.nodeType!==9&&u.nodeType!==11)}function tm(u){return!(!u||u.nodeType!==1&&u.nodeType!==9&&u.nodeType!==11&&(u.nodeType!==8||u.nodeValue!==" react-mount-point-unstable "))}function Uk(){}function J4(u,h,m,b,C){if(C){if(typeof b=="function"){var T=b;b=function(){var de=Jp(D);T.call(de)}}var D=Mk(h,b,u,0,null,!1,!1,"",Uk);return u._reactRootContainer=D,u[Wi]=D.current,Yd(u.nodeType===8?u.parentNode:u),Jl(),D}for(;C=u.lastChild;)u.removeChild(C);if(typeof b=="function"){var H=b;b=function(){var de=Jp(Q);H.call(de)}}var Q=Q0(u,0,!1,null,null,!1,!1,"",Uk);return u._reactRootContainer=Q,u[Wi]=Q.current,Yd(u.nodeType===8?u.parentNode:u),Jl(function(){Zp(h,Q,m,b)}),Q}function nm(u,h,m,b,C){var T=m._reactRootContainer;if(T){var D=T;if(typeof C=="function"){var H=C;C=function(){var Q=Jp(D);H.call(Q)}}Zp(h,D,u,C)}else D=J4(m,h,u,C,b);return Jp(D)}zi=function(u){switch(u.tag){case 3:var h=u.stateNode;if(h.current.memoizedState.isDehydrated){var m=Xo(h.pendingLanes);m!==0&&(Ll(h,m|1),is(h,Ut()),(Et&6)===0&&(wc=Ut()+500,Ha()))}break;case 13:Jl(function(){var b=Hi(u,1);if(b!==null){var C=Lr();Eo(b,u,1,C)}}),Z0(u,1)}},Ba=function(u){if(u.tag===13){var h=Hi(u,134217728);if(h!==null){var m=Lr();Eo(h,u,134217728,m)}Z0(u,134217728)}},Bi=function(u){if(u.tag===13){var h=Za(u),m=Hi(u,h);if(m!==null){var b=Lr();Eo(m,u,h,b)}Z0(u,h)}},Yo=function(){return St},Qu=function(u,h){var m=St;try{return St=u,h()}finally{St=m}},Ms=function(u,h,m){switch(h){case"input":if(Ia(u,m),h=m.name,m.type==="radio"&&h!=null){for(m=u;m.parentNode;)m=m.parentNode;for(m=m.querySelectorAll("input[name="+JSON.stringify(""+h)+'][type="radio"]'),h=0;h<m.length;h++){var b=m[h];if(b!==u&&b.form===u.form){var C=vp(b);if(!C)throw Error(n(90));ki(b),Ia(b,C)}}}break;case"textarea":Ss(u,m);break;case"select":h=m.value,h!=null&&ws(u,!!m.multiple,h,!1)}},Aa=G0,Pl=Jl;var eL={usingClientEntryPoint:!1,Events:[Jd,lc,vp,_l,Vs,G0]},fh={findFiberByHostInstance:Gl,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},tL={bundleType:fh.bundleType,version:fh.version,rendererPackageName:fh.rendererPackageName,rendererConfig:fh.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:R.ReactCurrentDispatcher,findHostInstanceByFiber:function(u){return u=Oa(u),u===null?null:u.stateNode},findFiberByHostInstance:fh.findFiberByHostInstance||Z4,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var rm=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!rm.isDisabled&&rm.supportsFiber)try{Vn=rm.inject(tL),tr=rm}catch{}}return as.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=eL,as.createPortal=function(u,h){var m=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!e1(h))throw Error(n(200));return Q4(u,h,null,m)},as.createRoot=function(u,h){if(!e1(u))throw Error(n(299));var m=!1,b="",C=Wk;return h!=null&&(h.unstable_strictMode===!0&&(m=!0),h.identifierPrefix!==void 0&&(b=h.identifierPrefix),h.onRecoverableError!==void 0&&(C=h.onRecoverableError)),h=Q0(u,1,!1,null,null,m,!1,b,C),u[Wi]=h.current,Yd(u.nodeType===8?u.parentNode:u),new J0(h)},as.findDOMNode=function(u){if(u==null)return null;if(u.nodeType===1)return u;var h=u._reactInternals;if(h===void 0)throw typeof u.render=="function"?Error(n(188)):(u=Object.keys(u).join(","),Error(n(268,u)));return u=Oa(h),u=u===null?null:u.stateNode,u},as.flushSync=function(u){return Jl(u)},as.hydrate=function(u,h,m){if(!tm(h))throw Error(n(200));return nm(null,u,h,!0,m)},as.hydrateRoot=function(u,h,m){if(!e1(u))throw Error(n(405));var b=m!=null&&m.hydratedSources||null,C=!1,T="",D=Wk;if(m!=null&&(m.unstable_strictMode===!0&&(C=!0),m.identifierPrefix!==void 0&&(T=m.identifierPrefix),m.onRecoverableError!==void 0&&(D=m.onRecoverableError)),h=Mk(h,null,u,1,m??null,C,!1,T,D),u[Wi]=h.current,Yd(u),b)for(u=0;u<b.length;u++)m=b[u],C=m._getVersion,C=C(m._source),h.mutableSourceEagerHydrationData==null?h.mutableSourceEagerHydrationData=[m,C]:h.mutableSourceEagerHydrationData.push(m,C);return new em(h)},as.render=function(u,h,m){if(!tm(h))throw Error(n(200));return nm(null,u,h,!1,m)},as.unmountComponentAtNode=function(u){if(!tm(u))throw Error(n(40));return u._reactRootContainer?(Jl(function(){nm(null,null,u,!1,function(){u._reactRootContainer=null,u[Wi]=null})}),!0):!1},as.unstable_batchedUpdates=G0,as.unstable_renderSubtreeIntoContainer=function(u,h,m,b){if(!tm(m))throw Error(n(200));if(u==null||u._reactInternals===void 0)throw Error(n(38));return nm(u,h,m,!1,b)},as.version="18.3.1-next-f1338f8080-20240426",as}var Zk;function LE(){if(Zk)return r1.exports;Zk=1;function t(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t)}catch(e){console.error(e)}}return t(),r1.exports=uL(),r1.exports}var Jk;function cL(){if(Jk)return sm;Jk=1;var t=LE();return sm.createRoot=t.createRoot,sm.hydrateRoot=t.hydrateRoot,sm}var dL=cL();const hL=Af(dL),fL="/tapfit-app/assets/body_measurement-Be1IKEjH.png";function pL(){return!!(globalThis!=null&&globalThis.document)}function mL(t,...e){if(t==null)throw new TypeError("Cannot convert undefined or null to object");const n={...t};for(const r of e)if(r!=null)for(const s in r)Object.prototype.hasOwnProperty.call(r,s)&&(s in n&&delete n[s],n[s]=r[s]);return n}const ii=t=>t?"":void 0,i1=t=>t?!0:void 0;function px(t){return Array.isArray(t)}function Vr(t){const e=typeof t;return t!=null&&(e==="object"||e==="function")&&!px(t)}function gL(t){const e=t==null?0:t.length;return e?t[e-1]:void 0}function yL(t){const e=parseFloat(t.toString()),n=t.toString().replace(String(e),"");return{unitless:!n,value:e,unit:n}}function mx(t){if(t==null)return t;const{unitless:e}=yL(t);return e||typeof t=="number"?`${t}px`:t}const zE=(t,e)=>parseInt(t[1],10)>parseInt(e[1],10)?1:-1,Uv=t=>Object.fromEntries(Object.entries(t).sort(zE));function e3(t){const e=Uv(t);return Object.assign(Object.values(e),e)}function xL(t){const e=Object.keys(Uv(t));return new Set(e)}function t3(t){if(!t)return t;t=mx(t)??t;const e=-.02;return typeof t=="number"?`${t+e}`:t.replace(/(\d+\.?\d*)/u,n=>`${parseFloat(n)+e}`)}function $h(t,e){const n=["@media screen"];return t&&n.push("and",`(min-width: ${mx(t)})`),e&&n.push("and",`(max-width: ${mx(e)})`),n.join(" ")}function vL(t){if(!t)return null;t.base=t.base??"0px";const e=e3(t),n=Object.entries(t).sort(zE).map(([o,i],a,l)=>{let[,c]=l[a+1]??[];return c=parseFloat(c)>0?t3(c):void 0,{_minW:t3(i),breakpoint:o,minW:i,maxW:c,maxWQuery:$h(null,c),minWQuery:$h(i),minMaxQuery:$h(i,c)}}),r=xL(t),s=Array.from(r.values());return{keys:r,normalized:e,isResponsive(o){const i=Object.keys(o);return i.length>0&&i.every(a=>r.has(a))},asObject:Uv(t),asArray:e3(t),details:n,get(o){return n.find(i=>i.breakpoint===o)},media:[null,...e.map(o=>$h(o)).slice(1)],toArrayValue(o){if(!Vr(o))throw new Error("toArrayValue: value must be an object");const i=s.map(a=>o[a]??null);for(;gL(i)===null;)i.pop();return i},toObjectValue(o){if(!Array.isArray(o))throw new Error("toObjectValue: value must be an array");return o.reduce((i,a,l)=>{const c=s[l];return c!=null&&a!=null&&(i[c]=a),i},{})}}}function n3(...t){return function(n){t.some(r=>(r==null||r(n),n==null?void 0:n.defaultPrevented))}}function jv(t){return J.Children.toArray(t).filter(e=>J.isValidElement(e))}function Vg(t){const e=Object.assign({},t);for(let n in e)e[n]===void 0&&delete e[n];return e}function bL(t,e){return`${t} returned \`undefined\`. Seems you forgot to wrap component within ${e}`}function Hr(t={}){const{name:e,strict:n=!0,hookName:r="useContext",providerName:s="Provider",errorMessage:o,defaultValue:i}=t,a=J.createContext(i);a.displayName=e;function l(){var d;const c=J.useContext(a);if(!c&&n){const f=new Error(o??bL(r,s));throw f.name="ContextError",(d=Error.captureStackTrace)==null||d.call(Error,f,l),f}return c}return[a.Provider,l,a]}const Lt=(...t)=>t.filter(Boolean).join(" ");function wL(t,e,n,r){const s=typeof e=="string"?e.split("."):[e];for(r=0;r<s.length&&t;r+=1)t=t[s[r]];return t===void 0?n:t}const SL=t=>{const e=new WeakMap;return(r,s,o,i)=>{if(typeof r>"u")return t(r,s,o);e.has(r)||e.set(r,new Map);const a=e.get(r);if(a.has(s))return a.get(s);const l=t(r,s,o,i);return a.set(s,l),l}},BE=SL(wL),CL=t=>t.default||t;function Gv(t,e=[]){const n=Object.assign({},t);for(const r of e)r in n&&delete n[r];return n}function $L(t,e){const n={};for(const r of e)r in t&&(n[r]=t[r]);return n}function Hv(t,e){return Array.isArray(t)?t.map(n=>n===null?null:e(n)):Vr(t)?Object.keys(t).reduce((n,r)=>(n[r]=e(t[r]),n),{}):t!=null?e(t):null}const kL=t=>typeof t=="function";function ro(t,...e){return kL(t)?t(...e):t}function TL(t,...e){const n=Object.getOwnPropertyDescriptors(t),r=Object.keys(n),s=i=>{const a={};for(let l=0;l<i.length;l++){const c=i[l];n[c]&&(Object.defineProperty(a,c,n[c]),delete n[c])}return a},o=i=>s(Array.isArray(i)?i:r.filter(i));return e.map(o).concat(s(r))}function r3(t,e,n={}){const{stop:r,getKey:s}=n;function o(i,a=[]){if(Vr(i)||Array.isArray(i)){const l={};for(const[c,d]of Object.entries(i)){const f=(s==null?void 0:s(c))??c,p=[...a,f];if(r!=null&&r(i,p))return e(i,a);l[f]=o(d,p)}return l}return e(i,a)}return o(t)}var kh={exports:{}};kh.exports;var s3;function IL(){return s3||(s3=1,function(t,e){var n=200,r="__lodash_hash_undefined__",s=800,o=16,i=9007199254740991,a="[object Arguments]",l="[object Array]",c="[object AsyncFunction]",d="[object Boolean]",f="[object Date]",p="[object Error]",g="[object Function]",y="[object GeneratorFunction]",x="[object Map]",w="[object Number]",S="[object Null]",$="[object Object]",I="[object Proxy]",R="[object RegExp]",_="[object Set]",O="[object String]",F="[object Undefined]",B="[object WeakMap]",M="[object ArrayBuffer]",V="[object DataView]",P="[object Float32Array]",re="[object Float64Array]",ie="[object Int8Array]",me="[object Int16Array]",ge="[object Int32Array]",ve="[object Uint8Array]",$e="[object Uint8ClampedArray]",fe="[object Uint16Array]",xe="[object Uint32Array]",ae=/[\\^$.*+?()[\]{}|]/g,q=/^\[object .+?Constructor\]$/,ue=/^(?:0|[1-9]\d*)$/,we={};we[P]=we[re]=we[ie]=we[me]=we[ge]=we[ve]=we[$e]=we[fe]=we[xe]=!0,we[a]=we[l]=we[M]=we[d]=we[V]=we[f]=we[p]=we[g]=we[x]=we[w]=we[$]=we[R]=we[_]=we[O]=we[B]=!1;var Ge=typeof Pc=="object"&&Pc&&Pc.Object===Object&&Pc,et=typeof self=="object"&&self&&self.Object===Object&&self,tt=Ge||et||Function("return this")(),Tt=e&&!e.nodeType&&e,dt=Tt&&!0&&t&&!t.nodeType&&t,vt=dt&&dt.exports===Tt,rn=vt&&Ge.process,Rr=function(){try{var U=dt&&dt.require&&dt.require("util").types;return U||rn&&rn.binding&&rn.binding("util")}catch{}}(),ki=Rr&&Rr.isTypedArray;function zt(U,ee,he){switch(he.length){case 0:return U.call(ee);case 1:return U.call(ee,he[0]);case 2:return U.call(ee,he[0],he[1]);case 3:return U.call(ee,he[0],he[1],he[2])}return U.apply(ee,he)}function sn(U,ee){for(var he=-1,Fe=Array(U);++he<U;)Fe[he]=ee(he);return Fe}function _r(U){return function(ee){return U(ee)}}function Vo(U,ee){return U==null?void 0:U[ee]}function Ia(U,ee){return function(he){return U(ee(he))}}var El=Array.prototype,Na=Function.prototype,bs=Object.prototype,ws=tt["__core-js_shared__"],zs=Na.toString,Xr=bs.hasOwnProperty,Ss=function(){var U=/[^.]+$/.exec(ws&&ws.keys&&ws.keys.IE_PROTO||"");return U?"Symbol(src)_1."+U:""}(),Ea=bs.toString,Ti=zs.call(Object),Ii=RegExp("^"+zs.call(Xr).replace(ae,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),go=vt?tt.Buffer:void 0,Ra=tt.Symbol,Wo=tt.Uint8Array;go&&go.allocUnsafe;var yo=Ia(Object.getPrototypeOf,Object),Rl=Object.create,Uo=bs.propertyIsEnumerable,_a=El.splice,Bs=Ra?Ra.toStringTag:void 0,jo=function(){try{var U=La(Object,"defineProperty");return U({},"",{}),U}catch{}}(),Pa=go?go.isBuffer:void 0,Go=Math.max,Cs=Date.now,Ms=La(tt,"Map"),Pr=La(Object,"create"),xo=function(){function U(){}return function(ee){if(!es(ee))return{};if(Rl)return Rl(ee);U.prototype=ee;var he=new U;return U.prototype=void 0,he}}();function qr(U){var ee=-1,he=U==null?0:U.length;for(this.clear();++ee<he;){var Fe=U[ee];this.set(Fe[0],Fe[1])}}function _l(){this.__data__=Pr?Pr(null):{},this.size=0}function Vs(U){var ee=this.has(U)&&delete this.__data__[U];return this.size-=ee?1:0,ee}function Aa(U){var ee=this.__data__;if(Pr){var he=ee[U];return he===r?void 0:he}return Xr.call(ee,U)?ee[U]:void 0}function Pl(U){var ee=this.__data__;return Pr?ee[U]!==void 0:Xr.call(ee,U)}function Ho(U,ee){var he=this.__data__;return this.size+=this.has(U)?0:1,he[U]=Pr&&ee===void 0?r:ee,this}qr.prototype.clear=_l,qr.prototype.delete=Vs,qr.prototype.get=Aa,qr.prototype.has=Pl,qr.prototype.set=Ho;function Jn(U){var ee=-1,he=U==null?0:U.length;for(this.clear();++ee<he;){var Fe=U[ee];this.set(Fe[0],Fe[1])}}function Ni(){this.__data__=[],this.size=0}function Ws(U){var ee=this.__data__,he=Us(ee,U);if(he<0)return!1;var Fe=ee.length-1;return he==Fe?ee.pop():_a.call(ee,he,1),--this.size,!0}function Ei(U){var ee=this.__data__,he=Us(ee,U);return he<0?void 0:ee[he][1]}function $s(U){return Us(this.__data__,U)>-1}function Ar(U,ee){var he=this.__data__,Fe=Us(he,U);return Fe<0?(++this.size,he.push([U,ee])):he[Fe][1]=ee,this}Jn.prototype.clear=Ni,Jn.prototype.delete=Ws,Jn.prototype.get=Ei,Jn.prototype.has=$s,Jn.prototype.set=Ar;function Yr(U){var ee=-1,he=U==null?0:U.length;for(this.clear();++ee<he;){var Fe=U[ee];this.set(Fe[0],Fe[1])}}function Xt(){this.size=0,this.__data__={hash:new qr,map:new(Ms||Jn),string:new qr}}function dr(U){var ee=wn(this,U).delete(U);return this.size-=ee?1:0,ee}function Al(U){return wn(this,U).get(U)}function zd(U){return wn(this,U).has(U)}function Da(U,ee){var he=wn(this,U),Fe=he.size;return he.set(U,ee),this.size+=he.size==Fe?0:1,this}Yr.prototype.clear=Xt,Yr.prototype.delete=dr,Yr.prototype.get=Al,Yr.prototype.has=zd,Yr.prototype.set=Da;function Bn(U){var ee=this.__data__=new Jn(U);this.size=ee.size}function Ri(){this.__data__=new Jn,this.size=0}function Ko(U){var ee=this.__data__,he=ee.delete(U);return this.size=ee.size,he}function qu(U){return this.__data__.get(U)}function Oa(U){return this.__data__.has(U)}function Fa(U,ee){var he=this.__data__;if(he instanceof Jn){var Fe=he.__data__;if(!Ms||Fe.length<n-1)return Fe.push([U,ee]),this.size=++he.size,this;he=this.__data__=new Yr(Fe)}return he.set(U,ee),this.size=he.size,this}Bn.prototype.clear=Ri,Bn.prototype.delete=Ko,Bn.prototype.get=qu,Bn.prototype.has=Oa,Bn.prototype.set=Fa;function Dl(U,ee){var he=fr(U),Fe=!he&&Zr(U),ht=!he&&!Fe&&Qo(U),It=!he&&!Fe&&!ht&&wo(U),Nt=he||Fe||ht||It,at=Nt?sn(U.length,String):[],_t=at.length;for(var jn in U)Nt&&(jn=="length"||ht&&(jn=="offset"||jn=="parent")||It&&(jn=="buffer"||jn=="byteLength"||jn=="byteOffset")||Li(jn,_t))||at.push(jn);return at}function Mn(U,ee,he){(he!==void 0&&!bo(U[ee],he)||he===void 0&&!(ee in U))&&Ut(U,ee,he)}function Qr(U,ee,he){var Fe=U[ee];(!(Xr.call(U,ee)&&bo(Fe,he))||he===void 0&&!(ee in U))&&Ut(U,ee,he)}function Us(U,ee){for(var he=U.length;he--;)if(bo(U[he][0],ee))return he;return-1}function Ut(U,ee,he){ee=="__proto__"&&jo?jo(U,ee,{configurable:!0,enumerable:!0,value:he,writable:!0}):U[ee]=he}var Ol=Oi();function vo(U){return U==null?U===void 0?F:S:Bs&&Bs in Object(U)?za(U):zi(U)}function _i(U){return ts(U)&&vo(U)==a}function er(U){if(!es(U)||Ll(U))return!1;var ee=Jr(U)?Ii:q;return ee.test(Bl(U))}function Yu(U){return ts(U)&&Zu(U.length)&&!!we[vo(U)]}function Pi(U){if(!es(U))return zl(U);var ee=St(U),he=[];for(var Fe in U)Fe=="constructor"&&(ee||!Xr.call(U,Fe))||he.push(Fe);return he}function Vn(U,ee,he,Fe,ht){U!==ee&&Ol(ee,function(It,Nt){if(ht||(ht=new Bn),es(It))tr(U,ee,Nt,he,Vn,Fe,ht);else{var at=Fe?Fe(Bi(U,Nt),It,Nt+"",U,ee,ht):void 0;at===void 0&&(at=It),Mn(U,Nt,at)}},Ml)}function tr(U,ee,he,Fe,ht,It,Nt){var at=Bi(U,he),_t=Bi(ee,he),jn=Nt.get(_t);if(jn){Mn(U,he,jn);return}var Gn=It?It(at,_t,he+"",U,ee,Nt):void 0,Dr=Gn===void 0;if(Dr){var Co=fr(_t),Ma=!Co&&Qo(_t),Rn=!Co&&!Ma&&wo(_t);Gn=_t,Co||Ma||Rn?fr(at)?Gn=at:Mi(at)?Gn=Ai(at):Ma?(Dr=!1,Gn=Fl(_t)):Rn?(Dr=!1,Gn=Vd(_t)):Gn=[]:Ju(_t)||Zr(_t)?(Gn=at,Zr(at)?Gn=Un(at):(!es(at)||Jr(at))&&(Gn=Fi(_t))):Dr=!1}Dr&&(Nt.set(_t,Gn),ht(Gn,_t,Fe,It,Nt),Nt.delete(_t)),Mn(U,he,Gn)}function Bd(U,ee){return Yo(Ba(U,ee,So),U+"")}var hr=jo?function(U,ee){return jo(U,"toString",{configurable:!0,enumerable:!1,value:Zo(ee),writable:!0})}:So;function Fl(U,ee){return U.slice()}function Md(U){var ee=new U.constructor(U.byteLength);return new Wo(ee).set(new Wo(U)),ee}function Vd(U,ee){var he=Md(U.buffer);return new U.constructor(he,U.byteOffset,U.length)}function Ai(U,ee){var he=-1,Fe=U.length;for(ee||(ee=Array(Fe));++he<Fe;)ee[he]=U[he];return ee}function Di(U,ee,he,Fe){var ht=!he;he||(he={});for(var It=-1,Nt=ee.length;++It<Nt;){var at=ee[It],_t=void 0;_t===void 0&&(_t=U[at]),ht?Ut(he,at,_t):Qr(he,at,_t)}return he}function Xo(U){return Bd(function(ee,he){var Fe=-1,ht=he.length,It=ht>1?he[ht-1]:void 0,Nt=ht>2?he[2]:void 0;for(It=U.length>3&&typeof It=="function"?(ht--,It):void 0,Nt&&qo(he[0],he[1],Nt)&&(It=ht<3?void 0:It,ht=1),ee=Object(ee);++Fe<ht;){var at=he[Fe];at&&U(ee,at,Fe,It)}return ee})}function Oi(U){return function(ee,he,Fe){for(var ht=-1,It=Object(ee),Nt=Fe(ee),at=Nt.length;at--;){var _t=Nt[++ht];if(he(It[_t],_t,It)===!1)break}return ee}}function wn(U,ee){var he=U.__data__;return Wd(ee)?he[typeof ee=="string"?"string":"hash"]:he.map}function La(U,ee){var he=Vo(U,ee);return er(he)?he:void 0}function za(U){var ee=Xr.call(U,Bs),he=U[Bs];try{U[Bs]=void 0;var Fe=!0}catch{}var ht=Ea.call(U);return Fe&&(ee?U[Bs]=he:delete U[Bs]),ht}function Fi(U){return typeof U.constructor=="function"&&!St(U)?xo(yo(U)):{}}function Li(U,ee){var he=typeof U;return ee=ee??i,!!ee&&(he=="number"||he!="symbol"&&ue.test(U))&&U>-1&&U%1==0&&U<ee}function qo(U,ee,he){if(!es(he))return!1;var Fe=typeof ee;return(Fe=="number"?Wn(he)&&Li(ee,he.length):Fe=="string"&&ee in he)?bo(he[ee],U):!1}function Wd(U){var ee=typeof U;return ee=="string"||ee=="number"||ee=="symbol"||ee=="boolean"?U!=="__proto__":U===null}function Ll(U){return!!Ss&&Ss in U}function St(U){var ee=U&&U.constructor,he=typeof ee=="function"&&ee.prototype||bs;return U===he}function zl(U){var ee=[];if(U!=null)for(var he in Object(U))ee.push(he);return ee}function zi(U){return Ea.call(U)}function Ba(U,ee,he){return ee=Go(ee===void 0?U.length-1:ee,0),function(){for(var Fe=arguments,ht=-1,It=Go(Fe.length-ee,0),Nt=Array(It);++ht<It;)Nt[ht]=Fe[ee+ht];ht=-1;for(var at=Array(ee+1);++ht<ee;)at[ht]=Fe[ht];return at[ee]=he(Nt),zt(U,this,at)}}function Bi(U,ee){if(!(ee==="constructor"&&typeof U[ee]=="function")&&ee!="__proto__")return U[ee]}var Yo=Qu(hr);function Qu(U){var ee=0,he=0;return function(){var Fe=Cs(),ht=o-(Fe-he);if(he=Fe,ht>0){if(++ee>=s)return arguments[0]}else ee=0;return U.apply(void 0,arguments)}}function Bl(U){if(U!=null){try{return zs.call(U)}catch{}try{return U+""}catch{}}return""}function bo(U,ee){return U===ee||U!==U&&ee!==ee}var Zr=_i(function(){return arguments}())?_i:function(U){return ts(U)&&Xr.call(U,"callee")&&!Uo.call(U,"callee")},fr=Array.isArray;function Wn(U){return U!=null&&Zu(U.length)&&!Jr(U)}function Mi(U){return ts(U)&&Wn(U)}var Qo=Pa||js;function Jr(U){if(!es(U))return!1;var ee=vo(U);return ee==g||ee==y||ee==c||ee==I}function Zu(U){return typeof U=="number"&&U>-1&&U%1==0&&U<=i}function es(U){var ee=typeof U;return U!=null&&(ee=="object"||ee=="function")}function ts(U){return U!=null&&typeof U=="object"}function Ju(U){if(!ts(U)||vo(U)!=$)return!1;var ee=yo(U);if(ee===null)return!0;var he=Xr.call(ee,"constructor")&&ee.constructor;return typeof he=="function"&&he instanceof he&&zs.call(he)==Ti}var wo=ki?_r(ki):Yu;function Un(U){return Di(U,Ml(U))}function Ml(U){return Wn(U)?Dl(U):Pi(U)}var Ud=Xo(function(U,ee,he,Fe){Vn(U,ee,he,Fe)});function Zo(U){return function(){return U}}function So(U){return U}function js(){return!1}t.exports=Ud}(kh,kh.exports)),kh.exports}var NL=IL();const so=Af(NL);function EL(t,e=[]){const n=J.useRef(t);return J.useEffect(()=>{n.current=t}),J.useCallback((...r)=>{var s;return(s=n.current)==null?void 0:s.call(n,...r)},e)}const ng=globalThis!=null&&globalThis.document?J.useLayoutEffect:J.useEffect,o3=(t,e)=>{const n=J.useRef(!1),r=J.useRef(!1);J.useEffect(()=>{if(n.current&&r.current)return t();r.current=!0},e),J.useEffect(()=>(n.current=!0,()=>{n.current=!1}),[])};function RL(t,e){if(t!=null){if(typeof t=="function"){t(e);return}try{t.current=e}catch{throw new Error(`Cannot assign value '${e}' to ref '${t}'`)}}}function gx(...t){return e=>{t.forEach(n=>{RL(n,e)})}}function _L(...t){return J.useMemo(()=>gx(...t),t)}function PL(t,e){const n=EL(t);J.useEffect(()=>{if(e==null)return;let r=null;return r=window.setTimeout(()=>{n()},e),()=>{r&&window.clearTimeout(r)}},[e,n])}const Dn={open:(t,e)=>`${t}[data-open], ${t}[open], ${t}[data-state=open] ${e}`,closed:(t,e)=>`${t}[data-closed], ${t}[data-state=closed] ${e}`,hover:(t,e)=>`${t}:hover ${e}, ${t}[data-hover] ${e}`,focus:(t,e)=>`${t}:focus ${e}, ${t}[data-focus] ${e}`,focusVisible:(t,e)=>`${t}:focus-visible ${e}`,focusWithin:(t,e)=>`${t}:focus-within ${e}`,active:(t,e)=>`${t}:active ${e}, ${t}[data-active] ${e}`,disabled:(t,e)=>`${t}:disabled ${e}, ${t}[data-disabled] ${e}`,invalid:(t,e)=>`${t}:invalid ${e}, ${t}[data-invalid] ${e}`,checked:(t,e)=>`${t}:checked ${e}, ${t}[data-checked] ${e}`,placeholderShown:(t,e)=>`${t}:placeholder-shown ${e}`},si=t=>ME(e=>t(e,"&"),"[role=group]","[data-group]",".group"),Yi=t=>ME(e=>t(e,"~ &"),"[data-peer]",".peer"),ME=(t,...e)=>e.map(t).join(", "),jc={_hover:"&:hover, &[data-hover]",_active:"&:active, &[data-active]",_focus:"&:focus, &[data-focus]",_highlighted:"&[data-highlighted]",_focusWithin:"&:focus-within, &[data-focus-within]",_focusVisible:"&:focus-visible, &[data-focus-visible]",_disabled:"&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]",_readOnly:"&[aria-readonly=true], &[readonly], &[data-readonly]",_before:"&::before",_after:"&::after",_empty:"&:empty, &[data-empty]",_expanded:"&[aria-expanded=true], &[data-expanded], &[data-state=expanded]",_checked:"&[aria-checked=true], &[data-checked], &[data-state=checked]",_grabbed:"&[aria-grabbed=true], &[data-grabbed]",_pressed:"&[aria-pressed=true], &[data-pressed]",_invalid:"&[aria-invalid=true], &[data-invalid]",_valid:"&[data-valid], &[data-state=valid]",_loading:"&[data-loading], &[aria-busy=true]",_selected:"&[aria-selected=true], &[data-selected]",_hidden:"&[hidden], &[data-hidden]",_autofill:"&:-webkit-autofill",_even:"&:nth-of-type(even)",_odd:"&:nth-of-type(odd)",_first:"&:first-of-type",_firstLetter:"&::first-letter",_last:"&:last-of-type",_notFirst:"&:not(:first-of-type)",_notLast:"&:not(:last-of-type)",_visited:"&:visited",_activeLink:"&[aria-current=page]",_activeStep:"&[aria-current=step]",_indeterminate:"&:indeterminate, &[aria-checked=mixed], &[data-indeterminate], &[data-state=indeterminate]",_groupOpen:si(Dn.open),_groupClosed:si(Dn.closed),_groupHover:si(Dn.hover),_peerHover:Yi(Dn.hover),_groupFocus:si(Dn.focus),_peerFocus:Yi(Dn.focus),_groupFocusVisible:si(Dn.focusVisible),_peerFocusVisible:Yi(Dn.focusVisible),_groupActive:si(Dn.active),_peerActive:Yi(Dn.active),_groupDisabled:si(Dn.disabled),_peerDisabled:Yi(Dn.disabled),_groupInvalid:si(Dn.invalid),_peerInvalid:Yi(Dn.invalid),_groupChecked:si(Dn.checked),_peerChecked:Yi(Dn.checked),_groupFocusWithin:si(Dn.focusWithin),_peerFocusWithin:Yi(Dn.focusWithin),_peerPlaceholderShown:Yi(Dn.placeholderShown),_placeholder:"&::placeholder, &[data-placeholder]",_placeholderShown:"&:placeholder-shown, &[data-placeholder-shown]",_fullScreen:"&:fullscreen, &[data-fullscreen]",_selection:"&::selection",_rtl:"[dir=rtl] &, &[dir=rtl]",_ltr:"[dir=ltr] &, &[dir=ltr]",_mediaDark:"@media (prefers-color-scheme: dark)",_mediaReduceMotion:"@media (prefers-reduced-motion: reduce)",_dark:".chakra-ui-dark &:not([data-theme]),[data-theme=dark] &:not([data-theme]),&[data-theme=dark]",_light:".chakra-ui-light &:not([data-theme]),[data-theme=light] &:not([data-theme]),&[data-theme=light]",_horizontal:"&[data-orientation=horizontal]",_vertical:"&[data-orientation=vertical]",_open:"&[data-open], &[open], &[data-state=open]",_closed:"&[data-closed], &[data-state=closed]",_complete:"&[data-complete]",_incomplete:"&[data-incomplete]",_current:"&[data-current]"},VE=Object.keys(jc),AL=t=>/!(important)?$/.test(t),i3=t=>typeof t=="string"?t.replace(/!(important)?$/,"").trim():t,DL=(t,e)=>n=>{const r=String(e),s=AL(r),o=i3(r),i=t?`${t}.${o}`:o;let a=Vr(n.__cssMap)&&i in n.__cssMap?n.__cssMap[i].varRef:e;return a=i3(a),s?`${a} !important`:a};function Kv(t){const{scale:e,transform:n,compose:r}=t;return(o,i)=>{const a=DL(e,o)(i);let l=(n==null?void 0:n(a,i))??a;return r&&(l=r(l,i)),l}}const om=(...t)=>e=>t.reduce((n,r)=>r(n),e);function Qs(t,e){return n=>{const r={property:n,scale:t};return r.transform=Kv({scale:t,transform:e}),r}}const OL=({rtl:t,ltr:e})=>n=>n.direction==="rtl"?t:e;function FL(t){const{property:e,scale:n,transform:r}=t;return{scale:n,property:OL(e),transform:n?Kv({scale:n,compose:r}):r}}const WE=["rotate(var(--chakra-rotate, 0))","scaleX(var(--chakra-scale-x, 1))","scaleY(var(--chakra-scale-y, 1))","skewX(var(--chakra-skew-x, 0))","skewY(var(--chakra-skew-y, 0))"];function LL(){return["translateX(var(--chakra-translate-x, 0))","translateY(var(--chakra-translate-y, 0))",...WE].join(" ")}function zL(){return["translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)",...WE].join(" ")}const BL={"--chakra-blur":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-brightness":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-contrast":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-grayscale":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-hue-rotate":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-invert":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-saturate":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-sepia":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-drop-shadow":"var(--chakra-empty,/*!*/ /*!*/)",filter:["var(--chakra-blur)","var(--chakra-brightness)","var(--chakra-contrast)","var(--chakra-grayscale)","var(--chakra-hue-rotate)","var(--chakra-invert)","var(--chakra-saturate)","var(--chakra-sepia)","var(--chakra-drop-shadow)"].join(" ")},ML={backdropFilter:["var(--chakra-backdrop-blur)","var(--chakra-backdrop-brightness)","var(--chakra-backdrop-contrast)","var(--chakra-backdrop-grayscale)","var(--chakra-backdrop-hue-rotate)","var(--chakra-backdrop-invert)","var(--chakra-backdrop-opacity)","var(--chakra-backdrop-saturate)","var(--chakra-backdrop-sepia)"].join(" "),"--chakra-backdrop-blur":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-brightness":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-contrast":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-grayscale":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-hue-rotate":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-invert":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-opacity":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-saturate":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-sepia":"var(--chakra-empty,/*!*/ /*!*/)"};function VL(t){return{"--chakra-ring-offset-shadow":"var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)","--chakra-ring-shadow":"var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)","--chakra-ring-width":t,boxShadow:["var(--chakra-ring-offset-shadow)","var(--chakra-ring-shadow)","var(--chakra-shadow, 0 0 #0000)"].join(", ")}}const WL={"row-reverse":{space:"--chakra-space-x-reverse",divide:"--chakra-divide-x-reverse"},"column-reverse":{space:"--chakra-space-y-reverse",divide:"--chakra-divide-y-reverse"}},yx={"to-t":"to top","to-tr":"to top right","to-r":"to right","to-br":"to bottom right","to-b":"to bottom","to-bl":"to bottom left","to-l":"to left","to-tl":"to top left"},UL=new Set(Object.values(yx)),xx=new Set(["none","-moz-initial","inherit","initial","revert","unset"]),jL=t=>t.trim();function GL(t,e){if(t==null||xx.has(t))return t;if(!(vx(t)||xx.has(t)))return`url('${t}')`;const s=/(^[a-z-A-Z]+)\((.*)\)/g.exec(t),o=s==null?void 0:s[1],i=s==null?void 0:s[2];if(!o||!i)return t;const a=o.includes("-gradient")?o:`${o}-gradient`,[l,...c]=i.split(",").map(jL).filter(Boolean);if((c==null?void 0:c.length)===0)return t;const d=l in yx?yx[l]:l;c.unshift(d);const f=c.map(p=>{if(UL.has(p))return p;const g=p.indexOf(" "),[y,x]=g!==-1?[p.substr(0,g),p.substr(g+1)]:[p],w=vx(x)?x:x&&x.split(" "),S=`colors.${y}`,$=S in e.__cssMap?e.__cssMap[S].varRef:y;return w?[$,...Array.isArray(w)?w:[w]].join(" "):$});return`${a}(${f.join(", ")})`}const vx=t=>typeof t=="string"&&t.includes("(")&&t.includes(")"),HL=(t,e)=>GL(t,e??{});function KL(t){return/^var\(--.+\)$/.test(t)}const XL=t=>{const e=parseFloat(t.toString()),n=t.toString().replace(String(e),"");return{unitless:!n,value:e,unit:n}},oi=t=>e=>`${t}(${e})`,Ct={filter(t){return t!=="auto"?t:BL},backdropFilter(t){return t!=="auto"?t:ML},ring(t){return VL(Ct.px(t))},bgClip(t){return t==="text"?{color:"transparent",backgroundClip:"text"}:{backgroundClip:t}},transform(t){return t==="auto"?LL():t==="auto-gpu"?zL():t},vh(t){return t==="$100vh"?"var(--chakra-vh)":t},px(t){if(t==null)return t;const{unitless:e}=XL(t);return e||typeof t=="number"?`${t}px`:t},fraction(t){return typeof t!="number"||t>1?t:`${t*100}%`},float(t,e){const n={left:"right",right:"left"};return e.direction==="rtl"?n[t]:t},degree(t){if(KL(t)||t==null)return t;const e=typeof t=="string"&&!t.endsWith("deg");return typeof t=="number"||e?`${t}deg`:t},gradient:HL,blur:oi("blur"),opacity:oi("opacity"),brightness:oi("brightness"),contrast:oi("contrast"),dropShadow:oi("drop-shadow"),grayscale:oi("grayscale"),hueRotate:t=>oi("hue-rotate")(Ct.degree(t)),invert:oi("invert"),saturate:oi("saturate"),sepia:oi("sepia"),bgImage(t){return t==null||vx(t)||xx.has(t)?t:`url(${t})`},outline(t){const e=String(t)==="0"||String(t)==="none";return t!==null&&e?{outline:"2px solid transparent",outlineOffset:"2px"}:{outline:t}},flexDirection(t){const{space:e,divide:n}=WL[t]??{},r={flexDirection:t};return e&&(r[e]=1),n&&(r[n]=1),r}},ne={borderWidths:Qs("borderWidths"),borderStyles:Qs("borderStyles"),colors:Qs("colors"),borders:Qs("borders"),gradients:Qs("gradients",Ct.gradient),radii:Qs("radii",Ct.px),space:Qs("space",om(Ct.vh,Ct.px)),spaceT:Qs("space",om(Ct.vh,Ct.px)),degreeT(t){return{property:t,transform:Ct.degree}},prop(t,e,n){return{property:t,scale:e,...e&&{transform:Kv({scale:e,transform:n})}}},propT(t,e){return{property:t,transform:e}},sizes:Qs("sizes",om(Ct.vh,Ct.px)),sizesT:Qs("sizes",om(Ct.vh,Ct.fraction)),shadows:Qs("shadows"),logical:FL,blur:Qs("blur",Ct.blur)},Em={background:ne.colors("background"),backgroundColor:ne.colors("backgroundColor"),backgroundImage:ne.gradients("backgroundImage"),backgroundSize:!0,backgroundPosition:!0,backgroundRepeat:!0,backgroundAttachment:!0,backgroundClip:{transform:Ct.bgClip},bgSize:ne.prop("backgroundSize"),bgPosition:ne.prop("backgroundPosition"),bg:ne.colors("background"),bgColor:ne.colors("backgroundColor"),bgPos:ne.prop("backgroundPosition"),bgRepeat:ne.prop("backgroundRepeat"),bgAttachment:ne.prop("backgroundAttachment"),bgGradient:ne.gradients("backgroundImage"),bgClip:{transform:Ct.bgClip}};Object.assign(Em,{bgImage:Em.backgroundImage,bgImg:Em.backgroundImage});const Pt={border:ne.borders("border"),borderWidth:ne.borderWidths("borderWidth"),borderStyle:ne.borderStyles("borderStyle"),borderColor:ne.colors("borderColor"),borderRadius:ne.radii("borderRadius"),borderTop:ne.borders("borderTop"),borderBlockStart:ne.borders("borderBlockStart"),borderTopLeftRadius:ne.radii("borderTopLeftRadius"),borderStartStartRadius:ne.logical({scale:"radii",property:{ltr:"borderTopLeftRadius",rtl:"borderTopRightRadius"}}),borderEndStartRadius:ne.logical({scale:"radii",property:{ltr:"borderBottomLeftRadius",rtl:"borderBottomRightRadius"}}),borderTopRightRadius:ne.radii("borderTopRightRadius"),borderStartEndRadius:ne.logical({scale:"radii",property:{ltr:"borderTopRightRadius",rtl:"borderTopLeftRadius"}}),borderEndEndRadius:ne.logical({scale:"radii",property:{ltr:"borderBottomRightRadius",rtl:"borderBottomLeftRadius"}}),borderRight:ne.borders("borderRight"),borderInlineEnd:ne.borders("borderInlineEnd"),borderBottom:ne.borders("borderBottom"),borderBlockEnd:ne.borders("borderBlockEnd"),borderBottomLeftRadius:ne.radii("borderBottomLeftRadius"),borderBottomRightRadius:ne.radii("borderBottomRightRadius"),borderLeft:ne.borders("borderLeft"),borderInlineStart:{property:"borderInlineStart",scale:"borders"},borderInlineStartRadius:ne.logical({scale:"radii",property:{ltr:["borderTopLeftRadius","borderBottomLeftRadius"],rtl:["borderTopRightRadius","borderBottomRightRadius"]}}),borderInlineEndRadius:ne.logical({scale:"radii",property:{ltr:["borderTopRightRadius","borderBottomRightRadius"],rtl:["borderTopLeftRadius","borderBottomLeftRadius"]}}),borderX:ne.borders(["borderLeft","borderRight"]),borderInline:ne.borders("borderInline"),borderY:ne.borders(["borderTop","borderBottom"]),borderBlock:ne.borders("borderBlock"),borderTopWidth:ne.borderWidths("borderTopWidth"),borderBlockStartWidth:ne.borderWidths("borderBlockStartWidth"),borderTopColor:ne.colors("borderTopColor"),borderBlockStartColor:ne.colors("borderBlockStartColor"),borderTopStyle:ne.borderStyles("borderTopStyle"),borderBlockStartStyle:ne.borderStyles("borderBlockStartStyle"),borderBottomWidth:ne.borderWidths("borderBottomWidth"),borderBlockEndWidth:ne.borderWidths("borderBlockEndWidth"),borderBottomColor:ne.colors("borderBottomColor"),borderBlockEndColor:ne.colors("borderBlockEndColor"),borderBottomStyle:ne.borderStyles("borderBottomStyle"),borderBlockEndStyle:ne.borderStyles("borderBlockEndStyle"),borderLeftWidth:ne.borderWidths("borderLeftWidth"),borderInlineStartWidth:ne.borderWidths("borderInlineStartWidth"),borderLeftColor:ne.colors("borderLeftColor"),borderInlineStartColor:ne.colors("borderInlineStartColor"),borderLeftStyle:ne.borderStyles("borderLeftStyle"),borderInlineStartStyle:ne.borderStyles("borderInlineStartStyle"),borderRightWidth:ne.borderWidths("borderRightWidth"),borderInlineEndWidth:ne.borderWidths("borderInlineEndWidth"),borderRightColor:ne.colors("borderRightColor"),borderInlineEndColor:ne.colors("borderInlineEndColor"),borderRightStyle:ne.borderStyles("borderRightStyle"),borderInlineEndStyle:ne.borderStyles("borderInlineEndStyle"),borderTopRadius:ne.radii(["borderTopLeftRadius","borderTopRightRadius"]),borderBottomRadius:ne.radii(["borderBottomLeftRadius","borderBottomRightRadius"]),borderLeftRadius:ne.radii(["borderTopLeftRadius","borderBottomLeftRadius"]),borderRightRadius:ne.radii(["borderTopRightRadius","borderBottomRightRadius"])};Object.assign(Pt,{rounded:Pt.borderRadius,roundedTop:Pt.borderTopRadius,roundedTopLeft:Pt.borderTopLeftRadius,roundedTopRight:Pt.borderTopRightRadius,roundedTopStart:Pt.borderStartStartRadius,roundedTopEnd:Pt.borderStartEndRadius,roundedBottom:Pt.borderBottomRadius,roundedBottomLeft:Pt.borderBottomLeftRadius,roundedBottomRight:Pt.borderBottomRightRadius,roundedBottomStart:Pt.borderEndStartRadius,roundedBottomEnd:Pt.borderEndEndRadius,roundedLeft:Pt.borderLeftRadius,roundedRight:Pt.borderRightRadius,roundedStart:Pt.borderInlineStartRadius,roundedEnd:Pt.borderInlineEndRadius,borderStart:Pt.borderInlineStart,borderEnd:Pt.borderInlineEnd,borderTopStartRadius:Pt.borderStartStartRadius,borderTopEndRadius:Pt.borderStartEndRadius,borderBottomStartRadius:Pt.borderEndStartRadius,borderBottomEndRadius:Pt.borderEndEndRadius,borderStartRadius:Pt.borderInlineStartRadius,borderEndRadius:Pt.borderInlineEndRadius,borderStartWidth:Pt.borderInlineStartWidth,borderEndWidth:Pt.borderInlineEndWidth,borderStartColor:Pt.borderInlineStartColor,borderEndColor:Pt.borderInlineEndColor,borderStartStyle:Pt.borderInlineStartStyle,borderEndStyle:Pt.borderInlineEndStyle});const qL={color:ne.colors("color"),textColor:ne.colors("color"),fill:ne.colors("fill"),stroke:ne.colors("stroke"),accentColor:ne.colors("accentColor"),textFillColor:ne.colors("textFillColor")},rg={alignItems:!0,alignContent:!0,justifyItems:!0,justifyContent:!0,flexWrap:!0,flexDirection:{transform:Ct.flexDirection},flex:!0,flexFlow:!0,flexGrow:!0,flexShrink:!0,flexBasis:ne.sizes("flexBasis"),justifySelf:!0,alignSelf:!0,order:!0,placeItems:!0,placeContent:!0,placeSelf:!0,gap:ne.space("gap"),rowGap:ne.space("rowGap"),columnGap:ne.space("columnGap")};Object.assign(rg,{flexDir:rg.flexDirection});const eo={width:ne.sizesT("width"),inlineSize:ne.sizesT("inlineSize"),height:ne.sizes("height"),blockSize:ne.sizes("blockSize"),boxSize:ne.sizes(["width","height"]),minWidth:ne.sizes("minWidth"),minInlineSize:ne.sizes("minInlineSize"),minHeight:ne.sizes("minHeight"),minBlockSize:ne.sizes("minBlockSize"),maxWidth:ne.sizes("maxWidth"),maxInlineSize:ne.sizes("maxInlineSize"),maxHeight:ne.sizes("maxHeight"),maxBlockSize:ne.sizes("maxBlockSize"),overflow:!0,overflowX:!0,overflowY:!0,overscrollBehavior:!0,overscrollBehaviorX:!0,overscrollBehaviorY:!0,display:!0,aspectRatio:!0,hideFrom:{scale:"breakpoints",transform:(t,e)=>{var s,o;return{[`@media screen and (min-width: ${((o=(s=e.__breakpoints)==null?void 0:s.get(t))==null?void 0:o.minW)??t})`]:{display:"none"}}}},hideBelow:{scale:"breakpoints",transform:(t,e)=>{var s,o;return{[`@media screen and (max-width: ${((o=(s=e.__breakpoints)==null?void 0:s.get(t))==null?void 0:o._minW)??t})`]:{display:"none"}}}},verticalAlign:!0,boxSizing:!0,boxDecorationBreak:!0,float:ne.propT("float",Ct.float),objectFit:!0,objectPosition:!0,visibility:!0,isolation:!0};Object.assign(eo,{w:eo.width,h:eo.height,minW:eo.minWidth,maxW:eo.maxWidth,minH:eo.minHeight,maxH:eo.maxHeight,overscroll:eo.overscrollBehavior,overscrollX:eo.overscrollBehaviorX,overscrollY:eo.overscrollBehaviorY});const YL={filter:{transform:Ct.filter},blur:ne.blur("--chakra-blur"),brightness:ne.propT("--chakra-brightness",Ct.brightness),contrast:ne.propT("--chakra-contrast",Ct.contrast),hueRotate:ne.propT("--chakra-hue-rotate",Ct.hueRotate),invert:ne.propT("--chakra-invert",Ct.invert),saturate:ne.propT("--chakra-saturate",Ct.saturate),dropShadow:ne.propT("--chakra-drop-shadow",Ct.dropShadow),backdropFilter:{transform:Ct.backdropFilter},backdropBlur:ne.blur("--chakra-backdrop-blur"),backdropBrightness:ne.propT("--chakra-backdrop-brightness",Ct.brightness),backdropContrast:ne.propT("--chakra-backdrop-contrast",Ct.contrast),backdropHueRotate:ne.propT("--chakra-backdrop-hue-rotate",Ct.hueRotate),backdropInvert:ne.propT("--chakra-backdrop-invert",Ct.invert),backdropSaturate:ne.propT("--chakra-backdrop-saturate",Ct.saturate)},QL={ring:{transform:Ct.ring},ringColor:ne.colors("--chakra-ring-color"),ringOffset:ne.prop("--chakra-ring-offset-width"),ringOffsetColor:ne.colors("--chakra-ring-offset-color"),ringInset:ne.prop("--chakra-ring-inset")},ZL={appearance:!0,cursor:!0,resize:!0,userSelect:!0,pointerEvents:!0,outline:{transform:Ct.outline},outlineOffset:!0,outlineColor:ne.colors("outlineColor")},UE={gridGap:ne.space("gridGap"),gridColumnGap:ne.space("gridColumnGap"),gridRowGap:ne.space("gridRowGap"),gridColumn:!0,gridRow:!0,gridAutoFlow:!0,gridAutoColumns:!0,gridColumnStart:!0,gridColumnEnd:!0,gridRowStart:!0,gridRowEnd:!0,gridAutoRows:!0,gridTemplate:!0,gridTemplateColumns:!0,gridTemplateRows:!0,gridTemplateAreas:!0,gridArea:!0};function JL(t,e,n,r){const s=typeof e=="string"?e.split("."):[e];for(r=0;r<s.length&&t;r+=1)t=t[s[r]];return t===void 0?n:t}const ez=t=>{const e=new WeakMap;return(r,s,o,i)=>{if(typeof r>"u")return t(r,s,o);e.has(r)||e.set(r,new Map);const a=e.get(r);if(a.has(s))return a.get(s);const l=t(r,s,o,i);return a.set(s,l),l}},tz=ez(JL),nz={border:"0px",clip:"rect(0, 0, 0, 0)",width:"1px",height:"1px",margin:"-1px",padding:"0px",overflow:"hidden",whiteSpace:"nowrap",position:"absolute"},rz={position:"static",width:"auto",height:"auto",clip:"auto",padding:"0",margin:"0",overflow:"visible",whiteSpace:"normal"},a1=(t,e,n)=>{const r={},s=tz(t,e,{});for(const o in s)o in n&&n[o]!=null||(r[o]=s[o]);return r},sz={srOnly:{transform(t){return t===!0?nz:t==="focusable"?rz:{}}},layerStyle:{processResult:!0,transform:(t,e,n)=>a1(e,`layerStyles.${t}`,n)},textStyle:{processResult:!0,transform:(t,e,n)=>a1(e,`textStyles.${t}`,n)},apply:{processResult:!0,transform:(t,e,n)=>a1(e,t,n)}},Bh={position:!0,pos:ne.prop("position"),zIndex:ne.prop("zIndex","zIndices"),inset:ne.spaceT("inset"),insetX:ne.spaceT(["left","right"]),insetInline:ne.spaceT("insetInline"),insetY:ne.spaceT(["top","bottom"]),insetBlock:ne.spaceT("insetBlock"),top:ne.spaceT("top"),insetBlockStart:ne.spaceT("insetBlockStart"),bottom:ne.spaceT("bottom"),insetBlockEnd:ne.spaceT("insetBlockEnd"),left:ne.spaceT("left"),insetInlineStart:ne.logical({scale:"space",property:{ltr:"left",rtl:"right"}}),right:ne.spaceT("right"),insetInlineEnd:ne.logical({scale:"space",property:{ltr:"right",rtl:"left"}})};Object.assign(Bh,{insetStart:Bh.insetInlineStart,insetEnd:Bh.insetInlineEnd});const bx={boxShadow:ne.shadows("boxShadow"),mixBlendMode:!0,blendMode:ne.prop("mixBlendMode"),backgroundBlendMode:!0,bgBlendMode:ne.prop("backgroundBlendMode"),opacity:!0};Object.assign(bx,{shadow:bx.boxShadow});const ln={margin:ne.spaceT("margin"),marginTop:ne.spaceT("marginTop"),marginBlockStart:ne.spaceT("marginBlockStart"),marginRight:ne.spaceT("marginRight"),marginInlineEnd:ne.spaceT("marginInlineEnd"),marginBottom:ne.spaceT("marginBottom"),marginBlockEnd:ne.spaceT("marginBlockEnd"),marginLeft:ne.spaceT("marginLeft"),marginInlineStart:ne.spaceT("marginInlineStart"),marginX:ne.spaceT(["marginInlineStart","marginInlineEnd"]),marginInline:ne.spaceT("marginInline"),marginY:ne.spaceT(["marginTop","marginBottom"]),marginBlock:ne.spaceT("marginBlock"),padding:ne.space("padding"),paddingTop:ne.space("paddingTop"),paddingBlockStart:ne.space("paddingBlockStart"),paddingRight:ne.space("paddingRight"),paddingBottom:ne.space("paddingBottom"),paddingBlockEnd:ne.space("paddingBlockEnd"),paddingLeft:ne.space("paddingLeft"),paddingInlineStart:ne.space("paddingInlineStart"),paddingInlineEnd:ne.space("paddingInlineEnd"),paddingX:ne.space(["paddingInlineStart","paddingInlineEnd"]),paddingInline:ne.space("paddingInline"),paddingY:ne.space(["paddingTop","paddingBottom"]),paddingBlock:ne.space("paddingBlock")};Object.assign(ln,{m:ln.margin,mt:ln.marginTop,mr:ln.marginRight,me:ln.marginInlineEnd,marginEnd:ln.marginInlineEnd,mb:ln.marginBottom,ml:ln.marginLeft,ms:ln.marginInlineStart,marginStart:ln.marginInlineStart,mx:ln.marginX,my:ln.marginY,p:ln.padding,pt:ln.paddingTop,py:ln.paddingY,px:ln.paddingX,pb:ln.paddingBottom,pl:ln.paddingLeft,ps:ln.paddingInlineStart,paddingStart:ln.paddingInlineStart,pr:ln.paddingRight,pe:ln.paddingInlineEnd,paddingEnd:ln.paddingInlineEnd});const oz={scrollBehavior:!0,scrollSnapAlign:!0,scrollSnapStop:!0,scrollSnapType:!0,scrollMargin:ne.spaceT("scrollMargin"),scrollMarginTop:ne.spaceT("scrollMarginTop"),scrollMarginBottom:ne.spaceT("scrollMarginBottom"),scrollMarginLeft:ne.spaceT("scrollMarginLeft"),scrollMarginRight:ne.spaceT("scrollMarginRight"),scrollMarginX:ne.spaceT(["scrollMarginLeft","scrollMarginRight"]),scrollMarginY:ne.spaceT(["scrollMarginTop","scrollMarginBottom"]),scrollPadding:ne.spaceT("scrollPadding"),scrollPaddingTop:ne.spaceT("scrollPaddingTop"),scrollPaddingBottom:ne.spaceT("scrollPaddingBottom"),scrollPaddingLeft:ne.spaceT("scrollPaddingLeft"),scrollPaddingRight:ne.spaceT("scrollPaddingRight"),scrollPaddingX:ne.spaceT(["scrollPaddingLeft","scrollPaddingRight"]),scrollPaddingY:ne.spaceT(["scrollPaddingTop","scrollPaddingBottom"])},iz={fontFamily:ne.prop("fontFamily","fonts"),fontSize:ne.prop("fontSize","fontSizes",Ct.px),fontWeight:ne.prop("fontWeight","fontWeights"),lineHeight:ne.prop("lineHeight","lineHeights"),letterSpacing:ne.prop("letterSpacing","letterSpacings"),textAlign:!0,fontStyle:!0,textIndent:!0,wordBreak:!0,overflowWrap:!0,textOverflow:!0,textTransform:!0,whiteSpace:!0,isTruncated:{transform(t){if(t===!0)return{overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"}}},noOfLines:{static:{overflow:"hidden",textOverflow:"ellipsis",display:"-webkit-box",WebkitBoxOrient:"vertical",WebkitLineClamp:"var(--chakra-line-clamp)"},property:"--chakra-line-clamp"}},az={textDecorationColor:ne.colors("textDecorationColor"),textDecoration:!0,textDecor:{property:"textDecoration"},textDecorationLine:!0,textDecorationStyle:!0,textDecorationThickness:!0,textUnderlineOffset:!0,textShadow:ne.shadows("textShadow")},lz={clipPath:!0,transform:ne.propT("transform",Ct.transform),transformOrigin:!0,translateX:ne.spaceT("--chakra-translate-x"),translateY:ne.spaceT("--chakra-translate-y"),skewX:ne.degreeT("--chakra-skew-x"),skewY:ne.degreeT("--chakra-skew-y"),scaleX:ne.prop("--chakra-scale-x"),scaleY:ne.prop("--chakra-scale-y"),scale:ne.prop(["--chakra-scale-x","--chakra-scale-y"]),rotate:ne.degreeT("--chakra-rotate")},uz={listStyleType:!0,listStylePosition:!0,listStylePos:ne.prop("listStylePosition"),listStyleImage:!0,listStyleImg:ne.prop("listStyleImage")},cz={transition:!0,transitionDelay:!0,animation:!0,willChange:!0,transitionDuration:ne.prop("transitionDuration","transition.duration"),transitionProperty:ne.prop("transitionProperty","transition.property"),transitionTimingFunction:ne.prop("transitionTimingFunction","transition.easing")},Xv=so({},Em,Pt,qL,rg,eo,YL,QL,ZL,UE,sz,Bh,bx,ln,oz,iz,az,lz,uz,cz);Object.assign({},ln,eo,rg,UE,Bh);const dz=[...Object.keys(Xv),...VE],hz={...Xv,...jc},fz=t=>t in hz,pz=t=>e=>{if(!e.__breakpoints)return t;const{isResponsive:n,toArrayValue:r,media:s}=e.__breakpoints,o={};for(const i in t){let a=ro(t[i],e);if(a==null)continue;if(a=Vr(a)&&n(a)?r(a):a,!Array.isArray(a)){o[i]=a;continue}const l=a.slice(0,s.length).length;for(let c=0;c<l;c+=1){const d=s==null?void 0:s[c];if(!d){o[i]=a[c];continue}o[d]=o[d]||{},a[c]!=null&&(o[d][i]=a[c])}}return o};function mz(t){const e=[];let n="",r=!1;for(let s=0;s<t.length;s++){const o=t[s];o==="("?(r=!0,n+=o):o===")"?(r=!1,n+=o):o===","&&!r?(e.push(n),n=""):n+=o}return n=n.trim(),n&&e.push(n),e}function gz(t){return/^var\(--.+\)$/.test(t)}const yz=(t,e)=>t.startsWith("--")&&typeof e=="string"&&!gz(e),xz=(t,e)=>{if(e==null)return e;const n=i=>{var a,l;return(l=(a=t.__cssMap)==null?void 0:a[i])==null?void 0:l.varRef},r=i=>n(i)??i,[s,o]=mz(e);return e=n(s)??r(o)??r(e),e};function vz(t){const{configs:e={},pseudos:n={},theme:r}=t,s=(o,i=!1)=>{var d;const a=ro(o,r),l=pz(a)(r);let c={};for(let f in l){const p=l[f];let g=ro(p,r);f in n&&(f=n[f]),yz(f,g)&&(g=xz(r,g));let y=e[f];if(y===!0&&(y={property:f}),Vr(g)){c[f]=c[f]??{},c[f]=so({},c[f],s(g,!0));continue}let x=((d=y==null?void 0:y.transform)==null?void 0:d.call(y,g,r,a))??g;x=y!=null&&y.processResult?s(x,!0):x;const w=ro(y==null?void 0:y.property,r);if(!i&&(y!=null&&y.static)){const S=ro(y.static,r);c=so({},c,S)}if(w&&Array.isArray(w)){for(const S of w)c[S]=x;continue}if(w){w==="&"&&Vr(x)?c=so({},c,x):c[w]=x;continue}if(Vr(x)){c=so({},c,x);continue}c[f]=x}return c};return s}const jE=t=>e=>vz({theme:e,pseudos:jc,configs:Xv})(t);function tn(t){return{definePartsStyle(e){return e},defineMultiStyleConfig(e){return{parts:t,...e}}}}function bz(t,e){if(Array.isArray(t))return t;if(Vr(t))return e(t);if(t!=null)return[t]}function wz(t,e){for(let n=e+1;n<t.length;n++)if(t[n]!=null)return n;return-1}function Sz(t){const e=t.__breakpoints;return function(r,s,o,i){var p,g;if(!e)return;const a={},l=bz(o,e.toArrayValue);if(!l)return a;const c=l.length,d=c===1,f=!!r.parts;for(let y=0;y<c;y++){const x=e.details[y],w=e.details[wz(l,y)],S=$h(x.minW,w==null?void 0:w._minW),$=ro((p=r[s])==null?void 0:p[l[y]],i);if($){if(f){(g=r.parts)==null||g.forEach(I=>{so(a,{[I]:d?$[I]:{[S]:$[I]}})});continue}if(!f){d?so(a,$):a[S]=$;continue}a[S]=$}}return a}}function Cz(t){return e=>{const{variant:n,size:r,theme:s}=e,o=Sz(s);return so({},ro(t.baseStyle??{},e),o(t,"sizes",r,e),o(t,"variants",n,e))}}function Ir(t){return Gv(t,["styleConfig","size","variant","colorScheme"])}function GE(t){return Vr(t)&&t.reference?t.reference:String(t)}const Wg=(t,...e)=>e.map(GE).join(` ${t} `).replace(/calc/g,""),a3=(...t)=>`calc(${Wg("+",...t)})`,l3=(...t)=>`calc(${Wg("-",...t)})`,wx=(...t)=>`calc(${Wg("*",...t)})`,u3=(...t)=>`calc(${Wg("/",...t)})`,c3=t=>{const e=GE(t);return e!=null&&!Number.isNaN(parseFloat(e))?String(e).startsWith("-")?String(e).slice(1):`-${e}`:wx(e,-1)},Ji=Object.assign(t=>({add:(...e)=>Ji(a3(t,...e)),subtract:(...e)=>Ji(l3(t,...e)),multiply:(...e)=>Ji(wx(t,...e)),divide:(...e)=>Ji(u3(t,...e)),negate:()=>Ji(c3(t)),toString:()=>t.toString()}),{add:a3,subtract:l3,multiply:wx,divide:u3,negate:c3});function $z(t,e="-"){return t.replace(/\s+/g,e)}function kz(t){const e=$z(t.toString());return Iz(Tz(e))}function Tz(t){return t.includes("\\.")?t:!Number.isInteger(parseFloat(t.toString()))?t.replace(".","\\."):t}function Iz(t){return t.replace(/[!-,/:-@[-^`{-~]/g,"\\$&")}function Nz(t,e=""){return[e,t].filter(Boolean).join("-")}function Ez(t,e){return`var(${t}${e?`, ${e}`:""})`}function Rz(t,e=""){return kz(`--${Nz(t,e)}`)}function Qe(t,e,n){const r=Rz(t,n);return{variable:r,reference:Ez(r,e)}}function _z(t,e){const n={};for(const r of e){if(Array.isArray(r)){const[s,o]=r;n[s]=Qe(`${t}-${s}`,o);continue}n[r]=Qe(`${t}-${r}`)}return n}const Pz=["colors","borders","borderWidths","borderStyles","fonts","fontSizes","fontWeights","gradients","letterSpacings","lineHeights","radii","space","shadows","sizes","zIndices","transition","blur","breakpoints"];function Az(t){return $L(t,Pz)}function Dz(t){return t.semanticTokens}function Oz(t){const{__cssMap:e,__cssVars:n,__breakpoints:r,...s}=t;return s}function Fz(t){const e=Az(t),n=Dz(t),r=o=>VE.includes(o)||o==="default",s={};return r3(e,(o,i)=>{o!=null&&(s[i.join(".")]={isSemantic:!1,value:o})}),r3(n,(o,i)=>{o!=null&&(s[i.join(".")]={isSemantic:!0,value:o})},{stop:o=>Object.keys(o).every(r)}),s}function d3(t,e){return Qe(String(t).replace(/\./g,"-"),void 0,e)}function Lz(t){var i;const e=Fz(t),n=(i=t.config)==null?void 0:i.cssVarPrefix;let r={};const s={};function o(a,l){const d=[String(a).split(".")[0],l].join(".");if(!e[d])return l;const{reference:p}=d3(d,n);return p}for(const[a,l]of Object.entries(e)){const{isSemantic:c,value:d}=l,{variable:f,reference:p}=d3(a,n);if(!c){if(a.startsWith("space")){const y=a.split("."),[x,...w]=y,S=`${x}.-${w.join(".")}`,$=Ji.negate(d),I=Ji.negate(p);s[S]={value:$,var:f,varRef:I}}r[f]=d,s[a]={value:d,var:f,varRef:p};continue}const g=Vr(d)?d:{default:d};r=so(r,Object.entries(g).reduce((y,[x,w])=>{if(!w)return y;const S=o(a,`${w}`);if(x==="default")return y[f]=S,y;const $=(jc==null?void 0:jc[x])??x;return y[$]={[f]:S},y},{})),s[a]={value:p,var:f,varRef:p}}return{cssVars:r,cssMap:s}}function zz(t){const e=Oz(t),{cssMap:n,cssVars:r}=Lz(e);return Object.assign(e,{__cssVars:{...{"--chakra-ring-inset":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-ring-offset-width":"0px","--chakra-ring-offset-color":"#fff","--chakra-ring-color":"rgba(66, 153, 225, 0.6)","--chakra-ring-offset-shadow":"0 0 #0000","--chakra-ring-shadow":"0 0 #0000","--chakra-space-x-reverse":"0","--chakra-space-y-reverse":"0"},...r},__cssMap:n,__breakpoints:vL(e.breakpoints)}),e}function Ft(t,e={}){let n=!1;function r(){if(!n){n=!0;return}throw new Error("[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?")}function s(...d){r();for(const f of d)e[f]=l(f);return Ft(t,e)}function o(...d){for(const f of d)f in e||(e[f]=l(f));return Ft(t,e)}function i(){return Object.fromEntries(Object.entries(e).map(([f,p])=>[f,p.selector]))}function a(){return Object.fromEntries(Object.entries(e).map(([f,p])=>[f,p.className]))}function l(d){const g=`chakra-${(["container","root"].includes(d??"")?[t]:[t,d]).filter(Boolean).join("__")}`;return{className:g,selector:`.${g}`,toString:()=>d}}return{parts:s,toPart:l,extend:o,selectors:i,classnames:a,get keys(){return Object.keys(e)},__type:{}}}const Bz=Ft("accordion").parts("root","container","button","panel","icon"),Mz=Ft("alert").parts("title","description","container","icon","spinner"),Vz=Ft("avatar").parts("label","badge","container","excessLabel","group"),Wz=Ft("breadcrumb").parts("link","item","container","separator");Ft("button").parts();const Uz=Ft("checkbox").parts("control","icon","container","label");Ft("progress").parts("track","filledTrack","label");const jz=Ft("drawer").parts("overlay","dialogContainer","dialog","header","closeButton","body","footer"),Gz=Ft("editable").parts("preview","input","textarea"),Hz=Ft("form").parts("container","requiredIndicator","helperText"),Kz=Ft("formError").parts("text","icon"),Xz=Ft("input").parts("addon","field","element","group"),qz=Ft("list").parts("container","item","icon"),Yz=Ft("menu").parts("button","list","item","groupTitle","icon","command","divider"),Qz=Ft("modal").parts("overlay","dialogContainer","dialog","header","closeButton","body","footer"),Zz=Ft("numberinput").parts("root","field","stepperGroup","stepper");Ft("pininput").parts("field");const Jz=Ft("popover").parts("content","header","body","footer","popper","arrow","closeButton"),eB=Ft("progress").parts("label","filledTrack","track"),tB=Ft("radio").parts("container","control","label"),nB=Ft("select").parts("field","icon"),rB=Ft("slider").parts("container","track","thumb","filledTrack","mark"),sB=Ft("stat").parts("container","label","helpText","number","icon"),oB=Ft("switch").parts("container","track","thumb","label"),iB=Ft("table").parts("table","thead","tbody","tr","th","td","tfoot","caption"),aB=Ft("tabs").parts("root","tab","tablist","tabpanel","tabpanels","indicator"),lB=Ft("tag").parts("container","label","closeButton"),uB=Ft("card").parts("container","header","body","footer");Ft("stepper").parts("stepper","step","title","description","indicator","separator","icon","number");const{definePartsStyle:cB,defineMultiStyleConfig:dB}=tn(Bz.keys),hB={borderTopWidth:"1px",borderColor:"inherit",_last:{borderBottomWidth:"1px"}},fB={transitionProperty:"common",transitionDuration:"normal",fontSize:"md",_focusVisible:{boxShadow:"outline"},_hover:{bg:"blackAlpha.50"},_disabled:{opacity:.4,cursor:"not-allowed"},px:"4",py:"2"},pB={pt:"2",px:"4",pb:"5"},mB={fontSize:"1.25em"},gB=cB({container:hB,button:fB,panel:pB,icon:mB}),yB=dB({baseStyle:gB});function gu(t,e,n){return Math.min(Math.max(t,n),e)}class xB extends Error{constructor(e){super(`Failed to parse color: "${e}"`)}}var Th=xB;function qv(t){if(typeof t!="string")throw new Th(t);if(t.trim().toLowerCase()==="transparent")return[0,0,0,0];let e=t.trim();e=TB.test(t)?wB(t):t;const n=SB.exec(e);if(n){const i=Array.from(n).slice(1);return[...i.slice(0,3).map(a=>parseInt(ef(a,2),16)),parseInt(ef(i[3]||"f",2),16)/255]}const r=CB.exec(e);if(r){const i=Array.from(r).slice(1);return[...i.slice(0,3).map(a=>parseInt(a,16)),parseInt(i[3]||"ff",16)/255]}const s=$B.exec(e);if(s){const i=Array.from(s).slice(1);return[...i.slice(0,3).map(a=>parseInt(a,10)),parseFloat(i[3]||"1")]}const o=kB.exec(e);if(o){const[i,a,l,c]=Array.from(o).slice(1).map(parseFloat);if(gu(0,100,a)!==a)throw new Th(t);if(gu(0,100,l)!==l)throw new Th(t);return[...IB(i,a,l),Number.isNaN(c)?1:c]}throw new Th(t)}function vB(t){let e=5381,n=t.length;for(;n;)e=e*33^t.charCodeAt(--n);return(e>>>0)%2341}const h3=t=>parseInt(t.replace(/_/g,""),36),bB="1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((t,e)=>{const n=h3(e.substring(0,3)),r=h3(e.substring(3)).toString(16);let s="";for(let o=0;o<6-r.length;o++)s+="0";return t[n]=`${s}${r}`,t},{});function wB(t){const e=t.toLowerCase().trim(),n=bB[vB(e)];if(!n)throw new Th(t);return`#${n}`}const ef=(t,e)=>Array.from(Array(e)).map(()=>t).join(""),SB=new RegExp(`^#${ef("([a-f0-9])",3)}([a-f0-9])?$`,"i"),CB=new RegExp(`^#${ef("([a-f0-9]{2})",3)}([a-f0-9]{2})?$`,"i"),$B=new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${ef(",\\s*(\\d+)\\s*",2)}(?:,\\s*([\\d.]+))?\\s*\\)$`,"i"),kB=/^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i,TB=/^[a-z]+$/i,f3=t=>Math.round(t*255),IB=(t,e,n)=>{let r=n/100;if(e===0)return[r,r,r].map(f3);const s=(t%360+360)%360/60,o=(1-Math.abs(2*r-1))*(e/100),i=o*(1-Math.abs(s%2-1));let a=0,l=0,c=0;s>=0&&s<1?(a=o,l=i):s>=1&&s<2?(a=i,l=o):s>=2&&s<3?(l=o,c=i):s>=3&&s<4?(l=i,c=o):s>=4&&s<5?(a=i,c=o):s>=5&&s<6&&(a=o,c=i);const d=r-o/2,f=a+d,p=l+d,g=c+d;return[f,p,g].map(f3)};function NB(t,e,n,r){return`rgba(${gu(0,255,t).toFixed()}, ${gu(0,255,e).toFixed()}, ${gu(0,255,n).toFixed()}, ${parseFloat(gu(0,1,r).toFixed(3))})`}function EB(t,e){const[n,r,s,o]=qv(t);return NB(n,r,s,o-e)}function RB(t){const[e,n,r,s]=qv(t);let o=i=>{const a=gu(0,255,i).toString(16);return a.length===1?`0${a}`:a};return`#${o(e)}${o(n)}${o(r)}${s<1?o(Math.round(s*255)):""}`}const _B=t=>Object.keys(t).length===0;function PB(t,e,n,r,s){for(e=e.split?e.split("."):e,r=0;r<e.length;r++)t=t?t[e[r]]:s;return t===s?n:t}const Br=(t,e,n)=>{const r=PB(t,`colors.${e}`,e);try{return RB(r),r}catch{return n??"#000000"}},AB=t=>{const[e,n,r]=qv(t);return(e*299+n*587+r*114)/1e3},DB=t=>e=>{const n=Br(e,t);return AB(n)<128?"dark":"light"},OB=t=>e=>DB(t)(e)==="dark",ed=(t,e)=>n=>{const r=Br(n,t);return EB(r,1-e)};function p3(t="1rem",e="rgba(255, 255, 255, 0.15)"){return{backgroundImage:`linear-gradient(
    45deg,
    ${e} 25%,
    transparent 25%,
    transparent 50%,
    ${e} 50%,
    ${e} 75%,
    transparent 75%,
    transparent
  )`,backgroundSize:`${t} ${t}`}}const FB=()=>`#${Math.floor(Math.random()*16777215).toString(16).padEnd(6,"0")}`;function LB(t){const e=FB();return!t||_B(t)?e:t.string&&t.colors?BB(t.string,t.colors):t.string&&!t.colors?zB(t.string):t.colors&&!t.string?MB(t.colors):e}function zB(t){let e=0;if(t.length===0)return e.toString();for(let r=0;r<t.length;r+=1)e=t.charCodeAt(r)+((e<<5)-e),e=e&e;let n="#";for(let r=0;r<3;r+=1){const s=e>>r*8&255;n+=`00${s.toString(16)}`.substr(-2)}return n}function BB(t,e){let n=0;if(t.length===0)return e[0];for(let r=0;r<t.length;r+=1)n=t.charCodeAt(r)+((n<<5)-n),n=n&n;return n=(n%e.length+e.length)%e.length,e[n]}function MB(t){return t[Math.floor(Math.random()*t.length)]}function Ye(t,e){return n=>n.colorMode==="dark"?e:t}function Yv(t){const{orientation:e,vertical:n,horizontal:r}=t;return e?e==="vertical"?n:r:{}}function HE(t){return Vr(t)&&t.reference?t.reference:String(t)}const Ug=(t,...e)=>e.map(HE).join(` ${t} `).replace(/calc/g,""),m3=(...t)=>`calc(${Ug("+",...t)})`,g3=(...t)=>`calc(${Ug("-",...t)})`,Sx=(...t)=>`calc(${Ug("*",...t)})`,y3=(...t)=>`calc(${Ug("/",...t)})`,x3=t=>{const e=HE(t);return e!=null&&!Number.isNaN(parseFloat(e))?String(e).startsWith("-")?String(e).slice(1):`-${e}`:Sx(e,-1)},ea=Object.assign(t=>({add:(...e)=>ea(m3(t,...e)),subtract:(...e)=>ea(g3(t,...e)),multiply:(...e)=>ea(Sx(t,...e)),divide:(...e)=>ea(y3(t,...e)),negate:()=>ea(x3(t)),toString:()=>t.toString()}),{add:m3,subtract:g3,multiply:Sx,divide:y3,negate:x3});function VB(t){return!Number.isInteger(parseFloat(t.toString()))}function WB(t,e="-"){return t.replace(/\s+/g,e)}function KE(t){const e=WB(t.toString());return e.includes("\\.")?t:VB(t)?e.replace(".","\\."):t}function UB(t,e=""){return[e,KE(t)].filter(Boolean).join("-")}function jB(t,e){return`var(${KE(t)}${e?`, ${e}`:""})`}function GB(t,e=""){return`--${UB(t,e)}`}function Ln(t,e){const n=GB(t,e==null?void 0:e.prefix);return{variable:n,reference:jB(n,HB(e==null?void 0:e.fallback))}}function HB(t){return t==null?void 0:t.reference}const{definePartsStyle:Df,defineMultiStyleConfig:KB}=tn(Mz.keys),Ps=Qe("alert-fg"),ua=Qe("alert-bg"),XB=Df({container:{bg:ua.reference,px:"4",py:"3"},title:{fontWeight:"bold",lineHeight:"6",marginEnd:"2"},description:{lineHeight:"6"},icon:{color:Ps.reference,flexShrink:0,marginEnd:"3",w:"5",h:"6"},spinner:{color:Ps.reference,flexShrink:0,marginEnd:"3",w:"5",h:"5"}});function Qv(t){const{theme:e,colorScheme:n}=t,r=ed(`${n}.200`,.16)(e);return{light:`colors.${n}.100`,dark:r}}const qB=Df(t=>{const{colorScheme:e}=t,n=Qv(t);return{container:{[Ps.variable]:`colors.${e}.600`,[ua.variable]:n.light,_dark:{[Ps.variable]:`colors.${e}.200`,[ua.variable]:n.dark}}}}),YB=Df(t=>{const{colorScheme:e}=t,n=Qv(t);return{container:{[Ps.variable]:`colors.${e}.600`,[ua.variable]:n.light,_dark:{[Ps.variable]:`colors.${e}.200`,[ua.variable]:n.dark},paddingStart:"3",borderStartWidth:"4px",borderStartColor:Ps.reference}}}),QB=Df(t=>{const{colorScheme:e}=t,n=Qv(t);return{container:{[Ps.variable]:`colors.${e}.600`,[ua.variable]:n.light,_dark:{[Ps.variable]:`colors.${e}.200`,[ua.variable]:n.dark},pt:"2",borderTopWidth:"4px",borderTopColor:Ps.reference}}}),ZB=Df(t=>{const{colorScheme:e}=t;return{container:{[Ps.variable]:"colors.white",[ua.variable]:`colors.${e}.600`,_dark:{[Ps.variable]:"colors.gray.900",[ua.variable]:`colors.${e}.200`},color:Ps.reference}}}),JB={subtle:qB,"left-accent":YB,"top-accent":QB,solid:ZB},eM=KB({baseStyle:XB,variants:JB,defaultProps:{variant:"subtle",colorScheme:"blue"}}),XE={px:"1px",.5:"0.125rem",1:"0.25rem",1.5:"0.375rem",2:"0.5rem",2.5:"0.625rem",3:"0.75rem",3.5:"0.875rem",4:"1rem",5:"1.25rem",6:"1.5rem",7:"1.75rem",8:"2rem",9:"2.25rem",10:"2.5rem",12:"3rem",14:"3.5rem",16:"4rem",20:"5rem",24:"6rem",28:"7rem",32:"8rem",36:"9rem",40:"10rem",44:"11rem",48:"12rem",52:"13rem",56:"14rem",60:"15rem",64:"16rem",72:"18rem",80:"20rem",96:"24rem"},tM={max:"max-content",min:"min-content",full:"100%","3xs":"14rem","2xs":"16rem",xs:"20rem",sm:"24rem",md:"28rem",lg:"32rem",xl:"36rem","2xl":"42rem","3xl":"48rem","4xl":"56rem","5xl":"64rem","6xl":"72rem","7xl":"80rem","8xl":"90rem",prose:"60ch"},nM={sm:"640px",md:"768px",lg:"1024px",xl:"1280px"},qE={...XE,...tM,container:nM},rM=t=>typeof t=="function";function Wr(t,...e){return rM(t)?t(...e):t}const{definePartsStyle:YE,defineMultiStyleConfig:sM}=tn(Vz.keys),Gc=Qe("avatar-border-color"),Mh=Qe("avatar-bg"),tf=Qe("avatar-font-size"),td=Qe("avatar-size"),oM={borderRadius:"full",border:"0.2em solid",borderColor:Gc.reference,[Gc.variable]:"white",_dark:{[Gc.variable]:"colors.gray.800"}},iM={bg:Mh.reference,fontSize:tf.reference,width:td.reference,height:td.reference,lineHeight:"1",[Mh.variable]:"colors.gray.200",_dark:{[Mh.variable]:"colors.whiteAlpha.400"}},aM=t=>{const{name:e,theme:n}=t,r=e?LB({string:e}):"colors.gray.400",s=OB(r)(n);let o="white";return s||(o="gray.800"),{bg:Mh.reference,fontSize:tf.reference,color:o,borderColor:Gc.reference,verticalAlign:"top",width:td.reference,height:td.reference,"&:not([data-loaded])":{[Mh.variable]:r},[Gc.variable]:"colors.white",_dark:{[Gc.variable]:"colors.gray.800"}}},lM={fontSize:tf.reference,lineHeight:"1"},uM=YE(t=>({badge:Wr(oM,t),excessLabel:Wr(iM,t),container:Wr(aM,t),label:lM}));function nl(t){const e=t!=="100%"?qE[t]:void 0;return YE({container:{[td.variable]:e??t,[tf.variable]:`calc(${e??t} / 2.5)`},excessLabel:{[td.variable]:e??t,[tf.variable]:`calc(${e??t} / 2.5)`}})}const cM={"2xs":nl(4),xs:nl(6),sm:nl(8),md:nl(12),lg:nl(16),xl:nl(24),"2xl":nl(32),full:nl("100%")},dM=sM({baseStyle:uM,sizes:cM,defaultProps:{size:"md"}}),$n=_z("badge",["bg","color","shadow"]),hM={px:1,textTransform:"uppercase",fontSize:"xs",borderRadius:"sm",fontWeight:"bold",bg:$n.bg.reference,color:$n.color.reference,boxShadow:$n.shadow.reference},fM=t=>{const{colorScheme:e,theme:n}=t,r=ed(`${e}.500`,.6)(n);return{[$n.bg.variable]:`colors.${e}.500`,[$n.color.variable]:"colors.white",_dark:{[$n.bg.variable]:r,[$n.color.variable]:"colors.whiteAlpha.800"}}},pM=t=>{const{colorScheme:e,theme:n}=t,r=ed(`${e}.200`,.16)(n);return{[$n.bg.variable]:`colors.${e}.100`,[$n.color.variable]:`colors.${e}.800`,_dark:{[$n.bg.variable]:r,[$n.color.variable]:`colors.${e}.200`}}},mM=t=>{const{colorScheme:e,theme:n}=t,r=ed(`${e}.200`,.8)(n);return{[$n.color.variable]:`colors.${e}.500`,_dark:{[$n.color.variable]:r},[$n.shadow.variable]:`inset 0 0 0px 1px ${$n.color.reference}`}},gM={solid:fM,subtle:pM,outline:mM},Vh={baseStyle:hM,variants:gM,defaultProps:{variant:"subtle",colorScheme:"gray"}},{defineMultiStyleConfig:yM,definePartsStyle:xM}=tn(Wz.keys),l1=Qe("breadcrumb-link-decor"),vM={transitionProperty:"common",transitionDuration:"fast",transitionTimingFunction:"ease-out",outline:"none",color:"inherit",textDecoration:l1.reference,[l1.variable]:"none","&:not([aria-current=page])":{cursor:"pointer",_hover:{[l1.variable]:"underline"},_focusVisible:{boxShadow:"outline"}}},bM=xM({link:vM}),wM=yM({baseStyle:bM}),SM={lineHeight:"1.2",borderRadius:"md",fontWeight:"semibold",transitionProperty:"common",transitionDuration:"normal",_focusVisible:{boxShadow:"outline"},_disabled:{opacity:.4,cursor:"not-allowed",boxShadow:"none"},_hover:{_disabled:{bg:"initial"}}},QE=t=>{const{colorScheme:e,theme:n}=t;if(e==="gray")return{color:Ye("gray.800","whiteAlpha.900")(t),_hover:{bg:Ye("gray.100","whiteAlpha.200")(t)},_active:{bg:Ye("gray.200","whiteAlpha.300")(t)}};const r=ed(`${e}.200`,.12)(n),s=ed(`${e}.200`,.24)(n);return{color:Ye(`${e}.600`,`${e}.200`)(t),bg:"transparent",_hover:{bg:Ye(`${e}.50`,r)(t)},_active:{bg:Ye(`${e}.100`,s)(t)}}},CM=t=>{const{colorScheme:e}=t,n=Ye("gray.200","whiteAlpha.300")(t);return{border:"1px solid",borderColor:e==="gray"?n:"currentColor",".chakra-button__group[data-attached][data-orientation=horizontal] > &:not(:last-of-type)":{marginEnd:"-1px"},".chakra-button__group[data-attached][data-orientation=vertical] > &:not(:last-of-type)":{marginBottom:"-1px"},...Wr(QE,t)}},$M={yellow:{bg:"yellow.400",color:"black",hoverBg:"yellow.500",activeBg:"yellow.600"},cyan:{bg:"cyan.400",color:"black",hoverBg:"cyan.500",activeBg:"cyan.600"}},kM=t=>{const{colorScheme:e}=t;if(e==="gray"){const a=Ye("gray.100","whiteAlpha.200")(t);return{bg:a,color:Ye("gray.800","whiteAlpha.900")(t),_hover:{bg:Ye("gray.200","whiteAlpha.300")(t),_disabled:{bg:a}},_active:{bg:Ye("gray.300","whiteAlpha.400")(t)}}}const{bg:n=`${e}.500`,color:r="white",hoverBg:s=`${e}.600`,activeBg:o=`${e}.700`}=$M[e]??{},i=Ye(n,`${e}.200`)(t);return{bg:i,color:Ye(r,"gray.800")(t),_hover:{bg:Ye(s,`${e}.300`)(t),_disabled:{bg:i}},_active:{bg:Ye(o,`${e}.400`)(t)}}},TM=t=>{const{colorScheme:e}=t;return{padding:0,height:"auto",lineHeight:"normal",verticalAlign:"baseline",color:Ye(`${e}.500`,`${e}.200`)(t),_hover:{textDecoration:"underline",_disabled:{textDecoration:"none"}},_active:{color:Ye(`${e}.700`,`${e}.500`)(t)}}},IM={bg:"none",color:"inherit",display:"inline",lineHeight:"inherit",m:"0",p:"0"},NM={ghost:QE,outline:CM,solid:kM,link:TM,unstyled:IM},EM={lg:{h:"12",minW:"12",fontSize:"lg",px:"6"},md:{h:"10",minW:"10",fontSize:"md",px:"4"},sm:{h:"8",minW:"8",fontSize:"sm",px:"3"},xs:{h:"6",minW:"6",fontSize:"xs",px:"2"}},RM={baseStyle:SM,variants:NM,sizes:EM,defaultProps:{variant:"solid",size:"md",colorScheme:"gray"}},{definePartsStyle:Su,defineMultiStyleConfig:_M}=tn(uB.keys),sg=Qe("card-bg"),oa=Qe("card-padding"),ZE=Qe("card-shadow"),Rm=Qe("card-radius"),JE=Qe("card-border-width","0"),eR=Qe("card-border-color"),PM=Su({container:{[sg.variable]:"colors.chakra-body-bg",backgroundColor:sg.reference,boxShadow:ZE.reference,borderRadius:Rm.reference,color:"chakra-body-text",borderWidth:JE.reference,borderColor:eR.reference},body:{padding:oa.reference,flex:"1 1 0%"},header:{padding:oa.reference},footer:{padding:oa.reference}}),AM={sm:Su({container:{[Rm.variable]:"radii.base",[oa.variable]:"space.3"}}),md:Su({container:{[Rm.variable]:"radii.md",[oa.variable]:"space.5"}}),lg:Su({container:{[Rm.variable]:"radii.xl",[oa.variable]:"space.7"}})},DM={elevated:Su({container:{[ZE.variable]:"shadows.base",_dark:{[sg.variable]:"colors.gray.700"}}}),outline:Su({container:{[JE.variable]:"1px",[eR.variable]:"colors.chakra-border-color"}}),filled:Su({container:{[sg.variable]:"colors.chakra-subtle-bg"}}),unstyled:{body:{[oa.variable]:0},header:{[oa.variable]:0},footer:{[oa.variable]:0}}},OM=_M({baseStyle:PM,variants:DM,sizes:AM,defaultProps:{variant:"elevated",size:"md"}}),{definePartsStyle:_m,defineMultiStyleConfig:FM}=tn(Uz.keys),Wh=Qe("checkbox-size"),LM=t=>{const{colorScheme:e}=t;return{w:Wh.reference,h:Wh.reference,transitionProperty:"box-shadow",transitionDuration:"normal",border:"2px solid",borderRadius:"sm",borderColor:"inherit",color:"white",_checked:{bg:Ye(`${e}.500`,`${e}.200`)(t),borderColor:Ye(`${e}.500`,`${e}.200`)(t),color:Ye("white","gray.900")(t),_hover:{bg:Ye(`${e}.600`,`${e}.300`)(t),borderColor:Ye(`${e}.600`,`${e}.300`)(t)},_disabled:{borderColor:Ye("gray.200","transparent")(t),bg:Ye("gray.200","whiteAlpha.300")(t),color:Ye("gray.500","whiteAlpha.500")(t)}},_indeterminate:{bg:Ye(`${e}.500`,`${e}.200`)(t),borderColor:Ye(`${e}.500`,`${e}.200`)(t),color:Ye("white","gray.900")(t)},_disabled:{bg:Ye("gray.100","whiteAlpha.100")(t),borderColor:Ye("gray.100","transparent")(t)},_focusVisible:{boxShadow:"outline"},_invalid:{borderColor:Ye("red.500","red.300")(t)}}},zM={_disabled:{cursor:"not-allowed"}},BM={userSelect:"none",_disabled:{opacity:.4}},MM={transitionProperty:"transform",transitionDuration:"normal"},VM=_m(t=>({icon:MM,container:zM,control:Wr(LM,t),label:BM})),WM={sm:_m({control:{[Wh.variable]:"sizes.3"},label:{fontSize:"sm"},icon:{fontSize:"3xs"}}),md:_m({control:{[Wh.variable]:"sizes.4"},label:{fontSize:"md"},icon:{fontSize:"2xs"}}),lg:_m({control:{[Wh.variable]:"sizes.5"},label:{fontSize:"lg"},icon:{fontSize:"2xs"}})},ol=FM({baseStyle:VM,sizes:WM,defaultProps:{size:"md",colorScheme:"blue"}}),Uh=Ln("close-button-size"),mh=Ln("close-button-bg"),UM={w:[Uh.reference],h:[Uh.reference],borderRadius:"md",transitionProperty:"common",transitionDuration:"normal",_disabled:{opacity:.4,cursor:"not-allowed",boxShadow:"none"},_hover:{[mh.variable]:"colors.blackAlpha.100",_dark:{[mh.variable]:"colors.whiteAlpha.100"}},_active:{[mh.variable]:"colors.blackAlpha.200",_dark:{[mh.variable]:"colors.whiteAlpha.200"}},_focusVisible:{boxShadow:"outline"},bg:mh.reference},jM={lg:{[Uh.variable]:"sizes.10",fontSize:"md"},md:{[Uh.variable]:"sizes.8",fontSize:"xs"},sm:{[Uh.variable]:"sizes.6",fontSize:"2xs"}},GM={baseStyle:UM,sizes:jM,defaultProps:{size:"md"}},{variants:HM,defaultProps:KM}=Vh,XM={fontFamily:"mono",fontSize:"sm",px:"0.2em",borderRadius:"sm",bg:$n.bg.reference,color:$n.color.reference,boxShadow:$n.shadow.reference},qM={baseStyle:XM,variants:HM,defaultProps:KM},YM={w:"100%",mx:"auto",maxW:"prose",px:"4"},QM={baseStyle:YM},ZM={opacity:.6,borderColor:"inherit"},JM={borderStyle:"solid"},eV={borderStyle:"dashed"},tV={solid:JM,dashed:eV},nV={baseStyle:ZM,variants:tV,defaultProps:{variant:"solid"}},{definePartsStyle:Cx,defineMultiStyleConfig:rV}=tn(jz.keys),u1=Qe("drawer-bg"),c1=Qe("drawer-box-shadow");function Cc(t){return Cx(t==="full"?{dialog:{maxW:"100vw",h:"100vh"}}:{dialog:{maxW:t}})}const sV={bg:"blackAlpha.600",zIndex:"modal"},oV={display:"flex",zIndex:"modal",justifyContent:"center"},iV=t=>{const{isFullHeight:e}=t;return{...e&&{height:"100vh"},zIndex:"modal",maxH:"100vh",color:"inherit",[u1.variable]:"colors.white",[c1.variable]:"shadows.lg",_dark:{[u1.variable]:"colors.gray.700",[c1.variable]:"shadows.dark-lg"},bg:u1.reference,boxShadow:c1.reference}},aV={px:"6",py:"4",fontSize:"xl",fontWeight:"semibold"},lV={position:"absolute",top:"2",insetEnd:"3"},uV={px:"6",py:"2",flex:"1",overflow:"auto"},cV={px:"6",py:"4"},dV=Cx(t=>({overlay:sV,dialogContainer:oV,dialog:Wr(iV,t),header:aV,closeButton:lV,body:uV,footer:cV})),hV={xs:Cc("xs"),sm:Cc("md"),md:Cc("lg"),lg:Cc("2xl"),xl:Cc("4xl"),full:Cc("full")},fV=rV({baseStyle:dV,sizes:hV,defaultProps:{size:"xs"}}),{definePartsStyle:pV,defineMultiStyleConfig:mV}=tn(Gz.keys),gV={borderRadius:"md",py:"1",transitionProperty:"common",transitionDuration:"normal"},yV={borderRadius:"md",py:"1",transitionProperty:"common",transitionDuration:"normal",width:"full",_focusVisible:{boxShadow:"outline"},_placeholder:{opacity:.6}},xV={borderRadius:"md",py:"1",transitionProperty:"common",transitionDuration:"normal",width:"full",_focusVisible:{boxShadow:"outline"},_placeholder:{opacity:.6}},vV=pV({preview:gV,input:yV,textarea:xV}),bV=mV({baseStyle:vV}),{definePartsStyle:wV,defineMultiStyleConfig:SV}=tn(Hz.keys),Hc=Qe("form-control-color"),CV={marginStart:"1",[Hc.variable]:"colors.red.500",_dark:{[Hc.variable]:"colors.red.300"},color:Hc.reference},$V={mt:"2",[Hc.variable]:"colors.gray.600",_dark:{[Hc.variable]:"colors.whiteAlpha.600"},color:Hc.reference,lineHeight:"normal",fontSize:"sm"},kV=wV({container:{width:"100%",position:"relative"},requiredIndicator:CV,helperText:$V}),TV=SV({baseStyle:kV}),{definePartsStyle:IV,defineMultiStyleConfig:NV}=tn(Kz.keys),Kc=Qe("form-error-color"),EV={[Kc.variable]:"colors.red.500",_dark:{[Kc.variable]:"colors.red.300"},color:Kc.reference,mt:"2",fontSize:"sm",lineHeight:"normal"},RV={marginEnd:"0.5em",[Kc.variable]:"colors.red.500",_dark:{[Kc.variable]:"colors.red.300"},color:Kc.reference},_V=IV({text:EV,icon:RV}),PV=NV({baseStyle:_V}),AV={fontSize:"md",marginEnd:"3",mb:"2",fontWeight:"medium",transitionProperty:"common",transitionDuration:"normal",opacity:1,_disabled:{opacity:.4}},DV={baseStyle:AV},OV={fontFamily:"heading",fontWeight:"bold"},FV={"4xl":{fontSize:["6xl",null,"7xl"],lineHeight:1},"3xl":{fontSize:["5xl",null,"6xl"],lineHeight:1},"2xl":{fontSize:["4xl",null,"5xl"],lineHeight:[1.2,null,1]},xl:{fontSize:["3xl",null,"4xl"],lineHeight:[1.33,null,1.2]},lg:{fontSize:["2xl",null,"3xl"],lineHeight:[1.33,null,1.2]},md:{fontSize:"xl",lineHeight:1.2},sm:{fontSize:"md",lineHeight:1.2},xs:{fontSize:"sm",lineHeight:1.2}},LV={baseStyle:OV,sizes:FV,defaultProps:{size:"xl"}},{definePartsStyle:ra,defineMultiStyleConfig:zV}=tn(Xz.keys),Ac=Qe("input-height"),Dc=Qe("input-font-size"),Oc=Qe("input-padding"),Fc=Qe("input-border-radius"),BV=ra({addon:{height:Ac.reference,fontSize:Dc.reference,px:Oc.reference,borderRadius:Fc.reference},field:{width:"100%",height:Ac.reference,fontSize:Dc.reference,px:Oc.reference,borderRadius:Fc.reference,minWidth:0,outline:0,position:"relative",appearance:"none",transitionProperty:"common",transitionDuration:"normal",_disabled:{opacity:.4,cursor:"not-allowed"}}}),rl={lg:{[Dc.variable]:"fontSizes.lg",[Oc.variable]:"space.4",[Fc.variable]:"radii.md",[Ac.variable]:"sizes.12"},md:{[Dc.variable]:"fontSizes.md",[Oc.variable]:"space.4",[Fc.variable]:"radii.md",[Ac.variable]:"sizes.10"},sm:{[Dc.variable]:"fontSizes.sm",[Oc.variable]:"space.3",[Fc.variable]:"radii.sm",[Ac.variable]:"sizes.8"},xs:{[Dc.variable]:"fontSizes.xs",[Oc.variable]:"space.2",[Fc.variable]:"radii.sm",[Ac.variable]:"sizes.6"}},MV={lg:ra({field:rl.lg,group:rl.lg}),md:ra({field:rl.md,group:rl.md}),sm:ra({field:rl.sm,group:rl.sm}),xs:ra({field:rl.xs,group:rl.xs})};function Zv(t){const{focusBorderColor:e,errorBorderColor:n}=t;return{focusBorderColor:e||Ye("blue.500","blue.300")(t),errorBorderColor:n||Ye("red.500","red.300")(t)}}const VV=ra(t=>{const{theme:e}=t,{focusBorderColor:n,errorBorderColor:r}=Zv(t);return{field:{border:"1px solid",borderColor:"inherit",bg:"inherit",_hover:{borderColor:Ye("gray.300","whiteAlpha.400")(t)},_readOnly:{boxShadow:"none !important",userSelect:"all"},_invalid:{borderColor:Br(e,r),boxShadow:`0 0 0 1px ${Br(e,r)}`},_focusVisible:{zIndex:1,borderColor:Br(e,n),boxShadow:`0 0 0 1px ${Br(e,n)}`}},addon:{border:"1px solid",borderColor:Ye("inherit","whiteAlpha.50")(t),bg:Ye("gray.100","whiteAlpha.300")(t)}}}),WV=ra(t=>{const{theme:e}=t,{focusBorderColor:n,errorBorderColor:r}=Zv(t);return{field:{border:"2px solid",borderColor:"transparent",bg:Ye("gray.100","whiteAlpha.50")(t),_hover:{bg:Ye("gray.200","whiteAlpha.100")(t)},_readOnly:{boxShadow:"none !important",userSelect:"all"},_invalid:{borderColor:Br(e,r)},_focusVisible:{bg:"transparent",borderColor:Br(e,n)}},addon:{border:"2px solid",borderColor:"transparent",bg:Ye("gray.100","whiteAlpha.50")(t)}}}),UV=ra(t=>{const{theme:e}=t,{focusBorderColor:n,errorBorderColor:r}=Zv(t);return{field:{borderBottom:"1px solid",borderColor:"inherit",borderRadius:"0",px:"0",bg:"transparent",_readOnly:{boxShadow:"none !important",userSelect:"all"},_invalid:{borderColor:Br(e,r),boxShadow:`0px 1px 0px 0px ${Br(e,r)}`},_focusVisible:{borderColor:Br(e,n),boxShadow:`0px 1px 0px 0px ${Br(e,n)}`}},addon:{borderBottom:"2px solid",borderColor:"inherit",borderRadius:"0",px:"0",bg:"transparent"}}}),jV=ra({field:{bg:"transparent",px:"0",height:"auto"},addon:{bg:"transparent",px:"0",height:"auto"}}),GV={outline:VV,filled:WV,flushed:UV,unstyled:jV},Ot=zV({baseStyle:BV,sizes:MV,variants:GV,defaultProps:{size:"md",variant:"outline"}}),d1=Qe("kbd-bg"),HV={[d1.variable]:"colors.gray.100",_dark:{[d1.variable]:"colors.whiteAlpha.100"},bg:d1.reference,borderRadius:"md",borderWidth:"1px",borderBottomWidth:"3px",fontSize:"0.8em",fontWeight:"bold",lineHeight:"normal",px:"0.4em",whiteSpace:"nowrap"},KV={baseStyle:HV},XV={transitionProperty:"common",transitionDuration:"fast",transitionTimingFunction:"ease-out",cursor:"pointer",textDecoration:"none",outline:"none",color:"inherit",_hover:{textDecoration:"underline"},_focusVisible:{boxShadow:"outline"}},qV={baseStyle:XV},{defineMultiStyleConfig:YV,definePartsStyle:QV}=tn(qz.keys),ZV={marginEnd:"2",display:"inline",verticalAlign:"text-bottom"},JV=QV({icon:ZV}),e5=YV({baseStyle:JV}),{defineMultiStyleConfig:t5,definePartsStyle:n5}=tn(Yz.keys),li=Qe("menu-bg"),h1=Qe("menu-shadow"),r5={[li.variable]:"#fff",[h1.variable]:"shadows.sm",_dark:{[li.variable]:"colors.gray.700",[h1.variable]:"shadows.dark-lg"},color:"inherit",minW:"3xs",py:"2",zIndex:"dropdown",borderRadius:"md",borderWidth:"1px",bg:li.reference,boxShadow:h1.reference},s5={py:"1.5",px:"3",transitionProperty:"background",transitionDuration:"ultra-fast",transitionTimingFunction:"ease-in",_focus:{[li.variable]:"colors.gray.100",_dark:{[li.variable]:"colors.whiteAlpha.100"}},_active:{[li.variable]:"colors.gray.200",_dark:{[li.variable]:"colors.whiteAlpha.200"}},_expanded:{[li.variable]:"colors.gray.100",_dark:{[li.variable]:"colors.whiteAlpha.100"}},_disabled:{opacity:.4,cursor:"not-allowed"},bg:li.reference},o5={mx:4,my:2,fontWeight:"semibold",fontSize:"sm"},i5={display:"inline-flex",alignItems:"center",justifyContent:"center",flexShrink:0},a5={opacity:.6},l5={border:0,borderBottom:"1px solid",borderColor:"inherit",my:"2",opacity:.6},u5={transitionProperty:"common",transitionDuration:"normal"},c5=n5({button:u5,list:r5,item:s5,groupTitle:o5,icon:i5,command:a5,divider:l5}),d5=t5({baseStyle:c5}),{defineMultiStyleConfig:h5,definePartsStyle:$x}=tn(Qz.keys),f1=Qe("modal-bg"),p1=Qe("modal-shadow"),f5={bg:"blackAlpha.600",zIndex:"modal"},p5=t=>{const{isCentered:e,scrollBehavior:n}=t;return{display:"flex",zIndex:"modal",justifyContent:"center",alignItems:e?"center":"flex-start",overflow:n==="inside"?"hidden":"auto",overscrollBehaviorY:"none"}},m5=t=>{const{isCentered:e,scrollBehavior:n}=t;return{borderRadius:"md",color:"inherit",my:e?"auto":"16",mx:e?"auto":void 0,zIndex:"modal",maxH:n==="inside"?"calc(100% - 7.5rem)":void 0,[f1.variable]:"colors.white",[p1.variable]:"shadows.lg",_dark:{[f1.variable]:"colors.gray.700",[p1.variable]:"shadows.dark-lg"},bg:f1.reference,boxShadow:p1.reference}},g5={px:"6",py:"4",fontSize:"xl",fontWeight:"semibold"},y5={position:"absolute",top:"2",insetEnd:"3"},x5=t=>{const{scrollBehavior:e}=t;return{px:"6",py:"2",flex:"1",overflow:e==="inside"?"auto":void 0}},v5={px:"6",py:"4"},b5=$x(t=>({overlay:f5,dialogContainer:Wr(p5,t),dialog:Wr(m5,t),header:g5,closeButton:y5,body:Wr(x5,t),footer:v5}));function Ro(t){return $x(t==="full"?{dialog:{maxW:"100vw",minH:"$100vh",my:"0",borderRadius:"0"}}:{dialog:{maxW:t}})}const w5={xs:Ro("xs"),sm:Ro("sm"),md:Ro("md"),lg:Ro("lg"),xl:Ro("xl"),"2xl":Ro("2xl"),"3xl":Ro("3xl"),"4xl":Ro("4xl"),"5xl":Ro("5xl"),"6xl":Ro("6xl"),full:Ro("full")},S5=h5({baseStyle:b5,sizes:w5,defaultProps:{size:"md"}}),tR={letterSpacings:{tighter:"-0.05em",tight:"-0.025em",normal:"0",wide:"0.025em",wider:"0.05em",widest:"0.1em"},lineHeights:{normal:"normal",none:1,shorter:1.25,short:1.375,base:1.5,tall:1.625,taller:"2",3:".75rem",4:"1rem",5:"1.25rem",6:"1.5rem",7:"1.75rem",8:"2rem",9:"2.25rem",10:"2.5rem"},fontWeights:{hairline:100,thin:200,light:300,normal:400,medium:500,semibold:600,bold:700,extrabold:800,black:900},fonts:{heading:'-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',body:'-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',mono:'SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace'},fontSizes:{"3xs":"0.45rem","2xs":"0.625rem",xs:"0.75rem",sm:"0.875rem",md:"1rem",lg:"1.125rem",xl:"1.25rem","2xl":"1.5rem","3xl":"1.875rem","4xl":"2.25rem","5xl":"3rem","6xl":"3.75rem","7xl":"4.5rem","8xl":"6rem","9xl":"8rem"}},{defineMultiStyleConfig:C5,definePartsStyle:nR}=tn(Zz.keys),Jv=Ln("number-input-stepper-width"),rR=Ln("number-input-input-padding"),$5=ea(Jv).add("0.5rem").toString(),m1=Ln("number-input-bg"),g1=Ln("number-input-color"),y1=Ln("number-input-border-color"),k5={[Jv.variable]:"sizes.6",[rR.variable]:$5},T5=t=>{var e;return((e=Wr(Ot.baseStyle,t))==null?void 0:e.field)??{}},I5={width:Jv.reference},N5={borderStart:"1px solid",borderStartColor:y1.reference,color:g1.reference,bg:m1.reference,[g1.variable]:"colors.chakra-body-text",[y1.variable]:"colors.chakra-border-color",_dark:{[g1.variable]:"colors.whiteAlpha.800",[y1.variable]:"colors.whiteAlpha.300"},_active:{[m1.variable]:"colors.gray.200",_dark:{[m1.variable]:"colors.whiteAlpha.300"}},_disabled:{opacity:.4,cursor:"not-allowed"}},E5=nR(t=>({root:k5,field:Wr(T5,t)??{},stepperGroup:I5,stepper:N5}));function im(t){var o,i;const e=(o=Ot.sizes)==null?void 0:o[t],n={lg:"md",md:"md",sm:"sm",xs:"sm"},r=((i=e.field)==null?void 0:i.fontSize)??"md",s=tR.fontSizes[r];return nR({field:{...e.field,paddingInlineEnd:rR.reference,verticalAlign:"top"},stepper:{fontSize:ea(s).multiply(.75).toString(),_first:{borderTopEndRadius:n[t]},_last:{borderBottomEndRadius:n[t],mt:"-1px",borderTopWidth:1}}})}const R5={xs:im("xs"),sm:im("sm"),md:im("md"),lg:im("lg")},_5=C5({baseStyle:E5,sizes:R5,variants:Ot.variants,defaultProps:Ot.defaultProps});var vE;const P5={...(vE=Ot.baseStyle)==null?void 0:vE.field,textAlign:"center"},A5={lg:{fontSize:"lg",w:12,h:12,borderRadius:"md"},md:{fontSize:"md",w:10,h:10,borderRadius:"md"},sm:{fontSize:"sm",w:8,h:8,borderRadius:"sm"},xs:{fontSize:"xs",w:6,h:6,borderRadius:"sm"}};var bE;const D5={outline:t=>{var e,n;return((n=Wr((e=Ot.variants)==null?void 0:e.outline,t))==null?void 0:n.field)??{}},flushed:t=>{var e,n;return((n=Wr((e=Ot.variants)==null?void 0:e.flushed,t))==null?void 0:n.field)??{}},filled:t=>{var e,n;return((n=Wr((e=Ot.variants)==null?void 0:e.filled,t))==null?void 0:n.field)??{}},unstyled:((bE=Ot.variants)==null?void 0:bE.unstyled.field)??{}},O5={baseStyle:P5,sizes:A5,variants:D5,defaultProps:Ot.defaultProps},{defineMultiStyleConfig:F5,definePartsStyle:L5}=tn(Jz.keys),am=Ln("popper-bg"),z5=Ln("popper-arrow-bg"),v3=Ln("popper-arrow-shadow-color"),B5={zIndex:"popover"},M5={[am.variable]:"colors.white",bg:am.reference,[z5.variable]:am.reference,[v3.variable]:"colors.gray.200",_dark:{[am.variable]:"colors.gray.700",[v3.variable]:"colors.whiteAlpha.300"},width:"xs",border:"1px solid",borderColor:"inherit",borderRadius:"md",boxShadow:"sm",zIndex:"inherit",_focusVisible:{outline:0,boxShadow:"outline"}},V5={px:3,py:2,borderBottomWidth:"1px"},W5={px:3,py:2},U5={px:3,py:2,borderTopWidth:"1px"},j5={position:"absolute",borderRadius:"md",top:1,insetEnd:2,padding:2},G5=L5({popper:B5,content:M5,header:V5,body:W5,footer:U5,closeButton:j5}),H5=F5({baseStyle:G5}),{defineMultiStyleConfig:K5,definePartsStyle:Ih}=tn(eB.keys),X5=t=>{const{colorScheme:e,theme:n,isIndeterminate:r,hasStripe:s}=t,o=Ye(p3(),p3("1rem","rgba(0,0,0,0.1)"))(t),i=Ye(`${e}.500`,`${e}.200`)(t),a=`linear-gradient(
    to right,
    transparent 0%,
    ${Br(n,i)} 50%,
    transparent 100%
  )`;return{...!r&&s&&o,...r?{bgImage:a}:{bgColor:i}}},q5={lineHeight:"1",fontSize:"0.25em",fontWeight:"bold",color:"white"},Y5=t=>({bg:Ye("gray.100","whiteAlpha.300")(t)}),Q5=t=>({transitionProperty:"common",transitionDuration:"slow",...X5(t)}),Z5=Ih(t=>({label:q5,filledTrack:Q5(t),track:Y5(t)})),J5={xs:Ih({track:{h:"1"}}),sm:Ih({track:{h:"2"}}),md:Ih({track:{h:"3"}}),lg:Ih({track:{h:"4"}})},e6=K5({sizes:J5,baseStyle:Z5,defaultProps:{size:"md",colorScheme:"blue"}}),{defineMultiStyleConfig:t6,definePartsStyle:Pm}=tn(tB.keys),n6=t=>{var n;const e=(n=Wr(ol.baseStyle,t))==null?void 0:n.control;return{...e,borderRadius:"full",_checked:{...e==null?void 0:e._checked,_before:{content:'""',display:"inline-block",pos:"relative",w:"50%",h:"50%",borderRadius:"50%",bg:"currentColor"}}}},r6=Pm(t=>{var e,n;return{label:(e=ol.baseStyle)==null?void 0:e.call(ol,t).label,container:(n=ol.baseStyle)==null?void 0:n.call(ol,t).container,control:n6(t)}}),s6={md:Pm({control:{w:"4",h:"4"},label:{fontSize:"md"}}),lg:Pm({control:{w:"5",h:"5"},label:{fontSize:"lg"}}),sm:Pm({control:{width:"3",height:"3"},label:{fontSize:"sm"}})},o6=t6({baseStyle:r6,sizes:s6,defaultProps:{size:"md",colorScheme:"blue"}}),{defineMultiStyleConfig:i6,definePartsStyle:a6}=tn(nB.keys),lm=Qe("select-bg");var wE;const l6={...(wE=Ot.baseStyle)==null?void 0:wE.field,appearance:"none",paddingBottom:"1px",lineHeight:"normal",bg:lm.reference,[lm.variable]:"colors.white",_dark:{[lm.variable]:"colors.gray.700"},"> option, > optgroup":{bg:lm.reference}},u6={width:"6",height:"100%",insetEnd:"2",position:"relative",color:"currentColor",fontSize:"xl",_disabled:{opacity:.5}},c6=a6({field:l6,icon:u6}),um={paddingInlineEnd:"8"};var SE,CE,$E,kE,TE,IE,NE,EE;const d6={lg:{...(SE=Ot.sizes)==null?void 0:SE.lg,field:{...(CE=Ot.sizes)==null?void 0:CE.lg.field,...um}},md:{...($E=Ot.sizes)==null?void 0:$E.md,field:{...(kE=Ot.sizes)==null?void 0:kE.md.field,...um}},sm:{...(TE=Ot.sizes)==null?void 0:TE.sm,field:{...(IE=Ot.sizes)==null?void 0:IE.sm.field,...um}},xs:{...(NE=Ot.sizes)==null?void 0:NE.xs,field:{...(EE=Ot.sizes)==null?void 0:EE.xs.field,...um},icon:{insetEnd:"1"}}},h6=i6({baseStyle:c6,sizes:d6,variants:Ot.variants,defaultProps:Ot.defaultProps}),x1=Qe("skeleton-start-color"),v1=Qe("skeleton-end-color"),f6={[x1.variable]:"colors.gray.100",[v1.variable]:"colors.gray.400",_dark:{[x1.variable]:"colors.gray.800",[v1.variable]:"colors.gray.600"},background:x1.reference,borderColor:v1.reference,opacity:.7,borderRadius:"sm"},p6={baseStyle:f6},b1=Qe("skip-link-bg"),m6={borderRadius:"md",fontWeight:"semibold",_focusVisible:{boxShadow:"outline",padding:"4",position:"fixed",top:"6",insetStart:"6",[b1.variable]:"colors.white",_dark:{[b1.variable]:"colors.gray.700"},bg:b1.reference}},g6={baseStyle:m6},{defineMultiStyleConfig:y6,definePartsStyle:jg}=tn(rB.keys),Eu=Qe("slider-thumb-size"),nf=Qe("slider-track-size"),al=Qe("slider-bg"),x6=t=>{const{orientation:e}=t;return{display:"inline-block",position:"relative",cursor:"pointer",_disabled:{opacity:.6,cursor:"default",pointerEvents:"none"},...Yv({orientation:e,vertical:{h:"100%",px:Ji(Eu.reference).divide(2).toString()},horizontal:{w:"100%",py:Ji(Eu.reference).divide(2).toString()}})}},v6=t=>({...Yv({orientation:t.orientation,horizontal:{h:nf.reference},vertical:{w:nf.reference}}),overflow:"hidden",borderRadius:"sm",[al.variable]:"colors.gray.200",_dark:{[al.variable]:"colors.whiteAlpha.200"},_disabled:{[al.variable]:"colors.gray.300",_dark:{[al.variable]:"colors.whiteAlpha.300"}},bg:al.reference}),b6=t=>{const{orientation:e}=t;return{...Yv({orientation:e,vertical:{left:"50%",transform:"translateX(-50%)",_active:{transform:"translateX(-50%) scale(1.15)"}},horizontal:{top:"50%",transform:"translateY(-50%)",_active:{transform:"translateY(-50%) scale(1.15)"}}}),w:Eu.reference,h:Eu.reference,display:"flex",alignItems:"center",justifyContent:"center",position:"absolute",outline:0,zIndex:1,borderRadius:"full",bg:"white",boxShadow:"base",border:"1px solid",borderColor:"transparent",transitionProperty:"transform",transitionDuration:"normal",_focusVisible:{boxShadow:"outline"},_disabled:{bg:"gray.300"}}},w6=t=>{const{colorScheme:e}=t;return{width:"inherit",height:"inherit",[al.variable]:`colors.${e}.500`,_dark:{[al.variable]:`colors.${e}.200`},bg:al.reference}},S6=jg(t=>({container:x6(t),track:v6(t),thumb:b6(t),filledTrack:w6(t)})),C6=jg({container:{[Eu.variable]:"sizes.4",[nf.variable]:"sizes.1"}}),$6=jg({container:{[Eu.variable]:"sizes.3.5",[nf.variable]:"sizes.1"}}),k6=jg({container:{[Eu.variable]:"sizes.2.5",[nf.variable]:"sizes.0.5"}}),T6={lg:C6,md:$6,sm:k6},I6=y6({baseStyle:S6,sizes:T6,defaultProps:{size:"md",colorScheme:"blue"}}),cu=Ln("spinner-size"),N6={width:[cu.reference],height:[cu.reference]},E6={xs:{[cu.variable]:"sizes.3"},sm:{[cu.variable]:"sizes.4"},md:{[cu.variable]:"sizes.6"},lg:{[cu.variable]:"sizes.8"},xl:{[cu.variable]:"sizes.12"}},R6={baseStyle:N6,sizes:E6,defaultProps:{size:"md"}},{defineMultiStyleConfig:_6,definePartsStyle:sR}=tn(sB.keys),P6={fontWeight:"medium"},A6={opacity:.8,marginBottom:"2"},D6={verticalAlign:"baseline",fontWeight:"semibold"},O6={marginEnd:1,w:"3.5",h:"3.5",verticalAlign:"middle"},F6=sR({container:{},label:P6,helpText:A6,number:D6,icon:O6}),L6={md:sR({label:{fontSize:"sm"},helpText:{fontSize:"sm"},number:{fontSize:"2xl"}})},z6=_6({baseStyle:F6,sizes:L6,defaultProps:{size:"md"}}),{defineMultiStyleConfig:B6,definePartsStyle:Nh}=tn(["stepper","step","title","description","indicator","separator","icon","number"]),ta=Qe("stepper-indicator-size"),Lc=Qe("stepper-icon-size"),zc=Qe("stepper-title-font-size"),Eh=Qe("stepper-description-font-size"),gh=Qe("stepper-accent-color"),M6=Nh(({colorScheme:t})=>({stepper:{display:"flex",justifyContent:"space-between",gap:"4","&[data-orientation=vertical]":{flexDirection:"column",alignItems:"flex-start"},"&[data-orientation=horizontal]":{flexDirection:"row",alignItems:"center"},[gh.variable]:`colors.${t}.500`,_dark:{[gh.variable]:`colors.${t}.200`}},title:{fontSize:zc.reference,fontWeight:"medium"},description:{fontSize:Eh.reference,color:"chakra-subtle-text"},number:{fontSize:zc.reference},step:{flexShrink:0,position:"relative",display:"flex",gap:"2","&[data-orientation=horizontal]":{alignItems:"center"},flex:"1","&:last-of-type:not([data-stretch])":{flex:"initial"}},icon:{flexShrink:0,width:Lc.reference,height:Lc.reference},indicator:{flexShrink:0,borderRadius:"full",width:ta.reference,height:ta.reference,display:"flex",justifyContent:"center",alignItems:"center","&[data-status=active]":{borderWidth:"2px",borderColor:gh.reference},"&[data-status=complete]":{bg:gh.reference,color:"chakra-inverse-text"},"&[data-status=incomplete]":{borderWidth:"2px"}},separator:{bg:"chakra-border-color",flex:"1","&[data-status=complete]":{bg:gh.reference},"&[data-orientation=horizontal]":{width:"100%",height:"2px",marginStart:"2"},"&[data-orientation=vertical]":{width:"2px",position:"absolute",height:"100%",maxHeight:`calc(100% - ${ta.reference} - 8px)`,top:`calc(${ta.reference} + 4px)`,insetStart:`calc(${ta.reference} / 2 - 1px)`}}})),V6=B6({baseStyle:M6,sizes:{xs:Nh({stepper:{[ta.variable]:"sizes.4",[Lc.variable]:"sizes.3",[zc.variable]:"fontSizes.xs",[Eh.variable]:"fontSizes.xs"}}),sm:Nh({stepper:{[ta.variable]:"sizes.6",[Lc.variable]:"sizes.4",[zc.variable]:"fontSizes.sm",[Eh.variable]:"fontSizes.xs"}}),md:Nh({stepper:{[ta.variable]:"sizes.8",[Lc.variable]:"sizes.5",[zc.variable]:"fontSizes.md",[Eh.variable]:"fontSizes.sm"}}),lg:Nh({stepper:{[ta.variable]:"sizes.10",[Lc.variable]:"sizes.6",[zc.variable]:"fontSizes.lg",[Eh.variable]:"fontSizes.md"}})},defaultProps:{size:"md",colorScheme:"blue"}}),{defineMultiStyleConfig:W6,definePartsStyle:Am}=tn(oB.keys),jh=Ln("switch-track-width"),Cu=Ln("switch-track-height"),w1=Ln("switch-track-diff"),U6=ea.subtract(jh,Cu),kx=Ln("switch-thumb-x"),yh=Ln("switch-bg"),j6=t=>{const{colorScheme:e}=t;return{borderRadius:"full",p:"0.5",width:[jh.reference],height:[Cu.reference],transitionProperty:"common",transitionDuration:"fast",[yh.variable]:"colors.gray.300",_dark:{[yh.variable]:"colors.whiteAlpha.400"},_focusVisible:{boxShadow:"outline"},_disabled:{opacity:.4,cursor:"not-allowed"},_checked:{[yh.variable]:`colors.${e}.500`,_dark:{[yh.variable]:`colors.${e}.200`}},bg:yh.reference}},G6={bg:"white",transitionProperty:"transform",transitionDuration:"normal",borderRadius:"inherit",width:[Cu.reference],height:[Cu.reference],_checked:{transform:`translateX(${kx.reference})`}},H6=Am(t=>({container:{[w1.variable]:U6,[kx.variable]:w1.reference,_rtl:{[kx.variable]:ea(w1).negate().toString()}},track:j6(t),thumb:G6})),K6={sm:Am({container:{[jh.variable]:"1.375rem",[Cu.variable]:"sizes.3"}}),md:Am({container:{[jh.variable]:"1.875rem",[Cu.variable]:"sizes.4"}}),lg:Am({container:{[jh.variable]:"2.875rem",[Cu.variable]:"sizes.6"}})},X6=W6({baseStyle:H6,sizes:K6,defaultProps:{size:"md",colorScheme:"blue"}}),{defineMultiStyleConfig:q6,definePartsStyle:Xc}=tn(iB.keys),Y6=Xc({table:{fontVariantNumeric:"lining-nums tabular-nums",borderCollapse:"collapse",width:"full"},th:{fontFamily:"heading",fontWeight:"bold",textTransform:"uppercase",letterSpacing:"wider",textAlign:"start"},td:{textAlign:"start"},caption:{mt:4,fontFamily:"heading",textAlign:"center",fontWeight:"medium"}}),og={"&[data-is-numeric=true]":{textAlign:"end"}},Q6=Xc(t=>{const{colorScheme:e}=t;return{th:{color:Ye("gray.600","gray.400")(t),borderBottom:"1px",borderColor:Ye(`${e}.100`,`${e}.700`)(t),...og},td:{borderBottom:"1px",borderColor:Ye(`${e}.100`,`${e}.700`)(t),...og},caption:{color:Ye("gray.600","gray.100")(t)},tfoot:{tr:{"&:last-of-type":{th:{borderBottomWidth:0}}}}}}),Z6=Xc(t=>{const{colorScheme:e}=t;return{th:{color:Ye("gray.600","gray.400")(t),borderBottom:"1px",borderColor:Ye(`${e}.100`,`${e}.700`)(t),...og},td:{borderBottom:"1px",borderColor:Ye(`${e}.100`,`${e}.700`)(t),...og},caption:{color:Ye("gray.600","gray.100")(t)},tbody:{tr:{"&:nth-of-type(odd)":{"th, td":{borderBottomWidth:"1px",borderColor:Ye(`${e}.100`,`${e}.700`)(t)},td:{background:Ye(`${e}.100`,`${e}.700`)(t)}}}},tfoot:{tr:{"&:last-of-type":{th:{borderBottomWidth:0}}}}}}),J6={simple:Q6,striped:Z6,unstyled:{}},eW={sm:Xc({th:{px:"4",py:"1",lineHeight:"4",fontSize:"xs"},td:{px:"4",py:"2",fontSize:"sm",lineHeight:"4"},caption:{px:"4",py:"2",fontSize:"xs"}}),md:Xc({th:{px:"6",py:"3",lineHeight:"4",fontSize:"xs"},td:{px:"6",py:"4",lineHeight:"5"},caption:{px:"6",py:"2",fontSize:"sm"}}),lg:Xc({th:{px:"8",py:"4",lineHeight:"5",fontSize:"sm"},td:{px:"8",py:"5",lineHeight:"6"},caption:{px:"6",py:"2",fontSize:"md"}})},tW=q6({baseStyle:Y6,variants:J6,sizes:eW,defaultProps:{variant:"simple",size:"md",colorScheme:"gray"}}),hs=Qe("tabs-color"),Fo=Qe("tabs-bg"),cm=Qe("tabs-border-color"),{defineMultiStyleConfig:nW,definePartsStyle:pi}=tn(aB.keys),rW=t=>{const{orientation:e}=t;return{display:e==="vertical"?"flex":"block"}},sW=t=>{const{isFitted:e}=t;return{flex:e?1:void 0,transitionProperty:"common",transitionDuration:"normal",_focusVisible:{zIndex:1,boxShadow:"outline"},_disabled:{cursor:"not-allowed",opacity:.4}}},oW=t=>{const{align:e="start",orientation:n}=t;return{justifyContent:{end:"flex-end",center:"center",start:"flex-start"}[e],flexDirection:n==="vertical"?"column":"row"}},iW={p:4},aW=pi(t=>({root:rW(t),tab:sW(t),tablist:oW(t),tabpanel:iW})),lW={sm:pi({tab:{py:1,px:4,fontSize:"sm"}}),md:pi({tab:{fontSize:"md",py:2,px:4}}),lg:pi({tab:{fontSize:"lg",py:3,px:4}})},uW=pi(t=>{const{colorScheme:e,orientation:n}=t,r=n==="vertical",s=r?"borderStart":"borderBottom",o=r?"marginStart":"marginBottom";return{tablist:{[s]:"2px solid",borderColor:"inherit"},tab:{[s]:"2px solid",borderColor:"transparent",[o]:"-2px",_selected:{[hs.variable]:`colors.${e}.600`,_dark:{[hs.variable]:`colors.${e}.300`},borderColor:"currentColor"},_active:{[Fo.variable]:"colors.gray.200",_dark:{[Fo.variable]:"colors.whiteAlpha.300"}},_disabled:{_active:{bg:"none"}},color:hs.reference,bg:Fo.reference}}}),cW=pi(t=>{const{colorScheme:e}=t;return{tab:{borderTopRadius:"md",border:"1px solid",borderColor:"transparent",mb:"-1px",[cm.variable]:"transparent",_selected:{[hs.variable]:`colors.${e}.600`,[cm.variable]:"colors.white",_dark:{[hs.variable]:`colors.${e}.300`,[cm.variable]:"colors.gray.800"},borderColor:"inherit",borderBottomColor:cm.reference},color:hs.reference},tablist:{mb:"-1px",borderBottom:"1px solid",borderColor:"inherit"}}}),dW=pi(t=>{const{colorScheme:e}=t;return{tab:{border:"1px solid",borderColor:"inherit",[Fo.variable]:"colors.gray.50",_dark:{[Fo.variable]:"colors.whiteAlpha.50"},mb:"-1px",_notLast:{marginEnd:"-1px"},_selected:{[Fo.variable]:"colors.white",[hs.variable]:`colors.${e}.600`,_dark:{[Fo.variable]:"colors.gray.800",[hs.variable]:`colors.${e}.300`},borderColor:"inherit",borderTopColor:"currentColor",borderBottomColor:"transparent"},color:hs.reference,bg:Fo.reference},tablist:{mb:"-1px",borderBottom:"1px solid",borderColor:"inherit"}}}),hW=pi(t=>{const{colorScheme:e,theme:n}=t;return{tab:{borderRadius:"full",fontWeight:"semibold",color:"gray.600",_selected:{color:Br(n,`${e}.700`),bg:Br(n,`${e}.100`)}}}}),fW=pi(t=>{const{colorScheme:e}=t;return{tab:{borderRadius:"full",fontWeight:"semibold",[hs.variable]:"colors.gray.600",_dark:{[hs.variable]:"inherit"},_selected:{[hs.variable]:"colors.white",[Fo.variable]:`colors.${e}.600`,_dark:{[hs.variable]:"colors.gray.800",[Fo.variable]:`colors.${e}.300`}},color:hs.reference,bg:Fo.reference}}}),pW=pi({}),mW={line:uW,enclosed:cW,"enclosed-colored":dW,"soft-rounded":hW,"solid-rounded":fW,unstyled:pW},gW=nW({baseStyle:aW,sizes:lW,variants:mW,defaultProps:{size:"md",variant:"line",colorScheme:"blue"}}),{defineMultiStyleConfig:yW,definePartsStyle:$u}=tn(lB.keys),b3=Qe("tag-bg"),w3=Qe("tag-color"),S1=Qe("tag-shadow"),Dm=Qe("tag-min-height"),Om=Qe("tag-min-width"),Fm=Qe("tag-font-size"),Lm=Qe("tag-padding-inline"),xW={fontWeight:"medium",lineHeight:1.2,outline:0,[w3.variable]:$n.color.reference,[b3.variable]:$n.bg.reference,[S1.variable]:$n.shadow.reference,color:w3.reference,bg:b3.reference,boxShadow:S1.reference,borderRadius:"md",minH:Dm.reference,minW:Om.reference,fontSize:Fm.reference,px:Lm.reference,_focusVisible:{[S1.variable]:"shadows.outline"}},vW={lineHeight:1.2,overflow:"visible"},bW={fontSize:"lg",w:"5",h:"5",transitionProperty:"common",transitionDuration:"normal",borderRadius:"full",marginStart:"1.5",marginEnd:"-1",opacity:.5,_disabled:{opacity:.4},_focusVisible:{boxShadow:"outline",bg:"rgba(0, 0, 0, 0.14)"},_hover:{opacity:.8},_active:{opacity:1}},wW=$u({container:xW,label:vW,closeButton:bW}),SW={sm:$u({container:{[Dm.variable]:"sizes.5",[Om.variable]:"sizes.5",[Fm.variable]:"fontSizes.xs",[Lm.variable]:"space.2"},closeButton:{marginEnd:"-2px",marginStart:"0.35rem"}}),md:$u({container:{[Dm.variable]:"sizes.6",[Om.variable]:"sizes.6",[Fm.variable]:"fontSizes.sm",[Lm.variable]:"space.2"}}),lg:$u({container:{[Dm.variable]:"sizes.8",[Om.variable]:"sizes.8",[Fm.variable]:"fontSizes.md",[Lm.variable]:"space.3"}})},CW={subtle:$u(t=>{var e;return{container:(e=Vh.variants)==null?void 0:e.subtle(t)}}),solid:$u(t=>{var e;return{container:(e=Vh.variants)==null?void 0:e.solid(t)}}),outline:$u(t=>{var e;return{container:(e=Vh.variants)==null?void 0:e.outline(t)}})},$W=yW({variants:CW,baseStyle:wW,sizes:SW,defaultProps:{size:"md",variant:"subtle",colorScheme:"gray"}});var RE;const kW={...(RE=Ot.baseStyle)==null?void 0:RE.field,paddingY:"2",minHeight:"20",lineHeight:"short",verticalAlign:"top"};var _E;const TW={outline:t=>{var e;return((e=Ot.variants)==null?void 0:e.outline(t).field)??{}},flushed:t=>{var e;return((e=Ot.variants)==null?void 0:e.flushed(t).field)??{}},filled:t=>{var e;return((e=Ot.variants)==null?void 0:e.filled(t).field)??{}},unstyled:((_E=Ot.variants)==null?void 0:_E.unstyled.field)??{}};var PE,AE,DE,OE;const IW={xs:((PE=Ot.sizes)==null?void 0:PE.xs.field)??{},sm:((AE=Ot.sizes)==null?void 0:AE.sm.field)??{},md:((DE=Ot.sizes)==null?void 0:DE.md.field)??{},lg:((OE=Ot.sizes)==null?void 0:OE.lg.field)??{}},NW={baseStyle:kW,sizes:IW,variants:TW,defaultProps:{size:"md",variant:"outline"}},dm=Ln("tooltip-bg"),C1=Ln("tooltip-fg"),EW=Ln("popper-arrow-bg"),RW={bg:dm.reference,color:C1.reference,[dm.variable]:"colors.gray.700",[C1.variable]:"colors.whiteAlpha.900",_dark:{[dm.variable]:"colors.gray.300",[C1.variable]:"colors.gray.900"},[EW.variable]:dm.reference,px:"2",py:"0.5",borderRadius:"sm",fontWeight:"medium",fontSize:"sm",boxShadow:"md",maxW:"xs",zIndex:"tooltip"},_W={baseStyle:RW},PW={Accordion:yB,Alert:eM,Avatar:dM,Badge:Vh,Breadcrumb:wM,Button:RM,Checkbox:ol,CloseButton:GM,Code:qM,Container:QM,Divider:nV,Drawer:fV,Editable:bV,Form:TV,FormError:PV,FormLabel:DV,Heading:LV,Input:Ot,Kbd:KV,Link:qV,List:e5,Menu:d5,Modal:S5,NumberInput:_5,PinInput:O5,Popover:H5,Progress:e6,Radio:o6,Select:h6,Skeleton:p6,SkipLink:g6,Slider:I6,Spinner:R6,Stat:z6,Switch:X6,Table:tW,Tabs:gW,Tag:$W,Textarea:NW,Tooltip:_W,Card:OM,Stepper:V6},AW={none:0,"1px":"1px solid","2px":"2px solid","4px":"4px solid","8px":"8px solid"},DW={base:"0em",sm:"30em",md:"48em",lg:"62em",xl:"80em","2xl":"96em"},OW={transparent:"transparent",current:"currentColor",black:"#000000",white:"#FFFFFF",whiteAlpha:{50:"rgba(255, 255, 255, 0.04)",100:"rgba(255, 255, 255, 0.06)",200:"rgba(255, 255, 255, 0.08)",300:"rgba(255, 255, 255, 0.16)",400:"rgba(255, 255, 255, 0.24)",500:"rgba(255, 255, 255, 0.36)",600:"rgba(255, 255, 255, 0.48)",700:"rgba(255, 255, 255, 0.64)",800:"rgba(255, 255, 255, 0.80)",900:"rgba(255, 255, 255, 0.92)"},blackAlpha:{50:"rgba(0, 0, 0, 0.04)",100:"rgba(0, 0, 0, 0.06)",200:"rgba(0, 0, 0, 0.08)",300:"rgba(0, 0, 0, 0.16)",400:"rgba(0, 0, 0, 0.24)",500:"rgba(0, 0, 0, 0.36)",600:"rgba(0, 0, 0, 0.48)",700:"rgba(0, 0, 0, 0.64)",800:"rgba(0, 0, 0, 0.80)",900:"rgba(0, 0, 0, 0.92)"},gray:{50:"#F7FAFC",100:"#EDF2F7",200:"#E2E8F0",300:"#CBD5E0",400:"#A0AEC0",500:"#718096",600:"#4A5568",700:"#2D3748",800:"#1A202C",900:"#171923"},red:{50:"#FFF5F5",100:"#FED7D7",200:"#FEB2B2",300:"#FC8181",400:"#F56565",500:"#E53E3E",600:"#C53030",700:"#9B2C2C",800:"#822727",900:"#63171B"},orange:{50:"#FFFAF0",100:"#FEEBC8",200:"#FBD38D",300:"#F6AD55",400:"#ED8936",500:"#DD6B20",600:"#C05621",700:"#9C4221",800:"#7B341E",900:"#652B19"},yellow:{50:"#FFFFF0",100:"#FEFCBF",200:"#FAF089",300:"#F6E05E",400:"#ECC94B",500:"#D69E2E",600:"#B7791F",700:"#975A16",800:"#744210",900:"#5F370E"},green:{50:"#F0FFF4",100:"#C6F6D5",200:"#9AE6B4",300:"#68D391",400:"#48BB78",500:"#38A169",600:"#2F855A",700:"#276749",800:"#22543D",900:"#1C4532"},teal:{50:"#E6FFFA",100:"#B2F5EA",200:"#81E6D9",300:"#4FD1C5",400:"#38B2AC",500:"#319795",600:"#2C7A7B",700:"#285E61",800:"#234E52",900:"#1D4044"},blue:{50:"#ebf8ff",100:"#bee3f8",200:"#90cdf4",300:"#63b3ed",400:"#4299e1",500:"#3182ce",600:"#2b6cb0",700:"#2c5282",800:"#2a4365",900:"#1A365D"},cyan:{50:"#EDFDFD",100:"#C4F1F9",200:"#9DECF9",300:"#76E4F7",400:"#0BC5EA",500:"#00B5D8",600:"#00A3C4",700:"#0987A0",800:"#086F83",900:"#065666"},purple:{50:"#FAF5FF",100:"#E9D8FD",200:"#D6BCFA",300:"#B794F4",400:"#9F7AEA",500:"#805AD5",600:"#6B46C1",700:"#553C9A",800:"#44337A",900:"#322659"},pink:{50:"#FFF5F7",100:"#FED7E2",200:"#FBB6CE",300:"#F687B3",400:"#ED64A6",500:"#D53F8C",600:"#B83280",700:"#97266D",800:"#702459",900:"#521B41"}},FW={none:"0",sm:"0.125rem",base:"0.25rem",md:"0.375rem",lg:"0.5rem",xl:"0.75rem","2xl":"1rem","3xl":"1.5rem",full:"9999px"},LW={xs:"0 0 0 1px rgba(0, 0, 0, 0.05)",sm:"0 1px 2px 0 rgba(0, 0, 0, 0.05)",base:"0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",md:"0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",lg:"0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",xl:"0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)","2xl":"0 25px 50px -12px rgba(0, 0, 0, 0.25)",outline:"0 0 0 3px rgba(66, 153, 225, 0.6)",inner:"inset 0 2px 4px 0 rgba(0,0,0,0.06)",none:"none","dark-lg":"rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px"},zW={common:"background-color, border-color, color, fill, stroke, opacity, box-shadow, transform",colors:"background-color, border-color, color, fill, stroke",dimensions:"width, height",position:"left, right, top, bottom",background:"background-color, background-image, background-position"},BW={"ease-in":"cubic-bezier(0.4, 0, 1, 1)","ease-out":"cubic-bezier(0, 0, 0.2, 1)","ease-in-out":"cubic-bezier(0.4, 0, 0.2, 1)"},MW={"ultra-fast":"50ms",faster:"100ms",fast:"150ms",normal:"200ms",slow:"300ms",slower:"400ms","ultra-slow":"500ms"},VW={property:zW,easing:BW,duration:MW},WW={hide:-1,auto:"auto",base:0,docked:10,dropdown:1e3,sticky:1100,banner:1200,overlay:1300,modal:1400,popover:1500,skipLink:1600,toast:1700,tooltip:1800},UW={none:0,sm:"4px",base:"8px",md:"12px",lg:"16px",xl:"24px","2xl":"40px","3xl":"64px"},jW={breakpoints:DW,zIndices:WW,radii:FW,blur:UW,colors:OW,...tR,sizes:qE,shadows:LW,space:XE,borders:AW,transition:VW},GW={colors:{"chakra-body-text":{_light:"gray.800",_dark:"whiteAlpha.900"},"chakra-body-bg":{_light:"white",_dark:"gray.800"},"chakra-border-color":{_light:"gray.200",_dark:"whiteAlpha.300"},"chakra-inverse-text":{_light:"white",_dark:"gray.800"},"chakra-subtle-bg":{_light:"gray.100",_dark:"gray.700"},"chakra-subtle-text":{_light:"gray.600",_dark:"gray.400"},"chakra-placeholder-color":{_light:"gray.500",_dark:"whiteAlpha.400"}}},HW={global:{body:{fontFamily:"body",color:"chakra-body-text",bg:"chakra-body-bg",transitionProperty:"background-color",transitionDuration:"normal",lineHeight:"base"},"*::placeholder":{color:"chakra-placeholder-color"},"*, *::before, &::after":{borderColor:"chakra-border-color"}}},KW=["borders","breakpoints","colors","components","config","direction","fonts","fontSizes","fontWeights","letterSpacings","lineHeights","radii","shadows","sizes","space","styles","transition","zIndices"];function XW(t){return Vr(t)?KW.every(e=>Object.prototype.hasOwnProperty.call(t,e)):!1}const qW="ltr",YW={useSystemColorMode:!1,initialColorMode:"light",cssVarPrefix:"chakra"},oR={semanticTokens:GW,direction:qW,...jW,components:PW,styles:HW,config:YW};function QW(t){if(t.sheet)return t.sheet;for(var e=0;e<document.styleSheets.length;e++)if(document.styleSheets[e].ownerNode===t)return document.styleSheets[e]}function ZW(t){var e=document.createElement("style");return e.setAttribute("data-emotion",t.key),t.nonce!==void 0&&e.setAttribute("nonce",t.nonce),e.appendChild(document.createTextNode("")),e.setAttribute("data-s",""),e}var JW=function(){function t(n){var r=this;this._insertTag=function(s){var o;r.tags.length===0?r.insertionPoint?o=r.insertionPoint.nextSibling:r.prepend?o=r.container.firstChild:o=r.before:o=r.tags[r.tags.length-1].nextSibling,r.container.insertBefore(s,o),r.tags.push(s)},this.isSpeedy=n.speedy===void 0?!0:n.speedy,this.tags=[],this.ctr=0,this.nonce=n.nonce,this.key=n.key,this.container=n.container,this.prepend=n.prepend,this.insertionPoint=n.insertionPoint,this.before=null}var e=t.prototype;return e.hydrate=function(r){r.forEach(this._insertTag)},e.insert=function(r){this.ctr%(this.isSpeedy?65e3:1)===0&&this._insertTag(ZW(this));var s=this.tags[this.tags.length-1];if(this.isSpeedy){var o=QW(s);try{o.insertRule(r,o.cssRules.length)}catch{}}else s.appendChild(document.createTextNode(r));this.ctr++},e.flush=function(){this.tags.forEach(function(r){var s;return(s=r.parentNode)==null?void 0:s.removeChild(r)}),this.tags=[],this.ctr=0},t}(),vr="-ms-",ig="-moz-",At="-webkit-",iR="comm",eb="rule",tb="decl",eU="@import",aR="@keyframes",tU="@layer",nU=Math.abs,Gg=String.fromCharCode,rU=Object.assign;function sU(t,e){return ir(t,0)^45?(((e<<2^ir(t,0))<<2^ir(t,1))<<2^ir(t,2))<<2^ir(t,3):0}function lR(t){return t.trim()}function oU(t,e){return(t=e.exec(t))?t[0]:t}function Dt(t,e,n){return t.replace(e,n)}function Tx(t,e){return t.indexOf(e)}function ir(t,e){return t.charCodeAt(e)|0}function rf(t,e,n){return t.slice(e,n)}function ui(t){return t.length}function nb(t){return t.length}function hm(t,e){return e.push(t),t}function iU(t,e){return t.map(e).join("")}var Hg=1,nd=1,uR=0,ps=0,Nn=0,gd="";function Kg(t,e,n,r,s,o,i){return{value:t,root:e,parent:n,type:r,props:s,children:o,line:Hg,column:nd,length:i,return:""}}function xh(t,e){return rU(Kg("",null,null,"",null,null,0),t,{length:-t.length},e)}function aU(){return Nn}function lU(){return Nn=ps>0?ir(gd,--ps):0,nd--,Nn===10&&(nd=1,Hg--),Nn}function As(){return Nn=ps<uR?ir(gd,ps++):0,nd++,Nn===10&&(nd=1,Hg++),Nn}function mi(){return ir(gd,ps)}function zm(){return ps}function Of(t,e){return rf(gd,t,e)}function sf(t){switch(t){case 0:case 9:case 10:case 13:case 32:return 5;case 33:case 43:case 44:case 47:case 62:case 64:case 126:case 59:case 123:case 125:return 4;case 58:return 3;case 34:case 39:case 40:case 91:return 2;case 41:case 93:return 1}return 0}function cR(t){return Hg=nd=1,uR=ui(gd=t),ps=0,[]}function dR(t){return gd="",t}function Bm(t){return lR(Of(ps-1,Ix(t===91?t+2:t===40?t+1:t)))}function uU(t){for(;(Nn=mi())&&Nn<33;)As();return sf(t)>2||sf(Nn)>3?"":" "}function cU(t,e){for(;--e&&As()&&!(Nn<48||Nn>102||Nn>57&&Nn<65||Nn>70&&Nn<97););return Of(t,zm()+(e<6&&mi()==32&&As()==32))}function Ix(t){for(;As();)switch(Nn){case t:return ps;case 34:case 39:t!==34&&t!==39&&Ix(Nn);break;case 40:t===41&&Ix(t);break;case 92:As();break}return ps}function dU(t,e){for(;As()&&t+Nn!==57;)if(t+Nn===84&&mi()===47)break;return"/*"+Of(e,ps-1)+"*"+Gg(t===47?t:As())}function hU(t){for(;!sf(mi());)As();return Of(t,ps)}function fU(t){return dR(Mm("",null,null,null,[""],t=cR(t),0,[0],t))}function Mm(t,e,n,r,s,o,i,a,l){for(var c=0,d=0,f=i,p=0,g=0,y=0,x=1,w=1,S=1,$=0,I="",R=s,_=o,O=r,F=I;w;)switch(y=$,$=As()){case 40:if(y!=108&&ir(F,f-1)==58){Tx(F+=Dt(Bm($),"&","&\f"),"&\f")!=-1&&(S=-1);break}case 34:case 39:case 91:F+=Bm($);break;case 9:case 10:case 13:case 32:F+=uU(y);break;case 92:F+=cU(zm()-1,7);continue;case 47:switch(mi()){case 42:case 47:hm(pU(dU(As(),zm()),e,n),l);break;default:F+="/"}break;case 123*x:a[c++]=ui(F)*S;case 125*x:case 59:case 0:switch($){case 0:case 125:w=0;case 59+d:S==-1&&(F=Dt(F,/\f/g,"")),g>0&&ui(F)-f&&hm(g>32?C3(F+";",r,n,f-1):C3(Dt(F," ","")+";",r,n,f-2),l);break;case 59:F+=";";default:if(hm(O=S3(F,e,n,c,d,s,a,I,R=[],_=[],f),o),$===123)if(d===0)Mm(F,e,O,O,R,o,f,a,_);else switch(p===99&&ir(F,3)===110?100:p){case 100:case 108:case 109:case 115:Mm(t,O,O,r&&hm(S3(t,O,O,0,0,s,a,I,s,R=[],f),_),s,_,f,a,r?R:_);break;default:Mm(F,O,O,O,[""],_,0,a,_)}}c=d=g=0,x=S=1,I=F="",f=i;break;case 58:f=1+ui(F),g=y;default:if(x<1){if($==123)--x;else if($==125&&x++==0&&lU()==125)continue}switch(F+=Gg($),$*x){case 38:S=d>0?1:(F+="\f",-1);break;case 44:a[c++]=(ui(F)-1)*S,S=1;break;case 64:mi()===45&&(F+=Bm(As())),p=mi(),d=f=ui(I=F+=hU(zm())),$++;break;case 45:y===45&&ui(F)==2&&(x=0)}}return o}function S3(t,e,n,r,s,o,i,a,l,c,d){for(var f=s-1,p=s===0?o:[""],g=nb(p),y=0,x=0,w=0;y<r;++y)for(var S=0,$=rf(t,f+1,f=nU(x=i[y])),I=t;S<g;++S)(I=lR(x>0?p[S]+" "+$:Dt($,/&\f/g,p[S])))&&(l[w++]=I);return Kg(t,e,n,s===0?eb:a,l,c,d)}function pU(t,e,n){return Kg(t,e,n,iR,Gg(aU()),rf(t,2,-2),0)}function C3(t,e,n,r){return Kg(t,e,n,tb,rf(t,0,r),rf(t,r+1,-1),r)}function qc(t,e){for(var n="",r=nb(t),s=0;s<r;s++)n+=e(t[s],s,t,e)||"";return n}function mU(t,e,n,r){switch(t.type){case tU:if(t.children.length)break;case eU:case tb:return t.return=t.return||t.value;case iR:return"";case aR:return t.return=t.value+"{"+qc(t.children,r)+"}";case eb:t.value=t.props.join(",")}return ui(n=qc(t.children,r))?t.return=t.value+"{"+n+"}":""}function gU(t){var e=nb(t);return function(n,r,s,o){for(var i="",a=0;a<e;a++)i+=t[a](n,r,s,o)||"";return i}}function yU(t){return function(e){e.root||(e=e.return)&&t(e)}}var $3=function(e){var n=new WeakMap;return function(r){if(n.has(r))return n.get(r);var s=e(r);return n.set(r,s),s}};function hR(t){var e=Object.create(null);return function(n){return e[n]===void 0&&(e[n]=t(n)),e[n]}}var xU=function(e,n,r){for(var s=0,o=0;s=o,o=mi(),s===38&&o===12&&(n[r]=1),!sf(o);)As();return Of(e,ps)},vU=function(e,n){var r=-1,s=44;do switch(sf(s)){case 0:s===38&&mi()===12&&(n[r]=1),e[r]+=xU(ps-1,n,r);break;case 2:e[r]+=Bm(s);break;case 4:if(s===44){e[++r]=mi()===58?"&\f":"",n[r]=e[r].length;break}default:e[r]+=Gg(s)}while(s=As());return e},bU=function(e,n){return dR(vU(cR(e),n))},k3=new WeakMap,wU=function(e){if(!(e.type!=="rule"||!e.parent||e.length<1)){for(var n=e.value,r=e.parent,s=e.column===r.column&&e.line===r.line;r.type!=="rule";)if(r=r.parent,!r)return;if(!(e.props.length===1&&n.charCodeAt(0)!==58&&!k3.get(r))&&!s){k3.set(e,!0);for(var o=[],i=bU(n,o),a=r.props,l=0,c=0;l<i.length;l++)for(var d=0;d<a.length;d++,c++)e.props[c]=o[l]?i[l].replace(/&\f/g,a[d]):a[d]+" "+i[l]}}},SU=function(e){if(e.type==="decl"){var n=e.value;n.charCodeAt(0)===108&&n.charCodeAt(2)===98&&(e.return="",e.value="")}};function fR(t,e){switch(sU(t,e)){case 5103:return At+"print-"+t+t;case 5737:case 4201:case 3177:case 3433:case 1641:case 4457:case 2921:case 5572:case 6356:case 5844:case 3191:case 6645:case 3005:case 6391:case 5879:case 5623:case 6135:case 4599:case 4855:case 4215:case 6389:case 5109:case 5365:case 5621:case 3829:return At+t+t;case 5349:case 4246:case 4810:case 6968:case 2756:return At+t+ig+t+vr+t+t;case 6828:case 4268:return At+t+vr+t+t;case 6165:return At+t+vr+"flex-"+t+t;case 5187:return At+t+Dt(t,/(\w+).+(:[^]+)/,At+"box-$1$2"+vr+"flex-$1$2")+t;case 5443:return At+t+vr+"flex-item-"+Dt(t,/flex-|-self/,"")+t;case 4675:return At+t+vr+"flex-line-pack"+Dt(t,/align-content|flex-|-self/,"")+t;case 5548:return At+t+vr+Dt(t,"shrink","negative")+t;case 5292:return At+t+vr+Dt(t,"basis","preferred-size")+t;case 6060:return At+"box-"+Dt(t,"-grow","")+At+t+vr+Dt(t,"grow","positive")+t;case 4554:return At+Dt(t,/([^-])(transform)/g,"$1"+At+"$2")+t;case 6187:return Dt(Dt(Dt(t,/(zoom-|grab)/,At+"$1"),/(image-set)/,At+"$1"),t,"")+t;case 5495:case 3959:return Dt(t,/(image-set\([^]*)/,At+"$1$`$1");case 4968:return Dt(Dt(t,/(.+:)(flex-)?(.*)/,At+"box-pack:$3"+vr+"flex-pack:$3"),/s.+-b[^;]+/,"justify")+At+t+t;case 4095:case 3583:case 4068:case 2532:return Dt(t,/(.+)-inline(.+)/,At+"$1$2")+t;case 8116:case 7059:case 5753:case 5535:case 5445:case 5701:case 4933:case 4677:case 5533:case 5789:case 5021:case 4765:if(ui(t)-1-e>6)switch(ir(t,e+1)){case 109:if(ir(t,e+4)!==45)break;case 102:return Dt(t,/(.+:)(.+)-([^]+)/,"$1"+At+"$2-$3$1"+ig+(ir(t,e+3)==108?"$3":"$2-$3"))+t;case 115:return~Tx(t,"stretch")?fR(Dt(t,"stretch","fill-available"),e)+t:t}break;case 4949:if(ir(t,e+1)!==115)break;case 6444:switch(ir(t,ui(t)-3-(~Tx(t,"!important")&&10))){case 107:return Dt(t,":",":"+At)+t;case 101:return Dt(t,/(.+:)([^;!]+)(;|!.+)?/,"$1"+At+(ir(t,14)===45?"inline-":"")+"box$3$1"+At+"$2$3$1"+vr+"$2box$3")+t}break;case 5936:switch(ir(t,e+11)){case 114:return At+t+vr+Dt(t,/[svh]\w+-[tblr]{2}/,"tb")+t;case 108:return At+t+vr+Dt(t,/[svh]\w+-[tblr]{2}/,"tb-rl")+t;case 45:return At+t+vr+Dt(t,/[svh]\w+-[tblr]{2}/,"lr")+t}return At+t+vr+t+t}return t}var CU=function(e,n,r,s){if(e.length>-1&&!e.return)switch(e.type){case tb:e.return=fR(e.value,e.length);break;case aR:return qc([xh(e,{value:Dt(e.value,"@","@"+At)})],s);case eb:if(e.length)return iU(e.props,function(o){switch(oU(o,/(::plac\w+|:read-\w+)/)){case":read-only":case":read-write":return qc([xh(e,{props:[Dt(o,/:(read-\w+)/,":"+ig+"$1")]})],s);case"::placeholder":return qc([xh(e,{props:[Dt(o,/:(plac\w+)/,":"+At+"input-$1")]}),xh(e,{props:[Dt(o,/:(plac\w+)/,":"+ig+"$1")]}),xh(e,{props:[Dt(o,/:(plac\w+)/,vr+"input-$1")]})],s)}return""})}},$U=[CU],kU=function(e){var n=e.key;if(n==="css"){var r=document.querySelectorAll("style[data-emotion]:not([data-s])");Array.prototype.forEach.call(r,function(x){var w=x.getAttribute("data-emotion");w.indexOf(" ")!==-1&&(document.head.appendChild(x),x.setAttribute("data-s",""))})}var s=e.stylisPlugins||$U,o={},i,a=[];i=e.container||document.head,Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="'+n+' "]'),function(x){for(var w=x.getAttribute("data-emotion").split(" "),S=1;S<w.length;S++)o[w[S]]=!0;a.push(x)});var l,c=[wU,SU];{var d,f=[mU,yU(function(x){d.insert(x)})],p=gU(c.concat(s,f)),g=function(w){return qc(fU(w),p)};l=function(w,S,$,I){d=$,g(w?w+"{"+S.styles+"}":S.styles),I&&(y.inserted[S.name]=!0)}}var y={key:n,sheet:new JW({key:n,container:i,nonce:e.nonce,speedy:e.speedy,prepend:e.prepend,insertionPoint:e.insertionPoint}),nonce:e.nonce,inserted:o,registered:{},insert:l};return y.sheet.hydrate(a),y};function ag(){return ag=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)({}).hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},ag.apply(null,arguments)}var $1={exports:{}},Bt={};/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var T3;function TU(){if(T3)return Bt;T3=1;var t=typeof Symbol=="function"&&Symbol.for,e=t?Symbol.for("react.element"):60103,n=t?Symbol.for("react.portal"):60106,r=t?Symbol.for("react.fragment"):60107,s=t?Symbol.for("react.strict_mode"):60108,o=t?Symbol.for("react.profiler"):60114,i=t?Symbol.for("react.provider"):60109,a=t?Symbol.for("react.context"):60110,l=t?Symbol.for("react.async_mode"):60111,c=t?Symbol.for("react.concurrent_mode"):60111,d=t?Symbol.for("react.forward_ref"):60112,f=t?Symbol.for("react.suspense"):60113,p=t?Symbol.for("react.suspense_list"):60120,g=t?Symbol.for("react.memo"):60115,y=t?Symbol.for("react.lazy"):60116,x=t?Symbol.for("react.block"):60121,w=t?Symbol.for("react.fundamental"):60117,S=t?Symbol.for("react.responder"):60118,$=t?Symbol.for("react.scope"):60119;function I(_){if(typeof _=="object"&&_!==null){var O=_.$$typeof;switch(O){case e:switch(_=_.type,_){case l:case c:case r:case o:case s:case f:return _;default:switch(_=_&&_.$$typeof,_){case a:case d:case y:case g:case i:return _;default:return O}}case n:return O}}}function R(_){return I(_)===c}return Bt.AsyncMode=l,Bt.ConcurrentMode=c,Bt.ContextConsumer=a,Bt.ContextProvider=i,Bt.Element=e,Bt.ForwardRef=d,Bt.Fragment=r,Bt.Lazy=y,Bt.Memo=g,Bt.Portal=n,Bt.Profiler=o,Bt.StrictMode=s,Bt.Suspense=f,Bt.isAsyncMode=function(_){return R(_)||I(_)===l},Bt.isConcurrentMode=R,Bt.isContextConsumer=function(_){return I(_)===a},Bt.isContextProvider=function(_){return I(_)===i},Bt.isElement=function(_){return typeof _=="object"&&_!==null&&_.$$typeof===e},Bt.isForwardRef=function(_){return I(_)===d},Bt.isFragment=function(_){return I(_)===r},Bt.isLazy=function(_){return I(_)===y},Bt.isMemo=function(_){return I(_)===g},Bt.isPortal=function(_){return I(_)===n},Bt.isProfiler=function(_){return I(_)===o},Bt.isStrictMode=function(_){return I(_)===s},Bt.isSuspense=function(_){return I(_)===f},Bt.isValidElementType=function(_){return typeof _=="string"||typeof _=="function"||_===r||_===c||_===o||_===s||_===f||_===p||typeof _=="object"&&_!==null&&(_.$$typeof===y||_.$$typeof===g||_.$$typeof===i||_.$$typeof===a||_.$$typeof===d||_.$$typeof===w||_.$$typeof===S||_.$$typeof===$||_.$$typeof===x)},Bt.typeOf=I,Bt}var I3;function IU(){return I3||(I3=1,$1.exports=TU()),$1.exports}var k1,N3;function NU(){if(N3)return k1;N3=1;var t=IU(),e={childContextTypes:!0,contextType:!0,contextTypes:!0,defaultProps:!0,displayName:!0,getDefaultProps:!0,getDerivedStateFromError:!0,getDerivedStateFromProps:!0,mixins:!0,propTypes:!0,type:!0},n={name:!0,length:!0,prototype:!0,caller:!0,callee:!0,arguments:!0,arity:!0},r={$$typeof:!0,render:!0,defaultProps:!0,displayName:!0,propTypes:!0},s={$$typeof:!0,compare:!0,defaultProps:!0,displayName:!0,propTypes:!0,type:!0},o={};o[t.ForwardRef]=r,o[t.Memo]=s;function i(y){return t.isMemo(y)?s:o[y.$$typeof]||e}var a=Object.defineProperty,l=Object.getOwnPropertyNames,c=Object.getOwnPropertySymbols,d=Object.getOwnPropertyDescriptor,f=Object.getPrototypeOf,p=Object.prototype;function g(y,x,w){if(typeof x!="string"){if(p){var S=f(x);S&&S!==p&&g(y,S,w)}var $=l(x);c&&($=$.concat(c(x)));for(var I=i(y),R=i(x),_=0;_<$.length;++_){var O=$[_];if(!n[O]&&!(w&&w[O])&&!(R&&R[O])&&!(I&&I[O])){var F=d(x,O);try{a(y,O,F)}catch{}}}}return y}return k1=g,k1}NU();var EU=!0;function pR(t,e,n){var r="";return n.split(" ").forEach(function(s){t[s]!==void 0?e.push(t[s]+";"):s&&(r+=s+" ")}),r}var rb=function(e,n,r){var s=e.key+"-"+n.name;(r===!1||EU===!1)&&e.registered[s]===void 0&&(e.registered[s]=n.styles)},sb=function(e,n,r){rb(e,n,r);var s=e.key+"-"+n.name;if(e.inserted[n.name]===void 0){var o=n;do e.insert(n===o?"."+s:"",o,e.sheet,!0),o=o.next;while(o!==void 0)}};function RU(t){for(var e=0,n,r=0,s=t.length;s>=4;++r,s-=4)n=t.charCodeAt(r)&255|(t.charCodeAt(++r)&255)<<8|(t.charCodeAt(++r)&255)<<16|(t.charCodeAt(++r)&255)<<24,n=(n&65535)*1540483477+((n>>>16)*59797<<16),n^=n>>>24,e=(n&65535)*1540483477+((n>>>16)*59797<<16)^(e&65535)*1540483477+((e>>>16)*59797<<16);switch(s){case 3:e^=(t.charCodeAt(r+2)&255)<<16;case 2:e^=(t.charCodeAt(r+1)&255)<<8;case 1:e^=t.charCodeAt(r)&255,e=(e&65535)*1540483477+((e>>>16)*59797<<16)}return e^=e>>>13,e=(e&65535)*1540483477+((e>>>16)*59797<<16),((e^e>>>15)>>>0).toString(36)}var _U={animationIterationCount:1,aspectRatio:1,borderImageOutset:1,borderImageSlice:1,borderImageWidth:1,boxFlex:1,boxFlexGroup:1,boxOrdinalGroup:1,columnCount:1,columns:1,flex:1,flexGrow:1,flexPositive:1,flexShrink:1,flexNegative:1,flexOrder:1,gridRow:1,gridRowEnd:1,gridRowSpan:1,gridRowStart:1,gridColumn:1,gridColumnEnd:1,gridColumnSpan:1,gridColumnStart:1,msGridRow:1,msGridRowSpan:1,msGridColumn:1,msGridColumnSpan:1,fontWeight:1,lineHeight:1,opacity:1,order:1,orphans:1,scale:1,tabSize:1,widows:1,zIndex:1,zoom:1,WebkitLineClamp:1,fillOpacity:1,floodOpacity:1,stopOpacity:1,strokeDasharray:1,strokeDashoffset:1,strokeMiterlimit:1,strokeOpacity:1,strokeWidth:1},PU=/[A-Z]|^ms/g,AU=/_EMO_([^_]+?)_([^]*?)_EMO_/g,mR=function(e){return e.charCodeAt(1)===45},E3=function(e){return e!=null&&typeof e!="boolean"},T1=hR(function(t){return mR(t)?t:t.replace(PU,"-$&").toLowerCase()}),R3=function(e,n){switch(e){case"animation":case"animationName":if(typeof n=="string")return n.replace(AU,function(r,s,o){return ci={name:s,styles:o,next:ci},s})}return _U[e]!==1&&!mR(e)&&typeof n=="number"&&n!==0?n+"px":n};function of(t,e,n){if(n==null)return"";var r=n;if(r.__emotion_styles!==void 0)return r;switch(typeof n){case"boolean":return"";case"object":{var s=n;if(s.anim===1)return ci={name:s.name,styles:s.styles,next:ci},s.name;var o=n;if(o.styles!==void 0){var i=o.next;if(i!==void 0)for(;i!==void 0;)ci={name:i.name,styles:i.styles,next:ci},i=i.next;var a=o.styles+";";return a}return DU(t,e,n)}case"function":{if(t!==void 0){var l=ci,c=n(t);return ci=l,of(t,e,c)}break}}var d=n;if(e==null)return d;var f=e[d];return f!==void 0?f:d}function DU(t,e,n){var r="";if(Array.isArray(n))for(var s=0;s<n.length;s++)r+=of(t,e,n[s])+";";else for(var o in n){var i=n[o];if(typeof i!="object"){var a=i;e!=null&&e[a]!==void 0?r+=o+"{"+e[a]+"}":E3(a)&&(r+=T1(o)+":"+R3(o,a)+";")}else if(Array.isArray(i)&&typeof i[0]=="string"&&(e==null||e[i[0]]===void 0))for(var l=0;l<i.length;l++)E3(i[l])&&(r+=T1(o)+":"+R3(o,i[l])+";");else{var c=of(t,e,i);switch(o){case"animation":case"animationName":{r+=T1(o)+":"+c+";";break}default:r+=o+"{"+c+"}"}}}return r}var _3=/label:\s*([^\s;{]+)\s*(;|$)/g,ci;function Xg(t,e,n){if(t.length===1&&typeof t[0]=="object"&&t[0]!==null&&t[0].styles!==void 0)return t[0];var r=!0,s="";ci=void 0;var o=t[0];if(o==null||o.raw===void 0)r=!1,s+=of(n,e,o);else{var i=o;s+=i[0]}for(var a=1;a<t.length;a++)if(s+=of(n,e,t[a]),r){var l=o;s+=l[a]}_3.lastIndex=0;for(var c="",d;(d=_3.exec(s))!==null;)c+="-"+d[1];var f=RU(s)+c;return{name:f,styles:s,next:ci}}var OU=function(e){return e()},gR=Xk.useInsertionEffect?Xk.useInsertionEffect:!1,yR=gR||OU,P3=gR||J.useLayoutEffect,ob=J.createContext(typeof HTMLElement<"u"?kU({key:"css"}):null);ob.Provider;var FU=function(){return J.useContext(ob)},ib=function(e){return J.forwardRef(function(n,r){var s=J.useContext(ob);return e(n,s,r)})},rd=J.createContext({}),LU=function(e,n){if(typeof n=="function"){var r=n(e);return r}return ag({},e,n)},zU=$3(function(t){return $3(function(e){return LU(t,e)})}),BU=function(e){var n=J.useContext(rd);return e.theme!==n&&(n=zU(n)(e.theme)),J.createElement(rd.Provider,{value:n},e.children)},ab={}.hasOwnProperty,Nx="__EMOTION_TYPE_PLEASE_DO_NOT_USE__",MU=function(e,n){var r={};for(var s in n)ab.call(n,s)&&(r[s]=n[s]);return r[Nx]=e,r},VU=function(e){var n=e.cache,r=e.serialized,s=e.isStringTag;return rb(n,r,s),yR(function(){return sb(n,r,s)}),null},WU=ib(function(t,e,n){var r=t.css;typeof r=="string"&&e.registered[r]!==void 0&&(r=e.registered[r]);var s=t[Nx],o=[r],i="";typeof t.className=="string"?i=pR(e.registered,o,t.className):t.className!=null&&(i=t.className+" ");var a=Xg(o,void 0,J.useContext(rd));i+=e.key+"-"+a.name;var l={};for(var c in t)ab.call(t,c)&&c!=="css"&&c!==Nx&&(l[c]=t[c]);return l.className=i,n&&(l.ref=n),J.createElement(J.Fragment,null,J.createElement(VU,{cache:e,serialized:a,isStringTag:typeof s=="string"}),J.createElement(s,l))}),UU=WU,A3=function(e,n){var r=arguments;if(n==null||!ab.call(n,"css"))return J.createElement.apply(void 0,r);var s=r.length,o=new Array(s);o[0]=UU,o[1]=MU(e,n);for(var i=2;i<s;i++)o[i]=r[i];return J.createElement.apply(null,o)};(function(t){var e;e||(e=t.JSX||(t.JSX={}))})(A3||(A3={}));var qg=ib(function(t,e){var n=t.styles,r=Xg([n],void 0,J.useContext(rd)),s=J.useRef();return P3(function(){var o=e.key+"-global",i=new e.sheet.constructor({key:o,nonce:e.sheet.nonce,container:e.sheet.container,speedy:e.sheet.isSpeedy}),a=!1,l=document.querySelector('style[data-emotion="'+o+" "+r.name+'"]');return e.sheet.tags.length&&(i.before=e.sheet.tags[0]),l!==null&&(a=!0,l.setAttribute("data-emotion",o),i.hydrate([l])),s.current=[i,a],function(){i.flush()}},[e]),P3(function(){var o=s.current,i=o[0],a=o[1];if(a){o[1]=!1;return}if(r.next!==void 0&&sb(e,r.next,!0),i.tags.length){var l=i.tags[i.tags.length-1].nextElementSibling;i.before=l,i.flush()}e.insert("",r,i,!1)},[e,r.name]),null});function jU(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];return Xg(e)}function Ff(){var t=jU.apply(void 0,arguments),e="animation-"+t.name;return{name:e,styles:"@keyframes "+e+"{"+t.styles+"}",anim:1,toString:function(){return"_EMO_"+this.name+"_"+this.styles+"_EMO_"}}}const lb=J.createContext({});lb.displayName="ColorModeContext";function ub(){const t=J.useContext(lb);if(t===void 0)throw new Error("useColorMode must be used within a ColorModeProvider");return t}const fm={light:"chakra-ui-light",dark:"chakra-ui-dark"};function GU(t={}){const{preventTransition:e=!0,nonce:n}=t,r={setDataset:s=>{const o=e?r.preventTransition():void 0;document.documentElement.dataset.theme=s,document.documentElement.style.colorScheme=s,o==null||o()},setClassName(s){document.body.classList.add(s?fm.dark:fm.light),document.body.classList.remove(s?fm.light:fm.dark)},query(){return window.matchMedia("(prefers-color-scheme: dark)")},getSystemTheme(s){return r.query().matches??s==="dark"?"dark":"light"},addListener(s){const o=r.query(),i=a=>{s(a.matches?"dark":"light")};return typeof o.addListener=="function"?o.addListener(i):o.addEventListener("change",i),()=>{typeof o.removeListener=="function"?o.removeListener(i):o.removeEventListener("change",i)}},preventTransition(){const s=document.createElement("style");return s.appendChild(document.createTextNode("*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")),n!==void 0&&(s.nonce=n),document.head.appendChild(s),()=>{window.getComputedStyle(document.body),requestAnimationFrame(()=>{requestAnimationFrame(()=>{document.head.removeChild(s)})})}}};return r}const HU="chakra-ui-color-mode";function KU(t){return{ssr:!1,type:"localStorage",get(e){if(!(globalThis!=null&&globalThis.document))return e;let n;try{n=localStorage.getItem(t)||e}catch{}return n||e},set(e){try{localStorage.setItem(t,e)}catch{}}}}const XU=KU(HU),D3=()=>{},qU=pL()?J.useLayoutEffect:J.useEffect;function O3(t,e){return t.type==="cookie"&&t.ssr?t.get(e):e}const xR=function(e){const{value:n,children:r,options:{useSystemColorMode:s,initialColorMode:o,disableTransitionOnChange:i}={},colorModeManager:a=XU}=e,l=FU(),c=o==="dark"?"dark":"light",[d,f]=J.useState(()=>O3(a,c)),[p,g]=J.useState(()=>O3(a)),{getSystemTheme:y,setClassName:x,setDataset:w,addListener:S}=J.useMemo(()=>GU({preventTransition:i,nonce:l==null?void 0:l.nonce}),[i,l==null?void 0:l.nonce]),$=o==="system"&&!d?p:d,I=J.useCallback(O=>{const F=O==="system"?y():O;f(F),x(F==="dark"),w(F),a.set(F)},[a,y,x,w]);qU(()=>{o==="system"&&g(y())},[]),J.useEffect(()=>{const O=a.get();if(O){I(O);return}if(o==="system"){I("system");return}I(c)},[a,c,o,I]);const R=J.useCallback(()=>{I($==="dark"?"light":"dark")},[$,I]);J.useEffect(()=>{if(s)return S(I)},[s,S,I]);const _=J.useMemo(()=>({colorMode:n??$,toggleColorMode:n?D3:R,setColorMode:n?D3:I,forced:n!==void 0}),[$,R,I,n]);return K.jsx(lb.Provider,{value:_,children:r})};xR.displayName="ColorModeProvider";const vR=String.raw,bR=vR`
  :root,
  :host {
    --chakra-vh: 100vh;
  }

  @supports (height: -webkit-fill-available) {
    :root,
    :host {
      --chakra-vh: -webkit-fill-available;
    }
  }

  @supports (height: -moz-fill-available) {
    :root,
    :host {
      --chakra-vh: -moz-fill-available;
    }
  }

  @supports (height: 100dvh) {
    :root,
    :host {
      --chakra-vh: 100dvh;
    }
  }
`,YU=()=>K.jsx(qg,{styles:bR}),QU=({scope:t=""})=>K.jsx(qg,{styles:vR`
      html {
        line-height: 1.5;
        -webkit-text-size-adjust: 100%;
        font-family: system-ui, sans-serif;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        -moz-osx-font-smoothing: grayscale;
        touch-action: manipulation;
      }

      body {
        position: relative;
        min-height: 100%;
        margin: 0;
        font-feature-settings: "kern";
      }

      ${t} :where(*, *::before, *::after) {
        border-width: 0;
        border-style: solid;
        box-sizing: border-box;
        word-wrap: break-word;
      }

      main {
        display: block;
      }

      ${t} hr {
        border-top-width: 1px;
        box-sizing: content-box;
        height: 0;
        overflow: visible;
      }

      ${t} :where(pre, code, kbd,samp) {
        font-family: SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: 1em;
      }

      ${t} a {
        background-color: transparent;
        color: inherit;
        text-decoration: inherit;
      }

      ${t} abbr[title] {
        border-bottom: none;
        text-decoration: underline;
        -webkit-text-decoration: underline dotted;
        text-decoration: underline dotted;
      }

      ${t} :where(b, strong) {
        font-weight: bold;
      }

      ${t} small {
        font-size: 80%;
      }

      ${t} :where(sub,sup) {
        font-size: 75%;
        line-height: 0;
        position: relative;
        vertical-align: baseline;
      }

      ${t} sub {
        bottom: -0.25em;
      }

      ${t} sup {
        top: -0.5em;
      }

      ${t} img {
        border-style: none;
      }

      ${t} :where(button, input, optgroup, select, textarea) {
        font-family: inherit;
        font-size: 100%;
        line-height: 1.15;
        margin: 0;
      }

      ${t} :where(button, input) {
        overflow: visible;
      }

      ${t} :where(button, select) {
        text-transform: none;
      }

      ${t} :where(
          button::-moz-focus-inner,
          [type="button"]::-moz-focus-inner,
          [type="reset"]::-moz-focus-inner,
          [type="submit"]::-moz-focus-inner
        ) {
        border-style: none;
        padding: 0;
      }

      ${t} fieldset {
        padding: 0.35em 0.75em 0.625em;
      }

      ${t} legend {
        box-sizing: border-box;
        color: inherit;
        display: table;
        max-width: 100%;
        padding: 0;
        white-space: normal;
      }

      ${t} progress {
        vertical-align: baseline;
      }

      ${t} textarea {
        overflow: auto;
      }

      ${t} :where([type="checkbox"], [type="radio"]) {
        box-sizing: border-box;
        padding: 0;
      }

      ${t} input[type="number"]::-webkit-inner-spin-button,
      ${t} input[type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none !important;
      }

      ${t} input[type="number"] {
        -moz-appearance: textfield;
      }

      ${t} input[type="search"] {
        -webkit-appearance: textfield;
        outline-offset: -2px;
      }

      ${t} input[type="search"]::-webkit-search-decoration {
        -webkit-appearance: none !important;
      }

      ${t} ::-webkit-file-upload-button {
        -webkit-appearance: button;
        font: inherit;
      }

      ${t} details {
        display: block;
      }

      ${t} summary {
        display: list-item;
      }

      template {
        display: none;
      }

      [hidden] {
        display: none !important;
      }

      ${t} :where(
          blockquote,
          dl,
          dd,
          h1,
          h2,
          h3,
          h4,
          h5,
          h6,
          hr,
          figure,
          p,
          pre
        ) {
        margin: 0;
      }

      ${t} button {
        background: transparent;
        padding: 0;
      }

      ${t} fieldset {
        margin: 0;
        padding: 0;
      }

      ${t} :where(ol, ul) {
        margin: 0;
        padding: 0;
      }

      ${t} textarea {
        resize: vertical;
      }

      ${t} :where(button, [role="button"]) {
        cursor: pointer;
      }

      ${t} button::-moz-focus-inner {
        border: 0 !important;
      }

      ${t} table {
        border-collapse: collapse;
      }

      ${t} :where(h1, h2, h3, h4, h5, h6) {
        font-size: inherit;
        font-weight: inherit;
      }

      ${t} :where(button, input, optgroup, select, textarea) {
        padding: 0;
        line-height: inherit;
        color: inherit;
      }

      ${t} :where(img, svg, video, canvas, audio, iframe, embed, object) {
        display: block;
      }

      ${t} :where(img, video) {
        max-width: 100%;
        height: auto;
      }

      [data-js-focus-visible]
        :focus:not([data-focus-visible-added]):not(
          [data-focus-visible-disabled]
        ) {
        outline: none;
        box-shadow: none;
      }

      ${t} select::-ms-expand {
        display: none;
      }

      ${bR}
    `});function ZU(t){const{cssVarsRoot:e,theme:n,children:r}=t,s=J.useMemo(()=>zz(n),[n]);return K.jsxs(BU,{theme:s,children:[K.jsx(JU,{root:e}),r]})}function JU({root:t=":host, :root"}){const e=[t,"[data-theme]"].join(",");return K.jsx(qg,{styles:n=>({[e]:n.__cssVars})})}Hr({name:"StylesContext",errorMessage:"useStyles: `styles` is undefined. Seems you forgot to wrap the components in `<StylesProvider />` "});function e8(t){return Hr({name:`${t}StylesContext`,errorMessage:`useStyles: "styles" is undefined. Seems you forgot to wrap the components in "<${t} />" `})}function t8(){const{colorMode:t}=ub();return K.jsx(qg,{styles:e=>{const n=BE(e,"styles.global"),r=ro(n,{theme:e,colorMode:t});return r?jE(r)(e):void 0}})}const[n8,r8]=Hr({strict:!1,name:"PortalManagerContext"});function wR(t){const{children:e,zIndex:n}=t;return K.jsx(n8,{value:{zIndex:n},children:e})}wR.displayName="PortalManager";const SR=J.createContext({getDocument(){return document},getWindow(){return window}});SR.displayName="EnvironmentContext";function CR(t){const{children:e,environment:n,disabled:r}=t,s=J.useRef(null),o=J.useMemo(()=>n||{getDocument:()=>{var a;return((a=s.current)==null?void 0:a.ownerDocument)??document},getWindow:()=>{var a;return((a=s.current)==null?void 0:a.ownerDocument.defaultView)??window}},[n]),i=!r||!n;return K.jsxs(SR.Provider,{value:o,children:[e,i&&K.jsx("span",{id:"__chakra_env",hidden:!0,ref:s})]})}CR.displayName="EnvironmentProvider";const s8=t=>{const{children:e,colorModeManager:n,portalZIndex:r,resetScope:s,resetCSS:o=!0,theme:i={},environment:a,cssVarsRoot:l,disableEnvironment:c,disableGlobalStyle:d}=t,f=K.jsx(CR,{environment:a,disabled:c,children:e});return K.jsx(ZU,{theme:i,cssVarsRoot:l,children:K.jsxs(xR,{colorModeManager:n,options:i.config,children:[o?K.jsx(QU,{scope:s}):K.jsx(YU,{}),!d&&K.jsx(t8,{}),r?K.jsx(wR,{zIndex:r,children:f}):f]})})},cb=J.createContext({});function db(t){const e=J.useRef(null);return e.current===null&&(e.current=t()),e.current}const hb=typeof window<"u",$R=hb?J.useLayoutEffect:J.useEffect,Lf=J.createContext(null),fb=J.createContext({transformPagePoint:t=>t,isStatic:!1,reducedMotion:"never"});class o8 extends J.Component{getSnapshotBeforeUpdate(e){const n=this.props.childRef.current;if(n&&e.isPresent&&!this.props.isPresent){const r=n.offsetParent,s=r instanceof HTMLElement&&r.offsetWidth||0,o=this.props.sizeRef.current;o.height=n.offsetHeight||0,o.width=n.offsetWidth||0,o.top=n.offsetTop,o.left=n.offsetLeft,o.right=s-o.width-o.left}return null}componentDidUpdate(){}render(){return this.props.children}}function i8({children:t,isPresent:e,anchorX:n}){const r=J.useId(),s=J.useRef(null),o=J.useRef({width:0,height:0,top:0,left:0,right:0}),{nonce:i}=J.useContext(fb);return J.useInsertionEffect(()=>{const{width:a,height:l,top:c,left:d,right:f}=o.current;if(e||!s.current||!a||!l)return;const p=n==="left"?`left: ${d}`:`right: ${f}`;s.current.dataset.motionPopId=r;const g=document.createElement("style");return i&&(g.nonce=i),document.head.appendChild(g),g.sheet&&g.sheet.insertRule(`
          [data-motion-pop-id="${r}"] {
            position: absolute !important;
            width: ${a}px !important;
            height: ${l}px !important;
            ${p}px !important;
            top: ${c}px !important;
          }
        `),()=>{document.head.removeChild(g)}},[e]),K.jsx(o8,{isPresent:e,childRef:s,sizeRef:o,children:J.cloneElement(t,{ref:s})})}const a8=({children:t,initial:e,isPresent:n,onExitComplete:r,custom:s,presenceAffectsLayout:o,mode:i,anchorX:a})=>{const l=db(l8),c=J.useId();let d=!0,f=J.useMemo(()=>(d=!1,{id:c,initial:e,isPresent:n,custom:s,onExitComplete:p=>{l.set(p,!0);for(const g of l.values())if(!g)return;r&&r()},register:p=>(l.set(p,!1),()=>l.delete(p))}),[n,l,r]);return o&&d&&(f={...f}),J.useMemo(()=>{l.forEach((p,g)=>l.set(g,!1))},[n]),J.useEffect(()=>{!n&&!l.size&&r&&r()},[n]),i==="popLayout"&&(t=K.jsx(i8,{isPresent:n,anchorX:a,children:t})),K.jsx(Lf.Provider,{value:f,children:t})};function l8(){return new Map}function kR(t=!0){const e=J.useContext(Lf);if(e===null)return[!0,null];const{isPresent:n,onExitComplete:r,register:s}=e,o=J.useId();J.useEffect(()=>{if(t)return s(o)},[t]);const i=J.useCallback(()=>t&&r&&r(o),[o,r,t]);return!n&&r?[!1,i]:[!0]}function u8(){return c8(J.useContext(Lf))}function c8(t){return t===null?!0:t.isPresent}const pm=t=>t.key||"";function F3(t){const e=[];return J.Children.forEach(t,n=>{J.isValidElement(n)&&e.push(n)}),e}const pb=({children:t,custom:e,initial:n=!0,onExitComplete:r,presenceAffectsLayout:s=!0,mode:o="sync",propagate:i=!1,anchorX:a="left"})=>{const[l,c]=kR(i),d=J.useMemo(()=>F3(t),[t]),f=i&&!l?[]:d.map(pm),p=J.useRef(!0),g=J.useRef(d),y=db(()=>new Map),[x,w]=J.useState(d),[S,$]=J.useState(d);$R(()=>{p.current=!1,g.current=d;for(let _=0;_<S.length;_++){const O=pm(S[_]);f.includes(O)?y.delete(O):y.get(O)!==!0&&y.set(O,!1)}},[S,f.length,f.join("-")]);const I=[];if(d!==x){let _=[...d];for(let O=0;O<S.length;O++){const F=S[O],B=pm(F);f.includes(B)||(_.splice(O,0,F),I.push(F))}return o==="wait"&&I.length&&(_=I),$(F3(_)),w(d),null}const{forceRender:R}=J.useContext(cb);return K.jsx(K.Fragment,{children:S.map(_=>{const O=pm(_),F=i&&!l?!1:d===S||f.includes(O),B=()=>{if(y.has(O))y.set(O,!0);else return;let M=!0;y.forEach(V=>{V||(M=!1)}),M&&(R==null||R(),$(g.current),i&&(c==null||c()),r&&r())};return K.jsx(a8,{isPresent:F,initial:!p.current||n?void 0:!1,custom:e,presenceAffectsLayout:s,mode:o,onExitComplete:F?void 0:B,anchorX:a,children:_},O)})})};function mb(t,e){t.indexOf(e)===-1&&t.push(e)}function gb(t,e){const n=t.indexOf(e);n>-1&&t.splice(n,1)}const ca=(t,e,n)=>n>e?e:n<t?t:n;let yb=()=>{};const da={},TR=t=>/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t),IR=t=>/^0[^.\s]+$/u.test(t);function xb(t){let e;return()=>(e===void 0&&(e=t()),e)}const io=t=>t,d8=(t,e)=>n=>e(t(n)),zf=(...t)=>t.reduce(d8),af=(t,e,n)=>{const r=e-t;return r===0?1:(n-t)/r};class vb{constructor(){this.subscriptions=[]}add(e){return mb(this.subscriptions,e),()=>gb(this.subscriptions,e)}notify(e,n,r){const s=this.subscriptions.length;if(s)if(s===1)this.subscriptions[0](e,n,r);else for(let o=0;o<s;o++){const i=this.subscriptions[o];i&&i(e,n,r)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}const gi=t=>t*1e3,yi=t=>t/1e3;function NR(t,e){return e?t*(1e3/e):0}const ER=(t,e,n)=>(((1-3*n+3*e)*t+(3*n-6*e))*t+3*e)*t,h8=1e-7,f8=12;function p8(t,e,n,r,s){let o,i,a=0;do i=e+(n-e)/2,o=ER(i,r,s)-t,o>0?n=i:e=i;while(Math.abs(o)>h8&&++a<f8);return i}function Bf(t,e,n,r){if(t===e&&n===r)return io;const s=o=>p8(o,0,1,t,n);return o=>o===0||o===1?o:ER(s(o),e,r)}const RR=t=>e=>e<=.5?t(2*e)/2:(2-t(2*(1-e)))/2,_R=t=>e=>1-t(1-e),PR=Bf(.33,1.53,.69,.99),bb=_R(PR),AR=RR(bb),DR=t=>(t*=2)<1?.5*bb(t):.5*(2-Math.pow(2,-10*(t-1))),wb=t=>1-Math.sin(Math.acos(t)),OR=_R(wb),FR=RR(wb),m8=Bf(.42,0,1,1),g8=Bf(0,0,.58,1),LR=Bf(.42,0,.58,1),y8=t=>Array.isArray(t)&&typeof t[0]!="number",zR=t=>Array.isArray(t)&&typeof t[0]=="number",x8={linear:io,easeIn:m8,easeInOut:LR,easeOut:g8,circIn:wb,circInOut:FR,circOut:OR,backIn:bb,backInOut:AR,backOut:PR,anticipate:DR},v8=t=>typeof t=="string",L3=t=>{if(zR(t)){yb(t.length===4);const[e,n,r,s]=t;return Bf(e,n,r,s)}else if(v8(t))return x8[t];return t},mm=["setup","read","resolveKeyframes","preUpdate","update","preRender","render","postRender"],z3={value:null};function b8(t,e){let n=new Set,r=new Set,s=!1,o=!1;const i=new WeakSet;let a={delta:0,timestamp:0,isProcessing:!1},l=0;function c(f){i.has(f)&&(d.schedule(f),t()),l++,f(a)}const d={schedule:(f,p=!1,g=!1)=>{const x=g&&s?n:r;return p&&i.add(f),x.has(f)||x.add(f),f},cancel:f=>{r.delete(f),i.delete(f)},process:f=>{if(a=f,s){o=!0;return}s=!0,[n,r]=[r,n],n.forEach(c),e&&z3.value&&z3.value.frameloop[e].push(l),l=0,n.clear(),s=!1,o&&(o=!1,d.process(f))}};return d}const w8=40;function BR(t,e){let n=!1,r=!0;const s={delta:0,timestamp:0,isProcessing:!1},o=()=>n=!0,i=mm.reduce((I,R)=>(I[R]=b8(o,e?R:void 0),I),{}),{setup:a,read:l,resolveKeyframes:c,preUpdate:d,update:f,preRender:p,render:g,postRender:y}=i,x=()=>{const I=da.useManualTiming?s.timestamp:performance.now();n=!1,da.useManualTiming||(s.delta=r?1e3/60:Math.max(Math.min(I-s.timestamp,w8),1)),s.timestamp=I,s.isProcessing=!0,a.process(s),l.process(s),c.process(s),d.process(s),f.process(s),p.process(s),g.process(s),y.process(s),s.isProcessing=!1,n&&e&&(r=!1,t(x))},w=()=>{n=!0,r=!0,s.isProcessing||t(x)};return{schedule:mm.reduce((I,R)=>{const _=i[R];return I[R]=(O,F=!1,B=!1)=>(n||w(),_.schedule(O,F,B)),I},{}),cancel:I=>{for(let R=0;R<mm.length;R++)i[mm[R]].cancel(I)},state:s,steps:i}}const{schedule:mn,cancel:ml,state:or,steps:I1}=BR(typeof requestAnimationFrame<"u"?requestAnimationFrame:io,!0);let Vm;function S8(){Vm=void 0}const fs={now:()=>(Vm===void 0&&fs.set(or.isProcessing||da.useManualTiming?or.timestamp:performance.now()),Vm),set:t=>{Vm=t,queueMicrotask(S8)}},MR=t=>e=>typeof e=="string"&&e.startsWith(t),Sb=MR("--"),C8=MR("var(--"),Cb=t=>C8(t)?$8.test(t.split("/*")[0].trim()):!1,$8=/var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,yd={test:t=>typeof t=="number",parse:parseFloat,transform:t=>t},lf={...yd,transform:t=>ca(0,1,t)},gm={...yd,default:1},Gh=t=>Math.round(t*1e5)/1e5,$b=/-?(?:\d+(?:\.\d+)?|\.\d+)/gu;function k8(t){return t==null}const T8=/^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,kb=(t,e)=>n=>!!(typeof n=="string"&&T8.test(n)&&n.startsWith(t)||e&&!k8(n)&&Object.prototype.hasOwnProperty.call(n,e)),VR=(t,e,n)=>r=>{if(typeof r!="string")return r;const[s,o,i,a]=r.match($b);return{[t]:parseFloat(s),[e]:parseFloat(o),[n]:parseFloat(i),alpha:a!==void 0?parseFloat(a):1}},I8=t=>ca(0,255,t),N1={...yd,transform:t=>Math.round(I8(t))},yu={test:kb("rgb","red"),parse:VR("red","green","blue"),transform:({red:t,green:e,blue:n,alpha:r=1})=>"rgba("+N1.transform(t)+", "+N1.transform(e)+", "+N1.transform(n)+", "+Gh(lf.transform(r))+")"};function N8(t){let e="",n="",r="",s="";return t.length>5?(e=t.substring(1,3),n=t.substring(3,5),r=t.substring(5,7),s=t.substring(7,9)):(e=t.substring(1,2),n=t.substring(2,3),r=t.substring(3,4),s=t.substring(4,5),e+=e,n+=n,r+=r,s+=s),{red:parseInt(e,16),green:parseInt(n,16),blue:parseInt(r,16),alpha:s?parseInt(s,16)/255:1}}const Ex={test:kb("#"),parse:N8,transform:yu.transform},Mf=t=>({test:e=>typeof e=="string"&&e.endsWith(t)&&e.split(" ").length===1,parse:parseFloat,transform:e=>`${e}${t}`}),sl=Mf("deg"),xi=Mf("%"),rt=Mf("px"),E8=Mf("vh"),R8=Mf("vw"),B3={...xi,parse:t=>xi.parse(t)/100,transform:t=>xi.transform(t*100)},Bc={test:kb("hsl","hue"),parse:VR("hue","saturation","lightness"),transform:({hue:t,saturation:e,lightness:n,alpha:r=1})=>"hsla("+Math.round(t)+", "+xi.transform(Gh(e))+", "+xi.transform(Gh(n))+", "+Gh(lf.transform(r))+")"},br={test:t=>yu.test(t)||Ex.test(t)||Bc.test(t),parse:t=>yu.test(t)?yu.parse(t):Bc.test(t)?Bc.parse(t):Ex.parse(t),transform:t=>typeof t=="string"?t:t.hasOwnProperty("red")?yu.transform(t):Bc.transform(t)},_8=/(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;function P8(t){var e,n;return isNaN(t)&&typeof t=="string"&&(((e=t.match($b))==null?void 0:e.length)||0)+(((n=t.match(_8))==null?void 0:n.length)||0)>0}const WR="number",UR="color",A8="var",D8="var(",M3="${}",O8=/var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;function uf(t){const e=t.toString(),n=[],r={color:[],number:[],var:[]},s=[];let o=0;const a=e.replace(O8,l=>(br.test(l)?(r.color.push(o),s.push(UR),n.push(br.parse(l))):l.startsWith(D8)?(r.var.push(o),s.push(A8),n.push(l)):(r.number.push(o),s.push(WR),n.push(parseFloat(l))),++o,M3)).split(M3);return{values:n,split:a,indexes:r,types:s}}function jR(t){return uf(t).values}function GR(t){const{split:e,types:n}=uf(t),r=e.length;return s=>{let o="";for(let i=0;i<r;i++)if(o+=e[i],s[i]!==void 0){const a=n[i];a===WR?o+=Gh(s[i]):a===UR?o+=br.transform(s[i]):o+=s[i]}return o}}const F8=t=>typeof t=="number"?0:t;function L8(t){const e=jR(t);return GR(t)(e.map(F8))}const gl={test:P8,parse:jR,createTransformer:GR,getAnimatableNone:L8};function E1(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+(e-t)*6*n:n<1/2?e:n<2/3?t+(e-t)*(2/3-n)*6:t}function z8({hue:t,saturation:e,lightness:n,alpha:r}){t/=360,e/=100,n/=100;let s=0,o=0,i=0;if(!e)s=o=i=n;else{const a=n<.5?n*(1+e):n+e-n*e,l=2*n-a;s=E1(l,a,t+1/3),o=E1(l,a,t),i=E1(l,a,t-1/3)}return{red:Math.round(s*255),green:Math.round(o*255),blue:Math.round(i*255),alpha:r}}function lg(t,e){return n=>n>0?e:t}const pn=(t,e,n)=>t+(e-t)*n,R1=(t,e,n)=>{const r=t*t,s=n*(e*e-r)+r;return s<0?0:Math.sqrt(s)},B8=[Ex,yu,Bc],M8=t=>B8.find(e=>e.test(t));function V3(t){const e=M8(t);if(!e)return!1;let n=e.parse(t);return e===Bc&&(n=z8(n)),n}const W3=(t,e)=>{const n=V3(t),r=V3(e);if(!n||!r)return lg(t,e);const s={...n};return o=>(s.red=R1(n.red,r.red,o),s.green=R1(n.green,r.green,o),s.blue=R1(n.blue,r.blue,o),s.alpha=pn(n.alpha,r.alpha,o),yu.transform(s))},Rx=new Set(["none","hidden"]);function V8(t,e){return Rx.has(t)?n=>n<=0?t:e:n=>n>=1?e:t}function W8(t,e){return n=>pn(t,e,n)}function Tb(t){return typeof t=="number"?W8:typeof t=="string"?Cb(t)?lg:br.test(t)?W3:G8:Array.isArray(t)?HR:typeof t=="object"?br.test(t)?W3:U8:lg}function HR(t,e){const n=[...t],r=n.length,s=t.map((o,i)=>Tb(o)(o,e[i]));return o=>{for(let i=0;i<r;i++)n[i]=s[i](o);return n}}function U8(t,e){const n={...t,...e},r={};for(const s in n)t[s]!==void 0&&e[s]!==void 0&&(r[s]=Tb(t[s])(t[s],e[s]));return s=>{for(const o in r)n[o]=r[o](s);return n}}function j8(t,e){const n=[],r={color:0,var:0,number:0};for(let s=0;s<e.values.length;s++){const o=e.types[s],i=t.indexes[o][r[o]],a=t.values[i]??0;n[s]=a,r[o]++}return n}const G8=(t,e)=>{const n=gl.createTransformer(e),r=uf(t),s=uf(e);return r.indexes.var.length===s.indexes.var.length&&r.indexes.color.length===s.indexes.color.length&&r.indexes.number.length>=s.indexes.number.length?Rx.has(t)&&!s.values.length||Rx.has(e)&&!r.values.length?V8(t,e):zf(HR(j8(r,s),s.values),n):lg(t,e)};function KR(t,e,n){return typeof t=="number"&&typeof e=="number"&&typeof n=="number"?pn(t,e,n):Tb(t)(t,e)}const H8=t=>{const e=({timestamp:n})=>t(n);return{start:()=>mn.update(e,!0),stop:()=>ml(e),now:()=>or.isProcessing?or.timestamp:fs.now()}},XR=(t,e,n=10)=>{let r="";const s=Math.max(Math.round(e/n),2);for(let o=0;o<s;o++)r+=t(o/(s-1))+", ";return`linear(${r.substring(0,r.length-2)})`},ug=2e4;function Ib(t){let e=0;const n=50;let r=t.next(e);for(;!r.done&&e<ug;)e+=n,r=t.next(e);return e>=ug?1/0:e}function K8(t,e=100,n){const r=n({...t,keyframes:[0,e]}),s=Math.min(Ib(r),ug);return{type:"keyframes",ease:o=>r.next(s*o).value/e,duration:yi(s)}}const X8=5;function qR(t,e,n){const r=Math.max(e-X8,0);return NR(n-t(r),e-r)}const vn={stiffness:100,damping:10,mass:1,velocity:0,duration:800,bounce:.3,visualDuration:.3,restSpeed:{granular:.01,default:2},restDelta:{granular:.005,default:.5},minDuration:.01,maxDuration:10,minDamping:.05,maxDamping:1},U3=.001;function q8({duration:t=vn.duration,bounce:e=vn.bounce,velocity:n=vn.velocity,mass:r=vn.mass}){let s,o,i=1-e;i=ca(vn.minDamping,vn.maxDamping,i),t=ca(vn.minDuration,vn.maxDuration,yi(t)),i<1?(s=c=>{const d=c*i,f=d*t,p=d-n,g=_x(c,i),y=Math.exp(-f);return U3-p/g*y},o=c=>{const f=c*i*t,p=f*n+n,g=Math.pow(i,2)*Math.pow(c,2)*t,y=Math.exp(-f),x=_x(Math.pow(c,2),i);return(-s(c)+U3>0?-1:1)*((p-g)*y)/x}):(s=c=>{const d=Math.exp(-c*t),f=(c-n)*t+1;return-.001+d*f},o=c=>{const d=Math.exp(-c*t),f=(n-c)*(t*t);return d*f});const a=5/t,l=Q8(s,o,a);if(t=gi(t),isNaN(l))return{stiffness:vn.stiffness,damping:vn.damping,duration:t};{const c=Math.pow(l,2)*r;return{stiffness:c,damping:i*2*Math.sqrt(r*c),duration:t}}}const Y8=12;function Q8(t,e,n){let r=n;for(let s=1;s<Y8;s++)r=r-t(r)/e(r);return r}function _x(t,e){return t*Math.sqrt(1-e*e)}const Z8=["duration","bounce"],J8=["stiffness","damping","mass"];function j3(t,e){return e.some(n=>t[n]!==void 0)}function ej(t){let e={velocity:vn.velocity,stiffness:vn.stiffness,damping:vn.damping,mass:vn.mass,isResolvedFromDuration:!1,...t};if(!j3(t,J8)&&j3(t,Z8))if(t.visualDuration){const n=t.visualDuration,r=2*Math.PI/(n*1.2),s=r*r,o=2*ca(.05,1,1-(t.bounce||0))*Math.sqrt(s);e={...e,mass:vn.mass,stiffness:s,damping:o}}else{const n=q8(t);e={...e,...n,mass:vn.mass},e.isResolvedFromDuration=!0}return e}function cg(t=vn.visualDuration,e=vn.bounce){const n=typeof t!="object"?{visualDuration:t,keyframes:[0,1],bounce:e}:t;let{restSpeed:r,restDelta:s}=n;const o=n.keyframes[0],i=n.keyframes[n.keyframes.length-1],a={done:!1,value:o},{stiffness:l,damping:c,mass:d,duration:f,velocity:p,isResolvedFromDuration:g}=ej({...n,velocity:-yi(n.velocity||0)}),y=p||0,x=c/(2*Math.sqrt(l*d)),w=i-o,S=yi(Math.sqrt(l/d)),$=Math.abs(w)<5;r||(r=$?vn.restSpeed.granular:vn.restSpeed.default),s||(s=$?vn.restDelta.granular:vn.restDelta.default);let I;if(x<1){const _=_x(S,x);I=O=>{const F=Math.exp(-x*S*O);return i-F*((y+x*S*w)/_*Math.sin(_*O)+w*Math.cos(_*O))}}else if(x===1)I=_=>i-Math.exp(-S*_)*(w+(y+S*w)*_);else{const _=S*Math.sqrt(x*x-1);I=O=>{const F=Math.exp(-x*S*O),B=Math.min(_*O,300);return i-F*((y+x*S*w)*Math.sinh(B)+_*w*Math.cosh(B))/_}}const R={calculatedDuration:g&&f||null,next:_=>{const O=I(_);if(g)a.done=_>=f;else{let F=_===0?y:0;x<1&&(F=_===0?gi(y):qR(I,_,O));const B=Math.abs(F)<=r,M=Math.abs(i-O)<=s;a.done=B&&M}return a.value=a.done?i:O,a},toString:()=>{const _=Math.min(Ib(R),ug),O=XR(F=>R.next(_*F).value,_,30);return _+"ms "+O},toTransition:()=>{}};return R}cg.applyToOptions=t=>{const e=K8(t,100,cg);return t.ease=e.ease,t.duration=gi(e.duration),t.type="keyframes",t};function Px({keyframes:t,velocity:e=0,power:n=.8,timeConstant:r=325,bounceDamping:s=10,bounceStiffness:o=500,modifyTarget:i,min:a,max:l,restDelta:c=.5,restSpeed:d}){const f=t[0],p={done:!1,value:f},g=B=>a!==void 0&&B<a||l!==void 0&&B>l,y=B=>a===void 0?l:l===void 0||Math.abs(a-B)<Math.abs(l-B)?a:l;let x=n*e;const w=f+x,S=i===void 0?w:i(w);S!==w&&(x=S-f);const $=B=>-x*Math.exp(-B/r),I=B=>S+$(B),R=B=>{const M=$(B),V=I(B);p.done=Math.abs(M)<=c,p.value=p.done?S:V};let _,O;const F=B=>{g(p.value)&&(_=B,O=cg({keyframes:[p.value,y(p.value)],velocity:qR(I,B,p.value),damping:s,stiffness:o,restDelta:c,restSpeed:d}))};return F(0),{calculatedDuration:null,next:B=>{let M=!1;return!O&&_===void 0&&(M=!0,R(B),F(B)),_!==void 0&&B>=_?O.next(B-_):(!M&&R(B),p)}}}function tj(t,e,n){const r=[],s=n||da.mix||KR,o=t.length-1;for(let i=0;i<o;i++){let a=s(t[i],t[i+1]);if(e){const l=Array.isArray(e)?e[i]||io:e;a=zf(l,a)}r.push(a)}return r}function nj(t,e,{clamp:n=!0,ease:r,mixer:s}={}){const o=t.length;if(yb(o===e.length),o===1)return()=>e[0];if(o===2&&e[0]===e[1])return()=>e[1];const i=t[0]===t[1];t[0]>t[o-1]&&(t=[...t].reverse(),e=[...e].reverse());const a=tj(e,r,s),l=a.length,c=d=>{if(i&&d<t[0])return e[0];let f=0;if(l>1)for(;f<t.length-2&&!(d<t[f+1]);f++);const p=af(t[f],t[f+1],d);return a[f](p)};return n?d=>c(ca(t[0],t[o-1],d)):c}function rj(t,e){const n=t[t.length-1];for(let r=1;r<=e;r++){const s=af(0,e,r);t.push(pn(n,1,s))}}function sj(t){const e=[0];return rj(e,t.length-1),e}function oj(t,e){return t.map(n=>n*e)}function ij(t,e){return t.map(()=>e||LR).splice(0,t.length-1)}function Hh({duration:t=300,keyframes:e,times:n,ease:r="easeInOut"}){const s=y8(r)?r.map(L3):L3(r),o={done:!1,value:e[0]},i=oj(n&&n.length===e.length?n:sj(e),t),a=nj(i,e,{ease:Array.isArray(s)?s:ij(e,s)});return{calculatedDuration:t,next:l=>(o.value=a(l),o.done=l>=t,o)}}const aj=t=>t!==null;function Nb(t,{repeat:e,repeatType:n="loop"},r,s=1){const o=t.filter(aj),a=s<0||e&&n!=="loop"&&e%2===1?0:o.length-1;return!a||r===void 0?o[a]:r}const lj={decay:Px,inertia:Px,tween:Hh,keyframes:Hh,spring:cg};function YR(t){typeof t.type=="string"&&(t.type=lj[t.type])}class Eb{constructor(){this.count=0,this.updateFinished()}get finished(){return this._finished}updateFinished(){this.count++,this._finished=new Promise(e=>{this.resolve=e})}notifyFinished(){this.resolve()}then(e,n){return this.finished.then(e,n)}}const uj=t=>t/100;class QR extends Eb{constructor(e){super(),this.state="idle",this.startTime=null,this.isStopped=!1,this.currentTime=0,this.holdTime=null,this.playbackSpeed=1,this.stop=()=>{const{motionValue:n}=this.options;if(n&&n.updatedAt!==fs.now()&&this.tick(fs.now()),this.isStopped=!0,this.state==="idle")return;this.teardown();const{onStop:r}=this.options;r&&r()},this.options=e,this.initAnimation(),this.play(),e.autoplay===!1&&this.pause()}initAnimation(){const{options:e}=this;YR(e);const{type:n=Hh,repeat:r=0,repeatDelay:s=0,repeatType:o,velocity:i=0}=e;let{keyframes:a}=e;const l=n||Hh;l!==Hh&&typeof a[0]!="number"&&(this.mixKeyframes=zf(uj,KR(a[0],a[1])),a=[0,100]);const c=l({...e,keyframes:a});o==="mirror"&&(this.mirroredGenerator=l({...e,keyframes:[...a].reverse(),velocity:-i})),c.calculatedDuration===null&&(c.calculatedDuration=Ib(c));const{calculatedDuration:d}=c;this.calculatedDuration=d,this.resolvedDuration=d+s,this.totalDuration=this.resolvedDuration*(r+1)-s,this.generator=c}updateTime(e){const n=Math.round(e-this.startTime)*this.playbackSpeed;this.holdTime!==null?this.currentTime=this.holdTime:this.currentTime=n}tick(e,n=!1){const{generator:r,totalDuration:s,mixKeyframes:o,mirroredGenerator:i,resolvedDuration:a,calculatedDuration:l}=this;if(this.startTime===null)return r.next(0);const{delay:c=0,keyframes:d,repeat:f,repeatType:p,repeatDelay:g,type:y,onUpdate:x,finalKeyframe:w}=this.options;this.speed>0?this.startTime=Math.min(this.startTime,e):this.speed<0&&(this.startTime=Math.min(e-s/this.speed,this.startTime)),n?this.currentTime=e:this.updateTime(e);const S=this.currentTime-c*(this.playbackSpeed>=0?1:-1),$=this.playbackSpeed>=0?S<0:S>s;this.currentTime=Math.max(S,0),this.state==="finished"&&this.holdTime===null&&(this.currentTime=s);let I=this.currentTime,R=r;if(f){const B=Math.min(this.currentTime,s)/a;let M=Math.floor(B),V=B%1;!V&&B>=1&&(V=1),V===1&&M--,M=Math.min(M,f+1),!!(M%2)&&(p==="reverse"?(V=1-V,g&&(V-=g/a)):p==="mirror"&&(R=i)),I=ca(0,1,V)*a}const _=$?{done:!1,value:d[0]}:R.next(I);o&&(_.value=o(_.value));let{done:O}=_;!$&&l!==null&&(O=this.playbackSpeed>=0?this.currentTime>=s:this.currentTime<=0);const F=this.holdTime===null&&(this.state==="finished"||this.state==="running"&&O);return F&&y!==Px&&(_.value=Nb(d,this.options,w,this.speed)),x&&x(_.value),F&&this.finish(),_}then(e,n){return this.finished.then(e,n)}get duration(){return yi(this.calculatedDuration)}get time(){return yi(this.currentTime)}set time(e){e=gi(e),this.currentTime=e,this.startTime===null||this.holdTime!==null||this.playbackSpeed===0?this.holdTime=e:this.driver&&(this.startTime=this.driver.now()-e/this.playbackSpeed)}get speed(){return this.playbackSpeed}set speed(e){this.updateTime(fs.now());const n=this.playbackSpeed!==e;this.playbackSpeed=e,n&&(this.time=yi(this.currentTime))}play(){if(this.isStopped)return;const{driver:e=H8,onPlay:n,startTime:r}=this.options;this.driver||(this.driver=e(o=>this.tick(o))),n&&n();const s=this.driver.now();this.state==="finished"?(this.updateFinished(),this.startTime=s):this.holdTime!==null?this.startTime=s-this.holdTime:this.startTime||(this.startTime=r??s),this.state==="finished"&&this.speed<0&&(this.startTime+=this.calculatedDuration),this.holdTime=null,this.state="running",this.driver.start()}pause(){this.state="paused",this.updateTime(fs.now()),this.holdTime=this.currentTime}complete(){this.state!=="running"&&this.play(),this.state="finished",this.holdTime=null}finish(){this.teardown(),this.state="finished";const{onComplete:e}=this.options;e&&e()}cancel(){this.holdTime=null,this.startTime=0,this.tick(0),this.teardown()}teardown(){this.notifyFinished(),this.state="idle",this.stopDriver(),this.startTime=this.holdTime=null}stopDriver(){this.driver&&(this.driver.stop(),this.driver=void 0)}sample(e){return this.startTime=0,this.tick(e,!0)}attachTimeline(e){return this.options.allowFlatten&&(this.options.type="keyframes",this.options.ease="linear",this.initAnimation()),e.observe(this)}}function cj(t){for(let e=1;e<t.length;e++)t[e]??(t[e]=t[e-1])}const xu=t=>t*180/Math.PI,Ax=t=>{const e=xu(Math.atan2(t[1],t[0]));return Dx(e)},dj={x:4,y:5,translateX:4,translateY:5,scaleX:0,scaleY:3,scale:t=>(Math.abs(t[0])+Math.abs(t[3]))/2,rotate:Ax,rotateZ:Ax,skewX:t=>xu(Math.atan(t[1])),skewY:t=>xu(Math.atan(t[2])),skew:t=>(Math.abs(t[1])+Math.abs(t[2]))/2},Dx=t=>(t=t%360,t<0&&(t+=360),t),G3=Ax,H3=t=>Math.sqrt(t[0]*t[0]+t[1]*t[1]),K3=t=>Math.sqrt(t[4]*t[4]+t[5]*t[5]),hj={x:12,y:13,z:14,translateX:12,translateY:13,translateZ:14,scaleX:H3,scaleY:K3,scale:t=>(H3(t)+K3(t))/2,rotateX:t=>Dx(xu(Math.atan2(t[6],t[5]))),rotateY:t=>Dx(xu(Math.atan2(-t[2],t[0]))),rotateZ:G3,rotate:G3,skewX:t=>xu(Math.atan(t[4])),skewY:t=>xu(Math.atan(t[1])),skew:t=>(Math.abs(t[1])+Math.abs(t[4]))/2};function X3(t){return t.includes("scale")?1:0}function Ox(t,e){if(!t||t==="none")return X3(e);const n=t.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);let r,s;if(n)r=hj,s=n;else{const a=t.match(/^matrix\(([-\d.e\s,]+)\)$/u);r=dj,s=a}if(!s)return X3(e);const o=r[e],i=s[1].split(",").map(pj);return typeof o=="function"?o(i):i[o]}const fj=(t,e)=>{const{transform:n="none"}=getComputedStyle(t);return Ox(n,e)};function pj(t){return parseFloat(t.trim())}const xd=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],vd=new Set(xd),q3=t=>t===yd||t===rt,mj=new Set(["x","y","z"]),gj=xd.filter(t=>!mj.has(t));function yj(t){const e=[];return gj.forEach(n=>{const r=t.getValue(n);r!==void 0&&(e.push([n,r.get()]),r.set(n.startsWith("scale")?1:0))}),e}const sd={width:({x:t},{paddingLeft:e="0",paddingRight:n="0"})=>t.max-t.min-parseFloat(e)-parseFloat(n),height:({y:t},{paddingTop:e="0",paddingBottom:n="0"})=>t.max-t.min-parseFloat(e)-parseFloat(n),top:(t,{top:e})=>parseFloat(e),left:(t,{left:e})=>parseFloat(e),bottom:({y:t},{top:e})=>parseFloat(e)+(t.max-t.min),right:({x:t},{left:e})=>parseFloat(e)+(t.max-t.min),x:(t,{transform:e})=>Ox(e,"x"),y:(t,{transform:e})=>Ox(e,"y")};sd.translateX=sd.x;sd.translateY=sd.y;const ku=new Set;let Fx=!1,Lx=!1,zx=!1;function ZR(){if(Lx){const t=Array.from(ku).filter(r=>r.needsMeasurement),e=new Set(t.map(r=>r.element)),n=new Map;e.forEach(r=>{const s=yj(r);s.length&&(n.set(r,s),r.render())}),t.forEach(r=>r.measureInitialState()),e.forEach(r=>{r.render();const s=n.get(r);s&&s.forEach(([o,i])=>{var a;(a=r.getValue(o))==null||a.set(i)})}),t.forEach(r=>r.measureEndState()),t.forEach(r=>{r.suspendedScrollY!==void 0&&window.scrollTo(0,r.suspendedScrollY)})}Lx=!1,Fx=!1,ku.forEach(t=>t.complete(zx)),ku.clear()}function JR(){ku.forEach(t=>{t.readKeyframes(),t.needsMeasurement&&(Lx=!0)})}function xj(){zx=!0,JR(),ZR(),zx=!1}class Rb{constructor(e,n,r,s,o,i=!1){this.isComplete=!1,this.isAsync=!1,this.needsMeasurement=!1,this.isScheduled=!1,this.unresolvedKeyframes=[...e],this.onComplete=n,this.name=r,this.motionValue=s,this.element=o,this.isAsync=i}scheduleResolve(){this.isScheduled=!0,this.isAsync?(ku.add(this),Fx||(Fx=!0,mn.read(JR),mn.resolveKeyframes(ZR))):(this.readKeyframes(),this.complete())}readKeyframes(){const{unresolvedKeyframes:e,name:n,element:r,motionValue:s}=this;if(e[0]===null){const o=s==null?void 0:s.get(),i=e[e.length-1];if(o!==void 0)e[0]=o;else if(r&&n){const a=r.readValue(n,i);a!=null&&(e[0]=a)}e[0]===void 0&&(e[0]=i),s&&o===void 0&&s.set(e[0])}cj(e)}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(e=!1){this.isComplete=!0,this.onComplete(this.unresolvedKeyframes,this.finalKeyframe,e),ku.delete(this)}cancel(){this.isComplete||(this.isScheduled=!1,ku.delete(this))}resume(){this.isComplete||this.scheduleResolve()}}const vj=t=>t.startsWith("--");function bj(t,e,n){vj(e)?t.style.setProperty(e,n):t.style[e]=n}const wj=xb(()=>window.ScrollTimeline!==void 0),Sj={};function Cj(t,e){const n=xb(t);return()=>Sj[e]??n()}const e_=Cj(()=>{try{document.createElement("div").animate({opacity:0},{easing:"linear(0, 1)"})}catch{return!1}return!0},"linearEasing"),Rh=([t,e,n,r])=>`cubic-bezier(${t}, ${e}, ${n}, ${r})`,Y3={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:Rh([0,.65,.55,1]),circOut:Rh([.55,0,1,.45]),backIn:Rh([.31,.01,.66,-.59]),backOut:Rh([.33,1.53,.69,.99])};function t_(t,e){if(t)return typeof t=="function"?e_()?XR(t,e):"ease-out":zR(t)?Rh(t):Array.isArray(t)?t.map(n=>t_(n,e)||Y3.easeOut):Y3[t]}function $j(t,e,n,{delay:r=0,duration:s=300,repeat:o=0,repeatType:i="loop",ease:a="easeOut",times:l}={},c=void 0){const d={[e]:n};l&&(d.offset=l);const f=t_(a,s);Array.isArray(f)&&(d.easing=f);const p={delay:r,duration:s,easing:Array.isArray(f)?"linear":f,fill:"both",iterations:o+1,direction:i==="reverse"?"alternate":"normal"};return c&&(p.pseudoElement=c),t.animate(d,p)}function n_(t){return typeof t=="function"&&"applyToOptions"in t}function kj({type:t,...e}){return n_(t)&&e_()?t.applyToOptions(e):(e.duration??(e.duration=300),e.ease??(e.ease="easeOut"),e)}class Tj extends Eb{constructor(e){if(super(),this.finishedTime=null,this.isStopped=!1,!e)return;const{element:n,name:r,keyframes:s,pseudoElement:o,allowFlatten:i=!1,finalKeyframe:a,onComplete:l}=e;this.isPseudoElement=!!o,this.allowFlatten=i,this.options=e,yb(typeof e.type!="string");const c=kj(e);this.animation=$j(n,r,s,c,o),c.autoplay===!1&&this.animation.pause(),this.animation.onfinish=()=>{if(this.finishedTime=this.time,!o){const d=Nb(s,this.options,a,this.speed);this.updateMotionValue?this.updateMotionValue(d):bj(n,r,d),this.animation.cancel()}l==null||l(),this.notifyFinished()},this.animation.oncancel=()=>this.notifyFinished()}play(){this.isStopped||(this.animation.play(),this.state==="finished"&&this.updateFinished())}pause(){this.animation.pause()}complete(){var e,n;(n=(e=this.animation).finish)==null||n.call(e)}cancel(){try{this.animation.cancel()}catch{}}stop(){if(this.isStopped)return;this.isStopped=!0;const{state:e}=this;e==="idle"||e==="finished"||(this.updateMotionValue?this.updateMotionValue():this.commitStyles(),this.isPseudoElement||this.cancel())}commitStyles(){var e,n;this.isPseudoElement||(n=(e=this.animation).commitStyles)==null||n.call(e)}get duration(){var n,r;const e=((r=(n=this.animation.effect)==null?void 0:n.getComputedTiming)==null?void 0:r.call(n).duration)||0;return yi(Number(e))}get time(){return yi(Number(this.animation.currentTime)||0)}set time(e){this.finishedTime=null,this.animation.currentTime=gi(e)}get speed(){return this.animation.playbackRate}set speed(e){e<0&&(this.finishedTime=null),this.animation.playbackRate=e}get state(){return this.finishedTime!==null?"finished":this.animation.playState}get startTime(){return Number(this.animation.startTime)}set startTime(e){this.animation.startTime=e}attachTimeline({timeline:e,observe:n}){var r;return this.allowFlatten&&((r=this.animation.effect)==null||r.updateTiming({easing:"linear"})),this.animation.onfinish=null,e&&wj()?(this.animation.timeline=e,io):n(this)}}const r_={anticipate:DR,backInOut:AR,circInOut:FR};function Ij(t){return t in r_}function Nj(t){typeof t.ease=="string"&&Ij(t.ease)&&(t.ease=r_[t.ease])}const Q3=10;class Ej extends Tj{constructor(e){Nj(e),YR(e),super(e),e.startTime&&(this.startTime=e.startTime),this.options=e}updateMotionValue(e){const{motionValue:n,onUpdate:r,onComplete:s,element:o,...i}=this.options;if(!n)return;if(e!==void 0){n.set(e);return}const a=new QR({...i,autoplay:!1}),l=gi(this.finishedTime??this.time);n.setWithVelocity(a.sample(l-Q3).value,a.sample(l).value,Q3),a.stop()}}const Z3=(t,e)=>e==="zIndex"?!1:!!(typeof t=="number"||Array.isArray(t)||typeof t=="string"&&(gl.test(t)||t==="0")&&!t.startsWith("url("));function Rj(t){const e=t[0];if(t.length===1)return!0;for(let n=0;n<t.length;n++)if(t[n]!==e)return!0}function _j(t,e,n,r){const s=t[0];if(s===null)return!1;if(e==="display"||e==="visibility")return!0;const o=t[t.length-1],i=Z3(s,e),a=Z3(o,e);return!i||!a?!1:Rj(t)||(n==="spring"||n_(n))&&r}const Pj=new Set(["opacity","clipPath","filter","transform"]),Aj=xb(()=>Object.hasOwnProperty.call(Element.prototype,"animate"));function Dj(t){const{motionValue:e,name:n,repeatDelay:r,repeatType:s,damping:o,type:i}=t;if(!e||!e.owner||!(e.owner.current instanceof HTMLElement))return!1;const{onUpdate:a,transformTemplate:l}=e.owner.getProps();return Aj()&&n&&Pj.has(n)&&(n!=="transform"||!l)&&!a&&!r&&s!=="mirror"&&o!==0&&i!=="inertia"}const Oj=40;class Fj extends Eb{constructor({autoplay:e=!0,delay:n=0,type:r="keyframes",repeat:s=0,repeatDelay:o=0,repeatType:i="loop",keyframes:a,name:l,motionValue:c,element:d,...f}){var y;super(),this.stop=()=>{var x,w;this._animation?(this._animation.stop(),(x=this.stopTimeline)==null||x.call(this)):(w=this.keyframeResolver)==null||w.cancel()},this.createdAt=fs.now();const p={autoplay:e,delay:n,type:r,repeat:s,repeatDelay:o,repeatType:i,name:l,motionValue:c,element:d,...f},g=(d==null?void 0:d.KeyframeResolver)||Rb;this.keyframeResolver=new g(a,(x,w,S)=>this.onKeyframesResolved(x,w,p,!S),l,c,d),(y=this.keyframeResolver)==null||y.scheduleResolve()}onKeyframesResolved(e,n,r,s){this.keyframeResolver=void 0;const{name:o,type:i,velocity:a,delay:l,isHandoff:c,onUpdate:d}=r;this.resolvedAt=fs.now(),_j(e,o,i,a)||((da.instantAnimations||!l)&&(d==null||d(Nb(e,r,n))),e[0]=e[e.length-1],r.duration=0,r.repeat=0);const p={startTime:s?this.resolvedAt?this.resolvedAt-this.createdAt>Oj?this.resolvedAt:this.createdAt:this.createdAt:void 0,finalKeyframe:n,...r,keyframes:e},g=!c&&Dj(p)?new Ej({...p,element:p.motionValue.owner.current}):new QR(p);g.finished.then(()=>this.notifyFinished()).catch(io),this.pendingTimeline&&(this.stopTimeline=g.attachTimeline(this.pendingTimeline),this.pendingTimeline=void 0),this._animation=g}get finished(){return this._animation?this.animation.finished:this._finished}then(e,n){return this.finished.finally(e).then(()=>{})}get animation(){return this._animation||xj(),this._animation}get duration(){return this.animation.duration}get time(){return this.animation.time}set time(e){this.animation.time=e}get speed(){return this.animation.speed}get state(){return this.animation.state}set speed(e){this.animation.speed=e}get startTime(){return this.animation.startTime}attachTimeline(e){return this._animation?this.stopTimeline=this.animation.attachTimeline(e):this.pendingTimeline=e,()=>this.stop()}play(){this.animation.play()}pause(){this.animation.pause()}complete(){this.animation.complete()}cancel(){this.animation.cancel()}}const Lj=/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;function zj(t){const e=Lj.exec(t);if(!e)return[,];const[,n,r,s]=e;return[`--${n??r}`,s]}function s_(t,e,n=1){const[r,s]=zj(t);if(!r)return;const o=window.getComputedStyle(e).getPropertyValue(r);if(o){const i=o.trim();return TR(i)?parseFloat(i):i}return Cb(s)?s_(s,e,n+1):s}function _b(t,e){return(t==null?void 0:t[e])??(t==null?void 0:t.default)??t}const o_=new Set(["width","height","top","left","right","bottom",...xd]),Bj={test:t=>t==="auto",parse:t=>t},i_=t=>e=>e.test(t),a_=[yd,rt,xi,sl,R8,E8,Bj],J3=t=>a_.find(i_(t));function Mj(t){return typeof t=="number"?t===0:t!==null?t==="none"||t==="0"||IR(t):!0}const Vj=new Set(["brightness","contrast","saturate","opacity"]);function Wj(t){const[e,n]=t.slice(0,-1).split("(");if(e==="drop-shadow")return t;const[r]=n.match($b)||[];if(!r)return t;const s=n.replace(r,"");let o=Vj.has(e)?1:0;return r!==n&&(o*=100),e+"("+o+s+")"}const Uj=/\b([a-z-]*)\(.*?\)/gu,Bx={...gl,getAnimatableNone:t=>{const e=t.match(Uj);return e?e.map(Wj).join(" "):t}},eT={...yd,transform:Math.round},jj={rotate:sl,rotateX:sl,rotateY:sl,rotateZ:sl,scale:gm,scaleX:gm,scaleY:gm,scaleZ:gm,skew:sl,skewX:sl,skewY:sl,distance:rt,translateX:rt,translateY:rt,translateZ:rt,x:rt,y:rt,z:rt,perspective:rt,transformPerspective:rt,opacity:lf,originX:B3,originY:B3,originZ:rt},Pb={borderWidth:rt,borderTopWidth:rt,borderRightWidth:rt,borderBottomWidth:rt,borderLeftWidth:rt,borderRadius:rt,radius:rt,borderTopLeftRadius:rt,borderTopRightRadius:rt,borderBottomRightRadius:rt,borderBottomLeftRadius:rt,width:rt,maxWidth:rt,height:rt,maxHeight:rt,top:rt,right:rt,bottom:rt,left:rt,padding:rt,paddingTop:rt,paddingRight:rt,paddingBottom:rt,paddingLeft:rt,margin:rt,marginTop:rt,marginRight:rt,marginBottom:rt,marginLeft:rt,backgroundPositionX:rt,backgroundPositionY:rt,...jj,zIndex:eT,fillOpacity:lf,strokeOpacity:lf,numOctaves:eT},Gj={...Pb,color:br,backgroundColor:br,outlineColor:br,fill:br,stroke:br,borderColor:br,borderTopColor:br,borderRightColor:br,borderBottomColor:br,borderLeftColor:br,filter:Bx,WebkitFilter:Bx},l_=t=>Gj[t];function u_(t,e){let n=l_(t);return n!==Bx&&(n=gl),n.getAnimatableNone?n.getAnimatableNone(e):void 0}const Hj=new Set(["auto","none","0"]);function Kj(t,e,n){let r=0,s;for(;r<t.length&&!s;){const o=t[r];typeof o=="string"&&!Hj.has(o)&&uf(o).values.length&&(s=t[r]),r++}if(s&&n)for(const o of e)t[o]=u_(n,s)}class Xj extends Rb{constructor(e,n,r,s,o){super(e,n,r,s,o,!0)}readKeyframes(){const{unresolvedKeyframes:e,element:n,name:r}=this;if(!n||!n.current)return;super.readKeyframes();for(let l=0;l<e.length;l++){let c=e[l];if(typeof c=="string"&&(c=c.trim(),Cb(c))){const d=s_(c,n.current);d!==void 0&&(e[l]=d),l===e.length-1&&(this.finalKeyframe=c)}}if(this.resolveNoneKeyframes(),!o_.has(r)||e.length!==2)return;const[s,o]=e,i=J3(s),a=J3(o);if(i!==a)if(q3(i)&&q3(a))for(let l=0;l<e.length;l++){const c=e[l];typeof c=="string"&&(e[l]=parseFloat(c))}else this.needsMeasurement=!0}resolveNoneKeyframes(){const{unresolvedKeyframes:e,name:n}=this,r=[];for(let s=0;s<e.length;s++)(e[s]===null||Mj(e[s]))&&r.push(s);r.length&&Kj(e,r,n)}measureInitialState(){const{element:e,unresolvedKeyframes:n,name:r}=this;if(!e||!e.current)return;r==="height"&&(this.suspendedScrollY=window.pageYOffset),this.measuredOrigin=sd[r](e.measureViewportBox(),window.getComputedStyle(e.current)),n[0]=this.measuredOrigin;const s=n[n.length-1];s!==void 0&&e.getValue(r,s).jump(s,!1)}measureEndState(){var a;const{element:e,name:n,unresolvedKeyframes:r}=this;if(!e||!e.current)return;const s=e.getValue(n);s&&s.jump(this.measuredOrigin,!1);const o=r.length-1,i=r[o];r[o]=sd[n](e.measureViewportBox(),window.getComputedStyle(e.current)),i!==null&&this.finalKeyframe===void 0&&(this.finalKeyframe=i),(a=this.removedTransforms)!=null&&a.length&&this.removedTransforms.forEach(([l,c])=>{e.getValue(l).set(c)}),this.resolveNoneKeyframes()}}function qj(t,e,n){if(t instanceof EventTarget)return[t];if(typeof t=="string"){let r=document;const s=(n==null?void 0:n[t])??r.querySelectorAll(t);return s?Array.from(s):[]}return Array.from(t)}const{schedule:Ab}=BR(queueMicrotask,!1),_o={x:!1,y:!1};function c_(){return _o.x||_o.y}function Yj(t){return t==="x"||t==="y"?_o[t]?null:(_o[t]=!0,()=>{_o[t]=!1}):_o.x||_o.y?null:(_o.x=_o.y=!0,()=>{_o.x=_o.y=!1})}function d_(t,e){const n=qj(t),r=new AbortController,s={passive:!0,...e,signal:r.signal};return[n,s,()=>r.abort()]}function tT(t){return!(t.pointerType==="touch"||c_())}function Qj(t,e,n={}){const[r,s,o]=d_(t,n),i=a=>{if(!tT(a))return;const{target:l}=a,c=e(l,a);if(typeof c!="function"||!l)return;const d=f=>{tT(f)&&(c(f),l.removeEventListener("pointerleave",d))};l.addEventListener("pointerleave",d,s)};return r.forEach(a=>{a.addEventListener("pointerenter",i,s)}),o}const h_=(t,e)=>e?t===e?!0:h_(t,e.parentElement):!1,Db=t=>t.pointerType==="mouse"?typeof t.button!="number"||t.button<=0:t.isPrimary!==!1,Zj=new Set(["BUTTON","INPUT","SELECT","TEXTAREA","A"]);function Jj(t){return Zj.has(t.tagName)||t.tabIndex!==-1}const _h=new WeakSet;function nT(t){return e=>{e.key==="Enter"&&t(e)}}function _1(t,e){t.dispatchEvent(new PointerEvent("pointer"+e,{isPrimary:!0,bubbles:!0}))}const eG=(t,e)=>{const n=t.currentTarget;if(!n)return;const r=nT(()=>{if(_h.has(n))return;_1(n,"down");const s=nT(()=>{_1(n,"up")}),o=()=>_1(n,"cancel");n.addEventListener("keyup",s,e),n.addEventListener("blur",o,e)});n.addEventListener("keydown",r,e),n.addEventListener("blur",()=>n.removeEventListener("keydown",r),e)};function rT(t){return Db(t)&&!c_()}function tG(t,e,n={}){const[r,s,o]=d_(t,n),i=a=>{const l=a.currentTarget;if(!rT(a)||_h.has(l))return;_h.add(l);const c=e(l,a),d=(g,y)=>{window.removeEventListener("pointerup",f),window.removeEventListener("pointercancel",p),!(!rT(g)||!_h.has(l))&&(_h.delete(l),typeof c=="function"&&c(g,{success:y}))},f=g=>{d(g,l===window||l===document||n.useGlobalTarget||h_(l,g.target))},p=g=>{d(g,!1)};window.addEventListener("pointerup",f,s),window.addEventListener("pointercancel",p,s)};return r.forEach(a=>{(n.useGlobalTarget?window:a).addEventListener("pointerdown",i,s),a instanceof HTMLElement&&(a.addEventListener("focus",c=>eG(c,s)),!Jj(a)&&!a.hasAttribute("tabindex")&&(a.tabIndex=0))}),o}const sT=30,nG=t=>!isNaN(parseFloat(t));class rG{constructor(e,n={}){this.version="12.9.1",this.canTrackVelocity=null,this.events={},this.updateAndNotify=(r,s=!0)=>{var i,a;const o=fs.now();this.updatedAt!==o&&this.setPrevFrameValue(),this.prev=this.current,this.setCurrent(r),this.current!==this.prev&&((i=this.events.change)==null||i.notify(this.current)),s&&((a=this.events.renderRequest)==null||a.notify(this.current))},this.hasAnimated=!1,this.setCurrent(e),this.owner=n.owner}setCurrent(e){this.current=e,this.updatedAt=fs.now(),this.canTrackVelocity===null&&e!==void 0&&(this.canTrackVelocity=nG(this.current))}setPrevFrameValue(e=this.current){this.prevFrameValue=e,this.prevUpdatedAt=this.updatedAt}onChange(e){return this.on("change",e)}on(e,n){this.events[e]||(this.events[e]=new vb);const r=this.events[e].add(n);return e==="change"?()=>{r(),mn.read(()=>{this.events.change.getSize()||this.stop()})}:r}clearListeners(){for(const e in this.events)this.events[e].clear()}attach(e,n){this.passiveEffect=e,this.stopPassiveEffect=n}set(e,n=!0){!n||!this.passiveEffect?this.updateAndNotify(e,n):this.passiveEffect(e,this.updateAndNotify)}setWithVelocity(e,n,r){this.set(n),this.prev=void 0,this.prevFrameValue=e,this.prevUpdatedAt=this.updatedAt-r}jump(e,n=!0){this.updateAndNotify(e),this.prev=e,this.prevUpdatedAt=this.prevFrameValue=void 0,n&&this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}get(){return this.current}getPrevious(){return this.prev}getVelocity(){const e=fs.now();if(!this.canTrackVelocity||this.prevFrameValue===void 0||e-this.updatedAt>sT)return 0;const n=Math.min(this.updatedAt-this.prevUpdatedAt,sT);return NR(parseFloat(this.current)-parseFloat(this.prevFrameValue),n)}start(e){return this.stop(),new Promise(n=>{this.hasAnimated=!0,this.animation=e(n),this.events.animationStart&&this.events.animationStart.notify()}).then(()=>{this.events.animationComplete&&this.events.animationComplete.notify(),this.clearAnimation()})}stop(){this.animation&&(this.animation.stop(),this.events.animationCancel&&this.events.animationCancel.notify()),this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){var e;(e=this.events.destroy)==null||e.notify(),this.clearListeners(),this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}}function cf(t,e){return new rG(t,e)}const sG=[...a_,br,gl],oG=t=>sG.find(i_(t)),f_=(t,e)=>e&&typeof t=="number"?e.transform(t):t,p_=J.createContext({strict:!1}),oT={animation:["animate","variants","whileHover","whileTap","exit","whileInView","whileFocus","whileDrag"],exit:["exit"],drag:["drag","dragControls"],focus:["whileFocus"],hover:["whileHover","onHoverStart","onHoverEnd"],tap:["whileTap","onTap","onTapStart","onTapCancel"],pan:["onPan","onPanStart","onPanSessionStart","onPanEnd"],inView:["whileInView","onViewportEnter","onViewportLeave"],layout:["layout","layoutId"]},od={};for(const t in oT)od[t]={isEnabled:e=>oT[t].some(n=>!!e[n])};function iG(t){for(const e in t)od[e]={...od[e],...t[e]}}const aG=new Set(["animate","exit","variants","initial","style","values","variants","transition","transformTemplate","custom","inherit","onBeforeLayoutMeasure","onAnimationStart","onAnimationComplete","onUpdate","onDragStart","onDrag","onDragEnd","onMeasureDragConstraints","onDirectionLock","onDragTransitionEnd","_dragX","_dragY","onHoverStart","onHoverEnd","onViewportEnter","onViewportLeave","globalTapTarget","ignoreStrict","viewport"]);function dg(t){return t.startsWith("while")||t.startsWith("drag")&&t!=="draggable"||t.startsWith("layout")||t.startsWith("onTap")||t.startsWith("onPan")||t.startsWith("onLayout")||aG.has(t)}let m_=t=>!dg(t);function lG(t){t&&(m_=e=>e.startsWith("on")?!dg(e):t(e))}try{lG(require("@emotion/is-prop-valid").default)}catch{}function uG(t,e,n){const r={};for(const s in t)s==="values"&&typeof t.values=="object"||(m_(s)||n===!0&&dg(s)||!e&&!dg(s)||t.draggable&&s.startsWith("onDrag"))&&(r[s]=t[s]);return r}function cG(t){if(typeof Proxy>"u")return t;const e=new Map,n=(...r)=>t(...r);return new Proxy(n,{get:(r,s)=>s==="create"?t:(e.has(s)||e.set(s,t(s)),e.get(s))})}const Yg=J.createContext({});function Qg(t){return t!==null&&typeof t=="object"&&typeof t.start=="function"}function df(t){return typeof t=="string"||Array.isArray(t)}const Ob=["animate","whileInView","whileFocus","whileHover","whileTap","whileDrag","exit"],Fb=["initial",...Ob];function Zg(t){return Qg(t.animate)||Fb.some(e=>df(t[e]))}function g_(t){return!!(Zg(t)||t.variants)}function dG(t,e){if(Zg(t)){const{initial:n,animate:r}=t;return{initial:n===!1||df(n)?n:void 0,animate:df(r)?r:void 0}}return t.inherit!==!1?e:{}}function hG(t){const{initial:e,animate:n}=dG(t,J.useContext(Yg));return J.useMemo(()=>({initial:e,animate:n}),[iT(e),iT(n)])}function iT(t){return Array.isArray(t)?t.join(" "):t}const fG=Symbol.for("motionComponentSymbol");function Mc(t){return t&&typeof t=="object"&&Object.prototype.hasOwnProperty.call(t,"current")}function pG(t,e,n){return J.useCallback(r=>{r&&t.onMount&&t.onMount(r),e&&(r?e.mount(r):e.unmount()),n&&(typeof n=="function"?n(r):Mc(n)&&(n.current=r))},[e])}const Lb=t=>t.replace(/([a-z])([A-Z])/gu,"$1-$2").toLowerCase(),mG="framerAppearId",y_="data-"+Lb(mG),x_=J.createContext({});function gG(t,e,n,r,s){var x,w;const{visualElement:o}=J.useContext(Yg),i=J.useContext(p_),a=J.useContext(Lf),l=J.useContext(fb).reducedMotion,c=J.useRef(null);r=r||i.renderer,!c.current&&r&&(c.current=r(t,{visualState:e,parent:o,props:n,presenceContext:a,blockInitialAnimation:a?a.initial===!1:!1,reducedMotionConfig:l}));const d=c.current,f=J.useContext(x_);d&&!d.projection&&s&&(d.type==="html"||d.type==="svg")&&yG(c.current,n,s,f);const p=J.useRef(!1);J.useInsertionEffect(()=>{d&&p.current&&d.update(n,a)});const g=n[y_],y=J.useRef(!!g&&!((x=window.MotionHandoffIsComplete)!=null&&x.call(window,g))&&((w=window.MotionHasOptimisedAnimation)==null?void 0:w.call(window,g)));return $R(()=>{d&&(p.current=!0,window.MotionIsMounted=!0,d.updateFeatures(),Ab.render(d.render),y.current&&d.animationState&&d.animationState.animateChanges())}),J.useEffect(()=>{d&&(!y.current&&d.animationState&&d.animationState.animateChanges(),y.current&&(queueMicrotask(()=>{var S;(S=window.MotionHandoffMarkAsComplete)==null||S.call(window,g)}),y.current=!1))}),d}function yG(t,e,n,r){const{layoutId:s,layout:o,drag:i,dragConstraints:a,layoutScroll:l,layoutRoot:c,layoutCrossfade:d}=e;t.projection=new n(t.latestValues,e["data-framer-portal-id"]?void 0:v_(t.parent)),t.projection.setOptions({layoutId:s,layout:o,alwaysMeasureLayout:!!i||a&&Mc(a),visualElement:t,animationType:typeof o=="string"?o:"both",initialPromotionConfig:r,crossfade:d,layoutScroll:l,layoutRoot:c})}function v_(t){if(t)return t.options.allowProjection!==!1?t.projection:v_(t.parent)}function xG({preloadedFeatures:t,createVisualElement:e,useRender:n,useVisualState:r,Component:s}){t&&iG(t);function o(a,l){let c;const d={...J.useContext(fb),...a,layoutId:vG(a)},{isStatic:f}=d,p=hG(a),g=r(a,f);if(!f&&hb){bG();const y=wG(d);c=y.MeasureLayout,p.visualElement=gG(s,g,d,e,y.ProjectionNode)}return K.jsxs(Yg.Provider,{value:p,children:[c&&p.visualElement?K.jsx(c,{visualElement:p.visualElement,...d}):null,n(s,a,pG(g,p.visualElement,l),g,f,p.visualElement)]})}o.displayName=`motion.${typeof s=="string"?s:`create(${s.displayName??s.name??""})`}`;const i=J.forwardRef(o);return i[fG]=s,i}function vG({layoutId:t}){const e=J.useContext(cb).id;return e&&t!==void 0?e+"-"+t:t}function bG(t,e){J.useContext(p_).strict}function wG(t){const{drag:e,layout:n}=od;if(!e&&!n)return{};const r={...e,...n};return{MeasureLayout:e!=null&&e.isEnabled(t)||n!=null&&n.isEnabled(t)?r.MeasureLayout:void 0,ProjectionNode:r.ProjectionNode}}const hf={};function SG(t){for(const e in t)hf[e]=t[e],Sb(e)&&(hf[e].isCSSVariable=!0)}function b_(t,{layout:e,layoutId:n}){return vd.has(t)||t.startsWith("origin")||(e||n!==void 0)&&(!!hf[t]||t==="opacity")}const kr=t=>!!(t&&t.getVelocity),CG={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},$G=xd.length;function kG(t,e,n){let r="",s=!0;for(let o=0;o<$G;o++){const i=xd[o],a=t[i];if(a===void 0)continue;let l=!0;if(typeof a=="number"?l=a===(i.startsWith("scale")?1:0):l=parseFloat(a)===0,!l||n){const c=f_(a,Pb[i]);if(!l){s=!1;const d=CG[i]||i;r+=`${d}(${c}) `}n&&(e[i]=c)}}return r=r.trim(),n?r=n(e,s?"":r):s&&(r="none"),r}function zb(t,e,n){const{style:r,vars:s,transformOrigin:o}=t;let i=!1,a=!1;for(const l in e){const c=e[l];if(vd.has(l)){i=!0;continue}else if(Sb(l)){s[l]=c;continue}else{const d=f_(c,Pb[l]);l.startsWith("origin")?(a=!0,o[l]=d):r[l]=d}}if(e.transform||(i||n?r.transform=kG(e,t.transform,n):r.transform&&(r.transform="none")),a){const{originX:l="50%",originY:c="50%",originZ:d=0}=o;r.transformOrigin=`${l} ${c} ${d}`}}const Bb=()=>({style:{},transform:{},transformOrigin:{},vars:{}});function w_(t,e,n){for(const r in e)!kr(e[r])&&!b_(r,n)&&(t[r]=e[r])}function TG({transformTemplate:t},e){return J.useMemo(()=>{const n=Bb();return zb(n,e,t),Object.assign({},n.vars,n.style)},[e])}function IG(t,e){const n=t.style||{},r={};return w_(r,n,t),Object.assign(r,TG(t,e)),r}function NG(t,e){const n={},r=IG(t,e);return t.drag&&t.dragListener!==!1&&(n.draggable=!1,r.userSelect=r.WebkitUserSelect=r.WebkitTouchCallout="none",r.touchAction=t.drag===!0?"none":`pan-${t.drag==="x"?"y":"x"}`),t.tabIndex===void 0&&(t.onTap||t.onTapStart||t.whileTap)&&(n.tabIndex=0),n.style=r,n}const EG=["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","switch","symbol","svg","text","tspan","use","view"];function Mb(t){return typeof t!="string"||t.includes("-")?!1:!!(EG.indexOf(t)>-1||/[A-Z]/u.test(t))}const RG={offset:"stroke-dashoffset",array:"stroke-dasharray"},_G={offset:"strokeDashoffset",array:"strokeDasharray"};function PG(t,e,n=1,r=0,s=!0){t.pathLength=1;const o=s?RG:_G;t[o.offset]=rt.transform(-r);const i=rt.transform(e),a=rt.transform(n);t[o.array]=`${i} ${a}`}function S_(t,{attrX:e,attrY:n,attrScale:r,pathLength:s,pathSpacing:o=1,pathOffset:i=0,...a},l,c){if(zb(t,a,c),l){t.style.viewBox&&(t.attrs.viewBox=t.style.viewBox);return}t.attrs=t.style,t.style={};const{attrs:d,style:f}=t;d.transform&&(f.transform=d.transform,delete d.transform),(f.transform||d.transformOrigin)&&(f.transformOrigin=d.transformOrigin??"50% 50%",delete d.transformOrigin),f.transform&&(f.transformBox="fill-box",delete d.transformBox),e!==void 0&&(d.x=e),n!==void 0&&(d.y=n),r!==void 0&&(d.scale=r),s!==void 0&&PG(d,s,o,i,!1)}const C_=()=>({...Bb(),attrs:{}}),$_=t=>typeof t=="string"&&t.toLowerCase()==="svg";function AG(t,e,n,r){const s=J.useMemo(()=>{const o=C_();return S_(o,e,$_(r),t.transformTemplate),{...o.attrs,style:{...o.style}}},[e]);if(t.style){const o={};w_(o,t.style,t),s.style={...o,...s.style}}return s}function DG(t=!1){return(n,r,s,{latestValues:o},i)=>{const l=(Mb(n)?AG:NG)(r,o,i,n),c=uG(r,typeof n=="string",t),d=n!==J.Fragment?{...c,...l,ref:s}:{},{children:f}=r,p=J.useMemo(()=>kr(f)?f.get():f,[f]);return J.createElement(n,{...d,children:p})}}function aT(t){const e=[{},{}];return t==null||t.values.forEach((n,r)=>{e[0][r]=n.get(),e[1][r]=n.getVelocity()}),e}function Vb(t,e,n,r){if(typeof e=="function"){const[s,o]=aT(r);e=e(n!==void 0?n:t.custom,s,o)}if(typeof e=="string"&&(e=t.variants&&t.variants[e]),typeof e=="function"){const[s,o]=aT(r);e=e(n!==void 0?n:t.custom,s,o)}return e}function Wm(t){return kr(t)?t.get():t}function OG({scrapeMotionValuesFromProps:t,createRenderState:e},n,r,s){return{latestValues:FG(n,r,s,t),renderState:e()}}const k_=t=>(e,n)=>{const r=J.useContext(Yg),s=J.useContext(Lf),o=()=>OG(t,e,r,s);return n?o():db(o)};function FG(t,e,n,r){const s={},o=r(t,{});for(const p in o)s[p]=Wm(o[p]);let{initial:i,animate:a}=t;const l=Zg(t),c=g_(t);e&&c&&!l&&t.inherit!==!1&&(i===void 0&&(i=e.initial),a===void 0&&(a=e.animate));let d=n?n.initial===!1:!1;d=d||i===!1;const f=d?a:i;if(f&&typeof f!="boolean"&&!Qg(f)){const p=Array.isArray(f)?f:[f];for(let g=0;g<p.length;g++){const y=Vb(t,p[g]);if(y){const{transitionEnd:x,transition:w,...S}=y;for(const $ in S){let I=S[$];if(Array.isArray(I)){const R=d?I.length-1:0;I=I[R]}I!==null&&(s[$]=I)}for(const $ in x)s[$]=x[$]}}}return s}function Wb(t,e,n){var o;const{style:r}=t,s={};for(const i in r)(kr(r[i])||e.style&&kr(e.style[i])||b_(i,t)||((o=n==null?void 0:n.getValue(i))==null?void 0:o.liveStyle)!==void 0)&&(s[i]=r[i]);return s}const LG={useVisualState:k_({scrapeMotionValuesFromProps:Wb,createRenderState:Bb})};function T_(t,e,n){const r=Wb(t,e,n);for(const s in t)if(kr(t[s])||kr(e[s])){const o=xd.indexOf(s)!==-1?"attr"+s.charAt(0).toUpperCase()+s.substring(1):s;r[o]=t[s]}return r}const zG={useVisualState:k_({scrapeMotionValuesFromProps:T_,createRenderState:C_})};function BG(t,e){return function(r,{forwardMotionProps:s}={forwardMotionProps:!1}){const i={...Mb(r)?zG:LG,preloadedFeatures:t,useRender:DG(s),createVisualElement:e,Component:r};return xG(i)}}function ff(t,e,n){const r=t.getProps();return Vb(r,e,n!==void 0?n:r.custom,t)}const Mx=t=>Array.isArray(t);function MG(t,e,n){t.hasValue(e)?t.getValue(e).set(n):t.addValue(e,cf(n))}function VG(t){return Mx(t)?t[t.length-1]||0:t}function WG(t,e){const n=ff(t,e);let{transitionEnd:r={},transition:s={},...o}=n||{};o={...o,...r};for(const i in o){const a=VG(o[i]);MG(t,i,a)}}function UG(t){return!!(kr(t)&&t.add)}function Vx(t,e){const n=t.getValue("willChange");if(UG(n))return n.add(e);if(!n&&da.WillChange){const r=new da.WillChange("auto");t.addValue("willChange",r),r.add(e)}}function I_(t){return t.props[y_]}const jG=t=>t!==null;function GG(t,{repeat:e,repeatType:n="loop"},r){const s=t.filter(jG),o=e&&n!=="loop"&&e%2===1?0:s.length-1;return s[o]}const HG={type:"spring",stiffness:500,damping:25,restSpeed:10},KG=t=>({type:"spring",stiffness:550,damping:t===0?2*Math.sqrt(550):30,restSpeed:10}),XG={type:"keyframes",duration:.8},qG={type:"keyframes",ease:[.25,.1,.35,1],duration:.3},YG=(t,{keyframes:e})=>e.length>2?XG:vd.has(t)?t.startsWith("scale")?KG(e[1]):HG:qG;function QG({when:t,delay:e,delayChildren:n,staggerChildren:r,staggerDirection:s,repeat:o,repeatType:i,repeatDelay:a,from:l,elapsed:c,...d}){return!!Object.keys(d).length}const Ub=(t,e,n,r={},s,o)=>i=>{const a=_b(r,t)||{},l=a.delay||r.delay||0;let{elapsed:c=0}=r;c=c-gi(l);const d={keyframes:Array.isArray(n)?n:[null,n],ease:"easeOut",velocity:e.getVelocity(),...a,delay:-c,onUpdate:p=>{e.set(p),a.onUpdate&&a.onUpdate(p)},onComplete:()=>{i(),a.onComplete&&a.onComplete()},name:t,motionValue:e,element:o?void 0:s};QG(a)||Object.assign(d,YG(t,d)),d.duration&&(d.duration=gi(d.duration)),d.repeatDelay&&(d.repeatDelay=gi(d.repeatDelay)),d.from!==void 0&&(d.keyframes[0]=d.from);let f=!1;if((d.type===!1||d.duration===0&&!d.repeatDelay)&&(d.duration=0,d.delay===0&&(f=!0)),(da.instantAnimations||da.skipAnimations)&&(f=!0,d.duration=0,d.delay=0),d.allowFlatten=!a.type&&!a.ease,f&&!o&&e.get()!==void 0){const p=GG(d.keyframes,a);if(p!==void 0){mn.update(()=>{d.onUpdate(p),d.onComplete()});return}}return new Fj(d)};function ZG({protectedKeys:t,needsAnimating:e},n){const r=t.hasOwnProperty(n)&&e[n]!==!0;return e[n]=!1,r}function N_(t,e,{delay:n=0,transitionOverride:r,type:s}={}){let{transition:o=t.getDefaultTransition(),transitionEnd:i,...a}=e;r&&(o=r);const l=[],c=s&&t.animationState&&t.animationState.getState()[s];for(const d in a){const f=t.getValue(d,t.latestValues[d]??null),p=a[d];if(p===void 0||c&&ZG(c,d))continue;const g={delay:n,..._b(o||{},d)},y=f.get();if(y!==void 0&&!f.isAnimating&&!Array.isArray(p)&&p===y&&!g.velocity)continue;let x=!1;if(window.MotionHandoffAnimation){const S=I_(t);if(S){const $=window.MotionHandoffAnimation(S,d,mn);$!==null&&(g.startTime=$,x=!0)}}Vx(t,d),f.start(Ub(d,f,p,t.shouldReduceMotion&&o_.has(d)?{type:!1}:g,t,x));const w=f.animation;w&&l.push(w)}return i&&Promise.all(l).then(()=>{mn.update(()=>{i&&WG(t,i)})}),l}function Wx(t,e,n={}){var l;const r=ff(t,e,n.type==="exit"?(l=t.presenceContext)==null?void 0:l.custom:void 0);let{transition:s=t.getDefaultTransition()||{}}=r||{};n.transitionOverride&&(s=n.transitionOverride);const o=r?()=>Promise.all(N_(t,r,n)):()=>Promise.resolve(),i=t.variantChildren&&t.variantChildren.size?(c=0)=>{const{delayChildren:d=0,staggerChildren:f,staggerDirection:p}=s;return JG(t,e,d+c,f,p,n)}:()=>Promise.resolve(),{when:a}=s;if(a){const[c,d]=a==="beforeChildren"?[o,i]:[i,o];return c().then(()=>d())}else return Promise.all([o(),i(n.delay)])}function JG(t,e,n=0,r=0,s=1,o){const i=[],a=(t.variantChildren.size-1)*r,l=s===1?(c=0)=>c*r:(c=0)=>a-c*r;return Array.from(t.variantChildren).sort(eH).forEach((c,d)=>{c.notify("AnimationStart",e),i.push(Wx(c,e,{...o,delay:n+l(d)}).then(()=>c.notify("AnimationComplete",e)))}),Promise.all(i)}function eH(t,e){return t.sortNodePosition(e)}function tH(t,e,n={}){t.notify("AnimationStart",e);let r;if(Array.isArray(e)){const s=e.map(o=>Wx(t,o,n));r=Promise.all(s)}else if(typeof e=="string")r=Wx(t,e,n);else{const s=typeof e=="function"?ff(t,e,n.custom):e;r=Promise.all(N_(t,s,n))}return r.then(()=>{t.notify("AnimationComplete",e)})}function E_(t,e){if(!Array.isArray(e))return!1;const n=e.length;if(n!==t.length)return!1;for(let r=0;r<n;r++)if(e[r]!==t[r])return!1;return!0}const nH=Fb.length;function R_(t){if(!t)return;if(!t.isControllingVariants){const n=t.parent?R_(t.parent)||{}:{};return t.props.initial!==void 0&&(n.initial=t.props.initial),n}const e={};for(let n=0;n<nH;n++){const r=Fb[n],s=t.props[r];(df(s)||s===!1)&&(e[r]=s)}return e}const rH=[...Ob].reverse(),sH=Ob.length;function oH(t){return e=>Promise.all(e.map(({animation:n,options:r})=>tH(t,n,r)))}function iH(t){let e=oH(t),n=lT(),r=!0;const s=l=>(c,d)=>{var p;const f=ff(t,d,l==="exit"?(p=t.presenceContext)==null?void 0:p.custom:void 0);if(f){const{transition:g,transitionEnd:y,...x}=f;c={...c,...x,...y}}return c};function o(l){e=l(t)}function i(l){const{props:c}=t,d=R_(t.parent)||{},f=[],p=new Set;let g={},y=1/0;for(let w=0;w<sH;w++){const S=rH[w],$=n[S],I=c[S]!==void 0?c[S]:d[S],R=df(I),_=S===l?$.isActive:null;_===!1&&(y=w);let O=I===d[S]&&I!==c[S]&&R;if(O&&r&&t.manuallyAnimateOnMount&&(O=!1),$.protectedKeys={...g},!$.isActive&&_===null||!I&&!$.prevProp||Qg(I)||typeof I=="boolean")continue;const F=aH($.prevProp,I);let B=F||S===l&&$.isActive&&!O&&R||w>y&&R,M=!1;const V=Array.isArray(I)?I:[I];let P=V.reduce(s(S),{});_===!1&&(P={});const{prevResolvedValues:re={}}=$,ie={...re,...P},me=$e=>{B=!0,p.has($e)&&(M=!0,p.delete($e)),$.needsAnimating[$e]=!0;const fe=t.getValue($e);fe&&(fe.liveStyle=!1)};for(const $e in ie){const fe=P[$e],xe=re[$e];if(g.hasOwnProperty($e))continue;let ae=!1;Mx(fe)&&Mx(xe)?ae=!E_(fe,xe):ae=fe!==xe,ae?fe!=null?me($e):p.add($e):fe!==void 0&&p.has($e)?me($e):$.protectedKeys[$e]=!0}$.prevProp=I,$.prevResolvedValues=P,$.isActive&&(g={...g,...P}),r&&t.blockInitialAnimation&&(B=!1),B&&(!(O&&F)||M)&&f.push(...V.map($e=>({animation:$e,options:{type:S}})))}if(p.size){const w={};if(typeof c.initial!="boolean"){const S=ff(t,Array.isArray(c.initial)?c.initial[0]:c.initial);S&&S.transition&&(w.transition=S.transition)}p.forEach(S=>{const $=t.getBaseTarget(S),I=t.getValue(S);I&&(I.liveStyle=!0),w[S]=$??null}),f.push({animation:w})}let x=!!f.length;return r&&(c.initial===!1||c.initial===c.animate)&&!t.manuallyAnimateOnMount&&(x=!1),r=!1,x?e(f):Promise.resolve()}function a(l,c){var f;if(n[l].isActive===c)return Promise.resolve();(f=t.variantChildren)==null||f.forEach(p=>{var g;return(g=p.animationState)==null?void 0:g.setActive(l,c)}),n[l].isActive=c;const d=i(l);for(const p in n)n[p].protectedKeys={};return d}return{animateChanges:i,setActive:a,setAnimateFunction:o,getState:()=>n,reset:()=>{n=lT(),r=!0}}}function aH(t,e){return typeof e=="string"?e!==t:Array.isArray(e)?!E_(e,t):!1}function ru(t=!1){return{isActive:t,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function lT(){return{animate:ru(!0),whileInView:ru(),whileHover:ru(),whileTap:ru(),whileDrag:ru(),whileFocus:ru(),exit:ru()}}class wl{constructor(e){this.isMounted=!1,this.node=e}update(){}}class lH extends wl{constructor(e){super(e),e.animationState||(e.animationState=iH(e))}updateAnimationControlsSubscription(){const{animate:e}=this.node.getProps();Qg(e)&&(this.unmountControls=e.subscribe(this.node))}mount(){this.updateAnimationControlsSubscription()}update(){const{animate:e}=this.node.getProps(),{animate:n}=this.node.prevProps||{};e!==n&&this.updateAnimationControlsSubscription()}unmount(){var e;this.node.animationState.reset(),(e=this.unmountControls)==null||e.call(this)}}let uH=0;class cH extends wl{constructor(){super(...arguments),this.id=uH++}update(){if(!this.node.presenceContext)return;const{isPresent:e,onExitComplete:n}=this.node.presenceContext,{isPresent:r}=this.node.prevPresenceContext||{};if(!this.node.animationState||e===r)return;const s=this.node.animationState.setActive("exit",!e);n&&!e&&s.then(()=>{n(this.id)})}mount(){const{register:e,onExitComplete:n}=this.node.presenceContext||{};n&&n(this.id),e&&(this.unmount=e(this.id))}unmount(){}}const dH={animation:{Feature:lH},exit:{Feature:cH}};function pf(t,e,n,r={passive:!0}){return t.addEventListener(e,n,r),()=>t.removeEventListener(e,n)}function Vf(t){return{point:{x:t.pageX,y:t.pageY}}}const hH=t=>e=>Db(e)&&t(e,Vf(e));function Kh(t,e,n,r){return pf(t,e,hH(n),r)}function __({top:t,left:e,right:n,bottom:r}){return{x:{min:e,max:n},y:{min:t,max:r}}}function fH({x:t,y:e}){return{top:e.min,right:t.max,bottom:e.max,left:t.min}}function pH(t,e){if(!e)return t;const n=e({x:t.left,y:t.top}),r=e({x:t.right,y:t.bottom});return{top:n.y,left:n.x,bottom:r.y,right:r.x}}const P_=1e-4,mH=1-P_,gH=1+P_,A_=.01,yH=0-A_,xH=0+A_;function Mr(t){return t.max-t.min}function vH(t,e,n){return Math.abs(t-e)<=n}function uT(t,e,n,r=.5){t.origin=r,t.originPoint=pn(e.min,e.max,t.origin),t.scale=Mr(n)/Mr(e),t.translate=pn(n.min,n.max,t.origin)-t.originPoint,(t.scale>=mH&&t.scale<=gH||isNaN(t.scale))&&(t.scale=1),(t.translate>=yH&&t.translate<=xH||isNaN(t.translate))&&(t.translate=0)}function Xh(t,e,n,r){uT(t.x,e.x,n.x,r?r.originX:void 0),uT(t.y,e.y,n.y,r?r.originY:void 0)}function cT(t,e,n){t.min=n.min+e.min,t.max=t.min+Mr(e)}function bH(t,e,n){cT(t.x,e.x,n.x),cT(t.y,e.y,n.y)}function dT(t,e,n){t.min=e.min-n.min,t.max=t.min+Mr(e)}function qh(t,e,n){dT(t.x,e.x,n.x),dT(t.y,e.y,n.y)}const hT=()=>({translate:0,scale:1,origin:0,originPoint:0}),Vc=()=>({x:hT(),y:hT()}),fT=()=>({min:0,max:0}),Cn=()=>({x:fT(),y:fT()});function to(t){return[t("x"),t("y")]}function P1(t){return t===void 0||t===1}function Ux({scale:t,scaleX:e,scaleY:n}){return!P1(t)||!P1(e)||!P1(n)}function iu(t){return Ux(t)||D_(t)||t.z||t.rotate||t.rotateX||t.rotateY||t.skewX||t.skewY}function D_(t){return pT(t.x)||pT(t.y)}function pT(t){return t&&t!=="0%"}function hg(t,e,n){const r=t-n,s=e*r;return n+s}function mT(t,e,n,r,s){return s!==void 0&&(t=hg(t,s,r)),hg(t,n,r)+e}function jx(t,e=0,n=1,r,s){t.min=mT(t.min,e,n,r,s),t.max=mT(t.max,e,n,r,s)}function O_(t,{x:e,y:n}){jx(t.x,e.translate,e.scale,e.originPoint),jx(t.y,n.translate,n.scale,n.originPoint)}const gT=.999999999999,yT=1.0000000000001;function wH(t,e,n,r=!1){const s=n.length;if(!s)return;e.x=e.y=1;let o,i;for(let a=0;a<s;a++){o=n[a],i=o.projectionDelta;const{visualElement:l}=o.options;l&&l.props.style&&l.props.style.display==="contents"||(r&&o.options.layoutScroll&&o.scroll&&o!==o.root&&Uc(t,{x:-o.scroll.offset.x,y:-o.scroll.offset.y}),i&&(e.x*=i.x.scale,e.y*=i.y.scale,O_(t,i)),r&&iu(o.latestValues)&&Uc(t,o.latestValues))}e.x<yT&&e.x>gT&&(e.x=1),e.y<yT&&e.y>gT&&(e.y=1)}function Wc(t,e){t.min=t.min+e,t.max=t.max+e}function xT(t,e,n,r,s=.5){const o=pn(t.min,t.max,s);jx(t,e,n,o,r)}function Uc(t,e){xT(t.x,e.x,e.scaleX,e.scale,e.originX),xT(t.y,e.y,e.scaleY,e.scale,e.originY)}function F_(t,e){return __(pH(t.getBoundingClientRect(),e))}function SH(t,e,n){const r=F_(t,n),{scroll:s}=e;return s&&(Wc(r.x,s.offset.x),Wc(r.y,s.offset.y)),r}const L_=({current:t})=>t?t.ownerDocument.defaultView:null,vT=(t,e)=>Math.abs(t-e);function CH(t,e){const n=vT(t.x,e.x),r=vT(t.y,e.y);return Math.sqrt(n**2+r**2)}class z_{constructor(e,n,{transformPagePoint:r,contextWindow:s,dragSnapToOrigin:o=!1}={}){if(this.startEvent=null,this.lastMoveEvent=null,this.lastMoveEventInfo=null,this.handlers={},this.contextWindow=window,this.updatePoint=()=>{if(!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const f=D1(this.lastMoveEventInfo,this.history),p=this.startEvent!==null,g=CH(f.offset,{x:0,y:0})>=3;if(!p&&!g)return;const{point:y}=f,{timestamp:x}=or;this.history.push({...y,timestamp:x});const{onStart:w,onMove:S}=this.handlers;p||(w&&w(this.lastMoveEvent,f),this.startEvent=this.lastMoveEvent),S&&S(this.lastMoveEvent,f)},this.handlePointerMove=(f,p)=>{this.lastMoveEvent=f,this.lastMoveEventInfo=A1(p,this.transformPagePoint),mn.update(this.updatePoint,!0)},this.handlePointerUp=(f,p)=>{this.end();const{onEnd:g,onSessionEnd:y,resumeAnimation:x}=this.handlers;if(this.dragSnapToOrigin&&x&&x(),!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const w=D1(f.type==="pointercancel"?this.lastMoveEventInfo:A1(p,this.transformPagePoint),this.history);this.startEvent&&g&&g(f,w),y&&y(f,w)},!Db(e))return;this.dragSnapToOrigin=o,this.handlers=n,this.transformPagePoint=r,this.contextWindow=s||window;const i=Vf(e),a=A1(i,this.transformPagePoint),{point:l}=a,{timestamp:c}=or;this.history=[{...l,timestamp:c}];const{onSessionStart:d}=n;d&&d(e,D1(a,this.history)),this.removeListeners=zf(Kh(this.contextWindow,"pointermove",this.handlePointerMove),Kh(this.contextWindow,"pointerup",this.handlePointerUp),Kh(this.contextWindow,"pointercancel",this.handlePointerUp))}updateHandlers(e){this.handlers=e}end(){this.removeListeners&&this.removeListeners(),ml(this.updatePoint)}}function A1(t,e){return e?{point:e(t.point)}:t}function bT(t,e){return{x:t.x-e.x,y:t.y-e.y}}function D1({point:t},e){return{point:t,delta:bT(t,B_(e)),offset:bT(t,$H(e)),velocity:kH(e,.1)}}function $H(t){return t[0]}function B_(t){return t[t.length-1]}function kH(t,e){if(t.length<2)return{x:0,y:0};let n=t.length-1,r=null;const s=B_(t);for(;n>=0&&(r=t[n],!(s.timestamp-r.timestamp>gi(e)));)n--;if(!r)return{x:0,y:0};const o=yi(s.timestamp-r.timestamp);if(o===0)return{x:0,y:0};const i={x:(s.x-r.x)/o,y:(s.y-r.y)/o};return i.x===1/0&&(i.x=0),i.y===1/0&&(i.y=0),i}function TH(t,{min:e,max:n},r){return e!==void 0&&t<e?t=r?pn(e,t,r.min):Math.max(t,e):n!==void 0&&t>n&&(t=r?pn(n,t,r.max):Math.min(t,n)),t}function wT(t,e,n){return{min:e!==void 0?t.min+e:void 0,max:n!==void 0?t.max+n-(t.max-t.min):void 0}}function IH(t,{top:e,left:n,bottom:r,right:s}){return{x:wT(t.x,n,s),y:wT(t.y,e,r)}}function ST(t,e){let n=e.min-t.min,r=e.max-t.max;return e.max-e.min<t.max-t.min&&([n,r]=[r,n]),{min:n,max:r}}function NH(t,e){return{x:ST(t.x,e.x),y:ST(t.y,e.y)}}function EH(t,e){let n=.5;const r=Mr(t),s=Mr(e);return s>r?n=af(e.min,e.max-r,t.min):r>s&&(n=af(t.min,t.max-s,e.min)),ca(0,1,n)}function RH(t,e){const n={};return e.min!==void 0&&(n.min=e.min-t.min),e.max!==void 0&&(n.max=e.max-t.min),n}const Gx=.35;function _H(t=Gx){return t===!1?t=0:t===!0&&(t=Gx),{x:CT(t,"left","right"),y:CT(t,"top","bottom")}}function CT(t,e,n){return{min:$T(t,e),max:$T(t,n)}}function $T(t,e){return typeof t=="number"?t:t[e]||0}const PH=new WeakMap;class AH{constructor(e){this.openDragLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic=Cn(),this.visualElement=e}start(e,{snapToCursor:n=!1}={}){const{presenceContext:r}=this.visualElement;if(r&&r.isPresent===!1)return;const s=d=>{const{dragSnapToOrigin:f}=this.getProps();f?this.pauseAnimation():this.stopAnimation(),n&&this.snapToCursor(Vf(d).point)},o=(d,f)=>{const{drag:p,dragPropagation:g,onDragStart:y}=this.getProps();if(p&&!g&&(this.openDragLock&&this.openDragLock(),this.openDragLock=Yj(p),!this.openDragLock))return;this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),to(w=>{let S=this.getAxisMotionValue(w).get()||0;if(xi.test(S)){const{projection:$}=this.visualElement;if($&&$.layout){const I=$.layout.layoutBox[w];I&&(S=Mr(I)*(parseFloat(S)/100))}}this.originPoint[w]=S}),y&&mn.postRender(()=>y(d,f)),Vx(this.visualElement,"transform");const{animationState:x}=this.visualElement;x&&x.setActive("whileDrag",!0)},i=(d,f)=>{const{dragPropagation:p,dragDirectionLock:g,onDirectionLock:y,onDrag:x}=this.getProps();if(!p&&!this.openDragLock)return;const{offset:w}=f;if(g&&this.currentDirection===null){this.currentDirection=DH(w),this.currentDirection!==null&&y&&y(this.currentDirection);return}this.updateAxis("x",f.point,w),this.updateAxis("y",f.point,w),this.visualElement.render(),x&&x(d,f)},a=(d,f)=>this.stop(d,f),l=()=>to(d=>{var f;return this.getAnimationState(d)==="paused"&&((f=this.getAxisMotionValue(d).animation)==null?void 0:f.play())}),{dragSnapToOrigin:c}=this.getProps();this.panSession=new z_(e,{onSessionStart:s,onStart:o,onMove:i,onSessionEnd:a,resumeAnimation:l},{transformPagePoint:this.visualElement.getTransformPagePoint(),dragSnapToOrigin:c,contextWindow:L_(this.visualElement)})}stop(e,n){const r=this.isDragging;if(this.cancel(),!r)return;const{velocity:s}=n;this.startAnimation(s);const{onDragEnd:o}=this.getProps();o&&mn.postRender(()=>o(e,n))}cancel(){this.isDragging=!1;const{projection:e,animationState:n}=this.visualElement;e&&(e.isAnimationBlocked=!1),this.panSession&&this.panSession.end(),this.panSession=void 0;const{dragPropagation:r}=this.getProps();!r&&this.openDragLock&&(this.openDragLock(),this.openDragLock=null),n&&n.setActive("whileDrag",!1)}updateAxis(e,n,r){const{drag:s}=this.getProps();if(!r||!ym(e,s,this.currentDirection))return;const o=this.getAxisMotionValue(e);let i=this.originPoint[e]+r[e];this.constraints&&this.constraints[e]&&(i=TH(i,this.constraints[e],this.elastic[e])),o.set(i)}resolveConstraints(){var o;const{dragConstraints:e,dragElastic:n}=this.getProps(),r=this.visualElement.projection&&!this.visualElement.projection.layout?this.visualElement.projection.measure(!1):(o=this.visualElement.projection)==null?void 0:o.layout,s=this.constraints;e&&Mc(e)?this.constraints||(this.constraints=this.resolveRefConstraints()):e&&r?this.constraints=IH(r.layoutBox,e):this.constraints=!1,this.elastic=_H(n),s!==this.constraints&&r&&this.constraints&&!this.hasMutatedConstraints&&to(i=>{this.constraints!==!1&&this.getAxisMotionValue(i)&&(this.constraints[i]=RH(r.layoutBox[i],this.constraints[i]))})}resolveRefConstraints(){const{dragConstraints:e,onMeasureDragConstraints:n}=this.getProps();if(!e||!Mc(e))return!1;const r=e.current,{projection:s}=this.visualElement;if(!s||!s.layout)return!1;const o=SH(r,s.root,this.visualElement.getTransformPagePoint());let i=NH(s.layout.layoutBox,o);if(n){const a=n(fH(i));this.hasMutatedConstraints=!!a,a&&(i=__(a))}return i}startAnimation(e){const{drag:n,dragMomentum:r,dragElastic:s,dragTransition:o,dragSnapToOrigin:i,onDragTransitionEnd:a}=this.getProps(),l=this.constraints||{},c=to(d=>{if(!ym(d,n,this.currentDirection))return;let f=l&&l[d]||{};i&&(f={min:0,max:0});const p=s?200:1e6,g=s?40:1e7,y={type:"inertia",velocity:r?e[d]:0,bounceStiffness:p,bounceDamping:g,timeConstant:750,restDelta:1,restSpeed:10,...o,...f};return this.startAxisValueAnimation(d,y)});return Promise.all(c).then(a)}startAxisValueAnimation(e,n){const r=this.getAxisMotionValue(e);return Vx(this.visualElement,e),r.start(Ub(e,r,0,n,this.visualElement,!1))}stopAnimation(){to(e=>this.getAxisMotionValue(e).stop())}pauseAnimation(){to(e=>{var n;return(n=this.getAxisMotionValue(e).animation)==null?void 0:n.pause()})}getAnimationState(e){var n;return(n=this.getAxisMotionValue(e).animation)==null?void 0:n.state}getAxisMotionValue(e){const n=`_drag${e.toUpperCase()}`,r=this.visualElement.getProps(),s=r[n];return s||this.visualElement.getValue(e,(r.initial?r.initial[e]:void 0)||0)}snapToCursor(e){to(n=>{const{drag:r}=this.getProps();if(!ym(n,r,this.currentDirection))return;const{projection:s}=this.visualElement,o=this.getAxisMotionValue(n);if(s&&s.layout){const{min:i,max:a}=s.layout.layoutBox[n];o.set(e[n]-pn(i,a,.5))}})}scalePositionWithinConstraints(){if(!this.visualElement.current)return;const{drag:e,dragConstraints:n}=this.getProps(),{projection:r}=this.visualElement;if(!Mc(n)||!r||!this.constraints)return;this.stopAnimation();const s={x:0,y:0};to(i=>{const a=this.getAxisMotionValue(i);if(a&&this.constraints!==!1){const l=a.get();s[i]=EH({min:l,max:l},this.constraints[i])}});const{transformTemplate:o}=this.visualElement.getProps();this.visualElement.current.style.transform=o?o({},""):"none",r.root&&r.root.updateScroll(),r.updateLayout(),this.resolveConstraints(),to(i=>{if(!ym(i,e,null))return;const a=this.getAxisMotionValue(i),{min:l,max:c}=this.constraints[i];a.set(pn(l,c,s[i]))})}addListeners(){if(!this.visualElement.current)return;PH.set(this.visualElement,this);const e=this.visualElement.current,n=Kh(e,"pointerdown",l=>{const{drag:c,dragListener:d=!0}=this.getProps();c&&d&&this.start(l)}),r=()=>{const{dragConstraints:l}=this.getProps();Mc(l)&&l.current&&(this.constraints=this.resolveRefConstraints())},{projection:s}=this.visualElement,o=s.addEventListener("measure",r);s&&!s.layout&&(s.root&&s.root.updateScroll(),s.updateLayout()),mn.read(r);const i=pf(window,"resize",()=>this.scalePositionWithinConstraints()),a=s.addEventListener("didUpdate",({delta:l,hasLayoutChanged:c})=>{this.isDragging&&c&&(to(d=>{const f=this.getAxisMotionValue(d);f&&(this.originPoint[d]+=l[d].translate,f.set(f.get()+l[d].translate))}),this.visualElement.render())});return()=>{i(),n(),o(),a&&a()}}getProps(){const e=this.visualElement.getProps(),{drag:n=!1,dragDirectionLock:r=!1,dragPropagation:s=!1,dragConstraints:o=!1,dragElastic:i=Gx,dragMomentum:a=!0}=e;return{...e,drag:n,dragDirectionLock:r,dragPropagation:s,dragConstraints:o,dragElastic:i,dragMomentum:a}}}function ym(t,e,n){return(e===!0||e===t)&&(n===null||n===t)}function DH(t,e=10){let n=null;return Math.abs(t.y)>e?n="y":Math.abs(t.x)>e&&(n="x"),n}class OH extends wl{constructor(e){super(e),this.removeGroupControls=io,this.removeListeners=io,this.controls=new AH(e)}mount(){const{dragControls:e}=this.node.getProps();e&&(this.removeGroupControls=e.subscribe(this.controls)),this.removeListeners=this.controls.addListeners()||io}unmount(){this.removeGroupControls(),this.removeListeners()}}const kT=t=>(e,n)=>{t&&mn.postRender(()=>t(e,n))};class FH extends wl{constructor(){super(...arguments),this.removePointerDownListener=io}onPointerDown(e){this.session=new z_(e,this.createPanHandlers(),{transformPagePoint:this.node.getTransformPagePoint(),contextWindow:L_(this.node)})}createPanHandlers(){const{onPanSessionStart:e,onPanStart:n,onPan:r,onPanEnd:s}=this.node.getProps();return{onSessionStart:kT(e),onStart:kT(n),onMove:r,onEnd:(o,i)=>{delete this.session,s&&mn.postRender(()=>s(o,i))}}}mount(){this.removePointerDownListener=Kh(this.node.current,"pointerdown",e=>this.onPointerDown(e))}update(){this.session&&this.session.updateHandlers(this.createPanHandlers())}unmount(){this.removePointerDownListener(),this.session&&this.session.end()}}const Um={hasAnimatedSinceResize:!0,hasEverUpdated:!1};function TT(t,e){return e.max===e.min?0:t/(e.max-e.min)*100}const vh={correct:(t,e)=>{if(!e.target)return t;if(typeof t=="string")if(rt.test(t))t=parseFloat(t);else return t;const n=TT(t,e.target.x),r=TT(t,e.target.y);return`${n}% ${r}%`}},LH={correct:(t,{treeScale:e,projectionDelta:n})=>{const r=t,s=gl.parse(t);if(s.length>5)return r;const o=gl.createTransformer(t),i=typeof s[0]!="number"?1:0,a=n.x.scale*e.x,l=n.y.scale*e.y;s[0+i]/=a,s[1+i]/=l;const c=pn(a,l,.5);return typeof s[2+i]=="number"&&(s[2+i]/=c),typeof s[3+i]=="number"&&(s[3+i]/=c),o(s)}};class zH extends J.Component{componentDidMount(){const{visualElement:e,layoutGroup:n,switchLayoutGroup:r,layoutId:s}=this.props,{projection:o}=e;SG(BH),o&&(n.group&&n.group.add(o),r&&r.register&&s&&r.register(o),o.root.didUpdate(),o.addEventListener("animationComplete",()=>{this.safeToRemove()}),o.setOptions({...o.options,onExitComplete:()=>this.safeToRemove()})),Um.hasEverUpdated=!0}getSnapshotBeforeUpdate(e){const{layoutDependency:n,visualElement:r,drag:s,isPresent:o}=this.props,i=r.projection;return i&&(i.isPresent=o,s||e.layoutDependency!==n||n===void 0||e.isPresent!==o?i.willUpdate():this.safeToRemove(),e.isPresent!==o&&(o?i.promote():i.relegate()||mn.postRender(()=>{const a=i.getStack();(!a||!a.members.length)&&this.safeToRemove()}))),null}componentDidUpdate(){const{projection:e}=this.props.visualElement;e&&(e.root.didUpdate(),Ab.postRender(()=>{!e.currentAnimation&&e.isLead()&&this.safeToRemove()}))}componentWillUnmount(){const{visualElement:e,layoutGroup:n,switchLayoutGroup:r}=this.props,{projection:s}=e;s&&(s.scheduleCheckAfterUnmount(),n&&n.group&&n.group.remove(s),r&&r.deregister&&r.deregister(s))}safeToRemove(){const{safeToRemove:e}=this.props;e&&e()}render(){return null}}function M_(t){const[e,n]=kR(),r=J.useContext(cb);return K.jsx(zH,{...t,layoutGroup:r,switchLayoutGroup:J.useContext(x_),isPresent:e,safeToRemove:n})}const BH={borderRadius:{...vh,applyTo:["borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]},borderTopLeftRadius:vh,borderTopRightRadius:vh,borderBottomLeftRadius:vh,borderBottomRightRadius:vh,boxShadow:LH};function MH(t,e,n){const r=kr(t)?t:cf(t);return r.start(Ub("",r,e,n)),r.animation}function VH(t){return t instanceof SVGElement&&t.tagName!=="svg"}const WH=(t,e)=>t.depth-e.depth;class UH{constructor(){this.children=[],this.isDirty=!1}add(e){mb(this.children,e),this.isDirty=!0}remove(e){gb(this.children,e),this.isDirty=!0}forEach(e){this.isDirty&&this.children.sort(WH),this.isDirty=!1,this.children.forEach(e)}}function jH(t,e){const n=fs.now(),r=({timestamp:s})=>{const o=s-n;o>=e&&(ml(r),t(o-e))};return mn.setup(r,!0),()=>ml(r)}const V_=["TopLeft","TopRight","BottomLeft","BottomRight"],GH=V_.length,IT=t=>typeof t=="string"?parseFloat(t):t,NT=t=>typeof t=="number"||rt.test(t);function HH(t,e,n,r,s,o){s?(t.opacity=pn(0,n.opacity??1,KH(r)),t.opacityExit=pn(e.opacity??1,0,XH(r))):o&&(t.opacity=pn(e.opacity??1,n.opacity??1,r));for(let i=0;i<GH;i++){const a=`border${V_[i]}Radius`;let l=ET(e,a),c=ET(n,a);if(l===void 0&&c===void 0)continue;l||(l=0),c||(c=0),l===0||c===0||NT(l)===NT(c)?(t[a]=Math.max(pn(IT(l),IT(c),r),0),(xi.test(c)||xi.test(l))&&(t[a]+="%")):t[a]=c}(e.rotate||n.rotate)&&(t.rotate=pn(e.rotate||0,n.rotate||0,r))}function ET(t,e){return t[e]!==void 0?t[e]:t.borderRadius}const KH=W_(0,.5,OR),XH=W_(.5,.95,io);function W_(t,e,n){return r=>r<t?0:r>e?1:n(af(t,e,r))}function RT(t,e){t.min=e.min,t.max=e.max}function Zs(t,e){RT(t.x,e.x),RT(t.y,e.y)}function _T(t,e){t.translate=e.translate,t.scale=e.scale,t.originPoint=e.originPoint,t.origin=e.origin}function PT(t,e,n,r,s){return t-=e,t=hg(t,1/n,r),s!==void 0&&(t=hg(t,1/s,r)),t}function qH(t,e=0,n=1,r=.5,s,o=t,i=t){if(xi.test(e)&&(e=parseFloat(e),e=pn(i.min,i.max,e/100)-i.min),typeof e!="number")return;let a=pn(o.min,o.max,r);t===o&&(a-=e),t.min=PT(t.min,e,n,a,s),t.max=PT(t.max,e,n,a,s)}function AT(t,e,[n,r,s],o,i){qH(t,e[n],e[r],e[s],e.scale,o,i)}const YH=["x","scaleX","originX"],QH=["y","scaleY","originY"];function DT(t,e,n,r){AT(t.x,e,YH,n?n.x:void 0,r?r.x:void 0),AT(t.y,e,QH,n?n.y:void 0,r?r.y:void 0)}function OT(t){return t.translate===0&&t.scale===1}function U_(t){return OT(t.x)&&OT(t.y)}function FT(t,e){return t.min===e.min&&t.max===e.max}function ZH(t,e){return FT(t.x,e.x)&&FT(t.y,e.y)}function LT(t,e){return Math.round(t.min)===Math.round(e.min)&&Math.round(t.max)===Math.round(e.max)}function j_(t,e){return LT(t.x,e.x)&&LT(t.y,e.y)}function zT(t){return Mr(t.x)/Mr(t.y)}function BT(t,e){return t.translate===e.translate&&t.scale===e.scale&&t.originPoint===e.originPoint}class JH{constructor(){this.members=[]}add(e){mb(this.members,e),e.scheduleRender()}remove(e){if(gb(this.members,e),e===this.prevLead&&(this.prevLead=void 0),e===this.lead){const n=this.members[this.members.length-1];n&&this.promote(n)}}relegate(e){const n=this.members.findIndex(s=>e===s);if(n===0)return!1;let r;for(let s=n;s>=0;s--){const o=this.members[s];if(o.isPresent!==!1){r=o;break}}return r?(this.promote(r),!0):!1}promote(e,n){const r=this.lead;if(e!==r&&(this.prevLead=r,this.lead=e,e.show(),r)){r.instance&&r.scheduleRender(),e.scheduleRender(),e.resumeFrom=r,n&&(e.resumeFrom.preserveOpacity=!0),r.snapshot&&(e.snapshot=r.snapshot,e.snapshot.latestValues=r.animationValues||r.latestValues),e.root&&e.root.isUpdating&&(e.isLayoutDirty=!0);const{crossfade:s}=e.options;s===!1&&r.hide()}}exitAnimationComplete(){this.members.forEach(e=>{const{options:n,resumingFrom:r}=e;n.onExitComplete&&n.onExitComplete(),r&&r.options.onExitComplete&&r.options.onExitComplete()})}scheduleRender(){this.members.forEach(e=>{e.instance&&e.scheduleRender(!1)})}removeLeadSnapshot(){this.lead&&this.lead.snapshot&&(this.lead.snapshot=void 0)}}function e7(t,e,n){let r="";const s=t.x.translate/e.x,o=t.y.translate/e.y,i=(n==null?void 0:n.z)||0;if((s||o||i)&&(r=`translate3d(${s}px, ${o}px, ${i}px) `),(e.x!==1||e.y!==1)&&(r+=`scale(${1/e.x}, ${1/e.y}) `),n){const{transformPerspective:c,rotate:d,rotateX:f,rotateY:p,skewX:g,skewY:y}=n;c&&(r=`perspective(${c}px) ${r}`),d&&(r+=`rotate(${d}deg) `),f&&(r+=`rotateX(${f}deg) `),p&&(r+=`rotateY(${p}deg) `),g&&(r+=`skewX(${g}deg) `),y&&(r+=`skewY(${y}deg) `)}const a=t.x.scale*e.x,l=t.y.scale*e.y;return(a!==1||l!==1)&&(r+=`scale(${a}, ${l})`),r||"none"}const O1=["","X","Y","Z"],t7={visibility:"hidden"},MT=1e3;let n7=0;function F1(t,e,n,r){const{latestValues:s}=e;s[t]&&(n[t]=s[t],e.setStaticValue(t,0),r&&(r[t]=0))}function G_(t){if(t.hasCheckedOptimisedAppear=!0,t.root===t)return;const{visualElement:e}=t.options;if(!e)return;const n=I_(e);if(window.MotionHasOptimisedAnimation(n,"transform")){const{layout:s,layoutId:o}=t.options;window.MotionCancelOptimisedAnimation(n,"transform",mn,!(s||o))}const{parent:r}=t;r&&!r.hasCheckedOptimisedAppear&&G_(r)}function H_({attachResizeListener:t,defaultParent:e,measureScroll:n,checkIsScrollRoot:r,resetTransform:s}){return class{constructor(i={},a=e==null?void 0:e()){this.id=n7++,this.animationId=0,this.children=new Set,this.options={},this.isTreeAnimating=!1,this.isAnimationBlocked=!1,this.isLayoutDirty=!1,this.isProjectionDirty=!1,this.isSharedProjectionDirty=!1,this.isTransformDirty=!1,this.updateManuallyBlocked=!1,this.updateBlockedByResize=!1,this.isUpdating=!1,this.isSVG=!1,this.needsReset=!1,this.shouldResetTransform=!1,this.hasCheckedOptimisedAppear=!1,this.treeScale={x:1,y:1},this.eventHandlers=new Map,this.hasTreeAnimated=!1,this.updateScheduled=!1,this.scheduleUpdate=()=>this.update(),this.projectionUpdateScheduled=!1,this.checkUpdateFailed=()=>{this.isUpdating&&(this.isUpdating=!1,this.clearAllSnapshots())},this.updateProjection=()=>{this.projectionUpdateScheduled=!1,this.nodes.forEach(o7),this.nodes.forEach(c7),this.nodes.forEach(d7),this.nodes.forEach(i7)},this.resolvedRelativeTargetAt=0,this.hasProjected=!1,this.isVisible=!0,this.animationProgress=0,this.sharedNodes=new Map,this.latestValues=i,this.root=a?a.root||a:this,this.path=a?[...a.path,a]:[],this.parent=a,this.depth=a?a.depth+1:0;for(let l=0;l<this.path.length;l++)this.path[l].shouldResetTransform=!0;this.root===this&&(this.nodes=new UH)}addEventListener(i,a){return this.eventHandlers.has(i)||this.eventHandlers.set(i,new vb),this.eventHandlers.get(i).add(a)}notifyListeners(i,...a){const l=this.eventHandlers.get(i);l&&l.notify(...a)}hasListeners(i){return this.eventHandlers.has(i)}mount(i,a=this.root.hasTreeAnimated){if(this.instance)return;this.isSVG=VH(i),this.instance=i;const{layoutId:l,layout:c,visualElement:d}=this.options;if(d&&!d.current&&d.mount(i),this.root.nodes.add(this),this.parent&&this.parent.children.add(this),a&&(c||l)&&(this.isLayoutDirty=!0),t){let f;const p=()=>this.root.updateBlockedByResize=!1;t(i,()=>{this.root.updateBlockedByResize=!0,f&&f(),f=jH(p,250),Um.hasAnimatedSinceResize&&(Um.hasAnimatedSinceResize=!1,this.nodes.forEach(WT))})}l&&this.root.registerSharedNode(l,this),this.options.animate!==!1&&d&&(l||c)&&this.addEventListener("didUpdate",({delta:f,hasLayoutChanged:p,hasRelativeLayoutChanged:g,layout:y})=>{if(this.isTreeAnimationBlocked()){this.target=void 0,this.relativeTarget=void 0;return}const x=this.options.transition||d.getDefaultTransition()||g7,{onLayoutAnimationStart:w,onLayoutAnimationComplete:S}=d.getProps(),$=!this.targetLayout||!j_(this.targetLayout,y),I=!p&&g;if(this.options.layoutRoot||this.resumeFrom||I||p&&($||!this.currentAnimation)){this.resumeFrom&&(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0),this.setAnimationOrigin(f,I);const R={..._b(x,"layout"),onPlay:w,onComplete:S};(d.shouldReduceMotion||this.options.layoutRoot)&&(R.delay=0,R.type=!1),this.startAnimation(R)}else p||WT(this),this.isLead()&&this.options.onExitComplete&&this.options.onExitComplete();this.targetLayout=y})}unmount(){this.options.layoutId&&this.willUpdate(),this.root.nodes.remove(this);const i=this.getStack();i&&i.remove(this),this.parent&&this.parent.children.delete(this),this.instance=void 0,ml(this.updateProjection)}blockUpdate(){this.updateManuallyBlocked=!0}unblockUpdate(){this.updateManuallyBlocked=!1}isUpdateBlocked(){return this.updateManuallyBlocked||this.updateBlockedByResize}isTreeAnimationBlocked(){return this.isAnimationBlocked||this.parent&&this.parent.isTreeAnimationBlocked()||!1}startUpdate(){this.isUpdateBlocked()||(this.isUpdating=!0,this.nodes&&this.nodes.forEach(h7),this.animationId++)}getTransformTemplate(){const{visualElement:i}=this.options;return i&&i.getProps().transformTemplate}willUpdate(i=!0){if(this.root.hasTreeAnimated=!0,this.root.isUpdateBlocked()){this.options.onExitComplete&&this.options.onExitComplete();return}if(window.MotionCancelOptimisedAnimation&&!this.hasCheckedOptimisedAppear&&G_(this),!this.root.isUpdating&&this.root.startUpdate(),this.isLayoutDirty)return;this.isLayoutDirty=!0;for(let d=0;d<this.path.length;d++){const f=this.path[d];f.shouldResetTransform=!0,f.updateScroll("snapshot"),f.options.layoutRoot&&f.willUpdate(!1)}const{layoutId:a,layout:l}=this.options;if(a===void 0&&!l)return;const c=this.getTransformTemplate();this.prevTransformTemplateValue=c?c(this.latestValues,""):void 0,this.updateSnapshot(),i&&this.notifyListeners("willUpdate")}update(){if(this.updateScheduled=!1,this.isUpdateBlocked()){this.unblockUpdate(),this.clearAllSnapshots(),this.nodes.forEach(VT);return}this.isUpdating||this.nodes.forEach(l7),this.isUpdating=!1,this.nodes.forEach(u7),this.nodes.forEach(r7),this.nodes.forEach(s7),this.clearAllSnapshots();const a=fs.now();or.delta=ca(0,1e3/60,a-or.timestamp),or.timestamp=a,or.isProcessing=!0,I1.update.process(or),I1.preRender.process(or),I1.render.process(or),or.isProcessing=!1}didUpdate(){this.updateScheduled||(this.updateScheduled=!0,Ab.read(this.scheduleUpdate))}clearAllSnapshots(){this.nodes.forEach(a7),this.sharedNodes.forEach(f7)}scheduleUpdateProjection(){this.projectionUpdateScheduled||(this.projectionUpdateScheduled=!0,mn.preRender(this.updateProjection,!1,!0))}scheduleCheckAfterUnmount(){mn.postRender(()=>{this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()})}updateSnapshot(){this.snapshot||!this.instance||(this.snapshot=this.measure(),this.snapshot&&!Mr(this.snapshot.measuredBox.x)&&!Mr(this.snapshot.measuredBox.y)&&(this.snapshot=void 0))}updateLayout(){if(!this.instance||(this.updateScroll(),!(this.options.alwaysMeasureLayout&&this.isLead())&&!this.isLayoutDirty))return;if(this.resumeFrom&&!this.resumeFrom.instance)for(let l=0;l<this.path.length;l++)this.path[l].updateScroll();const i=this.layout;this.layout=this.measure(!1),this.layoutCorrected=Cn(),this.isLayoutDirty=!1,this.projectionDelta=void 0,this.notifyListeners("measure",this.layout.layoutBox);const{visualElement:a}=this.options;a&&a.notify("LayoutMeasure",this.layout.layoutBox,i?i.layoutBox:void 0)}updateScroll(i="measure"){let a=!!(this.options.layoutScroll&&this.instance);if(this.scroll&&this.scroll.animationId===this.root.animationId&&this.scroll.phase===i&&(a=!1),a){const l=r(this.instance);this.scroll={animationId:this.root.animationId,phase:i,isRoot:l,offset:n(this.instance),wasRoot:this.scroll?this.scroll.isRoot:l}}}resetTransform(){if(!s)return;const i=this.isLayoutDirty||this.shouldResetTransform||this.options.alwaysMeasureLayout,a=this.projectionDelta&&!U_(this.projectionDelta),l=this.getTransformTemplate(),c=l?l(this.latestValues,""):void 0,d=c!==this.prevTransformTemplateValue;i&&(a||iu(this.latestValues)||d)&&(s(this.instance,c),this.shouldResetTransform=!1,this.scheduleRender())}measure(i=!0){const a=this.measurePageBox();let l=this.removeElementScroll(a);return i&&(l=this.removeTransform(l)),y7(l),{animationId:this.root.animationId,measuredBox:a,layoutBox:l,latestValues:{},source:this.id}}measurePageBox(){var c;const{visualElement:i}=this.options;if(!i)return Cn();const a=i.measureViewportBox();if(!(((c=this.scroll)==null?void 0:c.wasRoot)||this.path.some(x7))){const{scroll:d}=this.root;d&&(Wc(a.x,d.offset.x),Wc(a.y,d.offset.y))}return a}removeElementScroll(i){var l;const a=Cn();if(Zs(a,i),(l=this.scroll)!=null&&l.wasRoot)return a;for(let c=0;c<this.path.length;c++){const d=this.path[c],{scroll:f,options:p}=d;d!==this.root&&f&&p.layoutScroll&&(f.wasRoot&&Zs(a,i),Wc(a.x,f.offset.x),Wc(a.y,f.offset.y))}return a}applyTransform(i,a=!1){const l=Cn();Zs(l,i);for(let c=0;c<this.path.length;c++){const d=this.path[c];!a&&d.options.layoutScroll&&d.scroll&&d!==d.root&&Uc(l,{x:-d.scroll.offset.x,y:-d.scroll.offset.y}),iu(d.latestValues)&&Uc(l,d.latestValues)}return iu(this.latestValues)&&Uc(l,this.latestValues),l}removeTransform(i){const a=Cn();Zs(a,i);for(let l=0;l<this.path.length;l++){const c=this.path[l];if(!c.instance||!iu(c.latestValues))continue;Ux(c.latestValues)&&c.updateSnapshot();const d=Cn(),f=c.measurePageBox();Zs(d,f),DT(a,c.latestValues,c.snapshot?c.snapshot.layoutBox:void 0,d)}return iu(this.latestValues)&&DT(a,this.latestValues),a}setTargetDelta(i){this.targetDelta=i,this.root.scheduleUpdateProjection(),this.isProjectionDirty=!0}setOptions(i){this.options={...this.options,...i,crossfade:i.crossfade!==void 0?i.crossfade:!0}}clearMeasurements(){this.scroll=void 0,this.layout=void 0,this.snapshot=void 0,this.prevTransformTemplateValue=void 0,this.targetDelta=void 0,this.target=void 0,this.isLayoutDirty=!1}forceRelativeParentToResolveTarget(){this.relativeParent&&this.relativeParent.resolvedRelativeTargetAt!==or.timestamp&&this.relativeParent.resolveTargetDelta(!0)}resolveTargetDelta(i=!1){var p;const a=this.getLead();this.isProjectionDirty||(this.isProjectionDirty=a.isProjectionDirty),this.isTransformDirty||(this.isTransformDirty=a.isTransformDirty),this.isSharedProjectionDirty||(this.isSharedProjectionDirty=a.isSharedProjectionDirty);const l=!!this.resumingFrom||this!==a;if(!(i||l&&this.isSharedProjectionDirty||this.isProjectionDirty||(p=this.parent)!=null&&p.isProjectionDirty||this.attemptToResolveRelativeTarget||this.root.updateBlockedByResize))return;const{layout:d,layoutId:f}=this.options;if(!(!this.layout||!(d||f))){if(this.resolvedRelativeTargetAt=or.timestamp,!this.targetDelta&&!this.relativeTarget){const g=this.getClosestProjectingParent();g&&g.layout&&this.animationProgress!==1?(this.relativeParent=g,this.forceRelativeParentToResolveTarget(),this.relativeTarget=Cn(),this.relativeTargetOrigin=Cn(),qh(this.relativeTargetOrigin,this.layout.layoutBox,g.layout.layoutBox),Zs(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}if(!(!this.relativeTarget&&!this.targetDelta)&&(this.target||(this.target=Cn(),this.targetWithTransforms=Cn()),this.relativeTarget&&this.relativeTargetOrigin&&this.relativeParent&&this.relativeParent.target?(this.forceRelativeParentToResolveTarget(),bH(this.target,this.relativeTarget,this.relativeParent.target)):this.targetDelta?(this.resumingFrom?this.target=this.applyTransform(this.layout.layoutBox):Zs(this.target,this.layout.layoutBox),O_(this.target,this.targetDelta)):Zs(this.target,this.layout.layoutBox),this.attemptToResolveRelativeTarget)){this.attemptToResolveRelativeTarget=!1;const g=this.getClosestProjectingParent();g&&!!g.resumingFrom==!!this.resumingFrom&&!g.options.layoutScroll&&g.target&&this.animationProgress!==1?(this.relativeParent=g,this.forceRelativeParentToResolveTarget(),this.relativeTarget=Cn(),this.relativeTargetOrigin=Cn(),qh(this.relativeTargetOrigin,this.target,g.target),Zs(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}}}getClosestProjectingParent(){if(!(!this.parent||Ux(this.parent.latestValues)||D_(this.parent.latestValues)))return this.parent.isProjecting()?this.parent:this.parent.getClosestProjectingParent()}isProjecting(){return!!((this.relativeTarget||this.targetDelta||this.options.layoutRoot)&&this.layout)}calcProjection(){var y;const i=this.getLead(),a=!!this.resumingFrom||this!==i;let l=!0;if((this.isProjectionDirty||(y=this.parent)!=null&&y.isProjectionDirty)&&(l=!1),a&&(this.isSharedProjectionDirty||this.isTransformDirty)&&(l=!1),this.resolvedRelativeTargetAt===or.timestamp&&(l=!1),l)return;const{layout:c,layoutId:d}=this.options;if(this.isTreeAnimating=!!(this.parent&&this.parent.isTreeAnimating||this.currentAnimation||this.pendingAnimation),this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0),!this.layout||!(c||d))return;Zs(this.layoutCorrected,this.layout.layoutBox);const f=this.treeScale.x,p=this.treeScale.y;wH(this.layoutCorrected,this.treeScale,this.path,a),i.layout&&!i.target&&(this.treeScale.x!==1||this.treeScale.y!==1)&&(i.target=i.layout.layoutBox,i.targetWithTransforms=Cn());const{target:g}=i;if(!g){this.prevProjectionDelta&&(this.createProjectionDeltas(),this.scheduleRender());return}!this.projectionDelta||!this.prevProjectionDelta?this.createProjectionDeltas():(_T(this.prevProjectionDelta.x,this.projectionDelta.x),_T(this.prevProjectionDelta.y,this.projectionDelta.y)),Xh(this.projectionDelta,this.layoutCorrected,g,this.latestValues),(this.treeScale.x!==f||this.treeScale.y!==p||!BT(this.projectionDelta.x,this.prevProjectionDelta.x)||!BT(this.projectionDelta.y,this.prevProjectionDelta.y))&&(this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",g))}hide(){this.isVisible=!1}show(){this.isVisible=!0}scheduleRender(i=!0){var a;if((a=this.options.visualElement)==null||a.scheduleRender(),i){const l=this.getStack();l&&l.scheduleRender()}this.resumingFrom&&!this.resumingFrom.instance&&(this.resumingFrom=void 0)}createProjectionDeltas(){this.prevProjectionDelta=Vc(),this.projectionDelta=Vc(),this.projectionDeltaWithTransform=Vc()}setAnimationOrigin(i,a=!1){const l=this.snapshot,c=l?l.latestValues:{},d={...this.latestValues},f=Vc();(!this.relativeParent||!this.relativeParent.options.layoutRoot)&&(this.relativeTarget=this.relativeTargetOrigin=void 0),this.attemptToResolveRelativeTarget=!a;const p=Cn(),g=l?l.source:void 0,y=this.layout?this.layout.source:void 0,x=g!==y,w=this.getStack(),S=!w||w.members.length<=1,$=!!(x&&!S&&this.options.crossfade===!0&&!this.path.some(m7));this.animationProgress=0;let I;this.mixTargetDelta=R=>{const _=R/1e3;UT(f.x,i.x,_),UT(f.y,i.y,_),this.setTargetDelta(f),this.relativeTarget&&this.relativeTargetOrigin&&this.layout&&this.relativeParent&&this.relativeParent.layout&&(qh(p,this.layout.layoutBox,this.relativeParent.layout.layoutBox),p7(this.relativeTarget,this.relativeTargetOrigin,p,_),I&&ZH(this.relativeTarget,I)&&(this.isProjectionDirty=!1),I||(I=Cn()),Zs(I,this.relativeTarget)),x&&(this.animationValues=d,HH(d,c,this.latestValues,_,$,S)),this.root.scheduleUpdateProjection(),this.scheduleRender(),this.animationProgress=_},this.mixTargetDelta(this.options.layoutRoot?1e3:0)}startAnimation(i){this.notifyListeners("animationStart"),this.currentAnimation&&this.currentAnimation.stop(),this.resumingFrom&&this.resumingFrom.currentAnimation&&this.resumingFrom.currentAnimation.stop(),this.pendingAnimation&&(ml(this.pendingAnimation),this.pendingAnimation=void 0),this.pendingAnimation=mn.update(()=>{Um.hasAnimatedSinceResize=!0,this.currentAnimation=MH(0,MT,{...i,onUpdate:a=>{this.mixTargetDelta(a),i.onUpdate&&i.onUpdate(a)},onStop:()=>{},onComplete:()=>{i.onComplete&&i.onComplete(),this.completeAnimation()}}),this.resumingFrom&&(this.resumingFrom.currentAnimation=this.currentAnimation),this.pendingAnimation=void 0})}completeAnimation(){this.resumingFrom&&(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0);const i=this.getStack();i&&i.exitAnimationComplete(),this.resumingFrom=this.currentAnimation=this.animationValues=void 0,this.notifyListeners("animationComplete")}finishAnimation(){this.currentAnimation&&(this.mixTargetDelta&&this.mixTargetDelta(MT),this.currentAnimation.stop()),this.completeAnimation()}applyTransformsToTarget(){const i=this.getLead();let{targetWithTransforms:a,target:l,layout:c,latestValues:d}=i;if(!(!a||!l||!c)){if(this!==i&&this.layout&&c&&K_(this.options.animationType,this.layout.layoutBox,c.layoutBox)){l=this.target||Cn();const f=Mr(this.layout.layoutBox.x);l.x.min=i.target.x.min,l.x.max=l.x.min+f;const p=Mr(this.layout.layoutBox.y);l.y.min=i.target.y.min,l.y.max=l.y.min+p}Zs(a,l),Uc(a,d),Xh(this.projectionDeltaWithTransform,this.layoutCorrected,a,d)}}registerSharedNode(i,a){this.sharedNodes.has(i)||this.sharedNodes.set(i,new JH),this.sharedNodes.get(i).add(a);const c=a.options.initialPromotionConfig;a.promote({transition:c?c.transition:void 0,preserveFollowOpacity:c&&c.shouldPreserveFollowOpacity?c.shouldPreserveFollowOpacity(a):void 0})}isLead(){const i=this.getStack();return i?i.lead===this:!0}getLead(){var a;const{layoutId:i}=this.options;return i?((a=this.getStack())==null?void 0:a.lead)||this:this}getPrevLead(){var a;const{layoutId:i}=this.options;return i?(a=this.getStack())==null?void 0:a.prevLead:void 0}getStack(){const{layoutId:i}=this.options;if(i)return this.root.sharedNodes.get(i)}promote({needsReset:i,transition:a,preserveFollowOpacity:l}={}){const c=this.getStack();c&&c.promote(this,l),i&&(this.projectionDelta=void 0,this.needsReset=!0),a&&this.setOptions({transition:a})}relegate(){const i=this.getStack();return i?i.relegate(this):!1}resetSkewAndRotation(){const{visualElement:i}=this.options;if(!i)return;let a=!1;const{latestValues:l}=i;if((l.z||l.rotate||l.rotateX||l.rotateY||l.rotateZ||l.skewX||l.skewY)&&(a=!0),!a)return;const c={};l.z&&F1("z",i,c,this.animationValues);for(let d=0;d<O1.length;d++)F1(`rotate${O1[d]}`,i,c,this.animationValues),F1(`skew${O1[d]}`,i,c,this.animationValues);i.render();for(const d in c)i.setStaticValue(d,c[d]),this.animationValues&&(this.animationValues[d]=c[d]);i.scheduleRender()}getProjectionStyles(i){if(!this.instance||this.isSVG)return;if(!this.isVisible)return t7;const a={visibility:""},l=this.getTransformTemplate();if(this.needsReset)return this.needsReset=!1,a.opacity="",a.pointerEvents=Wm(i==null?void 0:i.pointerEvents)||"",a.transform=l?l(this.latestValues,""):"none",a;const c=this.getLead();if(!this.projectionDelta||!this.layout||!c.target){const g={};return this.options.layoutId&&(g.opacity=this.latestValues.opacity!==void 0?this.latestValues.opacity:1,g.pointerEvents=Wm(i==null?void 0:i.pointerEvents)||""),this.hasProjected&&!iu(this.latestValues)&&(g.transform=l?l({},""):"none",this.hasProjected=!1),g}const d=c.animationValues||c.latestValues;this.applyTransformsToTarget(),a.transform=e7(this.projectionDeltaWithTransform,this.treeScale,d),l&&(a.transform=l(d,a.transform));const{x:f,y:p}=this.projectionDelta;a.transformOrigin=`${f.origin*100}% ${p.origin*100}% 0`,c.animationValues?a.opacity=c===this?d.opacity??this.latestValues.opacity??1:this.preserveOpacity?this.latestValues.opacity:d.opacityExit:a.opacity=c===this?d.opacity!==void 0?d.opacity:"":d.opacityExit!==void 0?d.opacityExit:0;for(const g in hf){if(d[g]===void 0)continue;const{correct:y,applyTo:x,isCSSVariable:w}=hf[g],S=a.transform==="none"?d[g]:y(d[g],c);if(x){const $=x.length;for(let I=0;I<$;I++)a[x[I]]=S}else w?this.options.visualElement.renderState.vars[g]=S:a[g]=S}return this.options.layoutId&&(a.pointerEvents=c===this?Wm(i==null?void 0:i.pointerEvents)||"":"none"),a}clearSnapshot(){this.resumeFrom=this.snapshot=void 0}resetTree(){this.root.nodes.forEach(i=>{var a;return(a=i.currentAnimation)==null?void 0:a.stop()}),this.root.nodes.forEach(VT),this.root.sharedNodes.clear()}}}function r7(t){t.updateLayout()}function s7(t){var n;const e=((n=t.resumeFrom)==null?void 0:n.snapshot)||t.snapshot;if(t.isLead()&&t.layout&&e&&t.hasListeners("didUpdate")){const{layoutBox:r,measuredBox:s}=t.layout,{animationType:o}=t.options,i=e.source!==t.layout.source;o==="size"?to(f=>{const p=i?e.measuredBox[f]:e.layoutBox[f],g=Mr(p);p.min=r[f].min,p.max=p.min+g}):K_(o,e.layoutBox,r)&&to(f=>{const p=i?e.measuredBox[f]:e.layoutBox[f],g=Mr(r[f]);p.max=p.min+g,t.relativeTarget&&!t.currentAnimation&&(t.isProjectionDirty=!0,t.relativeTarget[f].max=t.relativeTarget[f].min+g)});const a=Vc();Xh(a,r,e.layoutBox);const l=Vc();i?Xh(l,t.applyTransform(s,!0),e.measuredBox):Xh(l,r,e.layoutBox);const c=!U_(a);let d=!1;if(!t.resumeFrom){const f=t.getClosestProjectingParent();if(f&&!f.resumeFrom){const{snapshot:p,layout:g}=f;if(p&&g){const y=Cn();qh(y,e.layoutBox,p.layoutBox);const x=Cn();qh(x,r,g.layoutBox),j_(y,x)||(d=!0),f.options.layoutRoot&&(t.relativeTarget=x,t.relativeTargetOrigin=y,t.relativeParent=f)}}}t.notifyListeners("didUpdate",{layout:r,snapshot:e,delta:l,layoutDelta:a,hasLayoutChanged:c,hasRelativeLayoutChanged:d})}else if(t.isLead()){const{onExitComplete:r}=t.options;r&&r()}t.options.transition=void 0}function o7(t){t.parent&&(t.isProjecting()||(t.isProjectionDirty=t.parent.isProjectionDirty),t.isSharedProjectionDirty||(t.isSharedProjectionDirty=!!(t.isProjectionDirty||t.parent.isProjectionDirty||t.parent.isSharedProjectionDirty)),t.isTransformDirty||(t.isTransformDirty=t.parent.isTransformDirty))}function i7(t){t.isProjectionDirty=t.isSharedProjectionDirty=t.isTransformDirty=!1}function a7(t){t.clearSnapshot()}function VT(t){t.clearMeasurements()}function l7(t){t.isLayoutDirty=!1}function u7(t){const{visualElement:e}=t.options;e&&e.getProps().onBeforeLayoutMeasure&&e.notify("BeforeLayoutMeasure"),t.resetTransform()}function WT(t){t.finishAnimation(),t.targetDelta=t.relativeTarget=t.target=void 0,t.isProjectionDirty=!0}function c7(t){t.resolveTargetDelta()}function d7(t){t.calcProjection()}function h7(t){t.resetSkewAndRotation()}function f7(t){t.removeLeadSnapshot()}function UT(t,e,n){t.translate=pn(e.translate,0,n),t.scale=pn(e.scale,1,n),t.origin=e.origin,t.originPoint=e.originPoint}function jT(t,e,n,r){t.min=pn(e.min,n.min,r),t.max=pn(e.max,n.max,r)}function p7(t,e,n,r){jT(t.x,e.x,n.x,r),jT(t.y,e.y,n.y,r)}function m7(t){return t.animationValues&&t.animationValues.opacityExit!==void 0}const g7={duration:.45,ease:[.4,0,.1,1]},GT=t=>typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().includes(t),HT=GT("applewebkit/")&&!GT("chrome/")?Math.round:io;function KT(t){t.min=HT(t.min),t.max=HT(t.max)}function y7(t){KT(t.x),KT(t.y)}function K_(t,e,n){return t==="position"||t==="preserve-aspect"&&!vH(zT(e),zT(n),.2)}function x7(t){var e;return t!==t.root&&((e=t.scroll)==null?void 0:e.wasRoot)}const v7=H_({attachResizeListener:(t,e)=>pf(t,"resize",e),measureScroll:()=>({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=>!0}),L1={current:void 0},X_=H_({measureScroll:t=>({x:t.scrollLeft,y:t.scrollTop}),defaultParent:()=>{if(!L1.current){const t=new v7({});t.mount(window),t.setOptions({layoutScroll:!0}),L1.current=t}return L1.current},resetTransform:(t,e)=>{t.style.transform=e!==void 0?e:"none"},checkIsScrollRoot:t=>window.getComputedStyle(t).position==="fixed"}),b7={pan:{Feature:FH},drag:{Feature:OH,ProjectionNode:X_,MeasureLayout:M_}};function XT(t,e,n){const{props:r}=t;t.animationState&&r.whileHover&&t.animationState.setActive("whileHover",n==="Start");const s="onHover"+n,o=r[s];o&&mn.postRender(()=>o(e,Vf(e)))}class w7 extends wl{mount(){const{current:e}=this.node;e&&(this.unmount=Qj(e,(n,r)=>(XT(this.node,r,"Start"),s=>XT(this.node,s,"End"))))}unmount(){}}class S7 extends wl{constructor(){super(...arguments),this.isActive=!1}onFocus(){let e=!1;try{e=this.node.current.matches(":focus-visible")}catch{e=!0}!e||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}onBlur(){!this.isActive||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}mount(){this.unmount=zf(pf(this.node.current,"focus",()=>this.onFocus()),pf(this.node.current,"blur",()=>this.onBlur()))}unmount(){}}function qT(t,e,n){const{props:r}=t;if(t.current instanceof HTMLButtonElement&&t.current.disabled)return;t.animationState&&r.whileTap&&t.animationState.setActive("whileTap",n==="Start");const s="onTap"+(n==="End"?"":n),o=r[s];o&&mn.postRender(()=>o(e,Vf(e)))}class C7 extends wl{mount(){const{current:e}=this.node;e&&(this.unmount=tG(e,(n,r)=>(qT(this.node,r,"Start"),(s,{success:o})=>qT(this.node,s,o?"End":"Cancel")),{useGlobalTarget:this.node.props.globalTapTarget}))}unmount(){}}const Hx=new WeakMap,z1=new WeakMap,$7=t=>{const e=Hx.get(t.target);e&&e(t)},k7=t=>{t.forEach($7)};function T7({root:t,...e}){const n=t||document;z1.has(n)||z1.set(n,{});const r=z1.get(n),s=JSON.stringify(e);return r[s]||(r[s]=new IntersectionObserver(k7,{root:t,...e})),r[s]}function I7(t,e,n){const r=T7(e);return Hx.set(t,n),r.observe(t),()=>{Hx.delete(t),r.unobserve(t)}}const N7={some:0,all:1};class E7 extends wl{constructor(){super(...arguments),this.hasEnteredView=!1,this.isInView=!1}startObserver(){this.unmount();const{viewport:e={}}=this.node.getProps(),{root:n,margin:r,amount:s="some",once:o}=e,i={root:n?n.current:void 0,rootMargin:r,threshold:typeof s=="number"?s:N7[s]},a=l=>{const{isIntersecting:c}=l;if(this.isInView===c||(this.isInView=c,o&&!c&&this.hasEnteredView))return;c&&(this.hasEnteredView=!0),this.node.animationState&&this.node.animationState.setActive("whileInView",c);const{onViewportEnter:d,onViewportLeave:f}=this.node.getProps(),p=c?d:f;p&&p(l)};return I7(this.node.current,i,a)}mount(){this.startObserver()}update(){if(typeof IntersectionObserver>"u")return;const{props:e,prevProps:n}=this.node;["amount","margin","root"].some(R7(e,n))&&this.startObserver()}unmount(){}}function R7({viewport:t={}},{viewport:e={}}={}){return n=>t[n]!==e[n]}const _7={inView:{Feature:E7},tap:{Feature:C7},focus:{Feature:S7},hover:{Feature:w7}},P7={layout:{ProjectionNode:X_,MeasureLayout:M_}},Kx={current:null},q_={current:!1};function A7(){if(q_.current=!0,!!hb)if(window.matchMedia){const t=window.matchMedia("(prefers-reduced-motion)"),e=()=>Kx.current=t.matches;t.addListener(e),e()}else Kx.current=!1}const D7=new WeakMap;function O7(t,e,n){for(const r in e){const s=e[r],o=n[r];if(kr(s))t.addValue(r,s);else if(kr(o))t.addValue(r,cf(s,{owner:t}));else if(o!==s)if(t.hasValue(r)){const i=t.getValue(r);i.liveStyle===!0?i.jump(s):i.hasAnimated||i.set(s)}else{const i=t.getStaticValue(r);t.addValue(r,cf(i!==void 0?i:s,{owner:t}))}}for(const r in n)e[r]===void 0&&t.removeValue(r);return e}const YT=["AnimationStart","AnimationComplete","Update","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"];class F7{scrapeMotionValuesFromProps(e,n,r){return{}}constructor({parent:e,props:n,presenceContext:r,reducedMotionConfig:s,blockInitialAnimation:o,visualState:i},a={}){this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.KeyframeResolver=Rb,this.features={},this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=()=>this.notify("Update",this.latestValues),this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))},this.renderScheduledAt=0,this.scheduleRender=()=>{const p=fs.now();this.renderScheduledAt<p&&(this.renderScheduledAt=p,mn.render(this.render,!1,!0))};const{latestValues:l,renderState:c}=i;this.latestValues=l,this.baseTarget={...l},this.initialValues=n.initial?{...l}:{},this.renderState=c,this.parent=e,this.props=n,this.presenceContext=r,this.depth=e?e.depth+1:0,this.reducedMotionConfig=s,this.options=a,this.blockInitialAnimation=!!o,this.isControllingVariants=Zg(n),this.isVariantNode=g_(n),this.isVariantNode&&(this.variantChildren=new Set),this.manuallyAnimateOnMount=!!(e&&e.current);const{willChange:d,...f}=this.scrapeMotionValuesFromProps(n,{},this);for(const p in f){const g=f[p];l[p]!==void 0&&kr(g)&&g.set(l[p],!1)}}mount(e){this.current=e,D7.set(e,this),this.projection&&!this.projection.instance&&this.projection.mount(e),this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=this.parent.addVariantChild(this)),this.values.forEach((n,r)=>this.bindToMotionValue(r,n)),q_.current||A7(),this.shouldReduceMotion=this.reducedMotionConfig==="never"?!1:this.reducedMotionConfig==="always"?!0:Kx.current,this.parent&&this.parent.children.add(this),this.update(this.props,this.presenceContext)}unmount(){this.projection&&this.projection.unmount(),ml(this.notifyUpdate),ml(this.render),this.valueSubscriptions.forEach(e=>e()),this.valueSubscriptions.clear(),this.removeFromVariantTree&&this.removeFromVariantTree(),this.parent&&this.parent.children.delete(this);for(const e in this.events)this.events[e].clear();for(const e in this.features){const n=this.features[e];n&&(n.unmount(),n.isMounted=!1)}this.current=null}bindToMotionValue(e,n){this.valueSubscriptions.has(e)&&this.valueSubscriptions.get(e)();const r=vd.has(e);r&&this.onBindTransform&&this.onBindTransform();const s=n.on("change",a=>{this.latestValues[e]=a,this.props.onUpdate&&mn.preRender(this.notifyUpdate),r&&this.projection&&(this.projection.isTransformDirty=!0)}),o=n.on("renderRequest",this.scheduleRender);let i;window.MotionCheckAppearSync&&(i=window.MotionCheckAppearSync(this,e,n)),this.valueSubscriptions.set(e,()=>{s(),o(),i&&i(),n.owner&&n.stop()})}sortNodePosition(e){return!this.current||!this.sortInstanceNodePosition||this.type!==e.type?0:this.sortInstanceNodePosition(this.current,e.current)}updateFeatures(){let e="animation";for(e in od){const n=od[e];if(!n)continue;const{isEnabled:r,Feature:s}=n;if(!this.features[e]&&s&&r(this.props)&&(this.features[e]=new s(this)),this.features[e]){const o=this.features[e];o.isMounted?o.update():(o.mount(),o.isMounted=!0)}}}triggerBuild(){this.build(this.renderState,this.latestValues,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):Cn()}getStaticValue(e){return this.latestValues[e]}setStaticValue(e,n){this.latestValues[e]=n}update(e,n){(e.transformTemplate||this.props.transformTemplate)&&this.scheduleRender(),this.prevProps=this.props,this.props=e,this.prevPresenceContext=this.presenceContext,this.presenceContext=n;for(let r=0;r<YT.length;r++){const s=YT[r];this.propEventSubscriptions[s]&&(this.propEventSubscriptions[s](),delete this.propEventSubscriptions[s]);const o="on"+s,i=e[o];i&&(this.propEventSubscriptions[s]=this.on(s,i))}this.prevMotionValues=O7(this,this.scrapeMotionValuesFromProps(e,this.prevProps,this),this.prevMotionValues),this.handleChildMotionValue&&this.handleChildMotionValue()}getProps(){return this.props}getVariant(e){return this.props.variants?this.props.variants[e]:void 0}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():void 0}addVariantChild(e){const n=this.getClosestVariantNode();if(n)return n.variantChildren&&n.variantChildren.add(e),()=>n.variantChildren.delete(e)}addValue(e,n){const r=this.values.get(e);n!==r&&(r&&this.removeValue(e),this.bindToMotionValue(e,n),this.values.set(e,n),this.latestValues[e]=n.get())}removeValue(e){this.values.delete(e);const n=this.valueSubscriptions.get(e);n&&(n(),this.valueSubscriptions.delete(e)),delete this.latestValues[e],this.removeValueFromRenderState(e,this.renderState)}hasValue(e){return this.values.has(e)}getValue(e,n){if(this.props.values&&this.props.values[e])return this.props.values[e];let r=this.values.get(e);return r===void 0&&n!==void 0&&(r=cf(n===null?void 0:n,{owner:this}),this.addValue(e,r)),r}readValue(e,n){let r=this.latestValues[e]!==void 0||!this.current?this.latestValues[e]:this.getBaseTargetFromProps(this.props,e)??this.readValueFromInstance(this.current,e,this.options);return r!=null&&(typeof r=="string"&&(TR(r)||IR(r))?r=parseFloat(r):!oG(r)&&gl.test(n)&&(r=u_(e,n)),this.setBaseTarget(e,kr(r)?r.get():r)),kr(r)?r.get():r}setBaseTarget(e,n){this.baseTarget[e]=n}getBaseTarget(e){var o;const{initial:n}=this.props;let r;if(typeof n=="string"||typeof n=="object"){const i=Vb(this.props,n,(o=this.presenceContext)==null?void 0:o.custom);i&&(r=i[e])}if(n&&r!==void 0)return r;const s=this.getBaseTargetFromProps(this.props,e);return s!==void 0&&!kr(s)?s:this.initialValues[e]!==void 0&&r===void 0?void 0:this.baseTarget[e]}on(e,n){return this.events[e]||(this.events[e]=new vb),this.events[e].add(n)}notify(e,...n){this.events[e]&&this.events[e].notify(...n)}}class Y_ extends F7{constructor(){super(...arguments),this.KeyframeResolver=Xj}sortInstanceNodePosition(e,n){return e.compareDocumentPosition(n)&2?1:-1}getBaseTargetFromProps(e,n){return e.style?e.style[n]:void 0}removeValueFromRenderState(e,{vars:n,style:r}){delete n[e],delete r[e]}handleChildMotionValue(){this.childSubscription&&(this.childSubscription(),delete this.childSubscription);const{children:e}=this.props;kr(e)&&(this.childSubscription=e.on("change",n=>{this.current&&(this.current.textContent=`${n}`)}))}}function Q_(t,{style:e,vars:n},r,s){Object.assign(t.style,e,s&&s.getProjectionStyles(r));for(const o in n)t.style.setProperty(o,n[o])}function L7(t){return window.getComputedStyle(t)}class z7 extends Y_{constructor(){super(...arguments),this.type="html",this.renderInstance=Q_}readValueFromInstance(e,n){if(vd.has(n))return fj(e,n);{const r=L7(e),s=(Sb(n)?r.getPropertyValue(n):r[n])||0;return typeof s=="string"?s.trim():s}}measureInstanceViewportBox(e,{transformPagePoint:n}){return F_(e,n)}build(e,n,r){zb(e,n,r.transformTemplate)}scrapeMotionValuesFromProps(e,n,r){return Wb(e,n,r)}}const Z_=new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength","startOffset","textLength","lengthAdjust"]);function B7(t,e,n,r){Q_(t,e,void 0,r);for(const s in e.attrs)t.setAttribute(Z_.has(s)?s:Lb(s),e.attrs[s])}class M7 extends Y_{constructor(){super(...arguments),this.type="svg",this.isSVGTag=!1,this.measureInstanceViewportBox=Cn}getBaseTargetFromProps(e,n){return e[n]}readValueFromInstance(e,n){if(vd.has(n)){const r=l_(n);return r&&r.default||0}return n=Z_.has(n)?n:Lb(n),e.getAttribute(n)}scrapeMotionValuesFromProps(e,n,r){return T_(e,n,r)}build(e,n,r){S_(e,n,this.isSVGTag,r.transformTemplate)}renderInstance(e,n,r,s){B7(e,n,r,s)}mount(e){this.isSVGTag=$_(e.tagName),super.mount(e)}}const V7=(t,e)=>Mb(t)?new M7(e):new z7(e,{allowProjection:t!==J.Fragment}),W7=BG({...dH,..._7,...b7,...P7},V7),Wf=cG(W7),U7=(t,e)=>t.find(n=>n.id===e);function QT(t,e){const n=J_(t,e),r=n?t[n].findIndex(s=>s.id===e):-1;return{position:n,index:r}}function J_(t,e){for(const[n,r]of Object.entries(t))if(U7(r,e))return n}function j7(t){const e=t.includes("right"),n=t.includes("left");let r="center";return e&&(r="flex-end"),n&&(r="flex-start"),{display:"flex",flexDirection:"column",alignItems:r}}function G7(t){const n=t==="top"||t==="bottom"?"0 auto":void 0,r=t.includes("top")?"env(safe-area-inset-top, 0px)":void 0,s=t.includes("bottom")?"env(safe-area-inset-bottom, 0px)":void 0,o=t.includes("left")?void 0:"env(safe-area-inset-right, 0px)",i=t.includes("right")?void 0:"env(safe-area-inset-left, 0px)";return{position:"fixed",zIndex:"var(--toast-z-index, 5500)",pointerEvents:"none",display:"flex",flexDirection:"column",margin:n,top:r,bottom:s,right:o,left:i}}var H7=/^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,K7=hR(function(t){return H7.test(t)||t.charCodeAt(0)===111&&t.charCodeAt(1)===110&&t.charCodeAt(2)<91}),X7=K7,q7=function(e){return e!=="theme"},ZT=function(e){return typeof e=="string"&&e.charCodeAt(0)>96?X7:q7},JT=function(e,n,r){var s;if(n){var o=n.shouldForwardProp;s=e.__emotion_forwardProp&&o?function(i){return e.__emotion_forwardProp(i)&&o(i)}:o}return typeof s!="function"&&r&&(s=e.__emotion_forwardProp),s},Y7=function(e){var n=e.cache,r=e.serialized,s=e.isStringTag;return rb(n,r,s),yR(function(){return sb(n,r,s)}),null},Q7=function t(e,n){var r=e.__emotion_real===e,s=r&&e.__emotion_base||e,o,i;n!==void 0&&(o=n.label,i=n.target);var a=JT(e,n,r),l=a||ZT(s),c=!l("as");return function(){var d=arguments,f=r&&e.__emotion_styles!==void 0?e.__emotion_styles.slice(0):[];if(o!==void 0&&f.push("label:"+o+";"),d[0]==null||d[0].raw===void 0)f.push.apply(f,d);else{var p=d[0];f.push(p[0]);for(var g=d.length,y=1;y<g;y++)f.push(d[y],p[y])}var x=ib(function(w,S,$){var I=c&&w.as||s,R="",_=[],O=w;if(w.theme==null){O={};for(var F in w)O[F]=w[F];O.theme=J.useContext(rd)}typeof w.className=="string"?R=pR(S.registered,_,w.className):w.className!=null&&(R=w.className+" ");var B=Xg(f.concat(_),S.registered,O);R+=S.key+"-"+B.name,i!==void 0&&(R+=" "+i);var M=c&&a===void 0?ZT(I):l,V={};for(var P in w)c&&P==="as"||M(P)&&(V[P]=w[P]);return V.className=R,$&&(V.ref=$),J.createElement(J.Fragment,null,J.createElement(Y7,{cache:S,serialized:B,isStringTag:typeof I=="string"}),J.createElement(I,V))});return x.displayName=o!==void 0?o:"Styled("+(typeof s=="string"?s:s.displayName||s.name||"Component")+")",x.defaultProps=e.defaultProps,x.__emotion_real=x,x.__emotion_base=s,x.__emotion_styles=f,x.__emotion_forwardProp=a,Object.defineProperty(x,"toString",{value:function(){return"."+i}}),x.withComponent=function(w,S){var $=t(w,ag({},n,S,{shouldForwardProp:JT(x,S,!0)}));return $.apply(void 0,f)},x}},Z7=["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","marquee","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr","circle","clipPath","defs","ellipse","foreignObject","g","image","line","linearGradient","mask","path","pattern","polygon","polyline","radialGradient","rect","stop","svg","text","tspan"],Xx=Q7.bind(null);Z7.forEach(function(t){Xx[t]=Xx(t)});const J7=new Set([...dz,"textStyle","layerStyle","apply","noOfLines","focusBorderColor","errorBorderColor","as","__css","css","sx"]),e9=new Set(["htmlWidth","htmlHeight","htmlSize","htmlTranslate"]);function t9(t){return(e9.has(t)||!J7.has(t))&&t[0]!=="_"}const n9=CL(Xx),r9=({baseStyle:t})=>e=>{const{theme:n,css:r,__css:s,sx:o,...i}=e,[a]=TL(i,fz),l=ro(t,e),c=mL({},s,l,Vg(a),o),d=jE(c)(e.theme);return r?[d,r]:d};function B1(t,e){const{baseStyle:n,...r}=e??{};r.shouldForwardProp||(r.shouldForwardProp=t9);const s=r9({baseStyle:n}),o=n9(t,r)(s);return J.forwardRef(function(l,c){const{children:d,...f}=l,{colorMode:p,forced:g}=ub(),y=g?p:void 0;return J.createElement(o,{ref:c,"data-theme":y,...f},d)})}function s9(){const t=new Map;return new Proxy(B1,{apply(e,n,r){return B1(...r)},get(e,n){return t.has(n)||t.set(n,B1(n)),t.get(n)}})}const it=s9(),o9={initial:t=>{const{position:e}=t,n=["top","bottom"].includes(e)?"y":"x";let r=["top-right","bottom-right"].includes(e)?1:-1;return e==="bottom"&&(r=1),{opacity:0,[n]:r*24}},animate:{opacity:1,y:0,x:0,scale:1,transition:{duration:.4,ease:[.4,0,.2,1]}},exit:{opacity:0,scale:.85,transition:{duration:.2,ease:[.4,0,1,1]}}},eP=J.memo(t=>{const{id:e,message:n,onCloseComplete:r,onRequestRemove:s,requestClose:o=!1,position:i="bottom",duration:a=5e3,containerStyle:l,motionVariants:c=o9,toastSpacing:d="0.5rem"}=t,[f,p]=J.useState(a),g=u8();o3(()=>{g||r==null||r()},[g]),o3(()=>{p(a)},[a]);const y=()=>p(null),x=()=>p(a),w=()=>{g&&s()};J.useEffect(()=>{g&&o&&s()},[g,o,s]),PL(w,f);const S=J.useMemo(()=>({pointerEvents:"auto",maxWidth:560,minWidth:300,margin:d,...l}),[l,d]),$=J.useMemo(()=>j7(i),[i]);return K.jsx(Wf.div,{layout:!0,className:"chakra-toast",variants:c,initial:"initial",animate:"animate",exit:"exit",onHoverStart:y,onHoverEnd:x,custom:{position:i},style:$,children:K.jsx(it.div,{role:"status","aria-atomic":"true",className:"chakra-toast__inner",__css:S,children:ro(n,{id:e,onClose:w})})})});eP.displayName="ToastComponent";function lt(t){return J.forwardRef(t)}var M1,eI;function i9(){if(eI)return M1;eI=1;var t=typeof Element<"u",e=typeof Map=="function",n=typeof Set=="function",r=typeof ArrayBuffer=="function"&&!!ArrayBuffer.isView;function s(o,i){if(o===i)return!0;if(o&&i&&typeof o=="object"&&typeof i=="object"){if(o.constructor!==i.constructor)return!1;var a,l,c;if(Array.isArray(o)){if(a=o.length,a!=i.length)return!1;for(l=a;l--!==0;)if(!s(o[l],i[l]))return!1;return!0}var d;if(e&&o instanceof Map&&i instanceof Map){if(o.size!==i.size)return!1;for(d=o.entries();!(l=d.next()).done;)if(!i.has(l.value[0]))return!1;for(d=o.entries();!(l=d.next()).done;)if(!s(l.value[1],i.get(l.value[0])))return!1;return!0}if(n&&o instanceof Set&&i instanceof Set){if(o.size!==i.size)return!1;for(d=o.entries();!(l=d.next()).done;)if(!i.has(l.value[0]))return!1;return!0}if(r&&ArrayBuffer.isView(o)&&ArrayBuffer.isView(i)){if(a=o.length,a!=i.length)return!1;for(l=a;l--!==0;)if(o[l]!==i[l])return!1;return!0}if(o.constructor===RegExp)return o.source===i.source&&o.flags===i.flags;if(o.valueOf!==Object.prototype.valueOf&&typeof o.valueOf=="function"&&typeof i.valueOf=="function")return o.valueOf()===i.valueOf();if(o.toString!==Object.prototype.toString&&typeof o.toString=="function"&&typeof i.toString=="function")return o.toString()===i.toString();if(c=Object.keys(o),a=c.length,a!==Object.keys(i).length)return!1;for(l=a;l--!==0;)if(!Object.prototype.hasOwnProperty.call(i,c[l]))return!1;if(t&&o instanceof Element)return!1;for(l=a;l--!==0;)if(!((c[l]==="_owner"||c[l]==="__v"||c[l]==="__o")&&o.$$typeof)&&!s(o[c[l]],i[c[l]]))return!1;return!0}return o!==o&&i!==i}return M1=function(i,a){try{return s(i,a)}catch(l){if((l.message||"").match(/stack|recursion/i))return console.warn("react-fast-compare cannot handle circular refs"),!1;throw l}},M1}var a9=i9();const l9=Af(a9);function tP(){const t=J.useContext(rd);if(!t)throw Error("useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`");return t}function nP(){const t=ub(),e=tP();return{...t,theme:e}}function u9(t,e,n){if(e==null)return e;const r=s=>{var o,i;return(i=(o=t.__cssMap)==null?void 0:o[s])==null?void 0:i.value};return r(e)??r(n)??n}function c9(t,e,n){const r=Array.isArray(e)?e:[e],s=Array.isArray(n)?n:[n];return o=>{const i=s.filter(Boolean),a=r.map((l,c)=>{const d=`${t}.${l}`;return u9(o,d,i[c]??l)});return Array.isArray(e)?a:a[0]}}function rP(t,e={}){const{styleConfig:n,...r}=e,{theme:s,colorMode:o}=nP(),i=t?BE(s,`components.${t}`):void 0,a=n||i,l=so({theme:s,colorMode:o},(a==null?void 0:a.defaultProps)??{},Vg(Gv(r,["children"])),(d,f)=>d?void 0:f),c=J.useRef({});if(a){const f=Cz(a)(l);l9(c.current,f)||(c.current=f)}return c.current}function Sl(t,e={}){return rP(t,e)}function ba(t,e={}){return rP(t,e)}const tI={path:K.jsxs("g",{stroke:"currentColor",strokeWidth:"1.5",children:[K.jsx("path",{strokeLinecap:"round",fill:"none",d:"M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25"}),K.jsx("path",{fill:"currentColor",strokeLinecap:"round",d:"M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0"}),K.jsx("circle",{fill:"none",strokeMiterlimit:"10",cx:"12",cy:"12",r:"11.25"})]}),viewBox:"0 0 24 24"},wa=lt((t,e)=>{const{as:n,viewBox:r,color:s="currentColor",focusable:o=!1,children:i,className:a,__css:l,...c}=t,d=Lt("chakra-icon",a),f=Sl("Icon",t),p={w:"1em",h:"1em",display:"inline-block",lineHeight:"1em",flexShrink:0,color:s,...l,...f},g={ref:e,focusable:o,className:d,__css:p},y=r??tI.viewBox;if(n&&typeof n!="string")return K.jsx(it.svg,{as:n,...g,...c});const x=i??tI.path;return K.jsx(it.svg,{verticalAlign:"middle",viewBox:y,...g,...c,children:x})});wa.displayName="Icon";function d9(t){return K.jsx(wa,{viewBox:"0 0 24 24",...t,children:K.jsx("path",{fill:"currentColor",d:"M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z"})})}function h9(t){return K.jsx(wa,{viewBox:"0 0 24 24",...t,children:K.jsx("path",{fill:"currentColor",d:"M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z"})})}function nI(t){return K.jsx(wa,{viewBox:"0 0 24 24",...t,children:K.jsx("path",{fill:"currentColor",d:"M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"})})}const f9=Ff({"0%":{transform:"rotate(0deg)"},"100%":{transform:"rotate(360deg)"}}),Uf=lt((t,e)=>{const n=Sl("Spinner",t),{label:r="Loading...",thickness:s="2px",speed:o="0.45s",emptyColor:i="transparent",className:a,...l}=Ir(t),c=Lt("chakra-spinner",a),d={display:"inline-block",borderColor:"currentColor",borderStyle:"solid",borderRadius:"99999px",borderWidth:s,borderBottomColor:i,borderLeftColor:i,animation:`${f9} ${o} linear infinite`,...n};return K.jsx(it.div,{ref:e,__css:d,className:c,...l,children:r&&K.jsx(it.span,{srOnly:!0,children:r})})});Uf.displayName="Spinner";const[p9,jb]=Hr({name:"AlertContext",hookName:"useAlertContext",providerName:"<Alert />"}),[m9,Gb]=Hr({name:"AlertStylesContext",hookName:"useAlertStyles",providerName:"<Alert />"}),sP={info:{icon:h9,colorScheme:"blue"},warning:{icon:nI,colorScheme:"orange"},success:{icon:d9,colorScheme:"green"},error:{icon:nI,colorScheme:"red"},loading:{icon:Uf,colorScheme:"blue"}};function g9(t){return sP[t].colorScheme}function y9(t){return sP[t].icon}const Hb=lt(function(e,n){const{status:r="info",addRole:s=!0,...o}=Ir(e),i=e.colorScheme??g9(r),a=ba("Alert",{...e,colorScheme:i}),l={width:"100%",display:"flex",alignItems:"center",position:"relative",overflow:"hidden",...a.container};return K.jsx(p9,{value:{status:r},children:K.jsx(m9,{value:a,children:K.jsx(it.div,{"data-status":r,role:s?"alert":void 0,ref:n,...o,className:Lt("chakra-alert",e.className),__css:l})})})});Hb.displayName="Alert";function Kb(t){const{status:e}=jb(),n=y9(e),r=Gb(),s=e==="loading"?r.spinner:r.icon;return K.jsx(it.span,{display:"inherit","data-status":e,...t,className:Lt("chakra-alert__icon",t.className),__css:s,children:t.children||K.jsx(n,{h:"100%",w:"100%"})})}Kb.displayName="AlertIcon";const oP=lt(function(e,n){const r=Gb(),{status:s}=jb();return K.jsx(it.div,{ref:n,"data-status":s,...e,className:Lt("chakra-alert__title",e.className),__css:r.title})});oP.displayName="AlertTitle";const iP=lt(function(e,n){const{status:r}=jb(),s=Gb(),o={display:"inline",...s.description};return K.jsx(it.div,{ref:n,"data-status":r,...e,className:Lt("chakra-alert__desc",e.className),__css:o})});iP.displayName="AlertDescription";function x9(t){return K.jsx(wa,{focusable:"false","aria-hidden":!0,...t,children:K.jsx("path",{fill:"currentColor",d:"M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z"})})}const aP=lt(function(e,n){const r=Sl("CloseButton",e),{children:s,isDisabled:o,__css:i,...a}=Ir(e),l={outline:0,display:"flex",alignItems:"center",justifyContent:"center",flexShrink:0};return K.jsx(it.button,{type:"button","aria-label":"Close",ref:n,disabled:o,__css:{...l,...r,...i},...a,children:s||K.jsx(x9,{width:"1em",height:"1em"})})});aP.displayName="CloseButton";const v9=t=>{const{status:e,variant:n="solid",id:r,title:s,isClosable:o,onClose:i,description:a,colorScheme:l,icon:c}=t,d=r?{root:`toast-${r}`,title:`toast-${r}-title`,description:`toast-${r}-description`}:void 0;return K.jsxs(Hb,{addRole:!1,status:e,variant:n,id:d==null?void 0:d.root,alignItems:"start",borderRadius:"md",boxShadow:"lg",paddingEnd:8,textAlign:"start",width:"auto",colorScheme:l,children:[K.jsx(Kb,{children:c}),K.jsxs(it.div,{flex:"1",maxWidth:"100%",children:[s&&K.jsx(oP,{id:d==null?void 0:d.title,children:s}),a&&K.jsx(iP,{id:d==null?void 0:d.description,display:"block",children:a})]}),o&&K.jsx(aP,{size:"sm",onClick:i,position:"absolute",insetEnd:1,top:1})]})};function lP(t={}){const{render:e,toastComponent:n=v9}=t;return s=>typeof e=="function"?e({...s,...t}):K.jsx(n,{...s,...t})}const b9={top:[],"top-left":[],"top-right":[],"bottom-left":[],bottom:[],"bottom-right":[]},di=w9(b9);function w9(t){let e=t;const n=new Set,r=s=>{e=s(e),n.forEach(o=>o())};return{getState:()=>e,subscribe:s=>(n.add(s),()=>{r(()=>t),n.delete(s)}),removeToast:(s,o)=>{r(i=>({...i,[o]:i[o].filter(a=>a.id!=s)}))},notify:(s,o)=>{const i=S9(s,o),{position:a,id:l}=i;return r(c=>{const f=a.includes("top")?[i,...c[a]??[]]:[...c[a]??[],i];return{...c,[a]:f}}),l},update:(s,o)=>{s&&r(i=>{const a={...i},{position:l,index:c}=QT(a,s);return l&&c!==-1&&(a[l][c]={...a[l][c],...o,message:lP(o)}),a})},closeAll:({positions:s}={})=>{r(o=>(s??["bottom","bottom-right","bottom-left","top","top-left","top-right"]).reduce((l,c)=>(l[c]=o[c].map(d=>({...d,requestClose:!0})),l),{...o}))},close:s=>{r(o=>{const i=J_(o,s);return i?{...o,[i]:o[i].map(a=>a.id==s?{...a,requestClose:!0}:a)}:o})},isActive:s=>!!QT(di.getState(),s).position}}let rI=0;function S9(t,e={}){rI+=1;const n=e.id??rI,r=e.position??"bottom";return{id:n,message:t,position:r,duration:e.duration,onCloseComplete:e.onCloseComplete,onRequestRemove:()=>di.removeToast(String(n),r),status:e.status,requestClose:!1,containerStyle:e.containerStyle}}var uP=LE();const[cP,C9]=Hr({strict:!1,name:"PortalContext"}),Xb="chakra-portal",$9=".chakra-portal",k9=t=>K.jsx("div",{className:"chakra-portal-zIndex",style:{position:"absolute",zIndex:t.zIndex,top:0,left:0,right:0},children:t.children}),T9=t=>{const{appendToParentPortal:e,children:n}=t,[r,s]=J.useState(null),o=J.useRef(null),[,i]=J.useState({});J.useEffect(()=>i({}),[]);const a=C9(),l=r8();ng(()=>{if(!r)return;const d=r.ownerDocument,f=e?a??d.body:d.body;if(!f)return;o.current=d.createElement("div"),o.current.className=Xb,f.appendChild(o.current),i({});const p=o.current;return()=>{f.contains(p)&&f.removeChild(p)}},[r]);const c=l!=null&&l.zIndex?K.jsx(k9,{zIndex:l==null?void 0:l.zIndex,children:n}):n;return o.current?uP.createPortal(K.jsx(cP,{value:o.current,children:c}),o.current):K.jsx("span",{ref:d=>{d&&s(d)}})},I9=t=>{const{children:e,containerRef:n,appendToParentPortal:r}=t,s=n.current,o=s??(typeof window<"u"?document.body:void 0),i=J.useMemo(()=>{const l=s==null?void 0:s.ownerDocument.createElement("div");return l&&(l.className=Xb),l},[s]),[,a]=J.useState({});return ng(()=>a({}),[]),ng(()=>{if(!(!i||!o))return o.appendChild(i),()=>{o.removeChild(i)}},[i,o]),o&&i?uP.createPortal(K.jsx(cP,{value:r?i:null,children:e}),i):null};function Jg(t){const e={appendToParentPortal:!0,...t},{containerRef:n,...r}=e;return n?K.jsx(I9,{containerRef:n,...r}):K.jsx(T9,{...r})}Jg.className=Xb;Jg.selector=$9;Jg.displayName="Portal";const[N9,E9]=Hr({name:"ToastOptionsContext",strict:!1}),R9=t=>{const e=J.useSyncExternalStore(di.subscribe,di.getState,di.getState),{motionVariants:n,component:r=eP,portalProps:s,animatePresenceProps:o}=t,a=Object.keys(e).map(l=>{const c=e[l];return K.jsx("div",{role:"region","aria-live":"polite","aria-label":`Notifications-${l}`,id:`chakra-toast-manager-${l}`,style:G7(l),children:K.jsx(pb,{...o,initial:!1,children:c.map(d=>K.jsx(r,{motionVariants:n,...d},d.id))})},l)});return K.jsx(Jg,{...s,children:a})},_9=t=>function({children:n,theme:r=t,toastOptions:s,...o}){return K.jsxs(s8,{theme:r,...o,children:[K.jsx(N9,{value:s==null?void 0:s.defaultOptions,children:n}),K.jsx(R9,{...s})]})},P9=_9(oR),sI={easeIn:[.4,0,1,1],easeOut:[0,0,.2,1]},fg={enter:{duration:.2,ease:sI.easeOut},exit:{duration:.1,ease:sI.easeIn}},pg={enter:(t,e)=>({...t,delay:typeof e=="number"?e:e==null?void 0:e.enter}),exit:(t,e)=>({...t,delay:typeof e=="number"?e:e==null?void 0:e.exit})};function A9(t){const{loading:e,src:n,srcSet:r,onLoad:s,onError:o,crossOrigin:i,sizes:a,ignoreFallback:l}=t,[c,d]=J.useState("pending");J.useEffect(()=>{d(n?"loading":"pending")},[n]);const f=J.useRef(null),p=J.useCallback(()=>{if(!n)return;g();const y=new Image;y.src=n,i&&(y.crossOrigin=i),r&&(y.srcset=r),a&&(y.sizes=a),e&&(y.loading=e),y.onload=x=>{g(),d("loaded"),s==null||s(x)},y.onerror=x=>{g(),d("failed"),o==null||o(x)},f.current=y},[n,i,r,a,s,o,e]),g=()=>{f.current&&(f.current.onload=null,f.current.onerror=null,f.current=null)};return ng(()=>{if(!l)return c==="loading"&&p(),()=>{g()}},[c,p,l]),l?"loaded":c}const D9=(t,e)=>t!=="loaded"&&e==="beforeLoadOrError"||t==="failed"&&e==="onError",Ao=it("div");Ao.displayName="Box";const dP=lt(function(e,n){const{size:r,centerContent:s=!0,...o}=e,i=s?{display:"flex",alignItems:"center",justifyContent:"center"}:{};return K.jsx(Ao,{ref:n,boxSize:r,__css:{...i,flexShrink:0,flexGrow:0},...o})});dP.displayName="Square";const hP=lt(function(e,n){const{size:r,...s}=e;return K.jsx(dP,{size:r,ref:n,borderRadius:"9999px",...s})});hP.displayName="Circle";const[T3e,O9]=Hr({strict:!1,name:"ButtonGroupContext"});function Ph(t){const{children:e,className:n,...r}=t,s=J.isValidElement(e)?J.cloneElement(e,{"aria-hidden":!0,focusable:!1}):e,o=Lt("chakra-button__icon",n);return K.jsx(it.span,{display:"inline-flex",alignSelf:"center",flexShrink:0,...r,className:o,children:s})}Ph.displayName="ButtonIcon";function qx(t){const{label:e,placement:n,spacing:r="0.5rem",children:s=K.jsx(Uf,{color:"currentColor",width:"1em",height:"1em"}),className:o,__css:i,...a}=t,l=Lt("chakra-button__spinner",o),c=n==="start"?"marginEnd":"marginStart",d=J.useMemo(()=>({display:"flex",alignItems:"center",position:e?"relative":"absolute",[c]:e?r:0,fontSize:"1em",lineHeight:"normal",...i}),[i,e,c,r]);return K.jsx(it.div,{className:l,...a,__css:d,children:s})}qx.displayName="ButtonSpinner";function F9(t){const[e,n]=J.useState(!t);return{ref:J.useCallback(o=>{o&&n(o.tagName==="BUTTON")},[]),type:e?"button":void 0}}const bd=lt((t,e)=>{const n=O9(),r=Sl("Button",{...n,...t}),{isDisabled:s=n==null?void 0:n.isDisabled,isLoading:o,isActive:i,children:a,leftIcon:l,rightIcon:c,loadingText:d,iconSpacing:f="0.5rem",type:p,spinner:g,spinnerPlacement:y="start",className:x,as:w,shouldWrapChildren:S,...$}=Ir(t),I=J.useMemo(()=>{const F={...r==null?void 0:r._focus,zIndex:1};return{display:"inline-flex",appearance:"none",alignItems:"center",justifyContent:"center",userSelect:"none",position:"relative",whiteSpace:"nowrap",verticalAlign:"middle",outline:"none",...r,...!!n&&{_focus:F}}},[r,n]),{ref:R,type:_}=F9(w),O={rightIcon:c,leftIcon:l,iconSpacing:f,children:a,shouldWrapChildren:S};return K.jsxs(it.button,{disabled:s||o,ref:_L(e,R),as:w,type:p??_,"data-active":ii(i),"data-loading":ii(o),__css:I,className:Lt("chakra-button",x),...$,children:[o&&y==="start"&&K.jsx(qx,{className:"chakra-button__spinner--start",label:d,placement:"start",spacing:f,children:g}),o?d||K.jsx(it.span,{opacity:0,children:K.jsx(oI,{...O})}):K.jsx(oI,{...O}),o&&y==="end"&&K.jsx(qx,{className:"chakra-button__spinner--end",label:d,placement:"end",spacing:f,children:g})]})});bd.displayName="Button";function oI(t){const{leftIcon:e,rightIcon:n,children:r,iconSpacing:s,shouldWrapChildren:o}=t;return o?K.jsxs("span",{style:{display:"contents"},children:[e&&K.jsx(Ph,{marginEnd:s,children:e}),r,n&&K.jsx(Ph,{marginStart:s,children:n})]}):K.jsxs(K.Fragment,{children:[e&&K.jsx(Ph,{marginEnd:s,children:e}),r,n&&K.jsx(Ph,{marginStart:s,children:n})]})}const[L9,fP]=e8("Card"),z9=lt(function(e,n){const{className:r,children:s,direction:o="column",justify:i,align:a,...l}=Ir(e),c=ba("Card",e);return K.jsx(it.div,{ref:n,className:Lt("chakra-card",r),__css:{display:"flex",flexDirection:o,justifyContent:i,alignItems:a,position:"relative",minWidth:0,wordWrap:"break-word",...c.container},...l,children:K.jsx(L9,{value:c,children:s})})}),B9=lt(function(e,n){const{className:r,...s}=e,o=fP();return K.jsx(it.div,{ref:n,className:Lt("chakra-card__body",r),__css:o.body,...s})}),M9=lt(function(e,n){const{className:r,...s}=e,o=fP();return K.jsx(it.div,{ref:n,className:Lt("chakra-card__header",r),__css:o.header,...s})}),pP=it("div",{baseStyle:{display:"flex",alignItems:"center",justifyContent:"center"}});pP.displayName="Center";const V9={horizontal:{insetStart:"50%",transform:"translateX(-50%)"},vertical:{top:"50%",transform:"translateY(-50%)"},both:{insetStart:"50%",top:"50%",transform:"translate(-50%, -50%)"}};lt(function(e,n){const{axis:r="both",...s}=e;return K.jsx(it.div,{ref:n,__css:V9[r],...s,position:"absolute"})});const[W9,mP]=Hr({name:"FormControlStylesContext",errorMessage:`useFormControlStyles returned is 'undefined'. Seems you forgot to wrap the components in "<FormControl />" `}),[U9,wd]=Hr({strict:!1,name:"FormControlContext"});function j9(t){const{id:e,isRequired:n,isInvalid:r,isDisabled:s,isReadOnly:o,...i}=t,a=J.useId(),l=e||`field-${a}`,c=`${l}-label`,d=`${l}-feedback`,f=`${l}-helptext`,[p,g]=J.useState(!1),[y,x]=J.useState(!1),[w,S]=J.useState(!1),$=J.useCallback((F={},B=null)=>({id:f,...F,ref:gx(B,M=>{M&&x(!0)})}),[f]),I=J.useCallback((F={},B=null)=>({...F,ref:B,"data-focus":ii(w),"data-disabled":ii(s),"data-invalid":ii(r),"data-readonly":ii(o),id:F.id!==void 0?F.id:c,htmlFor:F.htmlFor!==void 0?F.htmlFor:l}),[l,s,w,r,o,c]),R=J.useCallback((F={},B=null)=>({id:d,...F,ref:gx(B,M=>{M&&g(!0)}),"aria-live":"polite"}),[d]),_=J.useCallback((F={},B=null)=>({...F,...i,ref:B,role:"group","data-focus":ii(w),"data-disabled":ii(s),"data-invalid":ii(r),"data-readonly":ii(o)}),[i,s,w,r,o]),O=J.useCallback((F={},B=null)=>({...F,ref:B,role:"presentation","aria-hidden":!0,children:F.children||"*"}),[]);return{isRequired:!!n,isInvalid:!!r,isReadOnly:!!o,isDisabled:!!s,isFocused:!!w,onFocus:()=>S(!0),onBlur:()=>S(!1),hasFeedbackText:p,setHasFeedbackText:g,hasHelpText:y,setHasHelpText:x,id:l,labelId:c,feedbackId:d,helpTextId:f,htmlProps:i,getHelpTextProps:$,getErrorMessageProps:R,getRootProps:_,getLabelProps:I,getRequiredIndicatorProps:O}}const gP=lt(function(e,n){const r=ba("Form",e),s=Ir(e),{getRootProps:o,htmlProps:i,...a}=j9(s),l=Lt("chakra-form-control",e.className);return K.jsx(U9,{value:a,children:K.jsx(W9,{value:r,children:K.jsx(it.div,{...o({},n),className:l,__css:r.container})})})});gP.displayName="FormControl";const G9=lt(function(e,n){const r=wd(),s=mP(),o=Lt("chakra-form__helper-text",e.className);return K.jsx(it.div,{...r==null?void 0:r.getHelpTextProps(e,n),__css:s.helperText,className:o})});G9.displayName="FormHelperText";function H9(t){const{isDisabled:e,isInvalid:n,isReadOnly:r,isRequired:s,...o}=K9(t);return{...o,disabled:e,readOnly:r,required:s,"aria-invalid":i1(n),"aria-required":i1(s),"aria-readonly":i1(r)}}function K9(t){const e=wd(),{id:n,disabled:r,readOnly:s,required:o,isRequired:i,isInvalid:a,isReadOnly:l,isDisabled:c,onFocus:d,onBlur:f,...p}=t,g=t["aria-describedby"]?[t["aria-describedby"]]:[];return e!=null&&e.hasFeedbackText&&(e!=null&&e.isInvalid)&&g.push(e.feedbackId),e!=null&&e.hasHelpText&&g.push(e.helpTextId),{...p,"aria-describedby":g.join(" ")||void 0,id:n??(e==null?void 0:e.id),isDisabled:r??c??(e==null?void 0:e.isDisabled),isReadOnly:s??l??(e==null?void 0:e.isReadOnly),isRequired:o??i??(e==null?void 0:e.isRequired),isInvalid:a??(e==null?void 0:e.isInvalid),onFocus:n3(e==null?void 0:e.onFocus,d),onBlur:n3(e==null?void 0:e.onBlur,f)}}const jf=lt(function(e,n){const{className:r,centerContent:s,...o}=Ir(e),i=Sl("Container",e);return K.jsx(it.div,{ref:n,className:Lt("chakra-container",r),...o,__css:{...i,...s&&{display:"flex",flexDirection:"column",alignItems:"center"}}})});jf.displayName="Container";function Ah(t){return typeof t=="function"}function X9(...t){return e=>t.reduce((n,r)=>r(n),e)}const q9=t=>function(...n){let r=[...n],s=n[n.length-1];return XW(s)&&r.length>1?r=r.slice(0,r.length-1):s=t,X9(...r.map(o=>i=>Ah(o)?o(i):Q9(i,o)))(s)},Y9=q9(oR);function Q9(...t){return so({},...t,yP)}function yP(t,e,n,r){if((Ah(t)||Ah(e))&&Object.prototype.hasOwnProperty.call(r,n))return(...s)=>{const o=Ah(t)?t(...s):t,i=Ah(e)?e(...s):e;return so({},o,i,yP)};if(Vr(t)&&px(e)||px(t)&&Vr(e))return e}const[Z9,J9]=Hr({name:"FormErrorStylesContext",errorMessage:`useFormErrorStyles returned is 'undefined'. Seems you forgot to wrap the components in "<FormError />" `}),xP=lt((t,e)=>{const n=ba("FormError",t),r=Ir(t),s=wd();return s!=null&&s.isInvalid?K.jsx(Z9,{value:n,children:K.jsx(it.div,{...s==null?void 0:s.getErrorMessageProps(r,e),className:Lt("chakra-form__error-message",t.className),__css:{display:"flex",alignItems:"center",...n.text}})}):null});xP.displayName="FormErrorMessage";const eK=lt((t,e)=>{const n=J9(),r=wd();if(!(r!=null&&r.isInvalid))return null;const s=Lt("chakra-form__error-icon",t.className);return K.jsx(wa,{ref:e,"aria-hidden":!0,...t,__css:n.icon,className:s,children:K.jsx("path",{fill:"currentColor",d:"M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"})})});eK.displayName="FormErrorIcon";const vP=lt(function(e,n){const r=Sl("FormLabel",e),s=Ir(e),{className:o,children:i,requiredIndicator:a=K.jsx(bP,{}),optionalIndicator:l=null,...c}=s,d=wd(),f=(d==null?void 0:d.getLabelProps(c,n))??{ref:n,...c};return K.jsxs(it.label,{...f,className:Lt("chakra-form__label",s.className),__css:{display:"block",textAlign:"start",...r},children:[i,d!=null&&d.isRequired?a:l]})});vP.displayName="FormLabel";const bP=lt(function(e,n){const r=wd(),s=mP();if(!(r!=null&&r.isRequired))return null;const o=Lt("chakra-form__required-indicator",e.className);return K.jsx(it.span,{...r==null?void 0:r.getRequiredIndicatorProps(e,n),__css:s.requiredIndicator,className:o})});bP.displayName="RequiredIndicator";const wP=lt(function(e,n){const{templateAreas:r,gap:s,rowGap:o,columnGap:i,column:a,row:l,autoFlow:c,autoRows:d,templateRows:f,autoColumns:p,templateColumns:g,...y}=e,x={display:"grid",gridTemplateAreas:r,gridGap:s,gridRowGap:o,gridColumnGap:i,gridAutoColumns:p,gridColumn:a,gridRow:l,gridAutoFlow:c,gridAutoRows:d,gridTemplateRows:f,gridTemplateColumns:g};return K.jsx(it.div,{ref:n,__css:x,...y})});wP.displayName="Grid";const SP=lt(function(e,n){const{columns:r,spacingX:s,spacingY:o,spacing:i,minChildWidth:a,...l}=e,c=tP(),d=a?nK(a,c):rK(r);return K.jsx(wP,{ref:n,gap:i,columnGap:s,rowGap:o,templateColumns:d,...l})});SP.displayName="SimpleGrid";function tK(t){return typeof t=="number"?`${t}px`:t}function nK(t,e){return Hv(t,n=>{const r=c9("sizes",n,tK(n))(e);return n===null?null:`repeat(auto-fit, minmax(${r}, 1fr))`})}function rK(t){return Hv(t,e=>e===null?null:`repeat(${e}, minmax(0, 1fr))`)}const Yx=lt(function(e,n){const{htmlWidth:r,htmlHeight:s,alt:o,...i}=e;return K.jsx("img",{width:r,height:s,ref:n,alt:o,...i})});Yx.displayName="NativeImage";const CP=lt(function(e,n){const{fallbackSrc:r,fallback:s,src:o,srcSet:i,align:a,fit:l,loading:c,ignoreFallback:d,crossOrigin:f,fallbackStrategy:p="beforeLoadOrError",referrerPolicy:g,...y}=e,x=r!==void 0||s!==void 0,w=c!=null||d||!x,S=A9({...e,crossOrigin:f,ignoreFallback:w}),$=D9(S,p),I={ref:n,objectFit:l,objectPosition:a,...w?y:Gv(y,["onError","onLoad"])};return $?s||K.jsx(it.img,{as:Yx,className:"chakra-image__placeholder",src:r,...I}):K.jsx(it.img,{as:Yx,src:o,srcSet:i,crossOrigin:f,loading:c,referrerPolicy:g,className:"chakra-image",...I})});CP.displayName="Image";const qb=lt(function(e,n){const{htmlSize:r,...s}=e,o=ba("Input",s),i=Ir(s),a=H9(i),l=Lt("chakra-input",e.className);return K.jsx(it.input,{size:r,...a,__css:o.field,ref:n,className:l})});qb.displayName="Input";qb.id="Input";const[sK,oK]=Hr({name:"InputGroupStylesContext",errorMessage:`useInputGroupStyles returned is 'undefined'. Seems you forgot to wrap the components in "<InputGroup />" `}),$P=lt(function(e,n){const r=ba("Input",e),{children:s,className:o,...i}=Ir(e),a=Lt("chakra-input__group",o),l={},c=jv(s),d=r.field;c.forEach(p=>{r&&(d&&p.type.id==="InputLeftElement"&&(l.paddingStart=d.height??d.h),d&&p.type.id==="InputRightElement"&&(l.paddingEnd=d.height??d.h),p.type.id==="InputRightAddon"&&(l.borderEndRadius=0),p.type.id==="InputLeftAddon"&&(l.borderStartRadius=0))});const f=c.map(p=>{var y,x;const g=Vg({size:((y=p.props)==null?void 0:y.size)||e.size,variant:((x=p.props)==null?void 0:x.variant)||e.variant});return p.type.id!=="Input"?J.cloneElement(p,g):J.cloneElement(p,Object.assign(g,l,p.props))});return K.jsx(it.div,{className:a,ref:n,__css:{width:"100%",display:"flex",position:"relative",isolation:"isolate",...r.group},"data-group":!0,...i,children:K.jsx(sK,{value:r,children:f})})});$P.displayName="InputGroup";const iK={left:{marginEnd:"-1px",borderEndRadius:0,borderEndColor:"transparent"},right:{marginStart:"-1px",borderStartRadius:0,borderStartColor:"transparent"}},aK=it("div",{baseStyle:{flex:"0 0 auto",width:"auto",display:"flex",alignItems:"center",whiteSpace:"nowrap"}}),Yb=lt(function(e,n){const{placement:r="left",...s}=e,o=iK[r]??{},i=oK();return K.jsx(aK,{ref:n,...s,__css:{...i.addon,...o}})});Yb.displayName="InputAddon";const kP=lt(function(e,n){return K.jsx(Yb,{ref:n,placement:"left",...e,className:Lt("chakra-input__left-addon",e.className)})});kP.displayName="InputLeftAddon";kP.id="InputLeftAddon";const Qb=lt(function(e,n){return K.jsx(Yb,{ref:n,placement:"right",...e,className:Lt("chakra-input__right-addon",e.className)})});Qb.displayName="InputRightAddon";Qb.id="InputRightAddon";const[lK,TP]=Hr({name:"ListStylesContext",errorMessage:`useListStyles returned is 'undefined'. Seems you forgot to wrap the components in "<List />" `}),ey=lt(function(e,n){const r=ba("List",e),{children:s,styleType:o="none",stylePosition:i,spacing:a,...l}=Ir(e),c=jv(s),f=a?{["& > *:not(style) ~ *:not(style)"]:{mt:a}}:{};return K.jsx(lK,{value:r,children:K.jsx(it.ul,{ref:n,listStyleType:o,listStylePosition:i,role:"list",__css:{...r.container,...f},...l,children:c})})});ey.displayName="List";const uK=lt((t,e)=>{const{as:n,...r}=t;return K.jsx(ey,{ref:e,as:"ol",styleType:"decimal",marginStart:"1em",...r})});uK.displayName="OrderedList";const cK=lt(function(e,n){const{as:r,...s}=e;return K.jsx(ey,{ref:n,as:"ul",styleType:"initial",marginStart:"1em",...s})});cK.displayName="UnorderedList";const IP=lt(function(e,n){const r=TP();return K.jsx(it.li,{ref:n,...e,__css:r.item})});IP.displayName="ListItem";const au=lt(function(e,n){const r=TP();return K.jsx(wa,{ref:n,role:"presentation",...e,__css:r.icon})});au.displayName="ListIcon";const dK={exit:({reverse:t,initialScale:e,transition:n,transitionEnd:r,delay:s})=>({opacity:0,...t?{scale:e,transitionEnd:r==null?void 0:r.exit}:{transitionEnd:{scale:e,...r==null?void 0:r.exit}},transition:(n==null?void 0:n.exit)??pg.exit(fg.exit,s)}),enter:({transitionEnd:t,transition:e,delay:n})=>({opacity:1,scale:1,transition:(e==null?void 0:e.enter)??pg.enter(fg.enter,n),transitionEnd:t==null?void 0:t.enter})},hK={initial:"exit",animate:"enter",exit:"exit",variants:dK},NP=J.forwardRef(function(e,n){const{unmountOnExit:r,in:s,reverse:o=!0,initialScale:i=.95,className:a,transition:l,transitionEnd:c,delay:d,animatePresenceProps:f,...p}=e,g=r?s&&r:!0,y=s||r?"enter":"exit",x={initialScale:i,reverse:o,transition:l,transitionEnd:c,delay:d};return K.jsx(pb,{...f,custom:x,children:g&&K.jsx(Wf.div,{ref:n,className:Lt("chakra-offset-slide",a),...hK,animate:y,custom:x,...p})})});NP.displayName="ScaleFade";const fK={enter:({transition:t,transitionEnd:e,delay:n}={})=>({opacity:1,transition:(t==null?void 0:t.enter)??pg.enter(fg.enter,n),transitionEnd:e==null?void 0:e.enter}),exit:({transition:t,transitionEnd:e,delay:n}={})=>({opacity:0,transition:(t==null?void 0:t.exit)??pg.exit(fg.exit,n),transitionEnd:e==null?void 0:e.exit})},pK={initial:"exit",animate:"enter",exit:"exit",variants:fK},EP=J.forwardRef(function(e,n){const{unmountOnExit:r,in:s,className:o,transition:i,transitionEnd:a,delay:l,animatePresenceProps:c,...d}=e,f=s||r?"enter":"exit",p=r?s&&r:!0,g={transition:i,transitionEnd:a,delay:l};return K.jsx(pb,{...c,custom:g,children:p&&K.jsx(Wf.div,{ref:n,className:Lt("chakra-fade",o),custom:g,...pK,animate:f,...d})})});EP.displayName="Fade";function mK(t,e,n){return(t-e)*100/(n-e)}Ff({"0%":{strokeDasharray:"1, 400",strokeDashoffset:"0"},"50%":{strokeDasharray:"400, 400",strokeDashoffset:"-100"},"100%":{strokeDasharray:"400, 400",strokeDashoffset:"-260"}});Ff({"0%":{transform:"rotate(0deg)"},"100%":{transform:"rotate(360deg)"}});const gK=Ff({"0%":{left:"-40%"},"100%":{left:"100%"}}),yK=Ff({from:{backgroundPosition:"1rem 0"},to:{backgroundPosition:"0 0"}});function xK(t){const{value:e=0,min:n,max:r,valueText:s,getValueText:o,isIndeterminate:i,role:a="progressbar"}=t,l=mK(e,n,r);return{bind:{"data-indeterminate":i?"":void 0,"aria-valuemax":r,"aria-valuemin":n,"aria-valuenow":i?void 0:e,"aria-valuetext":(()=>{if(e!=null)return typeof o=="function"?o(e,l):s})(),role:a},percent:l,value:e}}const[vK,bK]=Hr({name:"ProgressStylesContext",errorMessage:`useProgressStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Progress />" `}),wK=lt((t,e)=>{const{min:n,max:r,value:s,isIndeterminate:o,role:i,...a}=t,l=xK({value:s,min:n,max:r,isIndeterminate:o,role:i}),d={height:"100%",...bK().filledTrack};return K.jsx(it.div,{ref:e,style:{width:`${l.percent}%`,...a.style},...l.bind,...a,__css:d})}),RP=lt((t,e)=>{var F;const{value:n,min:r=0,max:s=100,hasStripe:o,isAnimated:i,children:a,borderRadius:l,isIndeterminate:c,"aria-label":d,"aria-labelledby":f,"aria-valuetext":p,title:g,role:y,...x}=Ir(t),w=ba("Progress",t),S=l??((F=w.track)==null?void 0:F.borderRadius),$={animation:`${yK} 1s linear infinite`},_={...!c&&o&&i&&$,...c&&{position:"absolute",willChange:"left",minWidth:"50%",animation:`${gK} 1s ease infinite normal none running`}},O={overflow:"hidden",position:"relative",...w.track};return K.jsx(it.div,{ref:e,borderRadius:S,__css:O,...x,children:K.jsxs(vK,{value:w,children:[K.jsx(wK,{"aria-label":d,"aria-labelledby":f,"aria-valuetext":p,min:r,max:s,value:n,isIndeterminate:c,css:_,borderRadius:S,title:g,role:y}),a]})})});RP.displayName="Progress";const _P=t=>K.jsx(it.div,{className:"chakra-stack__item",...t,__css:{display:"inline-block",flex:"0 0 auto",minWidth:0,...t.__css}});_P.displayName="StackItem";function SK(t){const{spacing:e,direction:n}=t,r={column:{my:e,mx:0,borderLeftWidth:0,borderBottomWidth:"1px"},"column-reverse":{my:e,mx:0,borderLeftWidth:0,borderBottomWidth:"1px"},row:{mx:e,my:0,borderLeftWidth:"1px",borderBottomWidth:0},"row-reverse":{mx:e,my:0,borderLeftWidth:"1px",borderBottomWidth:0}};return{"&":Hv(n,s=>r[s])}}const PP=lt((t,e)=>{const{isInline:n,direction:r,align:s,justify:o,spacing:i="0.5rem",wrap:a,children:l,divider:c,className:d,shouldWrapChildren:f,...p}=t,g=n?"row":r??"column",y=J.useMemo(()=>SK({spacing:i,direction:g}),[i,g]),x=!!c,w=!f&&!x,S=J.useMemo(()=>{const I=jv(l);return w?I:I.map((R,_)=>{const O=typeof R.key<"u"?R.key:_,F=_+1===I.length,M=f?K.jsx(_P,{children:R},O):R;if(!x)return M;const V=J.cloneElement(c,{__css:y}),P=F?null:V;return K.jsxs(J.Fragment,{children:[M,P]},O)})},[c,y,x,w,f,l]),$=Lt("chakra-stack",d);return K.jsx(it.div,{ref:e,display:"flex",alignItems:s,justifyContent:o,flexDirection:g,flexWrap:a,gap:x?void 0:i,className:$,...p,children:S})});PP.displayName="Stack";const ia=lt((t,e)=>K.jsx(PP,{align:"center",...t,direction:"column",ref:e}));ia.displayName="VStack";const[CK,AP]=Hr({name:"StatStylesContext",errorMessage:`useStatStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Stat />" `}),DP=lt(function(e,n){const r=ba("Stat",e),s={position:"relative",flex:"1 1 0%",...r.container},{className:o,children:i,...a}=Ir(e);return K.jsx(CK,{value:r,children:K.jsx(it.div,{ref:n,...a,className:Lt("chakra-stat",o),__css:s,children:K.jsx("dl",{children:i})})})});DP.displayName="Stat";const OP=lt(function(e,n){const r=AP();return K.jsx(it.dt,{ref:n,...e,className:Lt("chakra-stat__label",e.className),__css:r.label})});OP.displayName="StatLabel";const FP=lt(function(e,n){const r=AP();return K.jsx(it.dd,{ref:n,...e,className:Lt("chakra-stat__number",e.className),__css:{...r.number,fontFeatureSettings:"pnum",fontVariantNumeric:"proportional-nums"}})});FP.displayName="StatNumber";function $K(t,e){const n=t??"bottom",s={"top-start":{ltr:"top-left",rtl:"top-right"},"top-end":{ltr:"top-right",rtl:"top-left"},"bottom-start":{ltr:"bottom-left",rtl:"bottom-right"},"bottom-end":{ltr:"bottom-right",rtl:"bottom-left"}}[n];return(s==null?void 0:s[e])??n}function kK(t,e){const n=s=>({...e,...s,position:$K((s==null?void 0:s.position)??(e==null?void 0:e.position),t)}),r=s=>{const o=n(s),i=lP(o);return di.notify(i,o)};return r.update=(s,o)=>{di.update(s,n(o))},r.promise=(s,o)=>{const i=r({...o.loading,status:"loading",duration:null});s.then(a=>r.update(i,{status:"success",duration:5e3,...ro(o.success,a)})).catch(a=>r.update(i,{status:"error",duration:5e3,...ro(o.error,a)}))},r.closeAll=di.closeAll,r.close=di.close,r.isActive=di.isActive,r}function LP(t){const{theme:e}=nP(),n=E9();return J.useMemo(()=>kK(e.direction,{...n,...t}),[t,e.direction,n])}const Sd=lt(function(e,n){const r=Sl("Heading",e),{className:s,...o}=Ir(e);return K.jsx(it.h2,{ref:n,className:Lt("chakra-heading",e.className),...o,__css:r})});Sd.displayName="Heading";const wr=lt(function(e,n){const r=Sl("Text",e),{className:s,align:o,decoration:i,casing:a,...l}=Ir(e),c=Vg({textAlign:e.align,textDecoration:e.decoration,textTransform:e.casing});return K.jsx(it.p,{ref:n,className:Lt("chakra-text",e.className),...c,...l,__css:r})});wr.displayName="Text";function TK({onNavigate:t}){const e=()=>{console.log("Start button clicked! Navigating..."),t("INSTRUCTIONS")};return K.jsx(Ao,{textAlign:"center",p:8,minHeight:"80vh",display:"flex",alignItems:"center",justifyContent:"center",children:K.jsxs(ia,{spacing:6,children:[K.jsx(CP,{src:fL,alt:"TapFit Logo",boxSize:"100px"}),K.jsx(Sd,{as:"h1",size:"2xl",children:"Welcome to TapFit!"}),K.jsx(wr,{fontSize:"lg",maxWidth:"450px",color:"gray.600",children:"Get ready to capture your pose and see relevant measurements."}),K.jsx(bd,{colorScheme:"blue",size:"lg",onClick:e,children:"Start"})]})})}var zP={color:void 0,size:void 0,className:void 0,style:void 0,attr:void 0},iI=sa.createContext&&sa.createContext(zP),IK=["attr","size","title"];function NK(t,e){if(t==null)return{};var n=EK(t,e),r,s;if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(s=0;s<o.length;s++)r=o[s],!(e.indexOf(r)>=0)&&Object.prototype.propertyIsEnumerable.call(t,r)&&(n[r]=t[r])}return n}function EK(t,e){if(t==null)return{};var n={};for(var r in t)if(Object.prototype.hasOwnProperty.call(t,r)){if(e.indexOf(r)>=0)continue;n[r]=t[r]}return n}function mg(){return mg=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},mg.apply(this,arguments)}function aI(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter(function(s){return Object.getOwnPropertyDescriptor(t,s).enumerable})),n.push.apply(n,r)}return n}function gg(t){for(var e=1;e<arguments.length;e++){var n=arguments[e]!=null?arguments[e]:{};e%2?aI(Object(n),!0).forEach(function(r){RK(t,r,n[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):aI(Object(n)).forEach(function(r){Object.defineProperty(t,r,Object.getOwnPropertyDescriptor(n,r))})}return t}function RK(t,e,n){return e=_K(e),e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function _K(t){var e=PK(t,"string");return typeof e=="symbol"?e:e+""}function PK(t,e){if(typeof t!="object"||!t)return t;var n=t[Symbol.toPrimitive];if(n!==void 0){var r=n.call(t,e);if(typeof r!="object")return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return(e==="string"?String:Number)(t)}function BP(t){return t&&t.map((e,n)=>sa.createElement(e.tag,gg({key:n},e.attr),BP(e.child)))}function ho(t){return e=>sa.createElement(AK,mg({attr:gg({},t.attr)},e),BP(t.child))}function AK(t){var e=n=>{var{attr:r,size:s,title:o}=t,i=NK(t,IK),a=s||n.size||"1em",l;return n.className&&(l=n.className),t.className&&(l=(l?l+" ":"")+t.className),sa.createElement("svg",mg({stroke:"currentColor",fill:"currentColor",strokeWidth:"0"},n.attr,r,i,{className:l,style:gg(gg({color:t.color||n.color},n.style),t.style),height:a,width:a,xmlns:"http://www.w3.org/2000/svg"}),o&&sa.createElement("title",null,o),t.children)};return iI!==void 0?sa.createElement(iI.Consumer,null,n=>e(n)):e(zP)}function DK(t){return ho({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"48",d:"M244 400 100 256l144-144M120 256h292"},child:[]}]})(t)}function OK(t){return ho({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"48",d:"m268 112 144 144-144 144m124-144H100"},child:[]}]})(t)}function Qx(t){return ho({attr:{viewBox:"0 0 512 512"},child:[{tag:"circle",attr:{cx:"256",cy:"56",r:"40",fill:"none",strokeMiterlimit:"10",strokeWidth:"32"},child:[]},{tag:"path",attr:{fill:"none",strokeMiterlimit:"10",strokeWidth:"32",d:"m199.3 295.62-30.4 172.2a24 24 0 0 0 19.5 27.8 23.76 23.76 0 0 0 27.6-19.5l21-119.9v.2s5.2-32.5 17.5-32.5h3.1c12.5 0 17.5 32.5 17.5 32.5v-.1l21 119.9a23.92 23.92 0 1 0 47.1-8.4l-30.4-172.2-4.9-29.7c-2.9-18.1-4.2-47.6.5-59.7 4-10.4 14.13-14.2 23.2-14.2H424a24 24 0 0 0 0-48H88a24 24 0 0 0 0 48h92.5c9.23 0 19.2 3.8 23.2 14.2 4.7 12.1 3.4 41.6.5 59.7z"},child:[]}]})(t)}function FK(t){return ho({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"m350.54 148.68-26.62-42.06C318.31 100.08 310.62 96 302 96h-92c-8.62 0-16.31 4.08-21.92 10.62l-26.62 42.06C155.85 155.23 148.62 160 140 160H80a32 32 0 0 0-32 32v192a32 32 0 0 0 32 32h352a32 32 0 0 0 32-32V192a32 32 0 0 0-32-32h-59c-8.65 0-16.85-4.77-22.46-11.32z"},child:[]},{tag:"circle",attr:{cx:"256",cy:"272",r:"80",fill:"none",strokeMiterlimit:"10",strokeWidth:"32"},child:[]},{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M124 158v-22h-24v22"},child:[]}]})(t)}function LK(t){return ho({attr:{viewBox:"0 0 512 512"},child:[{tag:"circle",attr:{cx:"256",cy:"256",r:"192",fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32"},child:[]}]})(t)}function zK(t){return ho({attr:{viewBox:"0 0 512 512"},child:[{tag:"rect",attr:{width:"256",height:"480",x:"128",y:"16",fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",rx:"48",ry:"48"},child:[]},{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M176 16h24a8 8 0 0 1 8 8h0a16 16 0 0 0 16 16h64a16 16 0 0 0 16-16h0a8 8 0 0 1 8-8h24"},child:[]}]})(t)}function BK(t){return ho({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M304 96h112v112m-10.23-101.8L111.98 400.02M208 416H96V304"},child:[]}]})(t)}function MK(t){return ho({attr:{viewBox:"0 0 512 512"},child:[{tag:"rect",attr:{width:"416",height:"416",x:"48",y:"48",fill:"none",strokeLinejoin:"round",strokeWidth:"32",rx:"96"},child:[]},{tag:"path",attr:{fill:"none",strokeLinejoin:"round",strokeWidth:"32",d:"M388.94 151.56c-24.46-22.28-68.72-51.4-132.94-51.4s-108.48 29.12-132.94 51.4a34.66 34.66 0 0 0-3.06 48.08l33.32 39.21a26.07 26.07 0 0 0 33.6 5.21c15.92-9.83 40.91-21.64 69.1-21.64s53.18 11.81 69.1 21.64a26.07 26.07 0 0 0 33.6-5.21L392 199.64a34.66 34.66 0 0 0-3.06-48.08z"},child:[]}]})(t)}function VK(t){return ho({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M314.56 48s-22.78 8-58.56 8-58.56-8-58.56-8a31.94 31.94 0 0 0-10.57 1.8L32 104l16.63 88 48.88 5.52a24 24 0 0 1 21.29 24.58L112 464h288l-6.8-241.9a24 24 0 0 1 21.29-24.58l48.88-5.52L480 104 325.13 49.8a31.94 31.94 0 0 0-10.57-1.8zm18.75 4.66a80 80 0 0 1-154.62 0"},child:[]}]})(t)}function WK(t){return ho({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M416 448H96a32.09 32.09 0 0 1-32-32V96a32.09 32.09 0 0 1 32-32h320a32.09 32.09 0 0 1 32 32v320a32.09 32.09 0 0 1-32 32z"},child:[]}]})(t)}function UK(t){return ho({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"m304 48 112 112-112 112m94.87-112H96m112 304L96 352l112-112m-94 112h302"},child:[]}]})(t)}function jK(t){return ho({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M48 448 256 64l208 384H48z"},child:[]}]})(t)}const $c=Wf(IP);function GK({onNavigate:t}){const e=()=>{console.log("Next button clicked! Navigating to Height Input..."),t("HEIGHT_INPUT")},n={hidden:{opacity:0,y:10},visible:{opacity:1,y:0}};return K.jsx(jf,{maxW:"container.md",py:{base:8,md:12},bg:"gray.50",borderRadius:"md",boxShadow:"sm",children:K.jsxs(ia,{spacing:6,align:"stretch",children:[K.jsx(Sd,{as:"h1",size:"xl",textAlign:"center",color:"teal.600",children:"How to Use TapFit"}),K.jsx(wr,{textAlign:"center",fontSize:"lg",color:"gray.700",children:"Follow these steps for accurate results:"}),K.jsxs(ey,{spacing:5,px:{base:2,md:4},children:[" ",K.jsxs($c,{display:"flex",alignItems:"start",variants:n,initial:"hidden",animate:"visible",transition:{duration:.3,delay:.1},children:[K.jsx(au,{as:VK,color:"teal.500",w:6,h:6,mt:1,mr:2}),K.jsxs(Ao,{children:[" ",K.jsx(wr,{as:"span",fontWeight:"bold",color:"teal.700",children:"Preparation: "}),"Wear form-fitting clothing. Ensure good, even lighting without strong shadows. Find a clear space with a plain background if possible."]})]}),K.jsxs($c,{display:"flex",alignItems:"start",variants:n,initial:"hidden",animate:"visible",transition:{duration:.3,delay:.2},children:[K.jsx(au,{as:zK,color:"teal.500",w:6,h:6,mt:1,mr:2}),K.jsxs(Ao,{children:[K.jsx(wr,{as:"span",fontWeight:"bold",color:"teal.700",children:"Phone Placement: "}),"Place your phone upright on a stable surface (like a table or tripod) around waist height. Ensure the camera lens is clean."]})]}),K.jsxs($c,{display:"flex",alignItems:"start",variants:n,initial:"hidden",animate:"visible",transition:{duration:.3,delay:.3},children:[K.jsx(au,{as:BK,color:"teal.500",w:6,h:6,mt:1,mr:2}),K.jsxs(Ao,{children:[K.jsx(wr,{as:"span",fontWeight:"bold",color:"teal.700",children:"Distance: "}),"Stand far enough back so your entire body, from head to toe, is clearly visible within the camera frame."]})]}),K.jsxs($c,{display:"flex",alignItems:"start",variants:n,initial:"hidden",animate:"visible",transition:{duration:.3,delay:.4},children:[K.jsx(au,{as:Qx,color:"teal.500",w:6,h:6,mt:1,mr:2}),K.jsxs(Ao,{children:[K.jsx(wr,{as:"span",fontWeight:"bold",color:"teal.700",children:"Front Pose: "}),"Stand facing the camera directly. Keep your feet shoulder-width apart, arms relaxed at your sides (not touching your body), and look straight ahead. Hold still."]})]}),K.jsxs($c,{display:"flex",alignItems:"start",variants:n,initial:"hidden",animate:"visible",transition:{duration:.3,delay:.5},children:[K.jsx(au,{as:UK,color:"teal.500",w:6,h:6,mt:1,mr:2}),K.jsxs(Ao,{children:[K.jsx(wr,{as:"span",fontWeight:"bold",color:"teal.700",children:"Side Pose: "}),"Turn 90 degrees (either left or right, but be consistent if asked again). Stand straight with your feet together, arms relaxed at your sides, and look straight ahead. Hold still."]})]}),K.jsxs($c,{display:"flex",alignItems:"start",variants:n,initial:"hidden",animate:"visible",transition:{duration:.3,delay:.6},children:[K.jsx(au,{as:FK,color:"teal.500",w:6,h:6,mt:1,mr:2}),K.jsxs(Ao,{children:[K.jsx(wr,{as:"span",fontWeight:"bold",color:"teal.700",children:"Capture: "}),"The app will guide you to capture both poses. You may need to retake if the pose isn't clear or your full body isn't visible."]})]})]}),K.jsx(bd,{colorScheme:"green",size:"lg",onClick:e,alignSelf:"center",mt:4,_hover:{bg:"green.600",transform:"translateY(-2px)",boxShadow:"lg"},children:"Next"})]})})}const HK=Wf(Ao);function KK({onNavigate:t}){const[e,n]=J.useState(""),[r,s]=J.useState(""),o=LP(),i=c=>{n(c.target.value),r&&s("")},a=()=>{const c=parseFloat(e);if(!e||isNaN(c)){s("Please enter your height.");return}if(c<140||c>180){console.log(`Validation failed: ${c} is out of range (140-180)`),s("Height must be between 140 cm and 180 cm.");return}s(""),console.log("Height submitted:",c),localStorage.setItem("userHeight",c.toString()),o({title:"Height Saved.",description:`Your height is set to ${c} cm.`,status:"success",duration:3e3,isClosable:!0}),t("CAMERA")},l={hidden:{opacity:0,y:20},visible:{opacity:1,y:0,transition:{duration:.5}}};return K.jsx(jf,{maxW:"container.sm",py:{base:8,md:12},display:"flex",alignItems:"center",minHeight:"80vh",children:K.jsx(HK,{bg:"white",p:{base:6,md:8},boxShadow:"md",borderRadius:"lg",width:"100%",variants:l,initial:"hidden",animate:"visible",children:K.jsxs(ia,{spacing:5,align:"stretch",children:[" ",K.jsx(wa,{as:MK,boxSize:{base:"40px",md:"50px"},color:"blue.500",alignSelf:"center",mb:-1}),K.jsx(Sd,{as:"h1",size:"lg",textAlign:"center",children:"Enter Your Height"}),K.jsx(wr,{textAlign:"center",color:"gray.600",children:"Please enter your height in centimeters (cm). This is required for measurement analysis."}),K.jsxs(gP,{isInvalid:!!r,id:"height-input",children:[K.jsx(vP,{children:"Height"}),K.jsxs($P,{children:[K.jsx(qb,{type:"number",placeholder:"e.g., 165",value:e,onChange:i,min:"140",max:"180"}),K.jsx(Qb,{children:"cm"})]}),r&&K.jsx(xP,{children:r})]}),K.jsx(bd,{colorScheme:"blue",size:"lg",onClick:a,mt:4,rightIcon:K.jsx(OK,{}),children:"Next: Capture Pose"})]})})})}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XK=1e-7,qK=1e-4;class MP{constructor(e,n){this.backend=e,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,n){this.dataIdsCount++,this.data.set(e,n)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Zb{refCount(e){return ls("refCount")}incRef(e){return ls("incRef")}timerAvailable(){return!0}time(e){return ls("time")}read(e){return ls("read")}readSync(e){return ls("readSync")}readToGPU(e,n){return ls("readToGPU")}numDataIds(){return ls("numDataIds")}disposeData(e,n){return ls("disposeData")}write(e,n,r){return ls("write")}move(e,n,r,s,o){return ls("move")}createTensorFromGPUData(e,n,r){return ls("createTensorFromGPUData")}memory(){return ls("memory")}floatPrecision(){return ls("floatPrecision")}epsilon(){return this.floatPrecision()===32?XK:qK}dispose(){return ls("dispose")}}function ls(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yg(t,e,n){return Math.max(t,Math.min(e,n))}function Jb(t){return t%2===0?t:t+1}function bh(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function VP(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function z(t,e){if(!t)throw new Error(typeof e=="string"?e:e())}function ys(t,e,n=""){z(Vt(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function Cd(t){z(t!=null,()=>"The input to the tensor constructor must be a non-null value.")}function pe(t){if(t.length===0)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function lI(t){return t.length===0}function YK(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==null&&e[n]!==null&&t[n]!==e[n])return!1;return!0}function Vt(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function id(t){return t%1===0}function Zx(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function Yc(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function uI(t,e=s=>0,n,r){return new Promise((s,o)=>{let i=0;const a=()=>{if(t()){s();return}i++;const l=e(i);if(n!=null&&i>=n){o();return}r!=null?r(a,l):setTimeout(a,l)};a()})}function WP(t,e){let n=1,r=-1;for(let o=0;o<t.length;++o)if(t[o]>=0)n*=t[o];else if(t[o]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(t[o]<0)throw Error(`Shapes can not be < 0. Found ${t[o]} at dim ${o}`);if(r===-1){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(n===0)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const s=t.slice();return s[r]=e/n,s}function nn(t,e){const n=e.length;return t=t==null?e.map((r,s)=>s):[].concat(t),z(t.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),z(t.every(r=>id(r)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(r=>r<0?n+r:r)}function Cl(t,e){const n=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,o=e==null||s?null:nn(e,t).sort();let i=0;for(let a=0;a<t.length;++a){if(o!=null){if(o[i]===a&&t[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${t[a]}' is not 1`);(o[i]==null||o[i]>a)&&t[a]===1&&(n.push(t[a]),r.push(a)),o[i]<=a&&i++}t[a]!==1&&(n.push(t[a]),r.push(a))}return{newShape:n,keptDims:r}}function Si(t,e){return En(t,e)}function En(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else if(t==="string")n=new Array(e);else throw new Error(`Unknown data type ${t}`);return n}function QK(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function ZK(t){return t==="bool"||t==="complex64"||t==="float32"||t==="int32"||t==="string"}function UP(t,e){return!(e==="complex64"||e==="float32"&&t!=="complex64"||e==="int32"&&t!=="float32"&&t!=="complex64"||e==="bool"&&t==="bool")}function xg(t){if(t==="float32"||t==="int32")return 4;if(t==="complex64")return 8;if(t==="bool")return 1;throw new Error(`Unknown dtype ${t}`)}function JK(t){if(t==null)return 0;let e=0;return t.forEach(n=>e+=n.length),e}function Gf(t){return typeof t=="string"||t instanceof String}function eX(t){return typeof t=="boolean"}function tX(t){return typeof t=="number"}function $d(t){return Array.isArray(t)?$d(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":tX(t)?"float32":Gf(t)?"string":eX(t)?"bool":"float32"}function Jx(t){return!!(t&&t.constructor&&t.call&&t.apply)}function ev(t,e){for(let n=e;n<t;++n)if(t%n===0)return n;return t}function gn(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function jP(t,e,n,r=!1){const s=new Array;if(e.length===1){const o=e[0]*(r?2:1);for(let i=0;i<o;i++)s[i]=n[t+i]}else{const o=e[0],i=e.slice(1),a=i.reduce((l,c)=>l*c)*(r?2:1);for(let l=0;l<o;l++)s[l]=jP(t+l*a,i,n,r)}return s}function tv(t,e,n=!1){if(t.length===0)return e[0];const r=t.reduce((s,o)=>s*o)*(n?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return jP(0,t,e,n)}function V1(t,e){if(Array.isArray(t))return t;if(e==="float32")return t instanceof Float32Array?t:new Float32Array(t);if(e==="int32")return t instanceof Int32Array?t:new Int32Array(t);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(t));throw new Error(`Unknown dtype ${e}`)}function GP(t,e){const n=ha(t,e);for(let r=0;r<n.length;r++)n[r]=1;return n}function ha(t,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool")return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function Os(t){t.forEach(e=>{z(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function nv(t,e,n){if(e===0)return 0;if(e===1)return t[0];let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=n[s]*t[s];return r}function e2(t,e,n){if(e===0)return[];if(e===1)return[t];const r=new Array(e);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(t/n[s]),t-=r[s]*n[s];return r[r.length-1]=t,r}function Ru(t){return t&&t.then&&typeof t.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cI="tfjsflags";class nX{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=rX,this.populateURLFlags()}setPlatform(e,n){this.platform!=null&&(se().getBool("IS_TEST")||se().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=n}registerFlag(e,n,r){if(this.flagRegistry[e]={evaluationFn:n,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];se().getBool("IS_TEST")||se().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const n=this.evaluateFlag(e);if(Ru(n))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=n,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,n){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=n,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(n)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);cI in e&&e[cI].split(",").forEach(r=>{const[s,o]=r.split(":");this.urlFlags[s]=oX(s,o)})}}function rX(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(sX(e,r[0],r[1]),r.join("="))),e}function sX(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}function oX(t,e){const n=e.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:e}function se(){return HP}let HP=null;function iX(t){HP=t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let W1;function KP(){if(W1==null){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else if(typeof self<"u")t=self;else throw new Error("Could not find a global object");W1=t}return W1}function aX(){const t=KP();return t._tfGlobals==null&&(t._tfGlobals=new Map),t._tfGlobals}function t2(t,e){const n=aX();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const n2="Abs",r2="Acos",s2="Acosh",ty="Add",o2="AddN",i2="All",a2="Any",l2="ArgMax",u2="ArgMin",c2="Asin",d2="Asinh",h2="Atan",f2="Atanh",p2="Atan2",m2="AvgPool",XP="AvgPoolGrad",g2="AvgPool3D",qP="AvgPool3DGrad",y2="BatchMatMul",x2="BatchToSpaceND",v2="Bincount",YP="BitwiseAnd",b2="BroadcastArgs",ny="Cast",w2="Ceil",S2="ClipByValue",C2="Complex",$2="ComplexAbs",k2="Concat",T2="Conv2D",I2="Conv2DBackpropFilter",N2="Conv2DBackpropInput",E2="Conv3D",QP="Conv3DBackpropFilterV2",R2="Conv3DBackpropInputV2",_2="Cos",P2="Cosh",A2="Cumprod",D2="Cumsum",O2="CropAndResize",F2="DenseBincount",L2="DepthToSpace",z2="DepthwiseConv2dNative",B2="DepthwiseConv2dNativeBackpropFilter",M2="DepthwiseConv2dNativeBackpropInput",V2="Diag",W2="Dilation2D",lX="Dilation2DBackpropInput",uX="Dilation2DBackpropFilter",ZP="Draw",U2="RealDiv",j2="Einsum",G2="Elu",JP="EluGrad",H2="Erf",K2="Equal",X2="Exp",q2="ExpandDims",Y2="Expm1",Q2="FFT",Z2="Fill",J2="FlipLeftRight",ew="Floor",tw="FloorDiv",nw="FusedBatchNorm",rw="GatherV2",sw="GatherNd",ow="Greater",iw="GreaterEqual",ry="Identity",aw="IFFT",lw="Imag",uw="IsFinite",cw="IsInf",dw="IsNan",hw="LeakyRelu",fw="Less",pw="LessEqual",mw="LinSpace",gw="Log",yw="Log1p",xw="LogicalAnd",vw="LogicalNot",bw="LogicalOr",ww="LRN",eA="LRNGrad",Sw="Max",Cw="Maximum",$w="MaxPool",tA="MaxPoolGrad",kw="MaxPool3D",nA="MaxPool3DGrad",Tw="MaxPoolWithArgmax",Iw="Mean",Nw="Min",Ew="Minimum",Rw="MirrorPad",_w="Mod",Pw="Multinomial",Aw="Multiply",Dw="Neg",Ow="NotEqual",Fw="NonMaxSuppressionV3",rA="NonMaxSuppressionV4",Lw="NonMaxSuppressionV5",zw="OnesLike",Bw="OneHot",Mw="Pack",Vw="PadV2",Ww="Pow",Uw="Prelu",jw="Prod",sA="RaggedGather",oA="RaggedRange",iA="RaggedTensorToTensor",Gw="Range",Hw="Real",Kw="Reciprocal",Xw="Relu",qw="Reshape",Yw="ResizeNearestNeighbor",aA="ResizeNearestNeighborGrad",Qw="ResizeBilinear",lA="ResizeBilinearGrad",Zw="Relu6",Jw="Reverse",eS="Round",tS="Rsqrt",nS="ScatterNd",rS="TensorScatterUpdate",sS="SearchSorted",oS="Select",iS="Selu",aS="Slice",lS="Sin",uS="Sinh",cS="Sign",dS="Sigmoid",hS="Softplus",fS="Sqrt",pS="Sum",mS="SpaceToBatchND",gS="SplitV",yS="Softmax",uA="SparseFillEmptyRows",cA="SparseReshape",xS="SparseSegmentMean",vS="SparseSegmentSum",bS="SparseToDense",wS="SquaredDifference",dA="Square",hA="StaticRegexReplace",SS="StridedSlice",CS="StringNGrams",fA="StringSplit",pA="StringToHashBucketFast",$S="Sub",kS="Tan",TS="Tanh",sy="Tile",IS="TopK",NS="Transform",Yh="Transpose",mA="Unique",ES="Unpack",RS="UnsortedSegmentSum",_S="ZerosLike",PS="Step",vg="FromPixels",AS="RotateWithOffset",bg="_FusedMatMul",wg="FusedConv2D",Sg="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lo(...t){se().getBool("IS_TEST")||se().getBool("PROD")||console.warn(...t)}function cX(...t){se().getBool("IS_TEST")||se().getBool("PROD")||console.log(...t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cg=t2("kernelRegistry",()=>new Map),dX=t2("gradRegistry",()=>new Map);function $g(t,e){const n=yA(t,e);return Cg.get(n)}function dI(t){return dX.get(t)}function hI(t){const e=Cg.entries(),n=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[o,i]=s,[a]=o.split("_");a===t&&n.push(i)}return n}function gA(t){const{kernelName:e,backendName:n}=t,r=yA(e,n);Cg.has(r)&&Lo(`The kernel '${e}' for backend '${n}' is already registered`),Cg.set(r,t)}function yA(t,e){return`${e}_${t}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xA(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}var U1,fI;function hX(){if(fI)return U1;fI=1,U1=e;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(V,P,re){this.low=V|0,this.high=P|0,this.unsigned=!!re}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function n(V){return(V&&V.__isLong__)===!0}e.isLong=n;var r={},s={};function o(V,P){var re,ie,me;return P?(V>>>=0,(me=0<=V&&V<256)&&(ie=s[V],ie)?ie:(re=a(V,(V|0)<0?-1:0,!0),me&&(s[V]=re),re)):(V|=0,(me=-128<=V&&V<128)&&(ie=r[V],ie)?ie:(re=a(V,V<0?-1:0,!1),me&&(r[V]=re),re))}e.fromInt=o;function i(V,P){if(isNaN(V))return P?$:S;if(P){if(V<0)return $;if(V>=y)return F}else{if(V<=-9223372036854776e3)return B;if(V+1>=x)return O}return V<0?i(-V,P).neg():a(V%g|0,V/g|0,P)}e.fromNumber=i;function a(V,P,re){return new e(V,P,re)}e.fromBits=a;var l=Math.pow;function c(V,P,re){if(V.length===0)throw Error("empty string");if(V==="NaN"||V==="Infinity"||V==="+Infinity"||V==="-Infinity")return S;if(typeof P=="number"?(re=P,P=!1):P=!!P,re=re||10,re<2||36<re)throw RangeError("radix");var ie;if((ie=V.indexOf("-"))>0)throw Error("interior hyphen");if(ie===0)return c(V.substring(1),P,re).neg();for(var me=i(l(re,8)),ge=S,ve=0;ve<V.length;ve+=8){var $e=Math.min(8,V.length-ve),fe=parseInt(V.substring(ve,ve+$e),re);if($e<8){var xe=i(l(re,$e));ge=ge.mul(xe).add(i(fe))}else ge=ge.mul(me),ge=ge.add(i(fe))}return ge.unsigned=P,ge}e.fromString=c;function d(V,P){return typeof V=="number"?i(V,P):typeof V=="string"?c(V,P):a(V.low,V.high,typeof P=="boolean"?P:V.unsigned)}e.fromValue=d;var f=65536,p=1<<24,g=f*f,y=g*g,x=y/2,w=o(p),S=o(0);e.ZERO=S;var $=o(0,!0);e.UZERO=$;var I=o(1);e.ONE=I;var R=o(1,!0);e.UONE=R;var _=o(-1);e.NEG_ONE=_;var O=a(-1,2147483647,!1);e.MAX_VALUE=O;var F=a(-1,-1,!0);e.MAX_UNSIGNED_VALUE=F;var B=a(0,-2147483648,!1);e.MIN_VALUE=B;var M=e.prototype;return M.toInt=function(){return this.unsigned?this.low>>>0:this.low},M.toNumber=function(){return this.unsigned?(this.high>>>0)*g+(this.low>>>0):this.high*g+(this.low>>>0)},M.toString=function(P){if(P=P||10,P<2||36<P)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(B)){var re=i(P),ie=this.div(re),me=ie.mul(re).sub(this);return ie.toString(P)+me.toInt().toString(P)}else return"-"+this.neg().toString(P);for(var ge=i(l(P,6),this.unsigned),ve=this,$e="";;){var fe=ve.div(ge),xe=ve.sub(fe.mul(ge)).toInt()>>>0,ae=xe.toString(P);if(ve=fe,ve.isZero())return ae+$e;for(;ae.length<6;)ae="0"+ae;$e=""+ae+$e}},M.getHighBits=function(){return this.high},M.getHighBitsUnsigned=function(){return this.high>>>0},M.getLowBits=function(){return this.low},M.getLowBitsUnsigned=function(){return this.low>>>0},M.getNumBitsAbs=function(){if(this.isNegative())return this.eq(B)?64:this.neg().getNumBitsAbs();for(var P=this.high!=0?this.high:this.low,re=31;re>0&&(P&1<<re)==0;re--);return this.high!=0?re+33:re+1},M.isZero=function(){return this.high===0&&this.low===0},M.eqz=M.isZero,M.isNegative=function(){return!this.unsigned&&this.high<0},M.isPositive=function(){return this.unsigned||this.high>=0},M.isOdd=function(){return(this.low&1)===1},M.isEven=function(){return(this.low&1)===0},M.equals=function(P){return n(P)||(P=d(P)),this.unsigned!==P.unsigned&&this.high>>>31===1&&P.high>>>31===1?!1:this.high===P.high&&this.low===P.low},M.eq=M.equals,M.notEquals=function(P){return!this.eq(P)},M.neq=M.notEquals,M.ne=M.notEquals,M.lessThan=function(P){return this.comp(P)<0},M.lt=M.lessThan,M.lessThanOrEqual=function(P){return this.comp(P)<=0},M.lte=M.lessThanOrEqual,M.le=M.lessThanOrEqual,M.greaterThan=function(P){return this.comp(P)>0},M.gt=M.greaterThan,M.greaterThanOrEqual=function(P){return this.comp(P)>=0},M.gte=M.greaterThanOrEqual,M.ge=M.greaterThanOrEqual,M.compare=function(P){if(n(P)||(P=d(P)),this.eq(P))return 0;var re=this.isNegative(),ie=P.isNegative();return re&&!ie?-1:!re&&ie?1:this.unsigned?P.high>>>0>this.high>>>0||P.high===this.high&&P.low>>>0>this.low>>>0?-1:1:this.sub(P).isNegative()?-1:1},M.comp=M.compare,M.negate=function(){return!this.unsigned&&this.eq(B)?B:this.not().add(I)},M.neg=M.negate,M.add=function(P){n(P)||(P=d(P));var re=this.high>>>16,ie=this.high&65535,me=this.low>>>16,ge=this.low&65535,ve=P.high>>>16,$e=P.high&65535,fe=P.low>>>16,xe=P.low&65535,ae=0,q=0,ue=0,we=0;return we+=ge+xe,ue+=we>>>16,we&=65535,ue+=me+fe,q+=ue>>>16,ue&=65535,q+=ie+$e,ae+=q>>>16,q&=65535,ae+=re+ve,ae&=65535,a(ue<<16|we,ae<<16|q,this.unsigned)},M.subtract=function(P){return n(P)||(P=d(P)),this.add(P.neg())},M.sub=M.subtract,M.multiply=function(P){if(this.isZero())return S;if(n(P)||(P=d(P)),t){var re=t.mul(this.low,this.high,P.low,P.high);return a(re,t.get_high(),this.unsigned)}if(P.isZero())return S;if(this.eq(B))return P.isOdd()?B:S;if(P.eq(B))return this.isOdd()?B:S;if(this.isNegative())return P.isNegative()?this.neg().mul(P.neg()):this.neg().mul(P).neg();if(P.isNegative())return this.mul(P.neg()).neg();if(this.lt(w)&&P.lt(w))return i(this.toNumber()*P.toNumber(),this.unsigned);var ie=this.high>>>16,me=this.high&65535,ge=this.low>>>16,ve=this.low&65535,$e=P.high>>>16,fe=P.high&65535,xe=P.low>>>16,ae=P.low&65535,q=0,ue=0,we=0,Ge=0;return Ge+=ve*ae,we+=Ge>>>16,Ge&=65535,we+=ge*ae,ue+=we>>>16,we&=65535,we+=ve*xe,ue+=we>>>16,we&=65535,ue+=me*ae,q+=ue>>>16,ue&=65535,ue+=ge*xe,q+=ue>>>16,ue&=65535,ue+=ve*fe,q+=ue>>>16,ue&=65535,q+=ie*ae+me*xe+ge*fe+ve*$e,q&=65535,a(we<<16|Ge,q<<16|ue,this.unsigned)},M.mul=M.multiply,M.divide=function(P){if(n(P)||(P=d(P)),P.isZero())throw Error("division by zero");if(t){if(!this.unsigned&&this.high===-2147483648&&P.low===-1&&P.high===-1)return this;var re=(this.unsigned?t.div_u:t.div_s)(this.low,this.high,P.low,P.high);return a(re,t.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?$:S;var ie,me,ge;if(this.unsigned){if(P.unsigned||(P=P.toUnsigned()),P.gt(this))return $;if(P.gt(this.shru(1)))return R;ge=$}else{if(this.eq(B)){if(P.eq(I)||P.eq(_))return B;if(P.eq(B))return I;var ve=this.shr(1);return ie=ve.div(P).shl(1),ie.eq(S)?P.isNegative()?I:_:(me=this.sub(P.mul(ie)),ge=ie.add(me.div(P)),ge)}else if(P.eq(B))return this.unsigned?$:S;if(this.isNegative())return P.isNegative()?this.neg().div(P.neg()):this.neg().div(P).neg();if(P.isNegative())return this.div(P.neg()).neg();ge=S}for(me=this;me.gte(P);){ie=Math.max(1,Math.floor(me.toNumber()/P.toNumber()));for(var $e=Math.ceil(Math.log(ie)/Math.LN2),fe=$e<=48?1:l(2,$e-48),xe=i(ie),ae=xe.mul(P);ae.isNegative()||ae.gt(me);)ie-=fe,xe=i(ie,this.unsigned),ae=xe.mul(P);xe.isZero()&&(xe=I),ge=ge.add(xe),me=me.sub(ae)}return ge},M.div=M.divide,M.modulo=function(P){if(n(P)||(P=d(P)),t){var re=(this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,P.low,P.high);return a(re,t.get_high(),this.unsigned)}return this.sub(this.div(P).mul(P))},M.mod=M.modulo,M.rem=M.modulo,M.not=function(){return a(~this.low,~this.high,this.unsigned)},M.and=function(P){return n(P)||(P=d(P)),a(this.low&P.low,this.high&P.high,this.unsigned)},M.or=function(P){return n(P)||(P=d(P)),a(this.low|P.low,this.high|P.high,this.unsigned)},M.xor=function(P){return n(P)||(P=d(P)),a(this.low^P.low,this.high^P.high,this.unsigned)},M.shiftLeft=function(P){return n(P)&&(P=P.toInt()),(P&=63)===0?this:P<32?a(this.low<<P,this.high<<P|this.low>>>32-P,this.unsigned):a(0,this.low<<P-32,this.unsigned)},M.shl=M.shiftLeft,M.shiftRight=function(P){return n(P)&&(P=P.toInt()),(P&=63)===0?this:P<32?a(this.low>>>P|this.high<<32-P,this.high>>P,this.unsigned):a(this.high>>P-32,this.high>=0?0:-1,this.unsigned)},M.shr=M.shiftRight,M.shiftRightUnsigned=function(P){if(n(P)&&(P=P.toInt()),P&=63,P===0)return this;var re=this.high;if(P<32){var ie=this.low;return a(ie>>>P|re<<32-P,re>>>P,this.unsigned)}else return P===32?a(re,0,this.unsigned):a(re>>>P-32,0,this.unsigned)},M.shru=M.shiftRightUnsigned,M.shr_u=M.shiftRightUnsigned,M.toSigned=function(){return this.unsigned?a(this.low,this.high,!1):this},M.toUnsigned=function(){return this.unsigned?this:a(this.low,this.high,!0)},M.toBytes=function(P){return P?this.toBytesLE():this.toBytesBE()},M.toBytesLE=function(){var P=this.high,re=this.low;return[re&255,re>>>8&255,re>>>16&255,re>>>24,P&255,P>>>8&255,P>>>16&255,P>>>24]},M.toBytesBE=function(){var P=this.high,re=this.low;return[P>>>24,P>>>16&255,P>>>8&255,P&255,re>>>24,re>>>16&255,re>>>8&255,re&255]},e.fromBytes=function(P,re,ie){return ie?e.fromBytesLE(P,re):e.fromBytesBE(P,re)},e.fromBytesLE=function(P,re){return new e(P[0]|P[1]<<8|P[2]<<16|P[3]<<24,P[4]|P[5]<<8|P[6]<<16|P[7]<<24,re)},e.fromBytesBE=function(P,re){return new e(P[4]<<24|P[5]<<16|P[6]<<8|P[7],P[0]<<24|P[1]<<16|P[2]<<8|P[3],re)},U1}var vA=hX();const bA=Af(vA),fX=FE({__proto__:null,default:bA},[vA]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const du=bA||fX;function oy(t){return du.fromString(t,!0,16)}const wA=oy("c3a5c85c97cb3127"),lu=oy("b492b66fbe98f273"),Cr=oy("9ae16a3b2f90404f");function rv(t){return t.xor(t.shru(47))}function SA(t,e,n){const r=t.slice(e,e+n);return du.fromBytes(Array.from(r),!0,!0)}function Zt(t,e){return SA(t,e,8)}function pI(t,e){return SA(t,e,4)}function On(t,e){return e===0?t:t.shru(e).or(t.shl(64-e))}function dl(t,e,n=oy("9ddfea08eb382d69")){let r=t.xor(e).mul(n);r=r.xor(r.shru(47));let s=e.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function pX(t,e,n,r,s,o){s=s.add(t),o=On(o.add(s).add(r),21);const i=s;return s=s.add(e),s=s.add(n),o=o.add(On(s,44)),[s.add(r),o.add(i)]}function xm(t,e,n,r){return pX(Zt(t,e),Zt(t,e+8),Zt(t,e+16),Zt(t,e+24),n,r)}function mX(t,e=t.length){if(e>=8){const n=Cr.add(e*2),r=Zt(t,0).add(Cr),s=Zt(t,e-8),o=On(s,37).mul(n).add(r),i=On(r,25).add(s).mul(n);return dl(o,i,n)}if(e>=4){const n=Cr.add(e*2),r=pI(t,0);return dl(r.shl(3).add(e),pI(t,e-4),n)}if(e>0){const n=t[0],r=t[e>>1],s=t[e-1],o=n+(r<<8),i=e+(s<<2);return rv(Cr.mul(o).xor(wA.mul(i))).mul(Cr)}return Cr}function gX(t,e=t.length){const n=Cr.add(e*2),r=Zt(t,0).mul(lu),s=Zt(t,8),o=Zt(t,e-8).mul(n),i=Zt(t,e-16).mul(Cr);return dl(On(r.add(s),43).add(On(o,30)).add(i),r.add(On(s.add(Cr),18)).add(o),n)}function yX(t,e=t.length){const n=Cr.add(e*2),r=Zt(t,0).mul(Cr),s=Zt(t,8),o=Zt(t,e-8).mul(n),i=Zt(t,e-16).mul(Cr),a=On(r.add(s),43).add(On(o,30)).add(i),l=dl(a,r.add(On(s.add(Cr),18)).add(o),n),c=Zt(t,16).mul(n),d=Zt(t,24),f=a.add(Zt(t,e-32)).mul(n),p=l.add(Zt(t,e-24)).mul(n);return dl(On(c.add(d),43).add(On(f,30)).add(p),c.add(On(d.add(r),18)).add(f),n)}function xX(t,e=t.length){const n=du.fromNumber(81,!0);if(e<=32)return e<=16?mX(t,e):gX(t,e);if(e<=64)return yX(t,e);let r=n,s=n.mul(lu).add(113),o=rv(s.mul(Cr).add(113)).mul(Cr),i=[du.UZERO,du.UZERO],a=[du.UZERO,du.UZERO];r=r.mul(Cr).add(Zt(t,0));let l=0;const c=(e-1>>6)*64,d=c+(e-1&63)-63;do r=On(r.add(s).add(i[0]).add(Zt(t,l+8)),37).mul(lu),s=On(s.add(i[1]).add(Zt(t,l+48)),42).mul(lu),r=r.xor(a[1]),s=s.add(i[0]).add(Zt(t,l+40)),o=On(o.add(a[0]),33).mul(lu),i=xm(t,l,i[1].mul(lu),r.add(a[0])),a=xm(t,l+32,o.add(a[1]),s.add(Zt(t,l+16))),[o,r]=[r,o],l+=64;while(l!==c);const f=lu.add(o.and(255).shl(1));return l=d,a[0]=a[0].add(e-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),r=On(r.add(s).add(i[0]).add(Zt(t,l+8)),37).mul(f),s=On(s.add(i[1]).add(Zt(t,l+48)),42).mul(f),r=r.xor(a[1].mul(9)),s=s.add(i[0].mul(9).add(Zt(t,l+40))),o=On(o.add(a[0]),33).mul(f),i=xm(t,l,i[1].mul(f),r.add(a[0])),a=xm(t,l+32,o.add(a[1]),s.add(Zt(t,l+16))),[o,r]=[r,o],dl(dl(i[0],a[0],f).add(rv(s).mul(wA)).add(o),dl(i[1],a[1],f).add(r),f)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kd(t,e){return e==="string"?hl(t):iy([t],e)}function vX(t,e){return t instanceof Float32Array&&e==="float32"||t instanceof Int32Array&&e==="int32"||t instanceof Uint8Array&&e==="bool"}function iy(t,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=pa(t)),se().getBool("DEBUG")&&QK(t,e),vX(t,e))return t;if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool"){const n=new Uint8Array(t.length);for(let r=0;r<n.length;++r)Math.round(t[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${e}`)}function Po(){return se().platform.now()}function hl(t,e="utf-8"){return e=e||"utf-8",se().platform.encode(t,e)}function fa(t,e="utf-8"){return e=e||"utf-8",se().platform.decode(t,e)}function uo(t){return se().platform.isTypedArray!=null?se().platform.isTypedArray(t):xA(t)}function pa(t,e=[],n=!1){if(e==null&&(e=[]),typeof t=="boolean"||typeof t=="number"||typeof t=="string"||Ru(t)||t==null||uo(t)&&n)e.push(t);else if(Array.isArray(t)||uo(t))for(let r=0;r<t.length;++r)pa(t[r],e,n);else{let r=-1;for(const s of Object.keys(t))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)pa(t[s],e,n)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bX{constructor(e,n){this.backendTimer=e,this.logger=n,n==null&&(this.logger=new SX)}profileKernel(e,n,r){let s;const o=()=>{s=r()};let i;const a=Po();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(o);else{o();for(const c of s)c.dataSync();i=Promise.resolve({kernelMs:Po()-a})}if(se().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<s.length;c++){const d=s[c];d.data().then(f=>{wX(f,d.dtype,e)})}return{kernelName:e,outputs:s,inputs:n,timeMs:i.then(c=>c.kernelMs),extraInfo:i.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:n,outputs:r,timeMs:s,inputs:o,extraInfo:i}=e;r.forEach(a=>{Promise.all([a.data(),s,i]).then(l=>{this.logger.logKernelProfile(n,a,l[0],l[1],o,l[2])})})}}function wX(t,e,n){if(e!=="float32")return!1;for(let r=0;r<t.length;r++){const s=t[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${n}'`),!0}return!1}class SX{logKernelProfile(e,n,r,s,o,i){const a=typeof s=="number"?Yc(`${s}ms`,9):s.error,l=Yc(e,25),c=n.rank,d=n.size,f=Yc(n.shape.toString(),14);let p="";for(const g in o){const y=o[g];if(y!=null){const x=y.shape||n.shape,w=x.length;p+=`${g}: ${w}D ${w>0?x:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${f}	%c${d}	%c${p}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CX(t,e,n){const r={},s={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<t.length;l++){const c=t[l],d=c.inputs;for(const f in d){const p=d[f];let g=!1;for(let y=0;y<e.length;y++)if(r[p.id]){c.outputs.forEach(x=>r[x.id]=!0),g=!0,s[c.id]=!0;break}if(g)break}}const o={};o[n.id]=!0;const i={};for(let l=t.length-1;l>=0;l--){const c=t[l],d=c.inputs;for(let f=0;f<c.outputs.length;f++)if(o[c.outputs[f].id]){for(const p in d)o[d[p].id]=!0,i[c.id]=!0;break}}const a=[];for(let l=0;l<t.length;l++){const c=t[l];if(s[c.id]&&i[c.id]){const d={};for(const p in c.inputs){const g=c.inputs[p];r[g.id]&&(d[p]=g)}const f=Object.assign({},c);f.inputs=d,f.outputs=c.outputs,a.push(f)}}return a}function $X(t,e,n,r){for(let s=e.length-1;s>=0;s--){const o=e[s],i=[];if(o.outputs.forEach(l=>{const c=t[l.id];c!=null?i.push(c):i.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const a=o.gradient(i);for(const l in o.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=n(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const d=o.inputs[l];if(!Vt(c.shape,d.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${d.shape}'`);if(t[d.id]==null)t[d.id]=c;else{const f=t[d.id];t[d.id]=r(f,c),f.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mI=20,wh=3,j1=7;function kX(t,e,n,r){const s=gn(e),o=TX(t,e,n,s),i=e.length,a=jm(t,e,n,s,o),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function TX(t,e,n,r){const s=pe(e),o=r[r.length-1],i=new Array(o).fill(0),a=e.length,l=n==="complex64"?Oh(t):t;if(a>1)for(let c=0;c<s/o;c++){const d=c*o;for(let f=0;f<o;f++)i[f]=Math.max(i[f],Dh(l[d+f],0,n).length)}return i}function Dh(t,e,n){let r;return Array.isArray(t)?r=`${parseFloat(t[0].toFixed(j1))} + ${parseFloat(t[1].toFixed(j1))}j`:Gf(t)?r=`'${t}'`:n==="bool"?r=CA(t):r=parseFloat(t.toFixed(j1)).toString(),Yc(r,e)}function CA(t){return t===0?"false":"true"}function jm(t,e,n,r,s,o=!0){const i=n==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(n==="complex64"){const x=Oh(t);return[Dh(x[0],0,n)]}return n==="bool"?[CA(t[0])]:[t[0].toString()]}if(l===1){if(a>mI){const w=wh*i;let S=Array.from(t.slice(0,w)),$=Array.from(t.slice((a-wh)*i,a*i));return n==="complex64"&&(S=Oh(S),$=Oh($)),["["+S.map((I,R)=>Dh(I,s[R],n)).join(", ")+", ..., "+$.map((I,R)=>Dh(I,s[a-wh+R],n)).join(", ")+"]"]}return["["+(n==="complex64"?Oh(t):Array.from(t)).map((w,S)=>Dh(w,s[S],n)).join(", ")+"]"]}const c=e.slice(1),d=r.slice(1),f=r[0]*i,p=[];if(a>mI){for(let x=0;x<wh;x++){const w=x*f,S=w+f;p.push(...jm(t.slice(w,S),c,n,d,s,!1))}p.push("...");for(let x=a-wh;x<a;x++){const w=x*f,S=w+f;p.push(...jm(t.slice(w,S),c,n,d,s,x===a-1))}}else for(let x=0;x<a;x++){const w=x*f,S=w+f;p.push(...jm(t.slice(w,S),c,n,d,s,x===a-1))}const g=l===2?",":"";p[0]="["+(a>0?p[0]+g:"");for(let x=1;x<p.length-1;x++)p[x]=" "+p[x]+g;let y=`,
`;for(let x=2;x<l;x++)y+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(o?"":y),p}function Oh(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ad{constructor(e,n,r){if(this.dtype=n,this.shape=e.slice(),this.size=pe(e),r!=null){const s=r.length;z(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||En(n,this.size),this.strides=gn(e)}set(e,...n){n.length===0&&(n=[0]),z(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const r=this.locToIndex(n);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let n=0;for(const s of e){if(s<0||s>=this.shape[n]){const o=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(o)}n++}let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=this.strides[s]*e[s];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return n}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const n=new Array(this.shape.length);for(let r=0;r<n.length-1;++r)n[r]=Math.floor(e/this.strides[r]),e-=n[r]*this.strides[r];return n[n.length-1]=e,n}get rank(){return this.shape.length}toTensor(){return Do().makeTensor(this.values,this.shape,this.dtype)}}let Do=null,Ec=null;function IX(t){Do=t}function NX(t){Ec=t}class fn{constructor(e,n,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=n||"float32",this.size=pe(e),this.strides=gn(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Ec.buffer(this.shape,this.dtype,e)}bufferSync(){return Ec.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return tv(this.shape,e,this.dtype==="complex64")}arraySync(){return tv(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Do().read(this.dataId);if(this.dtype==="string"){const n=await e;try{return n.map(r=>fa(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Do().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Do().readSync(this.dataId);if(this.dtype==="string")try{return e.map(n=>fa(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Do().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Do().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Ec.print(this,e)}clone(){return this.throwIfDisposed(),Ec.clone(this)}toString(e=!1){const n=this.dataSync();return kX(n,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Ec.cast(this,e)}variable(e=!0,n,r){return this.throwIfDisposed(),Do().makeVariable(this,e,n,r)}}Object.defineProperty(fn,Symbol.hasInstance,{value:t=>!!t&&t.data!=null&&t.dataSync!=null&&t.throwIfDisposed!=null});function $A(){return t2("Tensor",()=>fn)}$A();class kg extends fn{constructor(e,n,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=n,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Vt(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Do().disposeTensor(this),this.dataId=e.dataId,Do().incRef(this,null)}dispose(){Do().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(kg,Symbol.hasInstance,{value:t=>t instanceof fn&&t.assign!=null&&t.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var gI;(function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"})(gI||(gI={}));var sv;(function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"})(sv||(sv={}));var ov;(function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"})(ov||(ov={}));var iv;(function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"})(iv||(iv={}));var av;(function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"})(av||(av={}));const EX={float32:iv,int32:sv,bool:ov,complex64:av};function jr(t,e){if(t==="string"||e==="string"){if(t==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return EX[t][e]}function ay(t){return jr(t,"int32")}function kA(t){return t!=null&&typeof t=="object"&&"texture"in t&&t.texture instanceof WebGLTexture}function TA(t){return typeof GPUBuffer<"u"&&t!=null&&typeof t=="object"&&"buffer"in t&&t.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yn(t,e){if(t.dtype===e.dtype)return[t,e];const n=jr(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function RX(t,e){z(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function IA(t){const e=[];return NA(t,e,new Set),e}function NA(t,e,n){if(t==null)return;if(t instanceof fn){e.push(t);return}if(!_X(t))return;const r=t;for(const s in r){const o=r[s];n.has(o)||(n.add(o),NA(o,e,n))}}function _X(t){return Array.isArray(t)||typeof t=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G1(t){return t.kernelName!=null}class yI{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class ld{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new yI}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:n}=this.initializeBackend(e);if(n)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,n,r=1){return e in this.registryFactory?(Lo(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:n,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:n,asyncInit:r}=this.initializeBackend(e);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new bX(this.backendInstance),!0}setupRegisteredKernels(){hI(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){hI(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const n=this.registryFactory[e];if(n==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=n.factory();if(r&&!(r instanceof Zb)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,o=r.then(i=>s<this.pendingBackendInitId?!1:(this.registry[e]=i,this.pendingBackendInit=null,!0)).catch(i=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,Lo(`Initialization of backend ${e} failed`),Lo(i.stack||i.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return Lo(`Initialization of backend ${e} failed`),Lo(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,n)=>this.registryFactory[n].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n],{success:s,asyncInit:o}=this.initializeBackend(r);if(o||s)return{name:r,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,n){const r=this.state.tensorInfo.get(n),s=r.backend,o=this.readSync(n),i=s.refCount(n);s.disposeData(n,!0),r.backend=e,e.move(n,o,r.shape,r.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,n){let r=null;if(n==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");n=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=n(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,n,r){e();try{const s=r();return n(),s}catch(s){throw n(),s}}nextTensorId(){return ld.nextTensorId++}nextVariableId(){return ld.nextVariableId++}clone(e){const n=Y.runKernel(ry,{x:e}),r={x:e},s=i=>({x:()=>{const a="float32",l={x:i},c={dtype:a};return Y.runKernel(ny,l,c)}}),o=[];return this.addTapeNode(this.state.activeScope.name,r,[n],s,o,{}),n}runKernel(e,n,r){if(this.backendName==null&&this.backend,!($g(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,n,r){const s=this.backend.numDataIds();let o=0;r.forEach(l=>{o+=l.dtype==="complex64"?3:1});const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=s-n-o-i;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let n,r=[];const s=this.isTapeOn(),o=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const c=G1(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(G1(e)){const{kernelName:y,inputs:x,attrs:w}=e;this.backendName==null&&this.backend;const S=$g(y,this.backendName);z(S!=null,()=>`Cannot find registered kernel '${y}' for backend '${this.backendName}'`),a=()=>{const $=this.backend.numDataIds();l=S.kernelFunc({inputs:x,attrs:w,backend:this.backend});const I=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(y,$,I);const R=I.map(_=>_.rank!=null?_:this.makeTensorFromTensorInfo(_));if(s){const _=this.getTensorsForGradient(y,x,R);r=this.saveTensorsForBackwardMode(_)}return R}}else{const{forwardFunc:y}=e,x=w=>{s&&(r=w.map(S=>this.keep(this.clone(S))))};a=()=>{const w=this.backend.numDataIds();l=this.tidy(()=>y(this.backend,x));const S=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,w,S),S}}const{inputs:d,attrs:f}=e,p=G1(e)?null:e.backwardsFunc;let g;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=a():(g=this.profiler.profileKernel(c,d,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(g),n=g.outputs)}),s&&this.addTapeNode(c,d,n,p,r,f),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(y=>d[y]!=null?d[y].shape:null),outputShapes:n.map(y=>y.shape),kernelTimeMs:g.timeMs,extraInfo:g.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,n,r){const s=dI(e);if(s!=null){const o=s.inputsToSave||[],i=s.outputsToSave||[];let a;s.saveAllInputs?(z(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(n).map(c=>n[c])):a=o.map(c=>n[c]);const l=r.filter((c,d)=>i[d]);return a.concat(l)}return[]}makeTensor(e,n,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let o=e;r==="string"&&Gf(e[0])&&(o=e.map(l=>hl(l)));const i=s.write(o,n,r),a=new fn(n,r,i,this.nextTensorId());if(this.trackTensor(a,s),r==="string"){const l=this.state.tensorInfo.get(i),c=JK(o);this.state.numBytes+=c-l.bytes,l.bytes=c}return a}makeTensorFromDataId(e,n,r,s){r=r||"float32";const o={dataId:e,shape:n,dtype:r};return this.makeTensorFromTensorInfo(o,s)}makeTensorFromTensorInfo(e,n){const{dataId:r,shape:s,dtype:o}=e,i=new fn(s,o,r,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(e,n=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const o=new kg(e,n,r,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,n){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*xg(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:n||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof kg||this.track(e)}incRef(e,n){this.trackTensor(e,n),this.backend.incRef(e.dataId)}removeDataId(e,n){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===n&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const n=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*xg(e.dtype);this.state.numBytes-=r}n.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,n.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const n=this.state.registeredVariables[e];this.disposeVariable(n)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,n,r,s,o,i){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:n,outputs:r,saved:o},l=dI(e);l!=null&&(s=l.gradFunc),s!=null&&(a.gradient=c=>(c=c.map((d,f)=>{if(d==null){const p=r[f],g=ha(p.size,p.dtype);return this.makeTensor(g,p.shape,p.dtype)}return d}),s(c.length>1?c:c[0],o,i))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(n.name=e),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(e){const n=IA(e),r=new Set(n.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const i=this.state.activeScope.track[o];!i.kept&&!r.has(i.id)&&i.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(o=>{!o.kept&&o.scopeId===s.id&&this.track(o)})}gradients(e,n,r,s=!1){if(z(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));z(o instanceof fn,()=>"The result y returned by f() must be a tensor.");const i=CX(this.state.activeTape,n,o);if(!s&&i.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[o.id]=r??PX(o.shape),$X(a,i,c=>this.tidy(c),AX);const l=n.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const d of c.saved)d.dispose()}),this.state.activeTape=null),{value:o,grads:l}})}customGrad(e){return z(Jx(e),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{z(n.every(a=>a instanceof fn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};n.forEach((a,l)=>{s[l]=a});const o=(a,l)=>(r=e(...n,l),z(r.value instanceof fn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),z(Jx(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),i=(a,l)=>{const c=r.gradFunc(a,l),d=Array.isArray(c)?c:[c];z(d.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),z(d.every(p=>p instanceof fn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const f={};return d.forEach((p,g)=>{f[g]=()=>p}),f};return this.runKernelFunc({forwardFunc:o,backwardsFunc:i,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,n){return this.state.tensorInfo.get(e).backend.readToGPU(e,n)}async time(e){const n=Po(),r=await this.backend.time(e);return r.wallMs=Po()-n,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new yI;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}ld.nextTensorId=0;ld.nextVariableId=0;function PX(t){const e=GP(pe(t),"float32");return Y.makeTensor(e,t,"float32")}function EA(){const t=KP();if(t._tfengine==null){const e=new nX(t);t._tfengine=new ld(e)}return iX(t._tfengine.ENV),IX(()=>t._tfengine),t._tfengine}const Y=EA();function AX(t,e){const n={a:t,b:e};return Y.runKernel(ty,n)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DX(){return typeof navigator<"u"&&navigator!=null}function RA(t){if(t||DX()){if(t||(t=navigator),t.product==="ReactNative")return!0;const e=t.userAgent||t.vendor||(typeof window<"u"?window.opera:"");if(!e){const n=t;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function _A(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gr=se();Gr.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Gr.registerFlag("IS_BROWSER",()=>_A());Gr.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Gr.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Gr.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Gr.registerFlag("PROD",()=>!1);Gr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Gr.getBool("DEBUG"));Gr.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Gr.registerFlag("IS_TEST",()=>!1);Gr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Gr.getBool("DEBUG"));Gr.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Gr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Gr.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $l(t,e){let n=t;if(uo(t))return e==="string"?[]:[t.length];if(kA(t)){const s=t.channels||"RGBA";return[t.height,t.width*s.length]}else if(TA(t))return[t.buffer.size/(e==null?4:xg(e))];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||uo(n)&&e!=="string";)r.push(n.length),n=n[0];return Array.isArray(t)&&se().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&PA(t,r,[]),r}function PA(t,e,n){if(n=n||[],!Array.isArray(t)&&!uo(t)){z(e.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}z(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),z(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const r=e.slice(1);for(let s=0;s<t.length;++s)PA(t[s],r,n.concat(s))}function xI(t,e,n,r){if(t!=="string_or_numeric"){if(t==null)throw new Error("Expected dtype cannot be null.");if(t!=="numeric"&&t!==e||t==="numeric"&&e==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}}function L(t,e,n,r="numeric"){if(t instanceof $A())return xI(r,t.dtype,e,n),t;let s=$d(t);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),xI(r,s,e,n),t==null||!uo(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string"){const l=t==null?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${l}'`)}const o=$l(t,s);!uo(t)&&!Array.isArray(t)&&(t=[t]);const a=s!=="string"?iy(t,s):pa(t,[],!0);return Y.makeTensor(a,o,s)}function Tg(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((o,i)=>L(o,`${e}[${i}]`,n,r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AA="__op";function X(t){const e=Object.keys(t);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+AA;const s=(...o)=>{Y.startScope(n);try{const i=r(...o);return Ru(i)&&console.error("Cannot return a Promise inside of tidy."),Y.endScope(i),i}catch(i){throw Y.endScope(null),i}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OX(t,e){const n=L(t,"real","complex"),r=L(e,"imag","complex");ys(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return Y.runKernel(C2,s)}const yl=X({complex_:OX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kl(t,e,n,r){if(r==null)r=$d(t);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(TA(t)||kA(t)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return Y.backend.createTensorFromGPUData(t,e||n,r)}if(!uo(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Os(e);const s=pe(e),o=pe(n);z(s===o,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${o}`);for(let i=0;i<n.length;++i){const a=n[i],l=i===n.length-1?a!==pe(e.slice(i)):!0;z(n[i]===e[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return!uo(t)&&!Array.isArray(t)&&(t=[t]),e=e||n,t=r!=="string"?iy(t,r):pa(t,[],!0),Y.makeTensor(t,e,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vi(t,e,n){const r=$l(t,n);return kl(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _u={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Bo{static join(e){return new Bo(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(r=>uo(r)?r.buffer:r),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let n=0;for(let r=0;r<e.length;r++){const s=e[r];r!==e.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const o=n+s.byteLength;this.shards.push({buffer:s,start:n,end:o}),n=o}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,n=isNaN(Number(n))?0:n,e=Math.max(0,e),n=Math.min(this.byteLength,n),n<=e)return new ArrayBuffer(0);const r=this.findShardForByte(e);if(r===-1)throw new Error(`Could not find start shard for byte ${e}`);const s=n-e,o=new ArrayBuffer(s),i=new Uint8Array(o);let a=0;for(let l=r;l<this.shards.length;l++){const c=this.shards[l],f=e+a-c.start,p=a,y=Math.min(n,c.end)-c.start,x=new Uint8Array(c.buffer,f,y-f);if(i.set(x,p),a+=x.length,n<c.end)break}return o}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function n(s){return e<s.start?-1:e>=s.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const r=FX(this.shards,n);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function FX(t,e){let n=0,r=t.length;for(;n<=r;){const s=Math.floor((r-n)/2)+n,o=e(t[s]);if(o===0)return s;o<0?r=s:n=s+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ds(){return Y}function nt(t,e){return Y.tidy(t,e)}function Mt(t){IA(t).forEach(n=>n.dispose())}function hi(t){return Y.keep(t)}function LX(t){return Y.setBackend(t)}function zX(){return Y.ready()}function mf(){return Y.backendName}function DA(t,e,n=1){return Y.registerBackend(t,e,n)}function ud(){return Y.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xl=4;async function BX(t,e){const n=[],r=[],s=Array.isArray(t)?t.map(i=>i.name):Object.keys(t);for(let i=0;i<s.length;++i){const a=s[i],l=Array.isArray(t)?t[i].tensor:t[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const c={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const d=new Promise(async f=>{const p=await l.bytes(),g=p.reduce((w,S)=>w+S.length,0)+xl*p.length,y=new Uint8Array(g);let x=0;for(let w=0;w<p.length;w++){const S=p[w],$=new Uint8Array(new Uint32Array([S.length]).buffer);y.set($,x),x+=xl,y.set(S,x),x+=S.length}f(y)});r.push(d)}else r.push(l.data());e!=null&&(c.group=e),n.push(c)}const o=await Promise.all(r);return{data:WX(o),specs:n}}function OA(t,e){const n=new Bo(t),r={};let s=0;for(const o of e){const i=MX(o,(a,l)=>n.slice(s+a,s+l));r[o.name]=FA(o,n.slice(s,s+i)),s+=i}return r}function MX(t,e){const n=pe(t.shape);let r;if("quantization"in t){const s=t.quantization;r=_u[s.dtype]}else if(t.dtype==="string"){let s=0;for(let o=0;o<n;o++)s+=xl+new Uint32Array(e(s,s+xl))[0];return s}else r=_u[t.dtype];return n*r}async function VX(t,e){const n=pe(t.shape);let r;if("quantization"in t){const s=t.quantization;r=_u[s.dtype]}else if(t.dtype==="string"){let s=0;for(let o=0;o<n;o++)s+=xl+new Uint32Array(await e(s,s+xl))[0];return s}else r=_u[t.dtype];return n*r}function FA(t,e){const n=t.name,r=t.dtype,s=t.shape,o=pe(s);let i,a=0;if("quantization"in t){const l=t.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${t.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${t.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${t.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const c=_u[l.dtype],d=l.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(r==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){i=new Float32Array(d.length);for(let f=0;f<d.length;f++){const p=d[f];i[f]=p*l.scale+l.min}}else if(l.dtype==="float16")i=qX()(d);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(r==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(d.length);for(let f=0;f<d.length;f++){const p=d[f];i[f]=Math.round(p*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);a+=o*c}else if(r==="string"){const l=pe(t.shape);i=[];for(let c=0;c<l;c++){const d=new Uint32Array(e.slice(a,a+xl))[0];a+=xl;const f=new Uint8Array(e.slice(a,a+d));i.push(f),a+=d}}else{const l=_u[r];if(r==="float32")i=new Float32Array(e);else if(r==="int32")i=new Int32Array(e);else if(r==="bool")i=new Uint8Array(e);else if(r==="complex64"){i=new Float32Array(e);const c=new Float32Array(i.length/2),d=new Float32Array(i.length/2);for(let y=0;y<c.length;y++)c[y]=i[y*2],d[y]=i[y*2+1];const f=vi(c,s,"float32"),p=vi(d,s,"float32"),g=yl(f,p);return f.dispose(),p.dispose(),g}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);a+=o*l}return vi(i,s,r)}async function vI(t,e,n){let r=new Uint8Array(e);for(;r.byteLength<n;){const{done:s,value:o}=await t.read();if(s&&o==null){const a=n-r.byteLength;throw new Error(`Reader is done but ${a} bytes are still expected`)}const i=new Uint8Array(r.length+o.byteLength);i.set(r,0),i.set(new Uint8Array(o),r.length),r=i}return r.buffer}async function LA(t,e){const n={},r=t.getReader();let s=new ArrayBuffer(0);for(const o of e){const i=await VX(o,async(c,d)=>(s=await vI(r,s,d),s.slice(c,d)));s=await vI(r,s,i);const a=s.slice(0,i);s=s.slice(i);const l=FA(o,a);if(n[o.name]=l,mf()==="webgpu"){const c=ud();"uploadToGPU"in c&&pe(l.shape)>=se().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&c.uploadToGPU(l.dataId)}}return n}function WX(t){if(t===null)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(o=>{if(e+=o.byteLength,n.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const r=new Uint8Array(e);let s=0;return n.forEach(o=>{r.set(new Uint8Array(o.buffer),s),s+=o.byteLength}),r.buffer}const DS=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function bI(t){return DS?Buffer.byteLength(t,"utf8"):new Blob([t]).size}function UX(t){if(DS)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let r=0,s=e.length;r<s;r++)n+=String.fromCharCode(e[r]);return btoa(n)}function jX(t){if(DS){const r=Buffer.from(t,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n.set([e.charCodeAt(r)],r);return n.buffer}function GX(t){return Bo.join(t)}function wI(t){const e="/";for(t=t.trim();t.endsWith(e);)t=t.slice(0,t.length-1);const n=t.split(e);return n[n.length-1]}function zA(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return t.signature!=null&&(n.signature=t.signature),t.userDefinedMetadata!=null&&(n.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(n.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(n.initializerSignature=t.initializerSignature),t.trainingConfig!=null&&(n.trainingConfig=t.trainingConfig),n}function BA(t,e,n){const r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(t.trainingConfig!=null&&(r.trainingConfig=t.trainingConfig),t.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=n}return t.signature!=null&&(r.signature=t.signature),t.userDefinedMetadata!=null&&(r.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(r.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(r.initializerSignature=t.initializerSignature),r}async function OS(t,e){let n,r;return t.weightsManifest!=null&&([n,r]=await e(t.weightsManifest)),BA(t,n,r)}function Hf(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology==null?0:bI(JSON.stringify(t.modelTopology)),weightSpecsBytes:t.weightSpecs==null?0:bI(JSON.stringify(t.weightSpecs)),weightDataBytes:t.weightData==null?0:new Bo(t.weightData).byteLength}}function lv(t){const e=[];for(const n of t)e.push(...n.weights);return e}function HX(){const t=n=>{let r=n<<13,s=0;for(;(r&8388608)===0;)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}function KX(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}function XX(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}function qX(){const t=HX(),e=KX(),n=XX();return r=>{const s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let i=0;i<r.length;i++){const a=r[i],l=t[n[a>>10]+(a&1023)]+e[a>>10];o[i]=l}return new Float32Array(s)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return cn.instance==null&&(cn.instance=new cn),cn.instance}static registerSaveRouter(e){cn.getInstance().saveRouters.push(e)}static registerLoadRouter(e){cn.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return cn.getHandlers(e,"save")}static getLoadHandlers(e,n){return cn.getHandlers(e,"load",n)}static getHandlers(e,n,r){const s=[];return(n==="load"?cn.getInstance().loadRouters:cn.getInstance().saveRouters).forEach(i=>{const a=i(e,r);a!==null&&s.push(a)}),s}}const YX=t=>cn.registerSaveRouter(t),QX=t=>cn.registerLoadRouter(t),ZX=t=>cn.getSaveHandlers(t),JX=(t,e)=>cn.getLoadHandlers(t,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uv="tensorflowjs",cv=1,vu="models_store",ll="model_info_store";function MA(){if(!se().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t=typeof window>"u"?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function dv(t){const e=t.result;e.createObjectStore(vu,{keyPath:"modelPath"}),e.createObjectStore(ll,{keyPath:"modelPath"})}class Pu{constructor(e){if(this.indexedDB=MA(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,n){return new Promise((r,s)=>{const o=this.indexedDB.open(uv,cv);o.onupgradeneeded=()=>dv(o),o.onsuccess=()=>{const i=o.result;if(n==null){const a=i.transaction(vu,"readonly"),c=a.objectStore(vu).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return i.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(c.result.modelArtifacts)},c.onerror=d=>(i.close(),s(c.error)),a.oncomplete=()=>i.close()}else{n.weightData=Bo.join(n.weightData);const a=Hf(n),l=i.transaction(ll,"readwrite");let c=l.objectStore(ll),d;try{d=c.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(p){return s(p)}let f;d.onsuccess=()=>{f=i.transaction(vu,"readwrite");const p=f.objectStore(vu);let g;try{g=p.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:a})}catch(y){return s(y)}g.onsuccess=()=>r({modelArtifactsInfo:a}),g.onerror=y=>{c=l.objectStore(ll);const x=c.delete(this.modelPath);x.onsuccess=()=>(i.close(),s(g.error)),x.onerror=w=>(i.close(),s(g.error))}},d.onerror=p=>(i.close(),s(d.error)),l.oncomplete=()=>{f==null?i.close():f.oncomplete=()=>i.close()}}},o.onerror=i=>s(o.error)})}}Pu.URL_SCHEME="indexeddb://";const VA=t=>se().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Pu.URL_SCHEME)?eq(t.slice(Pu.URL_SCHEME.length)):null;cn.registerSaveRouter(VA);cn.registerLoadRouter(VA);function eq(t){return new Pu(t)}function tq(t){return t.startsWith(Pu.URL_SCHEME)?t.slice(Pu.URL_SCHEME.length):t}class nq{constructor(){this.indexedDB=MA()}async listModels(){return new Promise((e,n)=>{const r=this.indexedDB.open(uv,cv);r.onupgradeneeded=()=>dv(r),r.onsuccess=()=>{const s=r.result,o=s.transaction(ll,"readonly"),a=o.objectStore(ll).getAll();a.onsuccess=()=>{const l={};for(const c of a.result)l[c.modelPath]=c.modelArtifactsInfo;e(l)},a.onerror=l=>(s.close(),n(a.error)),o.oncomplete=()=>s.close()},r.onerror=s=>n(r.error)})}async removeModel(e){return e=tq(e),new Promise((n,r)=>{const s=this.indexedDB.open(uv,cv);s.onupgradeneeded=()=>dv(s),s.onsuccess=()=>{const o=s.result,i=o.transaction(ll,"readwrite"),a=i.objectStore(ll),l=a.get(e);let c;l.onsuccess=()=>{if(l.result==null)return o.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const d=a.delete(e),f=()=>{c=o.transaction(vu,"readwrite");const g=c.objectStore(vu).delete(e);g.onsuccess=()=>n(l.result.modelArtifactsInfo),g.onerror=y=>r(l.error)};d.onsuccess=f,d.onerror=p=>(f(),o.close(),r(l.error))}},l.onerror=d=>(o.close(),r(l.error)),i.oncomplete=()=>{c==null?o.close():c.oncomplete=()=>o.close()}},s.onerror=o=>r(s.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const na="/",Rc="tensorflowjs_models",WA="info",rq="model_topology",sq="weight_specs",oq="weight_data",iq="model_metadata";function UA(t){return{info:[Rc,t,WA].join(na),topology:[Rc,t,rq].join(na),weightSpecs:[Rc,t,sq].join(na),weightData:[Rc,t,oq].join(na),modelMetadata:[Rc,t,iq].join(na)}}function jA(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function aq(t){const e=t.split(na);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(na)}function lq(t){return t.startsWith(Au.URL_SCHEME)?t.slice(Au.URL_SCHEME.length):t}class Au{constructor(e){if(!se().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=UA(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=Hf(e),o=Bo.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,UX(o));const i={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:s}}catch{throw jA(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=s;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const a=JSON.parse(o);n.format=a.format,n.generatedBy=a.generatedBy,n.convertedBy=a.convertedBy,a.signature!=null&&(n.signature=a.signature),a.userDefinedMetadata!=null&&(n.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(n.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(n.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(n.trainingConfig=a.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=jX(i),n}}Au.URL_SCHEME="localstorage://";const GA=t=>se().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Au.URL_SCHEME)?uq(t.slice(Au.URL_SCHEME.length)):null;cn.registerSaveRouter(GA);cn.registerLoadRouter(GA);function uq(t){return new Au(t)}class cq{constructor(){z(se().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),z(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},n=Rc+na,r=na+WA;for(let s=0;s<this.LS.length;++s){const o=this.LS.key(s);if(o.startsWith(n)&&o.endsWith(r)){const i=aq(o);e[i]=JSON.parse(this.LS.getItem(o))}}return e}async removeModel(e){e=lq(e);const n=UA(e);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return jA(n),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qc="://";class Sr{constructor(){this.managers={}}static getInstance(){return Sr.instance==null&&(Sr.instance=new Sr),Sr.instance}static registerManager(e,n){z(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Qc)&&(e=e.slice(0,e.indexOf(Qc))),z(e.length>0,()=>"scheme must not be an empty string.");const r=Sr.getInstance();z(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=n}static getManager(e){const n=Sr.getInstance().managers[e];if(n==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return n}static getSchemes(){return Object.keys(Sr.getInstance().managers)}}function Gm(t){if(t.indexOf(Qc)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Sr.getSchemes().join(",")}`);return{scheme:t.split(Qc)[0],path:t.split(Qc)[1]}}async function HA(t,e,n=!1){z(t!==e,()=>`Old path and new path are the same: '${t}'`);const r=cn.getLoadHandlers(t);z(r.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),z(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${t}.`);const s=r[0],o=cn.getSaveHandlers(e);z(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),z(o.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const i=o[0],a=Gm(t).scheme,l=Gm(t).path,c=a===Gm(t).scheme,d=await s.load();n&&c&&await Sr.getManager(a).removeModel(l);const f=await i.save(d);return n&&!c&&await Sr.getManager(a).removeModel(l),f.modelArtifactsInfo}async function dq(){const t=Sr.getSchemes(),e={};for(const n of t){const r=await Sr.getManager(n).listModels();for(const s in r){const o=n+Qc+s;e[o]=r[s]}}return e}async function hq(t){const e=Gm(t);return Sr.getManager(e.scheme).removeModel(e.path)}async function fq(t,e){return HA(t,e,!1)}async function pq(t,e){return HA(t,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mq{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,n){return fetch(e,n)}now(){return performance.now()}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,n){return new TextDecoder(n).decode(e)}setTimeoutCustom(e,n){if(typeof window>"u"||!se().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,n);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const s=this.functionRefs[r.data.index];s(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return xA(e)}}if(se().get("IS_BROWSER")){se().setPlatform("browser",new mq);try{Sr.registerManager(Au.URL_SCHEME,new cq)}catch{}try{Sr.registerManager(Pu.URL_SCHEME,new nq)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gq={importFetch:()=>require("node-fetch")};let H1;class yq{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,n){return se().global.fetch!=null?se().global.fetch(e,n):(H1==null&&(H1=gq.importFetch()),H1(e,n))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(e)}decode(e,n){return e.length===0?"":new this.util.TextDecoder(n).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}se().get("IS_NODE")&&!se().get("IS_BROWSER")&&se().setPlatform("node",new yq);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wt(t,e="float32",n){return e=e||"float32",Os(t),new ad(t,e,n)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xq(t,e){const n=L(t,"x","cast");if(!ZK(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&n.dtype!=="string"||e!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:e};return Y.runKernel(ny,r,s)}const Qt=X({cast_:xq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vq(t){const n={x:L(t,"x","clone","string_or_numeric")};return Y.runKernel(ry,n)}const fl=X({clone_:vq});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KA(t,e=!1){console.log(t.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */EA();const bq={buffer:Wt,cast:Qt,clone:fl,print:KA};NX(bq);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wq(t,e){let n=L(t,"a","add"),r=L(e,"b","add");[n,r]=yn(n,r);const s={a:n,b:r};return Y.runKernel(ty,s)}const We=X({add_:wq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sq(t,e){let n=L(t,"a","floorDiv"),r=L(e,"b","floorDiv");[n,r]=yn(n,r);const s={a:n,b:r};return Y.runKernel(tw,s)}const XA=X({floorDiv_:Sq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cq(t,e){let n=L(t,"a","div"),r=L(e,"b","div");if([n,r]=yn(n,r),n.dtype==="int32"&&r.dtype==="int32")return XA(n,r);const s={a:n,b:r},o={};return Y.runKernel(U2,s,o)}const gt=X({div_:Cq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $q(t,e){let n=L(t,"a","mul"),r=L(e,"b","mul");[n,r]=yn(n,r);const s={a:n,b:r};return Y.runKernel(Aw,s)}const Te=X({mul_:$q});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kq(t){const e=L(t,"x","abs");if(e.dtype==="complex64"){const n={x:e};return Y.runKernel($2,n)}else{const n={x:e};return Y.runKernel(n2,n)}}const Es=X({abs_:kq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tq(t){const n={x:L(t,"x","acos")};return Y.runKernel(r2,n)}const Iq=X({acos_:Tq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nq(t){const n={x:L(t,"x","acosh")};return Y.runKernel(s2,n)}const Eq=X({acosh_:Nq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rq(t){z(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),z(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const e=t.map((s,o)=>L(s,`tensors${o}`,"addN")),n=e[0];e.forEach(s=>{if(s.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(s=>{if(!Vt(s.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return Y.runKernel(o2,r)}const _q=X({addN_:Rq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pq(t,e=null,n=!1){const s={x:L(t,"x","all","bool")},o={axis:e,keepDims:n};return Y.runKernel(i2,s,o)}const Aq=X({all_:Pq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dq(t,e=null,n=!1){const s={x:L(t,"x","any","bool")},o={axis:e,keepDims:n};return Y.runKernel(a2,s,o)}const Oq=X({any_:Dq});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fq(t,e=0){const r={x:L(t,"x","argMax")},s={axis:e};return Y.runKernel(l2,r,s)}const qA=X({argMax_:Fq});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lq(t,e=0){const r={x:L(t,"x","argMin")},s={axis:e};return Y.runKernel(u2,r,s)}const zq=X({argMin_:Lq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bq(t){const n={x:L(t,"x","asin")};return Y.runKernel(c2,n)}const Mq=X({asin_:Bq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vq(t){const n={x:L(t,"x","asinh")};return Y.runKernel(d2,n)}const Wq=X({asinh_:Vq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uq(t){const n={x:L(t,"x","atan")};return Y.runKernel(h2,n)}const jq=X({atan_:Uq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gq(t,e){let n=L(t,"a","atan2"),r=L(e,"b","atan2");[n,r]=yn(n,r);const s={a:n,b:r};return Y.runKernel(p2,s)}const Hq=X({atan2_:Gq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kq(t){const n={x:L(t,"x","atanh")};return Y.runKernel(f2,n)}const Xq=X({atanh_:Kq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kf(t,e,n,r,s="NHWC",o){const i=t[3],a=[...e,i],l=Mo(s);return kn(t,a,n,o,r,null,null,l)}function fo(t,e,n,r,s,o,i="channelsLast"){const[a,l]=gf(e);let c;if(i==="channelsLast")c=[a,l,t[3],t[3]];else if(i==="channelsFirst")c=[a,l,t[1],t[1]];else throw new Error(`Unknown dataFormat ${i}`);return kn(t,c,n,r,s,o,!1,i)}function Sa(t,e,n,r,s,o,i="NDHWC"){const[a,l,c]=hv(e);let d,f;if(i==="NDHWC")f="channelsLast",d=[a,l,c,t[4],t[4]];else if(i==="NCDHW")f="channelsFirst",d=[a,l,c,t[1],t[1]];else throw new Error(`Unknown dataFormat ${i}`);return Tl(t,d,n,r,s,!1,f,o)}function kn(t,e,n,r,s,o,i=!1,a="channelsLast"){let[l,c,d,f]=[-1,-1,-1,-1];if(a==="channelsLast")[l,c,d,f]=t;else if(a==="channelsFirst")[l,f,c,d]=t;else throw new Error(`Unknown dataFormat ${a}`);const[p,g,,y]=e,[x,w]=gf(n),[S,$]=gf(r),I=Zc(p,S),R=Zc(g,$),{padInfo:_,outHeight:O,outWidth:F}=Qq(s,c,d,x,w,I,R,o,a),B=i?y*f:y;let M;return a==="channelsFirst"?M=[l,B,O,F]:a==="channelsLast"&&(M=[l,O,F,B]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:d,inChannels:f,outHeight:O,outWidth:F,outChannels:B,padInfo:_,strideHeight:x,strideWidth:w,filterHeight:p,filterWidth:g,effectiveFilterHeight:I,effectiveFilterWidth:R,dilationHeight:S,dilationWidth:$,inShape:t,outShape:M,filterShape:e}}function Tl(t,e,n,r,s,o=!1,i="channelsLast",a){let[l,c,d,f,p]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,c,d,f,p]=t;else if(i==="channelsFirst")[l,p,c,d,f]=t;else throw new Error(`Unknown dataFormat ${i}`);const[g,y,x,,w]=e,[S,$,I]=hv(n),[R,_,O]=hv(r),F=Zc(g,R),B=Zc(y,_),M=Zc(x,O),{padInfo:V,outDepth:P,outHeight:re,outWidth:ie}=Zq(s,c,d,f,S,$,I,F,B,M,a),me=o?w*p:w;let ge;return i==="channelsFirst"?ge=[l,me,P,re,ie]:i==="channelsLast"&&(ge=[l,P,re,ie,me]),{batchSize:l,dataFormat:i,inDepth:c,inHeight:d,inWidth:f,inChannels:p,outDepth:P,outHeight:re,outWidth:ie,outChannels:me,padInfo:V,strideDepth:S,strideHeight:$,strideWidth:I,filterDepth:g,filterHeight:y,filterWidth:x,effectiveFilterDepth:F,effectiveFilterHeight:B,effectiveFilterWidth:M,dilationDepth:R,dilationHeight:_,dilationWidth:O,inShape:t,outShape:ge,filterShape:e}}function qq(t,e,n,r,s){r==null&&(r=FS(t,e,n));const o=t[0],i=t[1],a=yf((o-e+2*r)/n+1,s),l=yf((i-e+2*r)/n+1,s);return[a,l]}function Yq(t,e,n,r,s,o){s==null&&(s=FS(t,e[0],r[0]));const i=[0,0,0,n];for(let a=0;a<3;a++)t[a]+2*s>=e[a]&&(i[a]=yf((t[a]-e[a]+2*s)/r[a]+1,o));return i}function FS(t,e,n,r=1){const s=Zc(e,r);return Math.floor((t[0]*(n-1)-n+s)/2)}function gf(t){return typeof t=="number"?[t,t,t]:t.length===2?[t[0],t[1],1]:t}function hv(t){return typeof t=="number"?[t,t,t]:t}function Zc(t,e){return e<=1?t:t+(t-1)*(e-1)}function Qq(t,e,n,r,s,o,i,a,l){let c,d,f;if(typeof t=="number"){c={top:t,bottom:t,left:t,right:t,type:t===0?"VALID":"NUMBER"};const g=qq([e,n],o,r,t,a);d=g[0],f=g[1]}else if(t==="same"){d=Math.ceil(e/r),f=Math.ceil(n/s);const p=Math.max(0,(d-1)*r+o-e),g=Math.max(0,(f-1)*s+i-n),y=Math.floor(p/2),x=p-y,w=Math.floor(g/2),S=g-w;c={top:y,bottom:x,left:w,right:S,type:"SAME"}}else if(t==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},d=Math.ceil((e-o+1)/r),f=Math.ceil((n-i+1)/s);else if(typeof t=="object"){const p=l==="channelsLast"?t[1][0]:t[2][0],g=l==="channelsLast"?t[1][1]:t[2][1],y=l==="channelsLast"?t[2][0]:t[3][0],x=l==="channelsLast"?t[2][1]:t[3][1];c={top:p,bottom:g,left:y,right:x,type:p===0&&g===0&&y===0&&x===0?"VALID":"EXPLICIT"},d=yf((e-o+p+g)/r+1,a),f=yf((n-i+y+x)/s+1,a)}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:c,outHeight:d,outWidth:f}}function Zq(t,e,n,r,s,o,i,a,l,c,d){let f,p,g,y;if(t==="valid"&&(t=0),typeof t=="number"){f={top:t,bottom:t,left:t,right:t,front:t,back:t,type:t===0?"VALID":"NUMBER"};const w=Yq([e,n,r,1],[a,l,c],1,[s,o,i],t,d);p=w[0],g=w[1],y=w[2]}else if(t==="same"){p=Math.ceil(e/s),g=Math.ceil(n/o),y=Math.ceil(r/i);const x=(p-1)*s+a-e,w=(g-1)*o+l-n,S=(y-1)*i+c-r,$=Math.floor(x/2),I=x-$,R=Math.floor(w/2),_=w-R,O=Math.floor(S/2),F=S-O;f={top:R,bottom:_,left:O,right:F,front:$,back:I,type:"SAME"}}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:f,outDepth:p,outHeight:g,outWidth:y}}function yf(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function xf(t){const[e,n,r]=gf(t);return e===1&&n===1&&r===1}function Nr(t,e){return xf(t)||xf(e)}function Du(t){return gf(t).every(e=>e>0)}function Mo(t){if(t==="NHWC")return"channelsLast";if(t==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function po(t,e,n){if(n!=null){if(typeof e=="string")throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if(typeof e=="number")z(id(e),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(s=>{z(id(s),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${s}.`)})});else throw Error(`Error in ${t}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jq(t,e){const r={x:L(t,"x","reshape","string_or_numeric")},s={shape:e};return Y.runKernel(qw,r,s)}const ye=X({reshape_:Jq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eY(t,e,n,r,s){const o=L(t,"x","avgPool","float32"),i=1;z(Nr(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let a=o,l=!1;o.rank===3&&(l=!0,a=ye(o,[1,o.shape[0],o.shape[1],o.shape[2]])),z(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),po("avgPool",r,s);const c={x:a},d={filterSize:e,strides:n,pad:r,dimRoundingMode:s};let f=Y.runKernel(m2,c,d);return f=Qt(f,o.dtype),l?ye(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const YA=X({avgPool_:eY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tY(t,e,n,r,s,o="NDHWC"){const i=L(t,"x","avgPool3d","float32");let a=i,l=!1;i.rank===4&&(l=!0,a=ye(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),z(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),z(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),z(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),po("avgPool3d",r,s);const c={x:a},d={filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:o};let f=Y.runKernel(g2,c,d);return f=Qt(f,a.dtype),l?ye(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const nY=X({avgPool3d_:tY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rY(t,e=0){z(t.length>=1,()=>"Pass at least one tensor to concat");const n=Tg(t,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),n.length===1)return fl(n[0]);const r=n,s={axis:e};return Y.runKernel(k2,r,s)}const Fn=X({concat_:rY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sY(t,e,n=!1,r=!1){let s=L(t,"a","matMul"),o=L(e,"b","matMul");[s,o]=yn(s,o);const i={a:s,b:o},a={transposeA:n,transposeB:r};return Y.runKernel(y2,i,a)}const Ht=X({matMul_:sY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oY(t){const n={x:L(t,"x","sigmoid","float32")};return Y.runKernel(dS,n)}const aa=X({sigmoid_:oY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iY(t,e,n){const r=L(t,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},o={begin:e,size:n};return Y.runKernel(aS,s,o)}const pt=X({slice_:iY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aY(t){const n={x:L(t,"x","tanh","float32")};return Y.runKernel(TS,n)}const fv=X({tanh_:aY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lY(t,e,n,r,s,o){const i=L(t,"forgetBias","basicLSTMCell"),a=L(e,"lstmKernel","basicLSTMCell"),l=L(n,"lstmBias","basicLSTMCell"),c=L(r,"data","basicLSTMCell"),d=L(s,"c","basicLSTMCell"),f=L(o,"h","basicLSTMCell"),p=Fn([c,f],1),g=Ht(p,a),y=We(g,l),x=y.shape[0],w=y.shape[1]/4,S=[x,w],$=pt(y,[0,0],S),I=pt(y,[0,w],S),R=pt(y,[0,w*2],S),_=pt(y,[0,w*3],S),O=We(Te(aa($),fv(I)),Te(d,aa(We(i,R)))),F=Te(fv(O),aa(_));return[O,F]}const uY=X({basicLSTMCell_:lY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cY(t,e,n){const r=L(t,"x","batchToSpaceND"),s=e.reduce((a,l)=>a*l);z(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),z(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),z(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const o={x:r},i={blockShape:e,crops:n};return Y.runKernel(x2,o,i)}const QA=X({batchToSpaceND_:cY});function dY(t){let e;return t.rank===0||t.rank===1?e=ye(t,[1,1,1,t.size]):t.rank===2?e=ye(t,[1,1,t.shape[0],t.shape[1]]):t.rank===3?e=ye(t,[1,t.shape[0],t.shape[1],t.shape[2]]):e=t,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hY(t,e,n,r,s,o){o==null&&(o=.001);const i=L(t,"x","batchNorm"),a=L(e,"mean","batchNorm"),l=L(n,"variance","batchNorm");let c;s!=null&&(c=L(s,"scale","batchNorm"));let d;r!=null&&(d=L(r,"offset","batchNorm")),z(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),z(d==null||a.rank===d.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),z(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const p={x:dY(i),scale:c,offset:d,mean:a,variance:l},g={varianceEpsilon:o},y=Y.runKernel(nw,p,g);return ye(y,i.shape)}const ly=X({batchNorm_:hY});function fY(t,e,n,r,s,o){const i=L(t,"x","batchNorm"),a=L(e,"mean","batchNorm"),l=L(n,"variance","batchNorm");let c;s!=null&&(c=L(s,"scale","batchNorm"));let d;return r!=null&&(d=L(r,"offset","batchNorm")),z(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),z(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),z(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&z(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),d!=null&&z(d.rank===2||d.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${d.rank}.`),ly(i,a,l,d,c,o)}const pY=X({batchNorm2d_:fY});function mY(t,e,n,r,s,o){const i=L(t,"x","batchNorm"),a=L(e,"mean","batchNorm"),l=L(n,"variance","batchNorm");let c;s!=null&&(c=L(s,"scale","batchNorm"));let d;return r!=null&&(d=L(r,"offset","batchNorm")),z(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),z(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),z(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&z(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),d!=null&&z(d.rank===3||d.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${d.rank}.`),ly(i,a,l,d,c,o)}const gY=X({batchNorm3d_:mY});function yY(t,e,n,r,s,o){const i=L(t,"x","batchNorm"),a=L(e,"mean","batchNorm"),l=L(n,"variance","batchNorm");let c;s!=null&&(c=L(s,"scale","batchNorm"));let d;return r!=null&&(d=L(r,"offset","batchNorm")),z(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),z(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),z(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&z(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),d!=null&&z(d.rank===4||d.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${d.rank}.`),ly(i,a,l,d,c,o)}const xY=X({batchNorm4d_:yY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vY(t,e,n){const r=L(t,"x","bincount"),s=L(e,"weights","bincount");z(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),z(n>=0,()=>`size must be non-negative, but got ${n}.`),z(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const o={x:r,weights:s},i={size:n};return Y.runKernel(v2,o,i)}const ZA=X({bincount_:vY});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bY(t,e){const n=L(t,"x","bitwiseAnd"),r=L(e,"y","bitwiseAnd");if(!Vt(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if(n.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);const s={a:n,b:r};return Y.runKernel(YP,s)}const wY=X({bitwiseAnd_:bY});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SY(t,e){const n=L(t,"s0","broadcastArgs","int32"),r=L(e,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:n,s1:r};return Y.runKernel(b2,s)}const CY=X({broadcastArgs_:SY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Y(t,e){let n=L(t,"broadcastTo","x");const r=n.shape;if(Os(e),e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const c=n.shape.slice();for(;c.length<e.length;)c.unshift(1);n=ye(n,c)}const s=n.shape,o=Array.from(e);for(let c=e.length-1;c>=0;c--)if(s[c]===e[c])o[c]=1;else if(n.shape[c]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(o.map((c,d)=>c>1?d:-1).filter(c=>c>=0).length===0)return fl(n);const a={x:n},l={reps:o};return Y.runKernel(sy,a,l)}const Qh=X({broadcastTo_:$Y});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kY(t){const n={x:L(t,"x","ceil","float32")};return Y.runKernel(w2,n)}const TY=X({ceil_:kY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xf(t,e,n){Os(t),n=n||$d(e);const r={shape:t,value:e,dtype:n};return Y.runKernel(Z2,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IY(t,e,n){const r=L(t,"x","clipByValue");if(z(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`),e===n)return Xf(r.shape,e,r.dtype);const s={x:r},o={clipValueMin:e,clipValueMax:n};return Y.runKernel(S2,s,o)}const JA=X({clipByValue_:IY});function NY(t){return Fn(t,0)}const EY=X({concat1d_:NY});function RY(t,e){return Fn(t,e)}const _Y=X({concat2d_:RY});function PY(t,e){return Fn(t,e)}const AY=X({concat3d_:PY});function DY(t,e){return Fn(t,e)}const OY=X({concat4d_:DY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FY(t,e,n,r,s="NHWC",o=[1,1],i){const a=L(t,"x","conv2d","float32"),l=L(e,"filter","conv2d","float32");let c=a,d=!1;a.rank===3&&(d=!0,c=ye(a,[1,a.shape[0],a.shape[1],a.shape[2]])),z(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),z(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),po("conv2d",r,i);const f=s==="NHWC"?c.shape[3]:c.shape[1];z(f===l.shape[2],()=>`Error in conv2d: depth of input (${f}) must match input depth for filter ${l.shape[2]}.`),z(Nr(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),z(Du(o),()=>"Error in conv2D: Dilated rates should be larger than 0."),z(Du(n),()=>"Error in conv2D: Strides should be larger than 0.");const p={x:c,filter:l},g={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i},y=Y.runKernel(T2,p,g);return d?ye(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const uy=X({conv2d_:FY});function LY(t,e,n,r,s="NWC",o=1,i){const a=L(t,"x","conv1d"),l=L(e,"filter","conv1d");let c=a,d=!1;a.rank===2&&(d=!0,c=ye(a,[1,a.shape[0],a.shape[1]])),z(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),z(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),po("conv1d",r,i),z(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),z(Nr(n,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${o}'`),z(Du(o),()=>"Error in conv1D: Dilated rates should be larger than 0."),z(Du(n),()=>"Error in conv1D: Stride should be larger than 0."),z(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const f=ye(l,[1,l.shape[0],l.shape[1],l.shape[2]]),p=ye(c,[c.shape[0],1,c.shape[1],c.shape[2]]),w=uy(p,f,[1,n],r,"NHWC",[1,o],i);return d?ye(w,[w.shape[2],w.shape[3]]):ye(w,[w.shape[0],w.shape[2],w.shape[3]])}const zY=X({conv1d_:LY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BY(t,e,n,r,s,o="NHWC",i){z(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let a=t,l=e,c=!1;e.rank===3&&(c=!0,l=ye(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,t[0],t[1],t[2]]),z(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),z(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),z(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const d=o==="NHWC"?a[3]:a[1],f=o==="NHWC"?l.shape[3]:l.shape[1];z(d===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${d}) must match input depth for filter ${n.shape[2]}.`),z(f===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${f}) must match output depth for filter ${n.shape[3]}.`),po("conv2dDerInput",s,i);const p={dy:l,filter:n},g={strides:r,pad:s,dataFormat:o,dimRoundingMode:i,inputShape:a},y=Y.runKernel(N2,p,g);return c?ye(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const eD=X({conv2DBackpropInput_:BY});function MY(t,e,n,r,s,o){const i=L(t,"x","conv2dTranspose"),a=L(e,"filter","conv2dTranspose");return eD(n,i,a,r,s,"NHWC",o)}const VY=X({conv2dTranspose_:MY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WY(t,e,n,r,s="NDHWC",o=[1,1,1]){const i=L(t,"x","conv3d"),a=L(e,"filter","conv3d");let l=i,c=!1;i.rank===4&&(c=!0,l=ye(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),z(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),z(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),z(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),z(Nr(n,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),z(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),z(Du(o),()=>"Error in conv3D: Dilated rates should be larger than 0."),z(Du(n),()=>"Error in conv3D: Strides should be larger than 0.");const d={x:l,filter:a},f={strides:n,pad:r,dataFormat:s,dilations:o},p=Y.runKernel(E2,d,f);return c?ye(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const UY=X({conv3d_:WY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jY(t,e,n,r,s){z(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let o=t,i=e,a=!1;e.rank===4&&(a=!0,i=ye(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),o=[1,t[0],t[1],t[2],t[3]]);const l=o[4],c=i.shape[4];z(o.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),z(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),z(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),z(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),z(c===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[4]}.`);const d={dy:i,filter:n},f={pad:s,strides:r,inputShape:o},p=Y.runKernel(R2,d,f);return a?ye(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const GY=X({conv3DBackpropInput_:jY});function HY(t,e,n,r,s){const o=L(t,"x","conv3dTranspose"),i=L(e,"filter","conv3dTranspose");return GY(n,o,i,r,s)}const KY=X({conv3dTranspose_:HY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XY(t){const n={x:L(t,"x","cos","float32")};return Y.runKernel(_2,n)}const qY=X({cos_:XY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YY(t){const n={x:L(t,"x","cosh","float32")};return Y.runKernel(P2,n)}const QY=X({cosh_:YY});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZY(t,e=0,n=!1,r=!1){const o={x:L(t,"x","cumprod")},i={axis:e,exclusive:n,reverse:r};return Y.runKernel(A2,o,i)}const JY=X({cumprod_:ZY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eQ(t,e=0,n=!1,r=!1){const o={x:L(t,"x","cumsum")},i={axis:e,exclusive:n,reverse:r};return Y.runKernel(D2,o,i)}const tQ=X({cumsum_:eQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nQ(t,e,n,r=!1){const s=L(t,"x","denseBincount"),o=L(e,"weights","denseBincount");z(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),z(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),z(n>=0,()=>`size must be non-negative, but got ${n}.`),z(o.size===s.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`);const i={x:s,weights:o},a={size:n,binaryOutput:r};return Y.runKernel(F2,i,a)}const rQ=X({denseBincount_:nQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sQ(t,e,n="NHWC"){const r=L(t,"x","depthToSpace","float32"),s=n==="NHWC"?r.shape[1]:r.shape[2],o=n==="NHWC"?r.shape[2]:r.shape[3],i=n==="NHWC"?r.shape[3]:r.shape[1];z(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),z(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${r.shape}`),z(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e} for depthToSpace with input shape
        ${r.shape}`),z(i%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${i} for depthToSpace with input shape ${r.shape}`);const a={x:r},l={blockSize:e,dataFormat:n};return Y.runKernel(L2,a,l)}const oQ=X({depthToSpace_:sQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iQ(t,e,n,r,s="NHWC",o=[1,1],i){const a=L(t,"x","depthwiseConv2d","float32"),l=L(e,"filter","depthwiseConv2d","float32");let c=a,d=!1;a.rank===3&&(d=!0,c=ye(a,[1,a.shape[0],a.shape[1],a.shape[2]])),z(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),z(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const f=s==="NHWC"?c.shape[3]:c.shape[1];z(f===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${f}) must match the inChannels dimension in filter ${l.shape[2]}.`),po("depthwiseConv2d",r,i);const p={x:c,filter:l},g={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i},y=Y.runKernel(z2,p,g);return d?ye(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const LS=X({depthwiseConv2d_:iQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aQ(t){const n={x:L(t,"x","diag")};return Y.runKernel(V2,n)}const lQ=X({diag_:aQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uQ(t,e,n,r,s=[1,1],o="NHWC"){const i=L(t,"x","dilation2d"),a=L(e,"filter","dilation2d");z(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),z(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),z(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let l=i,c=!1;i.rank===3&&(l=ye(i,[1,i.shape[0],i.shape[1],i.shape[2]]),c=!0),z(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const d={x:l,filter:a},f={strides:n,pad:r,dilations:s},p=Y.runKernel(W2,d,f);return c?ye(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const cQ=X({dilation2d_:uQ});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cd(t,e){const n=t.length,r=[];for(let s=0;s<n;s++){const o=n-1-s,i=t[o]||1;(e[e.length-1-s]||1)>1&&i===1&&r.unshift(o)}return r}function tD(t,e){const n=[];for(let r=0;r<e.length;r++){const s=t[t.length-r-1],o=e.length-r-1,i=e[o];(s==null||s===1&&i>1)&&n.unshift(o)}return n}function ct(t,e){const n=Math.max(t.length,e.length),r=new Array(n);for(let s=0;s<n;s++){let o=t[t.length-s-1];o==null&&(o=1);let i=e[e.length-s-1];if(i==null&&(i=1),o===1)r[n-s-1]=i;else if(i===1)r[n-s-1]=o;else if(o!==i){const a=`Operands could not be broadcast together with shapes ${t} and ${e}.`;throw Error(a)}else r[n-s-1]=o}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dQ(t,e){let n=L(t,"a","equal","string_or_numeric"),r=L(e,"b","equal","string_or_numeric");[n,r]=yn(n,r),ct(n.shape,r.shape);const s={a:n,b:r};return Y.runKernel(K2,s)}const nD=X({equal_:dQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hQ(t,e,n){const r=L(e,"a","where"),s=L(n,"b","where"),o=L(t,"condition","where","bool"),i=ct(ct(o.shape,r.shape),s.shape),a=Qh(o,i),l=Qh(r,i),c=Qh(s,i),d={condition:a,t:l,e:c};return Y.runKernel(oS,d)}const pl=X({where_:hQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fQ(t){const n={x:L(t,"x","zerosLike")};return Y.runKernel(_S,n)}const Ds=X({zerosLike_:fQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pQ(t,e){let n=L(t,"a","div"),r=L(e,"b","div");[n,r]=yn(n,r);const s=gt(n,r),o=Ds(s),i=nD(r,o);return pl(i,o,s)}const mQ=X({divNoNan_:pQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gQ(t,e){const n=L(t,"t1","dot"),r=L(e,"t2","dot");z((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);const s=n.rank===1?n.size:n.shape[1],o=r.rank===1?r.size:r.shape[0];if(z(s===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${o}.`),n.rank===1&&r.rank===1){const i=ye(n,[1,-1]),a=ye(r,[-1,1]),l=Ht(i,a);return ye(l,[])}else if(n.rank===1&&r.rank===2){const i=ye(n,[1,-1]),a=ye(r,[r.shape[0],r.shape[1]]),l=Ht(i,a);return ye(l,[l.size])}else if(n.rank===2&&r.rank===1){const i=ye(r,[-1,1]),a=Ht(n,i);return ye(a,[a.size])}else{const i=ye(r,[r.shape[0],r.shape[1]]);return Ht(n,i)}}const yQ=X({dot_:gQ});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xQ(t,...e){const n=e.map((s,o)=>L(s,`tensors${o}`,"einsum")),r={equation:t};return Y.runKernel(j2,n,r)}const _c=X({einsum_:xQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vQ(t){const n={x:L(t,"x","elu","float32")};return Y.runKernel(G2,n)}const rD=X({elu_:vQ});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bQ(t,e){const n=L(t,"x","ensureShape","string_or_numeric");if(!YK(n.shape,e))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${e}`);return t}const wQ=X({ensureShape_:bQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SQ(t){let e=L(t,"x","erf");z(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Qt(e,"float32"));const n={x:e};return Y.runKernel(H2,n)}const CQ=X({erf_:SQ});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zS(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function sD(t,e,n){const r=t.length+e.length,s=[];let o=0,i=0;for(let a=0;a<r;a++)n.indexOf(a)===-1?s.push(t[o++]):s.push(e[i++]);return s}function Fs(t,e){const n=[],r=t.length;for(let o=0;o<r;o++)e.indexOf(o)===-1&&n.push(t[o]);const s=e.map(o=>t[o]);return[n,s]}function xs(t,e){const n=e.map(r=>1);return sD(t,n,e)}function vs(t,e,n){z(zS(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function lr(t,e){if(zS(t,e))return null;const n=[];for(let r=0;r<e;++r)t.indexOf(r)===-1&&n.push(r);return t.forEach(r=>n.push(r)),n}function qf(t){return t.map((e,n)=>[n,e]).sort((e,n)=>e[1]-n[1]).map(e=>e[0])}function ur(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Q(t,e=null,n=!1){const s={x:L(t,"x","max")},o={reductionIndices:e,keepDims:n};return Y.runKernel(Sw,s,o)}const Jc=X({max_:$Q});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kQ(t,e=null,n=!1){const s={x:L(t,"x","min")},o={axis:e,keepDims:n};return Y.runKernel(Nw,s,o)}const pv=X({min_:kQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TQ(t,e){let n=L(t,"base","pow"),r=L(e,"exp","pow");[n,r]=yn(n,r);const s={a:n,b:r};return Y.runKernel(Ww,s)}const vf=X({pow_:TQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mt(t,e){if((uo(t)&&e!=="string"||Array.isArray(t))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&uo(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return kl(t,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IQ(t){const n={x:L(t,"x","sqrt","float32")};return Y.runKernel(fS,n)}const ma=X({sqrt_:IQ});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NQ(t){const e=L(t,"x","square"),n={};return Y.runKernel("Square",{x:e},n)}const ao=X({square_:NQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EQ(t,e=null,n=!1){let r=L(t,"x","sum");r.dtype==="bool"&&(r=Qt(r,"int32"));const s={x:r},o={axis:e,keepDims:n};return Y.runKernel(pS,s,o)}const en=X({sum_:EQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RQ(t,e="euclidean",n=null,r=!1){t=L(t,"x","norm");const s=oD(t,e,n);let o=s.shape;if(r){const i=nn(n,t.shape);o=xs(s.shape,i)}return ye(s,o)}function oD(t,e,n=null){if(t.rank===0)return Es(t);if(t.rank!==1&&n===null)return oD(ye(t,[-1]),e,n);if(t.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(e===1)return en(Es(t),n);if(e===1/0)return Jc(Es(t),n);if(e===-1/0)return pv(Es(t),n);if(e==="euclidean"||e===2)return ma(en(vf(Es(t),mt(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&n.length===2){if(e===1)return Jc(en(Es(t),n[0]),n[1]-1);if(e===1/0)return Jc(en(Es(t),n[1]),n[0]);if(e===-1/0)return pv(en(Es(t),n[1]),n[0]);if(e==="fro"||e==="euclidean")return ma(en(ao(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const cy=X({norm_:RQ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Q(t,e=null,n=!1){return cy(t,"euclidean",e,n)}const PQ=X({euclideanNorm_:_Q});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AQ(t){const n={x:L(t,"x","exp")};return Y.runKernel(X2,n)}const ga=X({exp_:AQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DQ(t,e=0){const n=L(t,"x","expandDims","string_or_numeric");z(e<=n.rank,()=>"Axis must be <= rank of the tensor");const r={input:n},s={dim:e};return Y.runKernel(q2,r,s)}const Rs=X({expandDims_:DQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OQ(t){const n={x:L(t,"x","expm1")};return Y.runKernel(Y2,n)}const FQ=X({expm1_:OQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LQ(t,e){const n=L(t,"x","tile","string_or_numeric");z(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`);const r={x:n},s={reps:e};return Y.runKernel(sy,r,s)}const Zh=X({tile_:LQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zQ(t,e,n,r="float32"){e==null&&(e=t);const s=Wt([t,e],r),o=t<=e?t:e;for(let a=0;a<o;++a)s.set(1,a,a);const i=ye(s.toTensor(),[t,e]);if(n==null)return i;if(n.length===1)return Zh(Rs(i,0),[n[0],1,1]);if(n.length===2)return Zh(Rs(Rs(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return Zh(Rs(Rs(Rs(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const iD=X({eye_:zQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BQ(t){const n={x:L(t,"x","floor","float32")};return Y.runKernel(ew,n)}const aD=X({floor_:BQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MQ(t,e,n=0,r=0){const s=L(t,"x","gather"),o=L(e,"indices","gather","int32"),i={x:s,indices:o},a={axis:n,batchDims:r};return Y.runKernel(rw,i,a)}const lD=X({gather_:MQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VQ(t,e){let n=L(t,"a","greater","string_or_numeric"),r=L(e,"b","greater","string_or_numeric");[n,r]=yn(n,r),ct(n.shape,r.shape);const s={a:n,b:r};return Y.runKernel(ow,s)}const dy=X({greater_:VQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WQ(t,e){let n=L(t,"a","greaterEqual","string_or_numeric"),r=L(e,"b","greaterEqual","string_or_numeric");[n,r]=yn(n,r),ct(n.shape,r.shape);const s={a:n,b:r};return Y.runKernel(iw,s)}const uD=X({greaterEqual_:WQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UQ(t){const n={input:L(t,"input","imag")};return Y.runKernel(lw,n)}const hy=X({imag_:UQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jQ(t){const n={x:L(t,"x","isFinite")};return Y.runKernel(uw,n)}const GQ=X({isFinite_:jQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HQ(t){const n={x:L(t,"x","isInf")};return Y.runKernel(cw,n)}const KQ=X({isInf_:HQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XQ(t){const n={x:L(t,"x","isNaN")};return Y.runKernel(dw,n)}const qQ=X({isNaN_:XQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YQ(t,e=.2){const r={x:L(t,"x","leakyRelu")},s={alpha:e};return Y.runKernel(hw,r,s)}const cD=X({leakyRelu_:YQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QQ(t,e){let n=L(t,"a","less","string_or_numeric"),r=L(e,"b","less","string_or_numeric");[n,r]=yn(n,r),ct(n.shape,r.shape);const s={a:n,b:r};return Y.runKernel(fw,s)}const mv=X({less_:QQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZQ(t,e){let n=L(t,"a","lessEqual","string_or_numeric"),r=L(e,"b","lessEqual","string_or_numeric");[n,r]=yn(n,r),ct(n.shape,r.shape);const s={a:n,b:r};return Y.runKernel(pw,s)}const BS=X({lessEqual_:ZQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JQ(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:t,stop:e,num:n};return Y.runKernel(mw,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eZ(t,e=5,n=1,r=1,s=.5){const o=L(t,"x","localResponseNormalization");z(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),z(id(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let i=o,a=!1;o.rank===3&&(a=!0,i=ye(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const l={x:i},c={depthRadius:e,bias:n,alpha:r,beta:s},d=Y.runKernel(ww,l,c);return a?ye(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const tZ=X({localResponseNormalization_:eZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nZ(t){const n={x:L(t,"x","log","float32")};return Y.runKernel(gw,n)}const bf=X({log_:nZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rZ(t){const n={x:L(t,"x","log1p")};return Y.runKernel(yw,n)}const dD=X({log1p_:rZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sZ(t,e){z(Jx(t),()=>"The f passed in variableGrads(f) must be a function"),z(e==null||Array.isArray(e)&&e.every(c=>c instanceof kg),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=e!=null;if(!n){e=[];for(const c in Y.registeredVariables)e.push(Y.registeredVariables[c])}const r=n?e.filter(c=>!c.trainable):null,s=e.length;e=e.filter(c=>c.trainable),z(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const o=!0,{value:i,grads:a}=Y.gradients(t,e,null,o);z(a.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),z(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const l={};return e.forEach((c,d)=>{a[d]!=null&&(l[c.name]=a[d])}),r!=null&&r.forEach(c=>l[c.name]=null),{value:i,grads:l}}function ya(t){return Y.customGrad(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oZ(t){const n={x:L(t,"x","neg")};return Y.runKernel(Dw,n)}const bi=X({neg_:oZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iZ(t){const n={x:L(t,"x","softplus")};return Y.runKernel(hS,n)}const hD=X({softplus_:iZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aZ(t){const e=L(t,"x","logSigmoid");return ya(r=>({value:bi(hD(bi(r))),gradFunc:i=>Te(i,aa(bi(r)))}))(e)}const lZ=X({logSigmoid_:aZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uZ(t,e){let n=L(t,"a","sub"),r=L(e,"b","sub");[n,r]=yn(n,r);const s={a:n,b:r};return Y.runKernel($S,s)}const ot=X({sub_:uZ});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cZ(t,e=-1){const n=L(t,"logits","logSoftmax");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return ya((s,o)=>{const a=Jc(s,e,!0),l=ot(s,a),c=ot(Qt(l,"float32"),bf(en(ga(l),e,!0)));return o([c]),{value:c,gradFunc:(f,p)=>{const[g]=p,y=!0,x=ga(g);return ot(f,Te(en(f,e,y),x))}}})(n)}const dZ=X({logSoftmax_:cZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hZ(t,e=null,n=!1){const r=L(t,"x","logSumExp"),s=nn(e,r.shape),o=Jc(r,s,!0),i=ot(r,o),a=ga(i),l=en(a,s),c=bf(l),d=We(ye(o,c.shape),c);if(n){const f=xs(d.shape,s);return ye(d,f)}return d}const fD=X({logSumExp_:hZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fZ(t,e){const n=L(t,"a","logicalAnd","bool"),r=L(e,"b","logicalAnd","bool");ct(n.shape,r.shape);const s={a:n,b:r};return Y.runKernel(xw,s)}const Ig=X({logicalAnd_:fZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pZ(t){const n={x:L(t,"x","logicalNot","bool")};return Y.runKernel(vw,n)}const pD=X({logicalNot_:pZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mZ(t,e){const n=L(t,"a","logicalOr","bool"),r=L(e,"b","logicalOr","bool");ct(n.shape,r.shape);const s={a:n,b:r};return Y.runKernel(bw,s)}const mD=X({logicalOr_:mZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gZ(t,e){const n=L(t,"a","logicalXor","bool"),r=L(e,"b","logicalXor","bool");return ct(n.shape,r.shape),Ig(mD(t,e),pD(Ig(t,e)))}const yZ=X({logicalXor_:gZ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vm=2147483648;function xZ(t,e,n="left"){const r=L(t,"sortedSequence","searchSorted"),s=L(e,"values","searchSorted"),o=r.shape[r.shape.length-1],i=s.shape[s.shape.length-1],a=ye(r,[-1,o]),l=ye(s,[-1,i]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(pe(l.shape)>=vm)throw new Error(`values tensor size must less than ${vm}`);if(a.shape[1]>=vm)throw new Error(`trailing dim_size must less than ${vm} for int32 output type, was ${a.shape[1]}`);const c={sortedSequence:a,values:l},d={side:n};return Y.runKernel(sS,c,d)}const MS=X({searchSorted_:xZ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vZ(t,e){return MS(t,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bZ(t,e,n,r,s){const o=L(t,"x","maxPool"),i=1;let a=o,l=!1;o.rank===3&&(l=!0,a=ye(o,[1,o.shape[0],o.shape[1],o.shape[2]])),z(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),z(Nr(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),po("maxPool",r,s);const c={x:a},d={filterSize:e,strides:n,pad:r,dimRoundingMode:s},f=Y.runKernel($w,c,d);return l?ye(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const gD=X({maxPool_:bZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wZ(t,e=[1,1,1],n,r,s,o="NDHWC"){const i=L(t,"x","maxPool3d");let a=i,l=!1;i.rank===4&&(l=!0,a=ye(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),z(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),z(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),po("maxPool3d",r,s);const c={x:a},d={filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:o},f=Y.runKernel(kw,c,d);return l?ye(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const SZ=X({maxPool3d_:wZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CZ(t,e,n,r,s=!1){const i={x:L(t,"x","maxPoolWithArgmax")},a={filterSize:e,strides:n,pad:r,includeBatchInIndex:s},l=Y.runKernel(Tw,i,a);return{result:l[0],indexes:l[1]}}const $Z=X({maxPoolWithArgmax_:CZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kZ(t,e){let n=L(t,"a","maximum"),r=L(e,"b","maximum");[n,r]=yn(n,r),n.dtype==="bool"&&(n=Qt(n,"int32"),r=Qt(r,"int32")),ct(n.shape,r.shape);const s={a:n,b:r};return Y.runKernel(Cw,s)}const yD=X({maximum_:kZ});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TZ(t,e=null,n=!1){const s={x:L(t,"x","mean")},o={axis:e,keepDims:n};return Y.runKernel(Iw,s,o)}const Ng=X({mean_:TZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xa(t,e="float32"){if(Os(t),e==="complex64"){const r=xa(t,"float32"),s=xa(t,"float32");return yl(r,s)}const n=ha(pe(t),e);return Y.makeTensor(n,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bu(t,e="float32"){if(Os(t),e==="complex64"){const r=bu(t,"float32"),s=xa(t,"float32");return yl(r,s)}const n=GP(pe(t),e);return Y.makeTensor(n,t,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IZ(t,e,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(t===void 0)return[];let r=L(t,"x","meshgrid",t instanceof fn?t.dtype:"float32");if(e===void 0)return[r];let s=L(e,"y","meshgrid",e instanceof fn?e.dtype:"float32");const o=pe(r.shape),i=pe(s.shape);return n==="xy"?(r=ye(r,[1,-1]),s=ye(s,[-1,1]),[Ht(bu([i,1],r.dtype),r),Ht(s,bu([1,o],s.dtype))]):(r=ye(r,[-1,1]),s=ye(s,[1,-1]),[Ht(r,bu([1,i],r.dtype)),Ht(bu([o,1],s.dtype),s)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NZ(t,e){let n=L(t,"a","minimum"),r=L(e,"b","minimum");[n,r]=yn(n,r),n.dtype==="bool"&&(n=Qt(n,"int32"),r=Qt(r,"int32")),ct(n.shape,r.shape);const s={a:n,b:r};return Y.runKernel(Ew,s)}const wf=X({minimum_:NZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EZ(t,e,n){z(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const r=L(t,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");z(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const s=n==="reflect"?1:0;for(let a=0;a<r.rank;a++)z(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),z(e[a][0]>=0&&e[a][0]<=r.shape[a]-s&&e[a][1]>=0&&e[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);const o={paddings:e,mode:n},i={x:r};return Y.runKernel(Rw,i,o)}const xD=X({mirrorPad_:EZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RZ(t,e){let n=L(t,"a","mod"),r=L(e,"b","mod");[n,r]=yn(n,r);const s={a:n,b:r};return Y.runKernel(_w,s)}const _Z=X({mod_:RZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PZ(t,e=null,n=!1){t=L(t,"x","moments");const r=nn(e,t.shape),s=Ng(t,r,n);let o=s.shape;n||(o=xs(s.shape,r));const i=ao(ot(Qt(t,"float32"),ye(s,o))),a=Ng(i,r,n);return{mean:s,variance:a}}const AZ=X({moments_:PZ});function DZ(t,e,n,r){const s=L(e,"data","multiRNNCell"),o=Tg(n,"c","multiRNNCell"),i=Tg(r,"h","multiRNNCell");let a=s;const l=[];for(let f=0;f<t.length;f++){const p=t[f](a,o[f],i[f]);l.push(p[0]),l.push(p[1]),a=p[1]}const c=[],d=[];for(let f=0;f<l.length;f+=2)c.push(l[f]),d.push(l[f+1]);return[c,d]}const OZ=X({multiRNNCell_:DZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FZ(t,e,n,r=!1){const s=L(t,"logits","multinomial"),o=s.size,i=s.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const l={logits:i===1?ye(s,[1,-1]):s},c={numSamples:e,seed:n,normalized:r},d=Y.runKernel(Pw,l,c);return i===1?ye(d,[d.size]):d}const LZ=X({multinomial_:FZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zZ(t,e){let n=L(t,"a","notEqual","string_or_numeric"),r=L(e,"b","notEqual","string_or_numeric");[n,r]=yn(n,r),ct(n.shape,r.shape);const s={a:n,b:r};return Y.runKernel(Ow,s)}const vD=X({notEqual_:zZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BZ(t,e,n=1,r=0,s="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const i={indices:L(t,"indices","oneHot","int32")},a={dtype:s,depth:e,onValue:n,offValue:r};return Y.runKernel(Bw,i,a)}const MZ=X({oneHot_:BZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VZ(t){const n={x:L(t,"x","onesLike")};return Y.runKernel(zw,n)}const WZ=X({onesLike_:VZ});function UZ(t,e){const n=L(t,"v1","outerProduct"),r=L(e,"v2","outerProduct");z(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);const s=ye(n,[-1,1]),o=ye(r,[1,-1]);return Ht(s,o)}const jZ=X({outerProduct_:UZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GZ(t,e,n=0){const r=L(t,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:n},o={x:r};return Y.runKernel(Vw,o,s)}const vl=X({pad_:GZ});function HZ(t,e,n=0){return z(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),vl(t,[e],n)}const KZ=X({pad1d_:HZ});function XZ(t,e,n=0){return z(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),vl(t,e,n)}const qZ=X({pad2d_:XZ});function YZ(t,e,n=0){return z(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),vl(t,e,n)}const QZ=X({pad3d_:YZ});function ZZ(t,e,n=0){return z(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),vl(t,e,n)}const JZ=X({pad4d_:ZZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eJ(t,e,n){const r=L(t,"x","spaceToBatchND");z(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),z(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),z(r.shape.reduce((i,a,l)=>l>0&&l<=e.length?i&&(a+n[l-1][0]+n[l-1][1])%e[l-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:r},o={blockShape:e,paddings:n};return Y.runKernel(mS,s,o)}const bD=X({spaceToBatchND_:eJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tJ(t,e,n,r,s,o,i){s==null&&(s=[1,1]),o==null&&(o=1),r===0&&(r="valid");const a=L(t,"x","maxPool");let l=a,c=!1;a.rank===3&&(c=!0,l=ye(a,[1,a.shape[0],a.shape[1],a.shape[2]])),z(Nr(o,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${s}'`);const d=fo(l.shape,e,o,s,r),f=[d.dilationHeight,d.dilationWidth];let p;r==="same"?p=rJ([d.filterHeight,d.filterWidth],f):p=[[0,0],[0,0]];const g=f[0]===1&&f[1]===1,[y,x]=nJ([d.inHeight,d.inWidth],f,p),w=g?r:"valid",S=g?l:bD(l,f,y),I=(n==="avg"?()=>YA(S,e,o,w,i):()=>gD(S,e,o,w,i))(),R=g?I:QA(I,f,x);return c?ye(R,[R.shape[1],R.shape[2],R.shape[3]]):R}function nJ(t,e,n){const r=n.map(d=>d[0]),s=n.map(d=>d[1]),o=t.concat(r,s),i=e.map((d,f)=>(d-o[f]%d)%d),a=s.map((d,f)=>d+i[f]),l=e.map((d,f)=>[r[f],a[f]]),c=e.map((d,f)=>[0,i[f]]);return[l,c]}function rJ(t,e){const r=t.map((i,a)=>i+(i-1)*(e[a]-1)).map(i=>i-1),s=r.map(i=>Math.floor(i/2)),o=r.map((i,a)=>i-s[a]);return r.map((i,a)=>[s[a],o[a]])}const sJ=X({pool_:tJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oJ(t,e){const n=L(t,"x","prelu"),r=L(e,"alpha","prelu"),s={x:n,alpha:r};return Y.runKernel(Uw,s)}const wD=X({prelu_:oJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iJ(t,e=null,n=!1){let r=L(t,"x","prod");r.dtype==="bool"&&(r=Qt(r,"int32"));const s={x:r},o={axis:e,keepDims:n};return Y.runKernel(jw,s,o)}const aJ=X({prod_:iJ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lJ(t,e,n,r){const s=t.map((d,f)=>L(d,`tensors${f}`,"raggedGather","int32")),o=L(e,"paramsDenseValues","raggedGather"),i=L(n,"indices","raggedGather","int32"),a={paramsNestedSplits:s,paramsDenseValues:o,indices:i},l={outputRaggedRank:r},c=Y.runKernel(sA,a,l);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}const uJ=X({raggedGather_:lJ});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cJ(t,e,n){const r=L(t,"starts","raggedRange"),s=L(e,"limits","raggedRange",r.dtype),o=L(n,"deltas","raggedRange",r.dtype),i={starts:r,limits:s,deltas:o},a=Y.runKernel(oA,i);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}const dJ=X({raggedRange_:cJ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hJ(t,e,n,r,s){const o=L(t,"shape","raggedTensorToTensor","int32"),i=L(e,"values","raggedTensorToTensor"),a=L(n,"defaultValue","raggedTensorToTensor",i.dtype),l=r.map((f,p)=>L(f,`tensors${p}`,"raggedTensorToTensor","int32")),c={shape:o,values:i,defaultValue:a,rowPartitionTensors:l},d={rowPartitionTypes:s};return Y.runKernel(iA,c,d)}const fJ=X({raggedTensorToTensor_:hJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pJ(t,e,n){Os(t);const r=pe(t);let s=null;if(n==null||n==="float32")s=new Float32Array(r);else if(n==="int32")s=new Int32Array(r);else if(n==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let o=0;o<r;o++)s[o]=e();return Y.makeTensor(s,t,n)}const mJ=X({rand_:pJ});var Hm={exports:{}},gJ=Hm.exports,SI;function yJ(){return SI||(SI=1,function(t){(function(e,n,r){function s(l){var c=this,d=a();c.next=function(){var f=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=f-(c.c=f|0)},c.c=1,c.s0=d(" "),c.s1=d(" "),c.s2=d(" "),c.s0-=d(l),c.s0<0&&(c.s0+=1),c.s1-=d(l),c.s1<0&&(c.s1+=1),c.s2-=d(l),c.s2<0&&(c.s2+=1),d=null}function o(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function i(l,c){var d=new s(l),f=c&&c.state,p=d.next;return p.int32=function(){return d.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,f&&(typeof f=="object"&&o(f,d),p.state=function(){return o(d,{})}),p}function a(){var l=4022871197,c=function(d){d=String(d);for(var f=0;f<d.length;f++){l+=d.charCodeAt(f);var p=.02519603282416938*l;l=p>>>0,p-=l,p*=l,l=p>>>0,p-=l,l+=p*4294967296}return(l>>>0)*23283064365386963e-26};return c}n&&n.exports?n.exports=i:this.alea=i})(gJ,t)}(Hm)),Hm.exports}var Km={exports:{}},xJ=Km.exports,CI;function vJ(){return CI||(CI=1,function(t){(function(e,n,r){function s(a){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var f=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^f^f>>>8},a===(a|0)?l.x=a:c+=a;for(var d=0;d<c.length+64;d++)l.x^=c.charCodeAt(d)|0,l.next()}function o(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function i(a,l){var c=new s(a),d=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(p+g)/(1<<21);while(y===0);return y},f.int32=c.next,f.quick=f,d&&(typeof d=="object"&&o(d,c),f.state=function(){return o(c,{})}),f}n&&n.exports?n.exports=i:this.xor128=i})(xJ,t)}(Km)),Km.exports}var Xm={exports:{}},bJ=Xm.exports,$I;function wJ(){return $I||($I=1,function(t){(function(e,n,r){function s(a){var l=this,c="";l.next=function(){var f=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(f^f<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:c+=a;for(var d=0;d<c.length+64;d++)l.x^=c.charCodeAt(d)|0,d==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function o(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function i(a,l){var c=new s(a),d=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(p+g)/(1<<21);while(y===0);return y},f.int32=c.next,f.quick=f,d&&(typeof d=="object"&&o(d,c),f.state=function(){return o(c,{})}),f}n&&n.exports?n.exports=i:this.xorwow=i})(bJ,t)}(Xm)),Xm.exports}var qm={exports:{}},SJ=qm.exports,kI;function CJ(){return kI||(kI=1,function(t){(function(e,n,r){function s(a){var l=this;l.next=function(){var d=l.x,f=l.i,p,g;return p=d[f],p^=p>>>7,g=p^p<<24,p=d[f+1&7],g^=p^p>>>10,p=d[f+3&7],g^=p^p>>>3,p=d[f+4&7],g^=p^p<<7,p=d[f+7&7],p=p^p<<13,g^=p^p<<9,d[f]=g,l.i=f+1&7,g};function c(d,f){var p,g=[];if(f===(f|0))g[0]=f;else for(f=""+f,p=0;p<f.length;++p)g[p&7]=g[p&7]<<15^f.charCodeAt(p)+g[p+1&7]<<13;for(;g.length<8;)g.push(0);for(p=0;p<8&&g[p]===0;++p);for(p==8?g[7]=-1:g[p],d.x=g,d.i=0,p=256;p>0;--p)d.next()}c(l,a)}function o(a,l){return l.x=a.x.slice(),l.i=a.i,l}function i(a,l){a==null&&(a=+new Date);var c=new s(a),d=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(p+g)/(1<<21);while(y===0);return y},f.int32=c.next,f.quick=f,d&&(d.x&&o(d,c),f.state=function(){return o(c,{})}),f}n&&n.exports?n.exports=i:this.xorshift7=i})(SJ,t)}(qm)),qm.exports}var Ym={exports:{}},$J=Ym.exports,TI;function kJ(){return TI||(TI=1,function(t){(function(e,n,r){function s(a){var l=this;l.next=function(){var d=l.w,f=l.X,p=l.i,g,y;return l.w=d=d+1640531527|0,y=f[p+34&127],g=f[p=p+1&127],y^=y<<13,g^=g<<17,y^=y>>>15,g^=g>>>12,y=f[p]=y^g,l.i=p,y+(d^d>>>16)|0};function c(d,f){var p,g,y,x,w,S=[],$=128;for(f===(f|0)?(g=f,f=null):(f=f+"\0",g=0,$=Math.max($,f.length)),y=0,x=-32;x<$;++x)f&&(g^=f.charCodeAt((x+32)%f.length)),x===0&&(w=g),g^=g<<10,g^=g>>>15,g^=g<<4,g^=g>>>13,x>=0&&(w=w+1640531527|0,p=S[x&127]^=g+w,y=p==0?y+1:0);for(y>=128&&(S[(f&&f.length||0)&127]=-1),y=127,x=4*128;x>0;--x)g=S[y+34&127],p=S[y=y+1&127],g^=g<<13,p^=p<<17,g^=g>>>15,p^=p>>>12,S[y]=g^p;d.w=w,d.X=S,d.i=y}c(l,a)}function o(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function i(a,l){a==null&&(a=+new Date);var c=new s(a),d=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(p+g)/(1<<21);while(y===0);return y},f.int32=c.next,f.quick=f,d&&(d.X&&o(d,c),f.state=function(){return o(c,{})}),f}n&&n.exports?n.exports=i:this.xor4096=i})($J,t)}(Ym)),Ym.exports}var Qm={exports:{}},TJ=Qm.exports,II;function IJ(){return II||(II=1,function(t){(function(e,n,r){function s(a){var l=this,c="";l.next=function(){var f=l.b,p=l.c,g=l.d,y=l.a;return f=f<<25^f>>>7^p,p=p-g|0,g=g<<24^g>>>8^y,y=y-f|0,l.b=f=f<<20^f>>>12^p,l.c=p=p-g|0,l.d=g<<16^p>>>16^y,l.a=y-f|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):c+=a;for(var d=0;d<c.length+20;d++)l.b^=c.charCodeAt(d)|0,l.next()}function o(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function i(a,l){var c=new s(a),d=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(p+g)/(1<<21);while(y===0);return y},f.int32=c.next,f.quick=f,d&&(typeof d=="object"&&o(d,c),f.state=function(){return o(c,{})}),f}n&&n.exports?n.exports=i:this.tychei=i})(TJ,t)}(Qm)),Qm.exports}var Zm={exports:{}};const NJ={},EJ=Object.freeze(Object.defineProperty({__proto__:null,default:NJ},Symbol.toStringTag,{value:"Module"})),RJ=rL(EJ);var _J=Zm.exports,NI;function PJ(){return NI||(NI=1,function(t){(function(e,n,r){var s=256,o=6,i=52,a="random",l=r.pow(s,o),c=r.pow(2,i),d=c*2,f=s-1,p;function g(R,_,O){var F=[];_=_==!0?{entropy:!0}:_||{};var B=S(w(_.entropy?[R,I(n)]:R??$(),3),F),M=new y(F),V=function(){for(var P=M.g(o),re=l,ie=0;P<c;)P=(P+ie)*s,re*=s,ie=M.g(1);for(;P>=d;)P/=2,re/=2,ie>>>=1;return(P+ie)/re};return V.int32=function(){return M.g(4)|0},V.quick=function(){return M.g(4)/4294967296},V.double=V,S(I(M.S),n),(_.pass||O||function(P,re,ie,me){return me&&(me.S&&x(me,M),P.state=function(){return x(M,{})}),ie?(r[a]=P,re):P})(V,B,"global"in _?_.global:this==r,_.state)}function y(R){var _,O=R.length,F=this,B=0,M=F.i=F.j=0,V=F.S=[];for(O||(R=[O++]);B<s;)V[B]=B++;for(B=0;B<s;B++)V[B]=V[M=f&M+R[B%O]+(_=V[B])],V[M]=_;(F.g=function(P){for(var re,ie=0,me=F.i,ge=F.j,ve=F.S;P--;)re=ve[me=f&me+1],ie=ie*s+ve[f&(ve[me]=ve[ge=f&ge+re])+(ve[ge]=re)];return F.i=me,F.j=ge,ie})(s)}function x(R,_){return _.i=R.i,_.j=R.j,_.S=R.S.slice(),_}function w(R,_){var O=[],F=typeof R,B;if(_&&F=="object")for(B in R)try{O.push(w(R[B],_-1))}catch{}return O.length?O:F=="string"?R:R+"\0"}function S(R,_){for(var O=R+"",F,B=0;B<O.length;)_[f&B]=f&(F^=_[f&B]*19)+O.charCodeAt(B++);return I(_)}function $(){try{var R;return p&&(R=p.randomBytes)?R=R(s):(R=new Uint8Array(s),(e.crypto||e.msCrypto).getRandomValues(R)),I(R)}catch{var _=e.navigator,O=_&&_.plugins;return[+new Date,e,O,e.screen,I(n)]}}function I(R){return String.fromCharCode.apply(0,R)}if(S(r.random(),n),t.exports){t.exports=g;try{p=RJ}catch{}}else r["seed"+a]=g})(typeof self<"u"?self:_J,[],Math)}(Zm)),Zm.exports}var K1,EI;function AJ(){if(EI)return K1;EI=1;var t=yJ(),e=vJ(),n=wJ(),r=CJ(),s=kJ(),o=IJ(),i=PJ();return i.alea=t,i.xor128=e,i.xorwow=n,i.xorshift7=r,i.xor4096=s,i.tychei=o,K1=i,K1}var VS=AJ();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WS{constructor(e,n,r,s,o){this.mean=e,this.stdDev=n,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const i=o||Math.random();this.random=VS.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,n,r=!1;for(;!r;){let s,o,i;do s=2*this.random()-1,o=2*this.random()-1,i=s*s+o*o;while(i>=1||i===0);const a=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*s*a,n=this.mean+this.stdDev*o*a,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class DJ{constructor(e,n,r,s){this.alpha=e,this.beta=1/n,this.dtype=r;const o=s||Math.random();this.randu=VS.alea(o.toString()),this.randn=new WS(0,1,r,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,n,r,s,o,i;for(;;){do s=this.randn.nextValue(),i=1+this.c*s;while(i<=0);if(i*=i*i,e=s*s,n=1-.331*e*e,r=.5*e+this.d*(1-i+Math.log(i)),o=this.randu(),o<n||Math.log(o)<r)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class OJ{constructor(e=0,n=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=n-e,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${n} <= 1 and dtype is not float`);this.random=VS.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FJ(t,e,n=1,r="float32",s){if(Os(t),n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);const o=new DJ(e,n,r,s),i=Wt(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const LJ=X({randomGamma_:FJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zJ(t,e=0,n=1,r,s){if(Os(t),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const o=new WS(e,n,r,!1,s),i=Wt(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const SD=X({randomNormal_:zJ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BJ(t,e,n){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return SD(t,0,1,e,n)}const MJ=X({randomStandardNormal_:BJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VJ(t,e=0,n=1,r="float32",s){Os(t);const o=Wt(t,r),i=new OJ(e,n,null,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const US=X({randomUniform_:VJ});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WJ(t,e,n,r){return US(t,e,n,"int32",r)}const UJ=X({randomUniformInt_:WJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sf(t,e,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");const s={start:t,stop:e,step:n,dtype:r};return Y.runKernel(Gw,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jJ(t){const n={input:L(t,"input","real")};return Y.runKernel(Hw,n)}const Cf=X({real_:jJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GJ(t){const n={x:L(t,"x","reciprocal")};return Y.runKernel(Kw,n)}const HJ=X({reciprocal_:GJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KJ(t){const n={x:L(t,"x","relu")};return Y.runKernel(Xw,n)}const fy=X({relu_:KJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XJ(t){const n={x:L(t,"x","relu6")};return Y.runKernel(Zw,n)}const CD=X({relu6_:XJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qJ(t,e){const r={x:L(t,"x","reverse")},s={dims:e};return Y.runKernel(Jw,r,s)}const Ou=X({reverse_:qJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YJ(t){const e=L(t,"x","reverse");return z(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Ou(e,0)}const QJ=X({reverse1d_:YJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZJ(t,e){const n=L(t,"x","reverse");return z(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),Ou(n,e)}const JJ=X({reverse2d_:ZJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eee(t,e){const n=L(t,"x","reverse");return z(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),Ou(n,e)}const tee=X({reverse3d_:eee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nee(t,e){const n=L(t,"x","reverse");return z(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),Ou(n,e)}const ree=X({reverse4d_:nee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function see(t){const n={x:L(t,"x","round")};return Y.runKernel(eS,n)}const $D=X({round_:see});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oee(t){const n={x:L(t,"x","rsqrt","float32")};return Y.runKernel(tS,n)}const iee=X({rsqrt_:oee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aee(t){const n={x:L(t,"x","selu")};return Y.runKernel(iS,n)}const lee=X({selu_:aee});function uee(t,e,n,r,s,o=[1,1],i="NHWC"){const a=L(t,"x","separableConv2d"),l=L(e,"depthwiseFilter","separableConv2d"),c=L(n,"pointwiseFilter","separableConv2d");let d=a,f=!1;if(a.rank===3&&(f=!0,d=ye(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");z(d.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${d.rank}.`),z(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),z(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),z(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),z(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const p=l.shape[2],g=l.shape[3];z(c.shape[2]===p*g,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*g}, but got ${c.shape[2]}.`);const y=LS(d,l,r,s,i,o),w=uy(y,c,1,"valid",i);return f?ye(w,[w.shape[1],w.shape[2],w.shape[3]]):w}const cee=X({separableConv2d_:uee});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function dee(t,e){const n=L(t,"x","setdiff1d"),r=L(e,"y","setdiff1d");z(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),z(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),z(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await n.data(),o=await r.data(),i=new Set(o);let a=0;for(let d=0;d<s.length;d++)i.has(s[d])||a++;const l=new ad([a],n.dtype),c=new ad([a],"int32");for(let d=0,f=0;d<s.length;d++)i.has(s[d])||(l.values[f]=s[d],c.values[f]=d,f++);return[l.toTensor(),c.toTensor()]}const hee=dee;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fee(t){const n={x:L(t,"x","sign")};return Y.runKernel(cS,n)}const pee=X({sign_:fee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mee(t){const n={x:L(t,"x","sin","float32")};return Y.runKernel(lS,n)}const gee=X({sin_:mee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yee(t){const n={x:L(t,"x","sinh")};return Y.runKernel(uS,n)}const xee=X({sinh_:yee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vee(t,e,n){const r=L(t,"x","slice1d");return z(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),pt(r,[e],[n])}const bee=X({slice1d_:vee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wee(t,e,n){const r=L(t,"x","slice2d");return z(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),pt(r,e,n)}const See=X({slice2d_:wee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cee(t,e,n){const r=L(t,"x","slice3d");return z(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),pt(r,e,n)}const $ee=X({slice3d_:Cee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kee(t,e,n){const r=L(t,"x","slice4d");return z(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),pt(r,e,n)}const Tee=X({slice4d_:kee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iee(t,e=-1){const n=L(t,"logits","softmax","float32");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const r={logits:n},s={dim:e};return Y.runKernel(yS,r,s)}const Nee=X({softmax_:Iee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eee(t){z(t.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);const e={input:t};return Y.runKernel(Q2,e)}const jS=X({fft_:Eee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ree(t){z(t.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);const e={input:t};return Y.runKernel(aw,e)}const Eg=X({ifft_:Ree});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ee(t){const e=t.shape[t.shape.length-1],n=t.size/e;let r;if(e<=2){const s=ye(t,[n,e]);r=Eg(s)}else{const s=[n,2*(e-1)],o=ye(Cf(t),[n,e]),i=ye(hy(t),[n,e]),a=Ou(pt(o,[0,1],[n,e-2]),1),l=Te(Ou(pt(i,[0,1],[n,e-2]),1),mt(-1)),c=Fn([o,a],1),d=Fn([i,l],1),f=ye(yl(c,d),[s[0],s[1]]);r=Eg(f)}if(r=Cf(r),t.rank===3&&t.shape[0]!==0){const s=r,o=t.shape[0];r=ye(r,[o,r.shape[0]/o,r.shape[1]]),s.dispose()}return r}const kD=X({irfft_:_ee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pee(t,e,n=0){const s={x:L(t,"x","split")},o={numOrSizeSplits:e,axis:n};return Y.runKernel(gS,s,o)}const $f=X({split_:Pee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aee(t,e){z(t.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const r=t.size/n;let s;if(e!=null&&e<n){const y=t.shape.map(w=>0),x=t.shape.map(w=>w);x[t.shape.length-1]=e,s=pt(t,y,x),n=e}else if(e!=null&&e>n){const y=t.shape.map(x=>x);y[t.shape.length-1]=e-n,s=Fn([t,xa(y)],t.shape.length-1),n=e}else s=t;const o=Ds(s),i=ye(yl(s,o),[r,n]),a=jS(i),l=Math.floor(n/2)+1,c=Cf(a),d=hy(a),f=$f(c,[l,n-l],c.shape.length-1),p=$f(d,[l,n-l],d.shape.length-1),g=s.shape.slice();return g[s.shape.length-1]=l,ye(yl(f[0],p[0]),g)}const GS=X({rfft_:Aee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dee(t,e){let n=L(t,"a","squaredDifference"),r=L(e,"b","squaredDifference");[n,r]=yn(n,r),ct(n.shape,r.shape);const s={a:n,b:r},o={};return Y.runKernel(wS,s,o)}const TD=X({squaredDifference_:Dee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oee(t,e){const n=L(t,"x","squeeze","string_or_numeric");return ye(n,Cl(n.shape,e).newShape)}const Gt=X({squeeze_:Oee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fee(t,e=0){const n=Tg(t,"tensors","stack","string_or_numeric");z(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&z(e<=n[0].rank,()=>"Axis must be <= rank of the tensor");const r=n,s={axis:e};return Y.runKernel(Mw,r,s)}const va=X({stack_:Fee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lee(t,e=0){const r={x:L(t,"x","step")},s={alpha:e};return Y.runKernel(PS,r,s)}const ID=X({step_:Lee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zee(t,e,n,r,s=0,o=0,i=0,a=0,l=0){const d={x:L(t,"x","stridedSlice","string_or_numeric")},f={begin:e,end:n,strides:r,beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};return Y.runKernel(SS,d,f)}const Bee=X({stridedSlice_:zee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mee(t){const n={x:L(t,"x","tan","float32")};return Y.runKernel(kS,n)}const Vee=X({tan_:Mee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ar(t,e){Cd(t);const n=$l(t,e);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return kl(t,null,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lo(t,e,n){if(Cd(t),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=$l(t,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return kl(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ND(t,e,n){if(Cd(t),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=$l(t,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return kl(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wee(t,e,n){if(Cd(t),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=$l(t,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return kl(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uee(t,e,n){if(Cd(t),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const r=$l(t,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return kl(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jee(t,e,n){if(Cd(t),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const r=$l(t,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,kl(t,e,r,n)}function ED(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(o+` update.rank < ${s}. `);if(t.length<r+(n.rank-s))throw new Error(o+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+t.length-r)throw new Error(o+` update.rank != ${s+t.length-r}`);for(let i=0;i<s;++i)if(n.shape[i]!==e.shape[i])throw new Error(o+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${e.shape[i]}).`);for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==t[i+r])throw new Error(o+` updates.shape[${i+s}] (${n.shape[i+s]}) != shape[${i+s}] (${t[i+s]})`)}function HS(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(t.size===0)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}ED(n,e,t)}function Bu(t,e,n){const r=e.shape.length,s=r>1?e.shape[r-1]:1,o=n.length;let i=1;for(let f=s;f<o;++f)i*=n[f];const a=s<1?1:s,l=pe(e.shape)/a,c=[...gn(n.slice(0,s)),1],d=pe(n);return{sliceRank:s,numUpdates:l,sliceSize:i,strides:c,outputSize:d}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gee(t,e,n){const r=L(t,"tensor","tensorScatterupdate"),s=L(e,"indices","tensorScatterupdate","int32"),o=L(n,"updates","tensorScatterupdate");if(HS(o,s,r.shape),r.dtype!==o.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${o.dtype}.`);const i={tensor:r,indices:s,updates:o},a={};return Y.runKernel(rS,i,a)}const Hee=X({tensorScatterUpdate_:Gee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kee(t,e=1,n=!0){const r=L(t,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const o={x:r},i={k:e,sorted:n},[a,l]=Y.runKernel(IS,o,i);return{values:a,indices:l}}const Xee=X({topk_:Kee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qee(t,e=0,n=1,r,s){if(Os(t),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const o=new WS(e,n,r,!0,s),i=Wt(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const Yee=X({truncatedNormal_:qee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qee(t,e=0){const n=L(t,"x","unique","string_or_numeric");z(n.rank>0,()=>"The input tensor must be at least 1D");const r={x:n},s={axis:e},[o,i]=Y.runKernel(mA,r,s);return{values:o,indices:i}}const Zee=X({unique_:Qee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jee(t,e,n){const r=L(t,"x","unsortedSegmentSum"),s=L(e,"segmentIds","unsortedSegmentSum","int32");z(id(n),()=>"numSegments must be of dtype int");const o={x:r,segmentIds:s},i={numSegments:n};return Y.runKernel(RS,o,i)}const ete=X({unsortedSegmentSum_:Jee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tte(t,e=0){const n=L(t,"x","unstack","string_or_numeric");z(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`);const r={value:n},s={axis:e};return Y.runKernel(ES,r,s)}const Mu=X({unstack_:tte});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nte(t,e){return MS(t,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rte(t,e=!0,n,r){return Y.makeVariable(t,e,n,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RD(t,e){const n=[];for(let o=0;o<e.length;o++)e[o]&&n.push(o);const r=Wt(t,"int32"),s=Wt([n.length,t.length],"int32");for(let o=0;o<n.length;o++){const i=r.indexToLoc(n[o]),a=o*t.length;s.values.set(i,a)}return s.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function ste(t){const e=L(t,"condition","whereAsync","bool"),n=await e.data(),r=RD(e.shape,n);return t!==e&&e.dispose(),r}const _D=ste;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function ote(t,e,n){const r=L(t,"tensor","boolMask"),s=L(e,"mask","boolMask","bool"),o=n??0,i=s.rank,a=r.shape;z(i>0,()=>"mask cannot be scalar"),ys(a.slice(o,o+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let x=o;x<o+i;x++)l*=a[x];const c=a.slice(0,o).concat([l],a.slice(o+i)),d=ye(r,c),f=ye(s,[-1]),p=await _D(f),g=Gt(p,[1]),y=lD(d,g,o);return t!==r&&r.dispose(),e!==s&&s.dispose(),g.dispose(),d.dispose(),f.dispose(),p.dispose(),y}const ite=ote;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ate(t,e,n){const r=L(t,"x","transpose");if(e==null&&(e=r.shape.map((i,a)=>a).reverse()),z(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(i=>{z(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();const s={x:r},o={perm:e};return r.dtype==="complex64"?nt(()=>{let i=Cf(r),a=hy(r);return i=Y.runKernel(Yh,{x:i},o),a=Y.runKernel(Yh,{x:a},o),n&&(a=bi(a)),yl(i,a)}):Y.runKernel(Yh,s,o)}const gv=X({transpose_:ate});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lte(t,e,n,r,s=!0){const o=L(t,"v","movingAverage"),i=L(e,"x","movingAverage"),a=L(n,"decay","movingAverage");RX(o,i),z(Vt(o.shape,i.shape),()=>"Shape mismatch in v and x");const l=mt(1),c=ot(l,a);let d=Te(ot(i,o),c);if(s){z(r!=null,()=>"When using zeroDebias: true, step is required.");const f=L(r,"step","movingAverage");d=gt(d,ot(l,vf(a,f)))}return We(o,d)}const ute=X({movingAverage_:lte});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cte(t,e,n){Os(n);const r=L(t,"indices","scatterND","int32"),s=L(e,"updates","scatterND");HS(s,r,n);const o={indices:r,updates:s},i={shape:n};return Y.runKernel(nS,o,i)}const dte=X({scatterND_:cte});function hte(t,e,n,r){if(t.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const s=t.rank>0?t.shape[0]:1,o=t.rank>1?t.shape[1]:1;if(n.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${o}.`);const i=e.size;if(!(e.rank===0||e.rank===1&&i===s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fte(t,e,n,r=0){Os(n);const s=L(t,"sparseIndices","sparseToDense","int32"),o=L(e,"sparseValues","sparseToDense","string_or_numeric"),i=L(r,"defaultValue","sparseToDense",o.dtype);hte(s,o,n,i);const a={sparseIndices:s,sparseValues:o,defaultValue:i},l={outputShape:n};return Y.runKernel(bS,a,l)}const pte=X({sparseToDense_:fte});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mte(t,e){const n=L(e,"indices","gatherND","int32"),s={params:L(t,"x","gatherND","string_or_numeric"),indices:n};return Y.runKernel(sw,s)}const gte=X({gatherND_:mte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yte(t,e){if(e==null)return t.shape.slice();if(Vt(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)e[r]==null&&t.shape[r]!=null?n.push(t.shape[r]):n.push(e[r]);return n}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xte(t,e,n,r){const s=L(t,"x","dropout");if(z(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),z(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return t instanceof fn?s.clone():s;const o=yte(s,n),i=1-e,a=gt(aD(We(US(o,0,1,"float32",r),i)),i);return Te(s,a)}const vte=X({dropout_:xte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PD(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function KS(t,e,n){const r=1-t%2,s=new Float32Array(t);for(let o=0;o<t;++o){const i=2*Math.PI*o/(t+r-1);s[o]=e-n*Math.cos(i)}return ar(s,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function bte(t,e,n=1){const r=L(t,"predictions","inTopK"),s=L(e,"targets","inTopK");z(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),z(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),ys(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=r.shape[r.shape.length-1];z(n>0&&n<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${n}`);const i=await r.data(),a=await s.data(),[l,c]=[i.length/o,o],d=Si("bool",l);for(let f=0;f<l;f++){const p=f*c,g=i.subarray(p,p+c),y=[];for(let x=0;x<g.length;x++)y.push({value:g[x],index:x});y.sort((x,w)=>w.value-x.value),d[f]=0;for(let x=0;x<n;x++)if(y[x].index===a[f]){d[f]=1;break}}return t!==r&&r.dispose(),e!==s&&s.dispose(),vi(d,s.shape,"bool")}const wte=bte;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ste(t,e,n,r,s,o="NHWC",i){let a=t;t.rank===3&&(a=ye(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=ye(e,[1,e.shape[0],e.shape[1],e.shape[2]])),z(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),z(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),z(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const c=o==="NHWC"?a.shape[3]:a.shape[1],d=o==="NHWC"?l.shape[3]:l.shape[1];z(c===n[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${n[2]}.`),z(d===n[3],()=>`Error in conv2dDerFilter: depth of dy (${d}) must match output depth for filter (${n[3]}).`),po("conv2dDerFilter",s,i);const f={x:a,dy:l},p={strides:r,pad:s,dataFormat:o,dimRoundingMode:i,filterShape:n};return Y.runKernel(I2,f,p)}const Cte=X({conv2DBackpropFilter_:Ste});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function py(t,e,n){if(n==null||n==="linear")return t;if(n==="relu")return Te(t,ID(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function my(t,e){let n=e;const r=tD(t.shape,e.shape);return r.length>0&&(n=en(n,r)),ye(n,t.shape)}function gy(t,e,n,r){if(e==="linear")return t;if(e==="relu")return fy(t);if(e==="elu")return rD(t);if(e==="relu6")return CD(t);if(e==="prelu")return wD(t,n);if(e==="leakyrelu")return cD(t,r);if(e==="sigmoid")return aa(t);throw new Error(`Unknown fused activation ${e}.`)}const yy=(t,e)=>!(t>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $te({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:d}){if(l=l||"linear",yy(Y.state.gradientDepth,l)===!1){z(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let O=uy(t,e,n,r,s,o,i);return a!=null&&(O=We(O,a)),gy(O,l,c,d)}const f=L(t,"x","conv2d","float32"),p=L(e,"filter","conv2d","float32");let g=f,y=!1;f.rank===3&&(y=!0,g=ye(f,[1,f.shape[0],f.shape[1],f.shape[2]])),z(g.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${g.rank}.`),z(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),po("fused conv2d",r,i);const x=s==="NHWC"?g.shape[3]:g.shape[1];z(p.shape[2]===x,()=>`Error in conv2d: depth of input (${x}) must match input depth for filter ${p.shape[2]}.`),z(Nr(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);const w=kn(g.shape,p.shape,n,o,r,i);let S;a!=null&&(S=L(a,"bias","fused conv2d"),[S]=yn(S,f),s==="NHWC"?ct(w.outShape,S.shape):(z(S.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${S.shape.length}.`),z(S.shape.length===0||S.shape[0]===w.outChannels||S.shape[0]===1,()=>`Error in fused conv2d: bias shape (${S.shape}) is not compatible with the number of output channels (${w.outChannels})`)));let $;if(c!=null){const O=c.shape;if(z(O.length<=1||O.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${O.length}.`),O.length===1)z(O[0]===1||O[0]===w.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${O}) is not compatible with the number of output channels (${w.outChannels}).`);else if(O.length===3)try{ct(O,w.outShape)}catch{const B=`Error in fused conv2d: PReLU activation weights (${O}) is not compatible with the output shape of the conv2d (${w.outShape}).`;throw Error(B)}$=L(c,"prelu weights","fused conv2d")}const I=(O,F)=>{z(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[B,M,V,P]=F,re=py(O,V,l);z(xf(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const ie=eD(M.shape,re,B,n,r),me=Cte(M,re,B.shape,n,r),ge=[ie,me];if(P!=null){const ve=my(P,re);ge.push(ve)}return ge},R={x:g,filter:p,bias:S,preluActivationWeights:$},_={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:d};return a==null?ya((F,B,M)=>{let V=Y.runKernel(wg,R,_);return M([B,F,V]),y&&(V=ye(V,[V.shape[1],V.shape[2],V.shape[3]])),{value:V,gradFunc:I}})(g,p):ya((F,B,M,V)=>{let P=Y.runKernel(wg,R,_);return V([B,F,P,M]),y&&(P=ye(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:I}})(g,p,S)}const kte=X({fusedConv2d_:$te});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tte(t,e,n,r,s,o=[1,1],i){let a=t;t.rank===3&&(a=ye(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=ye(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:a,dy:l},d={strides:r,pad:s,dimRoundingMode:i,dilations:o,filterShape:n};return Y.runKernel(B2,c,d)}const Ite=X({depthwiseConv2dNativeBackpropFilter_:Tte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nte(t,e,n,r,s,o=[1,1],i){let a=e,l=!1;e.rank===3&&(l=!0,a=ye(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:a,filter:n},d={strides:r,pad:s,dimRoundingMode:i,dilations:o,inputShape:t},f=Y.runKernel(M2,c,d);return l?ye(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Ete=X({depthwiseConv2dNativeBackpropInput_:Nte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rte({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:d}){if(yy(Y.state.gradientDepth,l)===!1){let _=LS(t,e,n,r,s,o,i);return a!=null&&(_=We(_,a)),gy(_,l,c,d)}const f=L(t,"x","depthwiseConv2d","float32"),p=L(e,"filter","depthwiseConv2d","float32");let g=f,y=!1;f.rank===3&&(y=!0,g=ye(f,[1,f.shape[0],f.shape[1],f.shape[2]])),z(g.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${g.rank}.`),z(p.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),z(g.shape[3]===p.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${g.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),o==null&&(o=[1,1]),z(Nr(n,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),po("fused depthwiseConv2d",r,i);const x=kn(g.shape,p.shape,n,o,r,i,!0);let w;a!=null&&(w=L(a,"bias","fused conv2d"),[w]=yn(w,f),ct(x.outShape,w.shape));let S;c!=null&&(S=L(c,"prelu weights","fused depthwiseConv2d"));const $=(_,O)=>{z(xf(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[F,B,M,V]=O,P=py(_,M,l),re=Ete(B.shape,P,F,n,r,o,i),ie=Ite(B,P,F.shape,n,r,o,i);if(V!=null){const me=my(w,P);return[re,ie,me]}return[re,ie]},I={x:g,filter:p,bias:w,preluActivationWeights:S},R={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:d};return a==null?ya((O,F,B)=>{let M=Y.runKernel(Sg,I,R);return B([F,O,M]),y&&(M=ye(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:$}})(g,p):ya((O,F,B,M)=>{let V=Y.runKernel(Sg,I,R);return M([F,O,V,B]),y&&(V=ye(V,[V.shape[1],V.shape[2],V.shape[3]])),{value:V,gradFunc:$}})(g,p,w)}const _te=X({fusedDepthwiseConv2d_:Rte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pte({a:t,b:e,transposeA:n=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(yy(Y.state.gradientDepth,o)===!1){let P=Ht(t,e,n,r);return s!=null&&(P=We(P,s)),gy(P,o,i,a)}let l=L(t,"a","fused matMul"),c=L(e,"b","fused matMul");[l,c]=yn(l,c);const d=n?l.shape[l.rank-2]:l.shape[l.rank-1],f=r?c.shape[c.rank-1]:c.shape[c.rank-2],p=n?l.shape[l.rank-1]:l.shape[l.rank-2],g=r?c.shape[c.rank-2]:c.shape[c.rank-1],y=l.shape.slice(0,-2),x=c.shape.slice(0,-2),w=pe(y),S=pe(x);z(d===f,()=>`Error in fused matMul: inner shapes (${d}) and (${f}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${n} and transposeB=${r} must match.`);const I=ct(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([p,g]),R=n?ye(l,[w,d,p]):ye(l,[w,p,d]),_=r?ye(c,[S,g,f]):ye(c,[S,f,g]);let O;s!=null&&(O=L(s,"bias","fused matMul"),[O]=yn(O,l),ct(I,O.shape));let F;i!=null&&(F=L(i,"prelu weights","fused matMul"));const B=(P,re)=>{const[ie,me,ge,ve]=re,$e=py(ye(P,ge.shape),ge,o);let fe,xe;if(!n&&!r?(fe=Ht($e,me,!1,!0),xe=Ht(ie,$e,!0,!1)):!n&&r?(fe=Ht($e,me,!1,!1),xe=Ht($e,ie,!0,!1)):n&&!r?(fe=Ht(me,$e,!1,!0),xe=Ht(ie,$e,!1,!1)):(fe=Ht(me,$e,!0,!0),xe=Ht($e,ie,!0,!0)),s!=null){const ae=my(ve,$e);return[fe,xe,ae]}else return[fe,xe]},M={a:R,b:_,bias:O,preluActivationWeights:F},V={transposeA:n,transposeB:r,activation:o,leakyreluAlpha:a};return s==null?ya((re,ie,me)=>{const ge=Y.runKernel(bg,M,V);return me([re,ie,ge]),{value:ye(ge,I),gradFunc:B}})(R,_):ya((re,ie,me,ge)=>{const ve=Y.runKernel(bg,M,V);return ge([re,ie,ve,me]),{value:ye(ve,I),gradFunc:B}})(R,_,O)}const Ate=X({fusedMatMul_:Pte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dte=Object.freeze(Object.defineProperty({__proto__:null,conv2d:kte,depthwiseConv2d:_te,matMul:Ate},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ote(t){return KS(t,.54,.46)}const Fte=X({hammingWindow_:Ote});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lte(t){return KS(t,.5,.5)}const AD=X({hannWindow_:Lte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zte(t,e,n,r=!1,s=0){let o=0;const i=[];for(;o+e<=t.size;)i.push(pt(t,o,e)),o+=n;if(r)for(;o<t.size;){const a=o+e-t.size,l=Fn([pt(t,o,e-a),Xf([a],s)]);i.push(l),o+=n}return i.length===0?lo([],[0,e]):ye(Fn(i),[i.length,e])}const DD=X({frame_:zte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bte(t,e,n,r,s=AD){r==null&&(r=PD(e));const o=DD(t,e,n),i=Te(o,s(e));return GS(i,r)}const Mte=X({stft_:Bte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vte(t,e,n,r,s="bilinear",o=0){const i=L(t,"image","cropAndResize"),a=L(e,"boxes","cropAndResize","float32"),l=L(n,"boxInd","cropAndResize","int32"),c=a.shape[0];z(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),z(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),z(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),z(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),z(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),z(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const d={image:i,boxes:a,boxInd:l},f={method:s,extrapolationValue:o,cropSize:r};return Y.runKernel(O2,d,f)}const Wte=X({cropAndResize_:Vte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ute(t){const e=L(t,"image","flipLeftRight","float32");z(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const n={image:e};return Y.runKernel(J2,n,{})}const jte=X({flipLeftRight_:Ute});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gte(t){const e=L(t,"image","grayscaleToRGB"),n=e.rank-1,r=e.shape[n];z(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),z(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,n),s[n]=3,Zh(e,s)}const Hte=X({grayscaleToRGB_:Gte});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kte(t){const e=L(t,"image","RGBToGrayscale"),n=e.rank-1,r=e.shape[n];z(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),z(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const s=e.dtype,o=Qt(e,"float32"),i=ar([.2989,.587,.114]);let a;switch(e.rank){case 2:a=_c("ij,j->i",o,i);break;case 3:a=_c("ijk,k->ij",o,i);break;case 4:a=_c("ijkl,l->ijk",o,i);break;case 5:a=_c("ijklm,m->ijkl",o,i);break;case 6:a=_c("ijklmn,n->ijklm",o,i);break;default:throw new Error("Not a valid tensor rank.")}return a=Rs(a,-1),Qt(a,s)}const Xte=X({rgbToGrayscale_:Kte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qte(t,e,n=0,r=.5){const s=L(t,"image","rotateWithOffset","float32");z(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const o={image:s},i={radians:e,fillValue:n,center:r};return Y.runKernel(AS,o,i)}const Yte=X({rotateWithOffset_:qte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Td(t,e,n,r,s,o){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),o==null&&(o=0);const i=t.shape[0];return n=Math.min(n,i),z(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),z(t.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),z(t.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),z(e.rank===1,()=>"scores must be a 1D tensor"),z(e.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${e.shape[0]}`),z(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qte(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const o=L(t,"boxes","nonMaxSuppression","float32"),i=L(e,"scores","nonMaxSuppression","float32"),a=Td(o,i,n,r,s);n=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return Y.runKernel(Fw,{boxes:o,scores:i},l)}const Zte=X({nonMaxSuppression_:Qte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jte(t,e,n){const r=ene(t,e,n),s=r<0?-(r+1):r;t.splice(s,0,e)}function ene(t,e,n){return nne(t,e,n||tne)}function tne(t,e){return t>e?1:t<e?-1:0}function nne(t,e,n){let r=0,s=t.length,o=0,i=!1;for(;r<s;){o=r+(s-r>>>1);const a=n(e,t[o]);a>0?r=o+1:(s=o,i=!a)}return i?r:-r-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XS(t,e,n,r,s){return YS(t,e,n,r,s,0)}function OD(t,e,n,r,s,o){return YS(t,e,n,r,s,0,!1,o,!0)}function qS(t,e,n,r,s,o){return YS(t,e,n,r,s,o,!0)}function YS(t,e,n,r,s,o,i=!1,a=!1,l=!1){const c=[];for(let w=0;w<e.length;w++)e[w]>s&&c.push({score:e[w],boxIndex:w,suppressBeginIndex:0});c.sort(RI);const d=o>0?-.5/o:0,f=[],p=[];for(;f.length<n&&c.length>0;){const w=c.pop(),{score:S,boxIndex:$,suppressBeginIndex:I}=w;if(S<s)break;let R=!1;for(let _=f.length-1;_>=I;--_){const O=rne(t,$,f[_]);if(O>=r){R=!0;break}if(w.score=w.score*sne(r,d,O),w.score<=s)break}w.suppressBeginIndex=f.length,R||(w.score===S?(f.push($),p.push(w.score)):w.score>s&&Jte(c,w,RI))}const g=f.length,y=n-g;a&&y>0&&(f.push(...new Array(y).fill(0)),p.push(...new Array(y).fill(0)));const x={selectedIndices:f};return i&&(x.selectedScores=p),l&&(x.validOutputs=g),x}function rne(t,e,n){const r=t.subarray(e*4,e*4+4),s=t.subarray(n*4,n*4+4),o=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(s[0],s[2]),d=Math.min(s[1],s[3]),f=Math.max(s[0],s[2]),p=Math.max(s[1],s[3]),g=(a-o)*(l-i),y=(f-c)*(p-d);if(g<=0||y<=0)return 0;const x=Math.max(o,c),w=Math.max(i,d),S=Math.min(a,f),$=Math.min(l,p),I=Math.max(S-x,0)*Math.max($-w,0);return I/(g+y-I)}function sne(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function RI(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function one(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const o=L(t,"boxes","nonMaxSuppressionAsync"),i=L(e,"scores","nonMaxSuppressionAsync"),a=Td(o,i,n,r,s);n=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l=await Promise.all([o.data(),i.data()]),c=l[0],d=l[1],{selectedIndices:f}=XS(c,d,n,r,s);return o!==t&&o.dispose(),i!==e&&i.dispose(),ar(f,"int32")}const ine=one;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ane(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=L(t,"boxes","nonMaxSuppression"),a=L(e,"scores","nonMaxSuppression"),l=Td(i,a,n,r,s,o);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,o=l.softNmsSigma;const c={boxes:i,scores:a},d={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:o},f=Y.runKernel(Lw,c,d);return{selectedIndices:f[0],selectedScores:f[1]}}const lne=X({nonMaxSuppressionWithScore_:ane});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function une(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=L(t,"boxes","nonMaxSuppressionAsync"),a=L(e,"scores","nonMaxSuppressionAsync"),l=Td(i,a,n,r,s,o);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,o=l.softNmsSigma;const c=await Promise.all([i.data(),a.data()]),d=c[0],f=c[1],{selectedIndices:p,selectedScores:g}=qS(d,f,n,r,s,o);return i!==t&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:ar(p,"int32"),selectedScores:ar(g)}}const cne=une;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dne(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=L(t,"boxes","nonMaxSuppression"),a=L(e,"scores","nonMaxSuppression"),l=Td(i,a,n,r,s,null),c=l.maxOutputSize,d=l.iouThreshold,f=l.scoreThreshold,p={boxes:i,scores:a},g={maxOutputSize:c,iouThreshold:d,scoreThreshold:f,padToMaxOutputSize:o},y=Y.runKernel(rA,p,g);return{selectedIndices:y[0],validOutputs:y[1]}}const hne=X({nonMaxSuppressionPadded_:dne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function fne(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=L(t,"boxes","nonMaxSuppressionAsync"),a=L(e,"scores","nonMaxSuppressionAsync"),l=Td(i,a,n,r,s,null),c=l.maxOutputSize,d=l.iouThreshold,f=l.scoreThreshold,[p,g]=await Promise.all([i.data(),a.data()]),{selectedIndices:y,validOutputs:x}=OD(p,g,c,d,f,o);return i!==t&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:ar(y,"int32"),validOutputs:mt(x,"int32")}}const pne=fne;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mne(t,e,n=!1,r=!1){const s=L(t,"images","resizeBilinear");z(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),z(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),z(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;s.rank===3&&(i=!0,o=ye(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:o},l={alignCorners:n,halfPixelCenters:r,size:e},c=Y.runKernel(Qw,a,l);return i?ye(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const gne=X({resizeBilinear_:mne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yne(t,e,n=!1,r=!1){const s=L(t,"images","resizeNearestNeighbor");z(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),z(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),z(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),z(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;s.rank===3&&(i=!0,o=ye(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:o},l={alignCorners:n,halfPixelCenters:r,size:e},c=Y.runKernel(Yw,a,l);return i?ye(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const xne=X({resizeNearestNeighbor_:yne});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vne(t,e="binary",n=!1,r=.5){const s=L(t,"image","threshold"),o=.2989,i=.587,a=.114,l=s.shape[0]*s.shape[1];let c=Te(ar([r]),255),d,f,p,g;if(z(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),z(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),z(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),z(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[d,f,p]=$f(s,[1,1,1],-1);const w=Te(d,o),S=Te(f,i),$=Te(p,a);g=We(We(w,S),$)}else g=t;if(e==="otsu"){const w=ZA(Qt($D(g),"int32"),vi([]),256);c=bne(w,l)}const y=n?BS(g,c):dy(g,c);return Qt(Te(y,255),"int32")}function bne(t,e){let n=ar([-1]),r=ar([0]),s=ar([0]),o,i,a,l,c,d;for(let f=0;f<t.size-1;f++){o=pt(t,0,f+1),i=pt(t,f+1),c=gt(en(o),e),d=gt(en(i),e);const p=en(Te(o,Sf(0,o.size)));a=gt(p,en(o));const g=Xf(i.shape,o.size),y=We(Sf(0,i.size),g),x=Te(i,y);l=gt(en(x),en(i));const w=ot(a,l),S=ot(a,l),$=Te(c,d);s=Te(Te($,w),S);const I=dy(s,r);r=pl(I,s,r),n=pl(I,ar([f]),n)}return n}const wne=X({threshold_:vne});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sne(t,e,n="nearest",r="constant",s=0,o){const i=L(t,"image","transform","float32"),a=L(e,"transforms","transform","float32");z(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),z(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),z(o==null||o.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);const l={image:i,transforms:a},c={interpolation:n,fillMode:r,fillValue:s,outputShape:o};return Y.runKernel(NS,l,c)}const Cne=X({transform_:Sne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ne(t,e,n){const r=L(t,"a","bandPart");z(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[o,i]=r.shape.slice(-2);let a,l;typeof e=="number"?(z(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),z(e<=o,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${o}).`),a=L(e<0?o:e,"numLower","bandPart")):(z(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=pl(mv(e,0),o,wf(e,o))),typeof n=="number"?(z(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),z(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),l=L(n<0?i:n,"numUpper","bandPart")):(z(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=pl(mv(n,0),i,wf(n,i)));const c=ye(Sf(0,o,1,"int32"),[-1,1]),d=Sf(0,i,1,"int32"),f=ot(c,d),p=Ig(BS(f,a),uD(f,bi(l))),g=xa([o,i],r.dtype);return ye(va(Mu(ye(r,[-1,o,i])).map(y=>pl(p,y,g))),s)}const kne=X({bandPart_:$ne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tne(t){let e;if(Array.isArray(t)){e=!1,z(t!=null&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=t[0].shape[0];for(let o=1;o<t.length;++o)z(t[o].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[o].shape[0]} vs. ${s})`)}else e=!0,t=$f(t,t.shape[0],0).map(s=>Gt(s,[0]));z(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],r=t;for(let s=0;s<t.length;++s)n.push(Y.tidy(()=>{let o=r[s];if(s>0)for(let i=0;i<s;++i){const a=Te(en(Te(n[i],o)),n[i]);o=ot(o,a)}return gt(o,cy(o,"euclidean"))}));return e?va(n,0):n}const Ine=X({gramSchmidt_:Tne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nne(t,e=!1){if(z(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),t.rank===2)return _I(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((l,c)=>l*c),r=Mu(ye(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),s=[],o=[];r.forEach(l=>{const[c,d]=_I(l,e);s.push(c),o.push(d)});const i=ye(va(s,0),t.shape),a=ye(va(o,0),t.shape);return[i,a]}}function _I(t,e=!1){return Y.tidy(()=>{z(t.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],r=t.shape[1];let s=iD(n),o=fl(t);const i=lo([[1]],[1,1]);let a=fl(i);const l=n>=r?r:n;for(let c=0;c<l;++c){const d=o,f=a,p=s;[a,o,s]=Y.tidy(()=>{const g=pt(o,[c,c],[n-c,1]),y=cy(g),x=pt(o,[c,c],[1,1]),w=pl(dy(x,0),lo([[-1]]),lo([[1]])),S=ot(x,Te(w,y)),$=gt(g,S);$.shape[0]===1?a=fl(i):a=Fn([i,pt($,[1,0],[$.shape[0]-1,$.shape[1]])],0);const I=bi(gt(Ht(w,S),y)),R=pt(o,[c,0],[n-c,r]),_=Te(I,a),O=gv(a);if(c===0)o=ot(R,Ht(_,Ht(O,R)));else{const M=ot(R,Ht(_,Ht(O,R)));o=Fn([pt(o,[0,0],[c,r]),M],0)}const F=gv(_),B=pt(s,[0,c],[n,s.shape[1]-c]);if(c===0)s=ot(B,Ht(Ht(B,a),F));else{const M=ot(B,Ht(Ht(B,a),F));s=Fn([pt(s,[0,0],[n,c]),M],1)}return[a,o,s]}),Mt([d,f,p])}return!e&&n>r&&(s=pt(s,[0,0],[n,r]),o=pt(o,[0,0],[r,r])),[s,o]})}const Ene=X({qr_:Nne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var zr;(function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(zr||(zr={}));function Rne(t,e,n=zr.SUM_BY_NONZERO_WEIGHTS){const r=L(t,"losses","computeWeightedLoss");let s=null;e!=null&&(s=L(e,"weights","computeWeightedLoss"));const o=s==null?r:Te(r,s);if(n===zr.NONE)return o;if(n===zr.SUM)return en(o);if(n===zr.MEAN){if(s==null)return Ng(o);{const i=r.size/s.size,a=gt(en(o),en(s));return i>1?gt(a,mt(i)):a}}if(n===zr.SUM_BY_NONZERO_WEIGHTS){if(s==null)return gt(en(o),mt(r.size));{const i=Te(s,bu(r.shape)),a=Qt(en(vD(i,mt(0))),"float32");return gt(en(o),a)}}throw Error(`Unknown reduction: ${n}`)}const Ca=X({computeWeightedLoss_:Rne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ne(t,e,n,r=zr.SUM_BY_NONZERO_WEIGHTS){const s=L(t,"labels","absoluteDifference"),o=L(e,"predictions","absoluteDifference");let i=null;n!=null&&(i=L(n,"weights","absoluteDifference")),ys(s.shape,o.shape,"Error in absoluteDifference: ");const a=Es(ot(s,o));return Ca(a,i,r)}const Pne=X({absoluteDifference_:_ne});function Ane(t,e,n,r,s=zr.SUM_BY_NONZERO_WEIGHTS){const o=L(t,"labels","cosineDistance"),i=L(e,"predictions","cosineDistance");let a=null;r!=null&&(a=L(r,"weights","cosineDistance")),ys(o.shape,i.shape,"Error in cosineDistance: ");const l=mt(1),c=ot(l,en(Te(o,i),n,!0));return Ca(c,a,s)}const Dne=X({cosineDistance_:Ane});function One(t,e,n,r=zr.SUM_BY_NONZERO_WEIGHTS){let s=L(t,"labels","hingeLoss");const o=L(e,"predictions","hingeLoss");let i=null;n!=null&&(i=L(n,"weights","hingeLoss")),ys(s.shape,o.shape,"Error in hingeLoss: ");const a=mt(1);s=ot(Te(mt(2),s),a);const l=fy(ot(a,Te(s,o)));return Ca(l,i,r)}const Fne=X({hingeLoss_:One});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lne(t,e,n,r=1,s=zr.SUM_BY_NONZERO_WEIGHTS){const o=L(t,"labels","huberLoss"),i=L(e,"predictions","huberLoss");let a=null;n!=null&&(a=L(n,"weights","huberLoss")),ys(o.shape,i.shape,"Error in huberLoss: ");const l=mt(r),c=Es(ot(i,o)),d=wf(c,l),f=ot(c,d),p=We(Te(mt(.5),ao(d)),Te(l,f));return Ca(p,a,s)}const zne=X({huberLoss_:Lne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bne(t,e,n,r=1e-7,s=zr.SUM_BY_NONZERO_WEIGHTS){const o=L(t,"labels","logLoss"),i=L(e,"predictions","logLoss");let a=null;n!=null&&(a=L(n,"weights","logLoss")),ys(o.shape,i.shape,"Error in logLoss: ");const l=mt(1),c=mt(r),d=bi(Te(o,bf(We(i,c)))),f=Te(ot(l,o),bf(We(ot(l,i),c))),p=ot(d,f);return Ca(p,a,s)}const Mne=X({logLoss_:Bne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vne(t,e,n,r=zr.SUM_BY_NONZERO_WEIGHTS){const s=L(t,"labels","meanSquaredError"),o=L(e,"predictions","meanSquaredError");let i=null;n!=null&&(i=L(n,"weights","meanSquaredError")),ys(s.shape,o.shape,"Error in meanSquaredError: ");const a=TD(s,o);return Ca(a,i,r)}const Wne=X({meanSquaredError_:Vne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Une(t,e){const n=L(t,"labels","sigmoidCrossEntropyWithLogits"),r=L(e,"logits","sigmoidCrossEntropyWithLogits");ys(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=fy(r),o=Te(r,n),i=dD(ga(bi(Es(r))));return We(ot(s,o),i)}function jne(t,e,n,r=0,s=zr.SUM_BY_NONZERO_WEIGHTS){let o=L(t,"multiClassLabels","sigmoidCrossEntropy");const i=L(e,"logits","sigmoidCrossEntropy");let a=null;if(n!=null&&(a=L(n,"weights","sigmoidCrossEntropy")),ys(o.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const c=mt(r),d=mt(1),f=mt(.5);o=We(Te(o,ot(d,c)),Te(f,c))}const l=Une(o,i);return Ca(l,a,s)}const Gne=X({sigmoidCrossEntropy_:jne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hne(t,e,n=-1){if(n===-1&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return ya((s,o,i)=>{const l=fD(o,[n],!0),c=ot(Qt(o,"float32"),l);i([s,c]);const d=bi(Te(c,s));return{value:en(d,[n]),gradFunc:(g,y)=>{const[x,w]=y,S=xs(g.shape,[n]);return[Te(ye(g,S),ot(Qt(x,"float32"),ga(w))),Te(ye(g,S),ot(ga(w),Qt(x,"float32")))]}}})(t,e)}function Kne(t,e,n,r=0,s=zr.SUM_BY_NONZERO_WEIGHTS){let o=L(t,"onehotLabels","softmaxCrossEntropy");const i=L(e,"logits","softmaxCrossEntropy");let a=null;if(n!=null&&(a=L(n,"weights","softmaxCrossEntropy")),ys(o.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const c=mt(r),d=mt(1),f=mt(o.shape[1]);o=We(Te(o,ot(d,c)),gt(c,f))}const l=Hne(o,i);return Ca(l,a,s)}const Xne=X({softmaxCrossEntropy_:Kne});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qne(t,e,n,r){const s=L(t,"indices","sparseFillEmptyRows","int32"),o=L(e,"values","sparseFillEmptyRows"),i=L(n,"denseShape","sparseFillEmptyRows","int32"),a=L(r,"defaultValue","sparseFillEmptyRows",o.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(o.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const l={indices:s,values:o,denseShape:i,defaultValue:a},c=Y.runKernel(uA,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const Yne=X({sparseFillEmptyRows_:qne});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qne(t,e,n){const r=L(t,"inputIndices","sparseReshape","int32"),s=L(e,"inputShape","sparseReshape","int32"),o=L(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(o.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const i={inputIndices:r,inputShape:s,newShape:o},a=Y.runKernel(cA,i);return{outputIndices:a[0],outputShape:a[1]}}const Zne=X({sparseReshape_:Qne});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jne(t,e,n){const r=L(t,"data","sparseSegmentMean"),s=L(e,"indices","sparseSegmentMean","int32"),o=L(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${o.shape}`);const i={data:r,indices:s,segmentIds:o};return Y.runKernel(xS,i)}const ere=X({sparseSegmentMean_:Jne});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tre(t,e,n){const r=L(t,"data","sparseSegmentSum"),s=L(e,"indices","sparseSegmentSum","int32"),o=L(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${o.shape}`);const i={data:r,indices:s,segmentIds:o};return Y.runKernel(vS,i)}const nre=X({sparseSegmentSum_:tre});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rre(t,e,n,r,s,o,i,a){const l=L(t,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=L(e,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const d={separator:n,nGramWidths:r,leftPad:s,rightPad:o,padWidth:i,preserveShortSequences:a},f={data:l,dataSplits:c},p=Y.runKernel(CS,f,d);return{nGrams:p[0],nGramsSplits:p[1]}}const sre=X({stringNGrams_:rre});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ore(t,e,n=!0){const r=L(t,"input","stringSplit","string"),s=L(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const o={skipEmpty:n},i={input:r,delimiter:s},a=Y.runKernel(fA,i,o);return{indices:a[0],values:a[1],shape:a[2]}}const ire=X({stringSplit_:ore});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function are(t,e){const n=L(t,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return Y.runKernel(pA,s,r)}const lre=X({stringToHashBucketFast_:are});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ure(t,e,n,r=!0){const s=L(t,"input","staticRegexReplace","string"),o={pattern:e,rewrite:n,replaceGlobal:r};return Y.runKernel(hA,{x:s},o)}const cre=X({staticRegexReplace_:ure});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dre={fft:jS,ifft:Eg,rfft:GS,irfft:kD},hre={hammingWindow:Fte,hannWindow:AD,frame:DD,stft:Mte},Tu={flipLeftRight:jte,grayscaleToRGB:Hte,resizeNearestNeighbor:xne,resizeBilinear:gne,rgbToGrayscale:Xte,rotateWithOffset:Yte,cropAndResize:Wte,nonMaxSuppression:Zte,nonMaxSuppressionAsync:ine,nonMaxSuppressionWithScore:lne,nonMaxSuppressionWithScoreAsync:cne,nonMaxSuppressionPadded:hne,nonMaxSuppressionPaddedAsync:pne,threshold:wne,transform:Cne},fre={bandPart:kne,gramSchmidt:Ine,qr:Ene},pre={absoluteDifference:Pne,computeWeightedLoss:Ca,cosineDistance:Dne,hingeLoss:Fne,huberLoss:zne,logLoss:Mne,meanSquaredError:Wne,sigmoidCrossEntropy:Gne,softmaxCrossEntropy:Xne},mre={sparseFillEmptyRows:Yne,sparseReshape:Zne,sparseSegmentMean:ere,sparseSegmentSum:nre},gre={stringNGrams:sre,stringSplit:ire,stringToHashBucketFast:lre,staticRegexReplace:cre};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yre=new Map,xre=new Map;class vre{getClassName(){return this.constructor.className}static fromConfig(e,n){return new e(n)}}class hu{constructor(){this.classNameMap={}}static getMap(){return hu.instance==null&&(hu.instance=new hu),hu.instance}static register(e){hu.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function bre(t,e,n){z(t.className!=null,()=>"Class being registered does not have the static className property defined."),z(typeof t.className=="string",()=>"className is required to be a string, but got type "+typeof t.className),z(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof n>"u"&&(n=t.className);const r=n,s=e+">"+r;return hu.register(t),yre.set(s,t),xre.set(t,s),t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vu extends vre{minimize(e,n=!1,r){const{value:s,grads:o}=this.computeGradients(e,r);if(r!=null){const i=r.map(a=>({name:a.name,tensor:o[a.name]}));this.applyGradients(i)}else this.applyGradients(o);return Mt(o),n?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,n){return sZ(e,n)}dispose(){this.iterations_!=null&&Mt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:mt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Vu,Symbol.hasInstance,{value:t=>t.minimize!=null&&t.computeGradients!=null&&t.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wre extends Vu{static get className(){return"Adadelta"}constructor(e,n,r=null){super(),this.learningRate=e,this.rho=n,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=Y.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=Y.registeredVariables[r],i=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:nt(()=>Ds(o).variable(i))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:nt(()=>Ds(o).variable(i))});const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const l=this.accumulatedGrads[s].variable,c=this.accumulatedUpdates[s].variable;nt(()=>{const d=We(Te(l,this.rho),Te(ao(a),1-this.rho)),f=Te(gt(ma(We(c,this.epsilon)),ma(We(l,this.epsilon))),a),p=We(Te(c,this.rho),Te(ao(f),1-this.rho));l.assign(d),c.assign(p);const g=We(Te(f,-this.learningRate),o);o.assign(g)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Mt(this.accumulatedGrads.map(e=>e.variable)),Mt(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=e.length/2,r=!1;this.accumulatedGrads=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.rho,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sre extends Vu{static get className(){return"Adagrad"}constructor(e,n=.1){super(),this.learningRate=e,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=Y.registeredVariables[r];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:nt(()=>Xf(o.shape,this.initialAccumulatorValue).variable(!1))});const i=Array.isArray(e)?e[s].tensor:e[r];if(i==null)return;const a=this.accumulatedGrads[s].variable;nt(()=>{const l=We(a,ao(i));a.assign(l);const c=We(Te(gt(i,ma(We(l,Y.backend.epsilon()))),-this.learningRate),o);o.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Mt(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,n){return new e(n.learningRate,n.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cre extends Vu{static get className(){return"Adam"}constructor(e,n,r,s=null){super(),this.learningRate=e,this.beta1=n,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],nt(()=>{this.accBeta1=mt(n).variable(),this.accBeta2=mt(r).variable()}),s==null&&(this.epsilon=Y.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);nt(()=>{const r=ot(1,this.accBeta1),s=ot(1,this.accBeta2);n.forEach((o,i)=>{const a=Y.registeredVariables[o],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:nt(()=>Ds(a).variable(l))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${o}/v`,variable:nt(()=>Ds(a).variable(l))});const c=Array.isArray(e)?e[i].tensor:e[o];if(c==null)return;const d=this.accumulatedFirstMoment[i].variable,f=this.accumulatedSecondMoment[i].variable,p=We(Te(d,this.beta1),Te(c,1-this.beta1)),g=We(Te(f,this.beta2),Te(ao(c),1-this.beta2)),y=gt(p,r),x=gt(g,s);d.assign(p),f.assign(g);const w=We(Te(gt(y,We(ma(x),this.epsilon)),-this.learningRate),a);a.assign(w)}),this.accBeta1.assign(Te(this.accBeta1,this.beta1)),this.accBeta2.assign(Te(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Mt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Mt(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e),nt(()=>{this.accBeta1.assign(vf(this.beta1,this.iterations_+1)),this.accBeta2.assign(vf(this.beta2,this.iterations_+1))});const n=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $re extends Vu{static get className(){return"Adamax"}constructor(e,n,r,s=null,o=0){super(),this.learningRate=e,this.beta1=n,this.beta2=r,this.epsilon=s,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],nt(()=>{this.iteration=mt(0).variable(),this.accBeta1=mt(n).variable()}),s==null&&(this.epsilon=Y.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);nt(()=>{const r=ot(1,this.accBeta1),s=gt(-this.learningRate,We(Te(this.iteration,this.decay),1));n.forEach((o,i)=>{const a=Y.registeredVariables[o],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:Ds(a).variable(l)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${o}/v`,variable:Ds(a).variable(l)});const c=Array.isArray(e)?e[i].tensor:e[o];if(c==null)return;const d=this.accumulatedFirstMoment[i].variable,f=this.accumulatedWeightedInfNorm[i].variable,p=We(Te(d,this.beta1),Te(c,1-this.beta1)),g=Te(f,this.beta2),y=Es(c),x=yD(g,y);d.assign(p),f.assign(x);const w=We(Te(gt(s,r),gt(p,We(x,this.epsilon))),a);a.assign(w)}),this.iteration.assign(We(this.iteration,1)),this.accBeta1.assign(Te(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Mt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Mt(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FD extends Vu{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=Array.isArray(e)?e[s].tensor:e[r];if(o==null)return;const i=Y.registeredVariables[r];nt(()=>{const a=We(Te(this.c,o),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=hi(mt(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,n){return new e(n.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kre extends FD{static get className(){return"Momentum"}constructor(e,n,r=!1){super(e),this.learningRate=e,this.momentum=n,this.useNesterov=r,this.accumulations=[],this.m=mt(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=Y.registeredVariables[r];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:nt(()=>Ds(o).variable(!1))});const i=this.accumulations[s].variable,a=Array.isArray(e)?e[s].tensor:e[r];a!=null&&nt(()=>{let l;const c=We(Te(this.m,i),a);this.useNesterov?l=We(Te(this.c,We(a,Te(c,this.m))),o):l=We(Te(this.c,c),o),i.assign(c),o.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Mt(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,n){return new e(n.learningRate,n.momentum,n.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tre extends Vu{static get className(){return"RMSProp"}constructor(e,n=.9,r=0,s=null,o=!1){if(super(),this.learningRate=e,this.decay=n,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,s==null&&(this.epsilon=Y.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=Y.registeredVariables[r],i=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:nt(()=>Ds(o).variable(i))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:nt(()=>Ds(o).variable(i))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:nt(()=>Ds(o).variable(i))});const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const l=this.accumulatedMeanSquares[s].variable,c=this.accumulatedMoments[s].variable;nt(()=>{const d=We(Te(l,this.decay),Te(ao(a),1-this.decay));if(this.centered){const f=this.accumulatedMeanGrads[s].variable,p=We(Te(f,this.decay),Te(a,1-this.decay)),g=gt(Te(a,this.learningRate),ma(ot(d,We(ao(p),this.epsilon)))),y=We(Te(c,this.momentum),g);l.assign(d),f.assign(p),c.assign(y);const x=ot(o,y);o.assign(x)}else{const f=We(Te(l,this.decay),Te(ao(a),1-this.decay)),p=We(Te(c,this.momentum),gt(Te(a,this.learningRate),ma(We(f,this.epsilon))));l.assign(f),c.assign(p);const g=ot(o,p);o.assign(g)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Mt(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Mt(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Mt(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(n*2,n*3).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,n){return new e(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ire=[wre,Sre,Cre,$re,kre,Tre,FD];function Nre(){for(const t of Ire)bre(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ere="model",Rre=".json",_re=".weights.bin";function PI(t){return new Promise(e=>setTimeout(e)).then(t)}class Fu{constructor(e){if(!se().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Fu.URL_SCHEME)&&(e=e.slice(Fu.URL_SCHEME.length)),(e==null||e.length===0)&&(e=Ere),this.modelJsonFileName=e+Rre,this.weightDataFileName=e+_re}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=Bo.join(e.weightData),r=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],o=zA(e,s),i=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=i,await PI(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=r,await PI(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Hf(e)}}}}Fu.URL_SCHEME="downloads://";class Pre{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,n)=>{const r=new FileReader;r.onload=s=>{const o=JSON.parse(s.target.result),i=o.modelTopology;if(i==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(o.weightsManifest==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:i});return}const l=OS(o,c=>this.loadWeights(c));e(l)},r.onerror=s=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(e){const n=[],r=[];for(const i of e)n.push(...i.weights),r.push(...i.paths);const s=this.checkManifestAndWeightFiles(e),o=r.map(i=>this.loadWeightsFile(i,s[i]));return Promise.all(o).then(i=>[n,i])}loadWeightsFile(e,n){return new Promise((r,s)=>{const o=new FileReader;o.onload=i=>{const a=i.target.result;r(a)},o.onerror=i=>s(`Failed to weights data from file of path '${e}'.`),o.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(e){const n=[],r=this.weightsFiles.map(o=>wI(o.name)),s={};for(const o of e)o.paths.forEach(i=>{const a=wI(i);if(n.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(n.push(a),r.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);s[i]=this.weightsFiles[r.indexOf(a)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}const Are=t=>se().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Fu.URL_SCHEME)?Dre(t.slice(Fu.URL_SCHEME.length)):null;cn.registerSaveRouter(Are);function Dre(t="model"){return new Fu(t)}function Ore(t){return new Pre(t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AI(t,e,n,r){i(t),n=n??0,r=r??1,a(n,r);let s=0;const o=l=>(l.then(c=>{const d=n+ ++s/t.length*(r-n);return e(d),c}),l);function i(l){z(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,c){z(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),z(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),z(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(t.map(o))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function LD(t,e){e==null&&(e={});const n=e.fetchFunc==null?se().platform.fetch:e.fetchFunc,r=t.map(f=>n(f,e.requestInit,{isBinary:!0})),a=(e.onProgress==null?await Promise.all(r):await AI(r,e.onProgress,0,.5)).map(f=>f.arrayBuffer());return e.onProgress==null?await Promise.all(a):await AI(a,e.onProgress,.5,1)}function Fre(t,e){var n;const r=e.fetchFunc==null?se().platform.fetch:e.fetchFunc;let s=0,o;return(n=e.onProgress)===null||n===void 0||n.call(e,0),new ReadableStream({pull:async i=>{for(var a;s<t.length;){o||(o=(await r(t[s],e.requestInit,{isBinary:!0})).body.getReader());const{done:l,value:c}=await o.read();if(l){s++,o=void 0,(a=e.onProgress)===null||a===void 0||a.call(e,s/t.length);continue}i.enqueue(c);return}i.close()}})}async function Lre(t,e="",n,r){return zD(i=>LD(i,{requestInit:r}))(t,e,n)}function zD(t){return async(e,n="",r)=>{const s=e.map(()=>!1),o={},i=r!=null?r.map(()=>!1):[],a=[];if(e.forEach((g,y)=>{let x=0;g.weights.forEach(w=>{const S="quantization"in w?w.quantization.dtype:w.dtype,$=_u[S]*pe(w.shape),I=()=>{s[y]=!0,o[y]==null&&(o[y]=[]),o[y].push({manifestEntry:w,groupOffset:x,sizeBytes:$})};r!=null?r.forEach((R,_)=>{R===w.name&&(I(),i[_]=!0)}):I(),a.push(w.name),x+=$})}),!i.every(g=>g)){const g=r.filter((y,x)=>!i[x]);throw new Error(`Could not find weights in manifest with names: ${g.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const l=s.reduce((g,y,x)=>(y&&g.push(x),g),[]),c=[];l.forEach(g=>{e[g].paths.forEach(y=>{const x=n+(n.endsWith("/")?"":"/")+y;c.push(x)})});const d=await t(c),f={};let p=0;return l.forEach(g=>{const y=e[g].paths.length,x=new Bo(d.slice(p,p+y));o[g].forEach(S=>{const $=x.slice(S.groupOffset,S.groupOffset+S.sizeBytes),I=OA($,[S.manifestEntry]);for(const R in I)f[R]=I[R]}),p+=y}),f}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zre="application/octet-stream",Bre="application/json";class QS{constructor(e,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(z(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=se().platform.fetch,z(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&z(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{},this.loadOptions=n}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=zA(e,r);if(n.body.append("model.json",new Blob([JSON.stringify(s)],{type:Bre}),"model.json"),e.weightData!=null){const i=Bo.join(e.weightData);n.body.append("model.weights.bin",new Blob([i],{type:zre}),"model.weights.bin")}const o=await this.fetch(this.path,n);if(o.ok)return{modelArtifactsInfo:Hf(e),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await e.json()}catch{let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}const r=n.modelTopology,s=n.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return n}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return OS(e,n=>this.loadWeights(n))}async loadStream(){const e=await this.loadModelJSON(),n=await this.getWeightUrls(e.weightsManifest),r=lv(e.weightsManifest),s=()=>Fre(n,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:r,getWeightStream:s})}async getWeightUrls(e){const n=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=Mre(n),o=this.weightPathPrefix||r,i=[],a=[];for(const l of e)for(const c of l.paths)this.weightUrlConverter!=null?a.push(this.weightUrlConverter(c)):i.push(o+c+s);return this.weightUrlConverter&&i.push(...await Promise.all(a)),i}async loadWeights(e){const n=await this.getWeightUrls(e),r=lv(e),s=await LD(n,this.loadOptions);return[r,s]}}QS.URL_SCHEME_REGEX=/^https?:\/\//;function Mre(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),s=n>e?t.substring(n):"";return[r+"/",s]}function yv(t){return t.match(QS.URL_SCHEME_REGEX)!=null}const BD=(t,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let n=!0;if(Array.isArray(t)?n=t.every(r=>yv(r)):n=yv(t),n)return ZS(t,e)}return null};cn.registerSaveRouter(BD);cn.registerLoadRouter(BD);function ZS(t,e){return new QS(t,e)}function Vre(t,e){return ZS(t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class X1{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class MD{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class Wre{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=n=>Promise.resolve(e.save(n)))}}function Ure(t,e,n,r){const s=arguments;return new Wre(VD(...s))}function VD(t,e,n,r){return arguments.length===1?t.modelTopology!=null||t.weightSpecs!=null?new X1(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new X1({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new X1({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:r}))}function jre(t){return new MD(t)}function Gre(t){return new MD(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WD=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Bo,browserFiles:Ore,browserHTTPRequest:Vre,concatenateArrayBuffers:GX,copyModel:fq,decodeWeights:OA,decodeWeightsStream:LA,encodeWeights:BX,fromMemory:Ure,fromMemorySync:VD,getLoadHandlers:JX,getModelArtifactsForJSON:OS,getModelArtifactsForJSONSync:BA,getModelArtifactsInfoForJSON:Hf,getSaveHandlers:ZX,getWeightSpecs:lv,http:ZS,isHTTPScheme:yv,listModels:dq,loadWeights:Lre,moveModel:pq,registerLoadRouter:QX,registerSaveRouter:YX,removeModel:hq,weightsLoaderFactory:zD,withSaveHandler:jre,withSaveHandlerSync:Gre},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let su,DI=!1;function Hre(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(t==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,o=!1,i=!1,a=!1;if(t.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&t instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)o=!0;else if(t.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&t instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);if($g(vg,Y.backendName)!=null){const y={pixels:t},x={numChannels:e};return Y.runKernel(vg,y,x)}const[c,d]=s?[t.videoWidth,t.videoHeight]:[t.width,t.height];let f;if(i)f=t.getContext("2d").getImageData(0,0,c,d).data;else if(r||n)f=t.data;else if(o||s||a){if(su==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")su=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else su=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});su.canvas.width=c,su.canvas.height=d,su.drawImage(t,0,0,c,d),f=su.getImageData(0,0,c,d).data}let p;if(e===4)p=new Int32Array(f);else{const y=c*d;p=new Int32Array(y*e);for(let x=0;x<y;x++)for(let w=0;w<e;++w)p[x*e+w]=f[x*4+w]}return ND(p,[d,c,e],"int32")}function Kre(t){if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);const e=t.rank===2?1:t.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`)}async function JS(t,e){let n=L(t,"img","toPixels");if(!(t instanceof fn)){const c=n;n=Qt(c,"int32"),c.dispose()}Kre(n);const[r,s]=n.shape.slice(0,2),o=n.rank===2?1:n.shape[2],i=await n.data(),a=n.dtype==="float32"?255:1,l=new Uint8ClampedArray(s*r*4);for(let c=0;c<r*s;++c){const d=[0,0,0,255];for(let p=0;p<o;p++){const g=i[c*o+p];if(n.dtype==="float32"){if(g<0||g>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${g}.`)}else if(n.dtype==="int32"&&(g<0||g>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${g}.`);o===1?(d[0]=g*a,d[1]=g*a,d[2]=g*a):d[p]=g*a}const f=c*4;l[f+0]=Math.round(d[0]),l[f+1]=Math.round(d[1]),l[f+2]=Math.round(d[2]),l[f+3]=Math.round(d[3])}if(e!=null){DI||$g(ZP,Y.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),DI=!0),e.width=s,e.height=r;const c=e.getContext("2d"),d=new ImageData(l,s,r);c.putImageData(d,0,0)}return n!==t&&n.dispose(),l}const UD=X({fromPixels_:Hre});function eC(t,e){const n=t.shape.length,r=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${n}`);if(pe(t.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const s=e.shape,o=s[s.length-1];let i=1;for(let f=0;f<s.length-1;++f)i*=s[f];const a=t.shape,l=s.slice();l.pop();let c=1;for(let f=o;f<n;++f)c*=a[f],l.push(a[f]);const d=[...gn(t.shape).map(f=>f/c),1].slice(0,o);return[l,i,c,d]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xv=-2,Xre=-1;function tC(t,e,n){const r=t.shape.length;z(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),z(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)z(e[s]+n[s]<=t.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${e[s]+n[s]}) would overflow input.shape[${s}] (${t.shape[s]})`)}function qre(t){const e=[];let n=0;for(;t>0;)t&1&&e.push(n),t/=2,n++;return e}function nC(t,e,n){const r=[];for(let s=0;s<t.length;s++)r[s]=Math.ceil((e[s]-t[s])/n[s]);return r}function jD(t,e,n,r){const s=[...t];for(let o=s.length;o<r.length;o++)s.push(1);for(let o=0;o<n;o++)o===0?s[e]=1:(s.splice(e,0,1),s.pop());return s}function GD(t,e,n){return n<=t?n:n-(e-1)}function HD(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function Yre(t,e,n,r,s,o,i,a,l){const c=t.length;let d=new Array(c),f=new Array(c),p=new Array(c);if(e.length&&n>0){const g=e[0],y=n+1;d=KD(i,g,y,r,t),f=XD(a,g,y,s,t),p=jD(o,g,y,t)}else for(let g=0;g<c;g++)d[g]=YD(i,r,o,t,g,l),f[g]=QD(a,s,o,t,g,l),p[g]=qD(o,g,l);return{begin:d,end:f,strides:p}}function KD(t,e,n,r,s){const o=[...s],i=HD(n,e);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=0;else{const l=GD(e,n,a);let c=r[l];t&1<<l&&(c=0),o[a]=c}return o}function XD(t,e,n,r,s){const o=[...s],i=HD(n,e);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=Number.MAX_SAFE_INTEGER;else{const l=GD(e,n,a);let c=r[l];t&1<<l&&(c=Number.MAX_SAFE_INTEGER),o[a]=c}for(let a=0;a<o.length;a++){const l=s[a];o[a]<0&&(o[a]+=l),o[a]=yg(0,o[a],s[a])}return o}function qD(t,e,n){let r=t[e];return(n&1<<e||r==null)&&(r=1),r}function YD(t,e,n,r,s,o){let i=e[s];const a=n[s]||1;(t&1<<s||o&1<<s||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=yg(0,i,l-1),i}function QD(t,e,n,r,s,o){let i=e[s];const a=n[s]||1;(t&1<<s||o&1<<s||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),a>0?i=yg(0,i,l):i=yg(-1,i,l-1),i}function rC(t,e,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(e[s]>0||n[s]!==t[s])return!1;return!0}function sC(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function oC(t,e,n){let r;const s=t.shape.length;typeof e=="number"?r=[e,...new Array(s-1).fill(0)]:e.length<s?r=e.concat(new Array(s-e.length).fill(0)):r=e.slice(),r.forEach(i=>{z(i!==-1,()=>"slice() does not support negative begin indexing.")});let o;return n==null?o=new Array(s).fill(-1):typeof n=="number"?o=[n,...new Array(s-1).fill(-1)]:n.length<s?o=n.concat(new Array(s-n.length).fill(-1)):o=n,o=o.map((i,a)=>i>=0?i:(z(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),t.shape[a]-r[a])),[r,o]}function iC(t,e,n,r,s,o,i,a,l){let c;if(r==null?(c=new Array(e.length),c.fill(1)):c=r,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let d=!1;const f={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:c.slice(),beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};for(let I=0;I<f.dims;I++)d&&(1<<I&a)!==0&&f.numAddAxisAfterEllipsis++,1<<I&i&&(d=!0);d||(f.ellipsisMask|=1<<f.dims,f.dims++);const p={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Qre(f,p);let g=!0,y=!0,x=!0;const w=[],S=[];for(let I=0;I<t.length;++I){if(p.strides[I]===0)throw Error(`strides[${I}] must be non-zero`);const R=!!(p.shrinkAxisMask&1<<I),_=t[I];if(_===-1){w.push(R?1:-1);continue}const O=[p.beginMask&1<<I,p.endMask&1<<I],F=[p.strides[I]>0?0:-1,p.strides[I]>0?_:_-1];if(R&&p.strides[I]<=0)throw Error("only stride 1 allowed on non-range indexing.");x=x&&p.strides[I]===1;const B=!!(p.beginMask&1<<I&&p.endMask&1<<I);if(p.beginValid&&p.endValid){if(R){const re=p.begin[I]<0?_+p.begin[I]:p.begin[I];if(p.begin[I]=re,p.end[I]=p.begin[I]+1,re<0||re>=_)throw Error(`slice index ${p.begin[I]} of dimension ${I} out of bounds.`)}else p.begin[I]=OI(p.begin[I],0,p.strides[I],_,O,F),p.end[I]=OI(p.end[I],1,p.strides[I],_,O,F);const P=p.strides[I]===1&&p.begin[I]===0&&p.end[I]===_;g=g&&P,y=y&&(I===0&&p.strides[I]===1||P)}else g=g&&p.strides[I]===1&&B,y=y&&(I===0&&p.strides[I]===1||B);let M,V=!1;if(p.beginValid&&p.endValid?(M=p.end[I]-p.begin[I],V=!0):R?(M=1,V=!0):B&&_>=0&&(p.strides[I]<0?M=-_:M=_,V=!0),V){let P;M===0||M<0!=p.strides[I]<0?P=0:P=Math.trunc(M/p.strides[I])+(M%p.strides[I]!==0?1:0),w.push(P)}else w.push(-1)}for(let I=0;I<p.finalShapeGatherIndices.length;++I){const R=p.finalShapeGatherIndices[I];R>=0?S.push(w[R]):R===xv&&S.push(1)}return{finalShapeSparse:S.filter((I,R)=>p.finalShapeGatherIndices[R]!==xv),finalShape:S,isIdentity:g,sliceDim0:y,isSimpleSlice:x,begin:p.begin,end:p.end,strides:p.strides}}function Qre(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=t.begin!=null,e.endValid=t.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){const s=Math.min(e.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<s;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&t.newAxisMask)e.finalShapeGatherIndices.push(xv),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);t.begin!=null&&(e.begin[n]=t.begin[r]),t.end!=null&&(e.end[n]=t.end[r]),e.strides[n]=t.strides[r],t.beginMask&1<<r&&(e.beginMask|=1<<n),t.endMask&1<<r&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(Xre),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[n]=r,n++}}function OI(t,e,n,r,s,o){if(s[e])return n>0?o[e]:o[e+1&1];{const i=t<0?r+t:t;return i<o[0]?o[0]:i>o[1]?o[1]:i}}const Zre=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:tC,computeFlatOffset:sC,computeOutShape:nC,getNormalizedAxes:Yre,isSliceContinous:rC,maskToAxes:qre,parseSliceParams:oC,sliceInfo:iC,startForAxis:YD,startIndicesWithElidedDims:KD,stopForAxis:QD,stopIndicesWithElidedDims:XD,stridesForAxis:qD,stridesWithElidedDims:jD},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jre=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t();function ese(){return new Promise(t=>Jre(()=>t()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aC(t,e){const n=t[0].length;t.forEach((s,o)=>{z(s.length===n,()=>`Error in concat${n}D: rank of tensors[${o}] must be the same as the rank of the rest (${n})`)}),z(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=t[0];t.forEach((s,o)=>{for(let i=0;i<n;i++)z(i===e||s[i]===r[i],()=>`Error in concat${n}D: Shape of tensors[${o}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`)})}function co(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Oo;(function(t){t[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS"})(Oo||(Oo={}));function ZD(t,e,n){let r=new Array;if(n==null&&e==null)return r;if(e==null)for(;r.length<t+n.length;)r.push(-1);else r=e.slice();if(n==null)return r;if(t+n.length!==r.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${t+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){const o=n[s],i=r[r.length-n.length+s],a=r[i];if(o>=0)if(a>=0){if(a!==o)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${s+t}] = ${o} but shape[${s+t}] = ${a}`)}else r[i]=o}return r}function JD(t){const e={FIRST_DIM_SIZE:Oo.FIRST_DIM_SIZE,VALUE_ROWIDS:Oo.VALUE_ROWIDS,ROW_LENGTHS:Oo.ROW_LENGTHS,ROW_SPLITS:Oo.ROW_SPLITS,ROW_LIMITS:Oo.ROW_LIMITS,ROW_STARTS:Oo.ROW_STARTS},n=[];for(const r of t)if(r in e)n.push(e[r]);else break;return n}function eO(t){return t.length===0?0:t[0]===Oo.FIRST_DIM_SIZE?t.length-1:t.length}function tO(t,e){if(t==null||e==null)return;const n=t.length,r=e.length;if(n>=r)throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){const o=t[s],i=e[s+1];if(o>=0&&i>=0&&o!==1&&o!==i)throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${s-t.length}] = ${o} but ragged tensor input.flatValues.shape[${s-t.length}] = ${i}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lC=30;function xy(t){return t<=lC?t:ev(t,Math.floor(Math.sqrt(t)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uC(t,e,n){const r=n*(typeof t=="number"?t:t[0]),s=e*(typeof t=="number"?t:t[1]);return[r,s]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yf(t,e,n,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(t[0]/n),s=s.concat(t.slice(1));else{s=s.concat(t[0]);const o=e.length;for(let i=0;i<o;++i)s=s.concat([t[i+1]/e[i],e[i]]);s=s.concat(t.slice(o+1))}return s}function Qf(t,e,n=!0){const r=[];if(n){r.push(e);for(let s=e+1;s<t;++s)s<=2*e?(r.push(s),r.push(s-(e+1))):r.push(s)}else{const s=[],o=[];for(let i=1;i<t;++i)i>=e*2+1||i%2===1?o.push(i):s.push(i);r.push(...s),r.push(0),r.push(...o)}return r}function Zf(t,e,n,r=!0){const s=[];r?s.push(t[0]/n):s.push(t[0]*n);for(let o=1;o<t.length;++o)o<=e.length?r?s.push(e[o-1]*t[o]):s.push(t[o]/e[o-1]):s.push(t[o]);return s}function cC(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function dC(t,e,n){const r=t.slice(0,1);for(let s=0;s<n;++s)r.push(t[s+1]-e[s][0]-e[s][1]);return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hC=1.7580993408473768,fC=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pC=.3275911,mC=.254829592,gC=-.284496736,yC=1.421413741,xC=-1.453152027,vC=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kf(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(t.length*2);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function tse(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function nse(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=0;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function rse(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=2;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function sse(t,e){const n=t[e*2],r=t[e*2+1];return{real:n,imag:r}}function ose(t,e,n,r){t[r*2]=e,t[r*2+1]=n}function ise(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let s=0;s<Math.ceil(t/2);s++){const o=(e?2:-2)*Math.PI*(s/t);n[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:n,imag:r}}function ase(t,e,n){const r=(n?2:-2)*Math.PI*(t/e),s=Math.cos(r),o=Math.sin(r);return{real:s,imag:o}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q1="->",lse=/->/g,FI=",",LI="...";function bC(t,e){t=t.replace(/\s/g,"");const n=(t.length-t.replace(lse,"").length)/q1.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${q1}").`);const[r,s]=t.split(q1);z(r.indexOf(LI)===-1,()=>`The ellipsis notation ("${LI}") is not supported yet.`);const o=r.split(FI),i=o.length;if(e!==i)throw new Error(`Expected ${i} input tensors, received ${e}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let p=0;p<s.length;++p){const g=s[p];if(!o.some(y=>y.indexOf(g)!==-1))throw new Error(`Output subscripts contain the label ${g} not present in the input subscripts.`);a.indexOf(g)===-1&&a.push(g)}for(let p=0;p<r.length;++p){const g=r[p];a.indexOf(g)===-1&&g!==FI&&a.push(g)}const l=new Array(o.length);for(let p=0;p<i;++p){if(new Set(o[p].split("")).size!==o[p].length)throw new Error(`Found duplicate axes in input component ${o[p]}. Support for duplicate axes in input is not implemented yet.`);l[p]=[];for(let g=0;g<o[p].length;++g)l[p].push(a.indexOf(o[p][g]))}const c=a.length,d=s.length,f=[];for(let p=d;p<c;++p)f.push(p);return{allDims:a,summedDims:f,idDims:l}}function wC(t,e){let n=new Array(t);n.fill(-1);for(let s=0;s<e.length;++s)n[e[s]]=s;const r=[];for(let s=0;s<t;++s)n[s]===-1&&r.push(s);return n=n.filter(s=>s!==-1),{permutationIndices:n,expandDims:r}}function SC(t,e,n){const r=new Array(t);for(let s=0;s<n.length;++s){const o=n[s].shape;for(let i=0;i<e[s].length;++i)r[e[s][i]]===void 0?r[e[s][i]]=o[i]:z(r[e[s][i]]===o[i],()=>`Expected dimension ${r[e[s][i]]} at axis ${i} of input shaped ${JSON.stringify(o)}, but got dimension ${o[i]}`)}}function CC(t,e){const n=t,r=[];let s=0;t.length===0&&n.push(-1),s=t.length+1;for(let i=0;i<s;++i)r.push([]);const o=[];for(let i=0;i<n.length;++i){const a=n[i],l=use(e,a);for(const c of l)o.indexOf(c)===-1&&(r[i].push(c),o.push(c))}return{path:n,steps:r}}function $C(t){return t.every((e,n)=>e===n)}function use(t,e){const n=[];for(let r=0;r<t.length;++r)(t[r].length===0||t[r].indexOf(e)!==-1||e===-1)&&n.push(r);return n}function kC(t,e,n=0){let r=[];if(typeof e=="number")z(t.shape[n]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(t.shape[n]/e);else{const s=e.reduce((i,a)=>(a===-1&&(i+=1),i),0);z(s<=1,()=>"There should be only one negative value in split array.");const o=e.indexOf(-1);if(o!==-1){const i=e.reduce((a,l)=>l>0?a+l:a);e[o]=t.shape[n]-i}z(t.shape[n]===e.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nO(t){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${t}`}function rO(t,e){return`indices(${t}, 0) is invalid: ${e} < 0`}function sO(t,e,n){return`indices(${t}, 0) is invalid: ${e} >= ${n}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oO(t,e){return`only one output dimension may be -1, not both ${t} and ${e}`}function iO(t,e){return`size ${t} must be non-negative, not ${e}`}function aO(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function lO(t,e){const n=pe(t),r=pe(e);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${t} outputShape= ${e}`}function uO(t,e){const n=pe(t),r=pe(e);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${t} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vv(){return"segment ids must be >= 0"}function cO(){return"segment ids are not increasing"}function dO(t,e){return`Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function hO(t,e,n){return`Bad: indices[${t}] == ${e} out of range [0, ${n})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fO(t,e){let n=!1,r;for(t<=lC?(r=t,n=!0):r=ev(t,Math.floor(Math.sqrt(t)));!n;)r>e||r===t?n=!0:r=ev(t,r+1);return r}function TC(t,e,n){const r=[],s=t.length;for(let o=0;o<s;o++)o!==e?r.push(t[o]):r.push(n);return r}function IC(t,e,n,r){const s=e.shape.length,o=t.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${o}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let f=0;f<r;++f)if(t.shape[f]!==e.shape[f])throw new Error(`x.shape[${f}]: ${t.shape[f]} should be equal to indices.shape[${f}]: ${e.shape[f]}.`);const i=t.shape[n],a=[];let l=1,c=1,d=1;for(let f=0;f<r;++f)a.push(t.shape[f]),l*=t.shape[f];for(let f=r;f<n;f++)a.push(t.shape[f]),c*=t.shape[f];for(let f=r;f<s;f++)a.push(e.shape[f]);for(let f=n+1;f<o;f++)a.push(t.shape[f]),d*=t.shape[f];return{batchSize:l,sliceSize:d,outerSize:c,dimSize:i,outputShape:a}}const cse=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:IC,computeOutShape:TC,segOpComputeOptimalWindowSize:fO},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bl(t){try{return t.map(e=>fa(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function pO(t){return t.map(e=>hl(e))}const dse=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:mC,ERF_A2:gC,ERF_A3:yC,ERF_A4:xC,ERF_A5:vC,ERF_P:pC,PARALLELIZE_THRESHOLD:lC,get RowPartitionType(){return Oo},SELU_SCALE:fC,SELU_SCALEALPHA:hC,applyActivation:gy,assertAndGetBroadcastShape:ct,assertAxesAreInnerMostDims:vs,assertParamsConsistent:aC,assignToTypedArray:ose,axesAreInnerMostDims:zS,calculateShapes:Bu,checkEinsumDimSizes:SC,checkPadOnDimRoundingMode:po,combineLocations:sD,combineRaggedTensorToTensorShapes:ZD,complexWithEvenIndex:nse,complexWithOddIndex:rse,computeConv2DInfo:kn,computeConv3DInfo:Tl,computeDefaultPad:FS,computeDilation2DInfo:Kf,computeOptimalWindowSize:xy,computeOutAndReduceShapes:Fs,computeOutShape:co,computePool2DInfo:fo,computePool3DInfo:Sa,convertConv2DDataFormat:Mo,decodeEinsumEquation:bC,eitherStridesOrDilationsAreOne:Nr,expandShapeToKeepDim:xs,exponent:ase,exponents:ise,fromStringArrayToUint8:pO,fromUint8ToStringArray:bl,getAxesPermutation:lr,getBroadcastDims:cd,getComplexWithIndex:sse,getEinsumComputePath:CC,getEinsumPermutation:wC,getFusedBiasGradient:my,getFusedDyActivation:py,getImageCenter:uC,getInnerMostAxes:ur,getPermuted:Qf,getRaggedRank:eO,getReductionAxes:tD,getReshaped:Yf,getReshapedPermuted:Zf,getRowPartitionTypesHelper:JD,getSliceBeginCoords:cC,getSliceSize:dC,getSparseFillEmptyRowsIndicesDenseShapeMismatch:nO,getSparseFillEmptyRowsNegativeIndexErrorMessage:rO,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:sO,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:aO,getSparseReshapeInputOutputMismatchErrorMessage:uO,getSparseReshapeInputOutputMultipleErrorMessage:lO,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:oO,getSparseReshapeNegativeOutputDimErrorMessage:iO,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:hO,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:vv,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:cO,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:dO,getUndoAxesPermutation:qf,isIdentityPermutation:$C,log:cX,mergeRealAndImagArrays:kf,prepareAndValidate:eC,prepareSplitSize:kC,segment_util:cse,shouldFuse:yy,slice_util:Zre,splitRealAndImagArrays:tse,stridesOrDilationsArePositive:Du,tupleValuesAreOne:xf,upcastType:jr,validateDefaultValueShape:tO,validateInput:HS,validateUpdateShape:ED,warn:Lo},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Nre();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fu={},bm={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function hse(t,e){fu[t]=e}function zo(t,e){if(!(t in fu)||e!=null){const r=pse(t,e);if(r!==null)fu[t]=r;else return console.log("Could not get context for WebGL version",t),null}const n=fu[t];return n==null||n.isContextLost()?(delete fu[t],zo(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),fu[t])}function fse(t){if(!se().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&t===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function pse(t,e){if(t!==1&&t!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=e??fse(t);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete fu[t]},!1),se().getBool("SOFTWARE_WEBGL_ENABLED")&&(bm.failIfMajorPerformanceCaveat=!1),t===1?n.getContext("webgl",bm)||n.getContext("experimental-webgl",bm):n.getContext("webgl2",bm)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Tf;(function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"})(Tf||(Tf={}));var _s;(function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"})(_s||(_s={}));var qn;(function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(qn||(qn={}));function Jf(t,e){return[e,t]}function mse(t,e){return t*e}function wm(t){const e=pe(t),n=Math.ceil(e/4);return Zx(n)}function Id(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function gse(t,e){const[n,r]=Id(t,e);return n*r*4}function NC(t,e){const n=t;let r,s,o,i,a,l,c,d,f,p;return se().getNumber("WEBGL_VERSION")===2?(r=n.R32F,s=n.R16F,o=n.RGBA16F,i=n.RGBA32F,a=n.RED,c=4,d=1,f=n.HALF_FLOAT,p=n.FLOAT,l=n.RGBA8):(r=t.RGBA,s=t.RGBA,o=t.RGBA,i=n.RGBA,a=t.RGBA,c=4,d=4,f=e!=null?e.HALF_FLOAT_OES:null,p=t.FLOAT,l=t.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:d,textureTypeHalfFloat:f,textureTypeFloat:p}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oe(t,e){const n=e();return se().getBool("DEBUG")&&yse(t),n}function yse(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+wse(t,e))}const xse=596e-10,vse=65504;function bse(t){return!!(se().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||t===0||xse<Math.abs(t)&&Math.abs(t)<vse)}function wse(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Sm(t,e){return $a(t,()=>t.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function Sse(t,e){const n=$a(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Oe(t,()=>t.shaderSource(n,e)),Oe(t,()=>t.compileShader(n)),t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function Cse(t,e){const n=$a(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Oe(t,()=>t.shaderSource(n,e)),Oe(t,()=>t.compileShader(n)),se().get("ENGINE_COMPILE_ONLY"))return n;if(t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw mO(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const $se=/ERROR: [0-9]+:([0-9]+):/g;function mO(t,e){const n=$se.exec(e);if(n==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(t);return}const r=+n[1],s=t.split(`
`),o=s.length.toString().length+2,i=s.map((f,p)=>Yc((p+1).toString(),o)+f);let a=0;for(let f=0;f<i.length;f++)a=Math.max(i[f].length,a);const l=i.slice(0,r-1),c=i.slice(r-1,r),d=i.slice(r);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Yc(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join(`
`))}function kse(t){return $a(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}function Tse(t,e){if(Oe(t,()=>t.linkProgram(e)),!se().get("ENGINE_COMPILE_ONLY")&&t.getProgramParameter(e,t.LINK_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function Y1(t,e){if(Oe(t,()=>t.validateProgram(e)),t.getProgramParameter(e,t.VALIDATE_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function Ise(t,e){const n=$a(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Oe(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),Oe(t,()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function Nse(t,e){const n=$a(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Oe(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)),Oe(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function Ese(t){return $a(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}function Rse(t,e){const n=se().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){const r=`[${t}x${e}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(t>n||e>n){const r=`[${t}x${e}]`,s=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function _se(t){return $a(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function zI(t,e,n,r,s,o,i){const a=t.getAttribLocation(e,n);return a===-1?!1:(Oe(t,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),Oe(t,()=>t.vertexAttribPointer(a,s,t.FLOAT,!1,o,i)),Oe(t,()=>t.enableVertexAttribArray(a)),!0)}function Pse(t,e,n){Lse(t,n),Oe(t,()=>t.activeTexture(t.TEXTURE0+n)),Oe(t,()=>t.bindTexture(t.TEXTURE_2D,e))}function Ase(t,e,n){return $a(t,()=>t.getUniformLocation(e,n),'uniform "'+n+'" not present in program.')}function Dse(t,e,n){return t.getUniformLocation(e,n)}function Ose(t,e,n,r){Oe(t,()=>Pse(t,e,r)),Oe(t,()=>t.uniform1i(n,r))}function Q1(t,e,n){Oe(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),Oe(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0))}function BI(t,e){Oe(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),Oe(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function Cm(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Fse(t,e))}function Fse(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function $a(t,e,n){const r=Oe(t,()=>e());if(r==null)throw new Error(n);return r}function Lse(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n){const s=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${s}.`)}}function dd(t,e=2){return pe(t.slice(0,t.length-e))}function hd(t){if(t.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function $m(t){let e=[1,1,1];return t.length===0||t.length===1&&t[0]===1||(e=[dd(t),...hd(t)]),e}function zse(t,e=!1){let n=se().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=se().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&se().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),e&&(n=n*2,r=r*2,t=t.map((a,l)=>l>=t.length-2?Jb(t[l]):t[l]),t.length===1&&(t=[2,t[0]])),t.length!==2&&(t=Cl(t).newShape);let s=pe(t),o=null;t.length<=1&&s<=n?o=[1,s]:t.length===2&&t[0]<=n&&t[1]<=n?o=t:t.length===3&&t[0]*t[1]<=n&&t[2]<=n?o=[t[0]*t[1],t[2]]:t.length===3&&t[0]<=n&&t[1]*t[2]<=n?o=[t[0],t[1]*t[2]]:t.length===4&&t[0]*t[1]*t[2]<=n&&t[3]<=n?o=[t[0]*t[1]*t[2],t[3]]:t.length===4&&t[0]<=n&&t[1]*t[2]*t[3]<=n&&(o=[t[0],t[1]*t[2]*t[3]]);const i=o!=null&&Math.max(...o)>r&&Math.min(...o)<=(e?2:1)&&Math.min(...o)>0;if(o==null||i)if(e){const a=dd(t);let l=2,c=2;t.length&&([l,c]=hd(t)),s=a*(l/2)*(c/2),o=Zx(s).map(d=>d*2)}else o=Zx(s);return o}function km(t){return t%2===0}function Rg(t,e){if(t=t.slice(-2),e=e.slice(-2),Vt(t,e)||!t.length||!e.length||t[0]===0||t[1]===0||e[0]===0||e[1]===0)return!0;if(t.length!==e.length){const n=t[t.length-1],r=e[e.length-1];if(n===r||km(n)&&km(r)&&(t[0]===1||e[0]===1))return!0}return t[1]===e[1]&&km(t[0])&&km(e[0])}let Z1,J1;function Bse(t){if(Z1==null){const e=zo(t);Z1=e.getParameter(e.MAX_TEXTURE_SIZE)}return Z1}function Mse(t){if(J1==null){const e=zo(t);J1=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,J1)}function Vse(t){if(t===0)return 0;let e;const n=zo(t);return oo(n,"EXT_disjoint_timer_query_webgl2")&&t===2?e=2:oo(n,"EXT_disjoint_timer_query")?e=1:e=0,e}function oo(t,e){return t.getExtension(e)!=null}function MI(t){try{if(zo(t)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function Wse(t){if(t===0)return!1;const e=zo(t);if(t===1){if(!oo(e,"OES_texture_float"))return!1}else if(!oo(e,"EXT_color_buffer_float"))return!1;return bv(e)}function Use(t){if(t===0)return!1;const e=zo(t);if(t===1){if(!oo(e,"OES_texture_float")||!oo(e,"WEBGL_color_buffer_float"))return!1}else{if(oo(e,"EXT_color_buffer_float"))return bv(e);const r="EXT_color_buffer_half_float";if(oo(e,r)){const s=e.getExtension(r);return jse(e,s)}return!1}return bv(e)}function bv(t){const e=NC(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(o),i}function jse(t,e){const n=NC(t,e),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(i),a}function Gse(t){return t!==2?!1:zo(t).fenceSync!=null}function ep(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&z(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ve=se();Ve.registerFlag("HAS_WEBGL",()=>Ve.getNumber("WEBGL_VERSION")>0);Ve.registerFlag("WEBGL_VERSION",()=>MI(2)?2:MI(1)?1:0);Ve.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Ve.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Ve.get("WEBGL_VERSION")===2);Ve.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Ve.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Ve.registerFlag("WEBGL_PACK",()=>Ve.getBool("HAS_WEBGL"));Ve.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_CLIP",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_REDUCE",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_LAZILY_UNPACK",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_CONV_IM2COL",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Bse(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Mse(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=Ve.getNumber("WEBGL_VERSION");return t===0?0:Vse(t)});Ve.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Ve.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!RA());Ve.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Wse(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Ve.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Ve.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Ve.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Use(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_FENCE_API_ENABLED",()=>Gse(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Ve.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Ve.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)});Ve.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>RA()?1:-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)});Ve.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Ve.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Ve.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Ve.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Ve.registerFlag("WEBGL_EXP_CONV",()=>!1);Ve.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Ve.getBool("IS_TEST"));Ve.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Ve.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Ve.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Ve.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Er(){let t,e,n,r,s,o,i,a,l,c;return se().getNumber("WEBGL_VERSION")===2?(t="#version 300 es",e="in",n="out",r="in",s="texture",o="outputColor",i="out vec4 outputColor;",a=se().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(t="",e="attribute",n="varying",r="varying",s="texture2D",o="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:s,output:o,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wu(t,e,n="index"){const r=gn(e);return r.map((s,o)=>{const i=`int ${t[o]} = ${n} / ${s}`,a=o===r.length-1?`int ${t[o+1]} = ${n} - ${t[o]} * ${s}`:`index -= ${t[o]} * ${s}`;return`${i}; ${a};`}).join("")}function vy(t,e,n="index"){const r=gn(e);return r.map((s,o)=>{const i=`int ${t[o]} = ${n} / outShapeStrides[${o}]`,a=o===r.length-1?`int ${t[o+1]} = ${n} - ${t[o]} * outShapeStrides[${o}]`:`index -= ${t[o]} * outShapeStrides[${o}]`;return`${i}; ${a};`}).join("")}function Hse(t,e){const n=t.length,r=t.map(o=>`${e}[${o}]`),s=new Array(n-1);s[n-2]=r[n-1];for(let o=n-3;o>=0;--o)s[o]=`(${s[o+1]} * ${r[o+1]})`;return s}function Kse(t,e,n="index"){const r=t.map((o,i)=>i),s=Hse(r,e);return s.map((o,i)=>{const a=`int ${t[i]} = ${n} / ${s[i]}`,l=i===s.length-1?`int ${t[i+1]} = ${n} - ${t[i]} * ${s[i]}`:`index -= ${t[i]} * ${s[i]}`;return`${a}; ${l};`}).join("")}function EC(t){const e=gn(t).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function RC(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const gO=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:yO}=dse;function Xse(t,e,n){const r=[];if(t.forEach(g=>{const y=pe(g.shapeInfo.logicalShape);if(g.shapeInfo.isUniform?r.push(`uniform float ${g.name}${y>1?`[${y}]`:""};`):(r.push(`uniform sampler2D ${g.name};`),r.push(`uniform int offset${g.name};`)),n.enableShapeUniforms){const{uniformShape:x}=_C(n.packedInputs,g.shapeInfo.logicalShape,g.shapeInfo.texShape);switch(x.length){case 1:r.push(`uniform int ${g.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${g.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${g.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${g.name}Shape;`);break}r.push(`uniform ivec2 ${g.name}TexShape;`)}}),n.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(g=>{r.push(`uniform ${g.type} ${g.name}${g.arrayIndex?`[${g.arrayIndex}]`:""};`)});const s=r.join(`
`),o=t.map(g=>qse(g,e,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=e.texShape,a=Er(),l=Zse(a);let c,d,f=toe(a);return e.isPacked?(c=Yse(e.logicalShape,i,n.enableShapeUniforms),d=eoe(a)):(c=Qse(e.logicalShape,i,n.enableShapeUniforms),d=Jse(a)),n.packedInputs&&(f+=ooe),[f,l,d,s,c,o,n.userCode].join(`
`)}function Nd(t,e=!1){const n=t.shapeInfo.logicalShape;switch(n.length){case 0:return yoe(t,e);case 1:return voe(t,e);case 2:return woe(t,e);case 3:return Coe(t,e);case 4:return koe(t,e);case 5:return Toe(t);case 6:return Ioe(t);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function xO(t,e){switch(t.shapeInfo.logicalShape.length){case 0:return goe(t);case 1:return xoe(t,e);case 2:return boe(t,e);case 3:return Soe(t,e);default:return $oe(t,e)}}function qse(t,e,n=!1,r){let s="";n?s+=xO(t,r):s+=Nd(t,r);const o=t.shapeInfo.logicalShape,i=e.logicalShape;return o.length<=i.length&&(n?s+=Noe(t,e):s+=Eoe(t,e)),s}function Yse(t,e,n){switch(t.length){case 0:return vO();case 1:return ioe(t,e,n);case 2:return poe(t,e,n);case 3:return loe(t,e,n);default:return coe(t,e,n)}}function Qse(t,e,n){switch(t.length){case 0:return vO();case 1:return aoe(t,e,n);case 2:return moe(t,e,n);case 3:return uoe(t,e,n);case 4:return doe(t,e,n);case 5:return hoe(t,e);case 6:return foe(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}function Zse(t){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${t.texture2D}(textureSampler, uv).r;
    }
  `}function Jse(t){return`
    void setOutput(float val) {
      ${t.output} = vec4(val, 0, 0, 0);
    }
  `}function eoe(t){return`
    void setOutput(vec4 val) {
      ${t.output} = val;
    }
  `}function toe(t){return`${t.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${t.varyingFs} vec2 resultUV;
    ${t.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${t.defineSpecialNaN}
    ${t.defineSpecialInf}
    ${t.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${noe}
    ${roe}
    ${soe}
  `}const noe=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,roe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,soe=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,ooe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function vO(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function ioe(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function aoe(t,e,n){return e[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function loe(t,e,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[2]/2),o=s*Math.ceil(t[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function uoe(t,e,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${vy(["r","c","d"],t)}
    return ivec3(r, c, d);
  }
`;const r=Wu(["r","c","d"],t);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function coe(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[t.length-1]/2),o=s*Math.ceil(t[t.length-2]/2);let i=o,a="",l="b, r, c";for(let c=2;c<t.length-1;c++)i*=t[t.length-c-1],a=`
      int b${c} = index / ${i};
      index -= b${c} * ${i};
    `+a,l=`b${c}, `+l;return`
    ivec${t.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${a}

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${t.length}(${l});
    }
  `}function doe(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${vy(["r","c","d","d2"],t)}
      return ivec4(r, c, d, d2);
    }
  `;const r=Wu(["r","c","d","d2"],t);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function hoe(t,e){const n=Wu(["r","c","d","d2","d3"],t);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function foe(t,e){const n=Wu(["r","c","d","d2","d3","d4"],t);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function poe(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Vt(t,e))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const s=Math.ceil(t[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function moe(t,e,n){return Vt(t,e)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:t[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:t[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${t[1]};
      int c = index - r * ${t[1]};
      return ivec2(r, c);
    }
  `}function Uu(t){return`offset${t}`}function goe(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=Er();return`
    vec4 ${n}() {
      return ${r.texture2D}(${e}, halfCR);
    }
  `}function yoe(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[s,o]=t.shapeInfo.texShape;if(s===1&&o===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;const i=Uu(n);if(e)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;const[a,l]=t.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function xoe(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t.shapeInfo.texShape,o=Er();if(e)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${o.texture2D}(${n}, uv);
    }
  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${o.texture2D}(${n}, uv);
    }
  `}function voe(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Ed(t)}
      }
    `;const s=t.shapeInfo.texShape,o=s[0],i=s[1];if(i===1&&o===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;const a=Uu(n);return i===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${o}.0);
        return sampleTexture(${n}, uv);
      }
    `:o===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:e?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${a});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${o}, ${i}, index + ${a});
      return sampleTexture(${n}, uv);
    }
  `}function boe(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape,i=o[0],a=o[1],l=Er();if(o!=null&&Vt(n,o))return e?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(e)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;const c=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],d=Math.ceil(n[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${d}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function woe(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape;if(o!=null&&Vt(n,o)){if(e)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const p=o[0],g=o[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${g}.0, ${p}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:i,keptDims:a}=Cl(n),l=i;if(l.length<n.length){const p=Rd(t,l),g=["row","col"];return`
      ${Nd(p,e)}
      float ${s}(int row, int col) {
        return ${s}(${_d(g,a)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${Ed(t)}
      }
    `;const c=o[0],d=o[1],f=Uu(r);return d===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${r}, uv);
    }
  `:c===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:e?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${f};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${f};
    vec2 uv = uvFromFlat(${c}, ${d}, index);
    return sampleTexture(${r}, uv);
  }
`}function Soe(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(n[0]===1){const p=n.slice(1),g=[1,2],y=Rd(t,p),x=["b","row","col"];return`
        ${xO(y,e)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${_d(x,g)});
        }
      `}const a=Er();if(e)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `;const l=i[0],c=i[1],d=Math.ceil(n[2]/2),f=d*Math.ceil(n[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${f}, ${d}, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `}function Coe(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[1]*n[2],i=n[2],{newShape:a,keptDims:l}=Cl(n),c=a;if(c.length<n.length){const x=Rd(t,c),w=["row","col","depth"];return`
        ${Nd(x,e)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${_d(w,l)});
        }
      `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${o}, ${i}, 1)));
        ${Ed(t)}
      }
    `;const d=t.shapeInfo.texShape,f=d[0],p=d[1],g=t.shapeInfo.flatOffset;if(p===o&&g==null)return e?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${p}.0, ${f}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(p===i&&g==null)return e?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${f}.0);
      return sampleTexture(${r}, uv);
    }
  `;const y=Uu(r);return e?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${y};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o} + col * ${i} + depth + ${y};
        vec2 uv = uvFromFlat(${f}, ${p}, index);
        return sampleTexture(${r}, uv);
      }
  `}function $oe(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=Er();if(e)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);
    }
  `;const o=t.shapeInfo.logicalShape,i=o.length,a=t.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],d=l[1],f=Math.ceil(o[i-1]/2);let p=f*Math.ceil(o[i-2]/2),g="int b, int row, int col",y=`b * ${p} + (row / 2) * ${f} + (col / 2)`;for(let x=2;x<i-1;x++)g=`int b${x}, `+g,p*=o[i-x-1],y=`b${x} * ${p} + `+y;return`
    vec4 ${r}(${g}) {
      int index = ${y};
      int texR = index / ${d};
      int texC = index - texR * ${d};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${c});
      return ${s.texture2D}(${n}, uv);
    }
  `}function koe(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[3],i=n[2]*o,a=n[1]*i,{newShape:l,keptDims:c}=Cl(n);if(l.length<n.length){const $=Rd(t,l),I=["row","col","depth","depth2"];return`
      ${Nd($,e)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${_d(I,c)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${o}, 1)));
        ${Ed(t)}
      }
    `;const d=t.shapeInfo.flatOffset,f=t.shapeInfo.texShape,p=f[0],g=f[1],y=`int stride2 = ${r}Shape[3];`,x=`int stride1 = ${r}Shape[2] * stride2;`,w=`int stride0 = ${r}Shape[1] * stride1;`;if(g===a&&d==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${y}
        ${x}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${p}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(g===o&&d==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${p}.0);
        return sampleTexture(${r}, uv);
      }
    `;const S=Uu(r);return e?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${y}
      ${x}
      ${w}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${S});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${o} + depth2;
      vec2 uv = uvFromFlat(${p}, ${g}, index + ${S});
      return sampleTexture(${r}, uv);
    }
  `}function Toe(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[4],o=e[3]*s,i=e[2]*o,a=e[1]*i,{newShape:l,keptDims:c}=Cl(e);if(l.length<e.length){const x=Rd(t,l),w=["row","col","depth","depth2","depth3"];return`
      ${Nd(x)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${_d(w,c)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${o}, ${s})) +
          depth3;
        ${Ed(t)}
      }
    `;const d=t.shapeInfo.flatOffset,f=t.shapeInfo.texShape,p=f[0],g=f[1];if(g===a&&d==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${o}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(g===s&&d==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;const y=Uu(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${o} +
          depth2 * ${s} + depth3 + ${y};
      vec2 uv = uvFromFlat(${p}, ${g}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Ioe(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:o}=Cl(e);if(s.length<e.length){const w=Rd(t,s),S=["row","col","depth","depth2","depth3","depth4"];return`
      ${Nd(w)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${_d(S,o)});
      }
    `}const i=e[5],a=e[4]*i,l=e[3]*a,c=e[2]*l,d=e[1]*c;if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${d}, ${c}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Ed(t)}
      }
    `;const f=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,g=p[0],y=p[1];if(y===d&&f==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${g}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(y===i&&f==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${g}.0);
        return sampleTexture(${n}, uv);
      }
    `;const x=Uu(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${d} + col * ${c} + depth * ${l} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${x};
      vec2 uv = uvFromFlat(${g}, ${y}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Ed(t){const e=t.name,n=pe(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function Noe(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",o=t.shapeInfo.logicalShape.length,i=e.logicalShape.length,a=yO(t.shapeInfo.logicalShape,e.logicalShape),l=Kt(i),c=i-o;let d;const f=["x","y","z","w","u","v"];o===0?d="":i<2&&a.length>=1?d="coords = 0;":d=a.map($=>`coords.${f[$+c]} = 0;`).join(`
`);let p="";i<2&&o>0?p="coords":p=t.shapeInfo.logicalShape.map(($,I)=>`coords.${f[I+c]}`).join(", ");let g="return outputValue;";const x=pe(t.shapeInfo.logicalShape)===1,S=pe(e.logicalShape)===1;if(o===1&&!x&&!S)g=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(x&&!S)i===1?g=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:g=`
        return vec4(outputValue.x);
      `;else if(a.length){const $=o-2,I=o-1;a.indexOf($)>-1&&a.indexOf(I)>-1?g="return vec4(outputValue.x);":a.indexOf($)>-1?g="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(I)>-1&&(g="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${l} coords = getOutputCoords();
      ${d}
      vec4 outputValue = get${r}(${p});
      ${g}
    }
  `}function Eoe(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",o=e.texShape,i=t.shapeInfo.texShape,a=t.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!t.shapeInfo.isUniform&&a===l&&t.shapeInfo.flatOffset==null&&Vt(i,o))return`
      float ${s}() {
        return sampleTexture(${n}, resultUV);
      }
    `;const c=Kt(l),d=yO(t.shapeInfo.logicalShape,e.logicalShape),f=l-a;let p;const g=["x","y","z","w","u","v"];a===0?p="":l<2&&d.length>=1?p="coords = 0;":p=d.map(x=>`coords.${g[x+f]} = 0;`).join(`
`);let y="";return l<2&&a>0?y="coords":y=t.shapeInfo.logicalShape.map((x,w)=>`coords.${g[w+f]}`).join(", "),`
    float ${s}() {
      ${c} coords = getOutputCoords();
      ${p}
      return get${r}(${y});
    }
  `}function Kt(t){if(t<=1)return"int";if(t===2)return"ivec2";if(t===3)return"ivec3";if(t===4)return"ivec4";if(t===5)return"ivec5";if(t===6)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function _C(t,e,n){const{newShape:r,keptDims:s}=Cl(e),o=e.length,i=t&&o===3&&e[0]===1,a=i?e.slice(1):r,l=!t&&o>1&&!Vt(e,n)&&r.length<o||i;return{useSqueezeShape:l,uniformShape:l?a:e,keptDims:s}}function Rd(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function _d(t,e){return e.map(n=>t[n]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Roe(t,e,n,r){const s=n.map((d,f)=>{const p={logicalShape:d.shape,texShape:d.isUniform?null:d.texData.texShape,isUniform:d.isUniform,isPacked:d.isUniform?!1:d.texData.isPacked,flatOffset:null};return d.texData!=null&&d.texData.slice!=null&&d.texData.slice.flatOffset>0&&(p.flatOffset=d.texData.slice.flatOffset),{name:e.variableNames[f],shapeInfo:p}}),o=s.map(d=>d.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=Xse(s,i,e),l=Cse(t.gl,a),c=t.createProgram(l);return se().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:o,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(t.buildVao(c),Object.assign({program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:o,outShapeInfo:i},bO(t,e,c)))}function bO(t,e,n){const r=[],s=[];let o,i,a,l=null,c=null;c=t.getUniformLocation(n,"NAN",!1),se().getNumber("WEBGL_VERSION")===1&&(l=t.getUniformLocation(n,"INFINITY",!1));const d=!1;for(const f of e.variableNames){const p={name:f,uniform:t.getUniformLocation(n,f,d),offset:t.getUniformLocation(n,`offset${f}`,d)};e.enableShapeUniforms&&(p.shape=t.getUniformLocation(n,`${f}Shape`,d),p.texShape=t.getUniformLocation(n,`${f}TexShape`,d)),r.push(p)}if(e.enableShapeUniforms&&(o=t.getUniformLocation(n,"outShape",d),a=t.getUniformLocation(n,"outShapeStrides",d),i=t.getUniformLocation(n,"outTexShape",d)),e.customUniforms)for(const f of e.customUniforms)s.push(t.getUniformLocation(n,f.name,d));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:c,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:i}}function VI(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((n,r)=>{const s=n.logicalShape,o=e[r],i=o.shape;if(!Vt(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(n.isUniform&&o.isUniform)return;const a=n.texShape,l=o.isUniform?null:o.texData.texShape;if(!Vt(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function _oe(t,e,n,r,s){e.program.enableShapeUniforms||(VI(e.inShapeInfos,n),VI([e.outShapeInfo],[r]));const o=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(o.texture,i[0],i[1]):t.setOutputMatrixTexture(o.texture,i[0],i[1]),t.setProgram(e.webGLProgram),t.bindVertexArray(e.webGLProgram.vao),se().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&t.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&t.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<n.length;++l){const c=n[l],{uniform:d,offset:f,shape:p,texShape:g}=e.variablesLocations[l];if(p){const{uniformShape:y}=_C(e.program.packedInputs,c.shape,c.texData.texShape);switch(y.length){case 1:t.gl.uniform1iv(p,new Int32Array(y));break;case 2:t.gl.uniform2iv(p,new Int32Array(y));break;case 3:t.gl.uniform3iv(p,new Int32Array(y));break;case 4:t.gl.uniform4iv(p,new Int32Array(y));break}}if(g&&t.gl.uniform2i(g,c.texData.texShape[0],c.texData.texShape[1]),d!=null){if(c.isUniform){if(pe(c.shape)<2)t.gl.uniform1f(d,c.uniformValues[0]);else{let y=c.uniformValues;y instanceof Float32Array||(y=new Float32Array(y)),t.gl.uniform1fv(d,y)}continue}c.texData.slice!=null&&f!=null&&t.gl.uniform1i(f,c.texData.slice.flatOffset),t.setInputMatrixTexture(c.texData.texture.texture,d,l)}}const a=e.outShapeLocation;if(a)switch(r.shape.length){case 1:t.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:t.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:t.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:t.gl.uniform4iv(a,new Int32Array(r.shape));break}if(e.outShapeStridesLocation){const l=gn(r.shape);switch(r.shape.length){case 2:t.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:t.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:t.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&t.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&s)for(let l=0;l<e.program.customUniforms.length;++l){const c=e.program.customUniforms[l],d=e.customUniformLocations[l],f=s[l];if(c.type==="float")t.gl.uniform1fv(d,f);else if(c.type==="vec2")t.gl.uniform2fv(d,f);else if(c.type==="vec3")t.gl.uniform3fv(d,f);else if(c.type==="vec4")t.gl.uniform4fv(d,f);else if(c.type==="int")t.gl.uniform1iv(d,f);else if(c.type==="ivec2")t.gl.uniform2iv(d,f);else if(c.type==="ivec3")t.gl.uniform3iv(d,f);else if(c.type==="ivec4")t.gl.uniform4iv(d,f);else throw Error(`uniform type ${c.type} is not supported yet.`)}t.executeProgram()}function Poe(t,e,n){let r="";e.concat(n).forEach(i=>{const a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!i.isUniform){const l=i.texData.texShape,{useSqueezeShape:c,uniformShape:d,keptDims:f}=_C(t.packedInputs,i.shape,l);let p="",g="",y="";if(d.length===1&&t.packedInputs){const _=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];p=`${_[0]>1}_${_[1]>1}`}else if(d.length===2&&!t.packedInputs)g=`${d[0]>1}_${d[1]>1}`;else if(d.length>2&&!t.packedInputs){const _=gn(d);y=`${_[0]===l[1]}_${_[_.length-1]===l[1]}`}const x=i.shape.length,w=d.length===2&&Vt(i.shape,l),S=pe(i.shape)===1,$=cd(i.shape,n.shape),I=!t.packedInputs&&x===n.shape.length&&Vt(l,n.texData.texShape),R=t.packedInputs||d.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${x}_${I}_${c?f:""}_${d.length}_${S}_${$}_${w}_${p}_${g}_${y}_${R}_${a}`}else{const l=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${l}_${a}`}});const s=t.userCode;let o=t.constructor.name;return o+="_"+r+"_"+s+`${se().getNumber("WEBGL_VERSION")}`,o}function cr(t){return se().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Aoe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Tf.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Er();this.outputShape=e,this.enableShapeUniforms=cr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?vy(["r","c","d"],e):Wu(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Doe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Tf.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Er();this.outputShape=e,this.enableShapeUniforms=cr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?vy(["r","c","d"],e):Wu(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ooe{constructor(e){this.variableNames=["A"],this.outTexUsage=_s.DOWNLOAD;const n=Er();this.outputShape=e,this.userCode=`
      ${gO}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Foe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=_s.DOWNLOAD;const n=Er();this.outputShape=e,this.userCode=`
      ${gO}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Loe={R:0,G:1,B:2,A:3};class WI{constructor(e,n=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Er();this.outputShape=e,this.enableShapeUniforms=cr(this.outputShape.length);let o="result";n&&(o="floor(result * 255. + 0.5)");let i="";for(let a=0;a<r.length;a++){const l=r[a];i+=`
          if(offset == ${a}) {
            result = values[${Loe[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?RC():EC(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${s.texture2D}(A, uv);
          ${i}
        }
        ${s.output} = vec4(${o}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zoe{constructor(e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Er();this.outputShape=e,this.enableShapeUniforms=cr(this.outputShape.length);let s="",o="result";n&&(o="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){const l=i*2+a;s+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?RC():EC(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${s}

          ${r.output} = ${o};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Boe(t){const e=Er(),n=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return Sse(t,n)}function Moe(t){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Ise(t,e)}function Voe(t){const e=new Uint16Array([0,1,2,2,1,3]);return Nse(t,e)}function tp(t,e,n,r,s,o){Rse(e,n);const i=Ese(t),a=t.TEXTURE_2D;return Oe(t,()=>t.bindTexture(a,i)),Oe(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),Oe(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),Oe(t,()=>t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.NEAREST)),Oe(t,()=>t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.NEAREST)),se().getNumber("WEBGL_VERSION")===1?Oe(t,()=>t.texImage2D(a,0,r,e,n,0,s,o,null)):Oe(t,()=>t.texStorage2D(a,1,r,e,n)),Oe(t,()=>t.bindTexture(t.TEXTURE_2D,null)),{texture:i,texShape:[n,e]}}function wO(t){return t.internalFormatFloat}function Woe(t,e,n,r){const[s,o]=Jf(e,n);return tp(t,s,o,wO(r),r.textureFormatFloat,t.FLOAT)}function SO(t){return t.internalFormatHalfFloat}function Uoe(t,e,n,r){const[s,o]=Jf(e,n);return tp(t,s,o,SO(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function CO(t){return t.downloadTextureFormat}function joe(t,e,n,r){const[s,o]=Jf(e,n);return tp(t,s,o,CO(r),t.RGBA,t.UNSIGNED_BYTE)}function $O(t){return t.internalFormatPackedFloat}function Goe(t,e,n,r){const[s,o]=Id(e,n);return tp(t,s,o,$O(r),t.RGBA,t.FLOAT)}function kO(t){return t.internalFormatPackedHalfFloat}function Hoe(t,e,n,r){const[s,o]=Id(e,n);return tp(t,s,o,kO(r),t.RGBA,r.textureTypeHalfFloat)}function Koe(t,e,n){return Oe(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),zI(t,e,"clipSpacePos",n,3,20,0)&&zI(t,e,"uv",n,2,20,12)}function Xoe(t,e,n,r,s,o){Oe(t,()=>t.bindTexture(t.TEXTURE_2D,e));let i,a,l;s instanceof Uint8Array?(i=new Uint8Array(n*r*4),a=t.UNSIGNED_BYTE,l=t.RGBA):(i=new Float32Array(n*r*4),a=t.FLOAT,l=o.internalFormatPackedFloat),i.set(s),se().getNumber("WEBGL_VERSION")===2?Oe(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n,r,t.RGBA,a,i)):Oe(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,n,r,0,t.RGBA,a,i)),Oe(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function qoe(t,e,n){Oe(t,()=>t.bindTexture(t.TEXTURE_2D,e)),n.data instanceof Uint8Array?se().getNumber("WEBGL_VERSION")===2?Oe(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n.width,n.height,t.RGBA,t.UNSIGNED_BYTE,n.data)):Oe(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data)):se().getNumber("WEBGL_VERSION")===2?Oe(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,n)):Oe(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),Oe(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function Yoe(t,e,n,r){const s=t.createBuffer();Oe(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,s));const a=4*4*e*n;return Oe(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,a,t.STREAM_READ)),Oe(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0)),Oe(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),s}function Qoe(t,e,n){const r=t,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function Zoe(t,e,n,r){const[s,o]=Jf(e,n),i=4,a=new Uint8Array(mse(e*n,i));return Oe(t,()=>t.readPixels(0,0,s,o,r.downloadTextureFormat,t.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function Joe(t,e,n,r,s,o,i,a){const l=t,c=new Float32Array(gse(o,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function eie(t,e,n){const r=new Float32Array(e*n*4);return Oe(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,r)),r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ex{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const n=se().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,hse(n,e)):this.gl=zo(n),e=this.gl,se().getNumber("WEBGL_VERSION")===2){const o=e;this.createVertexArray=()=>Oe(o,()=>o.createVertexArray()),this.bindVertexArray=i=>Oe(o,()=>o.bindVertexArray(i)),this.deleteVertexArray=i=>Oe(o,()=>o.deleteVertexArray(i)),this.getVertexArray=()=>Oe(o,()=>o.getParameter(o.VERTEX_ARRAY_BINDING))}else if(e!=null){const o=e.getExtension("OES_vertex_array_object");if(o==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Oe(e,()=>o.createVertexArrayOES()),this.bindVertexArray=i=>Oe(e,()=>o.bindVertexArrayOES(i)),this.deleteVertexArray=i=>Oe(e,()=>o.deleteVertexArrayOES(i)),this.getVertexArray=()=>Oe(e,()=>e.getParameter(o.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),se().getNumber("WEBGL_VERSION")===1){const o="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=Sm(this.gl,o),oo(this.gl,i))this.textureHalfFloatExtension=Sm(this.gl,i);else if(se().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),oo(this.gl,s))this.colorBufferHalfFloatExtension=Sm(this.gl,s);else if(se().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",oo(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(oo(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=Moe(this.gl),this.indexBuffer=Voe(this.gl),this.framebuffer=_se(this.gl),this.textureConfig=NC(this.gl,this.textureHalfFloatExtension)}get debug(){return se().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Oe(e,()=>e.finish()),Oe(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Oe(e,()=>e.deleteFramebuffer(this.framebuffer)),Oe(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Oe(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Oe(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,n){return this.throwIfDisposed(),Woe(this.gl,e,n,this.textureConfig)}createFloat16MatrixTexture(e,n){return this.throwIfDisposed(),Uoe(this.gl,e,n,this.textureConfig)}createUnsignedBytesMatrixTexture(e,n){return this.throwIfDisposed(),joe(this.gl,e,n,this.textureConfig)}uploadPixelDataToTexture(e,n){this.throwIfDisposed(),qoe(this.gl,e,n)}uploadDenseMatrixToTexture(e,n,r,s){this.throwIfDisposed(),Xoe(this.gl,e,n,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(e,n){return this.throwIfDisposed(),Hoe(this.gl,e,n,this.textureConfig)}createPackedMatrixTexture(e,n){return this.throwIfDisposed(),Goe(this.gl,e,n,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(BI(this.gl,this.framebuffer),this.outputTexture=null),Oe(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,n,r){return this.downloadMatrixDriver(e,()=>Zoe(this.gl,n,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,n,r,s,o,i){return Joe(this.gl,e,n,r,s,o,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,n){return Qoe(this.gl,e,n)}createBufferFromTexture(e,n,r){this.bindTextureToFrameBuffer(e);const s=Yoe(this.gl,n,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let n,r;if(se().getBool("WEBGL_FENCE_API_ENABLED")){const s=e,o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{const i=s.clientWaitSync(o,0,0);return i===s.ALREADY_SIGNALED||i===s.CONDITION_SATISFIED},n=o}else se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(n,se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:n,isFencePassed:r}}downloadMatrixFromPackedTexture(e,n,r){return this.downloadMatrixDriver(e,()=>eie(this.gl,n,r))}createProgram(e){this.throwIfDisposed();const n=this.gl;this.vertexShader==null&&(this.vertexShader=Boe(n));const r=kse(n);Oe(n,()=>n.attachShader(r,this.vertexShader)),Oe(n,()=>n.attachShader(r,e)),Tse(n,r);const s=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&Y1(n,s),s}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const n=this.gl;Oe(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),Koe(n,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Oe(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Y1(this.gl,this.program),Oe(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,n,r=!0){return this.throwIfDisposed(),r?Ase(this.gl,e,n):Dse(this.gl,e,n)}getAttributeLocation(e,n){return this.throwIfDisposed(),Oe(this.gl,()=>this.gl.getAttribLocation(e,n))}getUniformLocationNoThrow(e,n){return this.throwIfDisposed(),this.gl.getUniformLocation(e,n)}setInputMatrixTexture(e,n,r){this.throwIfDisposed(),this.throwIfNoProgram(),Ose(this.gl,e,n,r)}setOutputMatrixTexture(e,n,r){this.setOutputMatrixTextureDriver(e,r,n)}setOutputPackedMatrixTexture(e,n,r){this.throwIfDisposed();const[s,o]=Id(n,r);this.setOutputMatrixTextureDriver(e,s,o)}setOutputMatrixWriteRegion(e,n,r,s){this.setOutputMatrixWriteRegionDriver(r,e,s,n)}setOutputPackedMatrixWriteRegion(e,n,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Y1(this.gl,this.program),Cm(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const n=this.getVertexArray();console.assert(n===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Oe(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Oe(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Sm(this.gl,se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,o),o}const e=this.getQueryTimerExtensionWebGL1(),n=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,n),n}endQuery(){if(se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,r=this.getQueryTimerExtensionWebGL2();n.endQuery(r.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await uI(()=>this.disposed||this.isQueryAvailable(e,se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,n){if(n===0)return null;if(n===2){const r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,n){if(n===0)return!0;if(n===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(e){return new Promise(n=>{this.addItemToPoll(()=>e.isFencePassed(),()=>n())})}pollItems(){const e=tie(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=e;++n){const{resolveFn:r}=this.itemsToPoll[n];r()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,n){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:n}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in se().platform&&(r=se().platform.setTimeoutCustom.bind(se().platform)),uI(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Q1(this.gl,e,this.framebuffer),this.debug&&Cm(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Q1(this.gl,this.outputTexture,this.framebuffer),this.debug&&Cm(this.gl)):BI(this.gl,this.framebuffer)}downloadMatrixDriver(e,n){this.bindTextureToFrameBuffer(e);const r=n();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,n,r){this.throwIfDisposed();const s=this.gl;Q1(s,e,this.framebuffer),this.debug&&Cm(s),this.outputTexture=e,Oe(s,()=>s.viewport(0,0,n,r)),Oe(s,()=>s.scissor(0,0,n,r))}setOutputMatrixWriteRegionDriver(e,n,r,s){this.throwIfDisposed(),Oe(this.gl,()=>this.gl.scissor(e,n,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function tie(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nie(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kr(t){return(e,n,r,s,o)=>{const i=ct(e,n),a=i.length,l=gn(i),c=pe(i),d=Si(o,c),f=e.length,p=n.length,g=gn(e),y=gn(n),x=cd(e,i),w=cd(n,i);if(x.length+w.length===0)for(let S=0;S<d.length;++S)d[S]=t(r[S%r.length],s[S%s.length]);else for(let S=0;S<d.length;++S){const $=e2(S,a,l),I=$.slice(-f);x.forEach(F=>I[F]=0);const R=nv(I,f,g),_=$.slice(-p);w.forEach(F=>_[F]=0);const O=nv(_,p,y);d[S]=t(r[R],s[O])}return[d,i]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rie(t,e,n,r){if(r==="int32"){const s=Int32Array.from(t);return[e,"int32",s]}if(r==="bool"){const s=iy([0],n),[o,i]=Kr((a,l)=>a!==l?1:0)(e,[],t,s,"bool");return[i,"bool",o]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sie=Kr((t,e)=>t+e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oie(t,e,n,r,s){const o=pe(r),i=ha(s,n);for(let a=0;a<t.length;a++){const l=t[a];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(o>0?i[l]+=e[a]:i[l]+=1)}return i}function iie(t,e,n,r=!1){const s=t.shape[0],o=t.shape[1],i=Wt([s,n],e.dtype);for(let a=0;a<s;a++)for(let l=0;l<o;l++){const c=t.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=n||(r?i.set(1,a,c):e.size>0?i.set(i.get(a,c)+e.get(a,l),a,c):i.set(i.get(a,c)+1,a,c))}return i}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aie=Kr((t,e)=>t&e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ka(t){return(e,n,r)=>{const s=En(n,e.length);for(let o=0;o<e.length;++o)s[o]=t(e[o],r);return s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lie=ka(t=>Math.ceil(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uie(t,e,n,r){const s=En(n,pe(e));if(r&&n!=="string"){let o=0;t.forEach(i=>{const a=pe(i.shape);s.set(i.vals,o),o+=a})}else{let o=0;t.forEach(i=>{const a=n==="string"?bl(i.vals):i.vals;let l=0;for(let c=0;c<i.shape[0];++c){const d=c*e[1]+o;for(let f=0;f<i.shape[1];++f)s[d+f]=a[l++]}o+=i.shape[1]})}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cie=Kr((t,e)=>t===e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const die=ka(t=>Math.exp(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hie=ka(t=>Math.expm1(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fie=ka(t=>Math.floor(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pie=Kr((t,e)=>Math.floor(t/e));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mie(t,e,n,r,s,o,i,a,l){const c=Wt([r,o],n);for(let d=0;d<r;d++){const f=[];let p=0;for(let g=0;g<s;g++){const y=t[d*s+g];p+=y*i[g],f.push(y)}if(p<0||p>=l/o)throw new Error(`Invalid indices: ${f} does not index into ${a}`);for(let g=0;g<o;g++)c.values[d*o+g]=e.get(...e.indexToLoc(p*o+g))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gie(t,e,n){const r=Wt(n,t.dtype);for(let s=0;s<r.size;++s){const i=r.indexToLoc(s).slice(),a=i[0],l=i[2],c=e.locToIndex([a,l]);i[2]=e.values[c];const d=t.locToIndex(i);0<=d&&d<t.values.length&&(r.values[s]=t.values[d])}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yie=Kr((t,e)=>t>e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xie=Kr((t,e)=>t>=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vie=Kr((t,e)=>t<e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bie=Kr((t,e)=>t<=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wie(t,e,n){const r=(e-t)/(n-1),s=ha(n,"float32");s[0]=t;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sie=ka(t=>Math.log(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cie(t,e,n,r){const s=Si(r,pe(n));for(let o=0;o<s.length;++o){const i=o*e;let a=t[i];for(let l=0;l<e;++l){const c=t[i+l];(Number.isNaN(c)||c>a)&&(a=c)}s[o]=a}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ie=Kr((t,e)=>Math.max(t,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kie=Kr((t,e)=>Math.min(t,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TO=Kr((t,e)=>t*e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tie(t,e,n){const r=kd(-1,n);return TO([],e,r,t,n)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iie=Kr((t,e)=>t!==e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nie(t,e,n,r,s){const o=e.length,i=pe(e),a=gn(e),l=gn(s),c=Si(n,pe(s));for(let d=0;d<i;++d){const f=e2(d,o,a),p=new Array(f.length);for(let y=0;y<p.length;y++)p[y]=f[r[y]];const g=nv(p,o,l);c[g]=t[d]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eie(t,e,n,r){const[s,o]=Fs(t,r),i=jr(e,"int32"),a=ha(pe(s),i),l=pe(o);for(let c=0;c<a.length;++c){const d=c*l;let f=1;for(let p=0;p<l;++p)f*=n[d+p];a[c]=f}return{outVals:a,outShape:s,outDtype:i}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rie(t,e,n){t.forEach((r,s)=>{if(r<0||r>=n){const o=e2(s,e.length,gn(e)).join(",");throw new Error(`indices[${o}] = ${r} is not in [0, ${n})`)}})}function _ie(t,e){for(let n=0;n<t.length;++n){const r=t[n],s=n===t.length-1?e:t[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let o=1;o<r.length;++o)if(r[o-1]>r[o])throw new Error("Ragged splits must be sorted in ascending order")}}function Pie(t,e,n,r){const s=[];let o=0;const i=e.length-1+n.length,a=new Array(i).fill(null).map(()=>[0]);_ie(n,r);let l=1;for(let c=0;c<e.length-1;++c){l*=e[c];const d=e[c+1];for(let f=1;f<l+1;++f)a[c].push(f*d)}for(let c=0;c<t.length;++c){let d=t[c],f=t[c]+1;for(let p=0;p<n.length;++p){const g=n[p],y=p+e.length-1;if(y>=0){const x=a[y],w=x[x.length-1]-g[d];for(let S=d;S<f;++S)a[y].push(g[S+1]+w)}d=g[d],f=g[f]}f!==d&&(s.push([d,f]),o+=f-d)}return{outSplits:a,valueSlices:s,numValues:o}}function Aie(t){const e=[];for(let n=0;n<t.length;++n){const r=t[n].length,s=En("int32",r);e.push(s),t[n].forEach((o,i)=>s[i]=o)}return e}function UI(t,e){const n=t.slice(0,e);for(;n.length<e;)n.push(1);for(let r=e;r<t.length;r++)n[e-1]*=t[r];return n}function Die(t,e,n,r,s,o){const i=UI(e,2)[1],a=UI(o,2)[1];let l=0;for(const c of n)for(let d=c[0];d<c[1];++d){for(let f=0;f<r;++f)s[l*a+f]=t[d*i+f];++l}}function Oie(t,e,n,r,s){const o=e.slice();o[0]=s;const i=En(n,pe(o)),a=t.length,l=a===0?0:a/e[0];return Die(t,e,r,l,i,o),[i,o]}function Fie(t,e,n,r,s,o,i,a){if(t.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(Rie(o,i,l),r.length===0)throw new Error("params.rank must be nonzero");const c=r[0],{outSplits:d,valueSlices:f,numValues:p}=Pie(o,i,t,c),g=Aie(d),y=Oie(n,r,s,f,p);return[g,y[0],y[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jI=2147483647;function Lie(t,e,n,r,s,o,i){if(e.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,l=s.length===0,c=i.length===0,d=[];a||d.push(e[0]),l||d.push(s[0]),c||d.push(i[0]);for(let w=1;w<d.length;++w)if(d[w]!==d[w-1])throw new Error("starts, limits, and deltas must have the same shape");const f=d.length===0?1:d[0],p=En("int32",f+1);p[0]=0;for(let w=0;w<f;++w){const S=a?t[0]:t[w],$=l?r[0]:r[w],I=c?o[0]:o[w];if(I===0)throw new Error("Requires delta != 0");let R;if(I>0&&$<S||I<0&&$>S)R=0;else if(R=Math.ceil(Math.abs(($-S)/I)),R>jI)throw new Error(`Requires ((limit - start) / delta) <= ${jI}`);p[w+1]=p[w]+R}const g=p[f],y=En(n,g);let x=0;for(let w=0;w<f;++w){const S=p[w+1]-p[w];let $=a?t[0]:t[w];const I=c?o[0]:o[w];for(let R=0;R<S;++R)y[x++]=$,$+=I}return[p,y]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Js=Oo;class _g{constructor(e,n,r,s,o,i,a,l,c,d){this.shape=e,this.shapeShape=n,this.values=r,this.valuesShape=s,this.valuesDType=o,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=JD(d),this.raggedRank=eO(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Js.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Js.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const n=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Js.VALUE_ROWIDS:return _g.getMaxWidthValueRowID(n);case Js.ROW_SPLITS:return _g.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${Js[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const n=e.length;if(n===0||n===1)return 0;let r=0;for(let s=0;s<n-1;++s){const o=e[s+1]-e[s];o>r&&(r=o)}return r}static getMaxWidthValueRowID(e){const n=e.length;if(n===0)return 0;let r=0,s=e[0],o=0;for(let i=1;i<n;++i){const a=e[i];a!==s&&(s=a,o=Math.max(i-r,o),r=i)}return Math.max(n-r,o)}tensorShapeFromTensor(e,n,r=!0){if(n.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return HI(e,r)}calculateOutputSize(e){const n=this.valuesShape,r=this.defaultValueShape;tO(r,n);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=ZD(this.raggedRank,s,n);i[0]<0&&(i[0]=e);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(e,n,r){const s=Math.min(e,r),o=[];let i=0;for(let a=0;a<s;++a,i+=n)o.push(i);for(let a=s;a<e;++a)o.push(-1);return z(o.length===e,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(e,n,r,s){const o=e.length,i=[];for(let a=0;a<o-1;++a){const l=e[a+1]-e[a];let c=Math.min(s,l),d=n[a];d===-1&&(c=0);for(let f=0;f<c;++f)i.push(d),d+=r;for(let f=0;f<l-c;++f)i.push(-1)}if(o>0&&i.length!==e[o-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(e,n,r,s){const o=e.length,i=[];if(o===0)return[];let a=0,l=e[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let c=n[l];i.push(c);for(let d=1;d<o;++d){const f=e[d];if(f===l)c>=0&&(++a,a<s?c+=r:c=-1);else{if(a=0,l=f,f>=n.length)throw new Error(`Got nextValueRowId=${f} which is not less than ${n.length}`);c=n[f]}i.push(c)}if(i.length!==e.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(e,n,r,s){const o=this.getRowPartitionTensor(e),i=this.getRowPartitionTypeByDimension(e);switch(i){case Js.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,n,r,s);case Js.ROW_SPLITS:if(o.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(o,n,r,s);default:throw new Error(`Unsupported partition type: ${Js[i]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const n=this.rowPartitionTypes[0];switch(n){case Js.FIRST_DIM_SIZE:return e[0];case Js.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Js.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Js[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const n=this.getFirstDimensionSize(),r=this.calculateOutputSize(n),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let l=s.length-2;l>=0;--l)s[l]=s[l+1]*r[l+1];const o=HI(r,!1),i=En(this.valuesDType,pe(o));if(s[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(n,s[0],r[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,s[c],r[c]);this.setOutput(this.raggedRank,l,i,o)}return[o,i]}setOutput(e,n,r,s){if(r.length===0)return;const o=this.values,i=r;let a=s.slice();a=a.slice(e+1);const l=pe(a),c=n.length;let d=this.defaultValue;if(d.length!==l&&d.length!==1){const y=this.defaultValueShape;nt(()=>{const x=ye(d,y);d=Qh(x,a).dataSync()})}let f=0,p=0,g=0;for(let y=0;y<=c;++y){let x=y<c?n[y]:-1;if(x===g){++g;continue}if(p<g){const w=o.subarray(f*l),S=i.subarray(p*l),$=(g-p)*l;GI(S,w,$)}if(y>=c){const w=r.length;x=Math.floor(w/l)}if(x>g)if(this.defaultValue.length===1)i.subarray(g*l,x*l).fill(this.defaultValue[0]),g=x;else for(;x>g;){const w=i.slice(g*l);GI(w,d,l),++g}x<0?(f=y+1,p=g):(f=y,p=g,g=p+1)}}}function GI(t,e,n){for(let r=0;r<n;r++)t[r]=e[r]}function HI(t,e){const n=[];for(let r of t){if(r<0){if(!e)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function zie(t,e,n,r,s,o,i,a,l,c){return new _g(t,e,n,r,s,o,i,a,l,c).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bie(t,e,n,r){const s=t===e,o=t<e&&n<0,i=e<t&&n>1;if(s||o||i)return ha(0,r);const a=Math.abs(Math.ceil((e-t)/n)),l=ha(a,r);e<t&&n===1&&(n=-1),l[0]=t;for(let c=1;c<l.length;c++)l[c]=l[c-1]+n;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mie=ka(t=>1/Math.sqrt(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vie(t,e,n,r,s,o,i,a,l,c){const d=[r/s,s],f=t.values,p=e.values;if(r===0)return Wt(n,e.dtype);const g=l instanceof ad?l:Wt(d,e.dtype);typeof l=="string"||typeof l=="number"?g.values.fill(l):typeof l=="boolean"&&g.values.fill(+l);for(let y=0;y<o;y++){const x=[];let w=0;for(let S=0;S<i;S++){const $=f[y*i+S];x.push($),w+=$*a[S]}if(w<0||w>=r/s)throw new Error(`Invalid indices: ${x} does not index into ${n}`);for(let S=0;S<s;S++)c?g.values[w*s+S]+=p[y*s+S]:g.values[w*s+S]=e.rank===0?p[0]:p[y*s+S]}return g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wie=ka(t=>1/(1+Math.exp(-t)));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uie(t,e,n,r,s){const o=rC(r,e,n),i=pe(n),a=gn(r);if(o){const f=sC(e,a);return s==="string"?t.slice(f,f+i):t.subarray(f,f+i)}const l=s==="string"?bl(t):t,c=Wt(r,s,l),d=Wt(n,s);for(let f=0;f<d.size;++f){const p=d.indexToLoc(f),g=p.map((y,x)=>y+e[x]);d.set(c.get(...g),...p)}return s==="string"?pO(d.values):d.values}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jie(t,e,n,r,s,o,i){const a=e[0],l=o[0],c=new Array(l),d=new Array(a),f=e[1];if(l===0){if(a!==0)throw new Error(nO(a));const w=En(n,0),S=En(s,0);return[w,[0,f],S,c,d]}let p=!0,g=0;const y=new Array(l).fill(0);for(let w=0;w<a;++w){const S=t[w*f];if(S<0)throw new Error(rO(w,S));if(S>=l)throw new Error(sO(w,S,l));++y[S],p=p&&S>=g,g=S}let x=!0;for(let w=0;w<l;++w){const S=y[w]===0;c[w]=S,x=x&&!S,y[w]=Math.max(y[w],1),w>0&&(y[w]+=y[w-1])}if(x&&p){const w=t,S=r;for(let $=0;$<a;++$)d[$]=$;return[w,[a,f],S,c,d]}else{const w=y[l-1],S=En(n,w*f),$=En(s,w),I=new Array(l).fill(0);for(let R=0;R<a;++R){const _=t[R*f],O=I[_],F=(_===0?0:y[_-1])+O;I[_]++;for(let B=0;B<f;++B)S[F*f+B]=t[R*f+B];$[F]=r[R],d[R]=F}for(let R=0;R<l;++R)if(I[R]===0){const O=R===0?0:y[R-1];S[O*f+0]=R;for(let F=1;F<f;++F)S[O*f+F]=0;$[O]=i}return[S,[w,f],$,c,d]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gie(t,e,n,r,s){const o=pe(r),i=e[0],a=s.length,l=[];let c=1,d=-1;for(let w=0;w<a;++w){const S=s[w];if(S===-1){if(d!==-1)throw new Error(oO(d,w));d=w,l.push(1)}else{if(S<0)throw new Error(iO(w,S));c*=S,l.push(S)}}if(d!==-1){if(c<=0)throw new Error(aO());const w=Math.trunc(o/c);if(c*w!==o)throw new Error(lO(r,l));l[d]=w}if(pe(l)!==o)throw new Error(uO(r,l));const p=r.length,g=[];if(p>0){g[p-1]=1;for(let w=p-2;w>=0;--w)g[w]=g[w+1]*r[w+1]}const y=[];if(a>0){y[a-1]=1;for(let w=a-2;w>=0;--w)y[w]=y[w+1]*l[w+1]}const x=En(n,i*a);for(let w=0;w<i;++w){let S=0;for(let $=0;$<p;++$)S+=t[w*p+$]*g[$];for(let $=0;$<a;++$)x[w*a+$]=Math.trunc(S/y[$]),S%=y[$]}return[x,[i,a],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hie(t,e,n,r,s,o=!1,i=0){const a=r.length,l=[e[0],t.length/e[0]],c=l[1],f=a>0?s[a-1]+1:0;if(f<0)throw new Error(vv());const p=e.slice();p[0]=f;const g=p.reduce((I,R)=>I*R,1),y=En(n,g);if(a===0)return f>0&&y.fill(i),[y,p];if(f<=0)throw new Error(vv());let x=0,w=1,S=0,$=s[x];for(;;){let I=0;if(w<a){if(I=s[w],$===I){++w;continue}if($>=I)throw new Error(cO())}if($<0||$>=f)throw new Error(dO($,f));$>S&&y.fill(i,S*c,$*c);for(let R=x;R<w;++R){const _=r[R];if(_<0||_>=l[0])throw new Error(hO(R,r[R],l[0]));for(let O=0;O<c;O++)y[$*c+O]+=t[_*c+O]}if(o)for(let R=0;R<c;R++)y[$*c+R]/=w-x;if(x=w,++w,S=$+1,$=I,w>a)break}return S<f&&y.fill(i,S*c,f*c),[y,p]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kie=ka(t=>Math.sqrt(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xie=Kr((t,e)=>{const n=t-e;return n*n});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qie=ka((t,e)=>{const{pattern:n,replaceGlobal:r,rewrite:s}=e;return t.replace(new RegExp(n,r?"g":""),s)});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yie(t,e,n,r){const s=Wt(t,e.dtype);for(let o=0;o<s.size;o++){const i=s.indexToLoc(o),a=new Array(i.length);for(let l=0;l<a.length;l++)a[l]=i[l]*n[l]+r[l];s.set(e.get(...a),...i)}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qie{constructor(e,n,r,s,o,i){this.separator=hl(e),this.nGramWidths=n,this.leftPad=hl(r),this.rightPad=hl(s),this.padWidth=o,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,n){const r=this.getPadWidth(n);return Math.max(0,e+2*r-n+1)}createNGrams(e,n,r,s,o,i){for(let a=0;a<o;++a){const l=this.getPadWidth(i),c=Math.max(0,l-a),d=Math.max(0,l-(o-(a+1))),f=i-(c+d),p=n+(c>0?0:a-l);let g=0;g+=c*this.leftPad.length;for(let $=0;$<f;++$)g+=e[p+$].length;g+=d*this.rightPad.length;const y=c+d+f-1;g+=y*this.separator.length,r[s+a]=new Uint8Array(g);const x=r[s+a];let w=0;const S=$=>$.forEach(I=>x[w++]=I);for(let $=0;$<c;++$)S(this.leftPad),S(this.separator);for(let $=0;$<f-1;++$)S(e[p+$]),S(this.separator);if(f>0){S(e[p+f-1]);for(let $=0;$<d;++$)S(this.separator),S(this.rightPad)}else{for(let $=0;$<d-1;++$)S(this.rightPad),S(this.separator);S(this.rightPad)}}}compute(e,n){const r=e.length,s=n.length;if(s>0){let l=n[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<s;++c){let d=n[c]>=l;if(d=d&&n[c]<=r,!d)throw new Error(`Invalid split value ${n[c]}, must be in [${l}, ${r}]`);l=n[c]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const o=s-1,i=En("int32",s);if(r===0||s===0){const l=new Array(r);for(let c=0;c<=o;++c)i[c]=0;return[l,i]}i[0]=0;for(let l=1;l<=o;++l){const c=n[l]-n[l-1];let d=0;this.nGramWidths.forEach(f=>{d+=this.getNumNGrams(c,f)}),this.preserveShort&&c>0&&d===0&&(d=1),i[l]=i[l-1]+d}const a=new Array(i[o]);for(let l=0;l<o;++l){const c=n[l];let d=i[l];if(this.nGramWidths.forEach(f=>{const p=n[l+1]-n[l],g=this.getNumNGrams(p,f);this.createNGrams(e,c,a,d,g,f),d+=g}),this.preserveShort&&d===i[l]){const f=n[l+1]-n[l];if(f===0)continue;const p=f+2*this.padWidth;this.createNGrams(e,c,a,d,1,p)}}return[a,i]}}function Zie(t,e,n,r,s,o,i,a){return new Qie(n,r,s,o,i,a).compute(t,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jie(t,e,n,r){if(!t.length)return;if(e.length===0){for(let o=0;o<t.length;++o)r.push(t.subarray(o,o+1));return}if(e.length===1){const o=e[0];let i=t.indexOf(o);for(;i!==-1;){const a=t.subarray(0,i);(!n||a.length!==0)&&r.push(a),t=t.subarray(i+1),i=t.indexOf(o)}(!n||t.length!==0)&&r.push(t);return}let s=0;for(let o=0;o<t.length+1;o++)if(o===t.length||e.indexOf(t[o])!==-1){const i=t.subarray(s,o);(!n||i.length!==0)&&r.push(i),s=o+1}}function eae(t,e,n){const r=t.length,s=[];let o=0,i=0;const a=new Array(r);for(let p=0;p<r;++p){const g=s.length;Jie(t[p],e,n,s);const y=s.length-g;a[p]=y,o+=y,i=Math.max(i,y)}const l=En("int32",o*2),c=new Array(o),d=[r,i];let f=0;for(let p=0;p<r;++p)for(let g=0;g<a[p];++g)l[f*2]=p,l[f*2+1]=g,c[f]=s[f],++f;return[l,c,d]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tae(t,e){const n=En("int32",t.length);for(let r=0;r<t.length;++r)n[r]=xX(t[r]).modulo(e).getLowBitsUnsigned();return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nae=Kr((t,e)=>t-e);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rae(t,e){const n=new Array(t.rank);for(let s=0;s<n.length;s++)n[s]=t.shape[s]*e[s];const r=Wt(n,t.dtype);for(let s=0;s<r.values.length;++s){const o=r.indexToLoc(s),i=new Array(t.rank);for(let l=0;l<i.length;l++)i[l]=o[l]%t.shape[l];const a=t.locToIndex(i);r.values[s]=t.values[a]}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fh=(t,e)=>{const n=e.value-t.value;return n===0?t.index-e.index:n};function IO(t,e,n=0,r=t.length-1){for(;r>n;){if(r-n>600){const a=r-n+1,l=e-n+1,c=Math.log(a),d=.5*Math.exp(2*c/3),f=.5*Math.sqrt(c*d*(a-d)/a)*Math.sign(l-a/2),p=Math.max(n,Math.floor(e-l*d/a+f)),g=Math.min(r,Math.floor(e+(a-l)*d/a+f));IO(t,e,p,g)}const s=t[e];let o=n,i=r;for(bh(t,n,e),Fh(t[r],s)>0&&bh(t,n,r);o<i;){for(bh(t,o,i),o++,i--;Fh(t[o],s)<0;)o=o+1;for(;Fh(t[i],s)>0;)i=i-1}Fh(t[n],s)===0?bh(t,n,i):(i=i+1,bh(t,i,r)),i<=e&&(n=i+1),e<=i&&(r=i-1)}}function sae(t,e,n,r,s){const o=e[e.length-1],[i,a]=[t.length/o,o],l=Si(n,i*r),c=Si("int32",i*r);for(let f=0;f<i;f++){const p=f*a,g=t.subarray(p,p+a);let y=new Array(g.length);g.forEach(($,I)=>y[I]={value:$,index:I}),r<y.length&&(IO(y,r),y=y.slice(0,r)),s&&y.sort(Fh);const x=f*r,w=l.subarray(x,x+r),S=c.subarray(x,x+r);for(let $=0;$<r;$++)w[$]=y[$].value,S[$]=y[$].index}const d=e.slice();return d[d.length-1]=r,[Wt(d,n,l),Wt(d,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oae(t,e,n,r){const s=nn(e,n)[0],o=[1,n[0],1];for(let y=0;y<s;y++)o[0]*=n[y];o[1]=n[s];for(let y=s+1;y<n.length;y++)o[2]*=n[y];const i=new Map,a=new Int32Array(n[s]),l=new ad(o,r,t),c=[],d=o[0]===1&&o[2]===1;for(let y=0;y<n[s];y++){let x;if(d)x=t[y].toString();else{const S=[];for(let $=0;$<o[0];$++)for(let I=0;I<o[2];I++)S.push(l.get($,y,I));x=S.join(",")}const w=i.get(x);if(w!=null)a[y]=w;else{const S=i.size;i.set(x,S),a[y]=S,c.push(y)}}const f=o.slice();f[1]=i.size;const p=new ad(f,r);c.forEach((y,x)=>{for(let w=0;w<o[0];w++)for(let S=0;S<o[2];S++)p.set(l.get(w,y,S),w,x,S)});const g=n.slice();return g[s]=f[1],{outputValues:p.values,outputShape:g,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NO=Object.freeze(Object.defineProperty({__proto__:null,addImpl:sie,bincountImpl:oie,bincountReduceImpl:iie,bitwiseAndImpl:aie,castImpl:rie,ceilImpl:lie,concatImpl:uie,equalImpl:cie,expImpl:die,expm1Impl:hie,floorDivImpl:pie,floorImpl:fie,gatherNdImpl:mie,gatherV2Impl:gie,greaterEqualImpl:xie,greaterImpl:yie,lessEqualImpl:bie,lessImpl:vie,linSpaceImpl:wie,logImpl:Sie,maxImpl:Cie,maximumImpl:$ie,minimumImpl:kie,multiplyImpl:TO,negImpl:Tie,notEqualImpl:Iie,prodImpl:Eie,raggedGatherImpl:Fie,raggedRangeImpl:Lie,raggedTensorToTensorImpl:zie,rangeImpl:Bie,rsqrtImpl:Mie,scatterImpl:Vie,sigmoidImpl:Wie,simpleAbsImpl:nie,sliceImpl:Uie,sparseFillEmptyRowsImpl:jie,sparseReshapeImpl:Gie,sparseSegmentReductionImpl:Hie,sqrtImpl:Kie,squaredDifferenceImpl:Xie,staticRegexReplaceImpl:qie,stridedSliceImpl:Yie,stringNGramsImpl:Zie,stringSplitImpl:eae,stringToHashBucketFastImpl:tae,subImpl:nae,tileImpl:rae,topKImpl:sae,transposeImpl:Nie,uniqueImpl:oae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:iae,bincountImpl:EO,bincountReduceImpl:aae,bitwiseAndImpl:lae,castImpl:uae,ceilImpl:cae,concatImpl:dae,equalImpl:hae,expImpl:fae,expm1Impl:pae,floorImpl:mae,gatherNdImpl:gae,gatherV2Impl:yae,greaterImpl:xae,greaterEqualImpl:vae,lessImpl:bae,lessEqualImpl:wae,linSpaceImpl:Sae,logImpl:Cae,maxImpl:$ae,maximumImpl:kae,minimumImpl:Tae,multiplyImpl:Iae,negImpl:Nae,notEqualImpl:Eae,prodImpl:Rae,raggedGatherImpl:_ae,raggedRangeImpl:Pae,raggedTensorToTensorImpl:Aae,rangeImpl:Dae,rsqrtImpl:Oae,scatterImpl:Fae,sigmoidImpl:Lae,simpleAbsImpl:RO,sliceImpl:zae,sparseFillEmptyRowsImpl:Bae,sparseReshapeImpl:Mae,sparseSegmentReductionImpl:_O,sqrtImpl:Vae,staticRegexReplaceImpl:Wae,stridedSliceImpl:Uae,stringNGramsImpl:jae,stringSplitImpl:Gae,stringToHashBucketFastImpl:Hae,subImpl:Kae,tileImpl:Xae,topKImpl:qae,transposeImpl:PC,uniqueImpl:Yae}=NO;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PO(t,e){return["x","y","z","w","u","v"].slice(0,e).map(n=>`${t}.${n}`)}function $r(t,e){return e===1?[t]:PO(t,e)}function Qae(t,e){if(t===1)return"rc";let n="";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zae{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=cr(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const n=$r("rc",this.rank),r=Kt(this.rank),s=this.getOutOfBoundsCondition(n),o=this.getSetup(n),i=this.getOutput(n);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${s}) {
            setOutput(vec4(0));
          } else {
            ${o}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(e){const n=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let o=`${r===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)o=`${e[e.length-1-i]},`+o;n.push(o)}return n}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let n="";for(let r=this.rank-2;r<this.rank;r++)n+=`${e[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(n+="||");return n}getSetup(e){if(this.rank===1)return"";const n=e.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],s=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${n[0]};
      int c = ${n[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${s};
    `}getOutput(e){const n=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${n[0]}),
            cEdge ? 0. : getA(${n[1]}),
            rEdge ? 0. : getA(${n[2]}),
            rEdge || cEdge ? 0. : getA(${n[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AO{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=cr(this.outputShape.length);let r="";for(let s=0;s<4;s++){let o="thisRC = rc;";s%2===1&&(o+="thisRC.z += 1;"),s>1&&(o+="thisRC.y += 1;"),r+=`
        ${o}
        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s>0?"}":""}
      `}this.userCode=`
      ${Jae(n,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?RC():EC(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}}function Jae(t,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?Kse(["r","c","d"],"inputShape"):Wu(["r","c","d"],t)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ele=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,n,r){const s=XI(n,r),o=qI(e,s,r);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const i=KI(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const l=this.freeTextures[o].pop();return this.usedTextures[o].push(l),l}let a;return s===qn.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):s===qn.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):s===qn.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):s===qn.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):s===qn.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(e,n,r,s){if(this.freeTextures==null)return;const o=XI(r,s),i=qI(n,o,s);i in this.freeTextures||(this.freeTextures[i]=[]);const a=KI(n,o,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=se().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[i],d=c&&c.indexOf(e);if(d==null||d<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[d]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function tle(t,e){const n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;if(e===n.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function KI(t,e,n,r,s){const o=nle(e,r);let i;if(s){const[l,c]=Id(t[0],t[1]);i=l*c}else{const[l,c]=Jf(t[0],t[1]);i=l*c}const a=tle(n,o);return i*a}function nle(t,e){switch(t){case qn.PACKED_2X2_FLOAT32:return $O(e);case qn.PACKED_2X2_FLOAT16:return kO(e);case qn.UNPACKED_FLOAT32:return wO(e);case qn.UNPACKED_FLOAT16:return SO(e);case qn.PACKED_4X1_UNSIGNED_BYTE:return CO(e);default:throw new Error(`Unknown physical texture type ${t}`)}}function rle(t){return se().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?qn.PACKED_2X2_FLOAT32:qn.UNPACKED_FLOAT32:t?qn.PACKED_2X2_FLOAT16:qn.UNPACKED_FLOAT16}function XI(t,e){if(t===_s.UPLOAD)return qn.PACKED_2X2_FLOAT32;if(t===_s.RENDER||t==null)return rle(e);if(t===_s.DOWNLOAD||t===_s.PIXELS)return qn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function qI(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let fi=class{constructor(e,n){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=cr(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${n}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}};const mo="if (isnan(x)) return x;",sle="return x;",YI="return abs(x);",ole="return (x >= 0.0) ? x : (exp(x) - 1.0);",ile=mo+`
  return (x < 0.0) ? 0.0 : x;
`,ale=mo+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,il="return x;",lle="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ule="return x;",cle=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,dle=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,hle=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,fle="return 1.0 / (1.0 + exp(-1.0 * x));";class ul{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=cr(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ple{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=cr(this.outputShape.length);const n=e.length,r=$r("rc",n),s=Kt(n),o=Qae(n,r),i=r.slice(-2),a=n<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${o});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mle=RD,gle=1e-7,yle=1e-4,Tm={};function xle(t){return t in Tm||(Tm[t]={}),Tm[t]}const vle=se().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),ble=600;function wle(){return se().global.screen==null?1024:se().global.screen.height*se().global.screen.width*window.devicePixelRatio*ble/1024/1024}class by extends Zb{nextDataId(){return by.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!se().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(e!=null){if(e instanceof ex)n=e;else{const r=zo(se().getNumber("WEBGL_VERSION"),e);n=new ex(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=zo(se().getNumber("WEBGL_VERSION"));n=new ex(r),this.binaryCache=xle(se().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new ele(this.gpgpu),this.numMBBeforeWarning=wle(),this.texData=new MP(this,ds())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,n,r,s,o,i){const a=this.makeTensorInfo(n,r),l=this.texData.get(a.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[s,o]},l.texShape=[s,o];const c=$m(n),d=new WI(c,!1,i),f=this.runWebGLProgram(d,[a],r,[[s,o]]);return f.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(a),f.dataId}write(e,n,r){if((se().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||se().getBool("DEBUG"))&&this.checkNumericalProblems(e),r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:n,dtype:r,values:e,usage:_s.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const n=this.texData.get(e);n.refCount++}decRef(e){if(this.texData.has(e)){const n=this.texData.get(e);n.refCount--}}move(e,n,r,s,o){if(se().getBool("DEBUG")&&this.checkNumericalProblems(n),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:s,values:n,usage:_s.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const n=this.texData.get(e),{values:r,dtype:s,complexTensorInfos:o,slice:i,shape:a,isPacked:l}=n;if(i!=null){let p;l?p=new ul(a,il):p=new fi(a,il);const g=this.runWebGLProgram(p,[{dataId:e,shape:a,dtype:s}],s),y=this.readSync(g.dataId);return this.disposeIntermediateTensorInfo(g),y}if(r!=null)return this.convertAndCacheOnCPU(e);if(s==="string")return r;const c=this.activeTimers!=null;let d;c&&(d=Po());let f;if(s==="complex64"){const p=this.readSync(o.real.dataId),g=this.readSync(o.imag.dataId);f=kf(p,g)}else f=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=Po()-d),this.convertAndCacheOnCPU(e,f)}async read(e){if(this.pendingRead.has(e)){const y=this.pendingRead.get(e);return new Promise(x=>y.push(x))}const n=this.texData.get(e),{values:r,shape:s,slice:o,dtype:i,complexTensorInfos:a,isPacked:l}=n;if(o!=null){let y;l?y=new ul(s,il):y=new fi(s,il);const x=this.runWebGLProgram(y,[{dataId:e,shape:s,dtype:i}],i),w=this.read(x.dataId);return this.disposeIntermediateTensorInfo(x),w}if(r!=null)return this.convertAndCacheOnCPU(e);if(se().getBool("DEBUG")&&!se().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&se().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,d;if(i!=="complex64"&&se().get("WEBGL_BUFFER_SUPPORTED")){d=this.decode(e);const y=this.texData.get(d.dataId);c=this.gpgpu.createBufferFromTexture(y.texture.texture,...wm(s))}this.pendingRead.set(e,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let f;if(i==="complex64"){const y=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),x=y[0],w=y[1];f=kf(x,w)}else if(c==null)f=this.getValuesFromTexture(e);else{const y=pe(s);f=this.gpgpu.downloadFloat32MatrixFromBuffer(c,y)}if(d!=null&&this.disposeIntermediateTensorInfo(d),c!=null){const y=this.gpgpu.gl;Oe(y,()=>y.deleteBuffer(c))}const p=this.convertAndCacheOnCPU(e,f),g=this.pendingRead.get(e);return this.pendingRead.delete(e),g.forEach(y=>y(p)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&ds().removeDataId(e,this),this.pendingDeletes--),p}readToGPU(e,n={}){const r=this.texData.get(e),{values:s,shape:o,slice:i,dtype:a,isPacked:l,texture:c}=r;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let g;l?g=new ul(o,il):g=new fi(o,il);const y=this.runWebGLProgram(g,[{dataId:e,shape:o,dtype:a}],a),x=this.readToGPU(y,n);return this.disposeIntermediateTensorInfo(y),x}if(c==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(e,n.customTexShape),f=ds().makeTensorFromTensorInfo(d),p=this.texData.get(d.dataId);return Object.assign({tensorRef:f},p.texture)}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const r=n.map(s=>fa(s));return Wt(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Wt(e.shape,e.dtype,n)}checkNumericalProblems(e){if(e!=null)for(let n=0;n<e.length;n++){const r=e[n];if(!bse(r))throw se().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:n,dtype:r,isPacked:s}=this.texData.get(e),o=pe(n);if(se().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const p=this.decode(e),g=this.texData.get(p.dataId),y=this.gpgpu.downloadMatrixFromPackedTexture(g.texture.texture,...wm(n)).subarray(0,o);return this.disposeIntermediateTensorInfo(p),y}const i=se().getBool("WEBGL_PACK")&&s===!0,a=i?$m(n):n,l=i?new Foe(a):new Ooe(a),c=this.runWebGLProgram(l,[{shape:a,dtype:r,dataId:e}],"float32"),d=this.texData.get(c.dataId),f=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(c),f}timerAvailable(){return se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const n=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const o=pa(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=pa(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,s&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(o);a.kernelMs=VP(l),a.getExtraProfileInfo=()=>l.map((c,d)=>({name:i[d],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Po(),endMs:null}}endTimer(e){return se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Po(),e)}async getQueryTime(e){if(se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const n=e;return n.endMs-n.startMs}disposeData(e,n=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(n?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!n&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return r!=null&&(this.disposeData(r.real.dataId,n),this.disposeData(r.imag.dataId,n)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:n,dtype:r,texShape:s,usage:o,isPacked:i,slice:a}=this.texData.get(e),l=a&&a.origDataId||e,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(n,s,o,i)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,n=vle){return se().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>this.texData.get(r.dataId).texture==null&&pe(r.shape)<n)}getGPGPUContext(){return this.gpgpu}where(e){Lo("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=e.dataSync();return mle(e.shape,n)}packedUnaryOp(e,n,r){const s=new ul(e.shape,n),o=this.compileAndRun(s,[e],r);return ds().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const s=RO(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if(se().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,YI,e.dtype);const n=new fi(e.shape,YI),r=this.compileAndRun(n,[e]);return ds().makeTensorFromTensorInfo(r)}makeTensorInfo(e,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&Gf(r[0])){const o=r.map(i=>hl(i));s=this.write(o,e,n)}else s=this.write(r,e,n);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:n}}makeOutput(e,n,r){return ds().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,r),this)}unpackTensor(e){const n=new ple(e.shape);return this.runWebGLProgram(n,[e],e.dtype)}packTensor(e){const n=new Zae(e.shape);return this.runWebGLProgram(n,[e],e.dtype,null,!0)}packedReshape(e,n){const r=[dd(e.shape),...hd(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},o=[dd(n),...hd(n)],i=new AO(o,r),a=!0,l=[r],c=this.runWebGLProgram(i,[s],e.dtype,l,a);return{dataId:c.dataId,shape:n,dtype:c.dtype}}decode(e,n){const r=this.texData.get(e),{isPacked:s,shape:o,dtype:i}=r;if(n!=null){const p=pe(o),g=n[0]*n[1]*4;z(p<=g,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=$m(o);let l;s?l=new Doe(a):l=new Aoe(a);const c=!0,d=[n??wm(a)],f=this.runWebGLProgram(l,[{shape:a,dtype:i,dataId:e}],i,d,c,n);return{dtype:i,shape:o,dataId:f.dataId}}runWebGLProgram(e,n,r,s,o=!1,i){const a=this.makeTensorInfo(e.outputShape,r),l=this.texData.get(a.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===Tf.DENSE){const S=i??wm(e.outputShape);l.texShape=S.map($=>$*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),pe(a.shape)===0)return l.values=Si(a.dtype,0),a;const c=[],d=n.map(S=>{if(S.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let $=this.texData.get(S.dataId);if($.texture==null){if(!e.packedInputs&&pe(S.shape)<=se().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:S.shape,texData:null,isUniform:!0,uniformValues:$.values};e.packedInputs&&($.isPacked=!0,$.shape=S.shape)}if(this.uploadToGPU(S.dataId),!!$.isPacked!=!!e.packedInputs)S=$.isPacked?this.unpackTensor(S):this.packTensor(S),c.push(S),$=this.texData.get(S.dataId);else if($.isPacked&&!Rg($.shape,S.shape)){const I=S,R=S.shape;S.shape=$.shape,S=this.packedReshape(S,R),c.push(S),$=this.texData.get(S.dataId),I.shape=R}return{shape:S.shape,texData:$,isUniform:!1}});this.uploadToGPU(a.dataId);const f={shape:a.shape,texData:l,isUniform:!1},p=Poe(e,d,f),g=this.getAndSaveBinary(p,()=>Roe(this.gpgpu,e,d,f)),y=this.activeTimers!=null;let x;y&&(x=this.startTimer()),se().get("ENGINE_COMPILE_ONLY")||_oe(this.gpgpu,g,d,f,s),c.forEach(S=>this.disposeIntermediateTensorInfo(S)),y&&(x=this.endTimer(x),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(x)}));const w=se().getNumber("WEBGL_FLUSH_THRESHOLD");if(w>0){const S=Po();S-this.lastGlFlushTime>w&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=S)}if(!se().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&o===!1){const S=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),S}return a}compileAndRun(e,n,r,s,o=!1){return r=r||n[0].dtype,this.runWebGLProgram(e,n,r,s,o)}getAndSaveBinary(e,n){return e in this.binaryCache||(this.binaryCache[e]=n()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(se().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=nt(()=>{if(!se().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=se().getBool("DEBUG");se().set("DEBUG",!1);const n=this.abs(mt(1e-8)).dataSync()[0];if(se().set("DEBUG",e),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?gle:yle}uploadToGPU(e){const n=this.texData.get(e),{shape:r,dtype:s,values:o,texture:i,usage:a,isPacked:l}=n;if(i!=null)return;const c=this.activeTimers!=null;let d;c&&(d=Po());let f=n.texShape;if(f==null&&(f=zse(r,l),n.texShape=f),o!=null){const p=$m(r);let g,y=f[1],x=f[0];const w=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(l||!w)&&([y,x]=Id(f[0],f[1])),l?g=new zoe(p,w):g=new WI(p,w);const S=w?[x,y]:f,$=this.makeTensorInfo(S,s),I=this.texData.get($.dataId);w?I.usage=_s.PIXELS:I.usage=_s.UPLOAD,I.texShape=S,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture($.dataId),y,x,o);const R=[[x,y]],O=this.runWebGLProgram(g,[$],s,R,!0),F=this.texData.get(O.dataId);n.texShape=F.texShape,n.isPacked=F.isPacked,n.usage=F.usage,se().get("ENGINE_COMPILE_ONLY")?this.disposeData(O.dataId):(n.texture=F.texture,n.values=null,this.texData.delete(O.dataId)),this.disposeIntermediateTensorInfo($),c&&(this.uploadWaitMs+=Po()-d)}else{const p=this.acquireTexture(f,a,s,l);n.texture=p}}convertAndCacheOnCPU(e,n){const r=this.texData.get(e),{dtype:s}=r;return n!=null&&(r.values=Sle(n,s)),r.values}acquireTexture(e,n,r,s){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,n,s)}computeBytes(e,n){return e[0]*e[1]*xg(n)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(n));return Promise.all(e)}else{for(const[,n]of Object.entries(this.binaryCache)){const r=new Promise(s=>{try{this.checkCompletion_(n),s(!0)}catch(o){throw o}});e.push(r)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await ese(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(mO(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:n,customUniformLocations:r,infLoc:s,nanLoc:o,outShapeLocation:i,outShapeStridesLocation:a,outTexShapeLocation:l}=bO(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=n,e.customUniformLocations=r,e.infLoc=s,e.nanLoc=o,e.outShapeLocation=i,e.outShapeStridesLocation=a,e.outTexShapeLocation=l}}createTensorFromGPUData(e,n,r){e.channels=e.channels||"RGBA";const{texture:s,height:o,width:i,channels:a}=e,l=ds().backend;if(!l.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=l.writeTexture(s,n,r,o,i,a);return ds().makeTensorFromDataId(c,n,r,l)}}by.nextDataId=0;function Sle(t,e){if(e==="float32"||e==="complex64")return t;if(e==="int32"||e==="bool"){const n=e==="int32"?new Int32Array(t.length):new Uint8Array(t.length);for(let r=0;r<n.length;++r)n[r]=Math.round(t[r]);return n}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_A()&&DA("webgl",()=>new by,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AC=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;let Lu=class{constructor(e,n,r){this.variableNames=["A","B"],this.outputShape=ct(n,r),this.enableShapeUniforms=cr(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ju=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Pd{constructor(e,n,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=ct(n,r);const o=this.outputShape.length;this.enableShapeUniforms=cr(o);let i="";if(s)if(o===0||pe(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${Kt(o)} coords = getOutputCoords();
        `,o===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=$r("coords",o);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${l[o-2]} + 1) >= outShape[${o} - 2];
            bool nextColOutOfBounds =
              (${l[o-1]} + 1) >= outShape[${o} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${l[o-2]} + 1) >= ${this.outputShape[o-2]};
            bool nextColOutOfBounds =
              (${l[o-1]} + 1) >= ${this.outputShape[o-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ms(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const Cle={kernelName:ry,backendName:"webgl",kernelFunc:ms};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Il(t){const{inputs:e,backend:n}=t,{real:r,imag:s}=e,o=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(o.dataId),a=ms({inputs:{x:r},backend:n}),l=ms({inputs:{x:s},backend:n});return i.complexTensorInfos={real:a,imag:l},o}const $le={kernelName:C2,backendName:"webgl",kernelFunc:Il};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DO="return (a < 0.) ? b * a : a;",OO=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function kle(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{alpha:o}=r,i=n.makeTensorInfo([],"float32",kd(o,"float32")),a=se().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Pd(OO,s.shape,i.shape):new Lu(DO,s.shape,i.shape),l=n.runWebGLProgram(a,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),l}const Tle={kernelName:hw,backendName:"webgl",kernelFunc:kle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FO="return (a < 0.) ? b * a : a;",LO=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Ile(t){const{inputs:e,backend:n}=t,{x:r,alpha:s}=e,o=se().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Pd(LO,r.shape,s.shape):new Lu(FO,r.shape,s.shape);return n.runWebGLProgram(o,[r,s],"float32")}const Nle={kernelName:Uw,backendName:"webgl",kernelFunc:Ile};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ad="if (isnan(x)) return x;";function $t({opSnippet:t,packedOpSnippet:e,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:o})=>{const{x:i}=s,a=o,l=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&n!=null){const f=a.texData.get(i.dataId),p=n(f.values,l);return a.makeTensorInfo(i.shape,l,p)}const c=se().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let d;return c?d=new ul(i.shape,e):d=new fi(i.shape,t),a.runWebGLProgram(d,[i],l)}}function Qn({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}){return({inputs:i,backend:a})=>{const{a:l,b:c}=i,d=a;if(r&&l.dtype==="complex64"){const y=d.texData.get(l.dataId),x=d.texData.get(c.dataId),[w,S]=[[y.complexTensorInfos.real,x.complexTensorInfos.real],[y.complexTensorInfos.imag,x.complexTensorInfos.imag]].map(I=>{const[R,_]=I,O={dataId:R.dataId,dtype:R.dtype,shape:l.shape},F={dataId:_.dataId,dtype:_.dtype,shape:c.shape},B=new Lu(t,l.shape,c.shape);return d.runWebGLProgram(B,[O,F],jr(R.dtype,_.dtype))}),$=Il({inputs:{real:w,imag:S},backend:d});return d.disposeIntermediateTensorInfo(w),d.disposeIntermediateTensorInfo(S),$}const f=o||jr(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||d.shouldExecuteOnCPU([l,c]))&&s!=null){const y=d.texData.get(l.dataId).values,x=d.texData.get(c.dataId).values,w=l.dtype==="string"?bl(y):y,S=l.dtype==="string"?bl(x):x,[$,I]=s(l.shape,c.shape,w,S,f),R=d.makeTensorInfo(I,f),_=d.texData.get(R.dataId);return _.values=$,R}const p=se().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let g;return p?g=new Pd(e,l.shape,c.shape,n):g=new Lu(t,l.shape,c.shape),d.runWebGLProgram(g,[l,c],f)}}function If(t,e=!1){if(t==="linear")return e?ule:sle;if(t==="relu")return e?dle:ile;if(t==="elu")return e?cle:ole;if(t==="relu6")return e?hle:ale;if(t==="prelu")return e?LO:FO;if(t==="leakyrelu")return e?OO:DO;if(t==="sigmoid")return e?fle:lle;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let zO=class{constructor(e,n,r,s=!1,o=!1,i=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=cr(this.outputShape.length);const d=s?e[1]:e[2],f=Math.ceil(d/2),p=s?"i * 2, rc.y":"rc.y, i * 2",g=o?"rc.z, i * 2":"i * 2, rc.z",y=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],x=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let w="",S="";a&&(l?w=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:c?w=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:w=`vec4 activation(vec4 x) {
          ${a}
        }`,S="result = activation(result);");const $=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let I="rc.x",R="rc.x";e[0]<n[0]?I=`imod(rc.x, ${e[0]})`:n[0]<e[0]&&(R=`imod(rc.x, ${n[0]})`),this.userCode=`
      ${w}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${f}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${I};
        int batchB = ${R};
        for (int i = 0; i < ${f}; i++) {
          vec4 a = getMatrixA(batchA, ${p});
          vec4 b = getMatrixB(batchB, ${g});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${y[0]} * ${x[0]});
          result += (${y[1]} * ${x[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${$}

        ${S}

        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QI={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};let ZI=class{constructor(e,n,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=ct(n,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JI="return a * b;";function DC(t){const{inputs:e,backend:n}=t,{a:r,b:s}=e,o=jr(r.dtype,s.dtype);if(r.dtype==="complex64"){const a=n.texData.get(r.dataId),l=n.texData.get(s.dataId),c=new ZI(QI.REAL,r.shape,s.shape),d=new ZI(QI.IMAG,r.shape,s.shape),f=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],p=n.runWebGLProgram(c,f,"float32"),g=n.runWebGLProgram(d,f,"float32"),y=Il({inputs:{real:p,imag:g},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g),y}if(n.shouldExecuteOnCPU([r,s])){const a=n.texData.get(r.dataId),l=n.texData.get(s.dataId),[c,d]=Iae(r.shape,s.shape,a.values,l.values,o),f=n.makeTensorInfo(d,o),p=n.texData.get(f.dataId);return p.values=c,f}let i;return se().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Pd(JI,r.shape,s.shape):i=new Lu(JI,r.shape,s.shape),n.runWebGLProgram(i,[r,s],o)}const Ele={kernelName:Aw,backendName:"webgl",kernelFunc:DC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rle(t,e,n){const r=[dd(t.shape),...hd(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},o=[dd(e),...hd(e)],i=new AO(o,r),a=!0,l=[r],c=n.runWebGLProgram(i,[s],t.dtype,l,a);return{dataId:c.dataId,shape:e,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{shape:o}=r,i=n,a=pe(s.shape),l=WP(o,a),c=pe(l);z(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const d=i.texData.get(s.dataId);return d.isPacked&&!Rg(s.shape,l)&&!(d.texture!==null&&Rg(d.shape,l))?Rle(s,l,i):(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype})}const _le={kernelName:qw,backendName:"webgl",kernelFunc:Pe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eN{constructor(e,n){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=e;this.outputShape=[s,i];const a=Math.floor(r/4)*4,l=r%4;let c="sumValue += dot(values, ones);";if(n!=null){const f=1/n;c=`sumValue += dot(values * ${id(f)?f.toPrecision(2):f}, ones);`}let d="";o%r>0&&(d=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ple=class{constructor(e,n){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=e;this.outputShape=[s,i];let a="0.0",l="";n==="prod"?a="1.0":n==="min"?(a="1.0 / 1e-20",l="min"):n==="max"&&(a="-1.0 / 1e-20",l="max");let c=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="sum"?c="sumValue":n==="prod"?c="prodValue":n==="all"?c="allValue":n==="any"&&(c="anyValue");const d=Math.floor(r/4)*4,f=r%4;let p=`
      if (${n==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${n==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${n==="min"} || ${n==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,g="vec4";n==="all"?(a="1.0",p=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,g="bvec4"):n==="any"&&(a="0.0",p=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,g="bvec4");let y="";o%r>0&&(y=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${y}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${d};
        if (${f===1}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${f===2}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${f===3}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${p}
        }
        setOutput(${c});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ale(t){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const n=e.length?e[e.length-1].outSize:t[1],r=xy(n);e.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return e}function Gu(t,e,n,r){const s=Ale(t.shape);let o=t;for(let i=0;i<s.length;i++){const{inSize:a,windowSize:l,outSize:c}=s[i];let d,f;n==="mean"?d=i===0?new eN({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:c},a):new eN({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:c}):d=new Ple({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:c},n),f=o,o=r.runWebGLProgram(d,[o],e),f.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(f)}return o}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Dle=class{constructor(e,n){this.variableNames=["A"];const r=new Array(e.length);for(let i=0;i<r.length;i++)r[i]=e[n[i]];this.outputShape=r,this.rank=r.length;const s=Kt(this.rank),o=Ole(n);this.userCode=`
    void main() {
      ${s} resRC = getOutputCoords();
      setOutput(getA(${o}));
    }
    `}};function Ole(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let s=0;s<t.length;s++)r[t[s]]=n[s];return r.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fle{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(e.length);for(let d=0;d<r.length;d++)r[d]=e[n[d]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=Kt(this.rank),o=PO("rc",this.rank),i=new Array(this.rank);for(let d=0;d<n.length;d++)i[n[d]]=o[d];const a=`vec2(${i.slice(-2).join()})`,l=`++${o[this.rank-1]} < ${r[this.rank-1]}`,c=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${o[this.rank-1]};
      if(++${o[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wy(t,e,n){const r=se().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Fle(t.shape,e):new Dle(t.shape,e);return n.runWebGLProgram(r,[t],t.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lle(t,e,n,r){const s=e,o=t.shape.length,i=nn(s,t.shape);let a=i;const l=lr(a,o),c=l!=null;let d=t;c&&(d=wy(t,l,r),a=ur(a.length,o)),vs("sum",a,o);const[f,p]=Fs(d.shape,a);let g=f;n&&(g=xs(f,i));const y=pe(p),w=pe(t.shape)/y,S=Pe({inputs:{x:d},attrs:{shape:[w,y]},backend:r}),$=ay(t.dtype),I=Gu(S,$,"sum",r),R=Pe({inputs:{x:I},attrs:{shape:g},backend:r});return r.disposeIntermediateTensorInfo(S),r.disposeIntermediateTensorInfo(I),c&&r.disposeIntermediateTensorInfo(d),R}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sy(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r;return Lle(s,o,i,n)}const zle={kernelName:pS,backendName:"webgl",kernelFunc:Sy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tr(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{perm:o}=r,i=n,a=s.shape.length,l=new Array(a);for(let d=0;d<l.length;d++)l[d]=s.shape[o[d]];let c;if(i.shouldExecuteOnCPU([s])){const f=i.texData.get(s.dataId).values,p=PC(f,s.shape,s.dtype,o,l);c=i.makeTensorInfo(l,s.dtype);const g=i.texData.get(c.dataId);g.values=p}else c=wy(s,o,i);return c}const Ble={kernelName:Yh,backendName:"webgl",kernelFunc:Tr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BO=1e3;function Pg({a:t,b:e,transposeA:n,transposeB:r,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:l=null}){const c=t.shape.length,d=e.shape.length,f=n?t.shape[c-2]:t.shape[c-1],p=r?e.shape[d-1]:e.shape[d-2],g=n?t.shape[c-1]:t.shape[c-2],y=r?e.shape[d-2]:e.shape[d-1],x=t.shape.slice(0,-2),w=e.shape.slice(0,-2),S=pe(x),$=pe(w),R=ct(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([g,y]);z(f===p,()=>`Error in matMul: inner shapes (${f}) and (${p}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${r} must match.`);const _=n?[S,f,g]:[S,g,f],O=r?[$,y,p]:[$,p,y],F=Pe({inputs:{x:t},backend:s,attrs:{shape:_}}),B=Pe({inputs:{x:e},backend:s,attrs:{shape:O}}),M=[F,B],V=Math.max(S,$),P=n?F.shape[1]:F.shape[2],re=o!=null,ie=i!=null,me=l==="leakyrelu",ge=l!=null?If(l,!0):null,ve=re||ie||me||ge!=null;let $e;if((g===1||y===1)&&P>BO&&ve===!1){let xe=F,ae=B;n&&(xe=Tr({inputs:{x:F},backend:s,attrs:{perm:[0,2,1]}}),M.push(xe)),r&&(ae=Tr({inputs:{x:B},backend:s,attrs:{perm:[0,2,1]}}),M.push(ae));const q=y!==1,ue=y===1;let we=xe;q&&(we=Pe({inputs:{x:xe},backend:s,attrs:{shape:[V,P,1]}}),M.push(we));const Ge=y===1?2:1;let et=ae;ue&&(et=Pe({inputs:{x:ae},backend:s,attrs:{shape:[V,1,P]}}),M.push(et));const tt=DC({inputs:{a:we,b:et},backend:s});$e=Sy({inputs:{x:tt},backend:s,attrs:{axis:Ge,keepDims:!0}}),M.push(tt)}else{const xe=jr(t.dtype,e.dtype),ae=new zO(_,O,[V,g,y],n,r,re,ge,ie,me),q=[F,B];if(o!=null&&q.push(o),ie&&q.push(i),me){const ue=s.makeTensorInfo([],"float32",kd(a,"float32"));q.push(ue),M.push(ue)}$e=s.runWebGLProgram(ae,q,xe)}const fe=Pe({inputs:{x:$e},backend:s,attrs:{shape:R}});M.push($e);for(const xe of M)s.disposeIntermediateTensorInfo(xe);return fe}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mle(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:o,bias:i,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:d,leakyreluAlpha:f}=r;return Pg({a:s,b:o,transposeA:l,transposeB:c,backend:n,bias:i,preluActivationWeights:a,leakyreluAlpha:f,activation:d})}const Vle={kernelName:bg,backendName:"webgl",kernelFunc:Mle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tN="return abs(x);";function Wle(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const o=n.texData.get(r.dataId),i=RO(o.values);return n.makeTensorInfo(r.shape,r.dtype,i)}let s;return se().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new ul(r.shape,tN):s=new fi(r.shape,tN),n.runWebGLProgram(s,[r],r.dtype)}const Ule={kernelName:n2,backendName:"webgl",kernelFunc:Wle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jle=mo+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Gle=$t({opSnippet:jle}),Hle={kernelName:r2,backendName:"webgl",kernelFunc:Gle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kle=mo+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Xle=$t({opSnippet:Kle}),qle={kernelName:s2,backendName:"webgl",kernelFunc:Xle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nN="return a + b;",Yle=Qn({opSnippet:nN,packedOpSnippet:nN,supportsComplex:!0,cpuKernelImpl:iae}),Qle={kernelName:ty,backendName:"webgl",kernelFunc:Yle};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zle{constructor(e,n){this.outputShape=[],this.outputShape=e,this.variableNames=n.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`float v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Jle=class{constructor(e,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=n.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`vec4 v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${s};
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jm(t){const{inputs:e,backend:n}=t,r=e;if(r.length===1)return ms({inputs:{x:r[0]},backend:n});if(r.length>se().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),c=Jm({inputs:r.slice(0,l),backend:n}),d=Jm({inputs:r.slice(l),backend:n});return Jm({inputs:[c,d],backend:n})}const s=r.map(l=>l.dtype).reduce((l,c)=>jr(l,c)),o=r.map(l=>l.shape),a=se().getBool("WEBGL_PACK")?new Jle(r[0].shape,o):new Zle(r[0].shape,o);return n.runWebGLProgram(a,r,s)}const eue={kernelName:o2,backendName:"webgl",kernelFunc:Jm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tue(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,l=nn(o,s.shape);let c=l;const d=lr(c,a);let f=s;d!=null&&(f=Tr({inputs:{x:s},backend:n,attrs:{perm:d}}),c=ur(c.length,a)),vs("all",c,a);const[p,g]=Fs(f.shape,c),y=pe(g),x=Pe({inputs:{x:f},backend:n,attrs:{shape:[-1,y]}}),w=Gu(x,x.dtype,"all",n);let S;if(i){const $=xs(p,l);S=Pe({inputs:{x:w},backend:n,attrs:{shape:$}})}else S=Pe({inputs:{x:w},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),d!=null&&n.disposeIntermediateTensorInfo(f),S}const nue={kernelName:i2,backendName:"webgl",kernelFunc:tue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rue(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,l=nn(o,s.shape);let c=l;const d=lr(c,a);let f=s;d!=null&&(f=Tr({inputs:{x:s},backend:n,attrs:{perm:d}}),c=ur(c.length,a)),vs("any",c,a);const[p,g]=Fs(f.shape,c),y=pe(g),x=Pe({inputs:{x:f},backend:n,attrs:{shape:[-1,y]}}),w=Gu(x,x.dtype,"any",n);let S;if(i){const $=xs(p,l);S=Pe({inputs:{x:w},backend:n,attrs:{shape:$}})}else S=Pe({inputs:{x:w},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),d!=null&&n.disposeIntermediateTensorInfo(f),S}const sue={kernelName:a2,backendName:"webgl",kernelFunc:rue};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let oue=class{constructor(e,n,r){this.variableNames=["A"];const{windowSize:s,batchSize:o,outSize:i}=e;r||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i];const a=n==="max"?">":"<",l=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iue{constructor(e,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,z(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const o=e[e.length-1],i=Math.ceil(o/n);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,c=Kt(l),d=$r("coords",l);let f,p;if(i===1){p=l+1;const B=Kt(p);f=`
        ${B} sourceLocR = ${B}(${d.join()}, 0);
        ++${d[l-1]};
        ${B} sourceLocG = ${B}(${d.join()}, 0);
        ++${d[l-2]};
        ${B} sourceLocA = ${B}(${d.join()}, 0);
        --${d[l-1]};
        ${B} sourceLocB = ${B}(${d.join()}, 0);
        --${d[l-2]};`}else p=l,f=`
        ${c} sourceLocR = coords;
        ++${d[l-1]};
        ${c} sourceLocG = coords;
        ++${d[l-2]};
        ${c} sourceLocA = coords;
        --${d[l-1]};
        ${c} sourceLocB = coords;
        --${d[l-2]};`;const g=["x","y","z","w","u","v"].slice(0,p),y="."+g[p-1],x=g.map(B=>"int "+B),w=$r("sourceLocR",p-1).concat("inIdx.r"),S=$r("sourceLocG",p-1).concat("inIdx.g"),$=$r("sourceLocB",p-1).concat("inIdx.b"),I=$r("sourceLocA",p-1).concat("inIdx.a"),R=r==="max"?"greaterThan":"lessThan",_=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${S.join()}),
                             getBestIndicesAChannel(${$.join()}),
                             getBestIndicesAChannel(${I.join()})));`,O=`vec4(
            getAChannel(${w.join()}),
            hasNextCol ? getAChannel(${S.join()}) : 0.,
            hasNextRow ? getAChannel(${$.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${I.join()}) : 0.)`,F=s?"":`
      float getBestIndicesAChannel(${x.join()}) {
        return getChannel(getBestIndicesA(${g.join()}),
                                          vec2(${g.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${x.join()}) {
        return getChannel(getA(${g.join()}),
                               vec2(${g.slice(-2).join()}));
      }
      ${F}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${d[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${d[l-2]} < ${a[l-2]-1};
        ${f}
        ivec4 srcIdx = ivec4(sourceLocR${y}, sourceLocG${y},
          sourceLocB${y}, sourceLocA${y}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${O};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${_}
          vec4 candidate = ${O};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${R}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MO(t,e,n,r=null){let s=e.shape[0],o=e.shape[1];r!=null&&(s=r.shape[0],o=r.shape[1]);const i=xy(o),a={windowSize:i,inSize:o,batchSize:s,outSize:Math.ceil(o/i)},l=new oue(a,n,r==null),c=[e];r!=null&&c.push(r);const d=t.runWebGLProgram(l,c,"int32");if(d.shape[1]===1)return d;const f=MO(t,e,n,d);return t.disposeIntermediateTensorInfo(d),f}function VO(t,e,n,r=null){const s=r!=null?r.shape:e.shape,o=s[s.length-1],i=xy(o),a=new iue(s,i,n,r==null),l=r==null?[e]:[e,r],c=t.runWebGLProgram(a,l,"int32");if(c.shape.length===e.shape.length){const d=VO(t,e,n,c);return t.disposeIntermediateTensorInfo(c),d}return c}function WO(t,e,n,r){const s=[n];if(vs("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,e.shape.length),!se().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const o=[],i=t.texData.get(e.dataId),a=i!==null&&i.isPacked;let l=e;a&&(l=t.unpackTensor(e),o.push(l));const[c,d]=Fs(l.shape,s),f=pe(d),p=Pe({inputs:{x:l},backend:t,attrs:{shape:[-1,f]}});o.push(p);const g=MO(t,p,r);o.push(g);const y=Pe({inputs:{x:g},backend:t,attrs:{shape:c}});return o.forEach(x=>t.disposeIntermediateTensorInfo(x)),y}return VO(t,e,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aue(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o}=r;let i=nn(o,s.shape);const a=lr(i,s.shape.length);let l=s;const c=[];a!=null&&(l=Tr({inputs:{x:s},backend:n,attrs:{perm:a}}),c.push(l),i=ur(i.length,l.shape.length)),vs("argMax",[i[0]],l.shape.length);const d=WO(n,l,i[0],"max");return c.forEach(f=>n.disposeIntermediateTensorInfo(f)),d}const lue={kernelName:l2,backendName:"webgl",kernelFunc:aue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uue(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o}=r;let i=nn(o,s.shape);const a=lr(i,s.shape.length);let l=s;const c=[];a!=null&&(l=Tr({inputs:{x:s},backend:n,attrs:{perm:a}}),c.push(l),i=ur(i.length,l.shape.length)),vs("argMin",[i[0]],l.shape.length);const d=WO(n,l,i[0],"min");return c.forEach(f=>n.disposeIntermediateTensorInfo(f)),d}const cue={kernelName:u2,backendName:"webgl",kernelFunc:uue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const due=mo+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,hue=$t({opSnippet:due}),fue={kernelName:c2,backendName:"webgl",kernelFunc:hue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pue=mo+"return log(x + sqrt(x * x + 1.0));",mue=$t({opSnippet:pue}),gue={kernelName:d2,backendName:"webgl",kernelFunc:mue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yue=mo+`
  return atan(x);
`,xue=$t({opSnippet:yue}),vue={kernelName:h2,backendName:"webgl",kernelFunc:xue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bue=AC+`
  return atan(a, b);
`,wue=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+ju+`
  return result;
`,Sue=Qn({opSnippet:bue,packedOpSnippet:wue}),Cue={kernelName:p2,backendName:"webgl",kernelFunc:Sue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ue=mo+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,kue=$t({opSnippet:$ue}),Tue={kernelName:f2,backendName:"webgl",kernelFunc:kue};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Nf=class{constructor(e,n,r,s=!1,o=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,d=e.dilationWidth,f=e.effectiveFilterHeight,p=e.effectiveFilterWidth,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const x=n==="avg",w=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,S=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let $="0.0";if(x||($="-1.0 / 1e-20"),r){const B=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${g}, ${y});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${f};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p};
                wC += ${d}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${B} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s?o?w:S:`wR * ${p} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const I="max";let R=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(R="avgValue / max(count, 1.0)");const _=Math.floor(i/4)*4,O=i%4,F=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${I}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${g}, ${y});
      const float initializationValue = ${$};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${$});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${f};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${_}; wC += 4) {
            int xC = xCCorner + wC * ${d};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              getValue(batch, xR, xC + 3 * ${d}, d)
            );

            ${F}
          }

          int xC = xCCorner + ${_};
          if (${O===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${F}
          } else if (${O===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              initializationValue,
              initializationValue
            );

            ${F}
          } else if (${O===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              initializationValue
            );

            ${F}
          }
        }
        setOutput(${R});
      }
    `}},OC=class{constructor(e,n,r,s=!1,o=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideDepth,l=e.strideHeight,c=e.strideWidth,d=e.dilationDepth,f=e.dilationHeight,p=e.dilationWidth,g=e.effectiveFilterDepth,y=e.effectiveFilterHeight,x=e.effectiveFilterWidth,w=e.padInfo.front,S=e.padInfo.top,$=e.padInfo.left;this.outputShape=e.outShape;const I=n==="avg";let R="0.0";if(I||(R="-1.0 / 1e-20"),r){const V=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${c});
        const ivec3 pads = ivec3(${w}, ${S}, ${$});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${g};
              wD += ${d}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${y};
                wR += ${f}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${x};
                  wC += ${p}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${V} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s?o?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${y} * ${x} +
                      wR * ${x} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const _="max";let O=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(O="avgValue / max(count, 1.0)");const F=Math.floor(i/4)*4,B=i%4,M=`
      if (${I}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${_}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${c});
      const ivec3 pads = ivec3(${w}, ${S}, ${$});
      const float initializationValue = ${R};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${R});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${g};
            wD += ${d}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${y};
            wR += ${f}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${F}; wC += 4) {
              int xC = xCCorner + wC * ${p};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                getValue(batch, xD, xR, xC + 3 * ${p}, ch)
              );

              ${M}
            }

            int xC = xCCorner + ${F};
            if (${B===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${M}
            } else if (${B===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                initializationValue,
                initializationValue
              );

              ${M}
            } else if (${B===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                initializationValue
              );

              ${M}
            }
          }
        }
        setOutput(${O});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iue(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;ep(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r,c=1;z(Nr(i,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const d=fo(s.shape,o,i,c,a,l);if(d.filterWidth===1&&d.filterHeight===1&&Vt(d.inShape,d.outShape))return ms({inputs:{x:s},backend:n});const f=new Nf(d,"avg",!1);return n.runWebGLProgram(f,[s],"float32")}const Nue={kernelName:m2,backendName:"webgl",kernelFunc:Iue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eue(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:c}=r,d=[1,1,1],f=Sa(s.shape,o,i,d,a,l,c),p=new OC(f,"avg",!1);return n.runWebGLProgram(p,[s],"float32")}const Rue={kernelName:g2,backendName:"webgl",kernelFunc:Eue};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let _ue=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,i=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,d=l-1-e.padInfo.top,f=c-1-e.padInfo.left,p=1/(n*r);this.userCode=`
      const ivec2 pads = ivec2(${d}, ${f});
      const float avgMultiplier = float(${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},Pue=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterDepth,r=e.filterHeight,s=e.filterWidth,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,f=e.effectiveFilterDepth,p=e.effectiveFilterHeight,g=e.effectiveFilterWidth,y=f-1-e.padInfo.front,x=p-1-e.padInfo.top,w=g-1-e.padInfo.left,S=1/(n*r*s);this.userCode=`
      const ivec3 pads = ivec3(${y}, ${x}, ${w});
      const float avgMultiplier = float(${S});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${o}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${g};
                wC += ${d}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aue(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,i=o,{filterSize:a,strides:l,pad:c,dimRoundingMode:d}=r,f=[1,1,1],p=Sa(i.shape,a,l,f,c,d),g=new Pue(p);return n.runWebGLProgram(g,[s],i.dtype)}const Due={kernelName:qP,backendName:"webgl",kernelFunc:Aue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oue(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,i=o;ep([s,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,d=fo(i.shape,a,l,1,c),f=new _ue(d);return n.runWebGLProgram(f,[s],i.dtype)}const Fue={kernelName:XP,backendName:"webgl",kernelFunc:Oue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lue(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:o}=e,{transposeA:i,transposeB:a}=r;return Pg({a:s,b:o,transposeA:i,transposeB:a,backend:n})}const zue={kernelName:y2,backendName:"webgl",kernelFunc:Lue};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Bue=class{constructor(e,n,r,s,o,i){this.outputShape=[],this.variableNames=["x","mean","variance"],ct(e,n),ct(e,r);let a="0.0";s!=null&&(ct(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";o!=null&&(ct(e,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mue{constructor(e,n,r,s,o,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],ct(e,n),ct(e,r);let a="vec4(0.0)";s!=null&&(ct(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";o!=null&&(ct(e,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vue=({inputs:t,backend:e,attrs:n})=>{const{x:r,mean:s,variance:o,offset:i,scale:a}=t;z(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),z(i==null||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),z(a==null||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);const c=[r,s,o];let d=null;i!=null&&(d=i.shape,c.push(i));let f=null;a!=null&&(f=a.shape,c.push(a));const p=se().getBool("WEBGL_PACK_NORMALIZATION")?new Mue(r.shape,s.shape,o.shape,d,f,l):new Bue(r.shape,s.shape,o.shape,d,f,l);return e.runWebGLProgram(p,c,c[0].dtype)},Wue={kernelName:nw,backendName:"webgl",kernelFunc:Vue};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Uue=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const n=Kt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=jue(this.rank);let s;const o=e.map((i,a)=>`sourceLoc.${wv[a]} = start[${a}] + coords.${wv[a]};`);s=`
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${o.join(`
`)}
      `,this.userCode=`
      void main() {
        ${s}
        setOutput(getSource(${r}));
      }
    `}};const wv=["x","y","z","w","u","v"];function jue(t){if(t===1)return"sourceLoc";if(t<=6)return wv.slice(0,t).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gue{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=Kt(this.rank),r=$r("coords",this.rank),s=$r("sourceLoc",this.rank),o=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${o})`,a=`
      result.x = ${i};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${i};
        --${s[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${i};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${i};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${n}(${e.map((d,f)=>`start[${f}]`).join()});`:e.map((d,f)=>`${s[f]} = ${r[f]} + start[${f}];`).join(`
`);this.userCode=`
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hue(t,e,n,r){const s=r.texData.get(t.dataId),o=r.makeTensorInfo(n,t.dtype),i=r.texData.get(o.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=t.dtype;let a=sC(e,gn(t.shape));s.slice&&(a+=s.slice.flatOffset),i.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||t.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),o}function Dd(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:o,size:i}=r,[a,l]=oC(s,o,i);if(tC(s,a,l),pe(l)===0)return n.makeTensorInfo(l,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||s.dtype==="string"){const f=n.texData.get(s.dataId),p=zae(f.values,a,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,p)}const{isPacked:c}=n.texData.get(s.dataId),d=rC(s.shape,a,l);if(c||!d){const f=se().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Gue(l):new Uue(l),p=[a];return n.runWebGLProgram(f,[s],s.dtype,p)}return n.uploadToGPU(s.dataId),Hue(s,a,l,n)}const Kue={kernelName:aS,backendName:"webgl",kernelFunc:Dd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xue=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:o,crops:i}=r;z(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce(($,I)=>$*I),l=Yf(s.shape,o,a),c=Qf(l.length,o.length),d=Zf(s.shape,o,a),f=cC(i,o.length),p=dC(d,i,o.length),g=[],y=Pe({inputs:{x:s},backend:n,attrs:{shape:l}}),x=Tr({inputs:{x:y},backend:n,attrs:{perm:c}}),w=Pe({inputs:{x},backend:n,attrs:{shape:d}}),S=Dd({inputs:{x:w},backend:n,attrs:{begin:f,size:p}});return g.push(y),g.push(x),g.push(w),g.forEach($=>n.disposeIntermediateTensorInfo($)),S},que={kernelName:x2,backendName:"webgl",kernelFunc:Xue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yue(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:o}=e,{size:i}=r,a=n.readSync(s.dataId),l=n.readSync(o.dataId),c=EO(a,l,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,c)}const Que={kernelName:v2,backendName:"webgl",kernelFunc:Yue};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zue=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,Jue=`
  return float(int(a.r) & int(b.r));
`;function ece(t){const{inputs:e,backend:n}=t,{a:r,b:s}=e,o=se().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=se().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,s])||i===1){const l=n.texData.get(r.dataId).values,c=n.texData.get(s.dataId).values,[d,f]=lae(r.shape,s.shape,l,c,r.dtype),p=n.makeTensorInfo(f,r.dtype),g=n.texData.get(p.dataId);return g.values=d,p}let a;return o?a=new Pd(Zue,r.shape,s.shape,!1):a=new Lu(Jue,r.shape,s.shape),n.runWebGLProgram(a,[r,s],r.dtype)}const tce={kernelName:YP,backendName:"webgl",kernelFunc:ece};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nce(t){const{inputs:e,backend:n}=t,{s0:r,s1:s}=e,o=n.readSync(r.dataId),i=n.readSync(s.dataId),a=ct(Array.from(o),Array.from(i));return n.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const rce={kernelName:b2,backendName:"webgl",kernelFunc:nce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sce="return float(a != b);",UO=Qn({opSnippet:sce,cpuKernelImpl:Eae,dtype:"bool"}),oce={kernelName:Ow,backendName:"webgl",kernelFunc:UO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function np(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.texData.get(r.dataId);return ms({inputs:{x:s.complexTensorInfos.real},backend:n})}const ice={kernelName:Hw,backendName:"webgl",kernelFunc:np};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ace="return float(int(x));";function lce(t,e){const n=new fi(t.shape,ace),r=e.runWebGLProgram(n,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sv(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dtype:o}=r;if(o==="complex64"){if(s.dtype==="complex64")return ms({inputs:{x:s},backend:n});const i=xa(s.shape),a=Sv({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),l=Il({inputs:{real:a,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(a),l}if(s.dtype==="complex64"){const i=np({inputs:{input:s},backend:n}),a=Sv({inputs:{x:i},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(i),a}if(!UP(s.dtype,o)){const i=ms({inputs:{x:s},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:o}}if(n.shouldExecuteOnCPU([s])){const i=n.texData.get(s.dataId).values,[a,l,c]=uae(i,s.shape,s.dtype,o);return n.makeTensorInfo(a,l,c)}if(o==="int32")return lce(s,n);if(o==="bool"){const i=n.makeTensorInfo([],"bool",Si("bool",1)),l=UO({inputs:{a:s,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}const uce={kernelName:ny,backendName:"webgl",kernelFunc:Sv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rN="return ceil(x);",cce=$t({opSnippet:rN,packedOpSnippet:rN,cpuKernelImpl:cae}),dce={kernelName:w2,backendName:"webgl",kernelFunc:cce};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let hce=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fce{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pce(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{clipValueMin:o,clipValueMax:i}=r;let a;se().getBool("WEBGL_PACK_CLIP")?a=new fce(s.shape):a=new hce(s.shape);const l=[[o],[i]];return n.runWebGLProgram(a,[s],s.dtype,l)}const mce={kernelName:S2,backendName:"webgl",kernelFunc:pce};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let gce=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sN(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}function yce(t){const{inputs:e,backend:n}=t,{x:r}=e,s=n.texData.get(r.dataId),o=new gce(r.shape),i=[sN(r,s.complexTensorInfos.real),sN(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(o,i,i[0].dtype)}const xce={kernelName:$2,backendName:"webgl",kernelFunc:yce};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let vce=class{constructor(e){this.outputShape=[],this.outputShape=co(e,1),this.variableNames=e.map((i,a)=>`T${a}`);const n=new Array(e.length-1);n[0]=e[0][1];for(let i=1;i<n.length;i++)n[i]=n[i-1]+e[i][1];const r=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<n.length;i++){const a=n[i-1];r.push(`else if (yC < ${n[i]}) setOutput(getT${i}(yR, yC-${a}));`)}const s=n.length,o=n[n.length-1];r.push(`else setOutput(getT${s}(yR, yC-${o}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bce{constructor(e,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=co(e,n);const r=this.outputShape,s=r.length,o=Kt(s),i=$r("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=e.map((x,w)=>`T${w}`);const l=new Array(e.length-1);l[0]=e[0][n];for(let x=1;x<l.length;x++)l[x]=l[x-1]+e[x][n];const c=a[n],d=a.slice(-2),f=a.join();let p=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${f}), vec2(${d.join()}));
        }`;for(let x=1;x<l.length;x++){const w=l[x-1];p+=`
        if (${c} < ${l[x]}  && ${c} >= ${l[x-1]}) {
          return getChannel(
            getT${x}(${Im(a,c,w)}),
            vec2(${Im(d,c,w)}));
        }`}const g=l.length,y=l[l.length-1];p+=`
        return getChannel(
          getT${g}(${Im(a,c,y)}),
          vec2(${Im(d,c,y)}));`,this.userCode=`
      float getValue(${a.map(x=>"int "+x)}) {
        ${p}
      }

      void main() {
        ${o} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[s-1]} = ${i[s-1]} + 1;
        if (${i[s-1]} < ${r[s-1]}) {
          result.g = getValue(${i});
        }

        ${i[s-2]} = ${i[s-2]} + 1;
        if (${i[s-2]} < ${r[s-2]}) {
          result.a = getValue(${i});
        }

        ${i[s-1]} = ${i[s-1]} - 1;
        if (${i[s-2]} < ${r[s-2]} &&
            ${i[s-1]} < ${r[s-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}}function Im(t,e,n){const r=t.indexOf(e);return t.map((o,i)=>i===r?`${o} - ${n}`:o).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cy(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.texData.get(r.dataId);return ms({inputs:{x:s.complexTensorInfos.imag},backend:n})}const wce={kernelName:lw,backendName:"webgl",kernelFunc:Cy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lh(t,e,n){const r=t[0].dtype;if(r==="complex64"){const g=t.map($=>np({inputs:{input:$},backend:n})),y=t.map($=>Cy({inputs:{input:$},backend:n})),x=Lh(g,e,n),w=Lh(y,e,n),S=Il({inputs:{real:x,imag:w},backend:n});return g.forEach($=>n.disposeIntermediateTensorInfo($)),y.forEach($=>n.disposeIntermediateTensorInfo($)),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),S}let s=n.shouldExecuteOnCPU(t);if(r==="string"&&(s=!0),s){const g=t.map(R=>{const O=[-1,pe(R.shape.slice(e))];return Pe({inputs:{x:R},backend:n,attrs:{shape:O}})}),y=g.map(R=>({vals:n.readSync(R.dataId),shape:R.shape})),x=co(g.map(R=>R.shape),1),w=g[0].shape[0]===1,S=dae(y,x,r,w),$=co(t.map(R=>R.shape),e),I=n.makeTensorInfo($,r,S);return g.forEach(R=>n.disposeIntermediateTensorInfo(R)),I}const o=t.filter(g=>pe(g.shape)>0),i=se().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(o.length===1){const g=i?new fi(t[0].shape,il):new ul(t[0].shape,il);return n.runWebGLProgram(g,t,r)}const a=se().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>a){const g=[];for(let x=0;x<o.length;x+=a){const w=o.slice(x,x+a);g.push(Lh(w,e,n))}const y=Lh(g,e,n);for(const x of g)n.disposeIntermediateTensorInfo(x);return y}if(i){const g=new bce(o.map(y=>y.shape),e);return n.runWebGLProgram(g,o,r)}const{tensors2D:l,outShape:c}=Sce(o,e,n),d=new vce(l.map(g=>g.shape)),f=n.runWebGLProgram(d,l,r);l.forEach(g=>n.disposeIntermediateTensorInfo(g));const p=Pe({inputs:{x:f},attrs:{shape:c},backend:n});return n.disposeIntermediateTensorInfo(f),p}function Sce(t,e,n){const r=co(t.map(o=>o.shape),e);return{tensors2D:t.map(o=>Pe({inputs:{x:o},attrs:{shape:[-1,pe(o.shape.slice(e))]},backend:n})),outShape:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jO(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r,o=nn(s,e[0].shape)[0],i=e.map(c=>c.shape);aC(i,o);const a=co(e.map(c=>c.shape),o);if(pe(a)===0)return n.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(c=>pe(c.shape)>0);return l.length===1?ms({inputs:{x:l[0]},backend:n}):Lh(l,o,n)}const Cce={kernelName:k2,backendName:"webgl",kernelFunc:jO};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GO{constructor(e,n=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const i=e.padInfo.top,a=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,d=e.dilationHeight,f=e.dilationWidth,p=e.filterHeight,g=e.filterWidth,y=Math.floor(e.inChannels/4)*4,x=e.inChannels%4,w=e.dataFormat==="channelsLast",S=w?1:2,$=w?2:3,I=w?3:1;let R="",_="";r&&(s?R=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?R=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:R=`
          float activation(float x) {
            ${r}
          }
        `,_="result = activation(result);");const O=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${R}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${I}];

        ivec2 xRCCorner =
            ivec2(coords[${S}], coords[${$}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p}; wR++) {
          int xR = xRCorner + wR * ${d};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${g}; wC++) {
            int xC = xCCorner + wC * ${f};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${y}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${w}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${x===1}) {

              if (${w}) {
                dotProd +=
                    getX(batch, xR, xC, ${y}) *
                    getW(wR, wC, ${y}, d2);
              } else {
                dotProd +=
                    getX(batch, ${y}, xR, xC) *
                    getW(wR, wC, ${y}, d2);
              }

            } else if (${x===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${y}, d2),
                getW(wR, wC, ${y} + 1, d2)
              );

              if (${w}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${y}),
                  getX(batch, xR, xC, ${y} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${y}, xR, xC),
                  getX(batch, ${y} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${x===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${y}, d2),
                getW(wR, wC, ${y} + 1, d2),
                getW(wR, wC, ${y} + 2, d2)
              );

              if (${w}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${y}),
                  getX(batch, xR, xC, ${y} + 1),
                  getX(batch, xR, xC, ${y} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${y}, xR, xC),
                  getX(batch, ${y} + 1, xR, xC),
                  getX(batch, ${y} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${O}
        ${_}
        setOutput(result);
      }
    `}}class $ce{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const n=e.padInfo.front,r=e.padInfo.top,s=e.padInfo.left,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,f=e.filterDepth,p=e.filterHeight,g=e.filterWidth,y=Math.floor(e.inChannels/4)*4,x=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${o}, ${i}, ${a});
      const ivec3 pads = ivec3(${n}, ${r}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${f}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${g}; wC++) {
              int xC = xCCorner + wC * ${d};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${y}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${x===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${y}) *
                  getW(wF, wR, wC, ${y}, d2);
              } else if (${x===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${y}),
                  getX(batch, xF, xR, xC, ${y} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${y}, d2),
                  getW(wF, wR, wC, ${y} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${x===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${y}),
                  getX(batch, xF, xR, xC, ${y} + 1),
                  getX(batch, xF, xR, xC, ${y} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${y}, d2),
                  getW(wF, wR, wC, ${y} + 1, d2),
                  getW(wF, wR, wC, ${y} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HO{constructor(e,n=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=cr(this.outputShape.length);const i=e.padInfo.left,a=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,f=d;let p=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let w=0;w<d;w++)p+=`
           vec4 xTexelC${w*2};
           int xTexelC${w*2}Ready;
           vec4 xTexelC${w*2+1};
           int xTexelC${w*2+1}Ready;
           vec4 xC${w};`;p+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let w=0;w<d;w++)p+=`
           xTexelC${w*2} = vec4(0.0);
           xTexelC${w*2}Ready = 0;
           xTexelC${w*2+1} = vec4(0.0);
           xTexelC${w*2+1}Ready = 0;
           xC${w} = vec4(0.0);`;p+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let w=0;w<(f+1)/2;w++){const S=w*2;if(p+=`
           xC = xCCorner + ${S*l};
           `,a===1){if(S<d&&(i%2===1?(p+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }
               `,l===1&&S>0?p+=`
                 xC${S} = vec4(xTexelC${S-2}.zw, xTexelC${S}.xy);
                 `:p+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${S} = vec4(previous.zw, xTexelC${S}.xy);
                   } else {
                     xC${S} = vec4(0.0, 0.0, xTexelC${S}.xy);
                   }
                   `):p+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 xC${S} = xTexelC${S};
                 `,S+1<d)){const $=i%2===0?Jb(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(p+=`
                   xCOffset = xC + imod(pads[1], 2) + ${$};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                     xTexelC${S+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${S+1}.zw = vec2(0.0);
                     }
                     xTexelC${S+1}Ready = 1;
                   }
                   `,l>1?p+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${S+1} = vec4(previous.zw, xTexelC${S+1}.xy);
                     } else {
                      xC${S+1} = vec4(0.0, 0.0, xTexelC${S+1}.xy);
                     }
                     `:p+=`
                     xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.xy);
                     `):$===1?p+=`
                     xC${S+1} = xTexelC${S};
                     `:p+=`
                     xCOffset = xC + ${$};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                       xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${S+1}.zw = vec2(0.0);
                       }
                       xTexelC${S+1}Ready = 1;
                     }

                     xC${S+1} = xTexelC${S+1};
                     `}}else S<d&&(i%2===1?(p+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${S+1}Ready == 0) {
                   xTexelC${S+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${S+1}.zw = vec2(0.0);
                   }
                   xTexelC${S+1}Ready = 1;
                 }

                 xC${S} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
               `,S+1<d&&(p+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${S+1} = vec4(xTexelC${S+1}.xy, final.xy);
                 `)):(p+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                   xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S+1}.zw = vec2(0.);
                   }
                   xTexelC${S+1}Ready = 1;
                 }

                 xC${S} = vec4(
                   xTexelC${S}.xy, xTexelC${S+1}.xy);
               `,S+1<d&&(p+=`
                   xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
                 `)));S<d&&(p+=`
             wTexel = getW(r, ${S}, d1, d2);
             dotProd += xC${S}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${S}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,S+1<d&&(p+=`
               wTexel = getW(r, ${S+1}, d1, d2);
               dotProd += xC${S+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${S+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}p+=`
     }
   `,p+=`
     }
   `,p+=`
     }
   `;let g="",y="";r&&(s?g=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:o?g=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:g=`vec4 activation(vec4 x) {
           ${r}
         }`,y="result = activation(result);");const x=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${g}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${p}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${x}
         ${y}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kce{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=cr(this.outputShape.length);const{dataFormat:r}=n,s=Er(),o=r==="channelsLast",i=o?1:2,a=o?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let c="";for(let d=0;d<=1;d++)for(let f=0;f<=1;f++)c+=`
          blockIndex = rc.z + ${f};
          pos = rc.y + ${d};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${o}) {
                  innerDims = vec2(d1, ch);
                  result[${d*2+f}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${d*2+f}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${s.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ag(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&n===1&&t[0]>1?[t[0],1]:null}function KO({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const l=t.shape,c=r.texData.get(t.dataId),d=n.inChannels,f=l[0]*l[1]*l[2],p=n.outChannels,g=n.dataFormat==="channelsLast",y=!1,x=!1;let w;const S=[];if(o!=null){const R=Ag(o.shape,g);R!=null&&(o=Pe({inputs:{x:o},backend:r,attrs:{shape:R}}),S.push(o))}if(s!=null){const R=Ag(s.shape,g);R!=null&&(s=Pe({inputs:{x:s},backend:r,attrs:{shape:R}}),S.push(s))}if(!((f===1||p===1)&&d>BO)&&c.isPacked&&g&&c.texture!=null&&l[2]%2!==0&&Vt(c.shape.slice(-3),l.slice(-3))){const R=l[0]*l[1]*(l[2]+1),_={dataId:t.dataId,shape:[1,R,n.inChannels],dtype:t.dtype},O=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,z(Rg(c.shape,_.shape),()=>`packed reshape ${c.shape} to ${_.shape} isn't free`);const F=Pe({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});S.push(F);const B=Pg({a:_,b:F,backend:r,transposeA:y,transposeB:x,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),M=r.texData.get(B.dataId);z(M.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=O,M.shape=n.outShape,w=ms({inputs:{x:B},backend:r}),w.shape=n.outShape,S.push(B)}else{const R=n.outHeight*n.outWidth,_=Pe({inputs:{x:t},backend:r,attrs:{shape:g?[n.batchSize,R,n.inChannels]:[n.batchSize,n.inChannels,R]}}),O=Pe({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),F=Pg({a:g?_:O,b:g?O:_,transposeA:!g,transposeB:x,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i});w=Pe({inputs:{x:F},backend:r,attrs:{shape:n.outShape}}),S.push(_),S.push(O),S.push(F)}for(const R of S)r.disposeIntermediateTensorInfo(R);return w}function XO({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:d,outWidth:f,outHeight:p,dataFormat:g}=n,y=g==="channelsLast",x=l*c*d,w=p*f,S=[n.batchSize,x,w],$=!0,I=!1,R=[];if(o!=null){const fe=Ag(o.shape,y);fe!=null&&(o=Pe({inputs:{x:o},backend:r,attrs:{shape:fe}}),R.push(o))}if(s!=null){const fe=Ag(s.shape,y);fe!=null&&(s=Pe({inputs:{x:s},backend:r,attrs:{shape:fe}}),R.push(s))}const _=Pe({inputs:{x:e},backend:r,attrs:{shape:[1,x,pe(e.shape)/x]}});R.push(_);const O=new kce(S,n),F=[t.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],B=r.runWebGLProgram(O,[t],"float32",F),M=Pe({inputs:{x:B},backend:r,attrs:{shape:S}});R.push(B),R.push(M);const V=s!=null,P=o!=null,re=a==="leakyrelu",ie=a?If(a,!0):null,me=new zO(y?M.shape:_.shape,y?_.shape:M.shape,y?[n.batchSize,w,n.outChannels]:[n.batchSize,n.outChannels,w],$,I,V,ie,P,re),ge=y?[M,_]:[_,M];if(s&&ge.push(s),P&&ge.push(o),re){const fe=r.makeTensorInfo([],"float32",kd(i,"float32"));ge.push(fe),R.push(fe)}const ve=r.runWebGLProgram(me,ge,"float32"),$e=Pe({inputs:{x:ve},backend:r,attrs:{shape:n.outShape}});R.push(ve);for(const fe of R)r.disposeIntermediateTensorInfo(fe);return $e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tce(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dataFormat:l,dilations:c,dimRoundingMode:d}=r,f=Mo(l),p=kn(s.shape,o.shape,i,c,a,d,!1,f);let g;if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))g=KO({x:s,filter:o,convInfo:p,backend:n});else if(p.strideWidth<=2&&f==="channelsLast"&&se().getBool("WEBGL_EXP_CONV")){const x=new HO(p),w=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];g=n.runWebGLProgram(x,[s,o],"float32",w)}else if(se().getBool("WEBGL_CONV_IM2COL"))g=XO({x:s,filter:o,convInfo:p,backend:n});else{const x=new GO(p);g=n.runWebGLProgram(x,[s,o],"float32")}const y=Pe({inputs:{x:g},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(g),y}const Ice={kernelName:T2,backendName:"webgl",kernelFunc:Tce};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Nce=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,o=e.padInfo.left,i=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Ece=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,i=e.dataFormat==="channelsLast",a=n-1-e.padInfo.top,l=r-1-e.padInfo.left,c=i?1:2,d=i?2:3,f=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${f}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${d}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Rce=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideDepth,r=e.strideHeight,s=e.strideWidth,o=e.padInfo.front,i=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${n} - ${o};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${i};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${s} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},_ce=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterDepth,r=e.filterHeight,s=e.filterWidth,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,l=n-1-e.padInfo.front,c=r-1-e.padInfo.top,d=s-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${n}; wF++) {
          float dyF = float(dyFCorner + wF) / ${o}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${n} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${s}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pce(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:i,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:d}=r,f=Mo(l),p=kn(s.shape,d,i,1,a,c,!1,f),g=new Nce(p);return n.runWebGLProgram(g,[s,o],"float32")}const Ace={kernelName:I2,backendName:"webgl",kernelFunc:Pce};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dce{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=cr(this.outputShape.length);const n=e.filterHeight,r=e.filterWidth,s=n-1-e.padInfo.top,o=r-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oce(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{inputShape:i,strides:a,pad:l,dataFormat:c,dimRoundingMode:d}=r,f=Mo(c),p=kn(i,o.shape,a,1,l,d,!1,f);if(se().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&f==="channelsLast"){const g=[[p.strideHeight,p.strideWidth]],y=new Dce(p);return n.runWebGLProgram(y,[s,o],"float32",g)}else{const g=new Ece(p);return n.runWebGLProgram(g,[s,o],"float32")}}const Fce={kernelName:N2,backendName:"webgl",kernelFunc:Oce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lce(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dilations:l}=r,c=Tl(s.shape,o.shape,i,l,a),d=new $ce(c);return n.runWebGLProgram(d,[s,o],"float32")}const zce={kernelName:E2,backendName:"webgl",kernelFunc:Lce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bce(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:i,pad:a,filterShape:l}=r,c=Tl(s.shape,l,i,1,a),d=new Rce(c);return n.runWebGLProgram(d,[s,o],"float32")}const Mce={kernelName:QP,backendName:"webgl",kernelFunc:Bce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vce(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{pad:i,strides:a,inputShape:l}=r,c=Tl(l,o.shape,a,1,i),d=new _ce(c);return n.runWebGLProgram(d,[s,o],"float32")}const Wce={kernelName:R2,backendName:"webgl",kernelFunc:Vce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uce=Ad+`
  return cos(x);
`,jce=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${ju}
  return result;
`,Gce=$t({opSnippet:Uce,packedOpSnippet:jce}),Hce={kernelName:_2,backendName:"webgl",kernelFunc:Gce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kce=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Xce=$t({opSnippet:Kce}),qce={kernelName:P2,backendName:"webgl",kernelFunc:Xce};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Yce=class{constructor(e,n,r,s,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,l,c]=e,[d]=n,[f,p]=r;this.outputShape=[d,f,p,c];const g=s==="bilinear"?1:0,[y,x]=[`${a-1}.0`,`${l-1}.0`],[w,S,$]=f>1?[`${(a-1)/(f-1)}`,"(y2-y1) * height_ratio",`y1*${y} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${y}`],[I,R,_]=p>1?[`${(l-1)/(p-1)}`,"(x2-x1) * width_ratio",`x1*${x} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${x}`];this.userCode=`
      const float height_ratio = float(${w});
      const float width_ratio = float(${I});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${S};
        float width_scale = ${R};

        float in_y = ${$};
        if( in_y < 0.0 || in_y > ${y} ) {
          setOutput(float(${o}));
          return;
        }
        float in_x = ${_};
        if( in_x < 0.0 || in_x > ${x} ) {
          setOutput(float(${o}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${g} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qce=t=>{const{inputs:e,backend:n,attrs:r}=t,{image:s,boxes:o,boxInd:i}=e,{cropSize:a,method:l,extrapolationValue:c}=r,d=new Yce(s.shape,o.shape,a,l,c);return n.runWebGLProgram(d,[s,o,i],"float32")},Zce={kernelName:O2,backendName:"webgl",kernelFunc:Qce};var Ef;(function(t){t.Prod="*",t.Sum="+"})(Ef||(Ef={}));let oN=class{constructor(e,n,r,s){this.op=e,this.outputShape=n,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,i=this.op===Ef.Prod?"1.0":"0.0",a=r?i:`getX(${iN(o,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",d="";r?(c=s?`end != ${l-1}`:"end != 0",d=s?"end + 1":"end - 1"):(c=s?`end + pow2 < ${l}`:"end >= pow2",d=s?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Kt(o)} coords = getOutputCoords();
        int end = ${aN(o,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${d};
          ${aN(o,"coords",this.op)} = idx;
          val ${this.op}= getX(${iN(o,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function iN(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.x, ${e}.y`;if(t===3)return`${e}.x, ${e}.y, ${e}.z`;if(t===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function aN(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.y`;if(t===3)return`${e}.z`;if(t===4)return`${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qO(t,e,n,r,s,o){const i=e.shape.length,a=lr([r],i);let l=e;a!=null&&(l=Tr({inputs:{x:e},backend:n,attrs:{perm:a}}));const c=ur(1,i)[0];if(c!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const d=l.shape[c];let f=ms({inputs:{x:l},backend:n});for(let p=0;p<=Math.ceil(Math.log2(d))-1;p++){const g=new oN(t,l.shape,!1,o),y=[[p]],x=f;f=n.runWebGLProgram(g,[f],f.dtype,y),n.disposeIntermediateTensorInfo(x)}if(s){const p=new oN(t,l.shape,s,o),g=f;f=n.runWebGLProgram(p,[f],f.dtype),n.disposeIntermediateTensorInfo(g)}if(a!=null){const p=qf(a),g=Tr({inputs:{x:f},backend:n,attrs:{perm:p}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(l),g}return f}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jce(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,exclusive:i,reverse:a}=r;return qO(Ef.Prod,s,n,o,i,a)}const ede={kernelName:A2,backendName:"webgl",kernelFunc:Jce};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tde(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,exclusive:i,reverse:a}=r;return qO(Ef.Sum,s,n,o,i,a)}const nde={kernelName:D2,backendName:"webgl",kernelFunc:tde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rde(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:o}=e,{size:i,binaryOutput:a}=r;if(s.shape.length===1){const l=n.readSync(s.dataId),c=n.readSync(o.dataId),d=EO(l,c,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,d)}else if(s.shape.length===2){const l=n.bufferSync(s),c=n.bufferSync(o),d=aae(l,c,i,a);return n.makeTensorInfo(d.shape,o.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const sde={kernelName:F2,backendName:"webgl",kernelFunc:rde};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ode=class{constructor(e,n,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=n,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${n};
      int offset_h = imod(h, ${n});
      int in_w = w / ${n};
      int offset_w = imod(w, ${n});
      int offset_d = (offset_h * ${n} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ide(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockSize:o,dataFormat:i}=r,a=s.shape[0],l=i==="NHWC"?s.shape[1]:s.shape[2],c=i==="NHWC"?s.shape[2]:s.shape[3],d=i==="NHWC"?s.shape[3]:s.shape[1],f=l*o,p=c*o,g=d/(o*o),y=i==="NHWC"?[a,f,p,g]:[a,g,f,p],x=new ode(y,o,i);return n.runWebGLProgram(x,[s],s.dtype)}const ade={kernelName:L2,backendName:"webgl",kernelFunc:ide};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let YO=class{constructor(e,n=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=cr(this.outputShape.length);const i=e.filterHeight,a=e.filterWidth,l=e.outChannels/e.inChannels;let c="",d="";r&&(s?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:c=`
          float activation(float x) {
            ${r}
          }
        `,d="result = activation(result);");const f=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${f}
        ${d}
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QO{constructor(e,n=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=cr(this.outputShape.length);const i=e.outChannels/e.inChannels,a=e.padInfo.left,l=e.strideWidth,c=e.dilationWidth,d=e.filterHeight,f=e.filterWidth,p=f;let g=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let S=0;S<f;S++)g+=`
          vec4 xTexelC${S*2};
          int xTexelC${S*2}Ready;
          vec4 xTexelC${S*2+1};
          int xTexelC${S*2+1}Ready;
          vec4 xC${S};`;g+=`
    for (int r = 0; r < ${d}; r++) {
      `;for(let S=0;S<f;S++)g+=`
          xTexelC${S*2} = vec4(0.0);
          xTexelC${S*2}Ready = 0;
          xTexelC${S*2+1} = vec4(0.0);
          xTexelC${S*2+1}Ready = 0;
          xC${S} = vec4(0.0);`;g+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let S=0;S<(p+1)/2;S++){const $=S*2;if(g+=`
          xC = xCCorner + ${$*c};
          `,l===1){if($<f&&(a%2===1?(g+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }
              `,c===1&&$>0?g+=`
                xC${$} = vec4(xTexelC${$-2}.zw, xTexelC${$}.xy);
                `:g+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${$} = vec4(previous.zw, xTexelC${$}.xy);
                  } else {
                    xC${$} = vec4(0.0, 0.0, xTexelC${$}.xy);
                  }
                  `):g+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                xC${$} = xTexelC${$};
                `,$+1<f)){const I=a%2===0?Jb(c):c;c%2===0&&a%2===1||c%2!==0&&a%2!==1?(g+=`
                  xCOffset = xC + imod(pads[1], 2) + ${I};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                    xTexelC${$+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${$+1}.zw = vec2(0.0);
                    }
                    xTexelC${$+1}Ready = 1;
                  }
                  `,c>1?g+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${$+1} = vec4(previous.zw, xTexelC${$+1}.xy);
                    } else {
                     xC${$+1} = vec4(0.0, 0.0, xTexelC${$+1}.xy);
                    }
                    `:g+=`
                    xC${$+1} = vec4(xTexelC${$}.zw, xTexelC${$+1}.xy);
                    `):I===1?g+=`
                    xC${$+1} = xTexelC${$};
                    `:g+=`
                    xCOffset = xC + ${I};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                      xTexelC${$+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${$+1}.zw = vec2(0.0);
                      }
                      xTexelC${$+1}Ready = 1;
                    }

                    xC${$+1} = xTexelC${$+1};
                    `}}else $<f&&(a%2===1?(g+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${$+1}Ready == 0) {
                  xTexelC${$+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${$+1}.zw = vec2(0.0);
                  }
                  xTexelC${$+1}Ready = 1;
                }

                xC${$} = vec4(xTexelC${$}.zw, xTexelC${$+1}.zw);
              `,$+1<f&&(g+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${$+1} = vec4(xTexelC${$+1}.xy, final.xy);
                `)):(g+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                  xTexelC${$+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$+1}.zw = vec2(0.);
                  }
                  xTexelC${$+1}Ready = 1;
                }

                xC${$} = vec4(
                  xTexelC${$}.xy, xTexelC${$+1}.xy);
              `,$+1<f&&(g+=`
                  xC${$+1} = vec4(xTexelC${$}.zw, xTexelC${$+1}.zw);
                `)));$<f&&(g+=`
            wTexel = getW(r, ${$}, d1, q);
            dotProd += xC${$} * vec4(wTexel.xz, wTexel.xz);
          `,$+1<f&&(g+=`
              wTexel = getW(r, ${$+1}, d1, q);
              dotProd += xC${$+1} * vec4(wTexel.xz, wTexel.xz);
            `))}g+=`
    }
  `,g+=`
      }
    `;let y="",x="";r&&(s?y=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?y=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:y=`vec4 activation(vec4 x) {
          ${r}
        }`,x="result = activation(result);");const w=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${y}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${g}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${w}
        ${x}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lde(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dilations:l,dimRoundingMode:c}=r;let d=l;d==null&&(d=[1,1]),z(Nr(i,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);const f=kn(s.shape,o.shape,i,d,a,c,!0);let p;se().getBool("WEBGL_PACK_DEPTHWISECONV")&&f.strideWidth<=2&&f.outChannels/f.inChannels===1?p=new QO(f):p=new YO(f);const g=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];return n.runWebGLProgram(p,[s,o],"float32",g)}const ude={kernelName:z2,backendName:"webgl",kernelFunc:lde};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let cde=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,o=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},dde=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,i=n-1-e.padInfo.top,a=r-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hde(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:i,dilations:a,pad:l,dimRoundingMode:c,filterShape:d}=r,f=kn(s.shape,d,i,a,l,c,!0),p=new cde(f);return n.runWebGLProgram(p,[s,o],"float32")}const fde={kernelName:B2,backendName:"webgl",kernelFunc:hde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pde(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{strides:i,dilations:a,pad:l,dimRoundingMode:c,inputShape:d}=r,f=kn(d,o.shape,i,a,l,c,!0),p=new dde(f);return n.runWebGLProgram(p,[s,o],"float32")}const mde={kernelName:M2,backendName:"webgl",kernelFunc:pde};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let gde=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yde(t){const{inputs:e,backend:n}=t,{x:r}=e,s=[...r.shape,...r.shape],o=pe(r.shape),i=Pe({inputs:{x:r},backend:n,attrs:{shape:[o]}}),a=new gde(o),l=n.runWebGLProgram(a,[i],i.dtype),c=Pe({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),c}const xde={kernelName:V2,backendName:"webgl",kernelFunc:yde};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let vde=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:n,inWidth:r,padInfo:s,strideHeight:o,strideWidth:i,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:d}=e,{top:f,left:p}=s;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${i});
      const ivec2 pads = ivec2(${f}, ${p});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${n}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${d};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bde(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dilations:l}=r,c=Kf(s.shape,o.shape,i,a,"NHWC",l);let d;const f=new vde(c);d=n.runWebGLProgram(f,[s,o],"float32");const p=Pe({inputs:{x:d},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(d),p}const wde={kernelName:W2,backendName:"webgl",kernelFunc:bde};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sde(t){const{inputs:e,backend:n,attrs:r}=t,{equation:s}=r,o=e,{allDims:i,summedDims:a,idDims:l}=bC(s,o.length);SC(i.length,l,o);const{path:c,steps:d}=CC(a,l),f=d.length;let p=null,g=i.length;const y=[];for(let x=0;x<f;++x){for(const w of d[x]){const{permutationIndices:S,expandDims:$}=wC(g,l[w]);let I;$C(S)?I=o[w]:(I=Tr({inputs:{x:o[w]},backend:n,attrs:{perm:S}}),y.push(I));const R=I.shape.slice();for(let _=0;_<$.length;++_)R.splice($[_],0,1);Vt(I.shape,R)||(I=Pe({inputs:{x:I},backend:n,attrs:{shape:R}}),y.push(I)),p===null?p=I:(p=DC({inputs:{a:I,b:p},backend:n}),y.push(p))}x<f-1&&(c[x]>=0&&(p=Sy({inputs:{x:p},backend:n,attrs:{axis:c[x]-(i.length-g),keepDims:!1}}),y.push(p)),g--)}for(const x of y)x!==p&&n.disposeIntermediateTensorInfo(x);return p}const Cde={kernelName:j2,backendName:"webgl",kernelFunc:Sde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $de="return (x >= 0.0) ? x : (exp(x) - 1.0);",kde=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Tde=$t({opSnippet:$de,packedOpSnippet:kde}),Ide={kernelName:G2,backendName:"webgl",kernelFunc:Tde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nde="return (b >= 0.0) ? a : a * (b + 1.0);",Ede=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Rde=t=>{const{inputs:e,backend:n}=t,{dy:r,y:s}=e,o=se().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Pd(Ede,r.shape,s.shape):new Lu(Nde,r.shape,s.shape);return n.runWebGLProgram(o,[r,s],r.dtype)},_de={kernelName:JP,backendName:"webgl",kernelFunc:Rde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pde=`
  return vec4(equal(a, b));
`,Ade="return float(a == b);",Dde=Qn({opSnippet:Ade,packedOpSnippet:Pde,dtype:"bool",cpuKernelImpl:hae}),Ode={kernelName:K2,backendName:"webgl",kernelFunc:Dde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fde=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${pC};
  float a1 = ${mC};
  float a2 = ${gC};
  float a3 = ${yC};
  float a4 = ${xC};
  float a5 = ${vC};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Lde=$t({opSnippet:Fde}),zde={kernelName:H2,backendName:"webgl",kernelFunc:Lde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bde=Ad+`
  return exp(x);
`,Mde=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ZO=$t({opSnippet:Bde,packedOpSnippet:Mde,cpuKernelImpl:fae,dtype:"float32"}),Vde={kernelName:X2,backendName:"webgl",kernelFunc:ZO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cv(t){const{inputs:e,attrs:n,backend:r}=t,{dim:s}=n,{input:o}=e,i=o.shape.length,a=o.shape.slice();let l=s;return s<0&&(z(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),a.splice(l,0,1),Pe({inputs:{x:o},backend:r,attrs:{shape:a}})}const Wde={kernelName:q2,backendName:"webgl",kernelFunc:Cv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lN="return exp(x) - 1.0;",Ude=$t({opSnippet:lN,packedOpSnippet:lN,cpuKernelImpl:pae}),jde={kernelName:Y2,backendName:"webgl",kernelFunc:Ude};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let uN=class{constructor(e,n,r){this.variableNames=["real","imag"];const s=n[1];this.outputShape=n;const o=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${s}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${o};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JO(t,e,n){const r=n.texData.get(t.dataId),s=pe(t.shape),o=t.shape[t.shape.length-1],i=s/o,a=Pe({inputs:{x:t},backend:n,attrs:{shape:[i,o]}}),l=a.shape,c=new uN("real",l,e),d=new uN("imag",l,e),f=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],p=n.runWebGLProgram(c,f,"float32"),g=n.runWebGLProgram(d,f,"float32"),y=Il({inputs:{real:p,imag:g},backend:n});n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g);const x=Pe({inputs:{x:y},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(y),x}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gde(t){const{inputs:e,backend:n}=t,{input:r}=e;return JO(r,!1,n)}const Hde={kernelName:Q2,backendName:"webgl",kernelFunc:Gde};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Kde=class{constructor(e,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rp(t){const{backend:e,attrs:n}=t,{shape:r,value:s}=n;let{dtype:o}=n;if(o=o||$d(s),o==="string"){const i=En(o,pe(r));return i.fill(s),e.makeTensorInfo(r,o,i)}else{const i=new Kde(r,s),a=[[s]];return e.runWebGLProgram(i,[],o,a)}}const Xde={kernelName:Z2,backendName:"webgl",kernelFunc:rp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let qde=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];const n=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${n} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${n}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yde={kernelName:J2,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,r=e,s=new qde(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cN="return floor(x);",Qde=$t({opSnippet:cN,packedOpSnippet:cN,cpuKernelImpl:mae}),Zde={kernelName:ew,backendName:"webgl",kernelFunc:Qde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jde=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,ehe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,the=Qn({opSnippet:Jde,packedOpSnippet:ehe,dtype:"int32"}),nhe={kernelName:tw,backendName:"webgl",kernelFunc:the};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rhe=class{constructor(e){this.variableNames=["A"];const n=Er(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);

        vec4 values = ${n.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class she{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=Er(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${r}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ohe={kernelName:vg,backendName:"webgl",kernelFunc:ihe};let kc,tx=se().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function ihe(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:s}=e;const{numChannels:o}=r,i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,c]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],d=[c,l],f=[c,l,o];if(a||i){const x=se().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(kc==null||x!==tx)&&(tx=x,kc=document.createElement("canvas").getContext("2d",{willReadFrequently:tx})),kc.canvas.width=l,kc.canvas.height=c,kc.drawImage(s,0,0,l,c),s=kc.canvas}const p=n.makeTensorInfo(d,"int32");n.texData.get(p.dataId).usage=_s.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId),s);const g=se().getBool("WEBGL_PACK")?new she(f):new rhe(f),y=n.runWebGLProgram(g,[p],"int32");return n.disposeData(p.dataId),y}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ahe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:d,dilations:f,dimRoundingMode:p,activation:g,leakyreluAlpha:y}=r,x=Mo(d),w=kn(s.shape,o.shape,l,f,c,p,!1,x);let S;const $=[],I=i!=null,R=a!=null,_=g==="leakyrelu",O=()=>{const B=[s,o],M=(V,P)=>{if(P==="NCHW"&&V.shape.length===1&&V.shape[0]!==1){const re=Pe({inputs:{x:V},backend:n,attrs:{shape:[V.shape[0],1,1]}});return $.push(re),re}return V};if(I&&B.push(M(i,d)),R&&B.push(M(a,d)),_){const V=n.makeTensorInfo([],"float32",kd(y,"float32"));B.push(V),$.push(V)}return B};if(w.filterHeight===1&&w.filterWidth===1&&w.dilationHeight===1&&w.dilationWidth===1&&w.strideHeight===1&&w.strideWidth===1&&(w.padInfo.type==="SAME"||w.padInfo.type==="VALID"))S=KO({x:s,filter:o,convInfo:w,backend:n,bias:i,activation:g,preluActivationWeights:a,leakyreluAlpha:y});else if(w.strideWidth<=2&&x==="channelsLast"&&se().getBool("WEBGL_EXP_CONV")){const B=g?If(g,!0):null,M=new HO(w,I,B,R,_),V=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],P=O();S=n.runWebGLProgram(M,P,"float32",V)}else if(se().getBool("WEBGL_CONV_IM2COL"))S=XO({x:s,filter:o,convInfo:w,backend:n,bias:i,activation:g,preluActivationWeights:a,leakyreluAlpha:y});else{const B=g?If(g,!1):null,M=new GO(w,I,B,R,_),V=O();S=n.runWebGLProgram(M,V,"float32")}const F=Pe({inputs:{x:S},backend:n,attrs:{shape:w.outShape}});return $.push(S),$.forEach(B=>n.disposeIntermediateTensorInfo(B)),F}const lhe={kernelName:wg,backendName:"webgl",kernelFunc:ahe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uhe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=e,{strides:l,pad:c,dilations:d,dimRoundingMode:f,activation:p,leakyreluAlpha:g}=r,y=[];let x=d;x==null&&(x=[1,1]),z(Nr(l,x),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${x}'`);const w=kn(s.shape,o.shape,l,x,c,f,!0),S=se().getBool("WEBGL_PACK_DEPTHWISECONV")&&w.strideWidth<=2&&w.outChannels/w.inChannels===1,$=p?If(p,S):null,I=[s,o],R=i!=null,_=a!=null,O=p==="leakyrelu";if(R&&I.push(i),_&&I.push(a),O){const V=n.makeTensorInfo([],"float32",kd(g,"float32"));I.push(V),y.push(V)}let F;S?F=new QO(w,R,$,_,O):F=new YO(w,R,$,_,O);const B=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],M=n.runWebGLProgram(F,I,"float32",B);return y.forEach(V=>n.disposeIntermediateTensorInfo(V)),M}const che={kernelName:Sg,backendName:"webgl",kernelFunc:uhe};let dhe=class{constructor(e,n,r,s){this.sliceDim=e,this.strides=n,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const o=Kt(r.length);let i=`
    int index;`;for(let a=0;a<this.sliceDim;a++)i+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${o} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hhe(t){const{inputs:e,backend:n}=t,{params:r,indices:s}=e,o=s.shape,i=o[o.length-1],a=pe(r.shape),[l,c,d,f]=eC(r,s),p=Pe({inputs:{x:s},backend:n,attrs:{shape:[c,i]}}),g=Pe({inputs:{x:r},backend:n,attrs:{shape:[pe(r.shape)/d,d]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const S=n.readSync(s.dataId),$=n.bufferSync(r),I=gae(S,$,r.dtype,c,i,d,f,r.shape,a);return n.makeTensorInfo(l,r.dtype,I.values)}const y=new dhe(i,f,[c,d],r.shape),x=n.runWebGLProgram(y,[g,p],g.dtype),w=Pe({inputs:{x},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(x),w}const fhe={kernelName:sw,backendName:"webgl",kernelFunc:hhe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let phe=class{constructor(e,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;const r=Kt(this.rank),s=mhe(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${s}));
      }
    `}};function mhe(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<t.length;s++)s===2?r.push("index"):r.push(`${n[s]}`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eF(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,indices:o}=e,{axis:i,batchDims:a}=r,l=nn(i,s.shape)[0];if(se().get("DEBUG")){const $=n.readSync(o.dataId),I=s.shape[l];for(let R=0;R<$.length;++R){const _=$[R];z(_<=I-1&&_>=0,()=>`GatherV2: the index value ${_} is not in [0, ${I-1}]`)}}const c=IC(s,o,l,a),d=pe(o.shape),f=[],p=Pe({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),g=Pe({inputs:{x:o},backend:n,attrs:{shape:[c.batchSize,d/c.batchSize]}});f.push(p),f.push(g);const y=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([s,o])||s.dtype==="string"){const $=n.bufferSync(g),I=n.bufferSync(p),R=yae(I,$,y);return f.forEach(_=>n.disposeIntermediateTensorInfo(_)),n.makeTensorInfo(c.outputShape,R.dtype,R.values)}const x=new phe(p.shape,y),w=n.runWebGLProgram(x,[p,g],p.dtype);f.push(w);const S=Pe({inputs:{x:w},backend:n,attrs:{shape:c.outputShape}});return f.forEach($=>n.disposeIntermediateTensorInfo($)),S}const ghe={kernelName:rw,backendName:"webgl",kernelFunc:eF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yhe="return float(a > b);",xhe=`
  return vec4(greaterThan(a, b));
`,vhe=Qn({opSnippet:yhe,packedOpSnippet:xhe,cpuKernelImpl:xae,dtype:"bool"}),bhe={kernelName:ow,backendName:"webgl",kernelFunc:vhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const whe="return float(a >= b);",She=`
  return vec4(greaterThanEqual(a, b));
`,Che=Qn({opSnippet:whe,packedOpSnippet:She,dtype:"bool",cpuKernelImpl:vae}),$he={kernelName:iw,backendName:"webgl",kernelFunc:Che};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function khe(t){const{inputs:e,backend:n}=t,{input:r}=e;return JO(r,!0,n)}const The={kernelName:aw,backendName:"webgl",kernelFunc:khe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ihe="return float(!isnan(x) && !isinf(x));",Nhe=$t({opSnippet:Ihe,dtype:"bool"}),Ehe={kernelName:uw,backendName:"webgl",kernelFunc:Nhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rhe="return float(isinf(x));",_he=$t({opSnippet:Rhe,dtype:"bool"}),Phe={kernelName:cw,backendName:"webgl",kernelFunc:_he};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ahe="return float(isnan(x));",Dhe=$t({opSnippet:Ahe,dtype:"bool"}),Ohe={kernelName:dw,backendName:"webgl",kernelFunc:Dhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fhe="return float(a < b);",Lhe=`
  return vec4(lessThan(a, b));
`,zhe=Qn({opSnippet:Fhe,packedOpSnippet:Lhe,cpuKernelImpl:bae,dtype:"bool"}),Bhe={kernelName:fw,backendName:"webgl",kernelFunc:zhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mhe="return float(a <= b);",Vhe=`
  return vec4(lessThanEqual(a, b));
`,Whe=Qn({opSnippet:Mhe,packedOpSnippet:Vhe,cpuKernelImpl:wae,dtype:"bool"}),Uhe={kernelName:pw,backendName:"webgl",kernelFunc:Whe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jhe(t){const{backend:e,attrs:n}=t,{start:r,stop:s,num:o}=n,i=Sae(r,s,o);return e.makeTensorInfo([i.length],"float32",i)}const Ghe={kernelName:mw,backendName:"webgl",kernelFunc:jhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hhe=Ad+`
  return x < 0.0 ? 0./0. : log(x);
`,Khe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Xhe=$t({opSnippet:Hhe,packedOpSnippet:Khe,cpuKernelImpl:Cae}),qhe={kernelName:gw,backendName:"webgl",kernelFunc:Xhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yhe=Ad+`
  return log(1.0 + x);
`,Qhe=$t({opSnippet:Yhe}),Zhe={kernelName:yw,backendName:"webgl",kernelFunc:Qhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jhe="return float(a >= 1.0 && b >= 1.0);",efe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,tfe=Qn({opSnippet:Jhe,packedOpSnippet:efe,dtype:"bool"}),nfe={kernelName:xw,backendName:"webgl",kernelFunc:tfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rfe="return float(!(x >= 1.0));",sfe=$t({opSnippet:rfe}),ofe={kernelName:vw,backendName:"webgl",kernelFunc:sfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ife="return float(a >= 1.0 || b >= 1.0);",afe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,lfe=Qn({opSnippet:ife,packedOpSnippet:afe,dtype:"bool"}),ufe={kernelName:bw,backendName:"webgl",kernelFunc:lfe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let cfe=class{constructor(e,n,r,s,o){this.variableNames=["x"],this.outputShape=[];const i=n,a=e[3]-1;this.outputShape=e;let l;const c=`float(${r}) + float(${s}) * sum`;o===.5?l=`inversesqrt(${c})`:o===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dfe{constructor(e,n,r,s,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=n,a=e[3]-1;this.outputShape=e;let l;const c=`float(${r}) + float(${s}) * sum`;o===.5?l=`inversesqrt(${c})`:o===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hfe=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{depthRadius:o,bias:i,alpha:a,beta:l}=r,c=se().getBool("WEBGL_PACK_NORMALIZATION")?new dfe(s.shape,o,i,a,l):new cfe(s.shape,o,i,a,l);return n.runWebGLProgram(c,[s],s.dtype)},ffe={kernelName:ww,backendName:"webgl",kernelFunc:hfe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let pfe=class{constructor(e,n,r,s,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=n,this.bias=r,this.alpha=s,this.beta=o,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${n})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${n} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s})
                * float(${o})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${o});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mfe=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s,y:o,dy:i}=e,{depthRadius:a,bias:l,alpha:c,beta:d}=r,f=new pfe(s.shape,a,l,c,d);return n.runWebGLProgram(f,[s,o,i],s.dtype)},gfe={kernelName:eA,backendName:"webgl",kernelFunc:mfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yfe(t,e,n,r){const s=pe(e),i=pe(t.shape)/s,a=Pe({inputs:{x:t},attrs:{shape:[i,s]},backend:r}),l=Gu(a,t.dtype,"max",r),c=Pe({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tF(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reductionIndices:o,keepDims:i}=r,a=s.shape.length,l=nn(o,s.shape);let c=l;const d=lr(c,a),f=d!=null,p=n.shouldExecuteOnCPU([s]);let g=s;if(f){if(p){const I=n.texData.get(g.dataId).values,R=new Array(a);for(let F=0;F<R.length;F++)R[F]=s.shape[d[F]];const _=PC(I,s.shape,s.dtype,d,R);g=n.makeTensorInfo(R,s.dtype);const O=n.texData.get(g.dataId);O.values=_}else g=wy(s,d,n);c=ur(c.length,a)}vs("max",c,a);const[y,x]=Fs(g.shape,c);let w=y;i&&(w=xs(y,l));let S;if(p){const I=n.texData.get(g.dataId).values,R=$ae(I,pe(x),w,s.dtype);S=n.makeTensorInfo(w,s.dtype);const _=n.texData.get(S.dataId);_.values=R}else S=yfe(g,x,w,n);return f&&n.disposeIntermediateTensorInfo(g),S}const xfe={kernelName:Sw,backendName:"webgl",kernelFunc:tF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vfe=AC+`
  return max(a, b);
`,bfe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+ju+`
  return result;
`,wfe=Qn({opSnippet:vfe,packedOpSnippet:bfe,cpuKernelImpl:kae}),Sfe={kernelName:Cw,backendName:"webgl",kernelFunc:wfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cfe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;ep(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r,c=1;z(Nr(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const d=fo(s.shape,o,i,c,a,l);if(d.filterWidth===1&&d.filterHeight===1&&Vt(d.inShape,d.outShape))return ms({inputs:{x:s},backend:n});const f=new Nf(d,"max",!1);return n.runWebGLProgram(f,[s],s.dtype)}const $fe={kernelName:$w,backendName:"webgl",kernelFunc:Cfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kfe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:i,pad:a,dataFormat:l,dimRoundingMode:c}=r,d=[1,1,1],f=Sa(s.shape,o,i,d,a,c,l),p=new OC(f,"max",!1);return n.runWebGLProgram(p,[s],s.dtype)}const Tfe={kernelName:kw,backendName:"webgl",kernelFunc:kfe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ife=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,o=e.effectiveFilterHeight,i=e.effectiveFilterWidth,a=o-1-e.padInfo.top,l=i-1-e.padInfo.left,c=o*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
          wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},Nfe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideDepth,r=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,i=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterDepth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,f=l-1-e.padInfo.front,p=c-1-e.padInfo.top,g=d-1-e.padInfo.left,y=l*c*d-1;this.userCode=`
      const ivec3 pads = ivec3(${f}, ${p}, ${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${n}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${y} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${d} +
                  wR * ${d} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Efe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,i=o,{filterSize:a,strides:l,pad:c,dimRoundingMode:d}=r,f=[1,1,1],p=Sa(i.shape,a,l,f,c,d),g=new OC(p,"max",!0),y=n.runWebGLProgram(g,[i],i.dtype),x=new Nfe(p),w=n.runWebGLProgram(x,[s,y],i.dtype);return n.disposeIntermediateTensorInfo(y),w}const Rfe={kernelName:nA,backendName:"webgl",kernelFunc:Efe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _fe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o,output:i}=e,a=o;ep([o,i],"maxPoolGrad");const{filterSize:l,strides:c,pad:d,dimRoundingMode:f}=r,p=fo(a.shape,l,c,1,d,f),g=!0,y=new Nf(p,"max",g),x=n.runWebGLProgram(y,[a],a.dtype),w=new Ife(p),S=n.runWebGLProgram(w,[s,x],a.dtype);return n.disposeIntermediateTensorInfo(x),S}const Pfe={kernelName:tA,backendName:"webgl",kernelFunc:_fe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Afe(t,e,n,r){let s=new Nf(n,"max",!1);const o=r.runWebGLProgram(s,[t],"float32");s=new Nf(n,"max",!0,!0,e);const i=r.runWebGLProgram(s,[t],"float32");return[o,i]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dfe={kernelName:Tw,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=e,l=n;z(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const c=[1,1];z(Nr(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const d=fo(r.shape,s,o,c,i),[f,p]=Afe(r,a,d,l);return[f,p]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ofe(t,e,n,r){const s=pe(e),i=pe(t.shape)/s,a=Pe({inputs:{x:t},attrs:{shape:[i,s]},backend:r}),l=Gu(a,"float32","mean",r),c=Pe({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ffe={kernelName:Iw,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{keepDims:s,axis:o}=e,i=n,a=r.shape.length,l=nn(o,r.shape);let c=l;const d=lr(c,a),f=d!=null,p=i.shouldExecuteOnCPU([r]),g=[];let y=r;if(f){if(p){const R=i.texData.get(y.dataId).values,_=new Array(a);for(let B=0;B<_.length;B++)_[B]=r.shape[d[B]];const O=PC(R,r.shape,r.dtype,d,_);y=i.makeTensorInfo(_,r.dtype);const F=i.texData.get(y.dataId);F.values=O}else y=wy(r,d,i);g.push(y),c=ur(c.length,a)}vs("sum",c,a);const[x,w]=Fs(y.shape,c);let S=x;s&&(S=xs(x,l));const $=Ofe(y,w,S,i);for(const I of g)i.disposeIntermediateTensorInfo(I);return $}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lfe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,l=nn(o,s.shape);let c=l;const d=lr(c,a);let f=s;d!=null&&(f=Tr({inputs:{x:s},backend:n,attrs:{perm:d}}),c=ur(c.length,s.shape.length)),vs("min",c,a);const[p,g]=Fs(f.shape,c),y=pe(g),x=Pe({inputs:{x:f},backend:n,attrs:{shape:[-1,y]}}),w=Gu(x,x.dtype,"min",n);let S;if(i){const $=xs(p,l);S=Pe({inputs:{x:w},backend:n,attrs:{shape:$}})}else S=Pe({inputs:{x:w},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),d!=null&&n.disposeIntermediateTensorInfo(f),S}const zfe={kernelName:Nw,backendName:"webgl",kernelFunc:Lfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bfe=AC+`
  return min(a, b);
`,Mfe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+ju+`
  return result;
`,Vfe=Qn({opSnippet:Bfe,packedOpSnippet:Mfe,cpuKernelImpl:Tae}),Wfe={kernelName:Ew,backendName:"webgl",kernelFunc:Vfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ufe=class{constructor(e,n,r){this.variableNames=["x"],this.outputShape=n.map((d,f)=>d[0]+e[f]+d[1]);const s=e.length,o=Kt(s),i=n.map(d=>d[0]).join(","),a=n.map((d,f)=>d[0]+e[f]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),c=r==="reflect"?0:1;if(s===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${i});
      ${o} end = ${o}(${a});

      void main() {
        ${o} outC = getOutputCoords();
        for (int i = 0; i < ${s}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${o} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jfe{constructor(e,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((y,x)=>y[0]+e[x]+y[1]);const s=e.length,o=Kt(s),i=n.map(y=>y[0]).join(","),a=n.map((y,x)=>y[0]+e[x]).join(","),l=$r("rc",s),c=$r("source",s),d=`${l[s-1]} < ${this.outputShape[s-1]}`,f=s===1?"source":`vec2(${c.slice(-2).join()})`,p=r==="reflect"?0:1;let g="";if(s===1){const y=`
        ${o} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p};
        }
        source -= start;
      `;g=`
        ${o} rc = outputLoc;
        ${y}
        result[0] = getChannel(getX(${c.join()}), ${f});
        ${l[s-1]} += 1;
        if(${d}) {
          ${y}
          result[1] = getChannel(getX(${c.join()}), ${f});
        }
      `}else{const y=`
        ${o} source = rc;
        ${o} lt = ${o}(lessThan(source, start));
        ${o} gte = ${o}(greaterThanEqual(source, end));
        ${o} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p}) +
                gte * ((end - 1) * 2 - source + ${p});
        source -= start;
      `;g=`
        ${o} rc = outputLoc;
        ${y}
        result[0] = getChannel(getX(${c.join()}), ${f});
        ${l[s-1]} += 1;
        if(${d}) {
          ${y}
          result[1] = getChannel(getX(${c.join()}), ${f});
        }
        rc = outputLoc;
        ${l[s-2]} += 1;
        if(${l[s-2]} < ${this.outputShape[s-2]}) {
          ${y}
          result[2] = getChannel(getX(${c.join()}), ${f});
          ${l[s-1]} += 1;
          if(${d}) {
            ${y}
            result[3] = getChannel(getX(${c.join()}), ${f});
          }
        }
      `}this.userCode=`
      const ${o} start = ${o}(${i});
      const ${o} end = ${o}(${a});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gfe=({inputs:t,backend:e,attrs:n})=>{const{x:r}=t,{paddings:s,mode:o}=n,i=se().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new jfe(r.shape,s,o):new Ufe(r.shape,s,o);return e.runWebGLProgram(i,[r],r.dtype)},Hfe={kernelName:Rw,backendName:"webgl",kernelFunc:Gfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kfe=`if (b == 0.0) return NAN;
  return mod(a, b);`,Xfe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+ju+`
  return result;
`,qfe=Qn({opSnippet:Kfe,packedOpSnippet:Xfe}),Yfe={kernelName:_w,backendName:"webgl",kernelFunc:qfe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Qfe=class{constructor(e,n,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${n-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${n-1}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zfe=`
if (a == b) {
  return 1.0;
};
return a / b;`,Jfe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,nF=Qn({opSnippet:Zfe,packedOpSnippet:Jfe,checkOutOfBounds:!0}),epe={kernelName:U2,backendName:"webgl",kernelFunc:nF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dN="return a - b;",rF=Qn({opSnippet:dN,packedOpSnippet:dN,supportsComplex:!0,cpuKernelImpl:Kae}),tpe={kernelName:$S,backendName:"webgl",kernelFunc:rF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sF(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{dim:o}=r,i=nn([o],s.shape),a=tF({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=xs(a.shape,i),c=Pe({inputs:{x:a},backend:n,attrs:{shape:l}}),d=rF({inputs:{a:s,b:c},backend:n}),f=ZO({inputs:{x:d},backend:n}),p=Sy({inputs:{x:f},backend:n,attrs:{axis:i,keepDims:!1}}),g=Pe({inputs:{x:p},backend:n,attrs:{shape:l}}),y=nF({inputs:{a:f,b:g},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g),y}const npe={kernelName:yS,backendName:"webgl",kernelFunc:sF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rpe(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{numSamples:o,seed:i,normalized:a}=r,l=a?s:sF({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),c=l.shape[0],d=l.shape[1],f=new Qfe(c,d,o),p=[[i]],g=n.runWebGLProgram(f,[l],"int32",p);return a||n.disposeIntermediateTensorInfo(l),g}const spe={kernelName:Pw,backendName:"webgl",kernelFunc:rpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ope=mo+`
  return -x;
`,ipe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function ape(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])){const o=n.texData.get(r.dataId),[i,a]=Nae(o.values,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,i)}let s;return se().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new ul(r.shape,ipe):s=new fi(r.shape,ope),n.runWebGLProgram(s,[r],r.dtype)}const lpe={kernelName:Dw,backendName:"webgl",kernelFunc:ape};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const upe=XS;function cpe(t){Lo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r,c=n.readSync(s.dataId),d=n.readSync(o.dataId),{selectedIndices:f}=upe(c,d,i,a,l);return n.makeTensorInfo([f.length],"int32",new Int32Array(f))}const dpe={kernelName:Fw,backendName:"webgl",kernelFunc:cpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hpe=OD;function fpe(t){Lo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r,d=n.readSync(s.dataId),f=n.readSync(o.dataId),{selectedIndices:p,validOutputs:g}=hpe(d,f,i,a,l,c);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([g]))]}const ppe={kernelName:rA,backendName:"webgl",kernelFunc:fpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mpe=qS;function gpe(t){Lo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r,d=n.readSync(s.dataId),f=n.readSync(o.dataId),p=i,g=a,y=l,x=c,{selectedIndices:w,selectedScores:S}=mpe(d,f,p,g,y,x);return[n.makeTensorInfo([w.length],"int32",new Int32Array(w)),n.makeTensorInfo([S.length],"float32",new Float32Array(S))]}const ype={kernelName:Lw,backendName:"webgl",kernelFunc:gpe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let xpe=class{constructor(e,n,r,s){this.variableNames=["indices"],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s}), float(${r}),
                      float(index == coords.y)));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vpe=t=>{const{inputs:e,backend:n,attrs:r}=t,{indices:s}=e,{dtype:o,depth:i,onValue:a,offValue:l}=r,c=pe(s.shape),d=new xpe(c,i,a,l),f=Pe({inputs:{x:s},backend:n,attrs:{shape:[c]}}),p=n.runWebGLProgram(d,[f],o);n.disposeIntermediateTensorInfo(f);const g=[...s.shape,i],y=Pe({inputs:{x:p},backend:n,attrs:{shape:g}});return n.disposeIntermediateTensorInfo(p),y},bpe={kernelName:Bw,backendName:"webgl",kernelFunc:vpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dg(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="complex64"){const s=np({inputs:{input:r},backend:n}),o=Dg({inputs:{x:s},backend:n}),i=Cy({inputs:{input:r},backend:n}),a=Dg({inputs:{x:i},backend:n}),l=Il({inputs:{real:o,imag:a},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),l}else return rp({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}const wpe={kernelName:_S,backendName:"webgl",kernelFunc:Dg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oF(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=np({inputs:{input:r},backend:n}),o=oF({inputs:{x:s},backend:n}),i=Cy({inputs:{input:r},backend:n}),a=Dg({inputs:{x:i},backend:n}),l=Il({inputs:{real:o,imag:a},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),l}else return rp({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}const Spe={kernelName:zw,backendName:"webgl",kernelFunc:oF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cpe(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r;if(e.length===1)return Cv({inputs:{input:e[0]},backend:n,attrs:{dim:s}});const o=e[0].shape,i=e[0].dtype;e.forEach(d=>{ys(o,d.shape,"All tensors passed to stack must have matching shapes"),z(i===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(d=>{const f=Cv({inputs:{input:d},backend:n,attrs:{dim:s}});return a.push(f),f}),c=jO({inputs:l,backend:n,attrs:{axis:s}});return a.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}const $pe={kernelName:Mw,backendName:"webgl",kernelFunc:Cpe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let kpe=class{constructor(e,n,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((c,d)=>c[0]+e[d]+c[1]);const s=e.length,o=Kt(s),i=n.map(c=>c[0]).join(","),a=n.map((c,d)=>c[0]+e[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${i});
      ${o} end = ${o}(${a});

      void main() {
        ${o} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${o} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tpe{constructor(e,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((x,w)=>x[0]+e[w]+x[1]);const s=e.length,o=Kt(s),i=n.map(x=>x[0]).join(","),a=n.map((x,w)=>x[0]+e[w]).join(","),l=$r("rc",s),c=$r("source",s),d=`${l[s-1]} < ${this.outputShape[s-1]}`,f=s===1?"source":`vec2(${c.slice(-2).join()})`,p=[`${o} rc = outputLoc;`,`${l[s-1]} += 1;
       if(${d}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${l[s-2]} += 1;
       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${l[s-1]} += 1;
         if(${d}) {`],g=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let y="";for(let x=0,w=s===1?2:4;x<w;x++)y+=`
        ${p[x]}
        if (${g}) {
          result[${x}] = float(value);
        } else {
          ${o} source = rc - start;
          result[${x}] = getChannel(getX(${c.join()}), ${f});
        }
      `;y+=s===1?"} ":"}}",this.userCode=`
      const ${o} start = ${o}(${i});
      const ${o} end = ${o}(${a});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${y}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iF=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{paddings:o,constantValue:i}=r;if(pe(s.shape)===0){const c=o.map((d,f)=>d[0]+s.shape[f]+d[1]);return rp({backend:n,attrs:{shape:c,value:i,dtype:s.dtype}})}const a=se().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Tpe(s.shape,o,i):new kpe(s.shape,o,i),l=[[i]];return n.runWebGLProgram(a,[s],s.dtype,l)},Ipe={kernelName:Vw,backendName:"webgl",kernelFunc:iF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Npe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Epe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+ju+`
  return result;
`,Rpe=Qn({opSnippet:Npe,packedOpSnippet:Epe}),_pe={kernelName:Ww,backendName:"webgl",kernelFunc:Rpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ppe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,l=[],c=nn(o,s.shape);let d=c;const f=lr(d,a);let p=s;f!=null&&(p=Tr({inputs:{x:s},backend:n,attrs:{perm:f}}),d=ur(d.length,a),l.push(p)),vs("prod",d,a);let g;if(n.shouldExecuteOnCPU([p])){const y=n.texData.get(p.dataId).values,{outVals:x,outShape:w,outDtype:S}=Rae(p.shape,p.dtype,y,d);g=n.makeTensorInfo(w,S,x)}else{const[y,x]=Fs(p.shape,d),w=pe(x),S=Pe({inputs:{x:p},backend:n,attrs:{shape:[-1,w]}}),$=ay(s.dtype),I=Gu(S,$,"prod",n);g=Pe({inputs:{x:I},backend:n,attrs:{shape:y}}),l.push(S),l.push(I)}if(i){l.push(g);const y=xs(g.shape,c);g=Pe({inputs:{x:g},backend:n,attrs:{shape:y}})}return l.forEach(y=>n.disposeIntermediateTensorInfo(y)),g}const Ape={kernelName:jw,backendName:"webgl",kernelFunc:Ppe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dpe(t){const{inputs:e,backend:n,attrs:r}=t,{paramsNestedSplits:s,paramsDenseValues:o,indices:i}=e,{outputRaggedRank:a}=r,l=s.map(S=>n.readSync(S.dataId)),c=s.map(S=>S.shape),d=n.readSync(o.dataId),f=n.readSync(i.dataId),[p,g,y]=_ae(l,c,d,o.shape,o.dtype,f,i.shape,a),x=p.map(S=>n.makeTensorInfo([S.length],"int32",S)),w=n.makeTensorInfo(y,o.dtype,g);return x.concat([w])}const Ope={kernelName:sA,backendName:"webgl",kernelFunc:Dpe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fpe(t){const{inputs:e,backend:n}=t,{starts:r,limits:s,deltas:o}=e,i=n.readSync(r.dataId),a=n.readSync(s.dataId),l=n.readSync(o.dataId),[c,d]=Pae(i,r.shape,r.dtype,a,s.shape,l,o.shape),f=n.makeTensorInfo([c.length],"int32",c),p=n.makeTensorInfo([d.length],r.dtype,d);return[f,p]}const Lpe={kernelName:oA,backendName:"webgl",kernelFunc:Fpe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zpe(t){const{inputs:e,backend:n,attrs:r}=t,{shape:s,values:o,defaultValue:i,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=r,c=n.readSync(s.dataId),d=n.readSync(o.dataId),f=n.readSync(i.dataId),p=a.map(w=>n.readSync(w.dataId)),g=a.map(w=>w.shape),[y,x]=Aae(c,s.shape,d,o.shape,o.dtype,f,i.shape,p,g,l);return n.makeTensorInfo(y,o.dtype,x)}const Bpe={kernelName:iA,backendName:"webgl",kernelFunc:zpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aF=t=>{const{backend:e,attrs:n}=t,{start:r,stop:s,step:o,dtype:i}=n,a=Dae(r,s,o,i);return e.makeTensorInfo([a.length],i,a)},Mpe={kernelName:Gw,backendName:"webgl",kernelFunc:aF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vpe="return 1.0 / x;",Wpe=$t({opSnippet:Vpe}),Upe={kernelName:Kw,backendName:"webgl",kernelFunc:Wpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jpe=mo+`
  return (x < 0.0) ? 0.0 : x;
`,Gpe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Hpe=$t({opSnippet:jpe,packedOpSnippet:Gpe}),Kpe={kernelName:Xw,backendName:"webgl",kernelFunc:Hpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xpe=mo+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,qpe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Ype=$t({opSnippet:Xpe,packedOpSnippet:qpe}),Qpe={kernelName:Zw,backendName:"webgl",kernelFunc:Ype};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Zpe=class{constructor(e,n,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,c]=e;this.outputShape=[i,n,r,c];const d=[s&&n>1?a-1:a,s&&r>1?l-1:l],f=[s&&n>1?n-1:n,s&&r>1?r-1:r];let p;o?p="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/f[0]},
          ${d[1]/f[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jpe{constructor(e,n,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,c]=e;this.outputShape=[i,n,r,c];const d=[s&&n>1?a-1:a,s&&r>1?l-1:l],f=[s&&n>1?n-1:n,s&&r>1?r-1:r];let p;o?p="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/f[0]},
          ${d[1]/f[1]},
          ${d[1]/f[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eme(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,c]=a,d=se().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Jpe(s.shape,l,c,o,i):new Zpe(s.shape,l,c,o,i);return n.runWebGLProgram(d,[s],"float32")}const tme={kernelName:Qw,backendName:"webgl",kernelFunc:eme};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nme=class{constructor(e,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,s,o]=n,[,i,a]=e,l=[r&&i>1?s-1:s,r&&a>1?o-1:o],c=[r&&i>1?i-1:i,r&&a>1?a-1:a],d=l[0]/c[0],f=l[1]/c[1],p=1/d,g=1/f,y=Math.ceil(p)*2+2,x=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${f});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${g});

        const int winHeight = int(${y});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rme(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:o}=e,{alignCorners:i}=r,a=new nme(o.shape,s.shape,i);return n.runWebGLProgram(a,[o],o.dtype)}const sme={kernelName:lA,backendName:"webgl",kernelFunc:rme};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ome=class{constructor(e,n,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,c]=e;this.outputShape=[i,n,r,c];const d=[s&&n>1?a-1:a,s&&r>1?l-1:l],f=[s&&n>1?n-1:n,s&&r>1?r-1:r],p=s?"0.5":"0.0";let g;o?g="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":g="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/f[0]},
          ${d[1]/f[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${g};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ime{constructor(e,n,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,c]=e;this.outputShape=[i,n,r,c];const d=[s&&n>1?a-1:a,s&&r>1?l-1:l],f=[s&&n>1?n-1:n,s&&r>1?r-1:r],p=s?"0.5":"0.0";let g;o?g="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":g="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/f[0]},
          ${d[1]/f[1]},
          ${d[1]/f[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${g};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ame(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,c]=a,d=se().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ime(s.shape,l,c,o,i):new ome(s.shape,l,c,o,i);return n.runWebGLProgram(d,[s],s.dtype)}const lme={kernelName:Yw,backendName:"webgl",kernelFunc:ame};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ume=class{constructor(e,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,s,o]=n,[,i,a]=e,l=[r&&i>1?s-1:s,r&&a>1?o-1:o],c=[r&&i>1?i-1:i,r&&a>1?a-1:a],d=l[0]/c[0],f=l[1]/c[1],p=1/d,g=1/f,y=Math.ceil(p)*2+2,x=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${f});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${g});

        const int winHeight = int(${y});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${o}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cme(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:o}=e,{alignCorners:i}=r,a=new ume(o.shape,s.shape,i);return n.runWebGLProgram(a,[o],o.dtype)}const dme={kernelName:aA,backendName:"webgl",kernelFunc:cme};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let hme=class{constructor(e,n){this.variableNames=["x"];const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=e,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const s=a=>n.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,o=e.map((a,l)=>s(l)).join(","),i=Kt(r);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fme{constructor(e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=e;const s=$r("rc",r),o=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=Kt(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${o}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(s.slice())};
          if(${o}){
            result.g = ${c(s.slice())};
          }
          if(${i}) {
            result.b = ${d(s.slice())};
            if(${o}) {
              result.a = ${f(s.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(y){return p(y)}function c(y){return y[r-1]="("+y[r-1]+" + 1)",p(y)}function d(y){return y[r-2]="("+y[r-2]+" + 1)",p(y)}function f(y){return y[r-1]="("+y[r-1]+" + 1)",y[r-2]="("+y[r-2]+" + 1)",p(y)}function p(y){const x=e.map(($,I)=>g(I,y)),w=x.join(","),S=x.slice(-2).join(",");return`getChannel(getX(${w}), vec2(${S}))`}function g(y,x){return n.indexOf(y)!==-1&&e[y]!==1?`${e[y]} - ${x[y]} - 1`:`${x[y]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pme(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dims:o}=r,i=s.shape.length,a=nn(o,s.shape);if(i===0)return ms({inputs:{x:s},backend:n});const l=se().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new fme(s.shape,a):new hme(s.shape,a);return n.runWebGLProgram(l,[s],s.dtype)}const mme={kernelName:Jw,backendName:"webgl",kernelFunc:pme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let gme=class{constructor(e,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=e[1],s=e[2];this.outputShape=e;let o="";typeof n=="number"?o=`float outputValue = ${n.toFixed(2)};`:o=`
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${o}
          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yme={kernelName:AS,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:s,fillValue:o,center:i}=e,a=n,l=new gme(r.shape,o),[c,d]=uC(i,r.shape[1],r.shape[2]),f=[[c,d,Math.sin(s),Math.cos(s)]];return a.runWebGLProgram(l,[r],r.dtype,f)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xme=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,vme=$t({opSnippet:xme}),bme={kernelName:eS,backendName:"webgl",kernelFunc:vme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wme="return inversesqrt(x);",Sme=$t({opSnippet:wme,cpuKernelImpl:Oae}),Cme={kernelName:tS,backendName:"webgl",kernelFunc:Sme};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let FC=class{constructor(e,n,r,s,o,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const c=Kt(o.length),d=Kt(i.length);let f="";r===1?f="i":r===2&&(f="i, j");const p=`getIndices(${f})`;let g="";s===1?g="i":s===2&&(g="i, coords[1]");const y=`getUpdates(${g})`;let x="";l&&(x="coords[0], coords[1]");const w=`getDefaultValue(${x})`,S=n>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${o});

        void main() {
          ${d} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${n}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${S};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${y};
              found = true;
            }
          }
          setOutput(mix(${w}, sum, float(found)));
        }
      `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $me{constructor(e,n,r,s,o,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const c=Kt(o.length),d=Kt(i.length);let f="";r===1?f="i":r===2&&(f="i, j");const p=`getIndices(${f})`;let g="";s===1?g="i":s===2&&(g="i, coords[1]");const y=`getUpdates(${g})`;let x="";l&&(x="coords[0], coords[1]");const w=`getDefaultValue(${x})`,S=n>1?"strides[j]":"strides",$=n>1?"strides[j + 1]":"strides";this.userCode=`
        ${c} strides = ${c}(${o});

        void main() {
          ${d} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${n}; j+=2) {
              ivec4 index = round(${p});
              flattenedIndex += index.xz * ${S};
              if (j + 1 < ${n}) {
                flattenedIndex += index.yw * ${$};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${y};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${w}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kme(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s,updates:o}=e,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:d,outputSize:f}=Bu(o,s,i),p=[f/c,c];if(f===0)return n.makeTensorInfo(i,s.dtype);const g=Pe({inputs:{x:s},backend:n,attrs:{shape:[l,a]}}),y=Pe({inputs:{x:o},backend:n,attrs:{shape:[l,c]}}),x=n.makeTensorInfo([],"float32",new Float32Array([0]));let w;se().getBool("WEBGL_PACK")?w=new $me(l,a,g.shape.length,y.shape.length,d,p):w=new FC(l,a,g.shape.length,y.shape.length,d,p);const S=n.runWebGLProgram(w,[y,g,x],y.dtype),$=Pe({inputs:{x:S},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(S),n.disposeIntermediateTensorInfo(x),$}const Tme={kernelName:nS,backendName:"webgl",kernelFunc:kme};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ime=class{constructor(e,n,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,r];const o="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(n+1))}; ++i) { if (left >= right) break;`,a=se().getNumber("WEBGL_VERSION")===2?o:i,l=s==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nme(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:s,values:o}=e,{side:i}=r,a=new Ime(s.shape[0],s.shape[1],o.shape[1],i),l=[[s.shape[1]]];return n.runWebGLProgram(a,[s,o],"int32",l)}const Eme={kernelName:sS,backendName:"webgl",kernelFunc:Nme};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Rme=class{constructor(e,n,r){this.variableNames=["c","a","b"],this.outputShape=n;let s,o;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)o="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let d=0;d<n.length;d++)c.push(`${a[d]}`),d<e&&l.push(`${a[d]}`);s=l.join(),o=c.join()}const i=Kt(r);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${s});
        if (cVal >= 1.0) {
          setOutput(getA(${o}));
        } else {
          setOutput(getB(${o}));
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _me(t){const{inputs:e,backend:n}=t,{condition:r,t:s,e:o}=e,i=new Rme(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,o],jr(s.dtype,o.dtype))}const Pme={kernelName:oS,backendName:"webgl",kernelFunc:_me};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ame=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${hC};
  float scale = ${fC};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Dme=$t({opSnippet:Ame}),Ome={kernelName:iS,backendName:"webgl",kernelFunc:Dme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fme=Ad+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Lme=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,zme=$t({opSnippet:Fme,packedOpSnippet:Lme,cpuKernelImpl:Lae}),Bme={kernelName:dS,backendName:"webgl",kernelFunc:zme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mme=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Vme=$t({opSnippet:Mme}),Wme={kernelName:cS,backendName:"webgl",kernelFunc:Vme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ume=Ad+`
  return sin(x);
`,jme=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${ju}
  return result;
`,Gme=$t({opSnippet:Ume,packedOpSnippet:jme}),Hme={kernelName:lS,backendName:"webgl",kernelFunc:Gme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kme=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Xme=$t({opSnippet:Kme}),qme={kernelName:uS,backendName:"webgl",kernelFunc:Xme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yme=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Qme=$t({opSnippet:Yme}),Zme={kernelName:hS,backendName:"webgl",kernelFunc:Qme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jme=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:o,paddings:i}=r;z(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((S,$)=>S*$),l=[[0,0]];l.push(...i);for(let S=1+o.length;S<s.shape.length;++S)l.push([0,0]);const c=[],d=iF({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),f=Yf(d.shape,o,a,!1),p=Qf(f.length,o.length,!1),g=Zf(d.shape,o,a,!1),y=Pe({inputs:{x:d},backend:n,attrs:{shape:f}}),x=Tr({inputs:{x:y},backend:n,attrs:{perm:p}}),w=Pe({inputs:{x},backend:n,attrs:{shape:g}});return c.push(d),c.push(y),c.push(x),c.forEach(S=>n.disposeIntermediateTensorInfo(S)),w},ege={kernelName:mS,backendName:"webgl",kernelFunc:Jme};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tge(t){const{inputs:e,backend:n}=t,{indices:r,values:s,denseShape:o,defaultValue:i}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${o.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const a=n.readSync(r.dataId),l=n.readSync(s.dataId),c=n.readSync(o.dataId),d=n.readSync(i.dataId)[0],[f,p,g,y,x]=Bae(a,r.shape,r.dtype,l,s.dtype,c,d);return[n.makeTensorInfo(p,r.dtype,f),n.makeTensorInfo([p[0]],s.dtype,g),n.makeTensorInfo([y.length],"bool",new Uint8Array(y.map(w=>Number(w)))),n.makeTensorInfo([x.length],r.dtype,new Int32Array(x))]}const nge={kernelName:uA,backendName:"webgl",kernelFunc:tge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rge(t){const{inputs:e,backend:n}=t,{inputIndices:r,inputShape:s,newShape:o}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(n.readSync(s.dataId)),a=n.readSync(r.dataId),l=Array.from(n.readSync(o.dataId)),[c,d,f]=Mae(a,r.shape,r.dtype,i,l);return[n.makeTensorInfo(d,r.dtype,c),n.makeTensorInfo([f.length],o.dtype,new Int32Array(f))]}const sge={kernelName:cA,backendName:"webgl",kernelFunc:rge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oge(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:o}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${o.shape}`);const i=n.readSync(r.dataId),a=n.readSync(s.dataId),l=n.readSync(o.dataId),[c,d]=_O(i,r.shape,r.dtype,a,l,!0);return n.makeTensorInfo(d,r.dtype,c)}const ige={kernelName:xS,backendName:"webgl",kernelFunc:oge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function age(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:o}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${o.shape}`);const i=n.readSync(r.dataId),a=n.readSync(s.dataId),l=n.readSync(o.dataId),[c,d]=_O(i,r.shape,r.dtype,a,l);return n.makeTensorInfo(d,r.dtype,c)}const lge={kernelName:vS,backendName:"webgl",kernelFunc:age};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uge(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:s,sparseValues:o,defaultValue:i}=e,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:d,strides:f,outputSize:p}=Bu(o,s,a),g=!1;if(o.dtype==="string"){const S=n.bufferSync(s),$=n.bufferSync(o),I=fa(n.readSync(i.dataId)[0]),R=Fae(S,$,a,p,d,c,l,f,I,g);return n.makeTensorInfo(a,R.dtype,R.values)}const y=new FC(c,l,s.shape.length,o.shape.length,f,[p,1],g),x=n.runWebGLProgram(y,[o,s,i],o.dtype),w=Pe({inputs:{x},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(x),w}const cge={kernelName:bS,backendName:"webgl",kernelFunc:uge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dge(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{numOrSizeSplits:o,axis:i}=r,a=nn(i,s.shape)[0],l=kC(s,o,a),c=s.shape.length,d=new Array(c).fill(0),f=s.shape.slice();return l.map(p=>{const g=[...f];g[a]=p;const y=Dd({inputs:{x:s},backend:n,attrs:{begin:d,size:g}});return d[a]+=p,y})}const hge={kernelName:gS,backendName:"webgl",kernelFunc:dge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hN="return sqrt(x);",fge=$t({opSnippet:hN,packedOpSnippet:hN,cpuKernelImpl:Vae}),pge={kernelName:fS,backendName:"webgl",kernelFunc:fge};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mge="return x * x;",gge=$t({opSnippet:mge}),yge={kernelName:dA,backendName:"webgl",kernelFunc:gge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fN="return (a - b) * (a - b);",xge=Qn({opSnippet:fN,packedOpSnippet:fN}),vge={kernelName:wS,backendName:"webgl",kernelFunc:xge};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bge(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");const o=n.readSync(s.dataId),i=bl(o),a=Wae(i,"string",r);return n.makeTensorInfo(s.shape,"string",a)}const wge={kernelName:hA,backendName:"webgl",kernelFunc:bge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sge({inputs:t,attrs:e,backend:n}){const{x:r}=t,s=mo+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,o=new fi(r.shape,s);return n.runWebGLProgram(o,[r],r.dtype)}const Cge={kernelName:PS,backendName:"webgl",kernelFunc:Sge};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let $ge=class{constructor(e,n,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,o=Kt(r.length),i=Kt(r.length);let a="";if(s===1)a="coords * strides + begin";else{let l=0;a=r.map((c,d)=>(l++,r.length===1?`coords * strides[${d}] + begin[${d}]`:`coords[${l-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`
      ${o} begin = ${o}(${e});
      ${o} strides = ${o}(${n});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kge(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:o,end:i,strides:a,beginMask:l,endMask:c,ellipsisMask:d,newAxisMask:f,shrinkAxisMask:p}=r,{finalShapeSparse:g,finalShape:y,isIdentity:x,sliceDim0:w,isSimpleSlice:S,begin:$,end:I,strides:R}=iC(s.shape,o,i,a,l,c,d,f,p);let _;if(x)_=Pe({inputs:{x:s},backend:n,attrs:{shape:y}});else if(w||S){z(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const F=nC($,I,R),B=Dd({inputs:{x:s},backend:n,attrs:{begin:$,size:F}});_=Pe({inputs:{x:B},backend:n,attrs:{shape:y}}),n.disposeIntermediateTensorInfo(B)}else if(n.shouldExecuteOnCPU([s])){const B=n.readSync(s.dataId),M=Wt(s.shape,s.dtype,B),V=Uae(g,M,R,$);_=n.makeTensorInfo(y,s.dtype,V.values)}else{const B=new $ge($,R,g);_=n.runWebGLProgram(B,[s],s.dtype)}const O=Pe({inputs:{x:_},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(_),O}const Tge={kernelName:SS,backendName:"webgl",kernelFunc:kge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ige(t){const{inputs:e,backend:n,attrs:r}=t,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:d,dataSplits:f}=e,p=n.readSync(d.dataId),g=n.readSync(f.dataId),[y,x]=jae(p,g,s,o,i,a,l,c);return[n.makeTensorInfo([y.length],"string",y),n.makeTensorInfo(f.shape,"int32",x)]}const Nge={kernelName:CS,backendName:"webgl",kernelFunc:Ige};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ege(t){const{inputs:e,backend:n,attrs:r}=t,{skipEmpty:s}=r,{input:o,delimiter:i}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=n.readSync(o.dataId),l=n.readSync(i.dataId)[0],[c,d,f]=Gae(a,l,s),p=d.length;return[n.makeTensorInfo([p,2],"int32",c),n.makeTensorInfo([p],"string",d),n.makeTensorInfo([2],"int32",new Int32Array(f))]}const Rge={kernelName:fA,backendName:"webgl",kernelFunc:Ege};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ge(t){const{inputs:e,backend:n,attrs:r}=t,{numBuckets:s}=r,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(o.dataId),a=Hae(i,s);return n.makeTensorInfo(o.shape,"int32",a)}const Pge={kernelName:pA,backendName:"webgl",kernelFunc:_ge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Age="return tan(x);",Dge=$t({opSnippet:Age}),Oge={kernelName:kS,backendName:"webgl",kernelFunc:Dge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fge=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,Lge=$t({opSnippet:Fge}),zge={kernelName:TS,backendName:"webgl",kernelFunc:Lge};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bge(t){const{inputs:e,backend:n,attrs:r}=t,{tensor:s,indices:o,updates:i}=e,{sliceRank:a,numUpdates:l,sliceSize:c,strides:d,outputSize:f}=Bu(i,o,s.shape),p=[f/c,c];if(f===0)return n.makeTensorInfo(s.shape,o.dtype);const g=Pe({inputs:{x:o},backend:n,attrs:{shape:[l,a]}}),y=Pe({inputs:{x:i},backend:n,attrs:{shape:[l,c]}}),x=Pe({inputs:{x:s},backend:n,attrs:{shape:p}}),w=new FC(l,a,g.shape.length,y.shape.length,d,p,!1,!0),S=n.runWebGLProgram(w,[y,g,x],x.dtype),$=Pe({inputs:{x:S},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(S),$}const Mge={kernelName:rS,backendName:"webgl",kernelFunc:Bge};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Vge=class{constructor(e,n){this.variableNames=["A"];const r=new Array(e.length);for(let i=0;i<r.length;i++)r[i]=e[i]*n[i];this.outputShape=r,this.rank=r.length;const s=Kt(this.rank),o=Wge(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}};function Wge(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<t.length;s++)r.push(`imod(${n[s]}, ${t[s]})`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lF(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reps:o}=r;if(s.dtype==="string"||s.shape.length>5){const l=n.readSync(s.dataId),c=s.dtype==="string"?l.map(p=>fa(p)):l,d=Wt(s.shape,s.dtype,c),f=Xae(d,o);return n.makeTensorInfo(f.shape,f.dtype,f.values)}const i=new Vge(s.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}const Uge={kernelName:sy,backendName:"webgl",kernelFunc:lF};let jge=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},Gge=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ou(t,e){e!==null&&t.disposeIntermediateTensorInfo(e)}function pN(t){let e=1;for(;e<t;)e*=2;return e}function Hge(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{k:o,sorted:i}=r,a=se().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=se().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=s.shape,d=c[c.length-1];if(n.shouldExecuteOnCPU([s])||d<a||o>l){const V=n.readSync(s.dataId),[P,re]=qae(V,c,s.dtype,o,i);return[n.makeTensorInfo(P.shape,P.dtype,P.values),n.makeTensorInfo(re.shape,re.dtype,re.values)]}if(o===0)return c[c.length-1]=0,[n.makeTensorInfo(c,s.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(d===1)return[s,rp({attrs:{shape:c,dtype:"int32",value:0},backend:n})];const f=n.texData.get(s.dataId),p=f!==null&&f.isPacked,g=p?n.unpackTensor(s):s,x=pe(c)/d,w=Pe({inputs:{x:g},attrs:{shape:[x,d]},backend:n});p&&ou(n,g);const S=pN(o),$=pN(d);let I=null;const R=()=>I===null?[w,w]:[w,I],_=(V,P,re)=>{const ie=R(),me=new jge(re),ve=[[d],[I===null?1:0],[Number.NEGATIVE_INFINITY],[V],[P]],$e=I;I=n.runWebGLProgram(me,ie,"int32",ve),ou(n,$e)};for(let V=1;V<S;V*=2){const P=V*2;for(let re=V;re>=1;re/=2)_(P,re,[x,$])}for(let V=$;V>S;V/=2){const P=R(),re=new Gge([x,V/2]),me=[[d],[I===null?1:0],[S]],ge=I;I=n.runWebGLProgram(re,P,"int32",me),ou(n,ge);const ve=S/2,$e=ve*2;for(let fe=ve;fe>=1;fe/=2)_($e,fe,I.shape)}let O=I;I=Dd({inputs:{x:I},backend:n,attrs:{begin:0,size:[x,o]}}),ou(n,O);let F=eF({inputs:{x:w,indices:I},backend:n,attrs:{axis:1,batchDims:1}});ou(n,w);const B=c.slice(0,-1);B.push(o),O=I,I=Pe({inputs:{x:I},attrs:{shape:B},backend:n}),ou(n,O);const M=F;return F=Pe({inputs:{x:F},attrs:{shape:B},backend:n}),ou(n,M),[F,I]}const Kge={kernelName:IS,backendName:"webgl",kernelFunc:Hge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Xge=class{constructor(e,n,r,s,o,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a=r==="nearest"?1:2;let l;switch(s){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${n}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${o});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${o});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${n}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qge(t){const{inputs:e,backend:n,attrs:r}=t,{image:s,transforms:o}=e,{interpolation:i,fillMode:a,fillValue:l,outputShape:c}=r,[d,f,p,g]=s.shape,[y,x]=c??[f,p],w=[d,y,x,g],S=new Xge(f,p,i,a,l,w);return n.runWebGLProgram(S,[s,o],"float32")}const Yge={kernelName:NS,backendName:"webgl",kernelFunc:qge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qge(t){const{inputs:e,attrs:n,backend:r}=t,{axis:s}=n,{x:o}=e;ep(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(o.dataId),{outputValues:a,outputShape:l,indices:c}=Yae(i,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}const Zge={kernelName:mA,backendName:"webgl",kernelFunc:Qge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jge(t){const{inputs:e,backend:n,attrs:r}=t,{value:s}=e;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s,a=i.shape.length,l=s.shape[o],c=new Array(a-1);let d=0;for(let x=0;x<a;x++)x!==o&&(c[d++]=i.shape[x]);const f=[],p=new Array(a).fill(0),g=i.shape.slice();g[o]=1;const y=new Array(l);for(let x=0;x<y.length;x++){p[o]=x;const w=Dd({inputs:{x:i},backend:n,attrs:{begin:p,size:g}}),S=Pe({inputs:{x:w},backend:n,attrs:{shape:c}});y[x]=S,f.push(w)}return f.forEach(x=>n.disposeIntermediateTensorInfo(x)),y}const eye={kernelName:ES,backendName:"webgl",kernelFunc:Jge};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tye{constructor(e,n){this.variableNames=["x","segmentIds"];const r=e.windowSize,s=e.batchSize,o=e.inSize,i=e.numSegments,a=i*Math.ceil(o/r);this.outputShape=[s,a];const l="0.0",c="sumValue",d=Math.floor(r/4)*4,f=r%4,p=`
        sumValue += dot(values, segFilter);
    `;let g="";o%r>0&&(g=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `);let y="";o%r>0&&(y=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${g}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${y}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${p}
        }

        int inIdx = inOffset + ${d};
        if (${f===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${p}
        } else if (${f===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${p}
        } else if (${f===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${p}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nye(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,segmentIds:o}=e,{numSegments:i}=r,a=s.shape.length,l=[];let c=0;const d=lr([c],a);let f=s;d!=null&&(f=Tr({inputs:{x:s},backend:n,attrs:{perm:d}}),l.push(f),c=ur(1,a)[0]);const p=TC(f.shape,c,i),g=pe([f.shape[c]]),y=Pe({inputs:{x:f},backend:n,attrs:{shape:[-1,g]}});l.push(y);const x=ay(s.dtype),w=(R,_,O,F,B)=>{const M=R.shape[0],V=R.shape[1],P=fO(V,B),re={windowSize:P,inSize:V,batchSize:M,numSegments:B},ie=new tye(re,_),me=n.compileAndRun(ie,[R,O],F);if(l.push(me),me.shape[1]===B)return me;const ge=aF({backend:n,attrs:{start:0,stop:B,step:1,dtype:"float32"}}),ve=lF({inputs:{x:ge},backend:n,attrs:{reps:[V/P]}});return l.push(ge),l.push(ve),w(me,_,ve,F,B)},S=w(y,"unsortedSegmentSum",o,x,i),$=Pe({inputs:{x:S},backend:n,attrs:{shape:p}});let I=$;if(d!=null){l.push($);const R=qf(d);I=Tr({inputs:{x:I},backend:n,attrs:{perm:R}})}return l.forEach(R=>n.disposeIntermediateTensorInfo(R)),I}const rye={kernelName:RS,backendName:"webgl",kernelFunc:nye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sye=[Vle,Ule,Hle,qle,Qle,eue,nue,sue,lue,cue,fue,gue,vue,Cue,Tue,Nue,Rue,Due,Fue,zue,Wue,que,Que,tce,rce,uce,dce,mce,$le,xce,Cce,Ice,Ace,Fce,zce,Mce,Wce,Hce,qce,Zce,ede,nde,sde,ade,ude,fde,mde,xde,wde,Cde,Ide,_de,Ode,zde,Vde,Wde,jde,Hde,Xde,Yde,Zde,nhe,ohe,lhe,che,fhe,ghe,bhe,$he,Cle,The,wce,Ehe,Phe,Ohe,Tle,Bhe,Uhe,Ghe,qhe,Zhe,nfe,ofe,ufe,ffe,gfe,xfe,Sfe,$fe,Tfe,Rfe,Pfe,Dfe,Ffe,zfe,Wfe,Hfe,Yfe,spe,Ele,lpe,dpe,ppe,ype,oce,bpe,Spe,$pe,Ipe,_pe,Nle,Ape,Ope,Lpe,Bpe,Mpe,ice,epe,Upe,Kpe,Qpe,_le,tme,sme,lme,dme,mme,yme,bme,Cme,Tme,Eme,Pme,Ome,Bme,Wme,Hme,qme,Kue,npe,Zme,ege,nge,sge,ige,lge,cge,hge,pge,yge,vge,wge,Cge,Tge,Nge,Rge,Pge,tpe,zle,Oge,zge,Mge,Uge,Kge,Yge,Ble,Zge,eye,rye,wpe];for(const t of sye)gA(t);var nx={},mN;function oye(){return mN||(mN=1,(function(){var t;function e(v){var k=0;return function(){return k<v.length?{done:!1,value:v[k++]}:{done:!0}}}var n=typeof Object.defineProperties=="function"?Object.defineProperty:function(v,k,E){return v==Array.prototype||v==Object.prototype||(v[k]=E.value),v};function r(v){v=[typeof globalThis=="object"&&globalThis,v,typeof window=="object"&&window,typeof self=="object"&&self,typeof Pc=="object"&&Pc];for(var k=0;k<v.length;++k){var E=v[k];if(E&&E.Math==Math)return E}throw Error("Cannot find global object")}var s=r(this);function o(v,k){if(k)e:{var E=s;v=v.split(".");for(var A=0;A<v.length-1;A++){var W=v[A];if(!(W in E))break e;E=E[W]}v=v[v.length-1],A=E[v],k=k(A),k!=A&&k!=null&&n(E,v,{configurable:!0,writable:!0,value:k})}}o("Symbol",function(v){function k(G){if(this instanceof k)throw new TypeError("Symbol is not a constructor");return new E(A+(G||"")+"_"+W++,G)}function E(G,j){this.h=G,n(this,"description",{configurable:!0,writable:!0,value:j})}if(v)return v;E.prototype.toString=function(){return this.h};var A="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",W=0;return k}),o("Symbol.iterator",function(v){if(v)return v;v=Symbol("Symbol.iterator");for(var k="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),E=0;E<k.length;E++){var A=s[k[E]];typeof A=="function"&&typeof A.prototype[v]!="function"&&n(A.prototype,v,{configurable:!0,writable:!0,value:function(){return i(e(this))}})}return v});function i(v){return v={next:v},v[Symbol.iterator]=function(){return this},v}function a(v){var k=typeof Symbol<"u"&&Symbol.iterator&&v[Symbol.iterator];return k?k.call(v):{next:e(v)}}function l(v){if(!(v instanceof Array)){v=a(v);for(var k,E=[];!(k=v.next()).done;)E.push(k.value);v=E}return v}var c=typeof Object.assign=="function"?Object.assign:function(v,k){for(var E=1;E<arguments.length;E++){var A=arguments[E];if(A)for(var W in A)Object.prototype.hasOwnProperty.call(A,W)&&(v[W]=A[W])}return v};o("Object.assign",function(v){return v||c});var d=typeof Object.create=="function"?Object.create:function(v){function k(){}return k.prototype=v,new k},f;if(typeof Object.setPrototypeOf=="function")f=Object.setPrototypeOf;else{var p;e:{var g={a:!0},y={};try{y.__proto__=g,p=y.a;break e}catch{}p=!1}f=p?function(v,k){if(v.__proto__=k,v.__proto__!==k)throw new TypeError(v+" is not extensible");return v}:null}var x=f;function w(v,k){if(v.prototype=d(k.prototype),v.prototype.constructor=v,x)x(v,k);else for(var E in k)if(E!="prototype")if(Object.defineProperties){var A=Object.getOwnPropertyDescriptor(k,E);A&&Object.defineProperty(v,E,A)}else v[E]=k[E];v.za=k.prototype}function S(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function $(v){if(v.m)throw new TypeError("Generator is already running");v.m=!0}S.prototype.u=function(v){this.i=v};function I(v,k){v.l={ma:k,na:!0},v.h=v.s||v.v}S.prototype.return=function(v){this.l={return:v},this.h=this.v};function R(v,k,E){return v.h=E,{value:k}}function _(v){this.h=new S,this.i=v}function O(v,k){$(v.h);var E=v.h.j;return E?F(v,"return"in E?E.return:function(A){return{value:A,done:!0}},k,v.h.return):(v.h.return(k),B(v))}function F(v,k,E,A){try{var W=k.call(v.h.j,E);if(!(W instanceof Object))throw new TypeError("Iterator result "+W+" is not an object");if(!W.done)return v.h.m=!1,W;var G=W.value}catch(j){return v.h.j=null,I(v.h,j),B(v)}return v.h.j=null,A.call(v.h,G),B(v)}function B(v){for(;v.h.h;)try{var k=v.i(v.h);if(k)return v.h.m=!1,{value:k.value,done:!1}}catch(E){v.h.i=void 0,I(v.h,E)}if(v.h.m=!1,v.h.l){if(k=v.h.l,v.h.l=null,k.na)throw k.ma;return{value:k.return,done:!0}}return{value:void 0,done:!0}}function M(v){this.next=function(k){return $(v.h),v.h.j?k=F(v,v.h.j.next,k,v.h.u):(v.h.u(k),k=B(v)),k},this.throw=function(k){return $(v.h),v.h.j?k=F(v,v.h.j.throw,k,v.h.u):(I(v.h,k),k=B(v)),k},this.return=function(k){return O(v,k)},this[Symbol.iterator]=function(){return this}}function V(v){function k(A){return v.next(A)}function E(A){return v.throw(A)}return new Promise(function(A,W){function G(j){j.done?A(j.value):Promise.resolve(j.value).then(k,E).then(G,W)}G(v.next())})}function P(v){return V(new M(new _(v)))}o("Promise",function(v){function k(j){this.i=0,this.j=void 0,this.h=[],this.u=!1;var Z=this.l();try{j(Z.resolve,Z.reject)}catch(ce){Z.reject(ce)}}function E(){this.h=null}function A(j){return j instanceof k?j:new k(function(Z){Z(j)})}if(v)return v;E.prototype.i=function(j){if(this.h==null){this.h=[];var Z=this;this.j(function(){Z.m()})}this.h.push(j)};var W=s.setTimeout;E.prototype.j=function(j){W(j,0)},E.prototype.m=function(){for(;this.h&&this.h.length;){var j=this.h;this.h=[];for(var Z=0;Z<j.length;++Z){var ce=j[Z];j[Z]=null;try{ce()}catch(Ce){this.l(Ce)}}}this.h=null},E.prototype.l=function(j){this.j(function(){throw j})},k.prototype.l=function(){function j(Ce){return function(_e){ce||(ce=!0,Ce.call(Z,_e))}}var Z=this,ce=!1;return{resolve:j(this.I),reject:j(this.m)}},k.prototype.I=function(j){if(j===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(j instanceof k)this.L(j);else{e:switch(typeof j){case"object":var Z=j!=null;break e;case"function":Z=!0;break e;default:Z=!1}Z?this.F(j):this.s(j)}},k.prototype.F=function(j){var Z=void 0;try{Z=j.then}catch(ce){this.m(ce);return}typeof Z=="function"?this.M(Z,j):this.s(j)},k.prototype.m=function(j){this.v(2,j)},k.prototype.s=function(j){this.v(1,j)},k.prototype.v=function(j,Z){if(this.i!=0)throw Error("Cannot settle("+j+", "+Z+"): Promise already settled in state"+this.i);this.i=j,this.j=Z,this.i===2&&this.K(),this.H()},k.prototype.K=function(){var j=this;W(function(){if(j.D()){var Z=s.console;typeof Z<"u"&&Z.error(j.j)}},1)},k.prototype.D=function(){if(this.u)return!1;var j=s.CustomEvent,Z=s.Event,ce=s.dispatchEvent;return typeof ce>"u"?!0:(typeof j=="function"?j=new j("unhandledrejection",{cancelable:!0}):typeof Z=="function"?j=new Z("unhandledrejection",{cancelable:!0}):(j=s.document.createEvent("CustomEvent"),j.initCustomEvent("unhandledrejection",!1,!0,j)),j.promise=this,j.reason=this.j,ce(j))},k.prototype.H=function(){if(this.h!=null){for(var j=0;j<this.h.length;++j)G.i(this.h[j]);this.h=null}};var G=new E;return k.prototype.L=function(j){var Z=this.l();j.T(Z.resolve,Z.reject)},k.prototype.M=function(j,Z){var ce=this.l();try{j.call(Z,ce.resolve,ce.reject)}catch(Ce){ce.reject(Ce)}},k.prototype.then=function(j,Z){function ce(He,Ae){return typeof He=="function"?function(Ke){try{Ce(He(Ke))}catch(ft){_e(ft)}}:Ae}var Ce,_e,Ze=new k(function(He,Ae){Ce=He,_e=Ae});return this.T(ce(j,Ce),ce(Z,_e)),Ze},k.prototype.catch=function(j){return this.then(void 0,j)},k.prototype.T=function(j,Z){function ce(){switch(Ce.i){case 1:j(Ce.j);break;case 2:Z(Ce.j);break;default:throw Error("Unexpected state: "+Ce.i)}}var Ce=this;this.h==null?G.i(ce):this.h.push(ce),this.u=!0},k.resolve=A,k.reject=function(j){return new k(function(Z,ce){ce(j)})},k.race=function(j){return new k(function(Z,ce){for(var Ce=a(j),_e=Ce.next();!_e.done;_e=Ce.next())A(_e.value).T(Z,ce)})},k.all=function(j){var Z=a(j),ce=Z.next();return ce.done?A([]):new k(function(Ce,_e){function Ze(Ke){return function(ft){He[Ke]=ft,Ae--,Ae==0&&Ce(He)}}var He=[],Ae=0;do He.push(void 0),Ae++,A(ce.value).T(Ze(He.length-1),_e),ce=Z.next();while(!ce.done)})},k});function re(v,k){v instanceof String&&(v+="");var E=0,A=!1,W={next:function(){if(!A&&E<v.length){var G=E++;return{value:k(G,v[G]),done:!1}}return A=!0,{done:!0,value:void 0}}};return W[Symbol.iterator]=function(){return W},W}o("Array.prototype.keys",function(v){return v||function(){return re(this,function(k){return k})}}),o("Array.prototype.fill",function(v){return v||function(k,E,A){var W=this.length||0;for(0>E&&(E=Math.max(0,W+E)),(A==null||A>W)&&(A=W),A=Number(A),0>A&&(A=Math.max(0,W+A)),E=Number(E||0);E<A;E++)this[E]=k;return this}});function ie(v){return v||Array.prototype.fill}o("Int8Array.prototype.fill",ie),o("Uint8Array.prototype.fill",ie),o("Uint8ClampedArray.prototype.fill",ie),o("Int16Array.prototype.fill",ie),o("Uint16Array.prototype.fill",ie),o("Int32Array.prototype.fill",ie),o("Uint32Array.prototype.fill",ie),o("Float32Array.prototype.fill",ie),o("Float64Array.prototype.fill",ie),o("Object.is",function(v){return v||function(k,E){return k===E?k!==0||1/k===1/E:k!==k&&E!==E}}),o("Array.prototype.includes",function(v){return v||function(k,E){var A=this;A instanceof String&&(A=String(A));var W=A.length;for(E=E||0,0>E&&(E=Math.max(E+W,0));E<W;E++){var G=A[E];if(G===k||Object.is(G,k))return!0}return!1}}),o("String.prototype.includes",function(v){return v||function(k,E){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(k instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(k,E||0)!==-1}});var me=this||self;function ge(v,k){v=v.split(".");var E=me;v[0]in E||typeof E.execScript>"u"||E.execScript("var "+v[0]);for(var A;v.length&&(A=v.shift());)v.length||k===void 0?E[A]&&E[A]!==Object.prototype[A]?E=E[A]:E=E[A]={}:E[A]=k}function ve(v){var k;e:{if((k=me.navigator)&&(k=k.userAgent))break e;k=""}return k.indexOf(v)!=-1}var $e=Array.prototype.map?function(v,k){return Array.prototype.map.call(v,k,void 0)}:function(v,k){for(var E=v.length,A=Array(E),W=typeof v=="string"?v.split(""):v,G=0;G<E;G++)G in W&&(A[G]=k.call(void 0,W[G],G,v));return A},fe={},xe=null;function ae(v){var k=v.length,E=3*k/4;E%3?E=Math.floor(E):"=.".indexOf(v[k-1])!=-1&&(E="=.".indexOf(v[k-2])!=-1?E-2:E-1);var A=new Uint8Array(E),W=0;return q(v,function(G){A[W++]=G}),W!==E?A.subarray(0,W):A}function q(v,k){function E(ce){for(;A<v.length;){var Ce=v.charAt(A++),_e=xe[Ce];if(_e!=null)return _e;if(!/^[\s\xa0]*$/.test(Ce))throw Error("Unknown base64 encoding at char: "+Ce)}return ce}ue();for(var A=0;;){var W=E(-1),G=E(0),j=E(64),Z=E(64);if(Z===64&&W===-1)break;k(W<<2|G>>4),j!=64&&(k(G<<4&240|j>>2),Z!=64&&k(j<<6&192|Z))}}function ue(){if(!xe){xe={};for(var v="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),k=["+/=","+/","-_=","-_.","-_"],E=0;5>E;E++){var A=v.concat(k[E].split(""));fe[E]=A;for(var W=0;W<A.length;W++){var G=A[W];xe[G]===void 0&&(xe[G]=W)}}}}var we=typeof Uint8Array<"u",Ge=!(ve("Trident")||ve("MSIE"))&&typeof me.btoa=="function";function et(v){if(!Ge){var k;k===void 0&&(k=0),ue(),k=fe[k];for(var E=Array(Math.floor(v.length/3)),A=k[64]||"",W=0,G=0;W<v.length-2;W+=3){var j=v[W],Z=v[W+1],ce=v[W+2],Ce=k[j>>2];j=k[(j&3)<<4|Z>>4],Z=k[(Z&15)<<2|ce>>6],ce=k[ce&63],E[G++]=Ce+j+Z+ce}switch(Ce=0,ce=A,v.length-W){case 2:Ce=v[W+1],ce=k[(Ce&15)<<2]||A;case 1:v=v[W],E[G]=k[v>>2]+k[(v&3)<<4|Ce>>4]+ce+A}return E.join("")}for(k="";10240<v.length;)k+=String.fromCharCode.apply(null,v.subarray(0,10240)),v=v.subarray(10240);return k+=String.fromCharCode.apply(null,v),btoa(k)}var tt=RegExp("[-_.]","g");function Tt(v){switch(v){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function dt(v){if(!Ge)return ae(v);tt.test(v)&&(v=v.replace(tt,Tt)),v=atob(v);for(var k=new Uint8Array(v.length),E=0;E<v.length;E++)k[E]=v.charCodeAt(E);return k}var vt;function rn(){return vt||(vt=new Uint8Array(0))}var Rr={},ki=typeof Uint8Array.prototype.slice=="function",zt=0,sn=0;function _r(v){var k=0>v;v=Math.abs(v);var E=v>>>0;v=Math.floor((v-E)/4294967296),k&&(E=a(Ia(E,v)),k=E.next().value,v=E.next().value,E=k),zt=E>>>0,sn=v>>>0}var Vo=typeof BigInt=="function";function Ia(v,k){return k=~k,v?v=~v+1:k+=1,[v,k]}function El(v,k){this.i=v>>>0,this.h=k>>>0}function Na(v){if(!v)return bs||(bs=new El(0,0));if(!/^-?\d+$/.test(v))return null;if(16>v.length)_r(Number(v));else if(Vo)v=BigInt(v),zt=Number(v&BigInt(4294967295))>>>0,sn=Number(v>>BigInt(32)&BigInt(4294967295));else{var k=+(v[0]==="-");sn=zt=0;for(var E=v.length,A=k,W=(E-k)%6+k;W<=E;A=W,W+=6)A=Number(v.slice(A,W)),sn*=1e6,zt=1e6*zt+A,4294967296<=zt&&(sn+=zt/4294967296|0,zt%=4294967296);k&&(k=a(Ia(zt,sn)),v=k.next().value,k=k.next().value,zt=v,sn=k)}return new El(zt,sn)}var bs;function ws(v,k){return Error("Invalid wire type: "+v+" (at position "+k+")")}function zs(){return Error("Failed to read varint, encoding is invalid.")}function Xr(v,k){return Error("Tried to read past the end of the data "+k+" > "+v)}function Ss(){throw Error("Invalid UTF8")}function Ea(v,k){return k=String.fromCharCode.apply(null,k),v==null?k:v+k}var Ti=void 0,Ii,go=typeof TextDecoder<"u",Ra,Wo=typeof TextEncoder<"u",yo;function Rl(v){if(v!==Rr)throw Error("illegal external caller")}function Uo(v,k){if(Rl(k),this.V=v,v!=null&&v.length===0)throw Error("ByteString should be constructed with non-empty values")}function _a(){return yo||(yo=new Uo(null,Rr))}function Bs(v){Rl(Rr);var k=v.V;return k=k==null||we&&k!=null&&k instanceof Uint8Array?k:typeof k=="string"?dt(k):null,k==null?k:v.V=k}function jo(v){if(typeof v=="string")return{buffer:dt(v),C:!1};if(Array.isArray(v))return{buffer:new Uint8Array(v),C:!1};if(v.constructor===Uint8Array)return{buffer:v,C:!1};if(v.constructor===ArrayBuffer)return{buffer:new Uint8Array(v),C:!1};if(v.constructor===Uo)return{buffer:Bs(v)||rn(),C:!0};if(v instanceof Uint8Array)return{buffer:new Uint8Array(v.buffer,v.byteOffset,v.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function Pa(v,k){this.i=null,this.m=!1,this.h=this.j=this.l=0,Go(this,v,k)}function Go(v,k,E){E=E===void 0?{}:E,v.S=E.S===void 0?!1:E.S,k&&(k=jo(k),v.i=k.buffer,v.m=k.C,v.l=0,v.j=v.i.length,v.h=v.l)}Pa.prototype.reset=function(){this.h=this.l};function Cs(v,k){if(v.h=k,k>v.j)throw Xr(v.j,k)}function Ms(v){var k=v.i,E=v.h,A=k[E++],W=A&127;if(A&128&&(A=k[E++],W|=(A&127)<<7,A&128&&(A=k[E++],W|=(A&127)<<14,A&128&&(A=k[E++],W|=(A&127)<<21,A&128&&(A=k[E++],W|=A<<28,A&128&&k[E++]&128&&k[E++]&128&&k[E++]&128&&k[E++]&128&&k[E++]&128)))))throw zs();return Cs(v,E),W}function Pr(v,k){if(0>k)throw Error("Tried to read a negative byte length: "+k);var E=v.h,A=E+k;if(A>v.j)throw Xr(k,v.j-E);return v.h=A,E}var xo=[];function qr(){this.h=[]}qr.prototype.length=function(){return this.h.length},qr.prototype.end=function(){var v=this.h;return this.h=[],v};function _l(v,k,E){for(;0<E||127<k;)v.h.push(k&127|128),k=(k>>>7|E<<25)>>>0,E>>>=7;v.h.push(k)}function Vs(v,k){for(;127<k;)v.h.push(k&127|128),k>>>=7;v.h.push(k)}function Aa(v,k){if(xo.length){var E=xo.pop();Go(E,v,k),v=E}else v=new Pa(v,k);this.h=v,this.j=this.h.h,this.i=this.l=-1,this.setOptions(k)}Aa.prototype.setOptions=function(v){v=v===void 0?{}:v,this.ca=v.ca===void 0?!1:v.ca},Aa.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};function Pl(v){var k=v.h;if(k.h==k.j)return!1;v.j=v.h.h;var E=Ms(v.h)>>>0;if(k=E>>>3,E&=7,!(0<=E&&5>=E))throw ws(E,v.j);if(1>k)throw Error("Invalid field number: "+k+" (at position "+v.j+")");return v.l=k,v.i=E,!0}function Ho(v){switch(v.i){case 0:if(v.i!=0)Ho(v);else e:{v=v.h;for(var k=v.h,E=k+10,A=v.i;k<E;)if((A[k++]&128)===0){Cs(v,k);break e}throw zs()}break;case 1:v=v.h,Cs(v,v.h+8);break;case 2:v.i!=2?Ho(v):(k=Ms(v.h)>>>0,v=v.h,Cs(v,v.h+k));break;case 5:v=v.h,Cs(v,v.h+4);break;case 3:k=v.l;do{if(!Pl(v))throw Error("Unmatched start-group tag: stream EOF");if(v.i==4){if(v.l!=k)throw Error("Unmatched end-group tag");break}Ho(v)}while(!0);break;default:throw ws(v.i,v.j)}}var Jn=[];function Ni(){this.j=[],this.i=0,this.h=new qr}function Ws(v,k){k.length!==0&&(v.j.push(k),v.i+=k.length)}function Ei(v,k){if(k=k.R){Ws(v,v.h.end());for(var E=0;E<k.length;E++)Ws(v,Bs(k[E])||rn())}}var $s=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol():void 0;function Ar(v,k){return $s?v[$s]|=k:v.A!==void 0?v.A|=k:(Object.defineProperties(v,{A:{value:k,configurable:!0,writable:!0,enumerable:!1}}),k)}function Yr(v,k){$s?v[$s]&&(v[$s]&=~k):v.A!==void 0&&(v.A&=~k)}function Xt(v){var k;return $s?k=v[$s]:k=v.A,k??0}function dr(v,k){$s?v[$s]=k:v.A!==void 0?v.A=k:Object.defineProperties(v,{A:{value:k,configurable:!0,writable:!0,enumerable:!1}})}function Al(v){return Ar(v,1),v}function zd(v,k){dr(k,(v|0)&-51)}function Da(v,k){dr(k,(v|18)&-41)}var Bn={};function Ri(v){return v!==null&&typeof v=="object"&&!Array.isArray(v)&&v.constructor===Object}var Ko,qu=[];dr(qu,23),Ko=Object.freeze(qu);function Oa(v){if(Xt(v.o)&2)throw Error("Cannot mutate an immutable Message")}function Fa(v){var k=v.length;(k=k?v[k-1]:void 0)&&Ri(k)?k.g=1:(k={},v.push((k.g=1,k)))}function Dl(v){var k=v.i+v.G;return v.B||(v.B=v.o[k]={})}function Mn(v,k){return k===-1?null:k>=v.i?v.B?v.B[k]:void 0:v.o[k+v.G]}function Qr(v,k,E,A){Oa(v),Us(v,k,E,A)}function Us(v,k,E,A){v.j&&(v.j=void 0),k>=v.i||A?Dl(v)[k]=E:(v.o[k+v.G]=E,(v=v.B)&&k in v&&delete v[k])}function Ut(v,k,E,A){var W=Mn(v,k);Array.isArray(W)||(W=Ko);var G=Xt(W);if(G&1||Al(W),A)G&2||Ar(W,2),E&1||Object.freeze(W);else{A=!(E&2);var j=G&2;E&1||!j?A&&G&16&&!j&&Yr(W,16):(W=Al(Array.prototype.slice.call(W)),Us(v,k,W))}return W}function Ol(v,k){var E=Mn(v,k),A=E==null?E:typeof E=="number"||E==="NaN"||E==="Infinity"||E==="-Infinity"?Number(E):void 0;return A!=null&&A!==E&&Us(v,k,A),A}function vo(v,k,E,A,W){v.h||(v.h={});var G=v.h[E],j=Ut(v,E,3,W);if(!G){var Z=j;G=[];var ce=!!(Xt(v.o)&16);j=!!(Xt(Z)&2);var Ce=Z;!W&&j&&(Z=Array.prototype.slice.call(Z));for(var _e=j,Ze=0;Ze<Z.length;Ze++){var He=Z[Ze],Ae=k,Ke=!1;if(Ke=Ke===void 0?!1:Ke,He=Array.isArray(He)?new Ae(He):Ke?new Ae:void 0,He!==void 0){Ae=He.o;var ft=Ke=Xt(Ae);j&&(ft|=2),ce&&(ft|=16),ft!=Ke&&dr(Ae,ft),Ae=ft,_e=_e||!!(2&Ae),G.push(He)}}return v.h[E]=G,ce=Xt(Z),k=ce|33,k=_e?k&-9:k|8,ce!=k&&(_e=Z,Object.isFrozen(_e)&&(_e=Array.prototype.slice.call(_e)),dr(_e,k),Z=_e),Ce!==Z&&Us(v,E,Z),(W||A&&j)&&Ar(G,2),A&&Object.freeze(G),G}return W||(W=Object.isFrozen(G),A&&!W?Object.freeze(G):!A&&W&&(G=Array.prototype.slice.call(G),v.h[E]=G)),G}function _i(v,k,E){var A=!!(Xt(v.o)&2);if(k=vo(v,k,E,A,A),v=Ut(v,E,3,A),!(A||Xt(v)&8)){for(A=0;A<k.length;A++){if(E=k[A],Xt(E.o)&2){var W=Oi(E,!1);W.j=E}else W=E;E!==W&&(k[A]=W,v[A]=W.o)}Ar(v,8)}return k}function er(v,k,E){if(E!=null&&typeof E!="number")throw Error("Value of float/double field must be a number|null|undefined, found "+typeof E+": "+E);Qr(v,k,E)}function Yu(v,k,E,A,W){Oa(v);var G=vo(v,E,k,!1,!1);return E=A??new E,v=Ut(v,k,2,!1),W!=null?(G.splice(W,0,E),v.splice(W,0,E.o)):(G.push(E),v.push(E.o)),E.C()&&Yr(v,8),E}function Pi(v,k){return v??k}function Vn(v,k,E){return E=E===void 0?0:E,Pi(Ol(v,k),E)}var tr;function Bd(v){switch(typeof v){case"number":return isFinite(v)?v:String(v);case"object":if(v)if(Array.isArray(v)){if((Xt(v)&128)!==0)return v=Array.prototype.slice.call(v),Fa(v),v}else{if(we&&v!=null&&v instanceof Uint8Array)return et(v);if(v instanceof Uo){var k=v.V;return k==null?"":typeof k=="string"?k:v.V=et(k)}}}return v}function hr(v,k,E,A){if(v!=null){if(Array.isArray(v))v=Fl(v,k,E,A!==void 0);else if(Ri(v)){var W={},G;for(G in v)W[G]=hr(v[G],k,E,A);v=W}else v=k(v,A);return v}}function Fl(v,k,E,A){var W=Xt(v);A=A?!!(W&16):void 0,v=Array.prototype.slice.call(v);for(var G=0;G<v.length;G++)v[G]=hr(v[G],k,E,A);return E(W,v),v}function Md(v){return v.ja===Bn?v.toJSON():Bd(v)}function Vd(v,k){v&128&&Fa(k)}function Ai(v,k,E){if(E=E===void 0?Da:E,v!=null){if(we&&v instanceof Uint8Array)return v.length?new Uo(new Uint8Array(v),Rr):_a();if(Array.isArray(v)){var A=Xt(v);return A&2?v:k&&!(A&32)&&(A&16||A===0)?(dr(v,A|2),v):(v=Fl(v,Ai,A&4?Da:E,!0),k=Xt(v),k&4&&k&2&&Object.freeze(v),v)}return v.ja===Bn?Xo(v):v}}function Di(v,k,E,A,W,G,j){if(v=v.h&&v.h[E]){if(A=Xt(v),A&2?A=v:(G=$e(v,Xo),Da(A,G),Object.freeze(G),A=G),Oa(k),j=A==null?Ko:Al([]),A!=null){for(G=!!A.length,v=0;v<A.length;v++){var Z=A[v];G=G&&!(Xt(Z.o)&2),j[v]=Z.o}G=(G?8:0)|1,v=Xt(j),(v&G)!==G&&(Object.isFrozen(j)&&(j=Array.prototype.slice.call(j)),dr(j,v|G)),k.h||(k.h={}),k.h[E]=A}else k.h&&(k.h[E]=void 0);Us(k,E,j,W)}else Qr(k,E,Ai(A,G,j),W)}function Xo(v){return Xt(v.o)&2||(v=Oi(v,!0),Ar(v.o,2)),v}function Oi(v,k){var E=v.o,A=[];Ar(A,16);var W=v.constructor.h;if(W&&A.push(W),W=v.B,W){A.length=E.length,A.fill(void 0,A.length,E.length);var G={};A[A.length-1]=G}(Xt(E)&128)!==0&&Fa(A),k=k||v.C()?Da:zd,G=v.constructor,tr=A,A=new G(A),tr=void 0,v.R&&(A.R=v.R.slice()),G=!!(Xt(E)&16);for(var j=W?E.length-1:E.length,Z=0;Z<j;Z++)Di(v,A,Z-v.G,E[Z],!1,G,k);if(W)for(var ce in W)Di(v,A,+ce,W[ce],!0,G,k);return A}function wn(v,k,E){v==null&&(v=tr),tr=void 0;var A=this.constructor.i||0,W=0<A,G=this.constructor.h,j=!1;if(v==null){v=G?[G]:[];var Z=48,ce=!0;W&&(A=0,Z|=128),dr(v,Z)}else{if(!Array.isArray(v)||G&&G!==v[0])throw Error();var Ce=Z=Ar(v,0);if((ce=(16&Ce)!==0)&&((j=(32&Ce)!==0)||(Ce|=32)),W){if(128&Ce)A=0;else if(0<v.length){var _e=v[v.length-1];if(Ri(_e)&&"g"in _e){A=0,Ce|=128,delete _e.g;var Ze=!0,He;for(He in _e){Ze=!1;break}Ze&&v.pop()}}}else if(128&Ce)throw Error();Z!==Ce&&dr(v,Ce)}this.G=(G?0:-1)-A,this.h=void 0,this.o=v;e:{if(G=this.o.length,A=G-1,G&&(G=this.o[A],Ri(G))){this.B=G,this.i=A-this.G;break e}k!==void 0&&-1<k?(this.i=Math.max(k,A+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE}if(!W&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(E){k=ce&&!j&&!0,W=this.i;var Ae;for(ce=0;ce<E.length;ce++)j=E[ce],j<W?(j+=this.G,(A=v[j])?La(A,k):v[j]=Ko):(Ae||(Ae=Dl(this)),(A=Ae[j])?La(A,k):Ae[j]=Ko)}}wn.prototype.toJSON=function(){return Fl(this.o,Md,Vd)},wn.prototype.C=function(){return!!(Xt(this.o)&2)};function La(v,k){if(Array.isArray(v)){var E=Xt(v),A=1;!k||E&2||(A|=16),(E&A)!==A&&dr(v,E|A)}}wn.prototype.ja=Bn,wn.prototype.toString=function(){return this.o.toString()};function za(v,k,E){if(E){var A={},W;for(W in E){var G=E[W],j=G.ra;j||(A.J=G.xa||G.oa.W,G.ia?(A.aa=Ba(G.ia),j=function(Z){return function(ce,Ce,_e){return Z.J(ce,Ce,_e,Z.aa)}}(A)):G.ka?(A.Z=Bi(G.da.P,G.ka),j=function(Z){return function(ce,Ce,_e){return Z.J(ce,Ce,_e,Z.Z)}}(A)):j=A.J,G.ra=j),j(k,v,G.da),A={J:A.J,aa:A.aa,Z:A.Z}}}Ei(k,v)}var Fi=Symbol();function Li(v,k,E){return v[Fi]||(v[Fi]=function(A,W){return k(A,W,E)})}function qo(v){var k=v[Fi];if(!k){var E=es(v);k=function(A,W){return ts(A,W,E)},v[Fi]=k}return k}function Wd(v){var k=v.ia;if(k)return qo(k);if(k=v.wa)return Li(v.da.P,k,v.ka)}function Ll(v){var k=Wd(v),E=v.da,A=v.oa.U;return k?function(W,G){return A(W,G,E,k)}:function(W,G){return A(W,G,E)}}function St(v,k){var E=v[k];return typeof E=="function"&&E.length===0&&(E=E(),v[k]=E),Array.isArray(E)&&(Wn in E||Yo in E||0<E.length&&typeof E[0]=="function")?E:void 0}function zl(v,k,E,A,W,G){k.P=v[0];var j=1;if(v.length>j&&typeof v[j]!="number"){var Z=v[j++];E(k,Z)}for(;j<v.length;){E=v[j++];for(var ce=j+1;ce<v.length&&typeof v[ce]!="number";)ce++;switch(Z=v[j++],ce-=j,ce){case 0:A(k,E,Z);break;case 1:(ce=St(v,j))?(j++,W(k,E,Z,ce)):A(k,E,Z,v[j++]);break;case 2:ce=j++,ce=St(v,ce),W(k,E,Z,ce,v[j++]);break;case 3:G(k,E,Z,v[j++],v[j++],v[j++]);break;case 4:G(k,E,Z,v[j++],v[j++],v[j++],v[j++]);break;default:throw Error("unexpected number of binary field arguments: "+ce)}}return k}var zi=Symbol();function Ba(v){var k=v[zi];if(!k){var E=fr(v);k=function(A,W){return Ju(A,W,E)},v[zi]=k}return k}function Bi(v,k){var E=v[zi];return E||(E=function(A,W){return za(A,W,k)},v[zi]=E),E}var Yo=Symbol();function Qu(v,k){v.push(k)}function Bl(v,k,E){v.push(k,E.W)}function bo(v,k,E,A){var W=Ba(A),G=fr(A).P,j=E.W;v.push(k,function(Z,ce,Ce){return j(Z,ce,Ce,G,W)})}function Zr(v,k,E,A,W,G){var j=Bi(A,G),Z=E.W;v.push(k,function(ce,Ce,_e){return Z(ce,Ce,_e,A,j)})}function fr(v){var k=v[Yo];return k||(k=zl(v,v[Yo]=[],Qu,Bl,bo,Zr),Wn in v&&Yo in v&&(v.length=0),k)}var Wn=Symbol();function Mi(v,k){v[0]=k}function Qo(v,k,E,A){var W=E.U;v[k]=A?function(G,j,Z){return W(G,j,Z,A)}:W}function Jr(v,k,E,A,W){var G=E.U,j=qo(A),Z=es(A).P;v[k]=function(ce,Ce,_e){return G(ce,Ce,_e,Z,j,W)}}function Zu(v,k,E,A,W,G,j){var Z=E.U,ce=Li(A,W,G);v[k]=function(Ce,_e,Ze){return Z(Ce,_e,Ze,A,ce,j)}}function es(v){var k=v[Wn];return k||(k=zl(v,v[Wn]={},Mi,Qo,Jr,Zu),Wn in v&&Yo in v&&(v.length=0),k)}function ts(v,k,E){for(;Pl(k)&&k.i!=4;){var A=k.l,W=E[A];if(!W){var G=E[0];G&&(G=G[A])&&(W=E[A]=Ll(G))}if(!W||!W(k,v,A)){W=k,A=v,G=W.j,Ho(W);var j=W;if(!j.ca){if(W=j.h.h-G,j.h.h=G,j=j.h,W==0)W=_a();else{if(G=Pr(j,W),j.S&&j.m)W=j.i.subarray(G,G+W);else{j=j.i;var Z=G;W=G+W,W=Z===W?rn():ki?j.slice(Z,W):new Uint8Array(j.subarray(Z,W))}W=W.length==0?_a():new Uo(W,Rr)}(G=A.R)?G.push(W):A.R=[W]}}}return v}function Ju(v,k,E){for(var A=E.length,W=A%2==1,G=W?1:0;G<A;G+=2)(0,E[G+1])(k,v,E[G]);za(v,k,W?E[0]:void 0)}function wo(v,k){return{U:v,W:k}}var Un=wo(function(v,k,E){if(v.i!==5)return!1;v=v.h;var A=v.i,W=v.h,G=A[W],j=A[W+1],Z=A[W+2];return A=A[W+3],Cs(v,v.h+4),j=(G<<0|j<<8|Z<<16|A<<24)>>>0,v=2*(j>>31)+1,G=j>>>23&255,j&=8388607,Qr(k,E,G==255?j?NaN:1/0*v:G==0?v*Math.pow(2,-149)*j:v*Math.pow(2,G-150)*(j+Math.pow(2,23))),!0},function(v,k,E){if(k=Ol(k,E),k!=null){Vs(v.h,8*E+5),v=v.h;var A=+k;A===0?0<1/A?zt=sn=0:(sn=0,zt=2147483648):isNaN(A)?(sn=0,zt=2147483647):(A=(E=0>A?-2147483648:0)?-A:A,34028234663852886e22<A?(sn=0,zt=(E|2139095040)>>>0):11754943508222875e-54>A?(A=Math.round(A/Math.pow(2,-149)),sn=0,zt=(E|A)>>>0):(k=Math.floor(Math.log(A)/Math.LN2),A*=Math.pow(2,-k),A=Math.round(8388608*A),16777216<=A&&++k,sn=0,zt=(E|k+127<<23|A&8388607)>>>0)),E=zt,v.h.push(E>>>0&255),v.h.push(E>>>8&255),v.h.push(E>>>16&255),v.h.push(E>>>24&255)}}),Ml=wo(function(v,k,E){if(v.i!==0)return!1;var A=v.h,W=0,G=v=0,j=A.i,Z=A.h;do{var ce=j[Z++];W|=(ce&127)<<G,G+=7}while(32>G&&ce&128);for(32<G&&(v|=(ce&127)>>4),G=3;32>G&&ce&128;G+=7)ce=j[Z++],v|=(ce&127)<<G;if(Cs(A,Z),128>ce)A=W>>>0,ce=v>>>0,(v=ce&2147483648)&&(A=~A+1>>>0,ce=~ce>>>0,A==0&&(ce=ce+1>>>0)),A=4294967296*ce+(A>>>0);else throw zs();return Qr(k,E,v?-A:A),!0},function(v,k,E){k=Mn(k,E),k!=null&&(typeof k=="string"&&Na(k),k!=null&&(Vs(v.h,8*E),typeof k=="number"?(v=v.h,_r(k),_l(v,zt,sn)):(E=Na(k),_l(v.h,E.i,E.h))))}),Ud=wo(function(v,k,E){return v.i!==0?!1:(Qr(k,E,Ms(v.h)),!0)},function(v,k,E){if(k=Mn(k,E),k!=null&&k!=null)if(Vs(v.h,8*E),v=v.h,E=k,0<=E)Vs(v,E);else{for(k=0;9>k;k++)v.h.push(E&127|128),E>>=7;v.h.push(1)}}),Zo=wo(function(v,k,E){if(v.i!==2)return!1;var A=Ms(v.h)>>>0;v=v.h;var W=Pr(v,A);if(v=v.i,go){var G=v,j;(j=Ii)||(j=Ii=new TextDecoder("utf-8",{fatal:!0})),v=W+A,G=W===0&&v===G.length?G:G.subarray(W,v);try{var Z=j.decode(G)}catch(Ze){if(Ti===void 0){try{j.decode(new Uint8Array([128]))}catch{}try{j.decode(new Uint8Array([97])),Ti=!0}catch{Ti=!1}}throw!Ti&&(Ii=void 0),Ze}}else{Z=W,A=Z+A,W=[];for(var ce=null,Ce,_e;Z<A;)Ce=v[Z++],128>Ce?W.push(Ce):224>Ce?Z>=A?Ss():(_e=v[Z++],194>Ce||(_e&192)!==128?(Z--,Ss()):W.push((Ce&31)<<6|_e&63)):240>Ce?Z>=A-1?Ss():(_e=v[Z++],(_e&192)!==128||Ce===224&&160>_e||Ce===237&&160<=_e||((G=v[Z++])&192)!==128?(Z--,Ss()):W.push((Ce&15)<<12|(_e&63)<<6|G&63)):244>=Ce?Z>=A-2?Ss():(_e=v[Z++],(_e&192)!==128||(Ce<<28)+(_e-144)>>30!==0||((G=v[Z++])&192)!==128||((j=v[Z++])&192)!==128?(Z--,Ss()):(Ce=(Ce&7)<<18|(_e&63)<<12|(G&63)<<6|j&63,Ce-=65536,W.push((Ce>>10&1023)+55296,(Ce&1023)+56320))):Ss(),8192<=W.length&&(ce=Ea(ce,W),W.length=0);Z=Ea(ce,W)}return Qr(k,E,Z),!0},function(v,k,E){if(k=Mn(k,E),k!=null){var A=!1;if(A=A===void 0?!1:A,Wo){if(A&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(k))throw Error("Found an unpaired surrogate");k=(Ra||(Ra=new TextEncoder)).encode(k)}else{for(var W=0,G=new Uint8Array(3*k.length),j=0;j<k.length;j++){var Z=k.charCodeAt(j);if(128>Z)G[W++]=Z;else{if(2048>Z)G[W++]=Z>>6|192;else{if(55296<=Z&&57343>=Z){if(56319>=Z&&j<k.length){var ce=k.charCodeAt(++j);if(56320<=ce&&57343>=ce){Z=1024*(Z-55296)+ce-56320+65536,G[W++]=Z>>18|240,G[W++]=Z>>12&63|128,G[W++]=Z>>6&63|128,G[W++]=Z&63|128;continue}else j--}if(A)throw Error("Found an unpaired surrogate");Z=65533}G[W++]=Z>>12|224,G[W++]=Z>>6&63|128}G[W++]=Z&63|128}}k=W===G.length?G:G.subarray(0,W)}Vs(v.h,8*E+2),Vs(v.h,k.length),Ws(v,v.h.end()),Ws(v,k)}}),So=wo(function(v,k,E,A,W){if(v.i!==2)return!1;k=Yu(k,E,A),E=v.h.j,A=Ms(v.h)>>>0;var G=v.h.h+A,j=G-E;if(0>=j&&(v.h.j=G,W(k,v,void 0,void 0,void 0),j=G-v.h.h),j)throw Error("Message parsing ended unexpectedly. Expected to read "+(A+" bytes, instead read "+(A-j)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return v.h.h=G,v.h.j=E,!0},function(v,k,E,A,W){if(k=_i(k,A,E),k!=null)for(A=0;A<k.length;A++){var G=v;Vs(G.h,8*E+2);var j=G.h.end();Ws(G,j),j.push(G.i),G=j,W(k[A],v),j=v;var Z=G.pop();for(Z=j.i+j.h.length()-Z;127<Z;)G.push(Z&127|128),Z>>>=7,j.i++;G.push(Z),j.i++}});function js(v){return function(k,E){e:{if(Jn.length){var A=Jn.pop();A.setOptions(E),Go(A.h,k,E),k=A}else k=new Aa(k,E);try{var W=es(v),G=ts(new W.P,k,W);break e}finally{W=k.h,W.i=null,W.m=!1,W.l=0,W.j=0,W.h=0,W.S=!1,k.l=-1,k.i=-1,100>Jn.length&&Jn.push(k)}G=void 0}return G}}function U(v){return function(){var k=new Ni;Ju(this,k,fr(v)),Ws(k,k.h.end());for(var E=new Uint8Array(k.i),A=k.j,W=A.length,G=0,j=0;j<W;j++){var Z=A[j];E.set(Z,G),G+=Z.length}return k.j=[E],E}}function ee(v){wn.call(this,v)}w(ee,wn);var he=[ee,1,Ud,2,Un,3,Zo,4,Zo];ee.prototype.l=U(he);function Fe(v){wn.call(this,v,-1,ht)}w(Fe,wn),Fe.prototype.addClassification=function(v,k){return Yu(this,1,ee,v,k),this};var ht=[1],It=js([Fe,1,So,he]);function Nt(v){wn.call(this,v)}w(Nt,wn);var at=[Nt,1,Un,2,Un,3,Un,4,Un,5,Un];Nt.prototype.l=U(at);function _t(v){wn.call(this,v,-1,jn)}w(_t,wn);var jn=[1],Gn=js([_t,1,So,at]);function Dr(v){wn.call(this,v)}w(Dr,wn);var Co=[Dr,1,Un,2,Un,3,Un,4,Un,5,Un,6,Ml],Ma=js(Co);Dr.prototype.l=U(Co);function Rn(v,k,E){if(E=v.createShader(E===0?v.VERTEX_SHADER:v.FRAGMENT_SHADER),v.shaderSource(E,k),v.compileShader(E),!v.getShaderParameter(E,v.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+v.getShaderInfoLog(E));return E}function Va(v){return _i(v,ee,1).map(function(k){var E=Mn(k,1);return{index:E??0,qa:Vn(k,2),label:Mn(k,3)!=null?Pi(Mn(k,3),""):void 0,displayName:Mn(k,4)!=null?Pi(Mn(k,4),""):void 0}})}function jd(v){return{x:Vn(v,1),y:Vn(v,2),z:Vn(v,3),visibility:Ol(v,4)!=null?Vn(v,4):void 0}}function Vi(v){return _i(Gn(v),Nt,1).map(jd)}function Gd(v,k){this.i=v,this.h=k,this.m=0}function ec(v,k,E){return Hd(v,k),typeof v.h.canvas.transferToImageBitmap=="function"?Promise.resolve(v.h.canvas.transferToImageBitmap()):E?Promise.resolve(v.h.canvas):typeof createImageBitmap=="function"?createImageBitmap(v.h.canvas):(v.j===void 0&&(v.j=document.createElement("canvas")),new Promise(function(A){v.j.height=v.h.canvas.height,v.j.width=v.h.canvas.width,v.j.getContext("2d",{}).drawImage(v.h.canvas,0,0,v.h.canvas.width,v.h.canvas.height),A(v.j)}))}function Hd(v,k){var E=v.h;if(v.s===void 0){var A=Rn(E,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),W=Rn(E,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),G=E.createProgram();if(E.attachShader(G,A),E.attachShader(G,W),E.linkProgram(G),!E.getProgramParameter(G,E.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+E.getProgramInfoLog(G));A=v.s=G,E.useProgram(A),W=E.getUniformLocation(A,"sampler0"),v.l={O:E.getAttribLocation(A,"aVertex"),N:E.getAttribLocation(A,"aTex"),ya:W},v.v=E.createBuffer(),E.bindBuffer(E.ARRAY_BUFFER,v.v),E.enableVertexAttribArray(v.l.O),E.vertexAttribPointer(v.l.O,2,E.FLOAT,!1,0,0),E.bufferData(E.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),E.STATIC_DRAW),E.bindBuffer(E.ARRAY_BUFFER,null),v.u=E.createBuffer(),E.bindBuffer(E.ARRAY_BUFFER,v.u),E.enableVertexAttribArray(v.l.N),E.vertexAttribPointer(v.l.N,2,E.FLOAT,!1,0,0),E.bufferData(E.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),E.STATIC_DRAW),E.bindBuffer(E.ARRAY_BUFFER,null),E.uniform1i(W,0)}A=v.l,E.useProgram(v.s),E.canvas.width=k.width,E.canvas.height=k.height,E.viewport(0,0,k.width,k.height),E.activeTexture(E.TEXTURE0),v.i.bindTexture2d(k.glName),E.enableVertexAttribArray(A.O),E.bindBuffer(E.ARRAY_BUFFER,v.v),E.vertexAttribPointer(A.O,2,E.FLOAT,!1,0,0),E.enableVertexAttribArray(A.N),E.bindBuffer(E.ARRAY_BUFFER,v.u),E.vertexAttribPointer(A.N,2,E.FLOAT,!1,0,0),E.bindFramebuffer(E.DRAW_FRAMEBUFFER?E.DRAW_FRAMEBUFFER:E.FRAMEBUFFER,null),E.clearColor(0,0,0,0),E.clear(E.COLOR_BUFFER_BIT),E.colorMask(!0,!0,!0,!0),E.drawArrays(E.TRIANGLE_FAN,0,4),E.disableVertexAttribArray(A.O),E.disableVertexAttribArray(A.N),E.bindBuffer(E.ARRAY_BUFFER,null),v.i.bindTexture2d(0)}function Vl(v){this.h=v}var tc=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function op(v,k){return k+v}function ip(v,k){window[v]=k}function Ny(v){var k=document.createElement("script");return k.setAttribute("src",v),k.setAttribute("crossorigin","anonymous"),new Promise(function(E){k.addEventListener("load",function(){E()},!1),k.addEventListener("error",function(){E()},!1),document.body.appendChild(k)})}function Ey(){return P(function(v){switch(v.h){case 1:return v.s=2,R(v,WebAssembly.instantiate(tc),4);case 4:v.h=3,v.s=0;break;case 2:return v.s=0,v.l=null,v.return(!1);case 3:return v.return(!0)}})}function Wl(v){if(this.h=v,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=v&&v.locateFile||op,typeof window=="object")var k=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")k=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.ha=k,v.options){k=a(Object.keys(v.options));for(var E=k.next();!E.done;E=k.next()){E=E.value;var A=v.options[E].default;A!==void 0&&(this.l[E]=typeof A=="function"?A():A)}}}t=Wl.prototype,t.close=function(){return this.j&&this.j.delete(),Promise.resolve()};function Ry(v){var k,E,A,W,G,j,Z,ce,Ce,_e,Ze;return P(function(He){switch(He.h){case 1:return v.ga?(k=v.h.files===void 0?[]:typeof v.h.files=="function"?v.h.files(v.l):v.h.files,R(He,Ey(),2)):He.return();case 2:if(E=He.i,typeof window=="object")return ip("createMediapipeSolutionsWasm",{locateFile:v.locateFile}),ip("createMediapipeSolutionsPackedAssets",{locateFile:v.locateFile}),j=k.filter(function(Ae){return Ae.data!==void 0}),Z=k.filter(function(Ae){return Ae.data===void 0}),ce=Promise.all(j.map(function(Ae){var Ke=nc(v,Ae.url);if(Ae.path!==void 0){var ft=Ae.path;Ke=Ke.then(function(qt){return v.overrideFile(ft,qt),Promise.resolve(qt)})}return Ke})),Ce=Promise.all(Z.map(function(Ae){return Ae.simd===void 0||Ae.simd&&E||!Ae.simd&&!E?Ny(v.locateFile(Ae.url,v.ha)):Promise.resolve()})).then(function(){var Ae,Ke,ft;return P(function(qt){if(qt.h==1)return Ae=window.createMediapipeSolutionsWasm,Ke=window.createMediapipeSolutionsPackedAssets,ft=v,R(qt,Ae(Ke),2);ft.i=qt.i,qt.h=0})}),_e=function(){return P(function(Ae){return v.h.graph&&v.h.graph.url?Ae=R(Ae,nc(v,v.h.graph.url),0):(Ae.h=0,Ae=void 0),Ae})}(),R(He,Promise.all([Ce,ce,_e]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return A=k.filter(function(Ae){return Ae.simd===void 0||Ae.simd&&E||!Ae.simd&&!E}).map(function(Ae){return v.locateFile(Ae.url,v.ha)}),importScripts.apply(null,l(A)),W=v,R(He,createMediapipeSolutionsWasm(Module),6);case 6:W.i=He.i,v.m=new OffscreenCanvas(1,1),v.i.canvas=v.m,G=v.i.GL.createContext(v.m,{antialias:!1,alpha:!1,va:typeof WebGL2RenderingContext<"u"?2:1}),v.i.GL.makeContextCurrent(G),He.h=4;break;case 7:if(v.m=document.createElement("canvas"),Ze=v.m.getContext("webgl2",{}),!Ze&&(Ze=v.m.getContext("webgl",{}),!Ze))return alert("Failed to create WebGL canvas context when passing video frame."),He.return();v.K=Ze,v.i.canvas=v.m,v.i.createContext(v.m,!0,!0,{});case 4:v.j=new v.i.SolutionWasm,v.ga=!1,He.h=0}})}function _y(v){var k,E,A,W,G,j,Z,ce;return P(function(Ce){if(Ce.h==1){if(v.h.graph&&v.h.graph.url&&v.fa===v.h.graph.url)return Ce.return();if(v.u=!0,!v.h.graph||!v.h.graph.url){Ce.h=2;return}return v.fa=v.h.graph.url,R(Ce,nc(v,v.h.graph.url),3)}for(Ce.h!=2&&(k=Ce.i,v.j.loadGraph(k)),E=a(Object.keys(v.D)),A=E.next();!A.done;A=E.next())W=A.value,v.j.overrideFile(W,v.D[W]);if(v.D={},v.h.listeners)for(G=a(v.h.listeners),j=G.next();!j.done;j=G.next())Z=j.value,Dy(v,Z);ce=v.l,v.l={},v.setOptions(ce),Ce.h=0})}t.reset=function(){var v=this;return P(function(k){v.j&&(v.j.reset(),v.s={},v.v={}),k.h=0})},t.setOptions=function(v,k){var E=this;if(k=k||this.h.options){for(var A=[],W=[],G={},j=a(Object.keys(v)),Z=j.next();!Z.done;G={X:G.X,Y:G.Y},Z=j.next())if(Z=Z.value,!(Z in this.l&&this.l[Z]===v[Z])){this.l[Z]=v[Z];var ce=k[Z];ce!==void 0&&(ce.onChange&&(G.X=ce.onChange,G.Y=v[Z],A.push(function(Ce){return function(){var _e;return P(function(Ze){if(Ze.h==1)return R(Ze,Ce.X(Ce.Y),2);_e=Ze.i,_e===!0&&(E.u=!0),Ze.h=0})}}(G))),ce.graphOptionXref&&(Z=Object.assign({},{calculatorName:"",calculatorIndex:0},ce.graphOptionXref,{valueNumber:ce.type===1?v[Z]:0,valueBoolean:ce.type===0?v[Z]:!1,valueString:ce.type===2?v[Z]:""}),W.push(Z)))}(A.length!==0||W.length!==0)&&(this.u=!0,this.H=(this.H===void 0?[]:this.H).concat(W),this.F=(this.F===void 0?[]:this.F).concat(A))}};function Py(v){var k,E,A,W,G,j,Z;return P(function(ce){switch(ce.h){case 1:if(!v.u)return ce.return();if(!v.F){ce.h=2;break}k=a(v.F),E=k.next();case 3:if(E.done){ce.h=5;break}return A=E.value,R(ce,A(),4);case 4:E=k.next(),ce.h=3;break;case 5:v.F=void 0;case 2:if(v.H){for(W=new v.i.GraphOptionChangeRequestList,G=a(v.H),j=G.next();!j.done;j=G.next())Z=j.value,W.push_back(Z);v.j.changeOptions(W),W.delete(),v.H=void 0}v.u=!1,ce.h=0}})}t.initialize=function(){var v=this;return P(function(k){return k.h==1?R(k,Ry(v),2):k.h!=3?R(k,_y(v),3):R(k,Py(v),0)})};function nc(v,k){var E,A;return P(function(W){return k in v.L?W.return(v.L[k]):(E=v.locateFile(k,""),A=fetch(E).then(function(G){return G.arrayBuffer()}),v.L[k]=A,W.return(A))})}t.overrideFile=function(v,k){this.j?this.j.overrideFile(v,k):this.D[v]=k},t.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},t.send=function(v,k){var E=this,A,W,G,j,Z,ce,Ce,_e,Ze;return P(function(He){switch(He.h){case 1:return E.h.inputs?(A=1e3*(k??performance.now()),R(He,E.I,2)):He.return();case 2:return R(He,E.initialize(),3);case 3:for(W=new E.i.PacketDataList,G=a(Object.keys(v)),j=G.next();!j.done;j=G.next())if(Z=j.value,ce=E.h.inputs[Z]){e:{var Ae=v[Z];switch(ce.type){case"video":var Ke=E.s[ce.stream];if(Ke||(Ke=new Gd(E.i,E.K),E.s[ce.stream]=Ke),Ke.m===0&&(Ke.m=Ke.i.createTexture()),typeof HTMLVideoElement<"u"&&Ae instanceof HTMLVideoElement)var ft=Ae.videoWidth,qt=Ae.videoHeight;else typeof HTMLImageElement<"u"&&Ae instanceof HTMLImageElement?(ft=Ae.naturalWidth,qt=Ae.naturalHeight):(ft=Ae.width,qt=Ae.height);qt={glName:Ke.m,width:ft,height:qt},ft=Ke.h,ft.canvas.width=qt.width,ft.canvas.height=qt.height,ft.activeTexture(ft.TEXTURE0),Ke.i.bindTexture2d(Ke.m),ft.texImage2D(ft.TEXTURE_2D,0,ft.RGBA,ft.RGBA,ft.UNSIGNED_BYTE,Ae),Ke.i.bindTexture2d(0),Ke=qt;break e;case"detections":for(Ke=E.s[ce.stream],Ke||(Ke=new Vl(E.i),E.s[ce.stream]=Ke),Ke.data||(Ke.data=new Ke.h.DetectionListData),Ke.data.reset(Ae.length),qt=0;qt<Ae.length;++qt){ft=Ae[qt];var jt=Ke.data,Tn=jt.setBoundingBox,Or=qt,nr=ft.la,yt=new Dr;if(er(yt,1,nr.sa),er(yt,2,nr.ta),er(yt,3,nr.height),er(yt,4,nr.width),er(yt,5,nr.rotation),Qr(yt,6,nr.pa),nr=yt.l(),Tn.call(jt,Or,nr),ft.ea)for(jt=0;jt<ft.ea.length;++jt){yt=ft.ea[jt],Tn=Ke.data,Or=Tn.addNormalizedLandmark,nr=qt,yt=Object.assign({},yt,{visibility:yt.visibility?yt.visibility:0});var _n=new Nt;er(_n,1,yt.x),er(_n,2,yt.y),er(_n,3,yt.z),yt.visibility&&er(_n,4,yt.visibility),yt=_n.l(),Or.call(Tn,nr,yt)}if(ft.ba)for(jt=0;jt<ft.ba.length;++jt)Tn=Ke.data,Or=Tn.addClassification,nr=qt,yt=ft.ba[jt],_n=new ee,er(_n,2,yt.qa),yt.index&&Qr(_n,1,yt.index),yt.label&&Qr(_n,3,yt.label),yt.displayName&&Qr(_n,4,yt.displayName),yt=_n.l(),Or.call(Tn,nr,yt)}Ke=Ke.data;break e;default:Ke={}}}switch(Ce=Ke,_e=ce.stream,ce.type){case"video":W.pushTexture2d(Object.assign({},Ce,{stream:_e,timestamp:A}));break;case"detections":Ze=Ce,Ze.stream=_e,Ze.timestamp=A,W.pushDetectionList(Ze);break;default:throw Error("Unknown input config type: '"+ce.type+"'")}}return E.j.send(W),R(He,E.I,4);case 4:W.delete(),He.h=0}})};function Ay(v,k,E){var A,W,G,j,Z,ce,Ce,_e,Ze,He,Ae,Ke,ft,qt;return P(function(jt){switch(jt.h){case 1:if(!E)return jt.return(k);for(A={},W=0,G=a(Object.keys(E)),j=G.next();!j.done;j=G.next())Z=j.value,ce=E[Z],typeof ce!="string"&&ce.type==="texture"&&k[ce.stream]!==void 0&&++W;1<W&&(v.M=!1),Ce=a(Object.keys(E)),j=Ce.next();case 2:if(j.done){jt.h=4;break}if(_e=j.value,Ze=E[_e],typeof Ze=="string")return ft=A,qt=_e,R(jt,ap(v,_e,k[Ze]),14);if(He=k[Ze.stream],Ze.type==="detection_list"){if(He){for(var Tn=He.getRectList(),Or=He.getLandmarksList(),nr=He.getClassificationsList(),yt=[],_n=0;_n<Tn.size();++_n){var Jo=Ma(Tn.get(_n)),Oy=Vn(Jo,1),cp=Vn(Jo,2),dp=Vn(Jo,3),Ul=Vn(Jo,4),jl=Vn(Jo,5,0),rc=void 0;rc=rc===void 0?0:rc,Jo={la:{sa:Oy,ta:cp,height:dp,width:Ul,rotation:jl,pa:Pi(Mn(Jo,6),rc)},ea:Vi(Or.get(_n)),ba:Va(It(nr.get(_n)))},yt.push(Jo)}Tn=yt}else Tn=[];A[_e]=Tn,jt.h=7;break}if(Ze.type==="proto_list"){if(He){for(Tn=Array(He.size()),Or=0;Or<He.size();Or++)Tn[Or]=He.get(Or);He.delete()}else Tn=[];A[_e]=Tn,jt.h=7;break}if(He===void 0){jt.h=3;break}if(Ze.type==="float_list"){A[_e]=He,jt.h=7;break}if(Ze.type==="proto"){A[_e]=He,jt.h=7;break}if(Ze.type!=="texture")throw Error("Unknown output config type: '"+Ze.type+"'");return Ae=v.v[_e],Ae||(Ae=new Gd(v.i,v.K),v.v[_e]=Ae),R(jt,ec(Ae,He,v.M),13);case 13:Ke=jt.i,A[_e]=Ke;case 7:Ze.transform&&A[_e]&&(A[_e]=Ze.transform(A[_e])),jt.h=3;break;case 14:ft[qt]=jt.i;case 3:j=Ce.next(),jt.h=2;break;case 4:return jt.return(A)}})}function ap(v,k,E){var A;return P(function(W){return typeof E=="number"||E instanceof Uint8Array||E instanceof v.i.Uint8BlobList?W.return(E):E instanceof v.i.Texture2dDataOut?(A=v.v[k],A||(A=new Gd(v.i,v.K),v.v[k]=A),W.return(ec(A,E,v.M))):W.return(void 0)})}function Dy(v,k){for(var E=k.name||"$",A=[].concat(l(k.wants)),W=new v.i.StringList,G=a(k.wants),j=G.next();!j.done;j=G.next())W.push_back(j.value);G=v.i.PacketListener.implement({onResults:function(Z){for(var ce={},Ce=0;Ce<k.wants.length;++Ce)ce[A[Ce]]=Z.get(Ce);var _e=v.listeners[E];_e&&(v.I=Ay(v,ce,k.outs).then(function(Ze){Ze=_e(Ze);for(var He=0;He<k.wants.length;++He){var Ae=ce[A[He]];typeof Ae=="object"&&Ae.hasOwnProperty&&Ae.hasOwnProperty("delete")&&Ae.delete()}Ze&&(v.I=Ze)}))}}),v.j.attachMultiListener(W,G),W.delete()}t.onResults=function(v,k){this.listeners[k||"$"]=v},ge("Solution",Wl),ge("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"});function lp(v){switch(v===void 0&&(v=0),v){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function up(v){var k=this;v=v||{},this.h=new Wl({locateFile:v.locateFile,files:function(E){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:lp(E.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:Vi},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:Vi},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window!="object"||window.navigator===void 0?!1:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(E){var A,W,G;return P(function(j){return j.h==1?(A=lp(E),W="third_party/mediapipe/modules/pose_landmark/"+A,R(j,nc(k.h,A),2)):(G=j.i,k.h.overrideFile(W,G),j.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}t=up.prototype,t.reset=function(){this.h.reset()},t.close=function(){return this.h.close(),Promise.resolve()},t.onResults=function(v){this.h.onResults(v)},t.initialize=function(){var v=this;return P(function(k){return R(k,v.h.initialize(),0)})},t.send=function(v,k){var E=this;return P(function(A){return R(A,E.h.send(v,k),0)})},t.setOptions=function(v){this.h.setOptions(v)},ge("Pose",up),ge("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),ge("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),ge("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),ge("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),ge("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),ge("VERSION","0.5.1675469404")}).call(nx)),nx}var iye=oye();/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aye=se();aye.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var us;(function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"})(us||(us={}));var gN;(function(t){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))})(gN||(gN={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lye={};function uF(t){return lye[t]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N(t,e,n,r,s){const o=e.inputParams[t];if(o&&o.inputIndexStart!==void 0){const a=o.inputIndexStart,l=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?a+1:o.inputIndexEnd,c=a<0?e.inputNames.length+a:a;if(o.type==="tensor")return Yn(e.inputNames[c],n,r,s);if(o.type==="tensors"){const p=e.inputs.slice(a,l);return e.inputNames.slice(a,l).filter((y,x)=>{var w;return((w=p[x])===null||w===void 0?void 0:w.op)!=="NoOp"}).map(y=>Yn(y,n,r,s))}const d=Yn(e.inputNames[c],n,r,s),f=d.dataSync();return o.type==="number"?f[0]:tv(d.shape,f)}const i=e.attrParams[t];return i&&i.value}function Yn(t,e,n,r){const[s,o]=cs(t,n);if(r!=null){const a=r.getHashTableHandleByName(s);if(a!=null)return a}const i=n.currentContextIds.find(a=>!!e[Og(s,a)]);return i!==void 0?e[Og(s,i)][o]:void 0}function yN(t,e,n){return e[Og(t,n.currentContextId)]}function Qi(t,e){const[n,r,s]=cs(t,e);return[Og(n,e&&e.currentContextId),r,s]}function Og(t,e){return e?`${t}-${e}`:t}function cs(t,e){if(t==="")return["",0,void 0];const n=e!=null&&e.parseNodeNameCache!=null;if(n){const o=e.parseNodeNameCache.get(t);if(o!=null)return o}const r=t.split(":");let s;if(r.length===1)s=[t,0,void 0];else{const o=r[0],i=r.length===3?r[1]:void 0,a=Number(r[r.length-1]);s=[o,a,i]}return n&&e.parseNodeNameCache.set(t,s),s}function eg(t,e,n){let r=N("pad",t,e,n);if(r==="explicit"){r=N("explicitPaddings",t,e,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)s[o][0]=r[o*2],s[o][1]=r[o*2+1];return s}return r}function Zi(t){return t.kept?t:fl(t)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uye=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],cye=Object.freeze(Object.defineProperty({__proto__:null,json:uye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dye=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],hye=Object.freeze(Object.defineProperty({__proto__:null,json:dye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fye=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],pye=Object.freeze(Object.defineProperty({__proto__:null,json:fye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mye=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],gye=Object.freeze(Object.defineProperty({__proto__:null,json:mye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yye=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],xye=Object.freeze(Object.defineProperty({__proto__:null,json:yye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vye=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],bye=Object.freeze(Object.defineProperty({__proto__:null,json:vye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wye=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Sye=Object.freeze(Object.defineProperty({__proto__:null,json:wye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cye=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],$ye=Object.freeze(Object.defineProperty({__proto__:null,json:Cye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kye=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Tye=Object.freeze(Object.defineProperty({__proto__:null,json:kye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iye=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Nye=Object.freeze(Object.defineProperty({__proto__:null,json:Iye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eye=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],Rye=Object.freeze(Object.defineProperty({__proto__:null,json:Eye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ye=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Pye=Object.freeze(Object.defineProperty({__proto__:null,json:_ye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aye=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Dye=Object.freeze(Object.defineProperty({__proto__:null,json:Aye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oye=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Fye=Object.freeze(Object.defineProperty({__proto__:null,json:Oye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lye=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],zye=Object.freeze(Object.defineProperty({__proto__:null,json:Lye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bye=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Mye=Object.freeze(Object.defineProperty({__proto__:null,json:Bye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vye=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Wye=Object.freeze(Object.defineProperty({__proto__:null,json:Vye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uye=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],jye=Object.freeze(Object.defineProperty({__proto__:null,json:Uye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gye=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],Hye=Object.freeze(Object.defineProperty({__proto__:null,json:Gye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xN{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[cye,hye,pye,gye,xye,bye,Sye,$ye,Tye,Nye,Rye,Pye,Dye,Fye,zye,Mye,Wye,jye,Hye],n=[].concat(...e.map(r=>r.json));this.opMappers=n.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(e,n={}){const r=e.node,s=[],o=[],i=[],a=r.reduce((x,w)=>(x[w.name]=this.mapNode(w),w.op.startsWith("Placeholder")?s.push(x[w.name]):w.op==="Const"?o.push(x[w.name]):(w.input==null||w.input.length===0)&&i.push(x[w.name]),x),{});let l=[];const c=[];let d={},f={};n!=null&&(d=this.mapSignatureEntries(n.inputs),f=this.mapSignatureEntries(n.outputs));const p=Object.keys(a);p.forEach(x=>{const w=a[x];w.inputNames.forEach((S,$)=>{const[I,,R]=Qi(S),_=a[I];if(_.outputs!=null){const O=_.outputs.indexOf(R);if(O!==-1){const F=`${I}:${O}`;w.inputNames[$]=F}}w.inputs.push(_),_.children.push(w)})}),Object.keys(f).length===0?p.forEach(x=>{const w=a[x];w.children.length===0&&c.push(w)}):Object.keys(f).forEach(x=>{const[w]=Qi(x),S=a[w];S!=null&&(S.signatureKey=f[x],c.push(S))}),Object.keys(d).length>0?Object.keys(d).forEach(x=>{const[w]=Qi(x),S=a[w];S&&(S.signatureKey=d[x],l.push(S))}):l=s;let g={};e.library!=null&&e.library.function!=null&&(g=e.library.function.reduce((x,w)=>(x[w.signature.name]=this.mapFunction(w),x),{}));const y={nodes:a,inputs:l,outputs:c,weights:o,placeholders:s,signature:n,functions:g};return i.length>0&&(y.initNodes=i),y}mapSignatureEntries(e){return Object.keys(e||{}).reduce((n,r)=>(n[e[r].name]=r,n),{})}mapNode(e){const n=uF(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const r={name:e.name,op:e.op,category:n.category,inputNames:(e.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:n.outputs};return n.inputs!=null&&(r.inputParams=n.inputs.reduce((s,o)=>(s[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},s),{})),n.attrs!=null&&(r.attrParams=n.attrs.reduce((s,o)=>{const i=o.type;let a;switch(o.type){case"string":a=$v(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=$v(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":a=_v(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=_v(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":a=Tv(e.attr,o.tfName,o.defaultValue||0),a===void 0&&o.tfDeprecatedName&&(a=Tv(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":a=Rv(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Rv(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":a=kv(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=kv(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":a=Av(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Av(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":a=Ev(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Ev(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":a=Pv(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Pv(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":a=Iv(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Iv(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":a=Nv(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Nv(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":a=vN(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=vN(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${e.op}`)}return s[o.name]={value:a,type:i},s},{})),r}mapFunction(e){const n=e.nodeDef,r=[],s=[];let o={};n!=null&&(o=n.reduce((f,p)=>(f[p.name]=this.mapNode(p),p.op==="Const"&&s.push(f[p.name]),f),{}));const i=[],a=[];e.signature.inputArg.forEach(f=>{const[p]=Qi(f.name),g={name:p,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:LC(f.type),type:"dtype"}},children:[]};g.signatureKey=f.name,i.push(g),o[p]=g}),Object.keys(o).forEach(f=>{const p=o[f];p.inputNames.forEach((g,y)=>{const[x,,w]=Qi(g),S=o[x];if(S.outputs!=null){const $=S.outputs.indexOf(w);if($!==-1){const I=`${x}:${$}`;p.inputNames[y]=I}}p.inputs.push(S),S.children.push(p)})});const c=e.ret;e.signature.outputArg.forEach(f=>{const[p,g]=Qi(c[f.name]),y=o[p];y!=null&&(y.defaultOutput=g,a.push(y))});const d=this.mapArgsToSignature(e);return{nodes:o,inputs:i,outputs:a,weights:s,placeholders:r,signature:d}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r),n),{}),outputs:e.signature.outputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r,e.ret),n),{})}}mapArgToTensorInfo(e,n){let r=e.name;return n!=null&&(r=n[r]),{name:r,dtype:e.type}}}function Kye(t){const e=se().global;if(typeof e.atob<"u")return e.atob(t);if(typeof Buffer<"u")return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function cF(t,e){const n=Array.isArray(t)?String.fromCharCode.apply(null,t):Kye(t);return e?n:n.toLowerCase()}function $v(t,e,n,r=!1){const s=t[e];return s!=null?cF(s.s,r):n}function kv(t,e,n){const r=t[e];return r?r.b:n}function Tv(t,e,n){const r=t[e]||{},s=r.i!=null?r.i:r.f!=null?r.f:n;return typeof s=="number"?s:parseInt(s,10)}function LC(t){switch(typeof t=="string"&&(t=us[t]),t){case us.DT_FLOAT:case us.DT_HALF:return"float32";case us.DT_INT32:case us.DT_INT64:case us.DT_INT8:case us.DT_UINT8:return"int32";case us.DT_BOOL:return"bool";case us.DT_DOUBLE:return"float32";case us.DT_STRING:return"string";case us.DT_COMPLEX64:case us.DT_COMPLEX128:return"complex64";default:return null}}function vN(t,e,n){const r=t[e];return r&&r.func?r.func.name:n}function Iv(t,e,n){const r=t[e];return r&&r.type?LC(r.type):n}function Nv(t,e,n){const r=t[e];return r&&r.list&&r.list.type?r.list.type.map(s=>LC(s)):n}function dF(t){if(!t.unknownRank)return t.dim!=null?t.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function Ev(t,e,n){const r=t[e];return r&&r.shape?dF(r.shape):n}function Rv(t,e,n){const r=t[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):n}function _v(t,e,n,r=!1){const s=t[e];return s&&s.list&&s.list.s?s.list.s.map(o=>cF(o,r)):n}function Pv(t,e,n){const r=t[e];return r&&r.list&&r.list.shape?r.list.shape.map(s=>dF(s)):n}function Av(t,e,n){const r=t[e];return r&&r.list&&r.list.b?r.list.b:n}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xye{constructor(e,n,r){this.node=e,this.tensorMap=n,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(s=>this.getInput(s)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((s,o)=>(s[o]=this.getAttr(o),s),{}))}getInput(e){return Yn(e,this.tensorMap,this.context)}getAttr(e,n){const r=this.node.rawAttrs[e];if(r.tensor!=null)return Yn(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return Tv(this.node.rawAttrs,e,n);if(r.s!=null)return $v(this.node.rawAttrs,e,n);if(r.b!=null)return kv(this.node.rawAttrs,e,n);if(r.shape!=null)return Ev(this.node.rawAttrs,e,n);if(r.type!=null)return Iv(this.node.rawAttrs,e,n);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return Rv(this.node.rawAttrs,e,n);if(r.list.s!=null)return _v(this.node.rawAttrs,e,n);if(r.list.shape!=null)return Pv(this.node.rawAttrs,e,n);if(r.list.b!=null)return Av(this.node.rawAttrs,e,n);if(r.list.type!=null)return Nv(this.node.rawAttrs,e,n)}return n}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zn=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:AA,abs:Es,acos:Iq,acosh:Eq,add:We,addN:_q,all:Aq,any:Oq,argMax:qA,argMin:zq,asin:Mq,asinh:Wq,atan:jq,atan2:Hq,atanh:Xq,avgPool:YA,avgPool3d:nY,basicLSTMCell:uY,batchNorm:ly,batchNorm2d:pY,batchNorm3d:gY,batchNorm4d:xY,batchToSpaceND:QA,bincount:ZA,bitwiseAnd:wY,booleanMaskAsync:ite,broadcastArgs:CY,broadcastTo:Qh,buffer:Wt,cast:Qt,ceil:TY,clipByValue:JA,clone:fl,complex:yl,concat:Fn,concat1d:EY,concat2d:_Y,concat3d:AY,concat4d:OY,conv1d:zY,conv2d:uy,conv2dTranspose:VY,conv3d:UY,conv3dTranspose:KY,cos:qY,cosh:QY,cosineWindow:KS,cumprod:JY,cumsum:tQ,denseBincount:rQ,depthToSpace:oQ,depthwiseConv2d:LS,diag:lQ,dilation2d:cQ,div:gt,divNoNan:mQ,dot:yQ,dropout:vte,einsum:_c,elu:rD,enclosingPowerOfTwo:PD,ensureShape:wQ,equal:nD,erf:CQ,euclideanNorm:PQ,exp:ga,expandDims:Rs,expm1:FQ,eye:iD,fft:jS,fill:Xf,floor:aD,floorDiv:XA,fused:Dte,gather:lD,gatherND:gte,greater:dy,greaterEqual:uD,ifft:Eg,imag:hy,image:Tu,inTopKAsync:wte,irfft:kD,isFinite:GQ,isInf:KQ,isNaN:qQ,leakyRelu:cD,less:mv,lessEqual:BS,linalg:fre,linspace:JQ,localResponseNormalization:tZ,log:bf,log1p:dD,logSigmoid:lZ,logSoftmax:dZ,logSumExp:fD,logicalAnd:Ig,logicalNot:pD,logicalOr:mD,logicalXor:yZ,losses:pre,lowerBound:vZ,matMul:Ht,max:Jc,maxPool:gD,maxPool3d:SZ,maxPoolWithArgmax:$Z,maximum:yD,mean:Ng,meshgrid:IZ,min:pv,minimum:wf,mirrorPad:xD,mod:_Z,moments:AZ,movingAverage:ute,mul:Te,multiRNNCell:OZ,multinomial:LZ,neg:bi,norm:cy,notEqual:vD,oneHot:MZ,ones:bu,onesLike:WZ,op:X,outerProduct:jZ,pad:vl,pad1d:KZ,pad2d:qZ,pad3d:QZ,pad4d:JZ,pool:sJ,pow:vf,prelu:wD,print:KA,prod:aJ,raggedGather:uJ,raggedRange:dJ,raggedTensorToTensor:fJ,rand:mJ,randomGamma:LJ,randomNormal:SD,randomStandardNormal:MJ,randomUniform:US,randomUniformInt:UJ,range:Sf,real:Cf,reciprocal:HJ,relu:fy,relu6:CD,reshape:ye,reverse:Ou,reverse1d:QJ,reverse2d:JJ,reverse3d:tee,reverse4d:ree,rfft:GS,round:$D,rsqrt:iee,scalar:mt,scatterND:dte,searchSorted:MS,selu:lee,separableConv2d:cee,setdiff1dAsync:hee,sigmoid:aa,sign:pee,signal:hre,sin:gee,sinh:xee,slice:pt,slice1d:bee,slice2d:See,slice3d:$ee,slice4d:Tee,softmax:Nee,softplus:hD,spaceToBatchND:bD,sparse:mre,sparseToDense:pte,spectral:dre,split:$f,sqrt:ma,square:ao,squaredDifference:TD,squeeze:Gt,stack:va,step:ID,stridedSlice:Bee,string:gre,sub:ot,sum:en,tan:Vee,tanh:fv,tensor:vi,tensor1d:ar,tensor2d:lo,tensor3d:ND,tensor4d:Wee,tensor5d:Uee,tensor6d:jee,tensorScatterUpdate:Hee,tile:Zh,topk:Xee,transpose:gv,truncatedNormal:Yee,unique:Zee,unsortedSegmentSum:ete,unstack:Mu,upperBound:nte,variable:rte,where:pl,whereAsync:_D,zeros:xa,zerosLike:Ds},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qye=(t,e,n,r=Zn)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(N("a",t,e,n),N("b",t,e,n))];case"AddN":return[r.addN(N("tensors",t,e,n))];case"FloorMod":case"Mod":return[r.mod(N("a",t,e,n),N("b",t,e,n))];case"Mul":return[r.mul(N("a",t,e,n),N("b",t,e,n))];case"RealDiv":case"Div":return[r.div(N("a",t,e,n),N("b",t,e,n))];case"DivNoNan":return[r.divNoNan(N("a",t,e,n),N("b",t,e,n))];case"FloorDiv":return[r.floorDiv(N("a",t,e,n),N("b",t,e,n))];case"Sub":return[r.sub(N("a",t,e,n),N("b",t,e,n))];case"Minimum":return[r.minimum(N("a",t,e,n),N("b",t,e,n))];case"Maximum":return[r.maximum(N("a",t,e,n),N("b",t,e,n))];case"Pow":return[r.pow(N("a",t,e,n),N("b",t,e,n))];case"SquaredDifference":return[r.squaredDifference(N("a",t,e,n),N("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yye=(t,e,n,r=Zn)=>{switch(t.op){case"Abs":case"ComplexAbs":return[r.abs(N("x",t,e,n))];case"Acos":return[r.acos(N("x",t,e,n))];case"Acosh":return[r.acosh(N("x",t,e,n))];case"Asin":return[r.asin(N("x",t,e,n))];case"Asinh":return[r.asinh(N("x",t,e,n))];case"Atan":return[r.atan(N("x",t,e,n))];case"Atan2":return[r.atan2(N("x",t,e,n),N("y",t,e,n))];case"Atanh":return[r.atanh(N("x",t,e,n))];case"Ceil":return[r.ceil(N("x",t,e,n))];case"Complex":return[r.complex(N("real",t,e,n),N("imag",t,e,n))];case"Cos":return[r.cos(N("x",t,e,n))];case"Cosh":return[r.cosh(N("x",t,e,n))];case"Elu":return[r.elu(N("x",t,e,n))];case"Erf":return[r.erf(N("x",t,e,n))];case"Exp":return[r.exp(N("x",t,e,n))];case"Expm1":return[r.expm1(N("x",t,e,n))];case"Floor":return[r.floor(N("x",t,e,n))];case"Log":return[r.log(N("x",t,e,n))];case"Log1p":return[r.log1p(N("x",t,e,n))];case"Imag":return[r.imag(N("x",t,e,n))];case"Neg":return[r.neg(N("x",t,e,n))];case"Reciprocal":return[r.reciprocal(N("x",t,e,n))];case"Real":return[r.real(N("x",t,e,n))];case"Relu":return[r.relu(N("x",t,e,n))];case"Round":return[r.round(N("x",t,e,n))];case"Selu":return[r.selu(N("x",t,e,n))];case"Sigmoid":return[r.sigmoid(N("x",t,e,n))];case"Sin":return[r.sin(N("x",t,e,n))];case"Sign":return[r.sign(N("x",t,e,n))];case"Sinh":return[r.sinh(N("x",t,e,n))];case"Softplus":return[r.softplus(N("x",t,e,n))];case"Sqrt":return[r.sqrt(N("x",t,e,n))];case"Square":return[r.square(N("x",t,e,n))];case"Tanh":return[r.tanh(N("x",t,e,n))];case"Tan":return[r.tan(N("x",t,e,n))];case"ClipByValue":return[r.clipByValue(N("x",t,e,n),N("clipValueMin",t,e,n),N("clipValueMax",t,e,n))];case"Relu6":return[r.relu6(N("x",t,e,n))];case"Rsqrt":return[r.rsqrt(Yn(t.inputNames[0],e,n))];case"LeakyRelu":return[r.leakyRelu(N("x",t,e,n),N("alpha",t,e,n))];case"Prelu":return[r.prelu(N("x",t,e,n),N("alpha",t,e,n))];case"IsNan":return[r.isNaN(Yn(t.inputNames[0],e,n))];case"IsInf":return[r.isInf(Yn(t.inputNames[0],e,n))];case"IsFinite":return[r.isFinite(Yn(t.inputNames[0],e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function no(t,e,n=""){if(!(typeof t=="number"||typeof e=="number")){z(t.length===e.length,()=>n+` Shapes ${t} and ${e} must match`);for(let r=0;r<t.length;r++){const s=t[r],o=e[r];z(s<0||o<0||s===o,()=>n+` Shapes ${t} and ${e} must match`)}}}function bN(t){return!(typeof t=="number"||t.some(e=>e<0))}function Sh(t,e,n){let r=Dv(t,n);const s=!bN(r);if(s&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&e.forEach(o=>{r=Dv(o.shape,r)}),!bN(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function Dv(t,e){if(typeof t=="number")return e;if(typeof e=="number")return t;if(t.length!==e.length)throw new Error(`Incompatible ranks during merge: ${t} vs. ${e}`);const n=[];for(let r=0;r<t.length;++r){const s=t[r],o=e[r];if(s>=0&&o>=0&&s!==o)throw new Error(`Incompatible shape during merge: ${t} vs. ${e}`);n[r]=s>=0?s:o}return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qye{constructor(e,n,r,s,o,i,a){this.name=e,this.dtype=n,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=o,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=mt(0),hi(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.tensor.id))&&n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const n=this.tensors[e];if(n.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(e){return e.map(n=>this.read(n))}write(e,n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[e]||{};if(n.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=n.shape),no(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=n,hi(n),r.written=!0,this.tensors[e]=r}writeMany(e,n){if(e.length!==n.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${n.length}.`);e.forEach((r,s)=>this.write(r,n[s]))}gather(e,n){if(n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);if(e)e=e.slice(0,this.size());else{e=[];for(let s=0;s<this.size();s++)e.push(s)}if(e.length===0)return vi([],[0].concat(this.elementShape));const r=this.readMany(e);return no(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),va(r,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return vi([],[0].concat(this.elementShape));const n=[];for(let s=0;s<this.size();s++)n.push(s);const r=this.readMany(n);return no(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),Fn(r,0)}scatter(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,Mu(n,0))}split(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);let r=0;const s=e.map(l=>(r+=l,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const o=r===0?0:n.size/r,i=[];nt(()=>{n=ye(n,[1,r,o]);for(let l=0;l<e.length;++l){const d=[0,l===0?0:s[l-1],0],f=[1,e[l],o];i[l]=ye(pt(n,d,f),this.elementShape)}return i});const a=[];for(let l=0;l<e.length;l++)a[l]=l;this.writeMany(a,i)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zu{get id(){return this.idTensor.id}constructor(e,n,r,s=-1){this.tensors=e,this.elementShape=n,this.elementDtype=r,e!=null&&e.forEach(o=>{if(r!==o.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${o.dtype}`);no(n,o.shape,"TensorList shape mismatch: "),hi(o)}),this.idTensor=mt(0),this.maxNumElements=s,hi(this.idTensor)}copy(){return new zu([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,n,r=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);no(e,this.elementShape,"TensorList shape mismatch: ");const s=Sh(this.elementShape,this.tensors,e);return nt(()=>{const o=this.tensors.map(i=>ye(i,s));return va(o,0)})}popBack(e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=Sh(this.elementShape,this.tensors,e),s=this.tensors.pop();return s.kept=!1,no(s.shape,e,"TensorList shape mismatch: "),ye(s,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(no(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");hi(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const n=new zu([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)n.tensors[r]=this.tensors[r];return n}getItem(e,n,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);no(this.tensors[e].shape,n,"TensorList shape mismatch: ");const s=Sh(this.elementShape,this.tensors,n);return ye(this.tensors[e],s)}setItem(e,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);no(this.elementShape,n.shape,"TensorList shape mismatch: "),hi(n),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=n}gather(e,n,r){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);no(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());const s=Sh(this.elementShape,this.tensors,r);return e.length===0?vi([],[0].concat(s)):nt(()=>{const o=e.map(i=>ye(this.tensors[i],s));return va(o,0)})}concat(e,n){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);no(this.elementShape,n,"TensorList shape mismatch: ");const r=Sh(this.elementShape,this.tensors,n);return this.size()===0?vi([],[0].concat(r)):nt(()=>{const s=this.tensors.map(o=>ye(o,r));return Fn(s,0)})}}function Zye(t,e,n){const r=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==n)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);const s=t.shape.slice(1);no(s,e,"TensorList shape mismatch: ");const o=Mu(t);return new zu(o,e,r)}function Jye(t,e,n,r){return new zu([],t,e,r)}function e0e(t,e,n,r){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const o=new zu([],n,t.dtype,r),i=Mu(t,0);return e.forEach((a,l)=>{o.setItem(a,i[l])}),o}function t0e(t,e,n){let r=0;const s=e.map(d=>(r+=d,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);const o=t.shape.slice(1),i=Dv(o,n),a=r===0?0:t.size/r,l=nt(()=>{const d=[];t=ye(t,[1,r,a]);for(let f=0;f<e.length;++f){const g=[0,f===0?0:s[f-1],0],y=[1,e[f],a];d[f]=ye(pt(t,g,y),i)}return t.dispose(),d}),c=new zu([],n,t.dtype,e.length);for(let d=0;d<l.length;d++)c.setItem(d,l[d]);return c}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n0e=async(t,e,n)=>{switch(t.op){case"If":case"StatelessIf":{const r=N("thenBranch",t,e,n),s=N("elseBranch",t,e,n),o=N("cond",t,e,n),i=N("args",t,e,n);return(await o.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=N("body",t,e,n),s=N("cond",t,e,n),o=N("args",t,e,n),i=await n.functionMap[s].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap),a=o.map(d=>d.id);let l=await i[0].data();i.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&d.dispose()});let c=o;for(;l[0];){const d=c;c=await n.functionMap[r].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);const f=c.map(g=>g.id);d.forEach(g=>{!g.kept&&a.indexOf(g.id)===-1&&f.indexOf(g.id)===-1&&g.dispose()});const p=await n.functionMap[s].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);l=await p[0].data(),p.forEach(g=>{!g.kept&&a.indexOf(g.id)===-1&&f.indexOf(g.id)===-1&&g.dispose()})}return c}case"LoopCond":{const r=N("pred",t,e,n);return[Zi(r)]}case"Switch":{const r=N("pred",t,e,n);let s=N("data",t,e,n);return s.kept||(s=Zi(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=t.inputNames.find(s=>Yn(s,e,n)!==void 0);if(r){const s=Yn(r,e,n);return[Zi(s)]}return}case"Enter":{const r=N("frameName",t,e,n),s=N("tensor",t,e,n);return n.enterFrame(r),[Zi(s)]}case"Exit":{const r=N("tensor",t,e,n);return n.exitFrame(),[Zi(r)]}case"NextIteration":{const r=N("tensor",t,e,n);return n.nextIteration(),[Zi(r)]}case"TensorArrayV3":{const r=N("size",t,e,n),s=N("dtype",t,e,n),o=N("elementShape",t,e,n),i=N("dynamicSize",t,e,n),a=N("clearAfterRead",t,e,n),l=N("identicalElementShapes",t,e,n),c=N("name",t,e,n),d=new Qye(c,s,r,o,l,i,a);return n.addTensorArray(d),[d.idTensor,mt(1)]}case"TensorArrayWriteV3":{const r=N("tensorArrayId",t,e,n),s=N("index",t,e,n),o=N("tensor",t,e,n),i=n.getTensorArray(r.id);return i.write(s,o),[i.idTensor]}case"TensorArrayReadV3":{const r=N("tensorArrayId",t,e,n),s=N("index",t,e,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=N("tensorArrayId",t,e,n),s=N("indices",t,e,n),o=N("dtype",t,e,n);return[n.getTensorArray(r.id).gather(s,o)]}case"TensorArrayScatterV3":{const r=N("tensorArrayId",t,e,n),s=N("indices",t,e,n),o=N("tensor",t,e,n),i=n.getTensorArray(r.id);return i.scatter(s,o),[i.idTensor]}case"TensorArrayConcatV3":{const r=N("tensorArrayId",t,e,n),s=n.getTensorArray(r.id),o=N("dtype",t,e,n);return[s.concat(o)]}case"TensorArraySplitV3":{const r=N("tensorArrayId",t,e,n),s=N("tensor",t,e,n),o=N("lengths",t,e,n),i=n.getTensorArray(r.id);return i.split(o,s),[i.idTensor]}case"TensorArraySizeV3":{const r=N("tensorArrayId",t,e,n),s=n.getTensorArray(r.id);return[mt(s.size(),"int32")]}case"TensorArrayCloseV3":{const r=N("tensorArrayId",t,e,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=N("tensorListId",t,e,n),s=N("index",t,e,n),o=N("tensor",t,e,n),i=n.getTensorList(r.id);return i.setItem(s,o),[i.idTensor]}case"TensorListGetItem":{const r=N("tensorListId",t,e,n),s=N("index",t,e,n),o=N("elementShape",t,e,n),i=N("elementDType",t,e,n);return[n.getTensorList(r.id).getItem(s,o,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=N("indices",t,e,n),s=N("tensor",t,e,n),o=N("elementShape",t,e,n),i=N("numElements",t,e,n),a=e0e(s,r,o,i);return n.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=N("elementShape",t,e,n),s=N("elementDType",t,e,n);let o;t.op==="TensorListReserve"?o="numElements":o="maxNumElements";const i=N(o,t,e,n),a=t.op==="TensorListReserve"?-1:i,l=Jye(r,s,i,a);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{const r=N("tensorListId",t,e,n),s=N("indices",t,e,n),o=N("elementShape",t,e,n),i=N("elementDType",t,e,n);return[n.getTensorList(r.id).gather(s,i,o)]}case"TensorListStack":{const r=N("tensorListId",t,e,n),s=N("elementShape",t,e,n),o=N("elementDType",t,e,n),i=N("numElements",t,e,n);return[n.getTensorList(r.id).stack(s,o,i)]}case"TensorListFromTensor":{const r=N("tensor",t,e,n),s=N("elementShape",t,e,n),o=N("elementDType",t,e,n),i=Zye(r,s,o);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=N("tensorListId",t,e,n),s=n.getTensorList(r.id),o=N("dtype",t,e,n),i=N("elementShape",t,e,n);return[s.concat(o,i)]}case"TensorListPushBack":{const r=N("tensorListId",t,e,n),s=N("tensor",t,e,n),o=n.getTensorList(r.id);return o.pushBack(s),[o.idTensor]}case"TensorListPopBack":{const r=N("tensorListId",t,e,n),s=N("elementShape",t,e,n),o=N("elementDType",t,e,n);return[n.getTensorList(r.id).popBack(s,o)]}case"TensorListSplit":{const r=N("tensor",t,e,n),s=N("elementShape",t,e,n),o=N("lengths",t,e,n),i=t0e(r,o,s);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{const r=N("tensorListId",t,e,n),s=n.getTensorList(r.id);return[mt(s.size(),"int32")]}case"TensorListResize":{const r=N("tensorListId",t,e,n),s=N("size",t,e,n),i=n.getTensorList(r.id).resize(s);return n.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wN(t,e,n){const[r,s]=N("fusedOps",t,e,n),o=r==="biasadd",i=!o,a=s==="prelu",l=r==="fusedbatchnorm",c=N("numArgs",t,e,n);if(o){if(a&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&o&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const d=N("strides",t,e,n),f=eg(t,e,n),p=N("dataFormat",t,e,n).toUpperCase(),g=N("dilations",t,e,n);let[y,x]=N("args",t,e,n);i&&(x=y,y=void 0);const w=N("leakyreluAlpha",t,e,n);return{stride:d,pad:f,dataFormat:p,dilations:g,biasArg:y,preluArg:x,activationFunc:s,leakyreluAlpha:w}}const r0e=(t,e,n,r=Zn)=>{switch(t.op){case"Conv1D":{const s=N("stride",t,e,n),o=N("pad",t,e,n),i=N("dataFormat",t,e,n).toUpperCase(),a=N("dilation",t,e,n);return[r.conv1d(N("x",t,e,n),N("filter",t,e,n),s,o,i,a)]}case"Conv2D":{const s=N("strides",t,e,n),o=eg(t,e,n),i=N("dataFormat",t,e,n).toUpperCase(),a=N("dilations",t,e,n);return[r.conv2d(N("x",t,e,n),N("filter",t,e,n),[s[1],s[2]],o,i,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:s,pad:o,dataFormat:i,dilations:a,biasArg:l,preluArg:c,activationFunc:d,leakyreluAlpha:f}=wN(t,e,n);return[r.fused.conv2d({x:N("x",t,e,n),filter:N("filter",t,e,n),strides:[s[1],s[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:d,preluActivationWeights:c,leakyreluAlpha:f})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:o,dataFormat:i,dilations:a,biasArg:l,preluArg:c,activationFunc:d,leakyreluAlpha:f}=wN(t,e,n);return[r.fused.depthwiseConv2d({x:N("x",t,e,n),filter:N("filter",t,e,n),strides:[s[1],s[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:d,preluActivationWeights:c,leakyreluAlpha:f})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=N("outputShape",t,e,n),o=N("strides",t,e,n),i=eg(t,e,n);return[r.conv2dTranspose(N("x",t,e,n),N("filter",t,e,n),s,[o[1],o[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=N("strides",t,e,n),o=eg(t,e,n),i=N("dilations",t,e,n),a=N("dataFormat",t,e,n).toUpperCase();return[r.depthwiseConv2d(N("input",t,e,n),N("filter",t,e,n),[s[1],s[2]],o,a,[i[1],i[2]])]}case"Conv3D":{const s=N("strides",t,e,n),o=N("pad",t,e,n),i=N("dataFormat",t,e,n).toUpperCase(),a=N("dilations",t,e,n);return[r.conv3d(N("x",t,e,n),N("filter",t,e,n),[s[1],s[2],s[3]],o,i,[a[1],a[2],a[3]])]}case"AvgPool":{const s=N("strides",t,e,n),o=N("pad",t,e,n),i=N("kernelSize",t,e,n);return[r.avgPool(N("x",t,e,n),[i[1],i[2]],[s[1],s[2]],o)]}case"MaxPool":{const s=N("strides",t,e,n),o=N("pad",t,e,n),i=N("kernelSize",t,e,n);return[r.maxPool(N("x",t,e,n),[i[1],i[2]],[s[1],s[2]],o)]}case"MaxPoolWithArgmax":{const s=N("strides",t,e,n),o=N("pad",t,e,n),i=N("kernelSize",t,e,n),a=N("includeBatchInIndex",t,e,n),{result:l,indexes:c}=r.maxPoolWithArgmax(N("x",t,e,n),[i[1],i[2]],[s[1],s[2]],o,a);return[l,c]}case"AvgPool3D":{const s=N("strides",t,e,n),o=N("pad",t,e,n),i=N("kernelSize",t,e,n);return[r.avgPool3d(N("x",t,e,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],o)]}case"MaxPool3D":{const s=N("strides",t,e,n),o=N("pad",t,e,n),i=N("kernelSize",t,e,n);return[r.maxPool3d(N("x",t,e,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],o)]}case"Dilation2D":{const s=N("strides",t,e,n),o=N("pad",t,e,n),i=N("dilations",t,e,n),a=s[1],l=s[2],c=i[1],d=i[2];return[r.dilation2d(N("x",t,e,n),N("filter",t,e,n),[a,l],o,[c,d],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s0e=(t,e,n,r=Zn)=>{switch(t.op){case"Fill":{const s=N("shape",t,e,n),o=N("dtype",t,e,n),i=N("value",t,e,n);return[r.fill(s,i,o)]}case"LinSpace":{const s=N("start",t,e,n),o=N("stop",t,e,n),i=N("num",t,e,n);return[r.linspace(s,o,i)]}case"Multinomial":{const s=N("logits",t,e,n),o=N("numSamples",t,e,n),i=N("seed",t,e,n);return[r.multinomial(s,o,i)]}case"OneHot":{const s=N("indices",t,e,n),o=N("depth",t,e,n),i=N("onValue",t,e,n),a=N("offValue",t,e,n),l=N("dtype",t,e,n);return[r.oneHot(s,o,i,a,l)]}case"Ones":return[r.ones(N("shape",t,e,n),N("dtype",t,e,n))];case"OnesLike":return[r.onesLike(N("x",t,e,n))];case"RandomStandardNormal":return[r.randomStandardNormal(N("shape",t,e,n),N("dtype",t,e,n),N("seed",t,e,n))];case"RandomUniform":return[r.randomUniform(N("shape",t,e,n),N("minval",t,e,n),N("maxval",t,e,n),N("dtype",t,e,n))];case"RandomUniformInt":return[r.randomUniformInt(N("shape",t,e,n),N("minval",t,e,n),N("maxval",t,e,n),N("seed",t,e,n))];case"Range":{const s=N("start",t,e,n),o=N("stop",t,e,n),i=N("step",t,e,n);return[r.range(s,o,i,N("dtype",t,e,n))]}case"TruncatedNormal":{const s=N("shape",t,e,n),o=N("mean",t,e,n),i=N("stdDev",t,e,n),a=N("seed",t,e,n);return[r.truncatedNormal(s,o,i,N("dtype",t,e,n),a)]}case"Zeros":return[r.zeros(N("shape",t,e,n),N("dtype",t,e,n))];case"ZerosLike":return[r.zerosLike(N("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rx(t,e,n){const r=N("boxes",t,e,n),s=N("scores",t,e,n),o=N("maxOutputSize",t,e,n),i=N("iouThreshold",t,e,n),a=N("scoreThreshold",t,e,n),l=N("softNmsSigma",t,e,n);return{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:a,softNmsSigma:l}}const o0e=async(t,e,n,r,s=Zn)=>{switch(t.op){case"NonMaxSuppressionV5":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:l,scoreThreshold:c,softNmsSigma:d}=rx(t,e,n),f=await s.image.nonMaxSuppressionWithScoreAsync(o,i,a,l,c,d);return[f.selectedIndices,f.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=rx(t,e,n),d=N("padToMaxOutputSize",t,e,n),f=await s.image.nonMaxSuppressionPaddedAsync(o,i,a,l,c,d);return[f.selectedIndices,f.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=rx(t,e,n);return[await s.image.nonMaxSuppressionAsync(o,i,a,l,c)]}case"Where":{const o=s.cast(N("condition",t,e,n),"bool"),i=[await s.whereAsync(o)];return o.dispose(),i}case"ListDiff":return s.setdiff1dAsync(N("x",t,e,n),N("y",t,e,n));default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i0e=(t,e,n,r=Zn)=>{switch(t.op){case"LowerBound":{const s=N("sortedSequence",t,e,n),o=N("values",t,e,n);return[r.lowerBound(s,o)]}case"TopKV2":{const s=N("x",t,e,n),o=N("k",t,e,n),i=N("sorted",t,e,n),a=r.topk(s,o,i);return[a.values,a.indices]}case"UpperBound":{const s=N("sortedSequence",t,e,n),o=N("values",t,e,n);return[r.upperBound(s,o)]}case"Unique":{const s=N("x",t,e,n),o=r.unique(s);return[o.values,o.indices]}case"UniqueV2":{const s=N("x",t,e,n),o=N("axis",t,e,n),i=r.unique(s,o);return[i.values,i.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a0e=(t,e,n,r=Zn)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":const s=N("default",t,e,n);return[Yn(t.name,e,n)||s];case"Placeholder":return[Yn(t.name,e,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const d=N("x",t,e,n);return[Zi(d)]}case"IdentityN":return N("x",t,e,n).map(d=>Zi(d));case"Snapshot":const o=N("x",t,e,n);return[Zi(o)];case"Shape":return[r.tensor1d(N("x",t,e,n).shape,"int32")];case"ShapeN":return N("x",t,e,n).map(d=>r.tensor1d(d.shape));case"Size":return[r.scalar(N("x",t,e,n).size,"int32")];case"Rank":return[r.scalar(N("x",t,e,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const i=N("x",t,e,n),a=N("data",t,e,n),l=N("message",t,e,n),c=N("summarize",t,e,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let d=0;d<a.length;d++)console.log(Array.prototype.slice.call(a[d].dataSync()).slice(0,c));return[i];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class l0e{get id(){return this.handle.id}constructor(e,n){this.keyDType=e,this.valueDType=n,this.handle=mt(0),this.tensorMap=new Map,hi(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return mt(this.size(),"int32")}async import(e,n){this.checkKeyAndValueTensor(e,n);const r=await e.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),nt(()=>{const s=Mu(n),o=r.length,i=s.length;z(o===i,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${i} elements.`);for(let a=0;a<o;a++){const l=r[a],c=s[a];hi(c),this.tensorMap.set(l,c)}return this.handle})}async find(e,n){this.checkKeyAndValueTensor(e,n);const r=await e.data();return nt(()=>{const s=[];for(let o=0;o<r.length;o++){const i=r[o],a=this.findWithDefault(i,n);s.push(a)}return va(s)})}findWithDefault(e,n){const r=this.tensorMap.get(e);return r??n}checkKeyAndValueTensor(e,n){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(n.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u0e=async(t,e,n,r)=>{switch(t.op){case"HashTable":case"HashTableV2":{const s=r.getHashTableHandleByName(t.name);if(s!=null)return[s];{const o=N("keyDType",t,e,n),i=N("valueDType",t,e,n),a=new l0e(o,i);return r.addHashTable(t.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=N("tableHandle",t,e,n,r),o=N("keys",t,e,n),i=N("values",t,e,n);return[await r.getHashTableById(s.id).import(o,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=N("tableHandle",t,e,n,r),o=N("keys",t,e,n),i=N("defaultValue",t,e,n);return[await r.getHashTableById(s.id).find(o,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=N("tableHandle",t,e,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c0e=(t,e,n,r=Zn)=>{switch(t.op){case"ResizeBilinear":{const s=N("images",t,e,n),o=N("size",t,e,n),i=N("alignCorners",t,e,n),a=N("halfPixelCenters",t,e,n);return[r.image.resizeBilinear(s,[o[0],o[1]],i,a)]}case"ResizeNearestNeighbor":{const s=N("images",t,e,n),o=N("size",t,e,n),i=N("alignCorners",t,e,n),a=N("halfPixelCenters",t,e,n);return[r.image.resizeNearestNeighbor(s,[o[0],o[1]],i,a)]}case"CropAndResize":{const s=N("image",t,e,n),o=N("boxes",t,e,n),i=N("boxInd",t,e,n),a=N("cropSize",t,e,n),l=N("method",t,e,n),c=N("extrapolationValue",t,e,n);return[r.image.cropAndResize(s,o,i,a,l,c)]}case"ImageProjectiveTransformV3":{const s=N("images",t,e,n),o=N("transforms",t,e,n),i=N("outputShape",t,e,n),a=N("fillValue",t,e,n),l=N("interpolation",t,e,n),c=N("fillMode",t,e,n);return[r.image.transform(s,o,l.toLowerCase(),c.toLowerCase(),a,i)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d0e=(t,e,n,r=Zn)=>{switch(t.op){case"Equal":return[r.equal(N("a",t,e,n),N("b",t,e,n))];case"NotEqual":return[r.notEqual(N("a",t,e,n),N("b",t,e,n))];case"Greater":return[r.greater(N("a",t,e,n),N("b",t,e,n))];case"GreaterEqual":return[r.greaterEqual(N("a",t,e,n),N("b",t,e,n))];case"Less":return[r.less(N("a",t,e,n),N("b",t,e,n))];case"LessEqual":return[r.lessEqual(N("a",t,e,n),N("b",t,e,n))];case"LogicalAnd":return[r.logicalAnd(N("a",t,e,n),N("b",t,e,n))];case"LogicalNot":return[r.logicalNot(N("a",t,e,n))];case"LogicalOr":return[r.logicalOr(N("a",t,e,n),N("b",t,e,n))];case"Select":case"SelectV2":return[r.where(N("condition",t,e,n),N("a",t,e,n),N("b",t,e,n))];case"BitwiseAnd":return[r.bitwiseAnd(N("a",t,e,n),N("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h0e=(t,e,n,r=Zn)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(N("a",t,e,n),N("b",t,e,n),N("transposeA",t,e,n),N("transposeB",t,e,n))];case"Einsum":return[r.einsum(N("equation",t,e,n),...N("tensors",t,e,n))];case"Transpose":return[r.transpose(N("x",t,e,n),N("perm",t,e,n))];case"_FusedMatMul":const[s,o]=N("fusedOps",t,e,n),i=s==="biasadd",a=o==="prelu",l=N("numArgs",t,e,n),c=N("leakyreluAlpha",t,e,n);if(i){if(a&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[d,f]=N("args",t,e,n);return[r.fused.matMul({a:N("a",t,e,n),b:N("b",t,e,n),transposeA:N("transposeA",t,e,n),transposeB:N("transposeB",t,e,n),bias:d,activation:o,preluActivationWeights:f,leakyreluAlpha:c})];case"MatrixBandPart":return[r.linalg.bandPart(N("a",t,e,n),N("numLower",t,e,n),N("numUpper",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f0e=(t,e,n,r=Zn)=>{switch(t.op){case"EuclideanNorm":return[r.euclideanNorm(N("x",t,e,n),N("axis",t,e,n),N("keepDims",t,e,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(N("x",t,e,n),N("mean",t,e,n),N("variance",t,e,n),N("offset",t,e,n),N("scale",t,e,n),N("epsilon",t,e,n))];case"FusedBatchNormV3":return[r.batchNorm(N("x",t,e,n),N("mean",t,e,n),N("variance",t,e,n),N("offset",t,e,n),N("scale",t,e,n),N("epsilon",t,e,n))];case"LRN":return[r.localResponseNormalization(N("x",t,e,n),N("radius",t,e,n),N("bias",t,e,n),N("alpha",t,e,n),N("beta",t,e,n))];case"Softmax":return[r.softmax(N("x",t,e,n))];case"LogSoftmax":return[r.logSoftmax(N("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p0e=(t,e,n,r=Zn)=>{switch(t.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:o}=r.raggedGather(N("paramsNestedSplits",t,e,n),N("paramsDenseValues",t,e,n),N("indices",t,e,n),N("outputRaggedRank",t,e,n));return s.concat(o)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:o}=r.raggedRange(N("starts",t,e,n),N("limits",t,e,n),N("splits",t,e,n));return[s,o]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(N("shape",t,e,n),N("values",t,e,n),N("defaultValue",t,e,n),N("rowPartitionTensors",t,e,n),N("rowPartitionTypes",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m0e=(t,e,n,r=Zn)=>{switch(t.op){case"Max":{const a=N("axis",t,e,n),l=N("keepDims",t,e,n);return[r.max(N("x",t,e,n),a,l)]}case"Mean":{const a=N("axis",t,e,n),l=N("keepDims",t,e,n);return[r.mean(N("x",t,e,n),a,l)]}case"Min":{const a=N("axis",t,e,n),l=N("keepDims",t,e,n);return[r.min(N("x",t,e,n),a,l)]}case"Sum":{const a=N("axis",t,e,n),l=N("keepDims",t,e,n);return[r.sum(N("x",t,e,n),a,l)]}case"All":{const a=N("axis",t,e,n),l=N("keepDims",t,e,n);return[r.all(N("x",t,e,n),a,l)]}case"Any":{const a=N("axis",t,e,n),l=N("keepDims",t,e,n);return[r.any(N("x",t,e,n),a,l)]}case"ArgMax":{const a=N("axis",t,e,n);return[r.argMax(N("x",t,e,n),a)]}case"ArgMin":{const a=N("axis",t,e,n);return[r.argMin(N("x",t,e,n),a)]}case"Prod":{const a=N("axis",t,e,n),l=N("keepDims",t,e,n);return[r.prod(N("x",t,e,n),a,l)]}case"Cumprod":{const a=N("axis",t,e,n),l=N("exclusive",t,e,n),c=N("reverse",t,e,n);return[r.cumprod(N("x",t,e,n),a,l,c)]}case"Cumsum":{const a=N("axis",t,e,n),l=N("exclusive",t,e,n),c=N("reverse",t,e,n);return[r.cumsum(N("x",t,e,n),a,l,c)]}case"Bincount":const s=N("x",t,e,n),o=N("weights",t,e,n),i=N("size",t,e,n);return[r.bincount(s,o,i)];case"DenseBincount":{const a=N("x",t,e,n),l=N("weights",t,e,n),c=N("size",t,e,n),d=N("binaryOutput",t,e,n);return[r.denseBincount(a,l,c,d)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g0e=(t,e,n,r=Zn)=>{switch(t.op){case"ConcatV2":case"Concat":{const s=N("n",t,e,n),o=N("axis",t,e,n);let i=N("tensors",t,e,n);return i=i.slice(0,s),[r.concat(i,o)]}case"Gather":{const s=N("x",t,e,n),o=N("indices",t,e,n);return[r.gather(s,r.cast(o,"int32"),0)]}case"GatherV2":{const s=N("axis",t,e,n),o=N("batchDims",t,e,n),i=N("x",t,e,n),a=N("indices",t,e,n);return[r.gather(i,r.cast(a,"int32"),s,o)]}case"Reverse":{const s=N("dims",t,e,n),o=[];for(let a=0;a<s.length;a++)s[a]&&o.push(a);const i=N("x",t,e,n);return[r.reverse(i,o)]}case"ReverseV2":{const s=N("axis",t,e,n),o=N("x",t,e,n);return[r.reverse(o,s)]}case"Slice":{const s=N("begin",t,e,n),o=N("size",t,e,n);return[r.slice(N("x",t,e,n),s,o)]}case"StridedSlice":{const s=N("begin",t,e,n),o=N("end",t,e,n),i=N("strides",t,e,n),a=N("beginMask",t,e,n),l=N("endMask",t,e,n),c=N("ellipsisMask",t,e,n),d=N("newAxisMask",t,e,n),f=N("shrinkAxisMask",t,e,n),p=N("x",t,e,n);return[r.stridedSlice(p,s,o,i,a,l,c,d,f)]}case"Pack":return nt(()=>{const s=N("axis",t,e,n),o=N("tensors",t,e,n),i=o[0].shape,a=r.squeeze(o[0]).shape,l=o.map(c=>{const d=Vt(c.shape,i);if(!d&&!Vt(r.squeeze(c).shape,a))throw new Error("the input tensors shape does not match");return d?c:r.reshape(c,i)});return[r.stack(l,s)]});case"Unpack":{const s=N("axis",t,e,n),o=N("tensor",t,e,n);return r.unstack(o,s)}case"Tile":{const s=N("reps",t,e,n);return[r.tile(N("x",t,e,n),s)]}case"Split":case"SplitV":{const s=N("axis",t,e,n),o=N("numOrSizeSplits",t,e,n),i=N("x",t,e,n);return r.split(i,o,s)}case"ScatterNd":{const s=N("indices",t,e,n),o=N("values",t,e,n),i=N("shape",t,e,n);return[r.scatterND(s,o,i)]}case"GatherNd":{const s=N("x",t,e,n),o=N("indices",t,e,n);return[r.gatherND(s,o)]}case"SparseToDense":{const s=N("sparseIndices",t,e,n),o=N("outputShape",t,e,n),i=N("sparseValues",t,e,n),a=N("defaultValue",t,e,n);return[r.sparseToDense(s,i,o,i.dtype===a.dtype?a:r.cast(a,i.dtype))]}case"TensorScatterUpdate":{const s=N("indices",t,e,n),o=N("values",t,e,n),i=N("tensor",t,e,n);return[r.tensorScatterUpdate(i,s,o)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y0e=(t,e,n,r=Zn)=>{switch(t.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:o,emptyRowIndicator:i,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(N("indices",t,e,n),N("values",t,e,n),N("denseShape",t,e,n),N("defaultValue",t,e,n));return[s,o,i,a]}case"SparseReshape":{const{outputIndices:s,outputShape:o}=r.sparse.sparseReshape(N("inputIndices",t,e,n),N("inputShape",t,e,n),N("newShape",t,e,n));return[s,o]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(N("data",t,e,n),N("indices",t,e,n),N("segmentIds",t,e,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(N("data",t,e,n),N("indices",t,e,n),N("segmentIds",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x0e=(t,e,n,r=Zn)=>{switch(t.op){case"FFT":return[r.fft(N("x",t,e,n))];case"IFFT":return[r.ifft(N("x",t,e,n))];case"RFFT":return[r.rfft(N("x",t,e,n))];case"IRFFT":return[r.irfft(N("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v0e=(t,e,n,r=Zn)=>{switch(t.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(N("input",t,e,n),N("pattern",t,e,n),N("rewrite",t,e,n),N("replaceGlobal",t,e,n))];case"StringNGrams":{const{nGrams:s,nGramsSplits:o}=r.string.stringNGrams(N("data",t,e,n),N("dataSplits",t,e,n),N("separator",t,e,n),N("nGramWidths",t,e,n),N("leftPad",t,e,n),N("rightPad",t,e,n),N("padWidth",t,e,n),N("preserveShortSequences",t,e,n));return[s,o]}case"StringSplit":{const{indices:s,values:o,shape:i}=r.string.stringSplit(N("input",t,e,n),N("delimiter",t,e,n),N("skipEmpty",t,e,n));return[s,o,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(N("input",t,e,n),N("numBuckets",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b0e=(t,e,n,r=Zn)=>{switch(t.op){case"Cast":return[r.cast(N("x",t,e,n),N("dtype",t,e,n))];case"ExpandDims":{const s=N("axis",t,e,n);return[r.expandDims(N("x",t,e,n),s)]}case"Squeeze":{const s=N("axis",t,e,n);return[r.squeeze(N("x",t,e,n),s)]}case"Reshape":return[r.reshape(N("x",t,e,n),N("shape",t,e,n))];case"EnsureShape":return[r.ensureShape(N("x",t,e,n),N("shape",t,e,n))];case"MirrorPad":return[r.mirrorPad(N("x",t,e,n),N("padding",t,e,n),N("mode",t,e,n))];case"PadV2":case"Pad":return[r.pad(N("x",t,e,n),N("padding",t,e,n),N("constantValue",t,e,n))];case"SpaceToBatchND":{const s=N("blockShape",t,e,n),o=N("paddings",t,e,n);return[r.spaceToBatchND(N("x",t,e,n),s,o)]}case"BatchToSpaceND":{const s=N("blockShape",t,e,n),o=N("crops",t,e,n);return[r.batchToSpaceND(N("x",t,e,n),s,o)]}case"DepthToSpace":{const s=N("blockSize",t,e,n),o=N("dataFormat",t,e,n).toUpperCase();return[r.depthToSpace(N("x",t,e,n),s,o)]}case"BroadcastTo":return[r.broadcastTo(N("x",t,e,n),N("shape",t,e,n))];case"BroadcastArgs":return[r.broadcastArgs(N("s0",t,e,n),N("s1",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SN(t,e,n,r,s=nt){const o=((i,a,l)=>{switch(i.category){case"arithmetic":return s(()=>qye(i,a,l));case"basic_math":return s(()=>Yye(i,a,l));case"control":return n0e(i,a,l);case"convolution":return s(()=>r0e(i,a,l));case"creation":return s(()=>s0e(i,a,l));case"dynamic":return o0e(i,a,l);case"evaluation":return s(()=>i0e(i,a,l));case"image":return s(()=>c0e(i,a,l));case"graph":return s(()=>a0e(i,a,l));case"logical":return s(()=>d0e(i,a,l));case"matrices":return s(()=>h0e(i,a,l));case"normalization":return s(()=>f0e(i,a,l));case"ragged":return s(()=>p0e(i,a,l));case"reduction":return s(()=>m0e(i,a,l));case"slice_join":return s(()=>g0e(i,a,l));case"sparse":return s(()=>y0e(i,a,l));case"spectral":return s(()=>x0e(i,a,l));case"string":return s(()=>v0e(i,a,l));case"transformation":return s(()=>b0e(i,a,l));case"hash_table":return u0e(i,a,l,r);case"custom":const c=uF(i.op);if(c&&c.customExecutor)return c.customExecutor(new Xye(i,a,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,n);return Ru(o)?o.then(i=>[].concat(i)):[].concat(o)}class CN{constructor(e={},n={},r={},s={},o){this.weightMap=e,this.tensorArrayMap=n,this.tensorListMap=r,this.functionMap=s,this.parseNodeNameCache=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,n){return{id:e,frameName:n,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let n=0;n<this.contexts.length-1;n++){const r=this.contexts.slice(0,this.contexts.length-n);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(n=>n.id===0&&n.iterationId===0?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(e);for(const n in this.tensorListMap)this.tensorListMap[n].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $N(t,e,n,r){const s=new Set,o=[];let i=null,a=null;const l=new Set,c=new Set(Object.keys(t).map(p=>cs(p)[0]));r=r||[];const d=new Set(r.map(p=>cs(p.name)[0])),f=[...e];for(;f.length>0;){const p=f.pop();if((pu(p)||N0e(p)||E0e(p))&&i==null&&(i=p,a=i.children.map(g=>g.name).filter(g=>s.has(g))),s.add(p.name),n[p.name]==null&&!c.has(p.name)&&!d.has(p.name)){if(p.inputs.length===0){o.push(p.name);continue}p.inputs.forEach(g=>{l.has(g.name)||(l.add(g.name),f.push(g))})}}return{inputs:t,outputs:e,usedNodes:s,missingInputs:o,dynamicNode:i,syncInputs:a}}function w0e(t,e){const{usedNodes:n,inputs:r}=e,s=Object.keys(r).map(w=>cs(w)[0]).map(w=>t.nodes[w]),o=t.initNodes||[],i=w=>n.has(typeof w=="string"?w:w.name);function a(w){return[...new Map(w.map(S=>[S.name,S])).values()]}const l=a([...s,...t.weights,...o]).filter(i),c=a([...l,...Object.values(t.nodes)]).filter(i),d=new Map(c.map(w=>[w.name,w])),f={};for(const w of c){f[w.name]=f[w.name]||0;for(const S of w.children)i(S)||(f[S.name]=Number.POSITIVE_INFINITY),f[S.name]=(f[S.name]||0)+1}const p=Object.entries(f).filter(([,w])=>w===0).map(([w])=>w),g=[...p];for(;p.length>0;){const w=p.pop(),S=d.get(w);for(const $ of S.children.filter(i))--f[$.name]===0&&(g.push($.name),p.push($.name))}const y=g.map(w=>d.get(w)),x=S0e(y,l);return C0e(x,l),x}function S0e(t,e){const n=new Map(t.map(i=>[i.name,i])),r=e.map(i=>i.name),s=new Set(r);for(;r.length>0;){const i=r.pop(),a=n.get(i);for(const l of a.children)!n.has(l.name)||s.has(l.name)||(s.add(l.name),r.push(l.name))}return t.filter(i=>s.has(i.name))}class Nm extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function C0e(t,e){const n=new Map(t.map((a,l)=>[a.name,l])),r=new Set(e.map(a=>a.name)),s=a=>r.has(typeof a=="string"?a:a.name),o=new Set(t.map(a=>a.name)),i=a=>o.has(typeof a=="string"?a:a.name);for(const a of t){for(const l of a.children.filter(i)){if(!n.has(l.name))throw new Nm(`Child ${l.name} of node ${a.name} is unreachable.`);if(n.get(a.name)>n.get(l.name))throw new Nm(`Node ${a.name} is scheduled to run after its child ${l.name}.`)}if(!s(a))for(const l of a.inputs){if(!n.has(l.name))throw new Nm(`Input ${l.name} of node ${a.name} is unreachable.`);if(n.get(l.name)>n.get(a.name))throw new Nm(`Node ${a.name} is scheduled to run before its input ${l.name}.`)}}}function $0e(t){const e=new Map(t.map((a,l)=>[a.name,l])),n=Number.MAX_SAFE_INTEGER,r=t.map((a,l)=>pu(a)?n:l),s=a=>{const l=r[e.get(a.name)];return l??-1},o=t.map((a,l)=>a.children.map(s).reduce((c,d)=>Math.max(c,d),r[l])),i=new Map;for(let a=0;a<t.length;++a){const l=o[a];if(l===n)continue;const c=t[a],d=t[l];i.has(d.name)||i.set(d.name,[]),i.get(d.name).push(c)}return i}const k0e=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),T0e=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),I0e=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function pu(t){return k0e.has(t.op)}function N0e(t){return T0e.has(t.op)}function E0e(t){return I0e.has(t.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fg{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const n=Object.keys(e).map(r=>e[r].map(s=>s.id));this._weightIds=[].concat(...n),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const n=e.signatureKey||e.name;return e.defaultOutput?`${n}:${e.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((e,n)=>(e[n]=this._functions[n].signature,e),{})}constructor(e,n){this.graph=e,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new Fg(e.functions[r],this)})}getCompilationKey(e,n){const r=e.map(o=>o.name).sort(),s=n.map(o=>o.name).sort();return r.join(this.SEPARATOR)+"--"+s.join(this.SEPARATOR)}compile(e,n){const r=$N(e,n,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:o,syncInputs:i}=r;if(o!=null)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(s.length>0){const c=n.map(f=>f.name),d=Object.keys(e);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${d}]. Missing the following inputs: [${s}]`)}const a=w0e(this.graph,r),l=$0e(a);return{orderedNodes:a,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;const n=e.clone();return hi(n),n}cloneTensorList(e){return e?e.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([n,r])=>[n,this.cloneTensorList(r)]))}execute(e,n){this.disposeIntermediateTensors(),e=this.mapInputs(e);const r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n);const s=r.map(p=>this.graph.nodes[cs(p)[0]]),o=n.map(p=>cs(p)[0]),i=new Set(o);let a=o.map(p=>this.graph.nodes[p]);a.length===0&&(a=this._outputs);const l=this.getCompilationKey(s,a);let c=this.compiledMap.get(l);c==null&&(c=this.compile(e,a),this.compiledMap.set(l,c));try{this.keepIntermediateTensors=se().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}const d={},f={};return nt(()=>{const p=new CN(this.weightMap,d,f,this.functionExecutorMap,this.parseNodeNameCache),g=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(S=>{const[$,I]=cs(S,p),R=[];R[I]=e[S],g[$]=R,this.keepIntermediateTensors&&(this.clonedTensorsMap[$]=this.cloneTensorList(R))});const y=this.getFrozenTensorIds(g),{orderedNodes:x,nodeLiveUntilMap:w}=c;for(const S of x){if(g[S.name])continue;const $=SN(S,g,p,this._resourceManager);if(Ru($))throw new Error(`The execution of the op '${S.op}' returned a promise. Please use model.executeAsync() instead.`);g[S.name]=$,this.keepIntermediateTensors&&(this.clonedTensorsMap[S.name]=this.cloneTensorList($)),this.checkTensorForDisposalWithNodeLiveUntilInfo(S,g,p,y,i,w.get(S.name))}return this.parent==null&&p.dispose(y),n.map(S=>Yn(S,g,p))})}getFrozenTensorIds(e){const n=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(s=>s.id)));return new Set(n)}checkTensorForDisposal(e,n,r,s,o,i,a){if(!(pu(n)||i.has(e))){for(const l of r[e])l!=null&&(a[l.id]=(a[l.id]||0)+n.children.length);for(const l of n.inputs){if(pu(l))continue;const c=yN(l.name,r,s);if(c!=null)for(const d of c){if(!d||d.kept||o.has(d.id))continue;const f=a[d.id];f===1?(d.dispose(),delete a[d.id]):f!=null&&a[d.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,n,r,s,o,i){function a(l){return pu(l)||o.has(l.name)}if(!(pu(e)||i==null))for(const l of i){if(a(l))continue;const c=yN(l.name,n,r);for(const d of c)!d||d.kept||s.has(d.id)||d.dispose()}}async executeAsync(e,n){return this._executeAsync(e,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const n of e)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,n,r=!1,s={},o={}){this.disposeIntermediateTensors(),r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=se().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}const i=new CN(this.weightMap,s,o,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const a=await this.executeWithControlFlow(e,i,n,r),l=n.map(p=>Yn(p,a,i)),c=l.map(p=>p.id),d=Object.keys(e).map(p=>e[p].id),f=new Set([...c,...d,...this.weightIds]);return Object.values(a).forEach(p=>{p.forEach(g=>{g&&!g.isDisposed&&!f.has(g.id)&&g.dispose()})}),this.parent==null&&i.dispose(f),l}async executeFunctionAsync(e,n,r){const s=e.reduce((o,i,a)=>(o[this.inputs[a].name]=i,o),{});return this._executeAsync(s,this.outputNodes,!0,n,r)}async executeWithControlFlow(e,n,r,s){const o=Object.keys(e),i=o.map(R=>this.graph.nodes[cs(R)[0]]),a=r.map(R=>cs(R)[0]),l=new Set(a);let c=a.map(R=>this.graph.nodes[R]);c.length===0&&(c=this._outputs);const{usedNodes:d,missingInputs:f,dynamicNode:p,syncInputs:g}=$N(e,c,this.weightMap,this._initNodes),y=[...i,...this.graph.weights,...this._initNodes||[]].map(R=>({node:R,contexts:n.currentContext})),x=Object.assign({},this.weightMap);Object.keys(e).forEach(R=>{const[_,O]=cs(R),F=[];F[O]=e[R],x[_]=F});const w={},S=this.getFrozenTensorIds(x),$={};for(;y.length>0;){const R=this.processStack(i,y,n,x,$,S,l,w,d);await Promise.all(R)}p==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const I=c.filter(R=>!pu(R)&&!Yn(R.name,x,n)).map(R=>R.name);if(I.length>0){let R="";throw p!=null&&(R=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${g}]`),new Error(`Cannot compute the outputs [${I}] from the provided inputs [${o}]. Consider providing the following inputs: [${f}]. ${R}`)}return x}processStack(e,n,r,s,o,i,a,l,c){const d=[];for(;n.length>0;){const f=n.pop();r.currentContext=f.contexts;let p="";if(f.node.op==="Enter"&&N("isConstant",f.node,s,r)&&([p]=Qi(f.node.name,r)),s[f.node.name]==null){const g=SN(f.node,s,r,this._resourceManager);p||([p]=Qi(f.node.name,r));const y=r.currentContext;Ru(g)?d.push(g.then(x=>(s[p]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(x)),r.currentContext=y,this.checkTensorForDisposal(p,f.node,s,r,i,a,l),this.processChildNodes(f.node,n,r,s,o,c),x))):(s[p]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(g)),this.checkTensorForDisposal(p,f.node,s,r,i,a,l),this.processChildNodes(f.node,n,r,s,o,c))}else this.processChildNodes(f.node,n,r,s,o,c)}return d}processChildNodes(e,n,r,s,o,i){e.children.forEach(a=>{const[l]=Qi(a.name,r);o[l]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(c=>!!Yn(c,s,r))&&(o[l]=!0,n.push({contexts:r.currentContext,node:a})):a.inputNames.every(c=>!!Yn(c,s,r))&&(o[l]=!0,n.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(n=>n.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(n=>{const r=e[n],[s]=cs(n),o=this.graph.nodes[s];if(o.attrParams.shape&&o.attrParams.shape.value){const i=o.attrParams.shape.value,a=i.length===r.shape.length&&r.shape.every((l,c)=>i[c]===-1||i[c]===l);z(a,()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&z(r.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){var n,r;const s={};for(const o in e){const i=(r=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||r===void 0?void 0:r[o];i!=null?s[i.name]=e[o]:s[o]=e[o]}return s}checkInputs(e){const n=Object.keys(e).filter(r=>{const[s]=cs(r);return this.graph.nodes[s]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(e){return e.map(n=>{var r,s;const o=(s=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||s===void 0?void 0:s[n];return o!=null?o.name:n},{})}checkOutputs(e){e.forEach(n=>{const[r]=cs(n);if(!this.graph.nodes[r])throw new Error(`The output '${n}' is not found in the graph`)})}}class R0e{constructor(e={},n={}){this.hashTableNameToHandle=e,this.hashTableMap=n}addHashTable(e,n){this.hashTableNameToHandle[e]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _0e="?tfjs-format=file",P0e="model.json";class A0e{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,n={},r=WD){this.modelUrl=e,this.loadOptions=n,this.version="n/a",this.io=r,n==null&&(this.loadOptions={}),this.resourceManager=new R0e}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const n=this.io.getLoadHandlers(e,this.loadOptions);if(n.length===0)n.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(n.length>1)throw new Error(`Found more than one (${n.length}) load handlers for URL '${[e]}'`);this.handler=n[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Ru(e)?e.then(n=>n.getWeightStream==null?this.loadSync(n):this.loadStreaming(n)):this.loadSync(e)}loadSync(e){const n=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,n)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const n=await LA(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,n)}loadWithWeightMap(e,n){this.artifacts=e;const r=this.artifacts.modelTopology;let s=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const o=this.artifacts.userDefinedMetadata;o.signature!=null&&(s=o.signature),o.structuredOutputKeys!=null&&(this.structuredOutputKeys=o.structuredOutputKeys)}if(this.signature=s,this.version=`${r.versions.producer}.${r.versions.minConsumer}`,this.executor=new Fg(xN.Instance.transformGraph(r,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(n),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const o=xN.Instance.transformGraph(e.modelInitializer);this.initializer=new Fg(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,n){if(typeof e=="string"){const r=this.io.getSaveHandlers(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const n=e instanceof fn?[e]:e,r={};return n.forEach((s,o)=>r[this.structuredOutputKeys[o]]=s),r}return e}predict(e,n){const r=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(r)}async predictAsync(e,n){const r=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(r)}normalizeInputs(e){var n;if(!(e instanceof fn)&&!Array.isArray(e)){const o=(n=this.signature)===null||n===void 0?void 0:n.inputs;if(o!=null)for(const i in o){const a=o[i];a.resourceId!=null&&(e[i]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];const r=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${e.length} input tensors provided.`);let s=0;return this.inputNodes.reduce((o,i)=>{var a,l,c;const d=(c=(l=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||l===void 0?void 0:l[i])===null||c===void 0?void 0:c.resourceId;return d!=null?o[i]=this.resourceIdToCapturedInput[d]:o[i]=e[s++],o},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const n=this.initializerSignature.outputs,r=Object.keys(n);for(let s=0;s<r.length;s++){const o=r[s],i=n[o];this.resourceIdToCapturedInput[i.resourceId]=e[s]}}}execute(e,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const r=this.executor.execute(e,n);return r.length>1?r:r[0]}async executeAsync(e,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const r=await this.executor.executeAsync(e,n);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((n,r)=>(n[r]=[e[r]],n),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Mt(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function fd(t,e={},n=WD){if(t==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof t=="string"&&(t=D0e(t));const r=new A0e(t,e,n);return await r.load(),r}function D0e(t){return t.endsWith("/")||(t=t+"/"),`${t}${P0e}${_0e}`}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ls=se();Ls.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);Ls.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);Ls.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);Ls.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0);Ls.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);Ls.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);Ls.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);Ls.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);Ls.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);Ls.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1);Ls.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);Ls.registerFlag("WEBGPU_PRINT_SHADER",()=>"");Ls.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class O0e{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F0e{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,n,r=!1,s=!0){let o;const i=kN(e,n);return s?(this.freeBuffers.has(i)||this.freeBuffers.set(i,[]),this.freeBuffers.get(i).length>0?(o=this.freeBuffers.get(i).pop(),this.numFreeBuffers--):(o=this.device.createBuffer({size:e,usage:n,mappedAtCreation:r}),this.numBytesAllocated+=e)):(o=this.device.createBuffer({size:e,usage:n,mappedAtCreation:r}),this.numBytesAllocated+=e),this.usedBuffers.has(i)||this.usedBuffers.set(i,[]),this.usedBuffers.get(i).push(o),this.numUsedBuffers++,this.numBytesUsed+=e,o}releaseBuffer(e,n=!0){if(this.freeBuffers.size===0)return;const r=e.size,s=e.usage,o=kN(r,s),i=this.usedBuffers.get(o),a=i.indexOf(e);if(a<0)throw new Error("Cannot find the buffer in buffer manager");i[a]=i[i.length-1],i.pop(),this.numUsedBuffers--,this.numBytesUsed-=r,n?(this.freeBuffers.get(o).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=r)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,n)=>{e.forEach(r=>{r.destroy()})}),this.usedBuffers.forEach((e,n)=>{e.forEach(r=>{r.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function kN(t,e){return`${t}_${e}`}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class L0e{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,n,r,s){const o=IN(r),i=e*n*o,a=TN(e,n,r,s);if(this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.usedTextures.has(a)||this.usedTextures.set(a,[]),this.numBytesUsed+=i,this.numUsedTextures++,this.freeTextures.get(a).length>0){this.numFreeTextures--;const c=this.freeTextures.get(a).shift();return this.usedTextures.get(a).push(c),c}this.numBytesAllocated+=i;const l=this.device.createTexture({size:[e,n],format:r,usage:s});return this.usedTextures.get(a).push(l),l}releaseTexture(e){if(this.freeTextures.size===0)return;const n=e.width,r=e.height,s=e.format,o=e.usage,i=TN(n,r,s,o);this.freeTextures.has(i)||this.freeTextures.set(i,[]),this.freeTextures.get(i).push(e),this.numFreeTextures++,this.numUsedTextures--;const a=this.usedTextures.get(i),l=a.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(l,1);const c=IN(s),d=n*r*c;this.numBytesUsed-=d}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,n)=>{e.forEach(r=>{r.destroy()})}),this.usedTextures.forEach((e,n)=>{e.forEach(r=>{r.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function TN(t,e,n,r){return`${t}_${e}_${n}_${r}`}function IN(t){if(t==="rgba8unorm")return 16;throw new Error(`${t} is not supported!`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z0e(t,e){if(Math.max(...t)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const n=t.length,r="xyzwuv",s=t.map(i=>`${e}.${r[i]}`),o=new Array(n-1);o[n-2]=s[n-1];for(let i=n-3;i>=0;--i)o[i]=`(${o[i+1]} * ${s[i+1]})`;return o}const Nl=(t,e,n)=>n==="int32"?`atomicAdd(${t}, bitcast<i32>(${e}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${e});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${t}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var pd;(function(t){t[t.FROM_PIXELS=0]="FROM_PIXELS",t[t.DRAW=1]="DRAW"})(pd||(pd={}));const B0e=(t,e,n,r,s)=>{const o={dtype:r.dtype,shape:r.shape},i=V0e(n,o,e),a=t.createShaderModule({code:i,label:e.constructor.name});let l=se().get("WEBGPU_PRINT_SHADER");if(l!==""){l=l.toLowerCase();const c=l.split(",");(l==="all"||c.some(d=>e.shaderKey.toLowerCase().includes(d)))&&(console.group(e.shaderKey),console.debug(i),console.groupEnd())}return s?t.createComputePipelineAsync({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"}):t.createComputePipeline({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})},ut=(t,e="f32")=>{switch(t){case 1:return`${e}`;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${t}-component ${e} is not supported.`)}};function bn(t){if(t<=1)return"i32";if(t===2)return"vec2<i32>";if(t===3)return"vec3<i32>";if(t===4)return"vec4<i32>";if(t===5)return"vec5";if(t===6)return"vec6";throw Error(`GPU for rank ${t} is not yet supported`)}function la(t){if(t===0)return"x";if(t===1)return"y";if(t===2)return"z";if(t===3)return"w";if(t===4)return"u";if(t===5)return"v";throw Error(`Index ${t} is not yet supported`)}function Ee(...t){let e;switch(t.length){case 0:e=`
        fn main()
      `;break;case 1:e=`
        fn main(${t[0]} : i32)
      `;break;default:throw Error("Unreachable")}return e}function NN(t,e){let n;return n=`
     ${M0e(e)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${t?"main(getGlobalIndex());":"main();"};
      }
    `,n}function M0e(t){return`
  @compute @workgroup_size(${t.workgroupSize[0]}, ${t.workgroupSize[1]}, ${t.workgroupSize[2]})
`}function V0e(t,e,n){const r=[],s=n.workgroupSize[0]*n.workgroupSize[1]*n.workgroupSize[2];if(n.outputComponent=n.outputComponent?n.outputComponent:1,r.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${hF(n)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${s}u +
                localIndex);
        `}
      }
    `),n.pixelsOpType!=null){const y=n.pixelsOpType===pd.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${mu(e.dtype,n.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${mu(t[0].dtype,n.outputComponent)}>;`,x=e.shape.length===3?"vec2<i32>":"i32";r.push(`
        struct Uniform {
          outShapeStrides : ${x},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${y}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const w=RN(n);return[EN,r.join(`
`),tg(e.shape),n.getUserCode(),NN(w,n)].join(`
`)}let o,i,a="struct Uniforms { NAN : f32, INFINITY : f32, ";n.variableNames.forEach((y,x)=>{const w=bn(t[x].shape.length);a+=`${y.charAt(0).toLowerCase()+y.slice(1)}Shape : ${w}, `,o=t[x].shape.length-1,i=bn(o),a+=`${y.charAt(0).toLowerCase()+y.slice(1)}ShapeStrides: ${i}, `});const l=bn(e.shape.length);a+=`outShape : ${l}, `,o=e.shape.length-1,i=bn(o),a+=`
         outShapeStrides: ${i}, `,n.size&&(a+="size : i32, "),n.uniforms&&(a+=n.uniforms),a+="};",a=Y0e(a),r.push(a),n.atomic?r.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):r.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${mu(e.dtype,n.outputComponent)}>;
    `),n.variableNames.forEach((y,x)=>{r.push(`
      @group(0) @binding(${1+x}) var<storage, read> ${y}: array<${n.variableComponents?mu(t[x].dtype,n.variableComponents[x]):mu(t[x].dtype,n.outputComponent)}>;
        `)}),a!==""&&r.push(`
      @group(0) @binding(${1+n.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const c=K0e(e.shape,n.dispatchLayout),d=[EN,r.join(`
`)+U0e,tg(e.shape),c,X0e(e.shape.length)];n.atomic||d.push(q0e(e.shape,e.dtype,n.outputComponent)),n.variableNames.forEach((y,x)=>{d.push(`${tg(t[x].shape,y)}`)});const f=t.map((y,x)=>H0e(y,e.shape,n.variableComponents?n.variableComponents[x]:n.outputComponent,n.dispatchLayout.x.length===e.shape.length)).join(`
`);d.push(f),d.push(n.getUserCode());const p=RN(n);return d.push(NN(p,n)),d.join(`
`)}function W0e(t,e,n){let r=t.shaderKey;if(t.pixelsOpType!=null)return r;const s=[],o=[];e.forEach(d=>{s.push(d.shape),o.push(d.dtype)}),s.push(n.shape),o.push(n.dtype);const i=e.map(d=>cd(d.shape,n.shape)),a=e.map(d=>Vt(d.shape,n.shape)).join("_"),l=i.map(d=>d.join("_")).join(";"),c=hF(t)?"flatDispatch":"";return r+="_"+(t.workgroupSize?t.workgroupSize.join(","):"")+s.map(d=>d.length).join(",")+o.join(",")+t.variableNames.join(",")+l+a+c,r}const EN=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,U0e=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function tg(t,e=""){const n=t.length,r=e!==""?`get${e.charAt(0).toUpperCase()+e.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",s=e!==""?`${e.charAt(0).toLowerCase()+e.slice(1)}ShapeStrides`:"outShapeStrides";if(n<=1)return`fn ${r}(index : i32) -> i32 { return index; }`;const o=gn(t),i=bn(n),a=[];for(let c=0;c<n;c++)a.push(`d${c}`);if(o.length===1)return`    fn ${r}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${s}; let d1 = index - d0 * uniforms.${s};
      return vec2<i32>(d0, d1);
    }`;let l;return l="var index2 = index;"+o.map((c,d)=>{const f=`let ${a[d]} = index2 / uniforms.${s}.${la(d)}`,p=d===o.length-1?`let ${a[d+1]} = index2 - ${a[d]} * uniforms.${s}.${la(d)}`:`index2 = index2 - ${a[d]} * uniforms.${s}.${la(d)}`;return`${f}; ${p};`}).join(""),`
    fn ${r}(index : i32) -> ${i} {
      ${l}
      return ${i}(${a.join(",")});
    }
  `}function j0e(t,e){const n=t.name,r=t.shape.length,s=bn(r),o="get"+n.charAt(0).toUpperCase()+n.slice(1),i=["d0","d1","d2","d3","d4","d5"].slice(0,r),a=i.map(d=>`${d} : i32`).join(", ");if(r<1)return`
      fn ${o}() -> ${ut(e)} {
        return ${ut(e)}(${n}[0]);
      }
    `;const l=`uniforms.${n.charAt(0).toLowerCase()+n.slice(1)}Shape`;let c=`${r}D`;return r===0&&(c="1D"),`
    fn ${o}(${a}) -> ${ut(e)} {
      return ${ut(e)}(${n}[getIndexFromCoords${c}(${s}(${i.join(",")}),
        ${l})${e===1?"":` / ${e}`}]);
    }
   `}function G0e(t,e,n,r){const s=t.name,o=s.charAt(0).toUpperCase()+s.slice(1),i="get"+o+"ByOutput",a=t.shape.length,l=e.length,c=bn(l);if(Vt(t.shape,e)&&r)return`
    fn ${i}Index(globalIndex : i32) -> ${ut(n)} {
      return ${ut(n)}(${s}[globalIndex]);
    }

    fn ${i}Coords(coords : ${c}) -> ${ut(n)} {
      return ${ut(n)}(${s}[${l>1?"getOutputIndexFromCoords(coords)":"coords"}${n===1?"":` / ${n}`}]);
    }
    `;const d=cd(t.shape,e),f=l-a;let p="";if(a===0)return`
    fn ${i}Index(globalIndex : i32) -> ${ut(n)}{
      return get${o}();
    }

    fn ${i}Coords(coords : ${c}) -> ${ut(n)}{
      return get${o}();
    }
  `;l<2&&d.length>=1?p="coords = 0;":p=d.map(w=>`coords.${la(w+f)} = 0;`).join(`
`);let g="";if(l<2&&a>0)g="coords";else if(l>1){const w=bn(a),S=t.shape.map(($,I)=>`coords.${la(I+f)}`).join(", ");g=`${w}(${S})`}else g="coords";const y=`uniforms.${s.charAt(0).toLowerCase()+s.slice(1)}Shape`,x=`${a}D`;return`
  fn ${i}Index(globalIndex : i32) -> ${ut(n)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${p}
    return ${ut(n)}(${s}[getIndexFromCoords${x}(${g}, ${y})${n===1?"":` / ${n}`}]);
  }

  fn ${i}Coords(coordsIn : ${c}) -> ${ut(n)} {
    var coords = coordsIn;
    ${p}
    return ${ut(n)}(${s}[getIndexFromCoords${x}(${g}, ${y})${n===1?"":` / ${n}`}]);
  }
`}function H0e(t,e,n,r){let s=j0e(t,n);return t.shape.length<=e.length&&(s+=G0e(t,e,n,r)),s}function K0e(t,e){const{x:n,y:r=[],z:s=[]}=e,o=t.length,i=n.length+r.length+s.length;if(i!==o)return"";if(n.length===o)return`fn getOutputCoords() -> ${bn(o)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let a="";const l=[n,r,s];for(let p=0;p<l.length;p++){const g=l[p];if(g.length!==0)if(g.length===1)a+=`let d${g[0]} = i32(globalId[${p}]);`;else{const y=z0e(g,"uniforms.outShape");a+=`var index${p} = i32(globalId[${p}]);`;for(let x=0;x<y.length;x++)a+=`let d${g[x]} = index${p} / ${y[x]};`,x===y.length-1?a+=`let d${g[x+1]} = index${p} - d${g[x]} * ${y[x]};`:a+=`index${p} = index${p} - d${g[x]} * ${y[x]};`}}const c=[];for(let p=0;p<i;p++)c.push(`d${p}`);const d=bn(i);let f=`fn getOutputCoords() -> ${d} {
  ${a}
`;return c.length===0?f+=`return ${d}(0); }`:f+=`return ${d}(${c.join(",")}); }`,f}function X0e(t){let e="";switch(t){case 0:case 1:e+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:e+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:e+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:z(!1,()=>`Unsupported ${t}D shape`);break}return e}function hF(t){return t.dispatch[1]===1&&t.dispatch[2]===1}function mu(t,e=1){if(t==="float32")return ut(e,"f32");if(t==="int32"||t==="bool")return ut(e,"i32");throw new Error(`type ${t} is not supported.`)}function q0e(t,e,n){const r=t.length,s=mu(e,n);let o=`fn setOutputAtIndex(flatIndex : i32, value : ${ut(n)}) {
      result[flatIndex] = ${s}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${ut(n,"i32")}) {
      result[flatIndex] = ${s}(value);
    }
    `;if(r>=2){const i=["d0","d1","d2","d3","d4","d5"].slice(0,r),a=bn(r);o+=`
      fn setOutputAtCoords(${i.map(l=>`${l} : i32`).join(", ")}, value : ${ut(n)}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${i.join(", ")}));
        setOutputAtIndex(flatIndex${n===1?"":` / ${n}`}, value);
      }
      fn setOutputAtCoordsI32(${i.map(l=>`${l} : i32`).join(", ")}, value : ${ut(n,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${i.join(", ")}));
        setOutputAtIndexI32(flatIndex${n===1?"":` / ${n}`}, value);
      }
    `}return o}function Y0e(t){const e=/(\w+)\s*:\s*vec(5|6)/g;t=t.replace(e,r=>"@align(16) "+r);const n=/vec(5|6)\s*,\s*(\w+)/g;return t=t.replace(n,(r,s,o)=>`vec${s}, @align(16) ${o}`),t}function RN(t){return!(t.dispatchLayout.hasOwnProperty("y")&&t.dispatchLayout.y.length!==0||t.dispatchLayout.hasOwnProperty("z")&&t.dispatchLayout.z.length!==0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iu=t=>{let e=1;for(let n=0;n<t.length;n++)e*=t[n];return e};function Re(t,e,n=[1,1,1],r=[1,1,1]){const[s,o,i]=[Math.ceil(Iu(t.x.map(a=>e[a]))/(n[0]*r[0])),t.y?Math.ceil(Iu(t.y.map(a=>e[a]))/(n[1]*r[1])):1,t.z?Math.ceil(Iu(t.z.map(a=>e[a]))/(n[2]*r[2])):1];return[s,o,i]}function Q0e(t,e,n,r=!1){const s=[8,8,1],o=[4,4,1];return r||(t<=8&&(o[1]=1),e<=16&&n<=16&&(s[0]=4)),{workgroupSize:s,elementsPerThread:o}}function fF(t,e,n=!1){if(n)return[8,8,1];const r=Iu(t.x.map(o=>e[o])),s=Iu(t.y.map(o=>e[o]));return r<=4?[4,16,1]:s<=4?[16,4,1]:[16,16,1]}function pF(t,e,n=!1){if(n)return[4,4,1];const r=Iu(t.x.map(o=>e[o])),s=Iu(t.y.map(o=>e[o]));return r<=4?[1,2,1]:s<=4?[2,1,1]:[2,2,1]}function De(t){return{x:t.map((e,n)=>n)}}function _N(t){if(t==="float32"||t==="int32"||t==="bool"||t==="string")return 4;if(t==="complex64")return 8;throw new Error(`Unknown dtype ${t}`)}function mF(){return!!(typeof globalThis<"u"&&globalThis.navigator&&globalThis.navigator.gpu)}function gF(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&z(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGPU backend.`)})}var ai;(function(t){t[t.MatMulReduceProgram=0]="MatMulReduceProgram",t[t.MatMulSplitKProgram=1]="MatMulSplitKProgram",t[t.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",t[t.MatMulPackedProgram=3]="MatMulPackedProgram",t[t.MatMulMax=4]="MatMulMax"})(ai||(ai={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z0e=se().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),J0e=(t,e)=>{const n=t.limits.maxComputeWorkgroupsPerDimension,r=e.dispatchLayout,s=e.dispatch;if(s.every(i=>i<=n))return s;z(s[0]>n&&r.y===void 0&&r.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let o=Math.ceil(Math.sqrt(s[0]));return o>n?(o=Math.ceil(Math.cbrt(s[0])),z(o<=n,()=>"Total dispatch size exceeds WebGPU maximum."),[o,o,o]):[o,o,1]};class Od extends Zb{nextDataId(){return Od.nextDataId++}constructor(e,n){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!mF())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new O0e(n),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new F0e(this.device),this.textureManager=new L0e(this.device),this.tensorMap=new MP(this,ds()),se().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e,n=!1){if(!this.tensorMap.has(e))return!0;const r=this.tensorMap.get(e);return n?r.refCount=0:r.refCount--,r.refCount>0?!1:(r.complexTensorInfos!=null&&(this.disposeData(r.complexTensorInfos.real.dataId),this.disposeData(r.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const n=this.tensorMap.get(e);if(!(!n||!n.resource)){if(n.external){n.resource=null;return}n.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(n.resource):n.resource instanceof GPUTexture&&this.textureManager.releaseTexture(n.resource),n.resource=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){const n=this.tensorMap.get(e);n.refCount++}decRef(e){if(this.tensorMap.has(e)){const n=this.tensorMap.get(e);n.refCount--}}write(e,n,r){if(r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.tensorMap.set(s,{dtype:r,shape:n,values:e,refCount:1}),s}move(e,n,r,s,o){if(s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:s,shape:r,values:n,refCount:o})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(n){throw new Error(n.message)}Object.keys(this.pipelineCache).map((n,r)=>{this.pipelineCache[n]=e[r]})}async getBufferData(e){if(se().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const n=e.size,r=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,r,0,n),this.submitQueue(),await r.mapAsync(GPUMapMode.READ);const s=r.getMappedRange().slice(0);return r.unmap(),r!=null&&this.bufferManager.releaseBuffer(r),se().getBool("WEBGPU_USE_PROFILE_TOOL")&&(z(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),s}convertAndCacheOnCPU(e,n){const r=this.tensorMap.get(e);return r.values=n,r.values}readSync(e){const n=this.tensorMap.get(e),{values:r,complexTensorInfos:s}=n;if(r!=null||n.dtype==="string")return r;if(n.dtype==="complex64"){const x=this.readSync(s.real.dataId),w=this.readSync(s.imag.dataId),S=V1(kf(x,w).buffer,"float32");return this.convertAndCacheOnCPU(e,S),S}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const o=["opaque","premultiplied"],i=n.resource,a=i.size;z(a%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const l=a/4,c=new ArrayBuffer(a),d=256,f=256,p=o.map(x=>new OffscreenCanvas(d,f)),g=new OffscreenCanvas(d,f);this.endComputePassEncoder(),p.map((x,w)=>{const S=x.getContext("webgpu");return S.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:o[w]}),S.getCurrentTexture()}).map((x,w)=>{const S=d*4,$=(B,M,V)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:i,bytesPerRow:S,offset:V},{texture:x},{width:B,height:M}),this.submitQueue();const P=g.getContext("2d",{willReadFrequently:!0});P.clearRect(0,0,B,M),P.drawImage(p[w],0,0);const re=P.getImageData(0,0,B,M).data,ie=o[w],me=new Uint8ClampedArray(c,V,B*M*4);for(let ge=0;ge<me.length;ge+=4)if(ie==="premultiplied")me[ge+3]=re[ge+3];else{const ve=re[ge];me[ge]=re[ge+2],me[ge+1]=re[ge+1],me[ge+2]=ve}},I=Math.floor(l/(d*f));let R=d,_=f,O=0;for(let B=0;B<I;B++)$(R,_,O),O+=d*f*4;const F=l%(d*f);_=Math.floor(F/d),_>0&&($(R,_,O),O+=_*(d*4)),R=F%d,R>0&&$(R,1,O)});const y=V1(c,n.dtype);return this.convertAndCacheOnCPU(e,y),y}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const n=this.tensorMap.get(e),{values:r}=n;if(r!=null)return r;let s;if(n.dtype==="complex64"){const o=await Promise.all([this.read(n.complexTensorInfos.real.dataId),this.read(n.complexTensorInfos.imag.dataId)]),i=o[0],a=o[1];s=kf(i,a)}else{const o=await this.getBufferData(n.resource);s=V1(o,n.dtype)}return this.convertAndCacheOnCPU(e,s),s}copyBuffer(e){const n=e.size,r=e.usage,s=this.bufferManager.acquireBuffer(n,r);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,s,0,n),this.submitQueue(),s}createTensorFromGPUData(e,n,r){let s=e.buffer;if(r==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const o={id:this.nextDataId()};this.tensorMap.set(o,{dtype:r,shape:n,values:null,refCount:1,external:e.zeroCopy});const i=this.tensorMap.get(o),a=_N(i.dtype)*pe(i.shape);if(e.buffer.size<a)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${a})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return e.zeroCopy!==!0&&(s=this.copyBuffer(s)),i.resource=s,ds().makeTensorFromDataId(o,n,r,this)}readToGPU(e){const n=this.tensorMap.get(e),{values:r,dtype:s,shape:o,resource:i}=n;if(s==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(i==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const a=i,l=a.size,c=a.usage,d=this.bufferManager.acquireBuffer(l,c);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(i,0,d,0,l),this.submitQueue();const f=this.makeTensorInfo(o,s),p=ds().makeTensorFromTensorInfo(f),g=this.tensorMap.get(f.dataId);return g.resource=d,{tensorRef:p,buffer:d}}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const r=n.map(s=>fa(s));return Wt(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Wt(e.shape,e.dtype,n)}async time(e){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const n=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const o=pa(this.activeTimers.map(c=>c.query)).filter(c=>c!=null),i=pa(this.activeTimers.map(c=>c.name)).filter(c=>c!=null);this.activeTimers=n,s&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},l=await Promise.all(o);return a.kernelMs=VP(l),a.getExtraProfileInfo=()=>l.map((c,d)=>({name:i[d],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,a}makeTensorInfo(e,n,r){return n==="string"&&r!=null&&r.length>0&&Gf(r[0])&&(r=r.map(o=>hl(o))),{dataId:this.write(r,e,n),shape:e,dtype:n}}tensorToBinding(e){if(!e)return null;const r=this.tensorMap.get(e.dataId).resource;return r instanceof GPUBuffer?{buffer:r}:r instanceof GPUTexture?r.createView():r}uploadToGPU(e){const n=this.tensorMap.get(e);if(n.resource!=null)return;const r=_N(n.dtype)*pe(n.shape);let s;const o=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(n.values){if(s=this.bufferManager.acquireBuffer(r,o,!0),s.mapState==="unmapped"){const i=this.bufferManager.acquireBuffer(r,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),a=i.getMappedRange();n.dtype==="int32"||n.dtype==="bool"?new Int32Array(a).set(n.values):new Float32Array(a).set(n.values),i.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(i,0,s,0,r),this.stagingPendingDisposal.push(i)}else{const i=s.getMappedRange();n.dtype==="int32"||n.dtype==="bool"?new Int32Array(i).set(n.values):new Float32Array(i).set(n.values),s.unmap()}n.values=null}else s=this.bufferManager.acquireBuffer(r,o);n.resource=s}makeUniforms(e){let n=0,r=0;const s=[];let o=1;e.forEach(l=>{l.data.length===0&&(l.data=[1]);let c;switch(l.data.length){case 1:c=4;break;case 2:c=8;break;case 3:c=16;break;case 4:c=16;break;case 5:c=16;break;case 6:c=16;break;default:z(!1,()=>`Unsupported ${l.data.length}D shape`)}(r===5||r===6)&&(c=16),c>o&&(o=c),n=Math.ceil(n/c)*c,r=l.data.length,s.push(n),n+=l.data.length*4}),n=Math.ceil(n/o)*o;const i=new ArrayBuffer(n);e.forEach((l,c)=>{const d=s[c];l.type==="int32"?new Int32Array(i,d,l.data.length).set(l.data):l.type==="uint32"?new Uint32Array(i,d,l.data.length).set(l.data):new Float32Array(i,d,l.data.length).set(l.data)});const a=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(a,0,i,0,n),this.uniformPendingDisposal.push(a),{offset:0,size:n,buffer:a}}runWebGPUProgram(e,n,r,s,o){if(o||(o=this.makeTensorInfo(e.outputShape,r)),pe(o.shape)===0)return this.tensorMap.get(o.dataId).values=Si(o.dtype,0),o;this.uploadToGPU(o.dataId),e.dispatch=J0e(this.device,e);const i=n.map((l,c)=>{if(l.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(l.dataId),{dtype:this.tensorMap.get(l.dataId).dtype,shape:l.shape,name:e.variableNames[c]}});e.shaderKey=W0e(e,i,o);const a=se().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=B0e(this.device,e,i,o,a)),e.pipeline=this.pipelineCache[e.shaderKey],a||this.recordAndSubmit(e,o,n,s),o}recordAndSubmit(e,n,r,s){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let o=[],i=[];const a="int32";if(e.pixelsOpType==null){o.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),i=r.concat(n).map(g=>g.shape);const p="int32";i.map(g=>{o.push({type:p,data:g});const y=gn(g);o.push({type:p,data:y})})}else{const p=gn(n.shape);o.push({type:a,data:p})}if(e.size){const p=pe(e.outputShape);o.push({type:a,data:[e.outputComponent?p/e.outputComponent:p]})}s&&(o=[...o,...s]);const l=[this.tensorToBinding(n),...r.map(p=>this.tensorToBinding(p)),this.makeUniforms(o)];r.forEach(p=>{this.commandQueueOwnedIds.add(p.dataId)}),this.commandQueueOwnedIds.add(n.dataId);const c=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:l.map((p,g)=>({binding:g,resource:p}))}),d=this.activeTimers!=null;this.ensureCommandEncoderReady();const f={};d&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),f.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(f)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(f)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,c),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(d||se().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===pd.DRAW)&&(this.endComputePassEncoder(),d?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.querySetCount*8),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const n=new BigUint64Array(e.getMappedRange()),r=Number(n[1]-n[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),r}shouldExecuteOnCPU(e,n=Z0e){return se().getBool("WEBGPU_CPU_FORWARD")&&e.every(r=>this.tensorMap.get(r.dataId).resource==null&&pe(r.shape)<n)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}Od.nextDataId=0;/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */mF()&&DA("webgpu",async()=>{const t={powerPreference:se().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(t),n={},r=[];e.features.has("timestamp-query")&&r.push("timestamp-query"),e.features.has("bgra8unorm-storage")&&r.push(["bgra8unorm-storage"]),n.requiredFeatures=r;const s=e.limits;n.requiredLimits={maxComputeWorkgroupStorageSize:s.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:s.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:s.maxStorageBufferBindingSize,maxBufferSize:s.maxBufferSize,maxComputeWorkgroupSizeX:s.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:s.maxComputeInvocationsPerWorkgroup};const o=await e.requestDevice(n),i="info"in e?e.info:"requestAdapterInfo"in e?await e.requestAdapterInfo():void 0;return new Od(o,i)},3);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Je;(function(t){t[t.ADD=0]="ADD",t[t.ATAN2=1]="ATAN2",t[t.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",t[t.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",t[t.DIV=4]="DIV",t[t.ELU_DER=5]="ELU_DER",t[t.EQUAL=6]="EQUAL",t[t.FLOOR_DIV=7]="FLOOR_DIV",t[t.GREATER=8]="GREATER",t[t.GREATER_EQUAL=9]="GREATER_EQUAL",t[t.LESS=10]="LESS",t[t.LESS_EQUAL=11]="LESS_EQUAL",t[t.LOGICAL_AND=12]="LOGICAL_AND",t[t.LOGICAL_OR=13]="LOGICAL_OR",t[t.MAX=14]="MAX",t[t.MIN=15]="MIN",t[t.MOD=16]="MOD",t[t.MUL=17]="MUL",t[t.NOT_EQUAL=18]="NOT_EQUAL",t[t.POW=19]="POW",t[t.PRELU=20]="PRELU",t[t.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",t[t.SUB=22]="SUB"})(Je||(Je={}));const e1e="let resultTemp = a + b;",t1e="let resultTemp = atan2(a, b);",n1e="let resultTemp = areal * breal - aimag * bimag;",r1e="let resultTemp = areal * bimag + aimag * breal;",s1e="let resultTemp = a / b;",o1e="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",i1e=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,a1e=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,l1e=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,u1e=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,c1e=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,d1e=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,h1e="return f32(a >= 1.0 && b >= 1.0);",f1e=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,p1e="return f32(a >= 1.0 || b >= 1.0);",m1e=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,g1e="let resultTemp = max(a, b);",y1e="let resultTemp = min(a, b);",x1e=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,v1e=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,b1e="let resultTemp = a * b;",w1e=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,S1e=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,C1e=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,$1e=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,k1e="if (a < 0.0) { return b * a; }  return a;",T1e=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,I1e="let resultTemp = (a - b) * (a - b);",N1e="let resultTemp = a - b;";function zC(t,e){let n;do{switch(t){case Je.ATAN2:n=t1e;break;case Je.MAX:n=g1e;break;case Je.MIN:n=y1e;break;case Je.MOD:n=e?v1e:x1e;break;case Je.NOT_EQUAL:n=e?S1e:w1e;break;case Je.POW:n=e?$1e:C1e;break;default:continue}let r,s,o;return e?(r="isnanVec4",s="vec4<f32>",o="vec4<bool>"):(r="isnan",s="f32",o="bool"),`
      let aIsNaN = ${r}(a);
      let aPostLegalization = select(a, ${s}(42), aIsNaN);
      let bIsNaN = ${r}(b);
      let bPostLegalization = select(b, ${s}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${n}
        return select(
            resultTemp, ${s}(valueForNaN),
            ${o}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(t){case Je.ADD:n=e1e;break;case Je.COMPLEX_MULTIPLY_IMAG:n=r1e;break;case Je.COMPLEX_MULTIPLY_REAL:n=n1e;break;case Je.DIV:n=s1e;break;case Je.ELU_DER:n=o1e;break;case Je.EQUAL:n=i1e;break;case Je.FLOOR_DIV:n=a1e;break;case Je.GREATER:n=l1e;break;case Je.GREATER_EQUAL:n=u1e;break;case Je.LESS:n=c1e;break;case Je.LESS_EQUAL:n=d1e;break;case Je.LOGICAL_AND:return e?f1e:h1e;case Je.LOGICAL_OR:return e?m1e:p1e;case Je.MUL:n=b1e;break;case Je.PRELU:return e?T1e:k1e;case Je.SQUARED_DIFFERENCE:n=I1e;break;case Je.SUB:n=N1e;break}return`
    ${n}
    return resultTemp;
  `}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ne;(function(t){t[t.ABS=0]="ABS",t[t.ACOS=1]="ACOS",t[t.ACOSH=2]="ACOSH",t[t.ASIN=3]="ASIN",t[t.ASINH=4]="ASINH",t[t.ATAN=5]="ATAN",t[t.ATANH=6]="ATANH",t[t.CEIL=7]="CEIL",t[t.COS=8]="COS",t[t.COSH=9]="COSH",t[t.ELU=10]="ELU",t[t.ERF=11]="ERF",t[t.EXP=12]="EXP",t[t.EXPM1=13]="EXPM1",t[t.FLOOR=14]="FLOOR",t[t.IS_FINITE=15]="IS_FINITE",t[t.IS_INF=16]="IS_INF",t[t.IS_NAN=17]="IS_NAN",t[t.LINEAR=18]="LINEAR",t[t.LOG=19]="LOG",t[t.LOG1P=20]="LOG1P",t[t.LOGICAL_NOT=21]="LOGICAL_NOT",t[t.NEG=22]="NEG",t[t.RELU=23]="RELU",t[t.RELU6=24]="RELU6",t[t.LEAKYRELU=25]="LEAKYRELU",t[t.RECIPROCAL=26]="RECIPROCAL",t[t.ROUND=27]="ROUND",t[t.RSQRT=28]="RSQRT",t[t.SELU=29]="SELU",t[t.SIGMOID=30]="SIGMOID",t[t.SIGN=31]="SIGN",t[t.SIN=32]="SIN",t[t.SINH=33]="SINH",t[t.SOFTPLUS=34]="SOFTPLUS",t[t.SQRT=35]="SQRT",t[t.SQUARE=36]="SQUARE",t[t.STEP=37]="STEP",t[t.TAN=38]="TAN",t[t.TANH=39]="TANH",t[t.TO_INT=40]="TO_INT"})(Ne||(Ne={}));const E1e="return abs(a);",R1e=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,_1e=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,P1e=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,A1e="return asinh(a);",D1e=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,O1e=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,F1e="return ceil(a);",L1e="return cos(a);",z1e=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,B1e="return exp(a) - 1.0;",M1e="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",V1e=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,W1e=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${pC};
  let a1 = ${mC};
  let a2 = ${gC};
  let a3 = ${yC};
  let a4 = ${xC};
  let a5 = ${vC};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,U1e="return exp(a);",j1e="return floor(a);",G1e="return f32(!isnan(a) && !isinf(a));",H1e="return f32(isinf(a));",K1e="return f32(isnan(a));",X1e="return a;",q1e=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,Y1e=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,Q1e="return f32(!(a >= 1.0));",Z1e="return -a;",J1e="if (a < 0.0) { return uniforms.alpha * a; } return a;",exe=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,txe="return 1.0 / a;",nxe="return select(a, 0.0, a < 0.0);",rxe="return clamp(a, 0.0, 6.0);",sxe="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",oxe=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,ixe="return round(a);",axe="return inverseSqrt(a);",lxe=`
  if (a >= 0.0) {
    return ${fC} * a;
  } else {
    return ${hC} * (exp(a) - 1.0);
  }
`,uxe="return 1.0 / (1.0 + exp(-1.0 * a));",cxe="return sign(a);",dxe="return sin(a);",hxe=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,fxe=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,pxe="return sqrt(a);",mxe="return a * a;",gxe=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,yxe="return tan(a);",xxe=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,vxe="return f32(i32((a)));";function uu(t,e){switch(t){case Ne.ABS:return E1e;case Ne.ACOS:return R1e;case Ne.ACOSH:return _1e;case Ne.ASIN:return P1e;case Ne.ASINH:return A1e;case Ne.ATAN:return D1e;case Ne.ATANH:return O1e;case Ne.COS:return L1e;case Ne.COSH:return z1e;case Ne.CEIL:return F1e;case Ne.ELU:return e?V1e:M1e;case Ne.ERF:return W1e;case Ne.EXP:return U1e;case Ne.EXPM1:return B1e;case Ne.FLOOR:return j1e;case Ne.IS_FINITE:return G1e;case Ne.IS_INF:return H1e;case Ne.IS_NAN:return K1e;case Ne.LINEAR:return X1e;case Ne.LOG:return q1e;case Ne.LOG1P:return Y1e;case Ne.LOGICAL_NOT:return Q1e;case Ne.NEG:return Z1e;case Ne.LEAKYRELU:return e?exe:J1e;case Ne.RECIPROCAL:return txe;case Ne.RELU:return e?oxe:nxe;case Ne.RELU6:return e?sxe:rxe;case Ne.ROUND:return ixe;case Ne.RSQRT:return axe;case Ne.SELU:return lxe;case Ne.SIGMOID:return uxe;case Ne.SIGN:return cxe;case Ne.SIN:return dxe;case Ne.SINH:return hxe;case Ne.SOFTPLUS:return fxe;case Ne.SQRT:return pxe;case Ne.SQUARE:return mxe;case Ne.STEP:return gxe;case Ne.TAN:return yxe;case Ne.TANH:return xxe;case Ne.TO_INT:return vxe;default:throw new Error(`BinaryType ${t} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ta(t,e=!1,n=!1,r=3){if(t===null)return"";let s="";if(t==="linear")s=uu(Ne.LINEAR);else if(t==="relu")s=uu(Ne.RELU,n);else if(t==="elu")s=uu(Ne.ELU,n);else if(t==="relu6")s=uu(Ne.RELU6,n);else if(t==="prelu")s=zC(Je.PRELU,n);else if(t==="sigmoid")s=uu(Ne.SIGMOID,n);else if(t==="leakyrelu")s=uu(Ne.LEAKYRELU,n);else throw new Error(`Activation ${t} has not been implemented for the WebGPU backend.`);const i=ut(n?4:1);let a="";return e?a=`
      fn activation(a : ${i}, coords : vec${r}<i32>) -> ${i} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${s}
      }`:a=`
      fn activation(a : ${i}, coords : vec${r}<i32>) -> ${i} {
        ${s}
      }`,a}function Hu(t,e){return`
      ${t?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yF(t,e,n=!1,r=!1,s=!1,o=1){z(t&&o===1||!t,()=>`transposeA ${t} is not compatible with component size ${o}`);const i=`
      ${t?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,a=e?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${ut(o)} {
    var value = ${ut(o)}(0.0);
    ${n&&s?i:`
    ${t?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${i}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${ut(o)} {
    var value = ${ut(o)}(0.0);
    ${a}
    return value;
  }
  `}function BC(t,e,n,r,s=!1,o=!1,i=!1,a=1){return`
  ${yF(n,r,s,o,i,a)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${ut(a)}) {
    ${s&&o?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${Hu(t,e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}const bxe=(t,e)=>t?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${e});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${e});
        `,wxe=(t,e,n,r)=>{if(t)return`
      for (var k = 0; k < ${r}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${n}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let s="",o="";for(let i=0;i<e;i++)s+=`let BCached${i} = mm_Bsub[k * ${e} + ${i}][tileCol];`,o+=`acc[i] = fma(BCached${i}, vec4<f32>(ACached[${i}]), acc[i]);`;return`
      for (var k = 0; k < ${r/e}; k++) {
        ${s}
        for (var i = 0; i < ${n}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${o}
        }
      }`}};function $y(t,e,n=!1,r=32,s=!1,o=32,i=!1){const a=e[1]*t[1],l=e[0]*t[0],c=n?a:r,d=n?r:a,f=c/e[0],p=r/e[1],g=t[1],y=t[0];return z((n&&f===4&&t[1]===4||!n&&(f===3||f===4))&&c%e[0]===0&&r%e[1]===0&&t[0]===4,()=>`If transposeA ${n} is true, innerElementSize ${f} and workPerThread[1] ${t[1]} must be 4.
          Otherwise, innerElementSize ${f} must be 3 or 4.
      tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}. tileInner ${r} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${t[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${f}<f32>, ${c/f}>, ${d}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${l/t[0]}>, ${r}>;

  ${Ee()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${g};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${g};
    let globalCol = i32(globalId.x) * ${y};
    let batch = ${s?"0":"i32(globalId.z)"};
    let batchA = ${s||!i?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${s||!i?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${a};

    let numTiles = ${s?`${Math.ceil(o/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};
    var kStart = ${s?`i32(globalId.z) * ${o}`:"0"};

    var acc: array<vec4<f32>, ${g}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${p};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${g}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${bxe(n,f)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${p}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${r};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${wxe(n,f,g,r)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const PN=t=>t?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,Sxe=t=>t?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function ky(t,e,n=!1,r=32,s=!1,o=32,i=!1,a=!1){const l=t[1]*e[1],c=t[0]*e[0],d=n?l:r,f=n?r:l;z(f%e[1]===0&&d%e[0]===0&&r%e[1]===0,()=>`tileAHight ${f} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${d} must be divisible by workgroupSize[0]${e[0]}, tileInner ${r} must be divisible by workgroupSize[1]${e[1]}`);const p=f/e[1],g=d/e[0],y=r/e[1],x=t[1],w=t[0],S=i?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${l};
      let globalColStart = i32(workgroupId.x) * ${c};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${f}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${e[0]}) {
            ${PN(n)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${r};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${w}>;
        for (var k = 0; k < ${r}; k++) {
          for (var inner = 0; inner < ${w}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < ${x}; innerRow++) {
            let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < ${w}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${x}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < ${w}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${x};
  let tileCol = i32(localId.x) * ${w};

  let globalRow = i32(globalId.y) * ${x};
  let globalCol = i32(globalId.x) * ${w};
  let globalRowStart = i32(workgroupId.y) * ${l};

  let tileRowA = i32(localId.y) * ${p};
  let tileColA = i32(localId.x) * ${g};
  let tileRowB = i32(localId.y) * ${y};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${p}; innerRow++) {
      for (var innerCol = 0; innerCol < ${g}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${PN(n)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${y}; innerRow++) {
      for (var innerCol = 0; innerCol < ${w}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${r};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${w}>;
    for (var k = 0; k < ${r}; k++) {
      for (var inner = 0; inner < ${w}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${x}; innerRow++) {
        ${Sxe(n)}
        for (var innerCol = 0; innerCol < ${w}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${x}; innerRow++) {
    for (var innerCol = 0; innerCol < ${w}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${d}>, ${f}>;
    var<workgroup> mm_Bsub : array<array<f32, ${c}>, ${r}>;

    ${Ee()} {
      let batch = ${s?"0":"i32(globalId.z)"};
      let batchA = ${s||!a?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${s||!a?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${s?`${Math.ceil(o/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};
      var kStart = ${s?`i32(globalId.z) * ${o}`:"0"};

      var acc : array<array<f32, ${w}>, ${x}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${x}; innerRow++) {
        for (var innerCol = 0; innerCol < ${w}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${S}
    }
  `}const Cxe=t=>t?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function $xe(t,e=!1){z(t[1]===1&&t[2]===1,()=>`A linear work group size is required. But got ${t}.`);const n=t[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${t[0]}>;

    ${Ee()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${n} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${n} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${Cxe(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${n/4}; k++) {
          let rowB = t * ${n} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}class kxe{constructor(e,n,r=!1,s=!1,o=null,i=null,a=null,l=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]};const c=r?e[1]:e[2];if(this.isVec4=(c%4===0&&!r||n[1]%4===0&&r)&&n[2]%4===0&&!s,this.outputComponent=this.isVec4?4:1,this.isVectorA=n[1]===1&&!r,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const p=Q0e(n[1],c,n[2],r);this.workgroupSize=p.workgroupSize,this.elementsPerThread=p.elementsPerThread}this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const d=o!=null,f=a!=null;d&&this.variableNames.push("bias"),f&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=l,this.transposeA=r,this.transposeB=s,this.addBias=d,this.activation=i,this.hasPreluActivationWeights=f,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(n[1],n[2],c),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${r}_${s}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,n,r){const s=this.workgroupSize[1]*this.elementsPerThread[1],o=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=o;const i=e%s===0,a=n%o===0,l=r%this.tileInner===0;return[i,a,l]}getUserCode(){return`
      ${Ta(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${BC(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?$y(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?$xe(this.workgroupSize,this.transposeA):ky(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Txe(t){return`
    var<workgroup> sumValues : array<f32, ${t}>;
    ${Ee()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${t}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${t/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}class Ixe{constructor(e,n=!1,r=!1,s=null,o=null,i=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize);const a=s!=null,l=i!=null;a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.transposeA=n,this.transposeB=r,this.addBias=a,this.activation=o,this.hasPreluActivationWeights=l,this.shaderKey=`matMulReduce_${this.activation}_${n}_${r}`}getUserCode(){return`
      ${Ta(this.activation,this.hasPreluActivationWeights)}
      ${BC(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${Txe(this.workgroupSize[0])}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nxe(t){const e=t[1],n=t[0],r=e>n?e:n;return`
  var<workgroup> mm_Asub : array<array<f32, ${r}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${r}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${Ee()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${r} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${r};
    globalRowB = globalRowB + ${r};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${r};
      globalRowB = globalRowB + ${r};

      for (var k = 0; k < ${r}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}class Exe{constructor(e,n,r,s=!1,o=!1,i=null,a=null,l=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=r,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(r[2]/this.workgroupSize[0]),Math.ceil(r[1]/this.workgroupSize[1]),r[0]];const c=i!=null;c&&this.variableNames.push("bias");const d=l!=null;d&&this.variableNames.push("preluActivationWeights"),this.transposeA=s,this.transposeB=o,this.addBias=c,this.activation=a,this.hasPreluActivationWeights=d,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${s}_${o}`}getUserCode(){return`
      ${Ta(this.activation,this.hasPreluActivationWeights)}
      ${BC(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${Nxe(this.workgroupSize)}
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rxe{constructor(e,n,r=!1,s=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,z(e[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const o=(r&&this.outputShape[1]%4===0||!r&&n%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=o?4:1,o||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=Re(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],n],this.workgroupSize,this.elementsPerThread),this.transposeA=r,this.transposeB=s,this.shaderKey=`matMulSplitK_${r}_${s}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`
      ${yF(!1,this.transposeB,!1,!1,!1,e)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${ut(e)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${Nl("&result[flatIndex + i]",`${e>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${e===4?$y(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):ky(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class _xe{constructor(e,n=null,r=null,s=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=n!=null,this.hasPreluActivationWeights=s!=null,this.activation=r,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${r}`}getUserCode(){return`
    ${Ta(this.activation,this.hasPreluActivationWeights)}
    ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${Hu(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pxe{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ur(t){const{backend:e,attrs:n}=t,{shape:r,value:s}=n;let{dtype:o}=n;if(o=o||$d(s),o==="string"){const i=En(o,pe(r));return i.fill(s),e.makeTensorInfo(r,o,i)}else{const i=new Pxe(r),a=[{type:"float32",data:[s]}];return e.runWebGPUProgram(i,[],o,a)}}const Axe={kernelName:Z2,backendName:"webgpu",kernelFunc:Ur};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Be(t){const{inputs:e,attrs:n}=t,{x:r}=e,{shape:s}=n,o=pe(r.shape),i=WP(s,o),a=pe(i);return z(o===a,()=>`The new shape (${i}) has ${a} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),t.backend.incRef(r.dataId),{dataId:r.dataId,shape:i,dtype:r.dtype}}const Dxe={kernelName:qw,backendName:"webgpu",kernelFunc:Be};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ty({a:t,b:e,transposeA:n,transposeB:r,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:l=null}){const c=t.shape.length,d=e.shape.length,f=n?t.shape[c-2]:t.shape[c-1],p=r?e.shape[d-1]:e.shape[d-2],g=n?t.shape[c-1]:t.shape[c-2],y=r?e.shape[d-2]:e.shape[d-1],x=t.shape.slice(0,-2),w=e.shape.slice(0,-2),S=pe(x),$=pe(w),R=ct(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([g,y]);z(f===p,()=>`Error in matMul: inner shapes (${f}) and (${p}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${r} must match.`);const _=n?[S,f,g]:[S,g,f],O=r?[$,y,p]:[$,p,y],F=Be({inputs:{x:t},backend:s,attrs:{shape:_}}),B=Be({inputs:{x:e},backend:s,attrs:{shape:O}}),M=[F,B],V=Math.max(S,$),P=[F,B],re=[{type:"int32",data:[g]},{type:"int32",data:[y]},{type:"int32",data:[f]}];let ie,me;const ge=[V,g,y];let ve=se().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(ve<0){const fe=se().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),xe=fe>0?fe:s.thresholdToIncreaseWorkgroups,ae=V*Math.ceil(g/32)*Math.ceil(y/32);ae<=xe||g<=8&&ae<=xe*2?V*g*y<=128?ve=ai.MatMulReduceProgram:V===1&&p>=2e3?ve=ai.MatMulSplitKProgram:ve=ai.MatMulSmallOutputSizeProgram:ve=ai.MatMulPackedProgram}switch(ve){case ai.MatMulReduceProgram:ie=new Ixe(ge,n,r,o,l,i);break;case ai.MatMulSplitKProgram:{if(me=Ur({backend:s,attrs:{shape:ge,value:0,dtype:t.dtype}}),ie=new Rxe(ge,p,n,r),o||l){me=s.runWebGPUProgram(ie,P,t.dtype,re,me);const xe=new _xe(me.shape,o,l,i);let ae=null;const q=[me];o&&q.push(o),i&&q.push(i),l==="leakyrelu"&&(ae=[{type:"float32",data:[a]}],xe.uniforms+=" alpha : f32,");const ue=s.runWebGPUProgram(xe,q,me.dtype,ae);M.push(me);const we=Be({inputs:{x:ue},backend:s,attrs:{shape:R}});M.push(ue);for(const Ge of M)s.disposeData(Ge.dataId);return we}break}case ai.MatMulSmallOutputSizeProgram:ie=new Exe(_,O,ge,n,r,o,l,i);break;case ai.MatMulPackedProgram:const fe=s.adapterInfo.isIntel();ie=new kxe(_,ge,n,r,o,l,i,fe);break;default:throw new Error(`Unsupported MatMulProgramType ${ve}.`)}o&&P.push(o),i&&P.push(i),l==="leakyrelu"&&(re.push({type:"float32",data:[a]}),ie.uniforms+=" alpha : f32,"),me=s.runWebGPUProgram(ie,P,t.dtype,re,me);const $e=Be({inputs:{x:me},backend:s,attrs:{shape:R}});M.push(me);for(const fe of M)s.disposeData(fe.dataId);return $e}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oxe(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:o,bias:i,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:d,leakyreluAlpha:f}=r;return Ty({a:s,b:o,transposeA:l,transposeB:c,backend:n,bias:i,preluActivationWeights:a,leakyreluAlpha:f,activation:d})}const Fxe={kernelName:bg,backendName:"webgpu",kernelFunc:Oxe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AN{constructor(e,n,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=ct(n,r),this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${zC(this.op,!1)}
      }

      ${Ee("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lg{constructor(e,n,r){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=ct(n,r),this.dispatchLayout=De(this.outputShape),this.op=e,this.useSharedMemoryWithA=n.length<=1&&r.length>1&&n[0]<128,this.useSharedMemoryWithB=r.length<=1&&n.length>1&&r[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?r[0]:n[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const s=n.length>0&&n[n.length-1]%4===0,o=r.length>0&&r[r.length-1]%4===0;s&&o?(this.outputComponent=4,this.variableComponents=[4,4]):s&&(lI(r)||r[r.length-1]===1)||o&&(lI(n)||n[n.length-1]===1)?(this.outputComponent=4,this.variableComponents=s?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const n=this.outputComponent===4?"vec4<f32>":"f32",r=`
    fn binaryOperation(a : ${n}, b : ${n}) -> ${n} {
      ${zC(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){const s=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",o=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${s}];`:`let a = sharedBuf[${s}];
          let b = getBByOutputIndex(index);`;e=`
        ${r}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${Ee("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${o}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${r}
       ${Ee("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${n}(getAByOutputCoords(coords));
           let b = ${n}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gs(t){const{inputs:e}=t,{x:n}=e;return t.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const Lxe={kernelName:ry,backendName:"webgpu",kernelFunc:gs};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ku(t){const{inputs:e,backend:n}=t,{real:r,imag:s}=e,o=n.makeTensorInfo(r.shape,"complex64"),i=n.tensorMap.get(o.dataId),a=gs({inputs:{x:r},backend:n}),l=gs({inputs:{x:s},backend:n});return i.complexTensorInfos={real:a,imag:l},o}const zxe={kernelName:C2,backendName:"webgpu",kernelFunc:Ku};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fd{constructor(e,n,r=""){this.variableNames=["A"],this.size=!0;const s=128;this.workgroupSize=[s,1,1],this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=n,r!==""&&(this.uniforms=r),this.shaderKey=`unary_${n}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${uu(this.op,!1)}
      }
      ${Ee("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kt({opType:t,cpuKernelImpl:e,dtype:n}){return({inputs:r,backend:s})=>{const{x:o}=r,i=s,a=n||o.dtype;if(i.shouldExecuteOnCPU([o])&&e!=null){const c=i.tensorMap.get(o.dataId),d=e(c.values,a);return i.makeTensorInfo(o.shape,a,d)}const l=new Fd(o.shape,t);return i.runWebGPUProgram(l,[o],a)}}function zn({opType:t,cpuKernelImpl:e,supportsComplex:n=!1,dtype:r}){return({inputs:s,backend:o})=>{const{a:i,b:a}=s,l=o;if(n&&i.dtype==="complex64"){const f=l.tensorMap.get(i.dataId),p=l.tensorMap.get(a.dataId);let g,y;if(t!==Je.MUL)[g,y]=[[f.complexTensorInfos.real,p.complexTensorInfos.real],[f.complexTensorInfos.imag,p.complexTensorInfos.imag]].map(w=>{const[S,$]=w,I={dataId:S.dataId,dtype:S.dtype,shape:i.shape},R={dataId:$.dataId,dtype:$.dtype,shape:a.shape},_=new Lg(t,i.shape,a.shape);return l.runWebGPUProgram(_,[I,R],jr(S.dtype,$.dtype))});else{const w=new AN(Je.COMPLEX_MULTIPLY_REAL,i.shape,a.shape),S=new AN(Je.COMPLEX_MULTIPLY_IMAG,i.shape,a.shape),$=[{dataId:f.complexTensorInfos.real.dataId,dtype:f.complexTensorInfos.real.dtype,shape:i.shape},{dataId:f.complexTensorInfos.imag.dataId,dtype:f.complexTensorInfos.imag.dtype,shape:i.shape},{dataId:p.complexTensorInfos.real.dataId,dtype:p.complexTensorInfos.real.dtype,shape:a.shape},{dataId:p.complexTensorInfos.imag.dataId,dtype:p.complexTensorInfos.imag.dtype,shape:a.shape}];g=l.runWebGPUProgram(w,$,"float32"),y=l.runWebGPUProgram(S,$,"float32")}const x=Ku({inputs:{real:g,imag:y},backend:l});return l.disposeData(g.dataId),l.disposeData(y.dataId),x}const c=r||jr(i.dtype,a.dtype);if((i.dtype==="string"||a.dtype==="string"||l.shouldExecuteOnCPU([i,a]))&&e!=null){const f=l.tensorMap.get(i.dataId).values,p=l.tensorMap.get(a.dataId).values,g=i.dtype==="string"?bl(f):f,y=i.dtype==="string"?bl(p):p,[x,w]=e(i.shape,a.shape,g,y,c);return l.makeTensorInfo(w,c,x)}const d=new Lg(t,i.shape,a.shape);return l.runWebGPUProgram(d,[i,a],c)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:Bxe,castImpl:Mxe,ceilImpl:Vxe,concatImpl:Wxe,equalImpl:Uxe,expImpl:jxe,expm1Impl:Gxe,floorImpl:Hxe,floorDivImpl:Kxe,gatherNdImpl:Xxe,gatherV2Impl:qxe,greaterEqualImpl:Yxe,greaterImpl:Qxe,lessEqualImpl:Zxe,lessImpl:Jxe,logImpl:eve,maxImpl:tve,maximumImpl:nve,minimumImpl:rve,multiplyImpl:sve,negImpl:ove,notEqualImpl:ive,prodImpl:ave,rangeImpl:lve,rsqrtImpl:uve,scatterImpl:cve,simpleAbsImpl:dve,sliceImpl:hve,stridedSliceImpl:fve,stringNGramsImpl:pve,subImpl:mve,tileImpl:gve,topKImpl:yve,transposeImpl:xve}=NO;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vve=kt({opType:Ne.ABS,cpuKernelImpl:dve}),bve={kernelName:n2,backendName:"webgpu",kernelFunc:vve};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wve=kt({opType:Ne.ACOS}),Sve={kernelName:r2,backendName:"webgpu",kernelFunc:wve};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cve=kt({opType:Ne.ACOSH}),$ve={kernelName:s2,backendName:"webgpu",kernelFunc:Cve};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kve=zn({opType:Je.ADD,cpuKernelImpl:Bxe,supportsComplex:!0}),Tve={kernelName:ty,backendName:"webgpu",kernelFunc:kve};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ive{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((n,r)=>`T${r}`),this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(s=>{e.push(`let v${s} = get${s}ByOutputCoords(coords);`)});const n=this.variableNames.map(s=>`v${s}`).join(" + ");return`
      ${Ee("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${n});
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nve(t){const{inputs:e,backend:n}=t,r=e;if(r.length===1)return gs({inputs:{x:r[0]},backend:n});const s=r.map(a=>a.dtype).reduce((a,l)=>jr(a,l)),o=r.map(a=>a.shape),i=new Ive(o);return n.runWebGPUProgram(i,r,s)}const Eve={kernelName:o2,backendName:"webgpu",kernelFunc:Nve};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rve{constructor(e,n){this.variableNames=["A"],this.workgroupSize=[16,16,1];const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[n[s]];this.outputShape=r,this.dispatchLayout={x:[0],y:[1]},this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){z(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const e=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${Ee()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _ve{constructor(e,n){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[n[s]];this.outputShape=r,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=n,this.shaderKey=`transpose_${n}`}getUserCode(){const e=bn(this.outputShape.length),n=xF(this.newDim);return`
      ${Ee("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${n}), uniforms.aShape)]);
          }
        }
      }
    `}}function xF(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=new Array(e);for(let r=0;r<t.length;r++)n[t[r]]=`coords.${la(r)}`;return n.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ci(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{perm:o}=r,i=n,a=s.shape.length,l=new Array(a);for(let d=0;d<l.length;d++)l[d]=s.shape[o[d]];if(n.shouldExecuteOnCPU([s])){const f=i.tensorMap.get(s.dataId).values,p=xve(f,s.shape,s.dtype,o,l);return n.makeTensorInfo(l,s.dtype,p)}if(s.shape.length===2&&Vt(o,[1,0])){const d=new Rve(s.shape,o);return i.runWebGPUProgram(d,[s],s.dtype)}const c=new _ve(s.shape,o);return i.runWebGPUProgram(c,[s],s.dtype)}const Pve={kernelName:Yh,backendName:"webgpu",kernelFunc:Ci};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ave{constructor(e,n,r){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[s]=Fs(this.inputShape,[1]);this.outputShape=s.length===0?[1]:s,e.inSize>=32768&&r>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=n,this.shaderKey=`reduce_${n}`}getUserCode(){let e="",n="0.0";const r=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,n="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(e=" bestValue = bestValue * candidate; ",n="1.0"):this.reduceType==="all"?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",n="1.0"):this.reduceType==="any"&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",n="0.0");const s=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${r}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${Ee("index")} {
         let outputIndex = index / ${r};
         let offset = getOffset(outputIndex);
         var bestValue = ${n};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${r}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${r}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${r}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${s}
        }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dve={mean:"float32",all:"bool",any:"bool"};function Xu(t,e,n,r,s){const o=t.shape.length,i=[],a=nn(e,t.shape);let l=a;const c=lr(l,o);let d=t;c!=null&&(d=Ci({inputs:{x:t},attrs:{perm:c},backend:s}),l=ur(l.length,o),i.push(d)),vs(r,l,o);const[f,p]=Fs(d.shape,l);let g=f;n&&(g=xs(f,a));let y;if((r==="max"||r==="prod")&&s.shouldExecuteOnCPU([d])){const x=s.tensorMap.get(d.dataId).values;switch(r){case"max":const w=tve(x,pe(p),g,t.dtype);y=s.makeTensorInfo(g,t.dtype,w);break;case"prod":const{outVals:S,outShape:$,outDtype:I}=ave(d.shape,d.dtype,x,l);y=s.makeTensorInfo($,I,S);break;default:throw new Error(`${r} CPU implementation is not yet supported.`)}}else{const x=pe(p),S=pe(d.shape)/x,$={windowSize:x,inSize:x,batchSize:S,outSize:1},I=Dve[r]||ay(t.dtype),R=[{type:"int32",data:[x]}],_=new Ave($,r,s.device.limits.maxComputeWorkgroupSizeX),O=s.runWebGPUProgram(_,[d],I,R);i.push(O),y=Be({inputs:{x:O},attrs:{shape:g},backend:s})}return i.forEach(x=>s.disposeData(x.dataId)),y}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ove(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{keepDims:o,axis:i}=r;return Xu(s,i,o,"all",n)}const Fve={kernelName:i2,backendName:"webgpu",kernelFunc:Ove};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lve(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{keepDims:o,axis:i}=r;return Xu(s,i,o,"any",n)}const zve={kernelName:a2,backendName:"webgpu",kernelFunc:Lve};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vF{constructor(e,n,r){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const s=[n];this.op=r==="min"?"<":">";const[o,i]=Fs(e,s);this.outputShape=o.length===0?[1]:o,this.dispatchLayout=De(this.outputShape),pe(i)<32?(this.type="plain",this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=Re(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],n=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${la(this.inputShape.length-1)}`,r=()=>{let s="";if(this.outputShape.length===1)this.inputShape.length!==1&&(s+="outputCoords,");else for(let o=0;o<this.outputShape.length;o++)s+=`outputCoords.${la(o)},`;return s};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    `}

      ${Ee("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${n()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${r()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${r()} 0);
          let reduceLength = ${n()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${r()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bve(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o}=r;let i=nn(o,s.shape);const a=lr(i,s.shape.length);let l=s;const c=[];a!=null&&(l=Ci({inputs:{x:s},backend:n,attrs:{perm:a}}),c.push(l),i=ur(i.length,l.shape.length)),vs("argMax",[i[0]],l.shape.length);const d=new vF(l.shape,i[0],"max"),f=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],p=n.runWebGPUProgram(d,[l],"int32",f);return c.forEach(g=>n.disposeData(g.dataId)),p}const Mve={kernelName:l2,backendName:"webgpu",kernelFunc:Bve};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vve(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o}=r;let i=nn(o,s.shape);const a=lr(i,s.shape.length);let l=s;const c=[];a!=null&&(l=Ci({inputs:{x:s},backend:n,attrs:{perm:a}}),c.push(l),i=ur(i.length,l.shape.length)),vs("argMin",[i[0]],l.shape.length);const d=new vF(l.shape,i[0],"min"),f=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],p=n.runWebGPUProgram(d,[l],"int32",f);return c.forEach(g=>n.disposeData(g.dataId)),p}const Wve={kernelName:u2,backendName:"webgpu",kernelFunc:Vve};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uve=kt({opType:Ne.ASIN}),jve={kernelName:c2,backendName:"webgpu",kernelFunc:Uve};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gve=kt({opType:Ne.ASINH}),Hve={kernelName:d2,backendName:"webgpu",kernelFunc:Gve};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kve=kt({opType:Ne.ATAN}),Xve={kernelName:h2,backendName:"webgpu",kernelFunc:Kve};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qve=zn({opType:Je.ATAN2}),Yve={kernelName:p2,backendName:"webgpu",kernelFunc:qve};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qve=kt({opType:Ne.ATANH}),Zve={kernelName:f2,backendName:"webgpu",kernelFunc:Qve};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jve{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rf{constructor(e,n,r=!1,s=!1,o=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=n,this.computePositions=r,this.flattenPositions=s,this.includeBatchIndex=o,this.shaderKey=`pool2D_${n}_${r}_${s}_${o}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:e="resultValue = max(value, resultValue);";let n="resultValue";return this.poolType==="avg"&&(n="resultValue / max(count, 1.0)"),`
      ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${n});`}
        }
      }
    `}}class MC{constructor(e,n,r=!1,s=!1,o=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=n,this.computePositions=r,this.flattenPositions=s,this.includeBatchIndex=o,this.shaderKey=`pool3D_${n}_${r}_${s}_${o}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue += value; count += 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:e="resultValue = max(value, resultValue);";let n="resultValue";return this.poolType==="avg"&&(n="resultValue / max(count, 1.0)"),`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${n});`}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bF(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reductionIndices:o,keepDims:i}=r;return Xu(s,o,i,"max",n)}const ebe={kernelName:Sw,backendName:"webgpu",kernelFunc:bF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wF(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{keepDims:o,axis:i}=r;return Xu(s,i,o,"mean",n)}const tbe={kernelName:Iw,backendName:"webgpu",kernelFunc:wF};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SF(t,e,n,r){if(e.filterWidth===1&&e.filterHeight===1&&Vt(e.inShape,e.outShape))return gs({inputs:{x:t},backend:r});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&e.batchSize===1&&e.padInfo.type==="VALID"){const i=t.shape.length,a=Be({inputs:{x:t},backend:r,attrs:{shape:[t.shape[i-3]*t.shape[i-2],t.shape[i-1]]}});let l;n==="avg"?l=wF({inputs:{x:a},backend:r,attrs:{axis:0,keepDims:!1}}):(z(n==="max",()=>`Invalid pool type ${n}`),l=bF({inputs:{x:a},backend:r,attrs:{reductionIndices:0,keepDims:!1}}));const c=Be({inputs:{x:l},backend:r,attrs:{shape:e.outShape}});return r.disposeData(a.dataId),r.disposeData(l.dataId),c}let s;const o=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return e.filterHeight===1&&e.filterWidth===1?s=new Jve(e):(n==="avg"?s=new Rf(e,"avg"):(z(n==="max",()=>`Invalid pool type ${n}`),s=new Rf(e,"max")),o.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),r.runWebGPUProgram(s,[t],t.dtype,o)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nbe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r,d=fo(s.shape,o,i,1,a,l);return SF(s,d,"avg",n)}const rbe={kernelName:m2,backendName:"webgpu",kernelFunc:nbe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sbe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:i,pad:a,dataFormat:l,dimRoundingMode:c}=r,d=[1,1,1],f=Sa(s.shape,o,i,d,a,c,l),p=new MC(f,"avg"),g=[{type:"int32",data:[f.strideDepth,f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.front,f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inDepth,f.inHeight,f.inWidth]},{type:"int32",data:[f.effectiveFilterDepth,f.effectiveFilterHeight,f.effectiveFilterWidth]}];return n.runWebGPUProgram(p,[s],s.dtype,g)}const obe={kernelName:g2,backendName:"webgpu",kernelFunc:sbe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ibe{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class abe{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lbe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,i=o,{filterSize:a,strides:l,pad:c,dimRoundingMode:d}=r,f=Sa(i.shape,a,l,1,c,d),p=new abe(f),g=1/(f.filterDepth*f.filterHeight*f.filterWidth),y=[{type:"int32",data:[f.strideDepth,f.strideHeight,f.strideWidth]},{type:"int32",data:[f.effectiveFilterDepth-1-f.padInfo.front,f.effectiveFilterHeight-1-f.padInfo.top,f.effectiveFilterWidth-1-f.padInfo.left]},{type:"int32",data:[f.effectiveFilterDepth,f.effectiveFilterHeight,f.effectiveFilterWidth]},{type:"int32",data:[f.outDepth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"float32",data:[g]}];return n.runWebGPUProgram(p,[s],i.dtype,y)}const ube={kernelName:qP,backendName:"webgpu",kernelFunc:lbe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cbe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,i=o;gF([s,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,d=fo(i.shape,a,l,1,c),f=new ibe(d),p=1/(d.filterHeight*d.filterWidth),g=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"float32",data:[p]}];return n.runWebGPUProgram(f,[s],i.dtype,g)}const dbe={kernelName:XP,backendName:"webgpu",kernelFunc:cbe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hbe(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:o}=e,{transposeA:i,transposeB:a}=r;return Ty({a:s,b:o,transposeA:i,transposeB:a,backend:n})}const fbe={kernelName:y2,backendName:"webgpu",kernelFunc:hbe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pbe{constructor(e,n){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.rank=n.length,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${bn(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=bn(this.rank),n=mbe(this.rank);let r;return this.start.length===1?r=this.outputShape.map((o,i)=>"sourceLoc = uniforms.start + coords;"):r=this.outputShape.map((o,i)=>`sourceLoc.${Ov[i]} = uniforms.start.${la(i)} + coords.${Ov[i]};`),`
      ${Ee("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${r.join(`
`)}
          setOutputAtIndex(index, getSource(${n}));
        }
      }
    `}}const Ov=["x","y","z","w","u","v"];function mbe(t){if(t===1)return"sourceLoc";if(t<=6)return Ov.slice(0,t).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ld(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:o,size:i}=r,[a,l]=oC(s,o,i);if(tC(s,a,l),n.shouldExecuteOnCPU([s])||s.dtype==="string"){const f=n.tensorMap.get(s.dataId),p=hve(f.values,a,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,p)}if(pe(l)===0)return n.makeTensorInfo(l,s.dtype,[]);const c=new pbe(a,l),d=[{type:"int32",data:a}];return n.runWebGPUProgram(c,[s],s.dtype,d)}const gbe={kernelName:aS,backendName:"webgpu",kernelFunc:Ld};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ybe=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:o,crops:i}=r;z(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const a=o.reduce(($,I)=>$*I),l=Yf(s.shape,o,a),c=Qf(l.length,o.length),d=Zf(s.shape,o,a),f=cC(i,o.length),p=dC(d,i,o.length),g=[],y=Be({inputs:{x:s},backend:n,attrs:{shape:l}}),x=Ci({inputs:{x:y},backend:n,attrs:{perm:c}}),w=Be({inputs:{x},backend:n,attrs:{shape:d}}),S=Ld({inputs:{x:w},backend:n,attrs:{begin:f,size:p}});return g.push(y),g.push(x),g.push(w),g.forEach($=>n.disposeData($.dataId)),S},xbe={kernelName:x2,backendName:"webgpu",kernelFunc:ybe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vbe=`
  fn bincount_write(index: i32, value: f32) {
    ${Nl("&result[index]","value","float32")}
  }
`,bbe=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;class CF{constructor(e,n,r=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=r,r&&(this.atomic=!1),this.hasWeights=n,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?bbe:vbe}
  ${Ee("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wbe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:o}=e,{size:i}=r,a=pe(s.shape),c=pe(o.shape)>0,d=[i],f=o.dtype,p=Ur({backend:n,attrs:{shape:d,value:0,dtype:f}}),g=new CF([a],c),y=[{type:"int32",data:[i]}],x=c?[s,o]:[s];return n.runWebGPUProgram(g,x,f,y,p)}const Sbe={kernelName:v2,backendName:"webgpu",kernelFunc:wbe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cbe{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${Ee("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $be(t){const{inputs:e,backend:n}=t,{s0:r,s1:s}=e;if(n.shouldExecuteOnCPU([r,s])){const d=n.tensorMap.get(r.dataId),f=n.tensorMap.get(s.dataId),p=d.values,g=f.values,y=ct(Array.from(p),Array.from(g));return n.makeTensorInfo([y.length],"int32",Int32Array.from(y))}const o=pe(r.shape),i=pe(s.shape),a=Math.max(o,i),l=new Cbe(a),c=[{type:"int32",data:[o]},{type:"int32",data:[i]}];return n.runWebGPUProgram(l,[r,s],"int32",c)}const kbe={kernelName:b2,backendName:"webgpu",kernelFunc:$be};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $F=zn({opType:Je.NOT_EQUAL,dtype:"bool",cpuKernelImpl:ive}),Tbe={kernelName:Ow,backendName:"webgpu",kernelFunc:$F};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sp(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.tensorMap.get(r.dataId);return gs({inputs:{x:s.complexTensorInfos.real},backend:n})}const Ibe={kernelName:Hw,backendName:"webgpu",kernelFunc:sp};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nbe(t,e){const n=new Fd(t.shape,Ne.TO_INT),r=e.runWebGPUProgram(n,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fv(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dtype:o}=r;if(o==="complex64"){if(s.dtype==="complex64")return gs({inputs:{x:s},backend:n});const i=xa(s.shape),a=Fv({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),l=Ku({inputs:{real:a,imag:i},backend:n});return i.dispose(),n.disposeData(a.dataId),l}if(s.dtype==="complex64"){const i=sp({inputs:{input:s},backend:n}),a=Fv({inputs:{x:i},backend:n,attrs:{dtype:o}});return n.disposeData(i.dataId),a}if(!UP(s.dtype,o)){const i=gs({inputs:{x:s},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:o}}if(n.shouldExecuteOnCPU([s])){const i=n.tensorMap.get(s.dataId).values,[a,l,c]=Mxe(i,s.shape,s.dtype,o);return n.makeTensorInfo(a,l,c)}if(o==="int32")return Nbe(s,n);if(o==="bool"){const i=n.makeTensorInfo([],"bool",Si("bool",1)),l=$F({inputs:{a:s,b:i},backend:n});return n.disposeData(i.dataId),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}const Ebe={kernelName:ny,backendName:"webgpu",kernelFunc:Fv};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rbe=kt({opType:Ne.CEIL,cpuKernelImpl:Vxe}),_be={kernelName:w2,backendName:"webgpu",kernelFunc:Rbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pbe{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${Ee("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Abe{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${Ee("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dbe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{clipValueMin:o,clipValueMax:i}=r;let a;const l=[{type:"float32",data:[o]},{type:"float32",data:[i]}];return pe(s.shape)%4===0?a=new Pbe(s.shape):a=new Abe(s.shape),n.runWebGPUProgram(a,[s],s.dtype,l)}const Obe={kernelName:S2,backendName:"webgpu",kernelFunc:Dbe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fbe{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DN(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}function Lbe(t){const{inputs:e,backend:n}=t,{x:r}=e,s=n.tensorMap.get(r.dataId),o=new Fbe(r.shape),i=[DN(r,s.complexTensorInfos.real),DN(r,s.complexTensorInfos.imag)];return n.runWebGPUProgram(o,i,i[0].dtype)}const zbe={kernelName:$2,backendName:"webgpu",kernelFunc:Lbe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bbe{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=co(e,1),this.variableNames=e.map((n,r)=>`T${r}`),this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let n=0;n<this.offsetLength;n++)this.uniforms+=`offset${n} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let o=1;o<this.offsetLength;o++)e.push(`else if (yC < uniforms.offset${[o]}){ setOutputAtCoords(coords.x, coords.y, getT${o}(yR, yC - uniforms.offset${o-1})); }`);const r=this.offsetLength,s=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${r}(yR, yC - uniforms.offset${s})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${Ee("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iy(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.tensorMap.get(r.dataId);return gs({inputs:{x:s.complexTensorInfos.imag},backend:n})}const Mbe={kernelName:lw,backendName:"webgpu",kernelFunc:Iy};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zh(t,e,n){const r=t[0].dtype;if(r==="complex64"){const y=t.map(I=>sp({inputs:{input:I},backend:n})),x=t.map(I=>Iy({inputs:{input:I},backend:n})),w=zh(y,e,n),S=zh(x,e,n),$=Ku({inputs:{real:w,imag:S},backend:n});return y.forEach(I=>n.disposeData(I.dataId)),x.forEach(I=>n.disposeData(I.dataId)),n.disposeData(w.dataId),n.disposeData(S.dataId),$}let s=n.shouldExecuteOnCPU(t);if(r==="string"&&(s=!0),s){const y=t.map(_=>{const F=[-1,pe(_.shape.slice(e))];return Be({inputs:{x:_},backend:n,attrs:{shape:F}})}),x=y.map(_=>({vals:n.readSync(_.dataId),shape:_.shape})),w=co(y.map(_=>_.shape),1),S=y[0].shape[0]===1,$=Wxe(x,w,r,S),I=co(t.map(_=>_.shape),e),R=n.makeTensorInfo(I,r,$);return y.forEach(_=>n.disposeData(_.dataId)),R}const o=n.device.limits.maxStorageBuffersPerShaderStage-1;if(t.length>o){const y=[];for(let w=0;w<t.length;w+=o){const S=t.slice(w,w+o);y.push(zh(S,e,n))}const x=zh(y,e,n);for(const w of y)n.disposeData(w.dataId);return x}const{tensors2D:i,outShape:a}=Vbe(t,e,n),l=i.map(y=>y.shape),c=new Bbe(l),d=[],f=new Array(l.length-1);if(f.length>0){f[0]=l[0][1],d.push({type:"int32",data:[f[0]]});for(let y=1;y<f.length;y++)f[y]=f[y-1]+l[y][1],d.push({type:"int32",data:[f[y]]})}const p=n.runWebGPUProgram(c,i,i[0].dtype,d);i.forEach(y=>n.disposeData(y.dataId));const g=Be({inputs:{x:p},backend:n,attrs:{shape:a}});return n.disposeData(p.dataId),g}function Vbe(t,e,n){const r=co(t.map(o=>o.shape),e);return{tensors2D:t.map(o=>Be({inputs:{x:o},backend:n,attrs:{shape:[pe(o.shape.slice(0,e)),pe(o.shape.slice(e))]}})),outShape:r}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kF(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r,o=nn(s,e[0].shape)[0],i=e.map(c=>c.shape);aC(i,o);const a=co(e.map(c=>c.shape),o);if(pe(a)===0)return n.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(c=>pe(c.shape)>0);return l.length===1?gs({inputs:{x:l[0]},backend:n}):zh(l,o,n)}const Wbe={kernelName:k2,backendName:"webgpu",kernelFunc:kF};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ube(t,e,n,r,s=!1,o=null,i=!1,a=4,l=4,c=4){const d=M=>{switch(M){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${M} is not supported.`)}},f=M=>{switch(M){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${M} is not supported.`)}},p=t?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,g=t?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,y=t?"uniforms.xShape[1]":"uniforms.xShape[2]",x=t?"uniforms.xShape[2]":"uniforms.xShape[3]",w=t?"row":"col",S=t?"col":"row",$=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${t?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${w} / outWidth;
      let outCol = ${w} % outWidth;

      let WRow = ${S} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${S} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${S} % inChannels;
      var resData = ${ut(a)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${y} && xCol >= 0 && xCol < ${x}) {
        ${p}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${d(a)}
      }
      return resData;`,I=t?e&&r?`
      ${$}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${$}
      }
      return ${ut(a)}(0.0);`:r&&n?`
      ${$}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${$}
      }
      return ${ut(a)}(0.0);`,R=`${f(l)}`,_=ut(c),O=ut(t?a:l),F=ut(t?l:a);return`
      ${Ta(o,i,c===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${O} {
        ${t?I:R}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${F} {
        ${t?R:I}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${_}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${t?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${g}
        ${Hu(s,o)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}class jbe{constructor(e,n,r,s,o=!1,i=null,a=!1,l=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=fF(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=pF(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),o&&(this.variableNames.push("bias"),this.variableComponents.push(4)),a&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],o&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=l,this.addBias=o,this.activation=i,this.hasPreluActivationWeights=a,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=n%this.tileAOuter===0,this.fitBOuter=r%this.tileBOuter===0,this.fitInner=s%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?$y(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):ky(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),n=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${Ube(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,n[0],n[1],n[2])}
    ${e}
  `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gbe{constructor(e,n=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=n,this.activation=r,this.hasPreluActivationWeights=s,n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${Ta(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${Hu(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${Ee("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hbe{constructor(e,n){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=n,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,n=this.isChannelsLast?2:3,r=this.isChannelsLast?"coords[1]":"coords[2]",s=this.isChannelsLast?"coords[2]":"coords[1]",o=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${Ee("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${r};
        let col = ${s};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${n}] && xCol >= 0) {
            value = ${o};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zg(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&n===1&&t[0]>1?[t[0],1]:null}function Kbe({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const l=n.dataFormat==="channelsLast",c=!l,d=!1,f=l&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&n.padInfo.type==="VALID",p=[];let g,y;if(f){const S=n.inHeight*n.inWidth*n.inChannels;g=Be({inputs:{x:t},backend:r,attrs:{shape:[1,n.batchSize,S]}}),y=Be({inputs:{x:e},backend:r,attrs:{shape:[1,S,n.outChannels]}})}else g=Be({inputs:{x:t},backend:r,attrs:{shape:l?[n.batchSize,n.inHeight*n.inWidth,n.inChannels]:[n.batchSize,n.inChannels,n.inHeight*n.inWidth]}}),y=Be({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});if(p.push(g),p.push(y),o!=null){const S=zg(o.shape,l);S!=null&&(o=Be({inputs:{x:o},backend:r,attrs:{shape:S}}),p.push(o))}if(s!=null){const S=zg(s.shape,l);S!=null&&(s=Be({inputs:{x:s},backend:r,attrs:{shape:S}}),p.push(s))}const x=Ty({a:l?g:y,b:l?y:g,transposeA:c,transposeB:d,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),w=Be({inputs:{x},backend:r,attrs:{shape:n.outShape}});p.push(x);for(const S of p)r.disposeData(S.dataId);return w}function Xbe({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:d,strideWidth:f,strideHeight:p,padInfo:g,outWidth:y,outHeight:x,dilationWidth:w,dilationHeight:S,dataFormat:$}=n,I=$==="channelsLast",R=l*c*d,_=x*y,O=I?[n.batchSize,_,R]:[n.batchSize,R,_],F=new Hbe(O,I),B=[{type:"int32",data:[g.top,g.left]},{type:"int32",data:[p,f]},{type:"int32",data:[S,w]},{type:"int32",data:[y]},{type:"int32",data:[d*l]},{type:"int32",data:[d]}],M=r.runWebGPUProgram(F,[t],t.dtype,B),V=[];V.push(M);const P=Be({inputs:{x:e},backend:r,attrs:{shape:[1,R,-1]}});if(V.push(P),o!=null){const ve=zg(o.shape,I);ve!=null&&(o=Be({inputs:{x:o},backend:r,attrs:{shape:ve}}),V.push(o))}if(s!=null){const ve=zg(s.shape,I);ve!=null&&(s=Be({inputs:{x:s},backend:r,attrs:{shape:ve}}),V.push(s))}const me=Ty({a:I?M:P,b:I?P:M,transposeA:!I,transposeB:!1,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),ge=Be({inputs:{x:me},backend:r,attrs:{shape:n.outShape}});V.push(me);for(const ve of V)r.disposeData(ve.dataId);return ge}function TF({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const l=s!=null,c=o!=null,d=n.dataFormat==="channelsLast",f=d&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&n.padInfo.type==="VALID",p=se().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!p&&(f||n.filterHeight===1&&n.filterWidth===1&&n.dilationHeight===1&&n.dilationWidth===1&&n.strideHeight===1&&n.strideWidth===1&&(n.padInfo.type==="SAME"||n.padInfo.type==="VALID")))return Kbe({x:t,filter:e,convInfo:n,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i});const g=se().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),y=g>-1?g:r.thresholdToIncreaseWorkgroups,x=n.batchSize*Math.ceil(n.outHeight*n.outWidth/32)*Math.ceil(n.outChannels/32);if(se().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||x<=y)return Xbe({x:t,filter:e,convInfo:n,backend:r,bias:s,preluActivationWeights:o,leakyreluAlpha:i,activation:a});let w;const S=[n.padInfo.top,n.padInfo.left],$=[{type:"int32",data:[n.filterHeight,n.filterWidth]},{type:"int32",data:[...S]},{type:"int32",data:[n.strideHeight,n.strideWidth]},{type:"int32",data:[n.dilationHeight,n.dilationWidth]}];if(p)w=new Gbe(n,l,a,c);else{const O=d?n.outHeight*n.outWidth:n.outChannels,F=d?n.outChannels:n.outHeight*n.outWidth,B=n.filterHeight*n.filterWidth*n.inChannels;$.push({type:"int32",data:[O]},{type:"int32",data:[F]},{type:"int32",data:[B]});const M=r.adapterInfo.isIntel();w=new jbe(n,O,F,B,l,a,c,M)}const I=[],R=[t,e];l&&(!d&&s.shape.length===1&&(s=Be({inputs:{x:s},backend:r,attrs:{shape:[s.shape[0],1,1]}}),I.push(s)),R.push(s)),c&&(!d&&o.shape.length===1&&(o=Be({inputs:{x:o},backend:r,attrs:{shape:[o.shape[0],1,1]}}),I.push(o)),R.push(o)),a==="leakyrelu"&&($.push({type:"float32",data:[i]}),w.uniforms+=" alpha : f32,");const _=r.runWebGPUProgram(w,R,t.dtype,$);for(const O of I)r.disposeData(O.dataId);return _}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qbe(t){const{inputs:e,attrs:n,backend:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dataFormat:l,dilations:c,dimRoundingMode:d}=n,f=Mo(l),p=kn(s.shape,o.shape,i,c,a,d,!1,f);return TF({x:s,filter:o,convInfo:p,backend:r})}const Ybe={kernelName:T2,backendName:"webgpu",kernelFunc:qbe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qbe{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&e.outChannels%4===0&&e.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,n=this.isChannelsLast?2:3,r=this.isChannelsLast?3:1,s=`
    ${Ee()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${s}
    `:`
    ${Ee("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${r}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${n}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class Zbe{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${Ee("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class Jbe{constructor(e){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${Ee("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class e2e{constructor(e){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${Ee("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t2e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:i,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:d}=r,f=Mo(l),p=kn(s.shape,d,i,1,a,c,!1,f),g=new Zbe(p),y=[{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.batchSize]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"int32",data:[p.inHeight]},{type:"int32",data:[p.inWidth]}];return n.runWebGPUProgram(g,[s,o],s.dtype,y)}const n2e={kernelName:I2,backendName:"webgpu",kernelFunc:t2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r2e(t=4){const e=o=>{switch(o){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${o} is not supported.`)}},r=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${ut(t)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${ut(t)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${t}];`}
      }
      return ${ut(t)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${ut(t)} {
    ${r}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${ut(t)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(t)}
    }
    return ${ut(t)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${ut(t)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${t}] = value;
    }
  }`}class s2e{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,z(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=fF(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=pF(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?$y(this.elementsPerThread,this.workgroupSize):ky(this.elementsPerThread,this.workgroupSize);return`
    ${r2e(this.isVec4?4:1)}
    ${e}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o2e(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{inputShape:i,strides:a,pad:l,dataFormat:c,dimRoundingMode:d}=r,f=Mo(c),p=kn(i,o.shape,a,1,l,d,!1,f),g=[{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.filterHeight-1-p.padInfo.top,p.filterWidth-1-p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.batchSize,p.outHeight,p.outWidth,p.outChannels]}];let y;if(se().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||p.dataFormat!=="channelsLast")y=new Qbe(p);else{y=new s2e(p);const x=p.inHeight*p.inWidth,w=p.inChannels,S=p.filterHeight*p.filterWidth*p.outChannels;g.push({type:"uint32",data:[x]},{type:"uint32",data:[w]},{type:"uint32",data:[S]})}return n.runWebGPUProgram(y,[s,o],"float32",g)}const i2e={kernelName:N2,backendName:"webgpu",kernelFunc:o2e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class a2e{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l2e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dilations:l}=r,c=Tl(s.shape,o.shape,i,l,a),d=[c.padInfo.front,c.padInfo.top,c.padInfo.left],f=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[...d]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationDepth,c.dilationHeight,c.dilationWidth]}],p=new a2e(c),g=jr(s.dtype,o.dtype);return n.runWebGPUProgram(p,[s,o],g,f)}const u2e={kernelName:E2,backendName:"webgpu",kernelFunc:l2e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c2e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:i,pad:a,filterShape:l}=r,c=Tl(s.shape,l,i,1,a),d=new Jbe(c),f=[{type:"int32",data:[c.padInfo.front,c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.batchSize]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.inDepth]},{type:"int32",data:[c.inHeight]},{type:"int32",data:[c.inWidth]}];return n.runWebGPUProgram(d,[s,o],o.dtype,f)}const d2e={kernelName:QP,backendName:"webgpu",kernelFunc:c2e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h2e(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{strides:i,pad:a,inputShape:l}=r,c=Tl(l,o.shape,i,1,a),d=new e2e(c),f=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[c.filterDepth-1-c.padInfo.front,c.filterHeight-1-c.padInfo.top,c.filterWidth-1-c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.outChannels]}];return n.runWebGPUProgram(d,[s,o],s.dtype,f)}const f2e={kernelName:R2,backendName:"webgpu",kernelFunc:h2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p2e=kt({opType:Ne.COS}),m2e={kernelName:_2,backendName:"webgpu",kernelFunc:p2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g2e=kt({opType:Ne.COSH}),y2e={kernelName:P2,backendName:"webgpu",kernelFunc:g2e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class x2e{constructor(e,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[o]=n;this.outputShape=[o,r[0],r[1],e],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=s==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,n]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[r,s,o]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[i,a,l]=this.cropWidthBiggerThan1?[`(${n} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${n} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${n}`];return`
    ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${r});
        let width_ratio = f32(${i});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${s};
        let width_scale = ${a};
        let in_y = ${o};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${l};
        if( in_x < 0.0 || in_x > ${n} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v2e=t=>{const{inputs:e,backend:n,attrs:r}=t,{image:s,boxes:o,boxInd:i}=e,{cropSize:a,method:l,extrapolationValue:c}=r,d=new x2e(s.shape[3],o.shape,a,l),f=[{type:"float32",data:[c]}];return n.runWebGPUProgram(d,[s,o,i],"float32",f)},b2e={kernelName:O2,backendName:"webgpu",kernelFunc:v2e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var _f;(function(t){t.Prod="*",t.Sum="+"})(_f||(_f={}));class ON{constructor(e,n,r,s){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=n,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=r,this.reverse=s,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,n=this.op===_f.Prod?"1.0":"0.0",r=this.exclusive?n:`getX(${FN(e,"coords",this.op)})`,s=this.outputShape[this.outputShape.length-1];let o="",i="";return this.exclusive?(o=this.reverse?`end != ${s-1}`:"end != 0",i=this.reverse?"end + 1":"end - 1"):(o=this.reverse?`end + pow2 < ${s}`:"end >= pow2",i=this.reverse?"end + pow2":"end - pow2"),`
      ${Ee("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${LN(e,"coords",this.op)};
         var val = ${r};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${o}) {
           let idx = ${i};
           ${LN(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${FN(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}}function FN(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.x, ${e}.y`;if(t===3)return`${e}.x, ${e}.y, ${e}.z`;if(t===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function LN(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.y`;if(t===3)return`${e}.z`;if(t===4)return`${e}.w`;throw Error(`Cumulative ${n} for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IF(t,e,n,r,s,o){const i=e.shape.length,a=lr([r],i);let l=e;a!=null&&(l=Ci({inputs:{x:e},backend:n,attrs:{perm:a}}));const c=ur(1,i)[0];if(c!==i-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const d=l.shape[c];let f=gs({inputs:{x:l},backend:n});for(let p=0;p<=Math.ceil(Math.log2(d))-1;p++){const g=new ON(t,l.shape,!1,o),y=f,x=[{type:"float32",data:[p]}];f=n.runWebGPUProgram(g,[f],f.dtype,x),n.disposeData(y.dataId)}if(s){const p=new ON(t,l.shape,s,o),g=f,y=[{type:"float32",data:[0]}];f=n.runWebGPUProgram(p,[f],f.dtype,y),n.disposeData(g.dataId)}if(a!=null){const p=qf(a),g=Ci({inputs:{x:f},backend:n,attrs:{perm:p}});return n.disposeData(f.dataId),n.disposeData(l.dataId),g}return f}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w2e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,exclusive:i,reverse:a}=r;return IF(_f.Prod,s,n,o,i,a)}const S2e={kernelName:A2,backendName:"webgpu",kernelFunc:w2e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C2e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,exclusive:i,reverse:a}=r;return IF(_f.Sum,s,n,o,i,a)}const $2e={kernelName:D2,backendName:"webgpu",kernelFunc:C2e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k2e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:o}=e,{size:i,binaryOutput:a}=r,l=s.shape.length===1,d=pe(o.shape)>0,f=o.dtype,p=l?[s.shape[0]]:[s.shape[0],s.shape[1]],g=l?[i]:[s.shape[0],i],y=Ur({backend:n,attrs:{shape:g,value:0,dtype:f}}),x=new CF(p,d,a),w=[{type:"int32",data:[i]}],S=d?[s,o]:[s];return n.runWebGPUProgram(x,S,f,w,y)}const T2e={kernelName:F2,backendName:"webgpu",kernelFunc:k2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class I2e{constructor(e,n){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${n}`,this.dataFormat=n}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N2e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockSize:o,dataFormat:i}=r,a=s.shape[0],l=i==="NHWC"?s.shape[1]:s.shape[2],c=i==="NHWC"?s.shape[2]:s.shape[3],d=i==="NHWC"?s.shape[3]:s.shape[1],f=l*o,p=c*o,g=d/(o*o),y=i==="NHWC"?[a,f,p,g]:[a,g,f,p],x=[{type:"int32",data:[o]}],w=new I2e(y,i);return n.runWebGPUProgram(w,[s],s.dtype,x)}const E2e={kernelName:L2,backendName:"webgpu",kernelFunc:N2e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class R2e{constructor(e,n,r,s=!1,o=null,i=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.addBias=s,this.activation=o,this.hasPreluActivation=i,this.filterHeight=n,this.filterWidth=r,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,n=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],r=this.workgroupSize[1]+this.filterHeight-1,s=this.workgroupSize[0]+this.filterWidth-1;return`
      ${Ta(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${s}>, ${r}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${Ee()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${s}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e<n?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${n})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${Hu(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NF{constructor(e,n=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const o=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=De(o),this.dispatch=Re(this.dispatchLayout,o,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),z(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=n,this.activation=r,this.hasPreluActivation=s,this.shaderKey=`depthwiseVec4_${r}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,n=this.convInfo.strideHeight,r=this.convInfo.strideWidth;return`
      ${Ta(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${Ee("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${n}, ${r}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${r} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${Hu(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EF{constructor(e,n=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=n,this.activation=r,this.hasPreluActivation=s,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${Ta(this.activation,this.hasPreluActivation,!1,4)}

      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${Hu(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _2e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dataFormat:l,dilations:c,dimRoundingMode:d}=r,f=Mo(l);let p=c;p==null&&(p=[1,1]);const g=kn(s.shape,o.shape,i,p,a,d,!0,f),y=[{type:"int32",data:[g.padInfo.top,g.padInfo.left]},{type:"int32",data:[g.inHeight,g.inWidth]}],x=g.dataFormat==="channelsLast";let w;return!x&&g.inHeight>16&&g.inWidth>16&&g.strideHeight===1&&g.strideWidth===1&&g.dilationWidth===1&&g.dilationHeight===1&&g.inChannels===g.outChannels?w=new R2e(g.outShape,g.filterHeight,g.filterWidth):x&&g.outHeight>4&&g.outWidth>4&&g.strideWidth<=2&&g.inChannels===g.outChannels&&g.dilationHeight===1&&g.dilationWidth===1&&g.inChannels%4===0?(w=new NF(g),y.push({type:"int32",data:[w.virtualWidth]})):(w=new EF(g),y.push({type:"int32",data:[g.filterHeight]},{type:"int32",data:[g.filterWidth]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]})),n.runWebGPUProgram(w,[s,o],s.dtype,y)}const P2e={kernelName:z2,backendName:"webgpu",kernelFunc:_2e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class A2e{constructor(e){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class D2e{constructor(e){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O2e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:i,dilations:a,pad:l,dimRoundingMode:c,filterShape:d}=r,f=kn(s.shape,d,i,a,l,c,!0),p=new A2e(f),g=[{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"int32",data:[f.inHeight]},{type:"int32",data:[f.inWidth]},{type:"int32",data:[f.batchSize]},{type:"int32",data:[f.outChannels/f.inChannels]}];return n.runWebGPUProgram(p,[s,o],"float32",g)}const F2e={kernelName:B2,backendName:"webgpu",kernelFunc:O2e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L2e(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{strides:i,dilations:a,pad:l,dimRoundingMode:c,inputShape:d}=r,f=kn(d,o.shape,i,a,l,c,!0),p=new D2e(f),g=[{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.filterHeight-1-f.padInfo.top,f.filterWidth-1-f.padInfo.left]},{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"int32",data:[f.outChannels/f.inChannels]}];return n.runWebGPUProgram(p,[s,o],s.dtype,g)}const z2e={kernelName:M2,backendName:"webgpu",kernelFunc:L2e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class B2e{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M2e(t){const{inputs:e,backend:n}=t,{x:r}=e,s=[...r.shape,...r.shape],o=pe(r.shape),i=Be({inputs:{x:r},backend:n,attrs:{shape:[o]}}),a=new B2e(o),l=n.runWebGPUProgram(a,[i],i.dtype),c=Be({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeData(i.dataId),n.disposeData(l.dataId),c}const V2e={kernelName:V2,backendName:"webgpu",kernelFunc:M2e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class W2e{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${Ee("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U2e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dilations:l}=r,c=Kf(s.shape,o.shape,i,a,"NHWC",l),d=[c.padInfo.top,c.padInfo.left],f=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[...d]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]}],p=new W2e(c);return n.runWebGPUProgram(p,[s,o],s.dtype,f)}const j2e={kernelName:W2,backendName:"webgpu",kernelFunc:U2e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class G2e{constructor(e,n){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=De(e.outShape),this.dispatch=Re(this.dispatchLayout,e.outShape,this.workgroupSize),n!=="float32"&&n!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${n} type.`);this.type=n,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${Ee("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${Nl("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}class H2e{constructor(e,n,r){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=De(e.outShape),this.dispatch=Re(this.dispatchLayout,e.outShape,this.workgroupSize),r!=="float32"&&r!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${r} type.`);this.type=r,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${Ee("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${Nl("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K2e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,dy:i}=e,{strides:a,pad:l,dilations:c}=r,d=Kf(s.shape,o.shape,a,l,"NHWC",c),f=o.dtype,p=new H2e(d,o.shape,f),g=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[pe(d.outShape)]}],y=Ur({backend:n,attrs:{shape:o.shape,value:0,dtype:f}});return n.runWebGPUProgram(p,[s,o,i],f,g,y)}const X2e={kernelName:uX,backendName:"webgpu",kernelFunc:K2e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q2e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,dy:i}=e,{strides:a,pad:l,dilations:c}=r,d=Kf(s.shape,o.shape,a,l,"NHWC",c),f=s.dtype,p=new G2e(d,f),g=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[pe(d.outShape)]}],y=Ur({backend:n,attrs:{shape:d.inShape,value:0,dtype:f}});return n.runWebGPUProgram(p,[s,o,i],f,g,y)}const Y2e={kernelName:lX,backendName:"webgpu",kernelFunc:q2e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q2e{constructor(e,n,r){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=pd.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=n,this.textureFormat=r,this.shaderKey=`draw_${n}_${r}`}getUserCode(){let e;const n=this.type==="float32"?"value":"value / 255.0";return e=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${n};
        rgba[1] = ${n};
        rgba[2] = ${n};
      } else {
        rgba[d] = ${n};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${Ee("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z2e(t){const{inputs:e,backend:n,attrs:r}=t,{image:s}=e,{canvas:o,options:i}=r,[a,l]=s.shape.slice(0,2),{imageOptions:c}=i||{},d=(c==null?void 0:c.alpha)||1,f=n.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",p=[a,l],g=new Q2e(p,s.dtype,f);o.width=l,o.height=a;const y="webgpu";let x=o.getContext(y),w;x||(w=new OffscreenCanvas(l,a),x=w.getContext(y));const S=s.shape.length===3?s.shape[2]:1;x.configure({device:n.device,format:f,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const $="int32",I=n.makeTensorInfo(p,$),R=n.tensorMap.get(I.dataId);R.resource=x.getCurrentTexture(),R.external=!0;const _=[{type:"uint32",data:[S]},{type:"float32",data:[d]}];if(n.runWebGPUProgram(g,[s],$,_,I),w){const O=o.getContext("2d");if(!O)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");O.drawImage(w,0,0)}return n.disposeData(I.dataId),s}const J2e={kernelName:ZP,backendName:"webgpu",kernelFunc:Z2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RF=zn({opType:Je.MUL,cpuKernelImpl:sve,supportsComplex:!0}),ewe={kernelName:Aw,backendName:"webgpu",kernelFunc:RF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _F(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r;return Xu(s,o,i,"sum",n)}const twe={kernelName:pS,backendName:"webgpu",kernelFunc:_F};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nwe(t){const{inputs:e,backend:n,attrs:r}=t,{equation:s}=r,o=e,{allDims:i,summedDims:a,idDims:l}=bC(s,o.length);SC(i.length,l,o);const{path:c,steps:d}=CC(a,l),f=d.length;let p=null,g=i.length;const y=[];for(let x=0;x<f;++x){for(const w of d[x]){const{permutationIndices:S,expandDims:$}=wC(g,l[w]);let I;$C(S)?I=o[w]:(I=Ci({inputs:{x:o[w]},backend:n,attrs:{perm:S}}),y.push(I));const R=I.shape.slice();for(let _=0;_<$.length;++_)R.splice($[_],0,1);Vt(I.shape,R)||(I=Be({inputs:{x:I},backend:n,attrs:{shape:R}}),y.push(I)),p===null?p=I:(p=RF({inputs:{a:I,b:p},backend:n}),y.push(p))}x<f-1&&(c[x]>=0&&(p=_F({inputs:{x:p},backend:n,attrs:{axis:c[x]-(i.length-g),keepDims:!1}}),y.push(p)),g--)}for(const x of y)x!==p&&n.disposeData(x.dataId);return p}const rwe={kernelName:j2,backendName:"webgpu",kernelFunc:nwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const swe=kt({opType:Ne.ELU}),owe={kernelName:G2,backendName:"webgpu",kernelFunc:swe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iwe=t=>{const{inputs:e,backend:n}=t,{dy:r,y:s}=e,o=new Lg(Je.ELU_DER,r.shape,s.shape);return n.runWebGPUProgram(o,[r,s],r.dtype)},awe={kernelName:JP,backendName:"webgpu",kernelFunc:iwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lwe=zn({opType:Je.EQUAL,dtype:"bool",cpuKernelImpl:Uxe}),uwe={kernelName:K2,backendName:"webgpu",kernelFunc:lwe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cwe=kt({opType:Ne.ERF}),dwe={kernelName:H2,backendName:"webgpu",kernelFunc:cwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hwe=kt({opType:Ne.EXP,cpuKernelImpl:jxe,dtype:"float32"}),fwe={kernelName:X2,backendName:"webgpu",kernelFunc:hwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lv(t){const{inputs:e,attrs:n,backend:r}=t,{dim:s}=n,{input:o}=e,i=o.shape.length,a=o.shape.slice();let l=s;return s<0&&(z(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),a.splice(l,0,1),Be({inputs:{x:o},backend:r,attrs:{shape:a}})}const pwe={kernelName:q2,backendName:"webgpu",kernelFunc:Lv};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mwe=kt({opType:Ne.EXPM1,cpuKernelImpl:Gxe}),gwe={kernelName:Y2,backendName:"webgpu",kernelFunc:mwe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zN{constructor(e,n){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PF(t,e,n){const r=n.tensorMap.get(t.dataId),s=pe(t.shape),o=t.shape[t.shape.length-1],i=s/o,a=[],l=Be({inputs:{x:t},backend:n,attrs:{shape:[i,o]}});a.push(l);const c=l.shape,d=new zN("real",c),f=new zN("imag",c),p=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:c},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:c}],g=e?2*Math.PI:-2*Math.PI,y=e?c[1]:1,x=[{type:"float32",data:[g]},{type:"float32",data:[y]}],w=n.runWebGPUProgram(d,p,"float32",x);a.push(w);const S=n.runWebGPUProgram(f,p,"float32",x);a.push(S);const $=Ku({inputs:{real:w,imag:S},backend:n});a.push($);const I=Be({inputs:{x:$},backend:n,attrs:{shape:t.shape}});return a.forEach(R=>n.disposeData(R.dataId)),I}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ywe(t){const{inputs:e,backend:n}=t,{input:r}=e;return PF(r,!1,n)}const xwe={kernelName:Q2,backendName:"webgpu",kernelFunc:ywe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vwe{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bwe={kernelName:J2,backendName:"webgpu",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,r=e,s=new vwe(n.shape);return r.runWebGPUProgram(s,[n],n.dtype)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wwe=kt({opType:Ne.FLOOR,cpuKernelImpl:Hxe}),Swe={kernelName:ew,backendName:"webgpu",kernelFunc:wwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cwe=zn({opType:Je.FLOOR_DIV,cpuKernelImpl:Kxe,dtype:"int32"}),$we={kernelName:tw,backendName:"webgpu",kernelFunc:Cwe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kwe{constructor(e,n,r=!1){this.pixelsOpType=pd.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[n,1,1]),this.importVideo=r,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${Ee("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Twe={kernelName:vg,backendName:"webgpu",kernelFunc:Iwe};let Tc,sx=se().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Iwe(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:s}=e;const{numChannels:o}=r;if(s==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,l=typeof HTMLCanvasElement<"u"&&s instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&s instanceof OffscreenCanvas,c=typeof ImageBitmap<"u"&&s instanceof ImageBitmap,[d,f]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],p=[f,d,o],g=se().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&i,y=i||a;if(c||l||y){let $;if(g)$=n.device.importExternalTexture({source:s});else{if(y){const ie=se().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Tc==null||ie!==sx)&&(sx=ie,Tc=document.createElement("canvas").getContext("2d",{willReadFrequently:sx})),Tc.canvas.width=d,Tc.canvas.height=f,Tc.drawImage(s,0,0,d,f),s=Tc.canvas}const V=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,re=n.textureManager.acquireTexture(p[1],p[0],"rgba8unorm",V);n.queue.copyExternalImageToTexture({source:s},{texture:re},[p[1],p[0]]),$=re}const I=pe(p),R=gn(p),_=new kwe(p,o,g),O=[{type:"uint32",data:[I]},{type:"uint32",data:[o]},{type:"uint32",data:[...R]}],F=n.makeTensorInfo([f,d],"int32"),B=n.tensorMap.get(F.dataId);B.resource=$;const M=n.runWebGPUProgram(_,[F],"int32",O);return n.disposeData(F.dataId),M}const x=s.data;let w=x;if(o!=null&&o!==4){w=new Uint8Array(s.width*s.height*o);const $=x.length;let I=0;for(let R=0;R<$;R++)R%4<o&&(w[I++]=x[R])}const S=n.makeTensorInfo(p,"int32",new Int32Array(w));return n.uploadToGPU(S.dataId),S}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nwe{constructor(e,n,r,s,o){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],ct(e,n),ct(e,r),this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),s!=null&&(ct(e,s),this.variableNames.push("offset")),o!=null&&(ct(e,o),this.variableNames.push("scale")),this.offsetShape=s,this.scaleShape=o,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetByOutputIndex(index)");let n="1.0";return this.scaleShape!=null&&(n="getScaleByOutputIndex(index)"),`
      ${Ee("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${n};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ewe={kernelName:nw,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r,scale:s,offset:o,mean:i,variance:a}=t,{varianceEpsilon:l}=e,c=n,d=[r,i,a];let f=null;o!=null&&(f=o.shape,d.push(o));let p=null;s!=null&&(p=s.shape,d.push(s));const g=new Nwe(r.shape,i.shape,a.shape,f,p),y=[{type:"float32",data:[l]}];return c.runWebGPUProgram(g,d,r.dtype,y)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rwe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:d,dilations:f,dimRoundingMode:p,activation:g,leakyreluAlpha:y}=r,x=Mo(d),w=kn(s.shape,o.shape,l,f,c,p,!1,x);return TF({x:s,filter:o,convInfo:w,backend:n,bias:i,preluActivationWeights:a,leakyreluAlpha:y,activation:g})}const _we={kernelName:wg,backendName:"webgpu",kernelFunc:Rwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pwe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=e,{strides:l,pad:c,dilations:d,dimRoundingMode:f,activation:p,leakyreluAlpha:g}=r;let y=d;y==null&&(y=[1,1]),z(Nr(l,y),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${y}'`);const x=kn(s.shape,o.shape,l,y,c,f,!0),w=[s,o],S=i!=null,$=a!=null;S&&w.push(i),$&&w.push(a);const I=[{type:"int32",data:[x.padInfo.top,x.padInfo.left]},{type:"int32",data:[x.inHeight,x.inWidth]}];let R;return x.outHeight>4&&x.outWidth>4&&x.strideWidth<=2&&x.inChannels===x.outChannels&&x.dilationHeight===1&&x.dilationWidth===1&&x.inChannels%4===0?(R=new NF(x,S,p,$),I.push({type:"int32",data:[R.virtualWidth]})):(R=new EF(x,S,p,$),I.push({type:"int32",data:[x.filterHeight]},{type:"int32",data:[x.filterWidth]},{type:"int32",data:[x.strideHeight,x.strideWidth]},{type:"int32",data:[x.dilationHeight,x.dilationWidth]})),p==="leakyrelu"&&(I.push({type:"float32",data:[g]}),R.uniforms+=" alpha : f32,"),n.runWebGPUProgram(R,w,"float32",I)}const Awe={kernelName:Sg,backendName:"webgpu",kernelFunc:Pwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dwe{constructor(e,n){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${bn(e)},`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Owe(t){const{inputs:e,backend:n}=t,{params:r,indices:s}=e,o=s.shape,i=o[o.length-1],a=pe(r.shape),[l,c,d,f]=eC(r,s),p=Be({inputs:{x:s},backend:n,attrs:{shape:[c,i]}}),g=Be({inputs:{x:r},backend:n,attrs:{shape:[pe(r.shape)/d,d]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const $=n.readSync(s.dataId),I=n.bufferSync(r),R=Xxe($,I,r.dtype,c,i,d,f,r.shape,a);return n.makeTensorInfo(l,r.dtype,R.values)}const y=new Dwe(i,[c,d]),x=[{type:"int32",data:[i]},{type:"int32",data:f}],w=n.runWebGPUProgram(y,[g,p],g.dtype,x),S=Be({inputs:{x:w},backend:n,attrs:{shape:l}});return n.disposeData(p.dataId),n.disposeData(g.dataId),n.disposeData(w.dataId),S}const Fwe={kernelName:sw,backendName:"webgpu",kernelFunc:Owe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lwe{constructor(e,n){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=n,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=zwe(this.aShape);return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `}}function zwe(t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<t.length;r++)r===2?n.push("indexZ"):n.push(`${e[r]}`);return n.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AF(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,indices:o}=e,{axis:i,batchDims:a}=r,l=nn(i,s.shape)[0],c=IC(s,o,l,a),d=pe(o.shape),f=[],p=Be({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),g=Be({inputs:{x:o},backend:n,attrs:{shape:[c.batchSize,d/c.batchSize]}});f.push(p),f.push(g);const y=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([s,o])){const I=n.tensorMap.get(g.dataId).values,R=Wt(g.shape,g.dtype,I),O=n.tensorMap.get(p.dataId).values,F=Wt(p.shape,p.dtype,O),B=qxe(F,R,y);return f.forEach(M=>n.disposeData(M.dataId)),n.makeTensorInfo(c.outputShape,B.dtype,B.values)}const x=new Lwe(p.shape,y),w=n.runWebGPUProgram(x,[p,g],p.dtype);f.push(w);const S=Be({inputs:{x:w},backend:n,attrs:{shape:c.outputShape}});return f.forEach($=>n.disposeData($.dataId)),S}const Bwe={kernelName:rw,backendName:"webgpu",kernelFunc:AF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mwe=zn({opType:Je.GREATER,cpuKernelImpl:Qxe,dtype:"bool"}),Vwe={kernelName:ow,backendName:"webgpu",kernelFunc:Mwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wwe=zn({opType:Je.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:Yxe}),Uwe={kernelName:iw,backendName:"webgpu",kernelFunc:Wwe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jwe(t){const{inputs:e,backend:n}=t,{input:r}=e;return PF(r,!0,n)}const Gwe={kernelName:aw,backendName:"webgpu",kernelFunc:jwe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hwe=kt({opType:Ne.IS_FINITE,dtype:"bool"}),Kwe={kernelName:uw,backendName:"webgpu",kernelFunc:Hwe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xwe=kt({opType:Ne.IS_INF,dtype:"bool"}),qwe={kernelName:cw,backendName:"webgpu",kernelFunc:Xwe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ywe=kt({opType:Ne.IS_NAN,dtype:"bool"}),Qwe={kernelName:dw,backendName:"webgpu",kernelFunc:Ywe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zwe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{alpha:o}=r,i=[{type:"float32",data:[o]}],a=new Fd(s.shape,Ne.LEAKYRELU,"alpha : f32,");return n.runWebGPUProgram(a,[s],"float32",i)}const Jwe={kernelName:hw,backendName:"webgpu",kernelFunc:Zwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eSe=zn({opType:Je.LESS,dtype:"bool",cpuKernelImpl:Jxe}),tSe={kernelName:fw,backendName:"webgpu",kernelFunc:eSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nSe=zn({opType:Je.LESS_EQUAL,dtype:"bool",cpuKernelImpl:Zxe}),rSe={kernelName:pw,backendName:"webgpu",kernelFunc:nSe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sSe{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oSe(t){const{backend:e,attrs:n}=t,{start:r,stop:s,num:o}=n,i=(s-r)/(o-1),a=new sSe(o),l=[{type:"float32",data:[r]},{type:"float32",data:[i]}];return e.runWebGPUProgram(a,[],"float32",l)}const iSe={kernelName:mw,backendName:"webgpu",kernelFunc:oSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aSe=kt({opType:Ne.LOG,cpuKernelImpl:eve}),lSe={kernelName:gw,backendName:"webgpu",kernelFunc:aSe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uSe=kt({opType:Ne.LOG1P}),cSe={kernelName:yw,backendName:"webgpu",kernelFunc:uSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dSe=zn({opType:Je.LOGICAL_AND,dtype:"bool"}),hSe={kernelName:xw,backendName:"webgpu",kernelFunc:dSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fSe=kt({opType:Ne.LOGICAL_NOT}),pSe={kernelName:vw,backendName:"webgpu",kernelFunc:fSe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mSe=zn({opType:Je.LOGICAL_OR}),gSe={kernelName:bw,backendName:"webgpu",kernelFunc:mSe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DF=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;class ySe{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${DF}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}}class xSe{constructor(e,n){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,z(n<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${n}`),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Re(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${Ee()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${DF}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vSe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{depthRadius:o,bias:i,alpha:a,beta:l}=r;let c;o>16?c=new ySe(s.shape):c=new xSe(s.shape,o);const d=[{type:"int32",data:[o]},{type:"float32",data:[i]},{type:"float32",data:[a]},{type:"float32",data:[l]}];return n.runWebGPUProgram(c,[s],s.dtype,d)}const bSe={kernelName:ww,backendName:"webgpu",kernelFunc:vSe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wSe{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SSe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,y:o,dy:i}=e,{depthRadius:a,bias:l,alpha:c,beta:d}=r,f=new wSe(s.shape),p=[{type:"int32",data:[a]},{type:"float32",data:[l]},{type:"float32",data:[c]},{type:"float32",data:[d]}];return n.runWebGPUProgram(f,[s,o,i],s.dtype,p)}const CSe={kernelName:eA,backendName:"webgpu",kernelFunc:SSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Se=zn({opType:Je.MAX,cpuKernelImpl:nve}),kSe={kernelName:Cw,backendName:"webgpu",kernelFunc:$Se};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TSe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r,d=fo(s.shape,o,i,1,a,l);return SF(s,d,"max",n)}const ISe={kernelName:$w,backendName:"webgpu",kernelFunc:TSe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NSe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:i,pad:a,dataFormat:l,dimRoundingMode:c}=r,d=[1,1,1],f=Sa(s.shape,o,i,d,a,c,l),p=new MC(f,"max"),g=[{type:"int32",data:[f.strideDepth,f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.front,f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inDepth,f.inHeight,f.inWidth]},{type:"int32",data:[f.effectiveFilterDepth,f.effectiveFilterHeight,f.effectiveFilterWidth]}];return n.runWebGPUProgram(p,[s],s.dtype,g)}const ESe={kernelName:kw,backendName:"webgpu",kernelFunc:NSe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RSe{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class _Se{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PSe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,i=o,{filterSize:a,strides:l,pad:c,dimRoundingMode:d}=r,f=[1,1,1],p=Sa(i.shape,a,l,f,c,d),g=new MC(p,"max",!0);let y=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.front,p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inDepth,p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]}];const x=n.runWebGPUProgram(g,[i],"int32",y),w=new _Se(p);y=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.effectiveFilterDepth-1-p.padInfo.front,p.effectiveFilterHeight-1-p.padInfo.top,p.effectiveFilterWidth-1-p.padInfo.left]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]},{type:"int32",data:[p.outDepth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]}];const S=n.runWebGPUProgram(w,[s,x],i.dtype,y);return n.disposeData(x.dataId),S}const ASe={kernelName:nA,backendName:"webgpu",kernelFunc:PSe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DSe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o,output:i}=e,a=o;gF([o,i],"maxPoolGrad");const{filterSize:l,strides:c,pad:d,dimRoundingMode:f}=r,p=fo(a.shape,l,c,1,d,f),g=new Rf(p,"max",!0);let y=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]}];const x=n.runWebGPUProgram(g,[a],"int32",y),w=new RSe(p);y=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.effectiveFilterHeight-1-p.padInfo.top,p.effectiveFilterWidth-1-p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]}];const S=n.runWebGPUProgram(w,[s,x],a.dtype,y);return n.disposeData(x.dataId),S}const OSe={kernelName:tA,backendName:"webgpu",kernelFunc:DSe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FSe(t){const{inputs:e,backend:n,attrs:r}=t,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=r,{x:l}=e;z(l.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${l.shape.length}.`);const c=[1,1];z(Nr(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const d=fo(l.shape,s,o,c,i),f=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]}];let p=new Rf(d,"max",!1);const g=n.runWebGPUProgram(p,[l],l.dtype,f);p=new Rf(d,"max",!0,!0,a);const y=n.runWebGPUProgram(p,[l],"int32",f);return[g,y]}const LSe={kernelName:Tw,backendName:"webgpu",kernelFunc:FSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zSe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r;return Xu(s,o,i,"min",n)}const BSe={kernelName:Nw,backendName:"webgpu",kernelFunc:zSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MSe=zn({opType:Je.MIN,cpuKernelImpl:rve}),VSe={kernelName:Ew,backendName:"webgpu",kernelFunc:MSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WSe{constructor(e,n,r){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n.map((s,o)=>s[0]+e[o]+s[1]),this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,n.map((s,o)=>{this.uniforms+=` pad${o} : vec2<i32>,`}),this.offset=r==="reflect"?0:1,this.shaderKey=`mirrorPad_${r}`}getUserCode(){const e=this.xShape.length,n=this.xShape.map((c,d)=>`uniforms.pad${d}[0]`).join(","),r=this.xShape.map((c,d)=>`uniforms.pad${d}[0] + uniforms.xShape${e>1?`[${d}]`:""}`).join(","),s=e===1?"start":"start[i]",o=e===1?"end":"end[i]",i=e===1?"outC":"outC[i]",a=bn(e),l=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let start = ${a}(${n});
          let end = ${a}(${r});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${i} < ${s}) {
              ${i} = ${s} * 2 - ${i} - ${this.offset};
            } else if(${i} >= ${o}) {
              ${i} = (${o} - 1) * 2 - ${i} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const USe={kernelName:Rw,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{paddings:s,mode:o}=e,i=n,a=s.map(d=>({type:"int32",data:[d[0],d[1]]})),l=new WSe(r.shape,s,o);return i.runWebGPUProgram(l,[r],r.dtype,a)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jSe=zn({opType:Je.MOD}),GSe={kernelName:_w,backendName:"webgpu",kernelFunc:jSe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HSe{constructor(e,n){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,n],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KSe{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${Ee("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OF(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{dim:o}=r,i=Be({inputs:{x:s},backend:n,attrs:{shape:[pe(s.shape)/s.shape[o],s.shape[o]]}}),a=new KSe(i.shape),l=n.runWebGPUProgram(a,[i],s.dtype),c=Be({inputs:{x:l},backend:n,attrs:{shape:s.shape}});return n.disposeData(i.dataId),n.disposeData(l.dataId),c}const XSe={kernelName:yS,backendName:"webgpu",kernelFunc:OF};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qSe(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{numSamples:o,seed:i,normalized:a}=r,l=a?s:OF({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),c=l.shape[0],d=l.shape[1],f=new HSe(c,o),p=[{type:"float32",data:[i]},{type:"int32",data:[d]}],g=n.runWebGPUProgram(f,[l],"int32",p);return a||n.disposeData(l.dataId),g}const YSe={kernelName:Pw,backendName:"webgpu",kernelFunc:qSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QSe(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])){const o=n.tensorMap.get(r.dataId),[i,a]=ove(o.values,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,i)}const s=new Fd(r.shape,Ne.NEG);return n.runWebGPUProgram(s,[r],r.dtype)}const ZSe={kernelName:Dw,backendName:"webgpu",kernelFunc:QSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JSe(t){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r,c=n.readSync(s.dataId),d=n.readSync(o.dataId),{selectedIndices:f}=XS(c,d,i,a,l);return n.makeTensorInfo([f.length],"int32",new Int32Array(f))}const eCe={kernelName:Fw,backendName:"webgpu",kernelFunc:JSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tCe(t){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r,d=n.readSync(s.dataId),f=n.readSync(o.dataId),p=i,g=a,y=l,x=c,{selectedIndices:w,selectedScores:S}=qS(d,f,p,g,y,x);return[n.makeTensorInfo([w.length],"int32",new Int32Array(w)),n.makeTensorInfo([S.length],"float32",new Float32Array(S))]}const nCe={kernelName:Lw,backendName:"webgpu",kernelFunc:tCe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rCe{constructor(e,n){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,n],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${Ee("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sCe(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s}=e,{dtype:o,depth:i,onValue:a,offValue:l}=r,c=pe(s.shape),d=new rCe(c,i),f=Be({inputs:{x:s},backend:n,attrs:{shape:[c]}}),p=[{type:"float32",data:[a]},{type:"float32",data:[l]}],g=n.runWebGPUProgram(d,[f],o,p);n.disposeData(f.dataId);const y=[...s.shape,i],x=Be({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeData(g.dataId),x}const oCe={kernelName:Bw,backendName:"webgpu",kernelFunc:sCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bg(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="complex64"){const s=sp({inputs:{input:r},backend:n}),o=Bg({inputs:{x:s},backend:n}),i=Iy({inputs:{input:r},backend:n}),a=Bg({inputs:{x:i},backend:n}),l=Ku({inputs:{real:o,imag:a},backend:n});return n.disposeData(s.dataId),n.disposeData(o.dataId),n.disposeData(i.dataId),n.disposeData(a.dataId),l}else return Ur({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}const iCe={kernelName:_S,backendName:"webgpu",kernelFunc:Bg};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FF(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=sp({inputs:{input:r},backend:n}),o=FF({inputs:{x:s},backend:n}),i=Iy({inputs:{input:r},backend:n}),a=Bg({inputs:{x:i},backend:n}),l=Ku({inputs:{real:o,imag:a},backend:n});return n.disposeData(s.dataId),n.disposeData(o.dataId),n.disposeData(i.dataId),n.disposeData(a.dataId),l}else return Ur({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}const aCe={kernelName:zw,backendName:"webgpu",kernelFunc:FF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lCe(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r;if(e.length===1)return Lv({inputs:{input:e[0]},backend:n,attrs:{dim:s}});const o=e[0].shape,i=e[0].dtype;e.forEach(d=>{ys(o,d.shape,"All tensors passed to stack must have matching shapes"),z(i===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(d=>{const f=Lv({inputs:{input:d},backend:n,attrs:{dim:s}});return a.push(f),f}),c=kF({inputs:l,backend:n,attrs:{axis:s}});return a.forEach(d=>n.disposeData(d.dataId)),c}const uCe={kernelName:Mw,backendName:"webgpu",kernelFunc:lCe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LF(t,e=!1){const n=t.length,r=bn(n),s=t.map((f,p)=>`uniforms.pad${p}[0]`).join(","),o=t.map((f,p)=>`uniforms.pad${p}[0] + uniforms.xShape${n>1?`[${p}]`:""}`).join(","),i=n>1?`${r}(${s})`:`${s}`,a=n>1?`${r}(${o})`:`${o}`,l=n>1?"any(paddedCoords < start)":"paddedCoords < start",c=n>1?"any(paddedCoords >= end)":"paddedCoords >= end",d=n>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n):"coords";return`
        let start = ${i};
        let end = ${a};
        if (${l} || ${c}) {
          setOutputAtIndex(index, ${e?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${d}));
        }
  `}class cCe{constructor(e,n){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n.map((r,s)=>r[0]+e[s]+r[1]),this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),n.map((r,s)=>{this.uniforms+=` pad${s} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${LF(this.xShape)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dCe=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{paddings:o,constantValue:i}=r;if(o.every(c=>Vt(c,[0,0])))return gs({inputs:{x:s},backend:n});if(pe(s.shape)===0){const c=o.map((d,f)=>d[0]+s.shape[f]+d[1]);return Ur({backend:n,attrs:{shape:c,value:i,dtype:s.dtype}})}const a=[{type:"float32",data:[i]}];o.map(c=>a.push({type:"int32",data:[c[0],c[1]]}));const l=new cCe(s.shape,o);return n.runWebGPUProgram(l,[s],s.dtype,a)},hCe={kernelName:Vw,backendName:"webgpu",kernelFunc:dCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fCe=zn({opType:Je.POW}),pCe={kernelName:Ww,backendName:"webgpu",kernelFunc:fCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mCe(t){const{inputs:e,backend:n}=t,{x:r,alpha:s}=e,o=new Lg(Je.PRELU,r.shape,s.shape);return n.runWebGPUProgram(o,[r,s],"float32")}const gCe={kernelName:Uw,backendName:"webgpu",kernelFunc:mCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yCe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r;return Xu(s,o,i,"prod",n)}const xCe={kernelName:jw,backendName:"webgpu",kernelFunc:yCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vCe=t=>{const{backend:e,attrs:n}=t,{start:r,stop:s,step:o,dtype:i}=n,a=lve(r,s,o,i);return e.makeTensorInfo([a.length],i,a)},bCe={kernelName:Gw,backendName:"webgpu",kernelFunc:vCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wCe=zn({opType:Je.DIV}),SCe={kernelName:U2,backendName:"webgpu",kernelFunc:wCe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CCe=kt({opType:Ne.RECIPROCAL}),$Ce={kernelName:Kw,backendName:"webgpu",kernelFunc:CCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kCe=kt({opType:Ne.RELU}),TCe={kernelName:Xw,backendName:"webgpu",kernelFunc:kCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ICe=kt({opType:Ne.RELU6}),NCe={kernelName:Zw,backendName:"webgpu",kernelFunc:ICe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ECe{constructor(e,n,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],n,r,e[3]],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RCe(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:o,size:i,halfPixelCenters:a}=r,[l,c]=i,d=o&&l>1?1:0,f=o&&c>1?1:0,g=[{type:"float32",data:[d,f]},{type:"float32",data:[a?.5:0]}],y=new ECe(s.shape,l,c);return n.runWebGPUProgram(y,[s],"float32",g)}const _Ce={kernelName:Qw,backendName:"webgpu",kernelFunc:RCe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PCe{constructor(e,n){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=n,this.shaderKey=`resizeBilinearBackprop_${n}`}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ACe(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:o}=e,{alignCorners:i}=r,[,a,l]=s.shape,[,c,d]=o.shape,f=[i&&c>1?a-1:a,i&&d>1?l-1:l],p=[i&&c>1?c-1:c,i&&d>1?d-1:d],g=f[0]/p[0],y=f[1]/p[1],x=1/g,w=1/y,S=Math.ceil(x)*2+2,$=Math.ceil(w)*2+2,I=new PCe(s.shape,i),R=[{type:"int32",data:f},{type:"int32",data:p},{type:"float32",data:[g]},{type:"float32",data:[y]},{type:"float32",data:[x]},{type:"float32",data:[w]},{type:"int32",data:[S]},{type:"int32",data:[$]}];return n.runWebGPUProgram(I,[o],o.dtype,R)}const DCe={kernelName:lA,backendName:"webgpu",kernelFunc:ACe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OCe{constructor(e,n,r,s){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],n,r,e[3]],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=s,this.shaderKey=`resizeNearest_${s}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FCe(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,c]=a,d=o&&l>1?1:0,f=o&&c>1?1:0,g=[{type:"float32",data:[d,f]},{type:"float32",data:[o?.5:0]}],y=new OCe(s.shape,l,c,i);return n.runWebGPUProgram(y,[s],s.dtype,g)}const LCe={kernelName:Yw,backendName:"webgpu",kernelFunc:FCe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zCe{constructor(e,n){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=n,this.shaderKey=`resizeNearestNeigborBackprop_${n}`}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BCe(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:o}=e,{alignCorners:i}=r,[,a,l]=s.shape,[,c,d]=o.shape,f=[i&&c>1?a-1:a,i&&d>1?l-1:l],p=[i&&c>1?c-1:c,i&&d>1?d-1:d],g=f[0]/p[0],y=f[1]/p[1],x=1/g,w=1/y,S=Math.ceil(x)*2+2,$=Math.ceil(w)*2+2,I=new zCe(s.shape,i),R=[{type:"int32",data:f},{type:"int32",data:p},{type:"float32",data:[x]},{type:"float32",data:[w]},{type:"int32",data:[S]},{type:"int32",data:[$]}];return n.runWebGPUProgram(I,[o],o.dtype,R)}const MCe={kernelName:aA,backendName:"webgpu",kernelFunc:BCe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VCe{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WCe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dims:o}=r,i=s.shape.length;if(i===0)return gs({inputs:{x:s},backend:n});const a=s.shape,l=[1,1,1,1];a.forEach((w,S)=>{const $=S+4-i;l[$]=w});const c=nn(o,s.shape),d=[0,0,0,0];c.forEach(w=>{const S=w+4-i;d[S]=1});const f=[{type:"int32",data:d}],p=Be({inputs:{x:s},backend:n,attrs:{shape:l}}),g=new VCe(l),y=n.runWebGPUProgram(g,[p],p.dtype,f);n.disposeData(p.dataId);const x=Be({inputs:{x:y},backend:n,attrs:{shape:a}});return n.disposeData(y.dataId),x}const UCe={kernelName:Jw,backendName:"webgpu",kernelFunc:WCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jCe{constructor(e,n){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,typeof n=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${Ee("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GCe={kernelName:AS,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:s,fillValue:o,center:i}=e,a=n,l=new jCe(r.shape,o),[c,d]=uC(i,r.shape[1],r.shape[2]),f=[{type:"float32",data:[c]},{type:"float32",data:[d]},{type:"float32",data:[Math.sin(s)]},{type:"float32",data:[Math.cos(s)]}];return typeof o=="number"?f.push({type:"float32",data:[Number.parseFloat(o.toFixed(2))]}):f.push({type:"float32",data:o}),a.runWebGPUProgram(l,[r],r.dtype,f)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HCe=kt({opType:Ne.ROUND}),KCe={kernelName:eS,backendName:"webgpu",kernelFunc:HCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XCe=kt({opType:Ne.RSQRT,cpuKernelImpl:uve}),qCe={kernelName:tS,backendName:"webgpu",kernelFunc:XCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jh{constructor(e,n,r,s,o,i,a,l=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=i,this.type=a,this.sumDupeIndices=l,this.dispatchLayout=De(e),this.dispatch=Re(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=n>1,this.shaderKey=`scatter_${r}_${s}_${this.sliceDimGreaterThanOne}_${a}_${l}_${o.length}`;const c=bn(o.length);this.uniforms=`sliceDim : i32, strides: ${c}, updatesSize: i32,`,this.updatesRank=s,this.indicesRank=r}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");const n=`getIndices(${e})`,r=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let s="",o="";this.dispatchLayout.x.length===1?(s="flattenedIndex",o=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(s="vec2<i32>(flattenedIndex, coords[1])",o=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const a=`getUpdates(${Array.from({length:this.updatesRank},(c,d)=>`coords[${d}]`).join(", ")})`;return`
    ${o}
      ${Ee("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${n}));
            flattenedIndex = flattenedIndex + indexInside * ${r};
          }
          let updateValue =
              ${mu(this.type)}(${a});
          let flatIndex = getOutputIndexFromCoords(${s});

          ${this.sumDupeIndices?Nl("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YCe(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s,updates:o}=e,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:d,outputSize:f}=Bu(o,s,i),p=[f/c,c];if(f===0)return n.makeTensorInfo(i,s.dtype);const g=Be({inputs:{x:s},backend:n,attrs:{shape:[l,a]}}),y=Be({inputs:{x:o},backend:n,attrs:{shape:[l,c]}}),x=y.dtype,w=Ur({backend:n,attrs:{shape:p,value:0,dtype:x}}),S=pe(y.shape),$=[{type:"int32",data:[a]},{type:"int32",data:d},{type:"int32",data:[S]}],I=new Jh(y.shape,a,g.shape.length,y.shape.length,d,p,x),R=n.runWebGPUProgram(I,[y,g],x,$,w),_=Be({inputs:{x:R},backend:n,attrs:{shape:i}});return n.disposeData(g.dataId),n.disposeData(y.dataId),n.disposeData(R.dataId),_}const QCe={kernelName:nS,backendName:"webgpu",kernelFunc:YCe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZCe{constructor(e,n){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=n,this.shaderKey=`search_sorted_${n}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JCe(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:s,values:o}=e,{side:i}=r,a=new ZCe([o.shape[0],o.shape[1]],i),l=[{type:"int32",data:[s.shape[1]]}];return n.runWebGPUProgram(a,[s,o],"int32",l)}const e$e={kernelName:sS,backendName:"webgpu",kernelFunc:JCe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class t$e{constructor(e,n,r){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=r,this.shaderKey="select"}getUserCode(){let e,n;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)n="resRC",e="resRC";else{const s=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],i=[];for(let a=0;a<this.outputShape.length;a++)i.push(`${s[a]}`),a<this.cRank&&o.push(`${s[a]}`);e=o.join(),n=i.join()}return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${n}));
          } else {
            setOutputAtIndex(index, getB(${n}));
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n$e(t){const{inputs:e,backend:n}=t,{condition:r,t:s,e:o}=e,i=new t$e(r.shape.length,s.shape,s.shape.length);return n.runWebGPUProgram(i,[r,s,o],jr(s.dtype,o.dtype))}const r$e={kernelName:oS,backendName:"webgpu",kernelFunc:n$e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s$e=kt({opType:Ne.SELU}),o$e={kernelName:iS,backendName:"webgpu",kernelFunc:s$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i$e=kt({opType:Ne.SIGMOID}),a$e={kernelName:dS,backendName:"webgpu",kernelFunc:i$e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l$e=kt({opType:Ne.SIGN}),u$e={kernelName:cS,backendName:"webgpu",kernelFunc:l$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c$e=kt({opType:Ne.SIN}),d$e={kernelName:lS,backendName:"webgpu",kernelFunc:c$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h$e=kt({opType:Ne.SINH}),f$e={kernelName:uS,backendName:"webgpu",kernelFunc:h$e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p$e=kt({opType:Ne.SOFTPLUS}),m$e={kernelName:hS,backendName:"webgpu",kernelFunc:p$e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class g$e{constructor(e,n,r,s,o,i){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const a=new Array(s.length);for(let l=0;l<a.length;l++)a[l]=s[o[l]];this.outputShape=a,this.newDim=o,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=n,this.uniforms+=`reshapedPaddedXShape : ${bn(s.length)}, paddedXShapeStrides : ${bn(i)}, `,r.map((l,c)=>{this.uniforms+=` pad${c} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${o}`}getUserCode(){const e=bn(this.outputShape.length),n=xF(this.newDim);return`
      ${tg(this.paddedXShape,"PaddedX")}
      ${Ee("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${n}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${LF(this.xShape,!0)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y$e=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:o,paddings:i}=r;z(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const a=o.reduce(($,I)=>$*I),l=[[0,0]];l.push(...i);for(let $=1+o.length;$<s.shape.length;++$)l.push([0,0]);const c=l.map(($,I)=>$[0]+s.shape[I]+$[1]),d=Yf(c,o,a,!1),f=Qf(d.length,o.length,!1),p=Zf(c,o,a,!1),g=gn(c),y=new g$e(s.shape,c,l,d,f,g.length),x=[{type:"int32",data:d},{type:"int32",data:g}];l.map($=>x.push({type:"int32",data:[$[0],$[1]]}));const w=n.runWebGPUProgram(y,[s],s.dtype,x),S=Be({inputs:{x:w},backend:n,attrs:{shape:p}});return n.disposeData(w.dataId),S},x$e={kernelName:mS,backendName:"webgpu",kernelFunc:y$e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class v$e{constructor(e,n,r){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=r,this.dispatchLayout=De([n]),this.dispatch=Re(this.dispatchLayout,[n],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${Nl("&result[outIndex]","value",this.type)}
      }
    }
  `}}class b$e{constructor(e,n){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=De(n),this.dispatch=Re(this.dispatchLayout,n,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${Nl("&result[segmentId]","1","int32")}
      }
    }
  `}}class w$e{constructor(e,n){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=n,this.dispatchLayout=De(e),this.dispatch=Re(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zF(t,e,n,r=!1,s){const i=pe(t.shape)/t.shape[0],a=t.dtype,l=pe(e.shape),c=s.readSync(n.dataId),f=l>0?c[l-1]+1:0;let p;const g=t.shape.slice();g[0]=f;const y=l*i,x=Ur({backend:s,attrs:{shape:g,value:0,dtype:a}});p=new v$e(g,y,a);let w=[{type:"int32",data:[i]},{type:"int32",data:[y]}];const S=s.runWebGPUProgram(p,[t,e,n],a,w,x);if(r)return S;const $=Ur({backend:s,attrs:{shape:[f],value:0,dtype:"int32"}});p=new b$e(f,n.shape);const I=s.runWebGPUProgram(p,[n],"int32",null,$),R=Ur({backend:s,attrs:{shape:g,value:0,dtype:a}});p=new w$e(g,a),w=[{type:"int32",data:[i]}];const _=s.runWebGPUProgram(p,[S,I],a,w,R);return s.disposeData(S.dataId),s.disposeData(I.dataId),_}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S$e(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:o}=e;return zF(r,s,o,!1,n)}const C$e={kernelName:xS,backendName:"webgpu",kernelFunc:S$e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $$e(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:o}=e;return zF(r,s,o,!0,n)}const k$e={kernelName:vS,backendName:"webgpu",kernelFunc:$$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class T$e{constructor(e,n){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[s]*n[s];this.outputShape=r,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=I$e(this.rank,"uniforms.");return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `}}function I$e(t,e=""){if(t>=5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`(resRC % ${e}aShape)`;const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<t;s++)r.push(`(${n[s]} % ${e}aShape[${s}])`);return r.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VC(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reps:o}=r;if(n.shouldExecuteOnCPU([s])||s.dtype==="string"||s.shape.length>=5){const l=n.readSync(s.dataId),c=s.dtype==="string"?l.map(p=>fa(p)):l,d=Wt(s.shape,s.dtype,c),f=gve(d,o);return n.makeTensorInfo(f.shape,f.dtype,f.values)}const i=new T$e(s.shape,o);return n.runWebGPUProgram(i,[s],s.dtype)}const N$e={kernelName:sy,backendName:"webgpu",kernelFunc:VC};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E$e(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:s,sparseValues:o,defaultValue:i}=e,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:d,strides:f,outputSize:p}=Bu(o,s,a),g=!1;if(o.dtype==="string"){const B=n.bufferSync(s),M=n.bufferSync(o),V=fa(n.readSync(i.dataId)[0]),P=cve(B,M,a,p,d,c,l,f,V,g);return n.makeTensorInfo(a,P.dtype,P.values)}const y=[p/d,d],x=Be({inputs:{x:s},backend:n,attrs:{shape:[c,l]}}),w=o.shape.length?Be({inputs:{x:o},backend:n,attrs:{shape:[c,d]}}):gs({inputs:{x:o},backend:n}),S=w.dtype,$=n.makeTensorInfo([],S,ha(1,S)),I=Be({inputs:{x:i},backend:n,attrs:{shape:Array(y.length).fill(1)}}),R=VC({inputs:{x:I},backend:n,attrs:{reps:y}}),_=pe([c,d]),O=[{type:"int32",data:[l]},{type:"int32",data:f},{type:"int32",data:[_]}];switch(c){case 0:break;case 1:{const B=new Jh([c,d],l,x.shape.length,w.shape.length,f,y,S,g);n.runWebGPUProgram(B,[w,x],S,O,R)}break;default:{const B=new Jh([c,d],l,x.shape.length,$.shape.length,f,y,S,g);n.runWebGPUProgram(B,[$,x],S,O,R)}{const B=new Jh([c,d],l,x.shape.length,w.shape.length,f,y,S);n.runWebGPUProgram(B,[w,x],S,O,R)}}const F=Be({inputs:{x:R},backend:n,attrs:{shape:a}});return n.disposeData(x.dataId),n.disposeData(w.dataId),n.disposeData(I.dataId),n.disposeData($.dataId),n.disposeData(R.dataId),F}const R$e={kernelName:bS,backendName:"webgpu",kernelFunc:E$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _$e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{numOrSizeSplits:o,axis:i}=r,a=nn(i,s.shape)[0],l=kC(s,o,a),c=s.shape.length,d=new Array(c).fill(0),f=s.shape.slice();return l.map(p=>{const g=[...f];g[a]=p;const y=Ld({inputs:{x:s},backend:n,attrs:{begin:d,size:g}});return d[a]+=p,y})}const P$e={kernelName:gS,backendName:"webgpu",kernelFunc:_$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A$e=kt({opType:Ne.SQRT}),D$e={kernelName:fS,backendName:"webgpu",kernelFunc:A$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O$e={kernelName:dA,backendName:"webgpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,r=e,s=new Fd(n.shape,Ne.SQUARE);return r.runWebGPUProgram(s,[n],n.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F$e=zn({opType:Je.SQUARED_DIFFERENCE}),L$e={kernelName:wS,backendName:"webgpu",kernelFunc:F$e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z$e({inputs:t,attrs:e,backend:n}){const{x:r}=t,s=new Fd(r.shape,Ne.STEP,"stepAlpha : f32,"),o=[{type:"float32",data:[e.alpha]}];return n.runWebGPUProgram(s,[r],r.dtype,o)}const B$e={kernelName:PS,backendName:"webgpu",kernelFunc:z$e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class M$e{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const n=bn(this.outputShape.length);this.uniforms=`begin : ${n},  strides : ${n}, `,this.shaderKey="stridedSlice"}getUserCode(){const e=this.outputShape.length;let n="";if(e===1)n="coords * uniforms.strides + uniforms.begin";else{let s=0;n=this.outputShape.map((o,i)=>(s++,this.outputShape.length===1?`coords * uniforms.strides[${i}] + uniforms.begin[${i}]`:`coords[${s-1}] * uniforms.strides[${i}] + uniforms.begin[${i}]`)).join(",")}return`
       ${Ee("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${n}));
         }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V$e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:o,end:i,strides:a,beginMask:l,endMask:c,ellipsisMask:d,newAxisMask:f,shrinkAxisMask:p}=r,{finalShapeSparse:g,finalShape:y,isIdentity:x,sliceDim0:w,isSimpleSlice:S,begin:$,end:I,strides:R}=iC(s.shape,o,i,a,l,c,d,f,p);let _;if(x)_=Be({inputs:{x:s},backend:n,attrs:{shape:y}});else if(w||S){z(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const O=nC($,I,R),F=Ld({inputs:{x:s},backend:n,attrs:{begin:$,size:O}});_=Be({inputs:{x:F},backend:n,attrs:{shape:y}}),n.disposeData(F.dataId)}else if(n.shouldExecuteOnCPU([s])){const F=n.readSync(s.dataId),B=Wt(s.shape,s.dtype,F),M=fve(g,B,R,$);_=n.makeTensorInfo(y,s.dtype,M.values)}else{const F=new M$e(g),B=[{type:"int32",data:$},{type:"int32",data:R}],M=n.runWebGPUProgram(F,[s],s.dtype,B);_=Be({inputs:{x:M},backend:n,attrs:{shape:y}}),n.disposeData(M.dataId)}return _}const W$e={kernelName:SS,backendName:"webgpu",kernelFunc:V$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U$e(t){const{inputs:e,backend:n,attrs:r}=t,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:d,dataSplits:f}=e,p=n.readSync(d.dataId),g=n.readSync(f.dataId),[y,x]=pve(p,g,s,o,i,a,l,c);return[n.makeTensorInfo([y.length],"string",y),n.makeTensorInfo(f.shape,"int32",x)]}const j$e={kernelName:CS,backendName:"webgpu",kernelFunc:U$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G$e=zn({opType:Je.SUB,cpuKernelImpl:mve,supportsComplex:!0}),H$e={kernelName:$S,backendName:"webgpu",kernelFunc:G$e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K$e=kt({opType:Ne.TAN}),X$e={kernelName:kS,backendName:"webgpu",kernelFunc:K$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q$e=kt({opType:Ne.TANH}),Y$e={kernelName:TS,backendName:"webgpu",kernelFunc:q$e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q$e(t){const{inputs:e,backend:n,attrs:r}=t,{tensor:s,indices:o,updates:i}=e,{sliceRank:a,numUpdates:l,sliceSize:c,strides:d,outputSize:f}=Bu(i,o,s.shape),p=[f/c,c];if(f===0)return n.makeTensorInfo(s.shape,o.dtype);const g=[],y=Be({inputs:{x:o},backend:n,attrs:{shape:[l,a]}});g.push(y);const x=Be({inputs:{x:i},backend:n,attrs:{shape:[l,c]}});g.push(x);const w=Be({inputs:{x:s},backend:n,attrs:{shape:p}});g.push(w);const S=VC({inputs:{x:w},backend:n,attrs:{reps:Array(p.length).fill(1)}}),$=new Jh([l,c],a,y.shape.length,x.shape.length,d,p,s.dtype,!1),I=pe([l,c]),R=[{type:"int32",data:[a]},{type:"int32",data:d},{type:"int32",data:[I]}],_=n.runWebGPUProgram($,[x,y],w.dtype,R,S);g.push(_);const O=Be({inputs:{x:_},backend:n,attrs:{shape:s.shape}});return g.forEach(F=>n.disposeData(F.dataId)),O}const Z$e={kernelName:rS,backendName:"webgpu",kernelFunc:Q$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class J$e{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${Ee("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}class eke{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${Ee("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ic(t,e){e!==null&&t.disposeData(e.dataId)}function BN(t){let e=1;for(;e<t;)e*=2;return e}function tke(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{k:o,sorted:i}=r,a=s.shape,l=a[a.length-1];if(n.shouldExecuteOnCPU([s])){const _=n.readSync(s.dataId),[O,F]=yve(_,a,s.dtype,o,i);return[n.makeTensorInfo(O.shape,O.dtype,O.values),n.makeTensorInfo(F.shape,F.dtype,F.values)]}if(o===0)return a[a.length-1]=0,[n.makeTensorInfo(a,s.dtype,[]),n.makeTensorInfo(a,"int32",[])];if(l===1)return[s,Ur({attrs:{shape:a,dtype:"int32",value:0},backend:n})];const d=pe(a)/l,f=Be({inputs:{x:s},attrs:{shape:[d,l]},backend:n}),p=BN(o),g=BN(l);let y=null;const x=()=>y===null?[f,f]:[f,y],w=(_,O,F)=>{const B=x(),M=new J$e(F),P=[{type:"int32",data:[l]},{type:"int32",data:[y===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[_]},{type:"int32",data:[O]}],re=y;y=n.runWebGPUProgram(M,B,"int32",P),Ic(n,re)};for(let _=1;_<p;_*=2){const O=_*2;for(let F=_;F>=1;F/=2)w(O,F,[d,g])}for(let _=g;_>p;_/=2){const O=x(),F=new eke([d,_/2]),M=[{type:"int32",data:[l]},{type:"int32",data:[y===null?1:0]},{type:"int32",data:[p]}],V=y;y=n.runWebGPUProgram(F,O,"int32",M),Ic(n,V);const P=p/2,re=P*2;for(let ie=P;ie>=1;ie/=2)w(re,ie,y.shape)}let S=y;y=Ld({inputs:{x:y},backend:n,attrs:{begin:0,size:[d,o]}}),Ic(n,S);let $=AF({inputs:{x:f,indices:y},backend:n,attrs:{axis:1,batchDims:1}});Ic(n,f);const I=a.slice(0,-1);I.push(o),S=y,y=Be({inputs:{x:y},attrs:{shape:I},backend:n}),Ic(n,S);const R=$;return $=Be({inputs:{x:$},attrs:{shape:I},backend:n}),Ic(n,R),[$,y]}const nke={kernelName:IS,backendName:"webgpu",kernelFunc:tke};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rke{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${Ee("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ske(t){const{inputs:e,backend:n,attrs:r}=t,{image:s,transforms:o}=e,{interpolation:i,fillMode:a,fillValue:l,outputShape:c}=r,[d,f,p,g]=s.shape,[y,x]=c??[f,p],w=[d,y,x,g],S=new rke(w),$=i==="nearest"?1:2;let I;switch(a){case"constant":I=1;break;case"reflect":I=2;break;case"wrap":I=3;break;case"nearest":I=4;break;default:I=1;break}const R=[{type:"int32",data:[$]},{type:"int32",data:[I]},{type:"float32",data:[l]}];return n.runWebGPUProgram(S,[s,o],"float32",R)}const oke={kernelName:NS,backendName:"webgpu",kernelFunc:ske};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ike(t){const{inputs:e,backend:n,attrs:r}=t,{value:s}=e;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s,a=i.shape.length,l=s.shape[o],c=new Array(a-1);let d=0;for(let x=0;x<a;x++)x!==o&&(c[d++]=i.shape[x]);const f=[],p=new Array(a).fill(0),g=i.shape.slice();g[o]=1;const y=new Array(l);for(let x=0;x<y.length;x++){p[o]=x;const w=Ld({inputs:{x:i},backend:n,attrs:{begin:p,size:g}}),S=Be({inputs:{x:w},backend:n,attrs:{shape:c}});y[x]=S,f.push(w)}return f.forEach(x=>n.disposeData(x.dataId)),y}const ake={kernelName:ES,backendName:"webgpu",kernelFunc:ike};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lke{constructor(e,n,r){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=n,this.dispatchLayout=De(e),this.dispatch=Re(this.dispatchLayout,e,this.workgroupSize),r!=="float32"&&r!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${r} type.`);this.type=r,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${Nl("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uke(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,segmentIds:o}=e,{numSegments:i}=r,a=s.shape.length,l=[];let c=0;const d=lr([c],a);let f=s;d!=null&&(f=Ci({inputs:{x:s},backend:n,attrs:{perm:d}}),l.push(f),c=ur(1,a)[0]);const p=TC(f.shape,c,i),g=pe([f.shape[c]]),y=Be({inputs:{x:f},backend:n,attrs:{shape:[-1,g]}});l.push(y);const x=s.dtype,w=[y.shape[0],i],S=Ur({backend:n,attrs:{shape:w,value:0,dtype:x}}),$=new lke(y.shape,w,x),I=[{type:"int32",data:[i]},{type:"int32",data:[pe(y.shape)]}],R=n.runWebGPUProgram($,[y,o],x,I,S),_=Be({inputs:{x:R},backend:n,attrs:{shape:p}});l.push(R);let O=_;if(d!=null){l.push(_);const F=qf(d);O=Ci({inputs:{x:O},backend:n,attrs:{perm:F}})}return l.forEach(F=>n.disposeData(F.dataId)),O}const cke={kernelName:RS,backendName:"webgpu",kernelFunc:uke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dke=[Fxe,bve,Sve,$ve,Tve,Eve,Fve,zve,Mve,Wve,jve,Hve,Xve,Yve,Zve,rbe,obe,ube,dbe,fbe,xbe,Sbe,kbe,Ebe,_be,Obe,zxe,zbe,Wbe,Ybe,n2e,i2e,u2e,d2e,f2e,m2e,y2e,b2e,S2e,$2e,T2e,E2e,F2e,z2e,P2e,V2e,j2e,X2e,Y2e,J2e,rwe,owe,awe,uwe,dwe,fwe,pwe,gwe,xwe,Axe,bwe,Twe,Swe,$we,Ewe,_we,Awe,Fwe,Bwe,Vwe,Uwe,Lxe,Gwe,Mbe,Kwe,qwe,Qwe,Jwe,tSe,rSe,iSe,cSe,lSe,hSe,pSe,gSe,bSe,CSe,ebe,kSe,ISe,OSe,ESe,ASe,LSe,tbe,BSe,VSe,USe,GSe,YSe,ewe,ZSe,eCe,nCe,Tbe,oCe,aCe,uCe,hCe,pCe,gCe,xCe,bCe,Ibe,SCe,$Ce,TCe,NCe,Dxe,_Ce,DCe,LCe,MCe,UCe,GCe,KCe,qCe,QCe,e$e,r$e,o$e,a$e,u$e,d$e,f$e,gbe,B$e,W$e,j$e,XSe,m$e,x$e,C$e,k$e,R$e,P$e,D$e,O$e,L$e,H$e,twe,X$e,Y$e,Z$e,N$e,nke,oke,Pve,ake,cke,iCe];for(const t of dke)gA(t);/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var BF=function(t,e){return(BF=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,r){n.__proto__=r}||function(n,r){for(var s in r)Object.prototype.hasOwnProperty.call(r,s)&&(n[s]=r[s])})(t,e)};function MF(t,e){if(typeof e!="function"&&e!==null)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function n(){this.constructor=t}BF(t,e),t.prototype=e===null?Object.create(e):(n.prototype=e.prototype,new n)}var Yt=function(){return(Yt=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var s in e=arguments[n])Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s]);return t}).apply(this,arguments)};function bt(t,e,n,r){return new(n||(n=Promise))(function(s,o){function i(c){try{l(r.next(c))}catch(d){o(d)}}function a(c){try{l(r.throw(c))}catch(d){o(d)}}function l(c){var d;c.done?s(c.value):(d=c.value,d instanceof n?d:new n(function(f){f(d)})).then(i,a)}l((r=r.apply(t,[])).next())})}function wt(t,e){var n,r,s,o,i={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(l){return function(c){return function(d){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,r&&(s=2&d[0]?r.return:d[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,d[1])).done)return s;switch(r=0,s&&(d=[2&d[0],s.value]),d[0]){case 0:case 1:s=d;break;case 4:return i.label++,{value:d[1],done:!1};case 5:i.label++,r=d[1],d=[0];continue;case 7:d=i.ops.pop(),i.trys.pop();continue;default:if(s=i.trys,!((s=s.length>0&&s[s.length-1])||d[0]!==6&&d[0]!==2)){i=0;continue}if(d[0]===3&&(!s||d[1]>s[0]&&d[1]<s[3])){i.label=d[1];break}if(d[0]===6&&i.label<s[1]){i.label=s[1],s=d;break}if(s&&i.label<s[2]){i.label=s[2],i.ops.push(d);break}s[2]&&i.ops.pop(),i.trys.pop();continue}d=e.call(t,i)}catch(f){d=[6,f],r=0}finally{n=s=0}if(5&d[0])throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}([l,c])}}}function wu(t,e,n){if(n||arguments.length===2)for(var r,s=0,o=e.length;s<o;s++)!r&&s in e||(r||(r=Array.prototype.slice.call(e,0,s)),r[s]=e[s]);return t.concat(r||Array.prototype.slice.call(e))}var $i=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],Pf=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"];function Mg(t){return t instanceof SVGAnimatedLength?t.baseVal.value:t}function VF(t){return bt(this,void 0,void 0,function(){var e,n;return wt(this,function(r){switch(r.label){case 0:return e=document.createElement("canvas"),t instanceof fn?[4,JS(t,e)]:[3,2];case 1:return r.sent(),[3,3];case 2:e.width=Mg(t.width),e.height=Mg(t.height),n=e.getContext("2d"),t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0),r.label=3;case 3:return[2,e]}})})}function WF(t){return bt(this,void 0,void 0,function(){var e,n,r,s,o,i;return wt(this,function(a){switch(a.label){case 0:return t instanceof fn?(e=t.shape.slice(0,2),n=e[0],r=e[1],s=ImageData.bind,[4,JS(t)]):[3,2];case 1:return[2,new(s.apply(ImageData,[void 0,a.sent(),r,n]))];case 2:return o=document.createElement("canvas"),i=o.getContext("2d"),o.width=Mg(t.width),o.height=Mg(t.height),i.drawImage(t,0,0),[2,i.getImageData(0,0,o.width,o.height)]}})})}function hke(t){return bt(this,void 0,void 0,function(){var e,n;return wt(this,function(r){switch(r.label){case 0:return t instanceof SVGImageElement||t instanceof OffscreenCanvas?[4,VF(t)]:[3,2];case 1:return n=r.sent(),[3,3];case 2:n=t,r.label=3;case 3:return e=n,[2,UD(e,4)]}})})}function UF(t){if(t<0||t>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(t));if(!Number.isInteger(t))throw new Error("Mask value must be an integer but got ".concat(t))}var Ch={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},fke=function(){function t(e){this.mask=e}return t.prototype.toCanvasImageSource=function(){return bt(this,void 0,void 0,function(){return wt(this,function(e){return[2,this.mask]})})},t.prototype.toImageData=function(){return bt(this,void 0,void 0,function(){return wt(this,function(e){return[2,WF(this.mask)]})})},t.prototype.toTensor=function(){return bt(this,void 0,void 0,function(){return wt(this,function(e){return[2,hke(this.mask)]})})},t.prototype.getUnderlyingType=function(){return"canvasimagesource"},t}();function pke(t){return UF(t),"person"}var mke=function(){function t(e){var n,r=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new iye.Pose({locateFile:function(s,o){if(e.solutionPath){var i=e.solutionPath.replace(/\/+$/,"");return"".concat(i,"/").concat(s)}return"".concat(o,"/").concat(s)}}),e.modelType){case"lite":n=0;break;case"heavy":n=2;break;case"full":default:n=1}this.poseSolution.setOptions({modelComplexity:n,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(s){if(r.height=s.image.height,r.width=s.image.width,s.poseLandmarks==null)r.poses=[];else{var o=r.translateOutput(s.poseLandmarks,s.poseWorldLandmarks);s.segmentationMask&&(o.segmentation={maskValueToLabel:pke,mask:new fke(s.segmentationMask)}),r.poses=[o]}})}return t.prototype.translateOutput=function(e,n){var r=this,s={keypoints:e.map(function(o,i){return{x:o.x*r.width,y:o.y*r.height,z:o.z,score:o.visibility,name:Pf[i]}})};return n!=null&&(s.keypoints3D=n.map(function(o,i){return{x:o.x,y:o.y,z:o.z,score:o.visibility,name:Pf[i]}})),s},t.prototype.estimatePoses=function(e,n,r){return bt(this,void 0,void 0,function(){var s,o;return wt(this,function(i){switch(i.label){case 0:return n&&n.flipHorizontal&&n.flipHorizontal!==this.selfieMode&&(this.selfieMode=n.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof fn?(o=ImageData.bind,[4,JS(e)]):[3,2];case 1:return s=new(o.apply(ImageData,[void 0,i.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:s=e,i.label=3;case 3:return e=s,[4,this.poseSolution.send({image:e},r)];case 4:return i.sent(),[2,this.poses]}})})},t.prototype.dispose=function(){this.poseSolution.close()},t.prototype.reset=function(){this.poseSolution.reset()},t.prototype.initialize=function(){return this.poseSolution.initialize()},t}();function gke(t){return bt(this,void 0,void 0,function(){var e,n;return wt(this,function(r){switch(r.label){case 0:return e=function(s){if(s==null)return Yt({},Ch);var o=Yt({},s);return o.runtime="mediapipe",o.enableSegmentation==null&&(o.enableSegmentation=Ch.enableSegmentation),o.enableSmoothing==null&&(o.enableSmoothing=Ch.enableSmoothing),o.smoothSegmentation==null&&(o.smoothSegmentation=Ch.smoothSegmentation),o.modelType==null&&(o.modelType=Ch.modelType),o}(t),[4,(n=new mke(e)).initialize()];case 1:return r.sent(),[2,n]}})})}function md(t){return t instanceof fn?{height:t.shape[0],width:t.shape[1]}:{height:t.height,width:t.width}}function jF(t){return t-2*Math.PI*Math.floor((t+Math.PI)/(2*Math.PI))}function WC(t){return t instanceof fn?t:UD(t)}function GF(t,e,n){return zv(n,"inputResolution"),[1/n.width*t[0][0]*e.width,1/n.height*t[0][1]*e.width,t[0][3]*e.width,1/n.width*t[1][0]*e.height,1/n.height*t[1][1]*e.height,t[1][3]*e.height,0,0]}function zv(t,e){z(t.width!==0,function(){return"".concat(e," width cannot be 0.")}),z(t.height!==0,function(){return"".concat(e," height cannot be 0.")})}function ox(t,e,n){var r=n.rotationVectorStartKeypointIndex,s=n.rotationVectorEndKeypointIndex,o=t.locationData,i=o.relativeKeypoints[r].x*e.width,a=o.relativeKeypoints[r].y*e.height,l=o.relativeKeypoints[s].x*e.width,c=o.relativeKeypoints[s].y*e.height,d=2*Math.sqrt((l-i)*(l-i)+(c-a)*(c-a)),f=function(p,g,y){var x,w=p.locationData,S=y.rotationVectorStartKeypointIndex,$=y.rotationVectorEndKeypointIndex;x=y.rotationVectorTargetAngle?y.rotationVectorTargetAngle:Math.PI*y.rotationVectorTargetAngleDegree/180;var I=w.relativeKeypoints[S].x*g.width,R=w.relativeKeypoints[S].y*g.height,_=w.relativeKeypoints[$].x*g.width,O=w.relativeKeypoints[$].y*g.height;return jF(x-Math.atan2(-(O-R),_-I))}(t,e,n);return{xCenter:i/e.width,yCenter:a/e.height,width:d/e.width,height:d/e.height,rotation:f}}function HF(t){if(t.length!==16)throw new Error("Array length must be 16 but got ".concat(t.length));return[[t[0],t[1],t[2],t[3]],[t[4],t[5],t[6],t[7]],[t[8],t[9],t[10],t[11]],[t[12],t[13],t[14],t[15]]]}function ix(t,e,n,r,s,o,i){return t[e][s]*(t[n][o]*t[r][i]-t[n][i]*t[r][o])}function xr(t,e,n){var r=(e+1)%4,s=(e+2)%4,o=(e+3)%4,i=(n+1)%4,a=(n+2)%4,l=(n+3)%4;return ix(t,r,s,o,i,a,l)+ix(t,s,o,r,i,a,l)+ix(t,o,r,s,i,a,l)}function MN(t,e,n){n===void 0&&(n={ignoreRotation:!1});for(var r=[],s=0,o=t;s<o.length;s++){var i=o[s],a=i.x-.5,l=i.y-.5,c=n.ignoreRotation?0:e.rotation,d=Math.cos(c)*a-Math.sin(c)*l,f=Math.sin(c)*a+Math.cos(c)*l;d=d*e.width+e.xCenter,f=f*e.height+e.yCenter;var p=i.z*e.width,g=Yt({},i);g.x=d,g.y=f,g.z=p,r.push(g)}return r}function KF(t,e){var n=function(r,s,o,i){var a=s-r,l=i-o,c=l/a;return{scale:c,offset:o-r*c}}(0,255,e[0],e[1]);return nt(function(){return We(Te(t,n.scale),n.offset)})}function Bv(t,e,n){var r,s,o,i,a,l,c,d,f,p,g,y,x,w,S=e.outputTensorSize,$=e.keepAspectRatio,I=e.borderMode,R=e.outputTensorFloatRange,_=md(t),O=function(M,V){return V?{xCenter:V.xCenter*M.width,yCenter:V.yCenter*M.height,width:V.width*M.width,height:V.height*M.height,rotation:V.rotation}:{xCenter:.5*M.width,yCenter:.5*M.height,width:M.width,height:M.height,rotation:0}}(_,n),F=function(M,V,P){if(P===void 0&&(P=!1),!P)return{top:0,left:0,right:0,bottom:0};var re=V.height,ie=V.width;zv(V,"targetSize"),zv(M,"roi");var me,ge,ve=re/ie,$e=M.height/M.width,fe=0,xe=0;return ve>$e?(me=M.width,ge=M.width*ve,xe=(1-$e/ve)/2):(me=M.height/ve,ge=M.height,fe=(1-ve/$e)/2),M.width=me,M.height=ge,{top:xe,left:fe,right:fe,bottom:xe}}(O,S,$),B=(r=O,s=_.width,o=_.height,i=!1,a=r.width,l=r.height,c=i?-1:1,d=Math.cos(r.rotation),f=Math.sin(r.rotation),p=r.xCenter,g=r.yCenter,y=1/s,x=1/o,(w=new Array(16))[0]=a*d*c*y,w[1]=-l*f*y,w[2]=0,w[3]=(-.5*a*d*c+.5*l*f+p)*y,w[4]=a*f*c*x,w[5]=l*d*x,w[6]=0,w[7]=(-.5*l*d-.5*a*f*c+g)*x,w[8]=0,w[9]=0,w[10]=a*y,w[11]=0,w[12]=0,w[13]=0,w[14]=0,w[15]=1,HF(w));return{imageTensor:nt(function(){var M=WC(t),V=lo(GF(B,_,S),[1,8]),P=I==="zero"?"constant":"nearest",re=Tu.transform(Rs(Qt(M,"float32")),V,"bilinear",P,0,[S.height,S.width]);return R!=null?KF(re,R):re}),padding:F,transformationMatrix:B}}function VN(t,e,n,r){return r===1?.5*(t+e):t+(e-t)*n/(r-1)}function yke(t){return nt(function(){var e=function(s){return nt(function(){return[pt(s,[0,0,0],[1,-1,1]),pt(s,[0,0,1],[1,-1,-1])]})}(t),n=e[0],r=e[1];return{boxes:Gt(r),logits:Gt(n)}})}function XF(t){return t!=null&&t.currentTime!=null}function WN(t){for(var e={locationData:{relativeKeypoints:[]}},n=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,s=Number.MAX_SAFE_INTEGER,o=Number.MIN_SAFE_INTEGER,i=0;i<t.length;++i){var a=t[i];n=Math.min(n,a.x),r=Math.max(r,a.x),s=Math.min(s,a.y),o=Math.max(o,a.y),e.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return e.locationData.relativeBoundingBox={xMin:n,yMin:s,xMax:r,yMax:o,width:r-n,height:o-s},e}function xke(t,e,n,r){return bt(this,void 0,void 0,function(){var s,o,i,a,l;return wt(this,function(c){switch(c.label){case 0:return t.sort(function(d,f){return Math.max.apply(Math,f.score)-Math.max.apply(Math,d.score)}),s=lo(t.map(function(d){return[d.locationData.relativeBoundingBox.yMin,d.locationData.relativeBoundingBox.xMin,d.locationData.relativeBoundingBox.yMax,d.locationData.relativeBoundingBox.xMax]})),o=ar(t.map(function(d){return d.score[0]})),[4,Tu.nonMaxSuppressionAsync(s,o,e,n)];case 1:return[4,(i=c.sent()).array()];case 2:return a=c.sent(),l=t.filter(function(d,f){return a.indexOf(f)>-1}),Mt([s,o,i]),[2,l]}})})}function qF(t,e){return t.map(function(n){var r=Yt(Yt({},n),{x:n.x*e.width,y:n.y*e.height});return n.z!=null&&(r.z=n.z*e.width),r})}function vke(t,e,n){return bt(this,void 0,void 0,function(){var r,s,o,i,a,l,c,d,f,p,g,y,x,w,S,$,I,R,_,O,F,B,M,V;return wt(this,function(P){switch(P.label){case 0:if(r=Gt(e,[0]),s=r.shape,o=s[0],i=s[1],a=s[2],t.length!==a)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(t.length,", heatmap length: ").concat(a));return l=[],[4,r.buffer()];case 1:for(c=P.sent(),d=0;d<t.length;d++)if(f=t[d],p=Yt({},f),l.push(p),g=Math.trunc(p.x*i),y=Math.trunc(p.y*o),!(g<0||g>=i||y<0||g>=o)){for(x=Math.trunc((n.kernelSize-1)/2),w=Math.max(0,g-x),S=Math.min(i,g+x+1),$=Math.max(0,y-x),I=Math.min(o,y+x+1),R=0,_=0,O=0,F=0,B=$;B<I;++B)for(M=w;M<S;++M)V=c.get(B,M,d),R+=V,F=Math.max(F,V),_+=M*V,O+=B*V;F>=n.minConfidenceToRefine&&R>0&&(p.x=_/i/R,p.y=O/o/R)}return r.dispose(),[2,l]}})})}function UN(t,e){var n=e.left,r=e.top,s=e.left+e.right,o=e.top+e.bottom;return t.map(function(i){return Yt(Yt({},i),{x:(i.x-n)/(1-s),y:(i.y-r)/(1-o),z:i.z/(1-s)})})}function bke(t,e,n){return mf()==="webgl"?function(r,s,o){var i=o.combineWithPreviousRatio.toFixed(2),a={variableNames:["prevMask","newMask"],outputShape:r.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `.concat(i,`);

      setOutput(outputValue);
    }
`)},l=ud();return nt(function(){var c=l.compileAndRun(a,[r,s]);return ds().makeTensorFromDataId(c.dataId,c.shape,c.dtype)})}(t,e,n):nt(function(){var r=ot(e,.5),s=ao(r),o=ot(1,wf(1,Te(s,We(5.68842,Te(s,We(-.748699,Te(s,We(-57.8051,Te(s,We(291.309,Te(s,-624.717)))))))))));return We(e,Te(ot(t,e),Te(o,n.combineWithPreviousRatio)))})}function wke(t,e,n){return bt(this,void 0,void 0,function(){var r,s,o,i,a;return wt(this,function(l){switch(l.label){case 0:return r=t[0],s=t[1],o=function(c,d,f){return nt(function(){var p,g,y,x;f.reverseOutputOrder?(g=Gt(pt(c,[0,f.boxCoordOffset+0],[-1,1])),p=Gt(pt(c,[0,f.boxCoordOffset+1],[-1,1])),x=Gt(pt(c,[0,f.boxCoordOffset+2],[-1,1])),y=Gt(pt(c,[0,f.boxCoordOffset+3],[-1,1]))):(p=Gt(pt(c,[0,f.boxCoordOffset+0],[-1,1])),g=Gt(pt(c,[0,f.boxCoordOffset+1],[-1,1])),y=Gt(pt(c,[0,f.boxCoordOffset+2],[-1,1])),x=Gt(pt(c,[0,f.boxCoordOffset+3],[-1,1]))),g=We(Te(gt(g,f.xScale),d.w),d.x),p=We(Te(gt(p,f.yScale),d.h),d.y),f.applyExponentialOnBoxSize?(y=Te(ga(gt(y,f.hScale)),d.h),x=Te(ga(gt(x,f.wScale)),d.w)):(y=Te(gt(y,f.hScale),d.h),x=Te(gt(x,f.wScale),d.h));var w=ot(p,gt(y,2)),S=ot(g,gt(x,2)),$=We(p,gt(y,2)),I=We(g,gt(x,2)),R=Fn([ye(w,[f.numBoxes,1]),ye(S,[f.numBoxes,1]),ye($,[f.numBoxes,1]),ye(I,[f.numBoxes,1])],1);if(f.numKeypoints)for(var _=0;_<f.numKeypoints;++_){var O=f.keypointCoordOffset+_*f.numValuesPerKeypoint,F=void 0,B=void 0;f.reverseOutputOrder?(F=Gt(pt(c,[0,O],[-1,1])),B=Gt(pt(c,[0,O+1],[-1,1]))):(B=Gt(pt(c,[0,O],[-1,1])),F=Gt(pt(c,[0,O+1],[-1,1])));var M=We(Te(gt(F,f.xScale),d.w),d.x),V=We(Te(gt(B,f.yScale),d.h),d.y);R=Fn([R,ye(M,[f.numBoxes,1]),ye(V,[f.numBoxes,1])],1)}return R})}(s,e,n),i=nt(function(){var c=r;return n.sigmoidScore?(n.scoreClippingThresh!=null&&(c=JA(r,-n.scoreClippingThresh,n.scoreClippingThresh)),c=aa(c)):c}),[4,Ske(o,i,n)];case 1:return a=l.sent(),Mt([o,i]),[2,a]}})})}function Ske(t,e,n){return bt(this,void 0,void 0,function(){var r,s,o,i,a,l,c,d,f,p,g,y;return wt(this,function(x){switch(x.label){case 0:return r=[],[4,t.data()];case 1:return s=x.sent(),[4,e.data()];case 2:for(o=x.sent(),i=0;i<n.numBoxes;++i)if(!(n.minScoreThresh!=null&&o[i]<n.minScoreThresh||(a=i*n.numCoords,l=Cke(s[a+0],s[a+1],s[a+2],s[a+3],o[i],n.flipVertically,i),(c=l.locationData.relativeBoundingBox).width<0||c.height<0))){if(n.numKeypoints>0)for((d=l.locationData).relativeKeypoints=[],f=n.numKeypoints*n.numValuesPerKeypoint,p=0;p<f;p+=n.numValuesPerKeypoint)g=a+n.keypointCoordOffset+p,y={x:s[g+0],y:n.flipVertically?1-s[g+1]:s[g+1]},d.relativeKeypoints.push(y);r.push(l)}return[2,r]}})})}function Cke(t,e,n,r,s,o,i){return{score:[s],ind:i,locationData:{relativeBoundingBox:{xMin:e,yMin:o?1-n:t,xMax:r,yMax:o?1-t:n,width:r-e,height:n-t}}}}function $ke(t,e){return t==="none"?e:function(n){return 1/(1+Math.exp(-n))}(e)}function jN(t,e,n,r){return bt(this,void 0,void 0,function(){var s,o,i,a,l,c,d,f;return wt(this,function(p){switch(p.label){case 0:return n=n||e.flipHorizontally||!1,r=r||e.flipVertically||!1,s=t.size,o=s/e.numLandmarks,[4,t.data()];case 1:for(i=p.sent(),a=[],l=0;l<e.numLandmarks;++l)c=l*o,(f={x:0,y:0}).x=n?e.inputImageWidth-i[c]:i[c],o>1&&(f.y=r?e.inputImageHeight-i[c+1]:i[c+1]),o>2&&(f.z=i[c+2]),o>3&&(f.score=$ke(e.visibilityActivation,i[c+3])),a.push(f);for(d=0;d<a.length;++d)(f=a[d]).x=f.x/e.inputImageWidth,f.y=f.y/e.inputImageHeight,f.z=f.z/e.inputImageWidth/(e.normalizeZ||1);return[2,a]}})})}function GN(t,e,n){var r=t.width,s=t.height,o=t.rotation;if(n.rotation==null&&n.rotationDegree==null||(o=function(c,d){return d.rotation!=null?c+=d.rotation:d.rotationDegree!=null&&(c+=Math.PI*d.rotationDegree/180),jF(c)}(o,n)),o===0)t.xCenter=t.xCenter+r*n.shiftX,t.yCenter=t.yCenter+s*n.shiftY;else{var i=(e.width*r*n.shiftX*Math.cos(o)-e.height*s*n.shiftY*Math.sin(o))/e.width,a=(e.width*r*n.shiftX*Math.sin(o)+e.height*s*n.shiftY*Math.cos(o))/e.height;t.xCenter=t.xCenter+i,t.yCenter=t.yCenter+a}{var l=Math.max(r*e.width,s*e.height);r=l/e.width,s=l/e.height}return t.width=r*n.scaleX,t.height=s*n.scaleY,t}function kke(t,e){return t.map(function(n){var r=Yt(Yt({},n),{x:n.x/e.width,y:n.y/e.height});return n.z!=null&&(n.z=n.z/e.width),r})}var cl=function(){function t(e){this.alpha=e,this.initialized=!1}return t.prototype.apply=function(e,n){var r;return this.initialized?r=n==null?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*n*Math.asinh((e-this.storedValue)/n):(r=e,this.initialized=!0),this.rawValue=e,this.storedValue=r,r},t.prototype.applyWithAlpha=function(e,n,r){return this.alpha=n,this.apply(e,r)},t.prototype.hasLastRawValue=function(){return this.initialized},t.prototype.lastRawValue=function(){return this.rawValue},t.prototype.reset=function(){this.initialized=!1},t}(),ax=function(){function t(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new cl(this.getAlpha(this.minCutOff)),this.dx=new cl(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return t.prototype.apply=function(e,n,r){if(e==null)return e;var s=Math.trunc(n);if(this.lastTimestamp>=s)return e;this.lastTimestamp!==0&&s!==0&&(this.frequency=1/(1e-6*(s-this.lastTimestamp))),this.lastTimestamp=s;var o=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*r*this.frequency:0,i=this.dx.applyWithAlpha(o,this.getAlpha(this.derivateCutOff)),a=this.minCutOff+this.beta*Math.abs(i),l=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(i):null;return this.x.applyWithAlpha(e,this.getAlpha(a),l)},t.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},t}(),Mv=function(){function t(e){this.config=e}return t.prototype.apply=function(e,n,r){var s=this;if(e==null)return this.reset(),null;this.initializeFiltersIfEmpty(e);var o=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return wu([],e,!0);o=1/r}return e.map(function(i,a){var l=Yt(Yt({},i),{x:s.xFilters[a].apply(i.x,n,o),y:s.yFilters[a].apply(i.y,n,o)});return i.z!=null&&(l.z=s.zFilters[a].apply(i.z,n,o)),l})},t.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},t.prototype.initializeFiltersIfEmpty=function(e){var n=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new ax(n.config)}),this.yFilters=e.map(function(r){return new ax(n.config)}),this.zFilters=e.map(function(r){return new ax(n.config)}))},t}(),lx=function(){function t(e){this.config=e,this.window=[],this.lowPassFilter=new cl(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return t.prototype.apply=function(e,n,r){if(e==null)return e;var s,o=Math.trunc(n);if(this.lastTimestamp>=o)return e;if(this.lastTimestamp===-1)s=1;else{for(var i=e*r-this.lastValue*this.lastValueScale,a=o-this.lastTimestamp,l=i,c=a,d=(1+this.window.length)*(1e6/30),f=0,p=this.window;f<p.length;f++){var g=p[f];if(c+g.duration>d)break;l+=g.distance,c+=g.duration}var y=l/(1e-6*c);s=1-1/(1+this.config.velocityScale*Math.abs(y)),this.window.unshift({distance:i,duration:a}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=r,this.lastTimestamp=o,this.lowPassFilter.applyWithAlpha(e,s)},t}(),Tke=function(){function t(e){this.config=e}return t.prototype.apply=function(e,n,r){var s=this;if(e==null)return this.reset(),null;var o=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return wu([],e,!0);o=1/r}return this.initializeFiltersIfEmpty(e),e.map(function(i,a){var l=Yt(Yt({},i),{x:s.xFilters[a].apply(i.x,n,o),y:s.yFilters[a].apply(i.y,n,o)});return i.z!=null&&(l.z=s.zFilters[a].apply(i.z,n,o)),l})},t.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},t.prototype.initializeFiltersIfEmpty=function(e){var n=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new lx(n.config)}),this.yFilters=e.map(function(r){return new lx(n.config)}),this.zFilters=e.map(function(r){return new lx(n.config)}))},t}(),ux=function(){function t(e){if(e.velocityFilter!=null)this.keypointsFilter=new Tke(e.velocityFilter);else{if(e.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(e,"."));this.keypointsFilter=new Mv(e.oneEuroFilter)}}return t.prototype.apply=function(e,n,r,s,o){if(s===void 0&&(s=!1),e==null)return this.keypointsFilter.reset(),null;var i=o!=null?function(c,d){return(c.width*d.width+c.height*d.height)/2}(o,r):1,a=s?qF(e,r):e,l=this.keypointsFilter.apply(a,n,i);return s?kke(l,r):l},t}(),HN=function(){function t(e){this.alpha=e.alpha}return t.prototype.apply=function(e){var n=this;if(e==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map(function(a){return new cl(n.alpha)}));for(var r=[],s=0;s<e.length;++s){var o=e[s],i=Yt({},o);i.score=this.visibilityFilters[s].apply(o.score),r.push(i)}return r},t}(),Ike={interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},Nc={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},Nke={maxPoses:1,flipHorizontal:!1},Eke={applyExponentialOnBoxSize:!1,flipVertically:!1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},Rke=.3,KN={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25},_ke={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},Pke={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},Ake={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},Dke={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},Oke={kernelSize:7,minConfidenceToRefine:.5},XN={alpha:.1},Fke={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},Lke={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},zke={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},Bke={activation:"none"},Mke={combineWithPreviousRatio:.7},Vke=function(){function t(e){this.mask=e}return t.prototype.toCanvasImageSource=function(){return bt(this,void 0,void 0,function(){return wt(this,function(e){return[2,VF(this.mask)]})})},t.prototype.toImageData=function(){return bt(this,void 0,void 0,function(){return wt(this,function(e){return[2,WF(this.mask)]})})},t.prototype.toTensor=function(){return bt(this,void 0,void 0,function(){return wt(this,function(e){return[2,this.mask]})})},t.prototype.getUnderlyingType=function(){return"tensor"},t}();function Wke(t){return UF(t),"person"}var Uke=function(){function t(e,n,r,s,o,i){this.detectorModel=e,this.landmarkModel=n,this.enableSmoothing=r,this.enableSegmentation=s,this.smoothSegmentation=o,this.modelType=i,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(f){f.reduceBoxesInLowestLayer==null&&(f.reduceBoxesInLowestLayer=!1),f.interpolatedScaleAspectRatio==null&&(f.interpolatedScaleAspectRatio=1),f.fixedAnchorSize==null&&(f.fixedAnchorSize=!1);for(var p=[],g=0;g<f.numLayers;){for(var y=[],x=[],w=[],S=[],$=g;$<f.strides.length&&f.strides[$]===f.strides[g];){var I=VN(f.minScale,f.maxScale,$,f.strides.length);if($===0&&f.reduceBoxesInLowestLayer)w.push(1),w.push(2),w.push(.5),S.push(.1),S.push(I),S.push(I);else{for(var R=0;R<f.aspectRatios.length;++R)w.push(f.aspectRatios[R]),S.push(I);if(f.interpolatedScaleAspectRatio>0){var _=$===f.strides.length-1?1:VN(f.minScale,f.maxScale,$+1,f.strides.length);S.push(Math.sqrt(I*_)),w.push(f.interpolatedScaleAspectRatio)}}$++}for(var O=0;O<w.length;++O){var F=Math.sqrt(w[O]);y.push(S[O]/F),x.push(S[O]*F)}var B=0,M=0;if(f.featureMapHeight.length>0)B=f.featureMapHeight[g],M=f.featureMapWidth[g];else{var V=f.strides[g];B=Math.ceil(f.inputSizeHeight/V),M=Math.ceil(f.inputSizeWidth/V)}for(var P=0;P<B;++P)for(var re=0;re<M;++re)for(var ie=0;ie<y.length;++ie){var me={xCenter:(re+f.anchorOffsetX)/M,yCenter:(P+f.anchorOffsetY)/B,width:0,height:0};f.fixedAnchorSize?(me.width=1,me.height=1):(me.width=x[ie],me.height=y[ie]),p.push(me)}g=$}return p}(Ike);var a=ar(this.anchors.map(function(f){return f.width})),l=ar(this.anchors.map(function(f){return f.height})),c=ar(this.anchors.map(function(f){return f.xCenter})),d=ar(this.anchors.map(function(f){return f.yCenter}));this.anchorTensor={x:c,y:d,w:a,h:l},this.prevFilteredSegmentationMask=this.enableSegmentation?lo([],[0,0]):null}return t.prototype.estimatePoses=function(e,n,r){return bt(this,void 0,void 0,function(){var s,o,i,a,l,c,d,f,p,g,y,x,w,S,$,I,R,_,O,F,B,M,V;return wt(this,function(P){switch(P.label){case 0:return s=function(re){var ie;if((ie=re==null?Nke:Yt({},re)).maxPoses==null&&(ie.maxPoses=1),ie.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(ie.maxPoses,". Should be > 0."));if(ie.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return ie}(n),e==null?(this.reset(),[2,[]]):(this.maxPoses=s.maxPoses,this.timestamp=r!=null?1e3*r:XF(e)?1e6*e.currentTime:null,o=md(e),i=nt(function(){return Qt(WC(e),"float32")}),(a=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(i)]);case 1:if((l=P.sent()).length===0)return this.reset(),i.dispose(),[2,[]];c=l[0],a=this.poseDetectionToRoi(c,o),P.label=2;case 2:return[4,this.poseLandmarksByRoi(a,i)];case 3:return d=P.sent(),i.dispose(),d==null?(this.reset(),[2,[]]):(f=d.landmarks,p=d.auxiliaryLandmarks,g=d.poseScore,y=d.worldLandmarks,x=d.segmentationMask,w=this.poseLandmarkFiltering(f,p,y,o),S=w.actualLandmarksFiltered,$=w.auxiliaryLandmarksFiltered,I=w.actualWorldLandmarksFiltered,R=this.poseLandmarksToRoi($,o),this.regionOfInterest=R,_=this.smoothSegmentation&&x!=null?this.poseSegmentationFiltering(x):x,(O=S!=null?qF(S,o):null)!=null&&O.forEach(function(re,ie){re.name=Pf[ie]}),(F=I)!=null&&F.forEach(function(re,ie){re.name=Pf[ie]}),B={score:g,keypoints:O,keypoints3D:F},_!==null&&(M=nt(function(){var re=Rs(_,2),ie=vl(re,[[0,0],[0,0],[0,1]]);return xD(ie,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||Mt(_),V={maskValueToLabel:Wke,mask:new Vke(M)},B.segmentation=V),[2,[B]])}})})},t.prototype.poseSegmentationFiltering=function(e){var n=this.prevFilteredSegmentationMask;return n.size===0?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=bke(n,e,Mke),Mt(e)),Mt(n),this.prevFilteredSegmentationMask},t.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),Mt([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},t.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(Mt(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=lo([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},t.prototype.detectPose=function(e){return bt(this,void 0,void 0,function(){var n,r,s,o,i,a,l,c,d,f;return wt(this,function(p){switch(p.label){case 0:return n=Bv(e,_ke),r=n.imageTensor,s=n.padding,o=this.detectorModel.predict(r),i=yke(o),a=i.boxes,[4,wke([l=i.logits,a],this.anchorTensor,Eke)];case 1:return(c=p.sent()).length===0?(Mt([r,o,l,a]),[2,c]):[4,xke(c,this.maxPoses,Rke)];case 2:return d=p.sent(),f=function(g,y){g===void 0&&(g=[]);for(var x=y.left,w=y.top,S=y.left+y.right,$=y.top+y.bottom,I=0;I<g.length;I++){var R=g[I],_=R.locationData.relativeBoundingBox,O=(_.xMin-x)/(1-S),F=(_.yMin-w)/(1-$),B=_.width/(1-S),M=_.height/(1-$);_.xMin=O,_.yMin=F,_.width=B,_.height=M,_.xMax=O+B,_.yMax=F+M;var V=R.locationData.relativeKeypoints;V&&V.forEach(function(P){var re=(P.x-x)/(1-S),ie=(P.y-w)/(1-$);P.x=re,P.y=ie})}return g}(d,s),Mt([r,o,l,a]),[2,f]}})})},t.prototype.poseDetectionToRoi=function(e,n){return GN(ox(e,n,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),n,KN)},t.prototype.poseLandmarksByRoi=function(e,n){return bt(this,void 0,void 0,function(){var r,s,o,i,a,l,c,d,f,p,g,y,x,w;return wt(this,function(S){switch(S.label){case 0:if(r=md(n),s=Bv(n,Pke,e),o=s.imageTensor,i=s.padding,a=s.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return l=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&l.push("activation_segmentation"),c=this.landmarkModel.execute(o,l),[4,this.tensorsToPoseLandmarksAndSegmentation(c)];case 1:return(d=S.sent())==null?(Mt(c),Mt(o),[2,null]):(f=d.landmarks,p=d.auxiliaryLandmarks,g=d.poseScore,y=d.worldLandmarks,x=d.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(r,e,i,a,f,p,y,x)]);case 2:return w=S.sent(),Mt(c),Mt(o),[2,Yt({poseScore:g},w)]}})})},t.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,n,r,s,o,i,a,l){return bt(this,void 0,void 0,function(){var c,d,f,p,g,y;return wt(this,function(x){return c=UN(o,r),d=UN(i,r),f=MN(c,n),p=MN(d,n),g=function(w,S){for(var $=[],I=0,R=w;I<R.length;I++){var _=R[I],O=_.x,F=_.y,B=S.rotation,M=Math.cos(B)*O-Math.sin(B)*F,V=Math.sin(B)*O+Math.cos(B)*F,P=Yt({},_);P.x=M,P.y=V,$.push(P)}return $}(a,n),y=null,this.enableSegmentation&&(y=nt(function(){var w=l.shape,S=w[0],$=w[1],I=function(O){var F=HF(new Array(16).fill(0));F[0][0]=xr(O,0,0),F[1][0]=-xr(O,0,1),F[2][0]=xr(O,0,2),F[3][0]=-xr(O,0,3),F[0][2]=xr(O,2,0),F[1][2]=-xr(O,2,1),F[2][2]=xr(O,2,2),F[3][2]=-xr(O,2,3),F[0][1]=-xr(O,1,0),F[1][1]=xr(O,1,1),F[2][1]=-xr(O,1,2),F[3][1]=xr(O,1,3),F[0][3]=-xr(O,3,0),F[1][3]=xr(O,3,1),F[2][3]=-xr(O,3,2),F[3][3]=xr(O,3,3);for(var B=O[0][0]*F[0][0]+O[1][0]*F[0][1]+O[2][0]*F[0][2]+O[3][0]*F[0][3],M=0;M<F.length;M++)for(var V=0;V<F.length;V++)F[M][V]/=B;return F}(s),R=lo(GF(I,{width:$,height:S},e),[1,8]),_=[1,S,$,1];return Gt(Tu.transform(ye(l,_),R,"bilinear","constant",0,[e.height,e.width]),[0,3])}),Mt(l)),[2,{landmarks:f,auxiliaryLandmarks:p,worldLandmarks:g,segmentationMask:y}]})})},t.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return bt(this,void 0,void 0,function(){var n,r,s,o,i,a,l,c,d,f,p,g,y;return wt(this,function(x){switch(x.label){case 0:return n=e[0],r=e[1],s=e[2],o=e[3],i=this.enableSegmentation?e[4]:null,[4,r.data()];case 1:return(a=x.sent()[0])<.5?[2,null]:[4,jN(n,Ake)];case 2:return[4,vke(x.sent(),s,Oke)];case 3:return l=x.sent(),c=l.slice(0,33),d=l.slice(33,35),[4,jN(o,Dke)];case 4:return f=x.sent(),p=f.slice(0,33),g=function(w,S,$){for(var I=[],R=0;R<w.length;R++){var _=Yt({},S[R]);_.score=w[R].score,I.push(_)}return I}(c,p),y=this.enableSegmentation?function(w,S,$){return nt(function(){var I=Gt(w,[0]),R=I.shape[2];if(R===1){var _=I;switch(S.activation){case"none":break;case"sigmoid":_=aa(_);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(S.activation,")"))}var O=_;return Gt(O,[2])}throw new Error("Unsupported number of tensor channels ".concat(R))})}(i,Bke):null,[2,{landmarks:c,auxiliaryLandmarks:d,poseScore:a,worldLandmarks:g,segmentationMask:y}]}})})},t.prototype.poseLandmarksToRoi=function(e,n){return GN(ox(WN(e),n,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),n,KN)},t.prototype.poseLandmarkFiltering=function(e,n,r,s){var o,i,a;if(this.timestamp!=null&&this.enableSmoothing){var l=ox(WN(n),s,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new HN(XN)),o=this.visibilitySmoothingFilterActual.apply(e),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new HN(XN)),i=this.visibilitySmoothingFilterAuxiliary.apply(n),a=this.visibilitySmoothingFilterActual.apply(r),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new ux(Fke)),o=this.landmarksSmoothingFilterActual.apply(o,this.timestamp,s,!0,l),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new ux(Lke)),i=this.landmarksSmoothingFilterAuxiliary.apply(i,this.timestamp,s,!0,l),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new ux(zke)),a=this.worldLandmarksSmoothingFilterActual.apply(r,this.timestamp)}else o=e,i=n,a=r;return{actualLandmarksFiltered:o,auxiliaryLandmarksFiltered:i,actualWorldLandmarksFiltered:a}},t}();function jke(t){return bt(this,void 0,void 0,function(){var e,n,r,s,o,i;return wt(this,function(a){switch(a.label){case 0:return e=function(l){var c=Yt({},l??Nc);if(c.enableSmoothing==null&&(c.enableSmoothing=Nc.enableSmoothing),c.enableSegmentation==null&&(c.enableSegmentation=Nc.enableSegmentation),c.smoothSegmentation==null&&(c.smoothSegmentation=Nc.smoothSegmentation),c.modelType==null&&(c.modelType=Nc.modelType),c.detectorModelUrl==null&&(c.detectorModelUrl=Nc.detectorModelUrl),c.landmarkModelUrl==null)switch(c.modelType){case"lite":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return c}(t),n=typeof e.detectorModelUrl=="string"&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,r=typeof e.landmarkModelUrl=="string"&&e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([fd(e.detectorModelUrl,{fromTFHub:n}),fd(e.landmarkModelUrl,{fromTFHub:r})])];case 1:return s=a.sent(),o=s[0],i=s[1],[2,new Uke(o,i,e.enableSmoothing,e.enableSegmentation,e.smoothSegmentation,e.modelType)]}})})}var Nu,wi,YF=function(){function t(e){(function(n){if(n.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(n.maxTracks));if(n.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(n.maxAge));if(n.keypointTrackerParams!==void 0){if(n.keypointTrackerParams.keypointConfidenceThreshold<0||n.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(n.keypointTrackerParams.keypointConfidenceThreshold));if(n.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(n.keypointTrackerParams.minNumberOfKeypoints));for(var r=0,s=n.keypointTrackerParams.keypointFalloff;r<s.length;r++){var o=s[r];if(o<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(o))}}})(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return t.prototype.apply=function(e,n){this.filterOldTracks(n);var r=this.computeSimilarity(e);return this.assignTracks(e,r,n),this.updateTracks(n),e},t.prototype.getTracks=function(){return this.tracks.slice()},t.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(e){return e.id}))},t.prototype.filterOldTracks=function(e){var n=this;this.tracks=this.tracks.filter(function(r){return e-r.lastTimestamp<=n.maxAge})},t.prototype.assignTracks=function(e,n,r){for(var s=Array.from(Array(n[0].length).keys()),o=[],i=0,a=Array.from(Array(e.length).keys());i<a.length;i++){var l=a[i];if(s.length!==0){for(var c=-1,d=-1,f=0,p=s;f<p.length;f++){var g=p[f],y=n[l][g];y>=this.minSimilarity&&y>d&&(c=g,d=y)}if(c>=0){var x=this.tracks[c];x=Object.assign(x,this.createTrack(e[l],r,x.id)),e[l].id=x.id;var w=s.indexOf(c);s.splice(w,1)}else o.push(l)}else o.push(l)}for(var S=0,$=o;S<$.length;S++){l=$[S];var I=this.createTrack(e[l],r);this.tracks.push(I),e[l].id=I.id}},t.prototype.updateTracks=function(e){this.tracks.sort(function(n,r){return r.lastTimestamp-n.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},t.prototype.createTrack=function(e,n,r){var s={id:r||this.nextTrackID(),lastTimestamp:n,keypoints:wu([],e.keypoints,!0).map(function(o){return Yt({},o)})};return e.box!==void 0&&(s.box=Yt({},e.box)),s},t.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},t.prototype.remove=function(){for(var e=[],n=0;n<arguments.length;n++)e[n]=arguments[n];this.tracks=this.tracks.filter(function(r){return!e.includes(r.id)})},t.prototype.reset=function(){this.tracks=[]},t}(),Gke=function(t){function e(n){return t.call(this,n)||this}return MF(e,t),e.prototype.computeSimilarity=function(n){var r=this;return n.length===0||this.tracks.length===0?[[]]:n.map(function(s){return r.tracks.map(function(o){return r.iou(s,o)})})},e.prototype.iou=function(n,r){var s=Math.max(n.box.xMin,r.box.xMin),o=Math.max(n.box.yMin,r.box.yMin),i=Math.min(n.box.xMax,r.box.xMax),a=Math.min(n.box.yMax,r.box.yMax);if(s>=i||o>=a)return 0;var l=(i-s)*(a-o);return l/(n.box.width*n.box.height+r.box.width*r.box.height-l)},e}(YF),Hke=function(t){function e(n){var r=t.call(this,n)||this;return r.keypointThreshold=n.keypointTrackerParams.keypointConfidenceThreshold,r.keypointFalloff=n.keypointTrackerParams.keypointFalloff,r.minNumKeyoints=n.keypointTrackerParams.minNumberOfKeypoints,r}return MF(e,t),e.prototype.computeSimilarity=function(n){if(n.length===0||this.tracks.length===0)return[[]];for(var r=[],s=0,o=n;s<o.length;s++){for(var i=o[s],a=[],l=0,c=this.tracks;l<c.length;l++){var d=c[l];a.push(this.oks(i,d))}r.push(a)}return r},e.prototype.oks=function(n,r){for(var s=this.area(r.keypoints)+1e-6,o=0,i=0,a=0;a<n.keypoints.length;++a){var l=n.keypoints[a],c=r.keypoints[a];if(!(l.score<this.keypointThreshold||c.score<this.keypointThreshold)){i+=1;var d=Math.pow(l.x-c.x,2)+Math.pow(l.y-c.y,2),f=2*this.keypointFalloff[a];o+=Math.exp(-1*d/(2*s*Math.pow(f,2)))}}return i<this.minNumKeyoints?0:o/i},e.prototype.area=function(n){var r=this,s=n.filter(function(l){return l.score>r.keypointThreshold}),o=Math.min.apply(Math,wu([1],s.map(function(l){return l.x}),!1)),i=Math.max.apply(Math,wu([0],s.map(function(l){return l.x}),!1)),a=Math.min.apply(Math,wu([1],s.map(function(l){return l.y}),!1));return(i-o)*(Math.max.apply(Math,wu([0],s.map(function(l){return l.y}),!1))-a)},e}(YF);function Kke(t){switch(t){case wi.BlazePose:return Pf.reduce(function(e,n,r){return e[n]=r,e},{});case wi.PoseNet:case wi.MoveNet:return $i.reduce(function(e,n,r){return e[n]=r,e},{});default:throw new Error("Model ".concat(t," is not supported."))}}(function(t){t.Keypoint="keypoint",t.BoundingBox="boundingBox"})(Nu||(Nu={})),function(t){t.MoveNet="MoveNet",t.BlazePose="BlazePose",t.PoseNet="PoseNet"}(wi||(wi={}));var qN=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],QF={modelType:"SinglePose.Lightning",enableSmoothing:!0},YN={},QN={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},cx={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},ZN={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function Xke(t,e,n,r){for(var s={},o=0,i=$i;o<i.length;o++){var a=i[o];s[a]=[e[n[a]].y*r.height,e[n[a]].x*r.width]}if(function($,I){return($[I.left_hip].score>.2||$[I.right_hip].score>.2)&&($[I.left_shoulder].score>.2||$[I.right_shoulder].score>.2)}(e,n)){var l=(s.left_hip[0]+s.right_hip[0])/2,c=(s.left_hip[1]+s.right_hip[1])/2,d=function($,I,R,_,O){for(var F=["left_shoulder","right_shoulder","left_hip","right_hip"],B=0,M=0,V=0;V<F.length;V++)(ge=Math.abs(_-R[F[V]][0]))>B&&(B=ge),(ve=Math.abs(O-R[F[V]][1]))>M&&(M=ve);for(var P=0,re=0,ie=0,me=Object.keys(R);ie<me.length;ie++){var ge,ve,$e=me[ie];$[I[$e]].score<.2||((ge=Math.abs(_-R[$e][0]))>P&&(P=ge),(ve=Math.abs(O-R[$e][1]))>re&&(re=ve))}return[B,M,P,re]}(e,n,s,l,c),f=d[0],p=d[1],g=d[2],y=d[3],x=Math.max(1.9*p,1.9*f,1.2*g,1.2*y),w=[l-(x=Math.min(x,Math.max(c,r.width-c,l,r.height-l))),c-x];if(x>Math.max(r.width,r.height)/2)return Vv(t==null,r);var S=2*x;return{yMin:w[0]/r.height,xMin:w[1]/r.width,yMax:(w[0]+S)/r.height,xMax:(w[1]+S)/r.width,height:(w[0]+S)/r.height-w[0]/r.height,width:(w[1]+S)/r.width-w[1]/r.width}}return Vv(t==null,r)}function Vv(t,e){var n,r,s,o;return t?e.width>e.height?(n=1,r=e.height/e.width,s=0,o=(e.width/2-e.height/2)/e.width):(n=e.width/e.height,r=1,s=(e.height/2-e.width/2)/e.height,o=0):e.width>e.height?(n=e.width/e.height,r=1,s=(e.height/2-e.width/2)/e.height,o=0):(n=1,r=e.height/e.width,s=0,o=(e.width/2-e.height/2)/e.width),{yMin:s,xMin:o,yMax:s+n,xMax:o+r,height:n,width:r}}function qke(t){var e,n=t==null?QF:Yt({},t);if(n.modelType==null)n.modelType="SinglePose.Lightning";else if(qN.indexOf(n.modelType)<0)throw new Error("Invalid architecture ".concat(n.modelType,". ")+"Should be one of ".concat(qN));if(n.enableSmoothing==null&&(n.enableSmoothing=!0),n.minPoseScore!=null&&(n.minPoseScore<0||n.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(n.multiPoseMaxDimension!=null&&(n.multiPoseMaxDimension%32!=0||n.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(n.modelType==="MultiPose.Lightning"&&n.enableTracking==null&&(n.enableTracking=!0),n.modelType==="MultiPose.Lightning"&&n.enableTracking===!0)if(n.trackerType==null&&(n.trackerType=Nu.BoundingBox),n.trackerType===Nu.Keypoint)n.trackerConfig!=null?n.trackerConfig=function(r){var s=JN(cx,r);return s.keypointTrackerParams=Yt({},cx.keypointTrackerParams),r.keypointTrackerParams!=null&&(r.keypointTrackerParams.keypointConfidenceThreshold!=null&&(s.keypointTrackerParams.keypointConfidenceThreshold=r.keypointTrackerParams.keypointConfidenceThreshold),r.keypointTrackerParams.keypointFalloff!=null&&(s.keypointTrackerParams.keypointFalloff=r.keypointTrackerParams.keypointFalloff),r.keypointTrackerParams.minNumberOfKeypoints!=null&&(s.keypointTrackerParams.minNumberOfKeypoints=r.keypointTrackerParams.minNumberOfKeypoints)),s}(n.trackerConfig):n.trackerConfig=cx;else{if(n.trackerType!==Nu.BoundingBox)throw new Error("Tracker type not supported by MoveNet");n.trackerConfig!=null?n.trackerConfig=(e=n.trackerConfig,JN(ZN,e)):n.trackerConfig=ZN}return n}function JN(t,e){var n={maxTracks:t.maxTracks,maxAge:t.maxAge,minSimilarity:t.minSimilarity};return e.maxTracks!=null&&(n.maxTracks=e.maxTracks),e.maxAge!=null&&(n.maxAge=e.maxAge),e.minSimilarity!=null&&(n.minSimilarity=e.minSimilarity),n}var Yke=function(){function t(e,n){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=Kke(wi.MoveNet),n.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):n.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=n.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new Mv(QN),this.cropRegionFilterYMin=new cl(.9),this.cropRegionFilterXMin=new cl(.9),this.cropRegionFilterYMax=new cl(.9),this.cropRegionFilterXMax=new cl(.9)),this.enableSmoothing=n.enableSmoothing,n.minPoseScore?this.minPoseScore=n.minPoseScore:this.minPoseScore=.25,n.multiPoseMaxDimension?this.multiPoseMaxDimension=n.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=n.enableTracking,this.multiPoseModel&&this.enableTracking&&(n.trackerType===Nu.Keypoint?this.tracker=new Hke(n.trackerConfig):n.trackerType===Nu.BoundingBox&&(this.tracker=new Gke(n.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return t.prototype.runSinglePersonPoseModel=function(e){return bt(this,void 0,void 0,function(){var n,r,s,o,i;return wt(this,function(a){switch(a.label){case 0:if((n=this.moveNetModel.execute(e)).shape.length!==4||n.shape[0]!==1||n.shape[1]!==1||n.shape[2]!==17||n.shape[3]!==3)throw n.dispose(),new Error("Unexpected output shape from model: [".concat(n.shape,"]"));return mf()==="webgpu"?[3,1]:(r=n.dataSync(),[3,3]);case 1:return[4,n.data()];case 2:r=a.sent(),a.label=3;case 3:for(n.dispose(),s={keypoints:[],score:0},o=0,i=0;i<17;++i)s.keypoints[i]={y:r[3*i],x:r[3*i+1],score:r[3*i+2]},s.keypoints[i].score>.2&&(++o,s.score+=s.keypoints[i].score);return o>0&&(s.score/=o),[2,s]}})})},t.prototype.runMultiPersonPoseModel=function(e){return bt(this,void 0,void 0,function(){var n,r,s,o,i,a,l,c;return wt(this,function(d){switch(d.label){case 0:if((n=this.moveNetModel.execute(e)).shape.length!==3||n.shape[0]!==1||n.shape[2]!==56)throw n.dispose(),new Error("Unexpected output shape from model: [".concat(n.shape,"]"));return mf()==="webgpu"?[3,1]:(r=n.dataSync(),[3,3]);case 1:return[4,n.data()];case 2:r=d.sent(),d.label=3;case 3:for(n.dispose(),s=[],o=r.length/56,i=0;i<o;++i)for(s[i]={keypoints:[]},a=56*i+51,s[i].box={yMin:r[a],xMin:r[a+1],yMax:r[a+2],xMax:r[a+3],width:r[a+3]-r[a+1],height:r[a+2]-r[a]},l=56*i+55,s[i].score=r[l],s[i].keypoints=[],c=0;c<17;++c)s[i].keypoints[c]={y:r[56*i+3*c],x:r[56*i+3*c+1],score:r[56*i+3*c+2]};return[2,s]}})})},t.prototype.estimatePoses=function(e,n,r){return n===void 0&&(n=YN),bt(this,void 0,void 0,function(){var s,o,i,a,l,c;return wt(this,function(d){switch(d.label){case 0:return n=function(f){return f==null?YN:Yt({},f)}(n),e==null?(this.reset(),[2,[]]):(r==null?XF(e)&&(r=1e6*e.currentTime):r*=1e3,s=WC(e),o=md(s),i=Rs(s,0),e instanceof fn||s.dispose(),a=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(i,o,r)]);case 1:return a=d.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(i,o,r)];case 3:a=d.sent(),d.label=4;case 4:for(l=0;l<a.length;++l)for(c=0;c<a[l].keypoints.length;++c)a[l].keypoints[c].name=$i[c],a[l].keypoints[c].y*=o.height,a[l].keypoints[c].x*=o.width;return[2,a]}})})},t.prototype.estimateSinglePose=function(e,n,r){return bt(this,void 0,void 0,function(){var s,o,i,a,l=this;return wt(this,function(c){switch(c.label){case 0:return this.cropRegion||(this.cropRegion=Vv(this.cropRegion==null,n)),s=nt(function(){var d=lo([[l.cropRegion.yMin,l.cropRegion.xMin,l.cropRegion.yMax,l.cropRegion.xMax]]),f=xa([1],"int32"),p=[l.modelInputResolution.height,l.modelInputResolution.width];return Qt(Tu.cropAndResize(e,d,f,p,"bilinear",0),"int32")}),e.dispose(),[4,this.runSinglePersonPoseModel(s)];case 1:if(o=c.sent(),s.dispose(),o.score<this.minPoseScore)return this.reset(),[2,[]];for(i=0;i<o.keypoints.length;++i)o.keypoints[i].y=this.cropRegion.yMin+o.keypoints[i].y*this.cropRegion.height,o.keypoints[i].x=this.cropRegion.xMin+o.keypoints[i].x*this.cropRegion.width;return r!=null&&this.enableSmoothing&&(o.keypoints=this.keypointFilter.apply(o.keypoints,r,1)),a=Xke(this.cropRegion,o.keypoints,this.keypointIndexByName,n),this.cropRegion=this.filterCropRegion(a),[2,[o]]}})})},t.prototype.estimateMultiplePoses=function(e,n,r){return bt(this,void 0,void 0,function(){var s,o,i,a,l,c,d,f,p,g,y,x=this;return wt(this,function(w){switch(w.label){case 0:return n.width>n.height?(o=this.multiPoseMaxDimension,i=Math.round(this.multiPoseMaxDimension*n.height/n.width),s=Tu.resizeBilinear(e,[i,o]),l=o,c=32*Math.ceil(i/32),a=vl(s,[[0,0],[0,c-i],[0,0],[0,0]])):(o=Math.round(this.multiPoseMaxDimension*n.width/n.height),i=this.multiPoseMaxDimension,s=Tu.resizeBilinear(e,[i,o]),l=32*Math.ceil(o/32),c=i,a=vl(s,[[0,0],[0,0],[0,l-o],[0,0]])),s.dispose(),e.dispose(),d=Qt(a,"int32"),a.dispose(),[4,this.runMultiPersonPoseModel(d)];case 1:for(f=w.sent(),d.dispose(),f=f.filter(function(S){return S.score>=x.minPoseScore}),g=0;g<f.length;++g)for(p=0;p<f[g].keypoints.length;++p)f[g].keypoints[p].y*=c/i,f[g].keypoints[p].x*=l/o;if(this.enableTracking&&(this.tracker.apply(f,r),this.enableSmoothing)){for(g=0;g<f.length;++g)this.keypointFilterMap.has(f[g].id)||this.keypointFilterMap.set(f[g].id,new Mv(QN)),f[g].keypoints=this.keypointFilterMap.get(f[g].id).apply(f[g].keypoints,r,1);y=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(S,$){y.has($)||x.keypointFilterMap.delete($)})}return[2,f]}})})},t.prototype.filterCropRegion=function(e){if(e){var n=this.cropRegionFilterYMin.apply(e.yMin),r=this.cropRegionFilterXMin.apply(e.xMin),s=this.cropRegionFilterYMax.apply(e.yMax),o=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:n,xMin:r,yMax:s,xMax:o,height:s-n,width:o-r}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},t.prototype.dispose=function(){this.moveNetModel.dispose()},t.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},t.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},t}();function Qke(t){return t===void 0&&(t=QF),bt(this,void 0,void 0,function(){var e,n,r,s;return wt(this,function(o){switch(o.label){case 0:return e=qke(t),r=!0,e.modelUrl?(r=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,fd(e.modelUrl,{fromTFHub:r})]):[3,2];case 1:return n=o.sent(),[3,4];case 2:return s=void 0,e.modelType==="SinglePose.Lightning"?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":e.modelType==="SinglePose.Thunder"?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":e.modelType==="MultiPose.Lightning"&&(s="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,fd(s,{fromTFHub:r})];case 3:n=o.sent(),o.label=4;case 4:return mf()==="webgl"&&se().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new Yke(n,e)]}})})}var eE={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},tE=["MobileNetV1","ResNet50"],nE={MobileNetV1:[8,16],ResNet50:[16]},Zke=[8,16,32],rE={MobileNetV1:[.5,.75,1],ResNet50:[1]},sE=[1,2,4],oE={maxPoses:1,flipHorizontal:!1},Jke={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},e3e=[-123.15,-115.9,-103.06];function dx(t){return Math.floor(t/2)}var t3e=function(){function t(e,n){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=n}return t.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},t.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},t.prototype.empty=function(){return this.numberOfElements===-1},t.prototype.size=function(){return this.numberOfElements+1},t.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},t.prototype.max=function(){return this.priorityQueue[0]},t.prototype.swim=function(e){for(;e>0&&this.less(dx(e),e);)this.exchange(e,dx(e)),e=dx(e)},t.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var n=2*e;if(n<this.numberOfElements&&this.less(n,n+1)&&n++,!this.less(e,n))break;this.exchange(e,n),e=n}},t.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},t.prototype.less=function(e,n){return this.getValueAt(e)<this.getValueAt(n)},t.prototype.exchange=function(e,n){var r=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[n],this.priorityQueue[n]=r},t}();function n3e(t,e,n,r,s,o){for(var i=o.shape,a=i[0],l=i[1],c=!0,d=Math.max(n-s,0),f=Math.min(n+s+1,a),p=d;p<f;++p){for(var g=Math.max(r-s,0),y=Math.min(r+s+1,l),x=g;x<y;++x)if(o.get(p,x,t)>e){c=!1;break}if(!c)break}return c}function r3e(t){return bt(this,void 0,void 0,function(){return wt(this,function(e){return[2,Promise.all(t.map(function(n){return n.buffer()}))]})})}function ZF(t,e,n,r){return{y:r.get(t,e,n),x:r.get(t,e,n+17)}}function JF(t,e,n){var r=ZF(t.heatmapY,t.heatmapX,t.id,n),s=r.y,o=r.x;return{x:t.heatmapX*e+o,y:t.heatmapY*e+s}}function e4(t,e,n,r){var s=n.x,o=n.y;return t.some(function(i){var a,l,c,d,f,p,g=i.keypoints;return a=o,l=s,c=g[r].y,d=g[r].x,(f=c-a)*f+(p=d-l)*p<=e})}var iE=$i.reduce(function(t,e,n){return t[e]=n,t},{}),t4=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(t){var e=t[0],n=t[1];return[iE[e],iE[n]]}),hx=t4.map(function(t){return t[1]}),aE=t4.map(function(t){return t[0]});function lE(t,e,n){return t<e?e:t>n?n:t}function fx(t,e,n,r){return{y:lE(Math.round(t.y/e),0,n-1),x:lE(Math.round(t.x/e),0,r-1)}}function uE(t,e){return{x:t.x+e.x,y:t.y+e.y}}function cE(t,e,n,r,s,o,i,a){a===void 0&&(a=2);for(var l=r.shape,c=l[0],d=l[1],f={y:e.y,x:e.x},p=uE(f,function($,I,R){var _=R.shape[2]/2;return{y:R.get(I.y,I.x,$),x:R.get(I.y,I.x,_+$)}}(t,fx(f,o,c,d),i)),g=0;g<a;g++){var y=fx(p,o,c,d),x=ZF(y.y,y.x,n,s);p=uE({x:y.x*o,y:y.y*o},{x:x.x,y:x.y})}var w=fx(p,o,c,d),S=r.get(w.y,w.x,n);return{y:p.y,x:p.x,name:$i[n],score:S}}function s3e(t,e,n,r,s,o){var i=e.shape[2],a=hx.length,l=new Array(i),c=t.part,d=t.score,f=JF(c,r,n);l[c.id]={score:d,name:$i[c.id],y:f.y,x:f.x};for(var p=a-1;p>=0;--p){var g=hx[p],y=aE[p];l[g]&&!l[y]&&(l[y]=cE(p,l[g],y,e,n,r,o))}for(p=0;p<a;++p)g=aE[p],y=hx[p],l[g]&&!l[y]&&(l[y]=cE(p,l[g],y,e,n,r,s));return l}function o3e(t,e,n){return n.reduce(function(r,s,o){var i=s.y,a=s.x,l=s.score;return e4(t,e,{y:i,x:a},o)||(r+=l),r},0)/n.length}function i3e(t,e,n,r,s,o,i,a){return i===void 0&&(i=.5),a===void 0&&(a=20),bt(this,void 0,void 0,function(){var l,c,d,f,p,g,y,x,w,S,$,I;return wt(this,function(R){switch(R.label){case 0:return[4,r3e([t,e,n,r])];case 1:for(l=R.sent(),c=l[0],d=l[1],f=l[2],p=l[3],g=[],y=function(_,O,F){for(var B=F.shape,M=B[0],V=B[1],P=B[2],re=new t3e(M*V*P,function($e){return $e.score}),ie=0;ie<M;++ie)for(var me=0;me<V;++me)for(var ge=0;ge<P;++ge){var ve=F.get(ie,me,ge);ve<_||n3e(ge,ve,ie,me,O,F)&&re.enqueue({score:ve,part:{heatmapY:ie,heatmapX:me,id:ge}})}return re}(i,1,c),x=a*a;g.length<o&&!y.empty();)w=y.dequeue(),S=JF(w.part,s,d),e4(g,x,S,w.part.id)||($=s3e(w,c,d,s,f,p),I=o3e(g,x,$),g.push({keypoints:$,score:I}));return[2,g]}})})}function n4(){for(var t,e=[],n=0;n<arguments.length;n++)e[n]=arguments[n];switch(e.length){case 0:t="fn main() ";break;case 1:t="fn main(".concat(e[0]," : i32)");break;default:throw Error("Unreachable")}return t}var a3e=function(){function t(e){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[e[0],1],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return t.prototype.getUserCode=function(){return`
        `.concat(n4("index"),` {
          if (index < uniforms.size) {
            let y = B[index * 2];
            let x = B[index * 2 + 1];
            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;
            result[index] = A[outIndex];
          }
        }
        `)},t}();function l3e(t,e){if(ud()instanceof Od)return function(n,r){var s=ud(),o=new a3e(r.shape),i=s.runWebGPUProgram(o,[n,r],"float32");return ds().makeTensorFromTensorInfo(i)}(t,e);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}var u3e=function(){function t(e){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,e.length!==2||e[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(e));this.workgroupSize=[32,1,1],this.outputShape=e;var n=[e[0],1];this.dispatchLayout=De(n),this.dispatch=Re(this.dispatchLayout,n,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return t.prototype.getUserCode=function(){return`
    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {
      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;
      let outIndexX = outIndexY + uniforms.bShape.z;
      let outY = i32(B[outIndexY]);
      let outX = i32(B[outIndexX]);
      return vec2<i32>(outY, outX);
    }

    `.concat(n4("index"),` {
      if (index < uniforms.size) {
        let indexY = index * `).concat(this.supportedLastDimension,`;
        let indexX = indexY + 1;
        let heatmapY = A[indexY];
        let heatmapX = A[indexX];
        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);
        result[indexY] = f32(out[0]);
        result[indexX] = f32(out[1]);
      }
    }
    `)},t}();function c3e(t,e){if(ud()instanceof Od)return function(n,r){var s=ud(),o=new u3e(n.shape),i=s.runWebGPUProgram(o,[n,r],"float32");return ds().makeTensorFromTensorInfo(i)}(t,e);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}function r4(t){var e=t.shape,n=e[0],r=e[1],s=e[2];return nt(function(){var o,i,a=ye(t,[n*r,s]),l=qA(a,0),c=Rs(gt(l,mt(r,"int32")),1),d=Rs((o=l,i=r,nt(function(){var f=gt(o,mt(i,"int32"));return ot(o,Te(f,mt(i,"int32")))})),1);return Fn([c,d],1)})}function d3e(t,e,n){return nt(function(){var r=function(s,o){for(var i=[],a=0;a<$i.length;a++){var l=s.get(a,0).valueOf(),c=s.get(a,1).valueOf(),d=h3e(l,c,a,o),f=d.x,p=d.y;i.push(p),i.push(f)}return lo(i,[$i.length,2])}(t,n);return We(Qt(Te(t.toTensor(),mt(e,"int32")),"float32"),r)})}function h3e(t,e,n,r){return{y:r.get(t,e,n),x:r.get(t,e,n+$i.length)}}function f3e(t,e,n){return bt(this,void 0,void 0,function(){var r,s,o,i,a,l,c,d,f,p;return wt(this,function(g){switch(g.label){case 0:return r=0,s=r4(t),[4,Promise.all([t.buffer(),e.buffer(),s.buffer()])];case 1:return o=g.sent(),i=o[0],a=o[1],l=o[2],[4,(c=d3e(l,n,a)).buffer()];case 2:return d=g.sent(),f=Array.from(function(y,x){for(var w=x.shape[0],S=new Float32Array(w),$=0;$<w;$++){var I=x.get($,0),R=x.get($,1);S[$]=y.get(I,R,$)}return S}(i,l)),p=f.map(function(y,x){return r+=y,{y:d.get(x,0),x:d.get(x,1),score:y,name:$i[x]}}),s.dispose(),c.dispose(),[2,{keypoints:p,score:r/p.length}]}})})}function p3e(t,e,n){return bt(this,void 0,void 0,function(){var r,s,o;return wt(this,function(i){return r=r4(t),s=function(a,l,c){return nt(function(){var d=c3e(a,c);return We(Qt(Te(a,mt(l,"int32")),"float32"),d)})}(r,n,e),o=l3e(t,r),[2,[s,o]]})})}function dE(t,e){return(t-1)%e==0}var hE="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",fE="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function pE(t,e){return function(n,r){return(n-1)%r==0}(t,e)?t:Math.floor(t/e)*e+1}var mE=function(){function t(e,n){this.posenetModel=e;var r=this.posenetModel.inputs[0].shape;z(r[1]===-1&&r[2]===-1,function(){return"Input shape [".concat(r[1],", ").concat(r[2],"] ")+"must both be equal to or -1"});var s,o,i=(s=n.inputResolution,o=n.outputStride,{height:pE(s.height,o),width:pE(s.width,o)});(function(a){z(Zke.indexOf(a)>=0,function(){return"outputStride of ".concat(a," is invalid. ")+"It must be either 8 or 16."})})(n.outputStride),function(a,l){z(dE(a.height,l),function(){return"height of ".concat(a.height," is invalid for output stride ")+"".concat(l,".")}),z(dE(a.width,l),function(){return"width of ".concat(a.width," is invalid for output stride ")+"".concat(l,".")})}(i,n.outputStride),this.inputResolution=i,this.outputStride=n.outputStride,this.architecture=n.architecture}return t.prototype.estimatePoses=function(e,n){return n===void 0&&(n=oE),bt(this,void 0,void 0,function(){return wt(this,function(r){return[2,this.estimatePosesGPU(e,n,!1)]})})},t.prototype.estimatePosesGPU=function(e,n,r){return n===void 0&&(n=oE),r===void 0&&(r=!1),bt(this,void 0,void 0,function(){var s,o,i,a,l,c,d,f,p,g,y,x,w,S,$,I,R,_;return wt(this,function(O){switch(O.label){case 0:return s=function(F){var B=F;if(B.maxPoses==null&&(B.maxPoses=1),B.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(B.maxPoses,". Should be > 0."));if(B.maxPoses>1){if((B=Yt(Yt({},Jke),B)).scoreThreshold<0||B.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(B.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(B.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(B.nmsRadius,"."))}return B}(n),e==null?[2,r?[[],[]]:[]]:(this.maxPoses=s.maxPoses,o=Bv(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),i=o.imageTensor,a=o.padding,l=this.architecture==="ResNet50"?We(i,e3e):KF(i,[-1,1]),c=this.posenetModel.predict(l),this.architecture==="ResNet50"?(d=Gt(c[2],[0]),f=Gt(c[3],[0]),p=Gt(c[0],[0]),g=Gt(c[1],[0])):(d=Gt(c[0],[0]),f=Gt(c[1],[0]),p=Gt(c[2],[0]),g=Gt(c[3],[0])),y=aa(f),this.maxPoses!==1?[3,5]:r?[4,p3e(y,d,this.outputStride)]:[3,2]);case 1:return w=O.sent(),$=w[0],S=w[1],x=[$,S],[3,4];case 2:return[4,f3e(y,d,this.outputStride)];case 3:$=O.sent(),x=[$],O.label=4;case 4:return[3,7];case 5:if(r)throw new Error("GPU renderer only supports single pose!");return[4,i3e(y,d,p,g,this.outputStride,this.maxPoses,s.scoreThreshold,s.nmsRadius)];case 6:x=O.sent(),O.label=7;case 7:if(r){if(s.flipHorizontal===!0)throw new Error("flipHorizontal is not supported!");I=this.getCanvasInfo(md(e),this.inputResolution,a)}else _=md(e),R=function(F,B,M,V){var P=B.height,re=B.width,ie=P/(M.height*(1-V.top-V.bottom)),me=re/(M.width*(1-V.left-V.right)),ge=-V.top*M.height,ve=-V.left*M.width;if(me===1&&ie===1&&ge===0&&ve===0)return F;for(var $e=0,fe=F;$e<fe.length;$e++)for(var xe=0,ae=fe[$e].keypoints;xe<ae.length;xe++){var q=ae[xe];q.x=(q.x+ve)*me,q.y=(q.y+ge)*ie}return F}(x,_,this.inputResolution,a),s.flipHorizontal&&(R=function(F,B){for(var M=0,V=F;M<V.length;M++)for(var P=0,re=V[M].keypoints;P<re.length;P++){var ie=re[P];ie.x=B.width-1-ie.x}return F}(R,_));return i.dispose(),l.dispose(),Mt(c),d.dispose(),f.dispose(),p.dispose(),g.dispose(),y.dispose(),[2,r?[x,I]:R]}})})},t.prototype.getCanvasInfo=function(e,n,r){var s=e.height,o=e.width,i=s/(n.height*(1-r.top-r.bottom)),a=o/(n.width*(1-r.left-r.right)),l=-r.top*n.height;return[-r.left*n.width,l,a,i,e.width,e.height]},t.prototype.dispose=function(){this.posenetModel.dispose()},t.prototype.reset=function(){},t}();function m3e(t){return t===void 0&&(t=eE),bt(this,void 0,void 0,function(){var e,n,r,s,o;return wt(this,function(i){switch(i.label){case 0:return(e=function(d){var f=d||eE;if(f.architecture==null&&(f.architecture="MobileNetV1"),tE.indexOf(f.architecture)<0)throw new Error("Invalid architecture ".concat(f.architecture,". ")+"Should be one of ".concat(tE));if(f.inputResolution==null&&(f.inputResolution={height:257,width:257}),f.outputStride==null&&(f.outputStride=16),nE[f.architecture].indexOf(f.outputStride)<0)throw new Error("Invalid outputStride ".concat(f.outputStride,". ")+"Should be one of ".concat(nE[f.architecture]," ")+"for architecture ".concat(f.architecture,"."));if(f.multiplier==null&&(f.multiplier=1),rE[f.architecture].indexOf(f.multiplier)<0)throw new Error("Invalid multiplier ".concat(f.multiplier,". ")+"Should be one of ".concat(rE[f.architecture]," ")+"for architecture ".concat(f.architecture,"."));if(f.quantBytes==null&&(f.quantBytes=4),sE.indexOf(f.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(f.quantBytes,". ")+"Should be one of ".concat(sE," ")+"for architecture ".concat(f.architecture,"."));if(f.architecture==="MobileNetV1"&&f.outputStride===32&&f.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return f}(t)).architecture!=="ResNet50"?[3,2]:(a=e.outputStride,l=e.quantBytes,c="model-stride".concat(a,".json"),n=l===4?fE+"float/"+c:fE+"quant".concat(l,"/")+c,[4,fd(e.modelUrl||n)]);case 1:return r=i.sent(),[2,new mE(r,e)];case 2:return s=function(d,f,p){var g={1:"100",.75:"075",.5:"050"},y="model-stride".concat(d,".json");return p===4?hE+"float/".concat(g[f],"/")+y:hE+"quant".concat(p,"/").concat(g[f],"/")+y}(e.outputStride,e.multiplier,e.quantBytes),[4,fd(e.modelUrl||s)];case 3:return o=i.sent(),[2,new mE(o,e)]}var a,l,c})})}function g3e(t,e){return bt(this,void 0,void 0,function(){var n,r;return wt(this,function(s){switch(t){case wi.PoseNet:return[2,m3e(e)];case wi.BlazePose:if(r=void 0,(n=e)!=null){if(n.runtime==="tfjs")return[2,jke(e)];if(n.runtime==="mediapipe")return[2,gke(e)];r=n.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(r));case wi.MoveNet:return[2,Qke(e)];default:throw new Error("".concat(t," is not a supported model name."))}})})}var y3e={modelType:{SINGLEPOSE_LIGHTNING:"SinglePose.Lightning"}};const gE={140:{Waist:[28.5,29.1,28.8,29.5,28.2,29,28.6,29.3,28.9],Hip:[34,34.8,34.2,35.1,33.8,34.5,34.1,34.9,34.6],Thigh:[16.8,17.3,17,17.5,16.6,17.1,16.9,17.4,17.2],BustChest:[30.5,31.2,30.8,31.5,30.2,31,30.6,31.3,30.9]},141:{Waist:[28.6,29.2,28.9,29.6,28.3,29.1,28.7,29.4,29],Hip:[34.2,34.9,34.3,35.2,33.9,34.6,34.2,35,34.7],Thigh:[16.9,17.4,17.1,17.6,16.7,17.2,17,17.5,17.3],BustChest:[30.7,31.4,31,31.7,30.4,31.2,30.8,31.5,31.1]},142:{Waist:[28.7,29.3,29,29.7,28.4,29.2,28.8,29.5,29.1],Hip:[34.4,35.1,34.5,35.4,34.1,34.8,34.4,35.2,34.9],Thigh:[17,17.5,17.2,17.7,16.8,17.3,17.1,17.6,17.4],BustChest:[30.9,31.6,31.2,31.9,30.6,31.4,31,31.7,31.3]},143:{Waist:[28.8,29.4,29.1,29.8,28.5,29.3,28.9,29.6,29.2],Hip:[34.6,35.3,34.7,35.6,34.3,35,34.6,35.4,35.1],Thigh:[17.1,17.6,17.3,17.8,16.9,17.4,17.2,17.7,17.5],BustChest:[31.1,31.8,31.4,32.1,30.8,31.6,31.2,31.9,31.5]},144:{Waist:[28.9,29.5,29.2,29.9,28.6,29.4,29,29.7,29.3],Hip:[34.8,35.5,34.9,35.8,34.5,35.2,34.8,35.6,35.3],Thigh:[17.2,17.7,17.4,17.9,17,17.5,17.3,17.8,17.6],BustChest:[31.3,32,31.6,32.3,31,31.8,31.4,32.1,31.7]},145:{Waist:[29,29.6,29.3,30,28.7,29.5,29.1,29.8,29.4],Hip:[35,35.7,35.1,36,34.7,35.4,35,35.8,35.5],Thigh:[17.3,17.8,17.5,18,17.1,17.6,17.4,17.9,17.7],BustChest:[31.5,32.2,31.8,32.5,31.2,32,31.6,32.3,31.9]},146:{Waist:[29.1,29.7,29.4,30.1,28.8,29.6,29.2,29.9,29.5],Hip:[35.2,35.9,35.3,36.2,34.9,35.6,35.2,36,35.7],Thigh:[17.4,17.9,17.6,18.1,17.2,17.7,17.5,18,17.8],BustChest:[31.7,32.4,32,32.7,31.4,32.2,31.8,32.5,32.1]},147:{Waist:[29.2,29.8,29.5,30.2,28.9,29.7,29.3,30,29.6],Hip:[35.4,36.1,35.5,36.4,35.1,35.8,35.4,36.2,35.9],Thigh:[17.5,18,17.7,18.2,17.3,17.8,17.6,18.1,17.9],BustChest:[31.9,32.6,32.2,32.9,31.6,32.4,32,32.7,32.3]},148:{Waist:[29.3,29.9,29.6,30.3,29,29.8,29.4,30.1,29.7],Hip:[35.6,36.3,35.7,36.6,35.3,36,35.6,36.4,36.1],Thigh:[17.6,18.1,17.8,18.3,17.4,17.9,17.7,18.2,18],BustChest:[32.1,32.8,32.4,33.1,31.8,32.6,32.2,32.9,32.5]},149:{Waist:[31,31.693,30.802,31.783,30.546,30.458,31.055,30.823,31.271],Hip:[37.25,38.33,36.987,37.832,36.539,37.649,37.091,36.383,37.783],Thigh:[17.5,17.198,17.705,17.627,17.495,17.33,17.32,18.004,17.916],BustChest:[23.125,22.921,22.521,23.637,23.023,23.599,23.288,22.987,22.981]},150:{Waist:[31,31.121,30.532,31.645,30.132,31.419,30.145,30.329,30.759],Hip:[37.25,36.844,36.542,36.64,38.337,37.214,36.226,37.397,36.23],Thigh:[17.5,17.117,17.359,17.154,17.208,17.42,17.27,17.79,17.277],BustChest:[23.125,23.675,23.66,23.677,22.452,22.888,23.38,23.744,23.069]},151:{Waist:[31,31.645,30.779,31.902,31.206,30.528,30.371,30.665,31.302],Hip:[37.25,37.477,37.749,38.36,37.803,38.261,37.028,36.542,37.372],Thigh:[17.5,17.173,17.963,17.257,17.948,17.195,17.719,17.625,17.592],BustChest:[23.125,23.131,22.849,22.848,23.731,22.972,23.548,23.54,23.017]},152:{Waist:[31,30.156,31.062,31.233,30.653,31.607,31.305,30.529,30.696],Hip:[37.25,37.156,37.175,36.281,37.545,36.526,36.424,37.849,37.111],Thigh:[17.5,17.051,17.149,17.936,17.148,17.611,17.897,18.015,17.975],BustChest:[23.125,22.62,22.502,23.26,22.985,22.636,23.712,22.498,23.706]},153:{Waist:[31,31.815,30.445,30.773,30.147,31.541,31.464,31.303,30.439],Hip:[37.25,38.055,37.488,37.973,38.086,37.169,37.226,37.611,37.466],Thigh:[17.5,16.978,17.689,17.077,17.011,17.983,17.946,17.042,17.47],BustChest:[23.125,23.735,23.256,23.117,23.689,23.409,22.855,23.592,23.805]},154:{Waist:[31,31.722,30.52,31.578,31.61,30.7,30.308,30.793,31.611],Hip:[37.25,37.179,36.924,37.781,38.207,38.358,36.659,38.015,38.087],Thigh:[17.5,17.965,17.91,17.093,17.917,17.687,17.28,17.32,17.786],BustChest:[23.125,23.027,23.44,23.275,22.833,23.617,23.528,22.957,23.569]},155:{Waist:[31,30.876,30.896,30.226,30.898,31.137,31.634,30.757,30.438],Hip:[37.25,37.333,37.687,36.634,36.218,36.901,37.263,38.114,36.336],Thigh:[17.5,17.617,17.402,17.231,17.842,17.795,17.84,17.471,17.785],BustChest:[23.125,22.602,22.822,23.27,22.592,23.358,23.411,23.195,23.127]},156:{Waist:[31.25,31.811,30.321,31.136,31.352,30.821,31.04,30.68,30.916],Hip:[36.75,35.803,36.514,36.156,36.801,37.422,37.484,36.855,37.418],Thigh:[19.5,19.167,19.639,19.685,19.452,19.37,19.856,19.245,19.591],BustChest:[29.563,29.663,29.924,29.937,29.371,29.021,29.333,30.222,29.45]},157:{Waist:[31.5,32.415,30.657,30.718,32.219,31.557,32.245,31.411,31.634],Hip:[36.25,35.909,36.318,35.448,37.213,36.386,35.426,36.014,36.209],Thigh:[21.5,21.441,21.249,21.562,22.054,21.266,21.607,20.99,21.48],BustChest:[36,35.203,35.448,35.376,36.569,35.245,35.64,36.086,35.64]},158:{Waist:[30.75,30.018,30.725,29.985,30.974,31.477,30.128,30.458,31.345],Hip:[38.125,37.532,37.786,37.373,37.236,38.082,38.768,37.938,39.218],Thigh:[21.813,21.649,21.642,22.019,21.37,21.504,21.78,21.601,22.435],BustChest:[36,36.785,36.3,36.856,35.079,36.531,36.073,35.495,35.06]},159:{Waist:[30,30.782,30.689,30.574,30.384,30.899,29.462,30.091,30.881],Hip:[40,39.728,39.22,39.866,40.549,39.915,40.817,40.5,41.012],Thigh:[22.125,21.974,21.607,22.377,21.466,22.305,22.776,22.425,21.838],BustChest:[36,35.29,35.163,36.482,36.187,35.287,35.145,35.412,35.537]},160:{Waist:[29.375,29.104,30.044,29.931,28.573,29.45,28.967,29.974,29.584],Hip:[39.167,40.156,40.187,38.769,39.369,38.6,39.15,38.885,38.857],Thigh:[21.875,21.811,22.057,21.529,22.506,21.621,21.732,21.323,21.765],BustChest:[35.708,35.924,35.456,35.612,35.49,36.122,35.816,34.854,36.379]},161:{Waist:[28.75,28.966,29.236,29.4,28.628,27.986,29.3,29.075,29.321],Hip:[38.333,39.319,39.436,37.755,39.145,38.074,37.692,37.879,39.345],Thigh:[21.625,21.971,21.25,21.532,21.298,21.912,22.104,21.308,21.733],BustChest:[35.417,34.805,35.396,35.026,36.264,35.776,35.841,35.13,35.579]},162:{Waist:[28.125,28.144,28.377,27.539,28.962,27.872,28.435,27.355,27.286],Hip:[37.5,37.306,38.1,38.483,38.521,37.745,37.046,37.01,37.385],Thigh:[21.375,21.823,21.906,20.741,21.862,21.367,21.391,21.53,21.877],BustChest:[35.125,35.735,35.839,35.986,35.453,36.027,35.184,34.171,35.685]},163:{Waist:[36,36.231,35.344,35.85,36.578,35.209,34.993,35.834,35.203],Hip:[42.75,42.673,43.865,43.409,43.499,42.553,41.917,41.617,43.553],Thigh:[24.125,23.767,24.181,23.876,23.986,24.039,23.437,24.537,23.941],BustChest:[40,39.88,39.278,40.397,39.096,41.07,39.877,40.846,40.838]},164:{Waist:[31,30.747,31.519,30.758,31.2,31.146,31.344,31.913,30.363],Hip:[37.875,37.268,37.229,38.98,37.391,38.63,37.037,38.519,37.145],Thigh:[20.563,20.481,20.616,20.108,20.862,20.846,20.496,20.744,20.023],BustChest:[36.5,36.786,37.317,37.514,36.002,37.413,37.194,35.951,36.961]},165:{Waist:[26,25.472,25.25,26.41,25.411,25.236,25.532,25.344,25.524],Hip:[33,33.972,32.74,32.091,33.468,32.591,33.792,32.502,32.303],Thigh:[17,16.546,17.168,17.326,17.387,16.692,16.886,16.94,16.903],BustChest:[33,32.997,32.66,33.419,33.066,33.403,32.796,32.844,33.005]},166:{Waist:[26.05,26.183,26.128,26.198,25.418,26.605,26.172,26.459,26.203],Hip:[33.2,32.843,32.37,32.236,32.735,33.579,32.385,33.371,32.284],Thigh:[17.15,17.217,16.956,17.338,17.521,17.462,16.793,16.973,17.369],BustChest:[32.8,33.494,33.6,31.865,32.107,32.744,32.194,32.308,32.755]},167:{Waist:[26.1,26.255,25.43,26.483,25.913,25.412,25.899,26.605,25.849],Hip:[33.4,32.922,34.17,33.484,32.435,32.719,33.093,34.246,34.246],Thigh:[17.3,16.914,17.813,17.236,17.432,17.027,17.27,17.568,17.547],BustChest:[32.6,32.427,33.289,32.834,33.183,33.4,33.191,32.818,31.808]},168:{Waist:[26.15,26.24,26.267,26.27,26.6,26.078,25.603,25.655,26.741],Hip:[33.6,33.094,33.058,32.658,34.567,33.705,33.591,33.472,34.202],Thigh:[17.45,17.143,17.733,17.606,17.673,16.932,17.137,17.789,17.608],BustChest:[32.4,31.787,32.937,32.551,32.256,33.216,32.082,33.156,32.986]},169:{Waist:[26.2,25.858,26.133,25.804,26.35,26.811,26.287,25.625,26.923],Hip:[33.8,32.97,34.087,34.407,33.415,34.454,33.477,34.02,33.115],Thigh:[17.6,17.806,17.442,17.407,17.998,17.859,17.752,17.247,17.232],BustChest:[32.2,32.49,31.499,32.739,32.139,31.782,32.306,31.931,31.365]},170:{Waist:[26.25,26.364,26.849,26.494,26.511,26.295,26.892,25.821,25.854],Hip:[34,33.738,33.991,33.495,33.955,33.002,33.63,34.973,33.97],Thigh:[17.75,18.014,17.225,17.242,18.238,18.229,17.457,17.881,18.015],BustChest:[32,31.537,31.641,32.443,32.389,32.83,32.293,31.258,31.655]},171:{Waist:[26.3,25.575,26.282,25.97,26.109,26.498,25.667,26.863,26.08],Hip:[34.2,34.081,33.767,33.482,35.043,33.837,33.791,33.795,33.302],Thigh:[17.9,18.344,17.877,18.018,18.096,17.394,17.741,17.684,18.112],BustChest:[31.8,31.425,31.012,32.165,31.122,32.442,30.974,32.151,32.221]},172:{Waist:[26.35,26.526,25.611,26.819,27.039,26.221,26.319,25.782,26.132],Hip:[34.4,35.354,34.479,35.27,35.221,35.098,35.349,34.305,34.345],Thigh:[18.05,18.153,17.607,17.652,18.246,17.609,17.994,18.41,18.034],BustChest:[31.6,30.786,32.169,30.745,32.485,30.926,32.466,32.371,30.783]},173:{Waist:[26.4,26.998,26.71,26.871,27.094,27.107,27.051,26.892,26.078],Hip:[34.6,33.991,33.941,34.246,33.739,34.646,33.663,34.123,35.442],Thigh:[18.2,18.694,18.676,18.62,18.098,18.535,17.759,18.511,18.36],BustChest:[31.4,31.813,32.135,32.155,31.042,32.248,32.238,31.648,30.856]},174:{Waist:[26.45,26.248,26.981,26.091,25.989,26.43,26.223,26.784,26.91],Hip:[34.8,35.297,33.939,35.097,34.229,34.455,35.418,35.501,35.647],Thigh:[18.35,17.824,18.754,18.744,18.736,18.364,17.976,18.499,18.848],BustChest:[31.2,31.581,30.432,30.495,31.892,30.666,31.986,31.733,31.98]},175:{Waist:[26.5,26.577,26.041,25.889,26.282,26.347,26.209,27.149,27.164],Hip:[35,34.038,35.22,35.264,35.431,36.003,35.855,33.997,34.69],Thigh:[18.5,18.737,18.238,18.413,18.786,18.968,18.328,18.499,18.827],BustChest:[31,31.127,30.727,31.923,31.034,30.458,30.824,30.564,30.566]},176:{Waist:[26.5,26.346,25.82,25.928,26.822,26.954,27.187,26.979,26.124],Hip:[35.5,36.535,35.557,34.934,36.219,35.766,36.309,34.446,36.083],Thigh:[18,17.815,18.047,18.27,18.462,18.519,17.635,18.271,17.907],BustChest:[32.5,32.338,32.156,33.432,33.265,32.958,31.8,33.309,32.395]},177:{Waist:[26.5,26.18,25.937,26.382,26.986,26.612,27.069,26.361,26.003],Hip:[35.5,35.074,35.863,35.162,35.264,35.947,34.535,34.495,35.847],Thigh:[18,17.599,18.259,18.028,17.494,17.674,17.558,18.204,18.126],BustChest:[32.5,32.63,33.184,33.137,32.581,33.055,31.723,32.025,32.801]},178:{Waist:[26.5,27.126,26.325,27.162,26.742,26.206,26.814,26.926,26.471],Hip:[35.5,35.596,34.894,35.013,34.846,36.215,36.005,35.913,36.382],Thigh:[18,17.697,18.482,17.832,17.584,17.56,18.256,18.189,18.317],BustChest:[32.5,31.989,32.088,31.544,32.996,32.016,31.973,31.909,31.577]},179:{Waist:[26.5,27.047,25.949,26.43,26.783,26.518,26.076,26.163,26.017],Hip:[35.5,36.122,35.782,35.145,35.667,35.072,36.343,35.315,36.106],Thigh:[18,17.716,17.514,18.401,18.261,18.387,18.507,17.541,17.738],BustChest:[32.5,33.314,33.242,32.577,31.671,33.214,32.688,32.494,31.77]},180:{Waist:[26.5,26.514,26.619,27.101,27.163,27.112,26.212,27.218,27.234],Hip:[35.5,36.12,34.698,36.204,34.916,35.211,34.9,34.696,36.503],Thigh:[18,17.817,18.027,17.885,17.809,17.974,18.05,17.548,17.881],BustChest:[32.5,32.837,32.796,32.71,31.955,32.628,31.977,33.234,32.219]}},Ns={NOSE:0,LEFT_SHOULDER:5,RIGHT_SHOULDER:6,LEFT_HIP:11,RIGHT_HIP:12,LEFT_KNEE:13,RIGHT_KNEE:14,LEFT_ANKLE:15,RIGHT_ANKLE:16},yE=[Ns.NOSE,Ns.LEFT_SHOULDER,Ns.RIGHT_SHOULDER,Ns.LEFT_HIP,Ns.RIGHT_HIP,Ns.LEFT_KNEE,Ns.RIGHT_KNEE,Ns.LEFT_ANKLE,Ns.RIGHT_ANKLE],x3e=.3,xE=5,v3e=1500;function b3e({onNavigate:t}){const e=J.useRef(null),n=J.useRef(null),r=J.useRef(null),s=J.useRef(null),o=J.useRef(null),[i,a]=J.useState(!0),[l,c]=J.useState(null),[d,f]=J.useState(null),[p,g]=J.useState(!1),[y,x]=J.useState(!1),[w,S]=J.useState("Initializing camera..."),[$,I]=J.useState("INITIALIZING"),[R,_]=J.useState(!1),[O,F]=J.useState(null),B=LP(),[M,V]=J.useState(null),P=J.useCallback(()=>{s.current&&(clearInterval(s.current),s.current=null,console.log("Countdown interval cleared.")),o.current&&(clearTimeout(o.current),o.current=null,console.log("Pre-countdown timeout cleared.")),F(null)},[]),re=J.useCallback(async()=>{a(!0),c(null),S("Requesting camera access..."),I("INITIALIZING"),_(!1),P(),f(ae=>(ae&&(ae.getTracks().forEach(q=>q.stop()),console.log("Stopped previous stream inside requestCamera.")),null));try{console.log("Requesting getUserMedia...");const ae=await navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"},audio:!1});console.log("getUserMedia successful."),f(ae)}catch(ae){console.error("Error accessing camera:",ae);let q="Could not access camera. Please ensure permission is granted.";ae.name==="NotAllowedError"?q="Camera permission denied.":ae.name==="NotFoundError"||ae.name==="DevicesNotFoundError"?q="No suitable camera found.":ae.name==="NotReadableError"||ae.name==="TrackStartError"?q="Camera is already in use.":ae instanceof TypeError&&ae.message.includes("getUserMedia")?q="Camera requires secure connection (HTTPS).":q=`Unexpected camera error: ${ae.message}`,c(q),S("Error initializing camera."),a(!1),I("ERROR")}},[P]);J.useEffect(()=>(re(),()=>{console.log("Cleanup: Unmounting, stopping stream"),f(ae=>(ae&&ae.getTracks().forEach(q=>q.stop()),null)),cancelAnimationFrame(n.current),P(),r.current&&(r.current.dispose(),r.current=null)}),[re,P]);const ie=J.useCallback(ae=>{ae!==null?(console.log("Video element mounted."),e.current=ae,g(!0)):(console.log("Video element unmounted."),g(!1),e.current=null)},[]),me=J.useCallback(async()=>{if(!(r.current||l||$==="ERROR"||y)){x(!0),S("Loading pose detection model..."),console.log("Loading MoveNet model...");try{await LX("webgl"),await zX();const ae=wi.MoveNet,ue={modelType:y3e.modelType.SINGLEPOSE_LIGHTNING,modelUrl:"https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4"},we=await g3e(ae,ue);r.current=we,console.log("MoveNet model loaded successfully."),x(!1),S("Model loaded. Position for FRONT pose."),I("DETECTING_FRONT")}catch(ae){console.error("Error loading pose model:",ae),ae instanceof TypeError&&ae.message.includes("fetch")?c("Failed to load pose model due to network/CORS issue."):c("Failed to load pose detection model."),S("Error loading model."),x(!1),I("ERROR")}}},[l,$,y]);J.useEffect(()=>{d&&p&&e.current&&!r.current&&!y&&(console.log("Attaching stream to video element."),e.current.srcObject=d,e.current.onloadedmetadata=()=>{console.log("Video metadata loaded."),a(!1),S("Camera ready. Prepare for FRONT pose."),I("FRONT_PROMPT"),me()},e.current.onerror=ae=>{console.error("Video element error:",ae),c("Video display error."),I("ERROR")})},[d,p,me,y]);const ge=J.useCallback(()=>{console.log("Processing results..."),cancelAnimationFrame(n.current),P();const ae=localStorage.getItem("userHeight");if(!ae){console.error("Height not found in storage!"),B({title:"Error",description:"Could not retrieve height.",status:"error",duration:3e3,isClosable:!0}),t("HEIGHT_INPUT");return}const q=ae;let ue={height:ae};if(gE[q]){const we=gE[q];for(const Ge in we){const et=we[Ge];if(et&&et.length>0){const tt=Math.floor(Math.random()*et.length);ue[Ge]=parseFloat(et[tt].toFixed(2))}else ue[Ge]="N/A"}}else console.warn(`No measurement data found for height: ${q}`),ue.Waist="N/A",ue.Hip="N/A",ue.Thigh="N/A",ue.BustChest="N/A";console.log("Generated results:",ue),B({title:"Success!",description:"Poses captured successfully!",status:"success",duration:2e3,isClosable:!0}),setTimeout(()=>t("RESULTS",ue),1500)},[t,B,P]),ve=J.useCallback(ae=>{o.current&&(clearTimeout(o.current),o.current=null),P(),F(xE),S(`Hold Pose: ${xE}`),s.current=setInterval(()=>{F(q=>{if(q===null)return P(),null;const ue=q-1;return ue>0?(S(`Hold Pose: ${ue}`),ue):(P(),console.log(`${$==="DETECTING_FRONT"?"FRONT":"SIDE"} POSE CONFIRMED`),ae==="SIDE_PROMPT"?S("Front pose captured! Prepare for SIDE pose."):(S("Side pose captured! Processing..."),ge()),I(ae),_(!1),null)})},1e3)},[P,ge,$]),$e=J.useCallback(ae=>{if(O!==null||o.current!==null)return;const q=_r=>{_(!1),P(),S(_r)};if(!ae||ae.length===0){S(_r=>{const Vo="No person detected. Ensure you are fully visible.";return _r!==Vo&&q(Vo),Vo});return}_(!1);const we=ae[0].keypoints;let Ge=0;for(const _r of yE)we[_r]&&we[_r].score>x3e&&Ge++;if(Ge<yE.length){q("Full body not visible or low confidence. Adjust position.");return}const et=we[Ns.LEFT_SHOULDER],tt=we[Ns.RIGHT_SHOULDER],Tt=we[Ns.LEFT_HIP],dt=we[Ns.RIGHT_HIP];if(!et||!tt||!Tt||!dt){q("Cannot determine orientation. Adjust position.");return}const vt=Math.abs(et.x-tt.x),rn=Math.abs(Tt.x-dt.x);console.log(`ShoulderW: ${vt.toFixed(1)}, HipW: ${rn.toFixed(1)}`);const Rr=vt>rn*.8&&vt>50,ki=vt<rn*.7||vt<50;let zt=!1,sn="";$==="DETECTING_FRONT"?(zt=Rr,sn="Please face the camera directly."):$==="DETECTING_SIDE"&&(zt=ki,sn="Please turn 90 degrees (side view)."),zt?R||(console.log("Valid pose detected, starting pre-countdown delay..."),_(!0),S("Good Pose! Hold Still..."),o.current=setTimeout(()=>{console.log("Pre-countdown finished, starting main countdown."),o.current=null,ve($==="DETECTING_FRONT"?"SIDE_PROMPT":"DONE")},v3e)):q(sn||"Detecting pose...")},[$,O,R,ve,P]),fe=J.useCallback(async()=>{if(($==="DETECTING_FRONT"||$==="DETECTING_SIDE")&&O===null&&o.current===null&&r.current&&e.current&&e.current.readyState>=2)try{const ae=await r.current.estimatePoses(e.current,{maxPoses:1,flipHorizontal:!1});$e(ae)}catch(ae){console.error("Error during pose estimation:",ae)}n.current=requestAnimationFrame(fe)},[$,$e,O]);J.useEffect(()=>(r.current&&e.current&&!i&&!y&&$!=="ERROR"&&$!=="DONE"?(console.log(`Starting/Managing detection loop for stage: ${$}`),cancelAnimationFrame(n.current),n.current=requestAnimationFrame(fe)):cancelAnimationFrame(n.current),()=>{cancelAnimationFrame(n.current)}),[$,fe,i,y]),J.useEffect(()=>{let ae=null;return $==="SIDE_PROMPT"&&(console.log("In SIDE_PROMPT stage, waiting before detection..."),cancelAnimationFrame(n.current),ae=setTimeout(()=>{console.log("SIDE_PROMPT timeout finished, moving to DETECTING_SIDE."),I("DETECTING_SIDE")},1500)),()=>clearTimeout(ae)},[$]);const xe=J.useCallback(()=>{console.log("Retake requested"),cancelAnimationFrame(n.current),P(),_(!1),c(null),r.current&&(r.current.dispose(),r.current=null),x(!1),re()},[re,P]);return K.jsx(jf,{maxW:"container.xl",py:4,children:K.jsxs(ia,{spacing:4,w:"100%",children:[K.jsx(Sd,{size:"lg",children:"Pose Capture"}),(i||y)&&$!=="ERROR"&&K.jsxs(ia,{children:[K.jsx(Uf,{size:"xl",color:"blue.500"}),K.jsx(wr,{children:w}),y&&K.jsx(RP,{size:"xs",isIndeterminate:!0,width:"80%",mt:2})]}),l&&K.jsxs(Hb,{status:"error",variant:"subtle",flexDirection:"column",alignItems:"center",justifyContent:"center",textAlign:"center",borderRadius:"md",children:[K.jsx(Kb,{boxSize:"40px",mr:0}),K.jsx(wr,{mt:2,children:l})]}),!l&&K.jsxs(Ao,{position:"relative",width:"100%",mx:"auto",bg:"gray.200",borderRadius:"lg",overflow:"hidden",boxShadow:"lg",display:d?"block":"none",children:[K.jsx("video",{ref:ie,autoPlay:!0,playsInline:!0,muted:!0,style:{width:"100%",height:"auto",display:"block"}}),K.jsx(NP,{initialScale:.9,in:O!==null,children:K.jsx(hP,{position:"absolute",top:"50%",left:"50%",transform:"translate(-50%, -50%)",size:"100px",bg:"rgba(46, 204, 113, 0.8)",color:"white",fontSize:"4xl",fontWeight:"bold",zIndex:"20",children:O})}),!i&&d&&K.jsx(wr,{position:"absolute",bottom:{base:"5px",md:"10px"},left:{base:"5px",md:"10px"},right:{base:"5px",md:"10px"},bg:R&&O===null&&o.current===null?"rgba(46, 204, 113, 0.8)":"rgba(0,0,0,0.7)",color:"white",p:{base:1,md:2},borderRadius:"md",fontSize:{base:"sm",md:"lg"},textAlign:"center",zIndex:"10",transition:"background-color 0.3s ease",children:w})]}),$!=="INITIALIZING"&&$!=="ERROR"&&!i&&!y&&K.jsx(bd,{onClick:xe,colorScheme:"orange",size:"lg",mt:4,children:"Retake Poses"})]})})}function w3e({onNavigate:t,results:e}){const[n,r]=J.useState(!0);J.useEffect(()=>{console.log("ResultsPage mounted, starting calculation simulation...");const a=setTimeout(()=>{console.log("Calculation simulation finished."),r(!1)},1500);return()=>clearTimeout(a)},[]);const s=()=>{console.log("Start Over clicked, navigating to HEIGHT_INPUT"),t("HEIGHT_INPUT")},o=a=>{const l=parseFloat(a);return a!=null&&a!=="N/A"&&!isNaN(l)?`${l.toFixed(1)} in`:"N/A"},i={Waist:LK,Hip:WK,Thigh:jK,BustChest:Qx};return K.jsx(jf,{maxW:"container.md",py:{base:8,md:12},children:K.jsxs(ia,{spacing:8,align:"stretch",children:[K.jsx(Sd,{as:"h1",size:"xl",textAlign:"center",color:"teal.600",children:n?"Calculating Measurements...":"Your Estimated Measurements"}),n?K.jsx(pP,{py:10,children:K.jsxs(ia,{spacing:4,children:[K.jsx(Uf,{thickness:"4px",speed:"0.65s",emptyColor:"gray.200",color:"teal.500",size:"xl"}),K.jsx(wr,{fontSize:"lg",color:"gray.500",children:"Analyzing for best results confidence..."})]})}):K.jsx(EP,{in:!n,children:K.jsxs(ia,{spacing:8,align:"stretch",children:[K.jsxs(wr,{textAlign:"center",fontSize:"lg",color:"gray.600",children:["Based on your height of ",(e==null?void 0:e.height)||"N/A"," cm and captured pose."]}),K.jsx(SP,{columns:{base:1,sm:2},spacing:6,children:["Waist","Hip","Thigh","BustChest"].map(a=>K.jsxs(z9,{variant:"outline",size:"lg",textAlign:"center",children:[K.jsxs(M9,{pb:0,children:[" ",K.jsx(wa,{as:i[a]||Qx,w:10,h:10,color:"teal.500"})]}),K.jsx(B9,{children:K.jsxs(DP,{children:[K.jsx(OP,{fontSize:"md",color:"gray.500",mb:1,children:a}),K.jsx(FP,{fontSize:"2xl",children:o(e==null?void 0:e[a])})]})})]},a))}),K.jsx(wr,{textAlign:"center",fontSize:"sm",color:"gray.500",mt:4,children:"Note: These are estimations based on general data and simulated pose capture."}),K.jsx(bd,{colorScheme:"teal",size:"lg",onClick:s,alignSelf:"center",mt:6,leftIcon:K.jsx(DK,{}),children:"Start Over (Enter Height)"})]})})]})})}function S3e(){const t=new Date().getFullYear();return K.jsxs("footer",{className:"app-footer",children:["DMMMSU BSFT ",t]})}function C3e(){const[t,e]=J.useState("LANDING"),[n,r]=J.useState(null),s=(i,a=null)=>{console.log(`Navigating to ${i} with data:`,a),r(a),e(i)};let o;return t==="LANDING"?o=K.jsx(TK,{onNavigate:s}):t==="INSTRUCTIONS"?o=K.jsx(GK,{onNavigate:s}):t==="HEIGHT_INPUT"?o=K.jsx(KK,{onNavigate:s}):t==="CAMERA"?o=K.jsx(b3e,{onNavigate:s}):t==="RESULTS"?o=K.jsx(w3e,{onNavigate:s,results:n}):o=K.jsxs("div",{children:["Unknown View: ",t]}),K.jsxs("div",{className:"app-container",children:[K.jsx("main",{className:"main-content",children:o}),K.jsx(S3e,{})]})}const $3e=Y9();hL.createRoot(document.getElementById("root")).render(K.jsx(sa.StrictMode,{children:K.jsx(P9,{theme:$3e,children:K.jsx(C3e,{})})}));
