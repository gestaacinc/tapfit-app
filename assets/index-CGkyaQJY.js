function zE(t,e){for(var n=0;n<e.length;n++){const r=e[n];if(typeof r!="string"&&!Array.isArray(r)){for(const s in r)if(s!=="default"&&!(s in t)){const o=Object.getOwnPropertyDescriptor(r,s);o&&Object.defineProperty(t,s,o.get?o:{enumerable:!0,get:()=>r[s]})}}}return Object.freeze(Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const i of o.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&r(i)}).observe(document,{childList:!0,subtree:!0});function n(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function r(s){if(s.ep)return;s.ep=!0;const o=n(s);fetch(s.href,o)}})();var Pc=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Af(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}function iL(t){if(Object.prototype.hasOwnProperty.call(t,"__esModule"))return t;var e=t.default;if(typeof e=="function"){var n=function r(){return this instanceof r?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};n.prototype=e.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(t).forEach(function(r){var s=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(n,r,s.get?s:{enumerable:!0,get:function(){return t[r]}})}),n}var t1={exports:{}},ph={},n1={exports:{}},xt={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Gk;function aL(){if(Gk)return xt;Gk=1;var t=Symbol.for("react.element"),e=Symbol.for("react.portal"),n=Symbol.for("react.fragment"),r=Symbol.for("react.strict_mode"),s=Symbol.for("react.profiler"),o=Symbol.for("react.provider"),i=Symbol.for("react.context"),a=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),c=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),f=Symbol.iterator;function p(q){return q===null||typeof q!="object"?null:(q=f&&q[f]||q["@@iterator"],typeof q=="function"?q:null)}var g={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},y=Object.assign,x={};function w(q,ue,we){this.props=q,this.context=ue,this.refs=x,this.updater=we||g}w.prototype.isReactComponent={},w.prototype.setState=function(q,ue){if(typeof q!="object"&&typeof q!="function"&&q!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,q,ue,"setState")},w.prototype.forceUpdate=function(q){this.updater.enqueueForceUpdate(this,q,"forceUpdate")};function S(){}S.prototype=w.prototype;function $(q,ue,we){this.props=q,this.context=ue,this.refs=x,this.updater=we||g}var I=$.prototype=new S;I.constructor=$,y(I,w.prototype),I.isPureReactComponent=!0;var R=Array.isArray,_=Object.prototype.hasOwnProperty,O={current:null},F={key:!0,ref:!0,__self:!0,__source:!0};function B(q,ue,we){var Ge,et={},tt=null,Tt=null;if(ue!=null)for(Ge in ue.ref!==void 0&&(Tt=ue.ref),ue.key!==void 0&&(tt=""+ue.key),ue)_.call(ue,Ge)&&!F.hasOwnProperty(Ge)&&(et[Ge]=ue[Ge]);var dt=arguments.length-2;if(dt===1)et.children=we;else if(1<dt){for(var vt=Array(dt),rn=0;rn<dt;rn++)vt[rn]=arguments[rn+2];et.children=vt}if(q&&q.defaultProps)for(Ge in dt=q.defaultProps,dt)et[Ge]===void 0&&(et[Ge]=dt[Ge]);return{$$typeof:t,type:q,key:tt,ref:Tt,props:et,_owner:O.current}}function M(q,ue){return{$$typeof:t,type:q.type,key:ue,ref:q.ref,props:q.props,_owner:q._owner}}function V(q){return typeof q=="object"&&q!==null&&q.$$typeof===t}function P(q){var ue={"=":"=0",":":"=2"};return"$"+q.replace(/[=:]/g,function(we){return ue[we]})}var re=/\/+/g;function ie(q,ue){return typeof q=="object"&&q!==null&&q.key!=null?P(""+q.key):ue.toString(36)}function me(q,ue,we,Ge,et){var tt=typeof q;(tt==="undefined"||tt==="boolean")&&(q=null);var Tt=!1;if(q===null)Tt=!0;else switch(tt){case"string":case"number":Tt=!0;break;case"object":switch(q.$$typeof){case t:case e:Tt=!0}}if(Tt)return Tt=q,et=et(Tt),q=Ge===""?"."+ie(Tt,0):Ge,R(et)?(we="",q!=null&&(we=q.replace(re,"$&/")+"/"),me(et,ue,we,"",function(rn){return rn})):et!=null&&(V(et)&&(et=M(et,we+(!et.key||Tt&&Tt.key===et.key?"":(""+et.key).replace(re,"$&/")+"/")+q)),ue.push(et)),1;if(Tt=0,Ge=Ge===""?".":Ge+":",R(q))for(var dt=0;dt<q.length;dt++){tt=q[dt];var vt=Ge+ie(tt,dt);Tt+=me(tt,ue,we,vt,et)}else if(vt=p(q),typeof vt=="function")for(q=vt.call(q),dt=0;!(tt=q.next()).done;)tt=tt.value,vt=Ge+ie(tt,dt++),Tt+=me(tt,ue,we,vt,et);else if(tt==="object")throw ue=String(q),Error("Objects are not valid as a React child (found: "+(ue==="[object Object]"?"object with keys {"+Object.keys(q).join(", ")+"}":ue)+"). If you meant to render a collection of children, use an array instead.");return Tt}function ge(q,ue,we){if(q==null)return q;var Ge=[],et=0;return me(q,Ge,"","",function(tt){return ue.call(we,tt,et++)}),Ge}function ve(q){if(q._status===-1){var ue=q._result;ue=ue(),ue.then(function(we){(q._status===0||q._status===-1)&&(q._status=1,q._result=we)},function(we){(q._status===0||q._status===-1)&&(q._status=2,q._result=we)}),q._status===-1&&(q._status=0,q._result=ue)}if(q._status===1)return q._result.default;throw q._result}var $e={current:null},fe={transition:null},xe={ReactCurrentDispatcher:$e,ReactCurrentBatchConfig:fe,ReactCurrentOwner:O};function ae(){throw Error("act(...) is not supported in production builds of React.")}return xt.Children={map:ge,forEach:function(q,ue,we){ge(q,function(){ue.apply(this,arguments)},we)},count:function(q){var ue=0;return ge(q,function(){ue++}),ue},toArray:function(q){return ge(q,function(ue){return ue})||[]},only:function(q){if(!V(q))throw Error("React.Children.only expected to receive a single React element child.");return q}},xt.Component=w,xt.Fragment=n,xt.Profiler=s,xt.PureComponent=$,xt.StrictMode=r,xt.Suspense=l,xt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=xe,xt.act=ae,xt.cloneElement=function(q,ue,we){if(q==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+q+".");var Ge=y({},q.props),et=q.key,tt=q.ref,Tt=q._owner;if(ue!=null){if(ue.ref!==void 0&&(tt=ue.ref,Tt=O.current),ue.key!==void 0&&(et=""+ue.key),q.type&&q.type.defaultProps)var dt=q.type.defaultProps;for(vt in ue)_.call(ue,vt)&&!F.hasOwnProperty(vt)&&(Ge[vt]=ue[vt]===void 0&&dt!==void 0?dt[vt]:ue[vt])}var vt=arguments.length-2;if(vt===1)Ge.children=we;else if(1<vt){dt=Array(vt);for(var rn=0;rn<vt;rn++)dt[rn]=arguments[rn+2];Ge.children=dt}return{$$typeof:t,type:q.type,key:et,ref:tt,props:Ge,_owner:Tt}},xt.createContext=function(q){return q={$$typeof:i,_currentValue:q,_currentValue2:q,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},q.Provider={$$typeof:o,_context:q},q.Consumer=q},xt.createElement=B,xt.createFactory=function(q){var ue=B.bind(null,q);return ue.type=q,ue},xt.createRef=function(){return{current:null}},xt.forwardRef=function(q){return{$$typeof:a,render:q}},xt.isValidElement=V,xt.lazy=function(q){return{$$typeof:d,_payload:{_status:-1,_result:q},_init:ve}},xt.memo=function(q,ue){return{$$typeof:c,type:q,compare:ue===void 0?null:ue}},xt.startTransition=function(q){var ue=fe.transition;fe.transition={};try{q()}finally{fe.transition=ue}},xt.unstable_act=ae,xt.useCallback=function(q,ue){return $e.current.useCallback(q,ue)},xt.useContext=function(q){return $e.current.useContext(q)},xt.useDebugValue=function(){},xt.useDeferredValue=function(q){return $e.current.useDeferredValue(q)},xt.useEffect=function(q,ue){return $e.current.useEffect(q,ue)},xt.useId=function(){return $e.current.useId()},xt.useImperativeHandle=function(q,ue,we){return $e.current.useImperativeHandle(q,ue,we)},xt.useInsertionEffect=function(q,ue){return $e.current.useInsertionEffect(q,ue)},xt.useLayoutEffect=function(q,ue){return $e.current.useLayoutEffect(q,ue)},xt.useMemo=function(q,ue){return $e.current.useMemo(q,ue)},xt.useReducer=function(q,ue,we){return $e.current.useReducer(q,ue,we)},xt.useRef=function(q){return $e.current.useRef(q)},xt.useState=function(q){return $e.current.useState(q)},xt.useSyncExternalStore=function(q,ue,we){return $e.current.useSyncExternalStore(q,ue,we)},xt.useTransition=function(){return $e.current.useTransition()},xt.version="18.3.1",xt}var Hk;function Uv(){return Hk||(Hk=1,n1.exports=aL()),n1.exports}/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Kk;function lL(){if(Kk)return ph;Kk=1;var t=Uv(),e=Symbol.for("react.element"),n=Symbol.for("react.fragment"),r=Object.prototype.hasOwnProperty,s=t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,o={key:!0,ref:!0,__self:!0,__source:!0};function i(a,l,c){var d,f={},p=null,g=null;c!==void 0&&(p=""+c),l.key!==void 0&&(p=""+l.key),l.ref!==void 0&&(g=l.ref);for(d in l)r.call(l,d)&&!o.hasOwnProperty(d)&&(f[d]=l[d]);if(a&&a.defaultProps)for(d in l=a.defaultProps,l)f[d]===void 0&&(f[d]=l[d]);return{$$typeof:e,type:a,key:p,ref:g,props:f,_owner:s.current}}return ph.Fragment=n,ph.jsx=i,ph.jsxs=i,ph}var Xk;function uL(){return Xk||(Xk=1,t1.exports=lL()),t1.exports}var K=uL(),J=Uv();const sa=Af(J),qk=zE({__proto__:null,default:sa},[J]);var sm={},r1={exports:{}},ls={},s1={exports:{}},o1={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Yk;function cL(){return Yk||(Yk=1,function(t){function e(fe,xe){var ae=fe.length;fe.push(xe);e:for(;0<ae;){var q=ae-1>>>1,ue=fe[q];if(0<s(ue,xe))fe[q]=xe,fe[ae]=ue,ae=q;else break e}}function n(fe){return fe.length===0?null:fe[0]}function r(fe){if(fe.length===0)return null;var xe=fe[0],ae=fe.pop();if(ae!==xe){fe[0]=ae;e:for(var q=0,ue=fe.length,we=ue>>>1;q<we;){var Ge=2*(q+1)-1,et=fe[Ge],tt=Ge+1,Tt=fe[tt];if(0>s(et,ae))tt<ue&&0>s(Tt,et)?(fe[q]=Tt,fe[tt]=ae,q=tt):(fe[q]=et,fe[Ge]=ae,q=Ge);else if(tt<ue&&0>s(Tt,ae))fe[q]=Tt,fe[tt]=ae,q=tt;else break e}}return xe}function s(fe,xe){var ae=fe.sortIndex-xe.sortIndex;return ae!==0?ae:fe.id-xe.id}if(typeof performance=="object"&&typeof performance.now=="function"){var o=performance;t.unstable_now=function(){return o.now()}}else{var i=Date,a=i.now();t.unstable_now=function(){return i.now()-a}}var l=[],c=[],d=1,f=null,p=3,g=!1,y=!1,x=!1,w=typeof setTimeout=="function"?setTimeout:null,S=typeof clearTimeout=="function"?clearTimeout:null,$=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function I(fe){for(var xe=n(c);xe!==null;){if(xe.callback===null)r(c);else if(xe.startTime<=fe)r(c),xe.sortIndex=xe.expirationTime,e(l,xe);else break;xe=n(c)}}function R(fe){if(x=!1,I(fe),!y)if(n(l)!==null)y=!0,ve(_);else{var xe=n(c);xe!==null&&$e(R,xe.startTime-fe)}}function _(fe,xe){y=!1,x&&(x=!1,S(B),B=-1),g=!0;var ae=p;try{for(I(xe),f=n(l);f!==null&&(!(f.expirationTime>xe)||fe&&!P());){var q=f.callback;if(typeof q=="function"){f.callback=null,p=f.priorityLevel;var ue=q(f.expirationTime<=xe);xe=t.unstable_now(),typeof ue=="function"?f.callback=ue:f===n(l)&&r(l),I(xe)}else r(l);f=n(l)}if(f!==null)var we=!0;else{var Ge=n(c);Ge!==null&&$e(R,Ge.startTime-xe),we=!1}return we}finally{f=null,p=ae,g=!1}}var O=!1,F=null,B=-1,M=5,V=-1;function P(){return!(t.unstable_now()-V<M)}function re(){if(F!==null){var fe=t.unstable_now();V=fe;var xe=!0;try{xe=F(!0,fe)}finally{xe?ie():(O=!1,F=null)}}else O=!1}var ie;if(typeof $=="function")ie=function(){$(re)};else if(typeof MessageChannel<"u"){var me=new MessageChannel,ge=me.port2;me.port1.onmessage=re,ie=function(){ge.postMessage(null)}}else ie=function(){w(re,0)};function ve(fe){F=fe,O||(O=!0,ie())}function $e(fe,xe){B=w(function(){fe(t.unstable_now())},xe)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(fe){fe.callback=null},t.unstable_continueExecution=function(){y||g||(y=!0,ve(_))},t.unstable_forceFrameRate=function(fe){0>fe||125<fe?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):M=0<fe?Math.floor(1e3/fe):5},t.unstable_getCurrentPriorityLevel=function(){return p},t.unstable_getFirstCallbackNode=function(){return n(l)},t.unstable_next=function(fe){switch(p){case 1:case 2:case 3:var xe=3;break;default:xe=p}var ae=p;p=xe;try{return fe()}finally{p=ae}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(fe,xe){switch(fe){case 1:case 2:case 3:case 4:case 5:break;default:fe=3}var ae=p;p=fe;try{return xe()}finally{p=ae}},t.unstable_scheduleCallback=function(fe,xe,ae){var q=t.unstable_now();switch(typeof ae=="object"&&ae!==null?(ae=ae.delay,ae=typeof ae=="number"&&0<ae?q+ae:q):ae=q,fe){case 1:var ue=-1;break;case 2:ue=250;break;case 5:ue=1073741823;break;case 4:ue=1e4;break;default:ue=5e3}return ue=ae+ue,fe={id:d++,callback:xe,priorityLevel:fe,startTime:ae,expirationTime:ue,sortIndex:-1},ae>q?(fe.sortIndex=ae,e(c,fe),n(l)===null&&fe===n(c)&&(x?(S(B),B=-1):x=!0,$e(R,ae-q))):(fe.sortIndex=ue,e(l,fe),y||g||(y=!0,ve(_))),fe},t.unstable_shouldYield=P,t.unstable_wrapCallback=function(fe){var xe=p;return function(){var ae=p;p=xe;try{return fe.apply(this,arguments)}finally{p=ae}}}}(o1)),o1}var Qk;function dL(){return Qk||(Qk=1,s1.exports=cL()),s1.exports}/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Zk;function hL(){if(Zk)return ls;Zk=1;var t=Uv(),e=dL();function n(u){for(var h="https://reactjs.org/docs/error-decoder.html?invariant="+u,m=1;m<arguments.length;m++)h+="&args[]="+encodeURIComponent(arguments[m]);return"Minified React error #"+u+"; visit "+h+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var r=new Set,s={};function o(u,h){i(u,h),i(u+"Capture",h)}function i(u,h){for(s[u]=h,u=0;u<h.length;u++)r.add(h[u])}var a=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),l=Object.prototype.hasOwnProperty,c=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,d={},f={};function p(u){return l.call(f,u)?!0:l.call(d,u)?!1:c.test(u)?f[u]=!0:(d[u]=!0,!1)}function g(u,h,m,b){if(m!==null&&m.type===0)return!1;switch(typeof h){case"function":case"symbol":return!0;case"boolean":return b?!1:m!==null?!m.acceptsBooleans:(u=u.toLowerCase().slice(0,5),u!=="data-"&&u!=="aria-");default:return!1}}function y(u,h,m,b){if(h===null||typeof h>"u"||g(u,h,m,b))return!0;if(b)return!1;if(m!==null)switch(m.type){case 3:return!h;case 4:return h===!1;case 5:return isNaN(h);case 6:return isNaN(h)||1>h}return!1}function x(u,h,m,b,C,T,D){this.acceptsBooleans=h===2||h===3||h===4,this.attributeName=b,this.attributeNamespace=C,this.mustUseProperty=m,this.propertyName=u,this.type=h,this.sanitizeURL=T,this.removeEmptyString=D}var w={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(u){w[u]=new x(u,0,!1,u,null,!1,!1)}),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(u){var h=u[0];w[h]=new x(h,1,!1,u[1],null,!1,!1)}),["contentEditable","draggable","spellCheck","value"].forEach(function(u){w[u]=new x(u,2,!1,u.toLowerCase(),null,!1,!1)}),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(u){w[u]=new x(u,2,!1,u,null,!1,!1)}),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(u){w[u]=new x(u,3,!1,u.toLowerCase(),null,!1,!1)}),["checked","multiple","muted","selected"].forEach(function(u){w[u]=new x(u,3,!0,u,null,!1,!1)}),["capture","download"].forEach(function(u){w[u]=new x(u,4,!1,u,null,!1,!1)}),["cols","rows","size","span"].forEach(function(u){w[u]=new x(u,6,!1,u,null,!1,!1)}),["rowSpan","start"].forEach(function(u){w[u]=new x(u,5,!1,u.toLowerCase(),null,!1,!1)});var S=/[\-:]([a-z])/g;function $(u){return u[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(u){var h=u.replace(S,$);w[h]=new x(h,1,!1,u,null,!1,!1)}),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(u){var h=u.replace(S,$);w[h]=new x(h,1,!1,u,"http://www.w3.org/1999/xlink",!1,!1)}),["xml:base","xml:lang","xml:space"].forEach(function(u){var h=u.replace(S,$);w[h]=new x(h,1,!1,u,"http://www.w3.org/XML/1998/namespace",!1,!1)}),["tabIndex","crossOrigin"].forEach(function(u){w[u]=new x(u,1,!1,u.toLowerCase(),null,!1,!1)}),w.xlinkHref=new x("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach(function(u){w[u]=new x(u,1,!1,u.toLowerCase(),null,!0,!0)});function I(u,h,m,b){var C=w.hasOwnProperty(h)?w[h]:null;(C!==null?C.type!==0:b||!(2<h.length)||h[0]!=="o"&&h[0]!=="O"||h[1]!=="n"&&h[1]!=="N")&&(y(h,m,C,b)&&(m=null),b||C===null?p(h)&&(m===null?u.removeAttribute(h):u.setAttribute(h,""+m)):C.mustUseProperty?u[C.propertyName]=m===null?C.type===3?!1:"":m:(h=C.attributeName,b=C.attributeNamespace,m===null?u.removeAttribute(h):(C=C.type,m=C===3||C===4&&m===!0?"":""+m,b?u.setAttributeNS(b,h,m):u.setAttribute(h,m))))}var R=t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,_=Symbol.for("react.element"),O=Symbol.for("react.portal"),F=Symbol.for("react.fragment"),B=Symbol.for("react.strict_mode"),M=Symbol.for("react.profiler"),V=Symbol.for("react.provider"),P=Symbol.for("react.context"),re=Symbol.for("react.forward_ref"),ie=Symbol.for("react.suspense"),me=Symbol.for("react.suspense_list"),ge=Symbol.for("react.memo"),ve=Symbol.for("react.lazy"),$e=Symbol.for("react.offscreen"),fe=Symbol.iterator;function xe(u){return u===null||typeof u!="object"?null:(u=fe&&u[fe]||u["@@iterator"],typeof u=="function"?u:null)}var ae=Object.assign,q;function ue(u){if(q===void 0)try{throw Error()}catch(m){var h=m.stack.trim().match(/\n( *(at )?)/);q=h&&h[1]||""}return`
`+q+u}var we=!1;function Ge(u,h){if(!u||we)return"";we=!0;var m=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(h)if(h=function(){throw Error()},Object.defineProperty(h.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(h,[])}catch(de){var b=de}Reflect.construct(u,[],h)}else{try{h.call()}catch(de){b=de}u.call(h.prototype)}else{try{throw Error()}catch(de){b=de}u()}}catch(de){if(de&&b&&typeof de.stack=="string"){for(var C=de.stack.split(`
`),T=b.stack.split(`
`),D=C.length-1,H=T.length-1;1<=D&&0<=H&&C[D]!==T[H];)H--;for(;1<=D&&0<=H;D--,H--)if(C[D]!==T[H]){if(D!==1||H!==1)do if(D--,H--,0>H||C[D]!==T[H]){var Q=`
`+C[D].replace(" at new "," at ");return u.displayName&&Q.includes("<anonymous>")&&(Q=Q.replace("<anonymous>",u.displayName)),Q}while(1<=D&&0<=H);break}}}finally{we=!1,Error.prepareStackTrace=m}return(u=u?u.displayName||u.name:"")?ue(u):""}function et(u){switch(u.tag){case 5:return ue(u.type);case 16:return ue("Lazy");case 13:return ue("Suspense");case 19:return ue("SuspenseList");case 0:case 2:case 15:return u=Ge(u.type,!1),u;case 11:return u=Ge(u.type.render,!1),u;case 1:return u=Ge(u.type,!0),u;default:return""}}function tt(u){if(u==null)return null;if(typeof u=="function")return u.displayName||u.name||null;if(typeof u=="string")return u;switch(u){case F:return"Fragment";case O:return"Portal";case M:return"Profiler";case B:return"StrictMode";case ie:return"Suspense";case me:return"SuspenseList"}if(typeof u=="object")switch(u.$$typeof){case P:return(u.displayName||"Context")+".Consumer";case V:return(u._context.displayName||"Context")+".Provider";case re:var h=u.render;return u=u.displayName,u||(u=h.displayName||h.name||"",u=u!==""?"ForwardRef("+u+")":"ForwardRef"),u;case ge:return h=u.displayName||null,h!==null?h:tt(u.type)||"Memo";case ve:h=u._payload,u=u._init;try{return tt(u(h))}catch{}}return null}function Tt(u){var h=u.type;switch(u.tag){case 24:return"Cache";case 9:return(h.displayName||"Context")+".Consumer";case 10:return(h._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return u=h.render,u=u.displayName||u.name||"",h.displayName||(u!==""?"ForwardRef("+u+")":"ForwardRef");case 7:return"Fragment";case 5:return h;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return tt(h);case 8:return h===B?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof h=="function")return h.displayName||h.name||null;if(typeof h=="string")return h}return null}function dt(u){switch(typeof u){case"boolean":case"number":case"string":case"undefined":return u;case"object":return u;default:return""}}function vt(u){var h=u.type;return(u=u.nodeName)&&u.toLowerCase()==="input"&&(h==="checkbox"||h==="radio")}function rn(u){var h=vt(u)?"checked":"value",m=Object.getOwnPropertyDescriptor(u.constructor.prototype,h),b=""+u[h];if(!u.hasOwnProperty(h)&&typeof m<"u"&&typeof m.get=="function"&&typeof m.set=="function"){var C=m.get,T=m.set;return Object.defineProperty(u,h,{configurable:!0,get:function(){return C.call(this)},set:function(D){b=""+D,T.call(this,D)}}),Object.defineProperty(u,h,{enumerable:m.enumerable}),{getValue:function(){return b},setValue:function(D){b=""+D},stopTracking:function(){u._valueTracker=null,delete u[h]}}}}function _r(u){u._valueTracker||(u._valueTracker=rn(u))}function ki(u){if(!u)return!1;var h=u._valueTracker;if(!h)return!0;var m=h.getValue(),b="";return u&&(b=vt(u)?u.checked?"true":"false":u.value),u=b,u!==m?(h.setValue(u),!0):!1}function zt(u){if(u=u||(typeof document<"u"?document:void 0),typeof u>"u")return null;try{return u.activeElement||u.body}catch{return u.body}}function sn(u,h){var m=h.checked;return ae({},h,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:m??u._wrapperState.initialChecked})}function Pr(u,h){var m=h.defaultValue==null?"":h.defaultValue,b=h.checked!=null?h.checked:h.defaultChecked;m=dt(h.value!=null?h.value:m),u._wrapperState={initialChecked:b,initialValue:m,controlled:h.type==="checkbox"||h.type==="radio"?h.checked!=null:h.value!=null}}function Vo(u,h){h=h.checked,h!=null&&I(u,"checked",h,!1)}function Ia(u,h){Vo(u,h);var m=dt(h.value),b=h.type;if(m!=null)b==="number"?(m===0&&u.value===""||u.value!=m)&&(u.value=""+m):u.value!==""+m&&(u.value=""+m);else if(b==="submit"||b==="reset"){u.removeAttribute("value");return}h.hasOwnProperty("value")?Na(u,h.type,m):h.hasOwnProperty("defaultValue")&&Na(u,h.type,dt(h.defaultValue)),h.checked==null&&h.defaultChecked!=null&&(u.defaultChecked=!!h.defaultChecked)}function El(u,h,m){if(h.hasOwnProperty("value")||h.hasOwnProperty("defaultValue")){var b=h.type;if(!(b!=="submit"&&b!=="reset"||h.value!==void 0&&h.value!==null))return;h=""+u._wrapperState.initialValue,m||h===u.value||(u.value=h),u.defaultValue=h}m=u.name,m!==""&&(u.name=""),u.defaultChecked=!!u._wrapperState.initialChecked,m!==""&&(u.name=m)}function Na(u,h,m){(h!=="number"||zt(u.ownerDocument)!==u)&&(m==null?u.defaultValue=""+u._wrapperState.initialValue:u.defaultValue!==""+m&&(u.defaultValue=""+m))}var ws=Array.isArray;function Ss(u,h,m,b){if(u=u.options,h){h={};for(var C=0;C<m.length;C++)h["$"+m[C]]=!0;for(m=0;m<u.length;m++)C=h.hasOwnProperty("$"+u[m].value),u[m].selected!==C&&(u[m].selected=C),C&&b&&(u[m].defaultSelected=!0)}else{for(m=""+dt(m),h=null,C=0;C<u.length;C++){if(u[C].value===m){u[C].selected=!0,b&&(u[C].defaultSelected=!0);return}h!==null||u[C].disabled||(h=u[C])}h!==null&&(h.selected=!0)}}function Bs(u,h){if(h.dangerouslySetInnerHTML!=null)throw Error(n(91));return ae({},h,{value:void 0,defaultValue:void 0,children:""+u._wrapperState.initialValue})}function qr(u,h){var m=h.value;if(m==null){if(m=h.children,h=h.defaultValue,m!=null){if(h!=null)throw Error(n(92));if(ws(m)){if(1<m.length)throw Error(n(93));m=m[0]}h=m}h==null&&(h=""),m=h}u._wrapperState={initialValue:dt(m)}}function Cs(u,h){var m=dt(h.value),b=dt(h.defaultValue);m!=null&&(m=""+m,m!==u.value&&(u.value=m),h.defaultValue==null&&u.defaultValue!==m&&(u.defaultValue=m)),b!=null&&(u.defaultValue=""+b)}function Ea(u){var h=u.textContent;h===u._wrapperState.initialValue&&h!==""&&h!==null&&(u.value=h)}function Ti(u){switch(u){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Ii(u,h){return u==null||u==="http://www.w3.org/1999/xhtml"?Ti(h):u==="http://www.w3.org/2000/svg"&&h==="foreignObject"?"http://www.w3.org/1999/xhtml":u}var go,Ra=function(u){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(h,m,b,C){MSApp.execUnsafeLocalFunction(function(){return u(h,m,b,C)})}:u}(function(u,h){if(u.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in u)u.innerHTML=h;else{for(go=go||document.createElement("div"),go.innerHTML="<svg>"+h.valueOf().toString()+"</svg>",h=go.firstChild;u.firstChild;)u.removeChild(u.firstChild);for(;h.firstChild;)u.appendChild(h.firstChild)}});function Wo(u,h){if(h){var m=u.firstChild;if(m&&m===u.lastChild&&m.nodeType===3){m.nodeValue=h;return}}u.textContent=h}var yo={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Rl=["Webkit","ms","Moz","O"];Object.keys(yo).forEach(function(u){Rl.forEach(function(h){h=h+u.charAt(0).toUpperCase()+u.substring(1),yo[h]=yo[u]})});function Uo(u,h,m){return h==null||typeof h=="boolean"||h===""?"":m||typeof h!="number"||h===0||yo.hasOwnProperty(u)&&yo[u]?(""+h).trim():h+"px"}function _a(u,h){u=u.style;for(var m in h)if(h.hasOwnProperty(m)){var b=m.indexOf("--")===0,C=Uo(m,h[m],b);m==="float"&&(m="cssFloat"),b?u.setProperty(m,C):u[m]=C}}var Ms=ae({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function jo(u,h){if(h){if(Ms[u]&&(h.children!=null||h.dangerouslySetInnerHTML!=null))throw Error(n(137,u));if(h.dangerouslySetInnerHTML!=null){if(h.children!=null)throw Error(n(60));if(typeof h.dangerouslySetInnerHTML!="object"||!("__html"in h.dangerouslySetInnerHTML))throw Error(n(61))}if(h.style!=null&&typeof h.style!="object")throw Error(n(62))}}function Pa(u,h){if(u.indexOf("-")===-1)return typeof h.is=="string";switch(u){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Go=null;function $s(u){return u=u.target||u.srcElement||window,u.correspondingUseElement&&(u=u.correspondingUseElement),u.nodeType===3?u.parentNode:u}var Vs=null,Ar=null,xo=null;function Yr(u){if(u=Jd(u)){if(typeof Vs!="function")throw Error(n(280));var h=u.stateNode;h&&(h=vp(h),Vs(u.stateNode,u.type,h))}}function _l(u){Ar?xo?xo.push(u):xo=[u]:Ar=u}function Ws(){if(Ar){var u=Ar,h=xo;if(xo=Ar=null,Yr(u),h)for(u=0;u<h.length;u++)Yr(h[u])}}function Aa(u,h){return u(h)}function Pl(){}var Ho=!1;function er(u,h,m){if(Ho)return u(h,m);Ho=!0;try{return Aa(u,h,m)}finally{Ho=!1,(Ar!==null||xo!==null)&&(Pl(),Ws())}}function Ni(u,h){var m=u.stateNode;if(m===null)return null;var b=vp(m);if(b===null)return null;m=b[h];e:switch(h){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(b=!b.disabled)||(u=u.type,b=!(u==="button"||u==="input"||u==="select"||u==="textarea")),u=!b;break e;default:u=!1}if(u)return null;if(m&&typeof m!="function")throw Error(n(231,h,typeof m));return m}var Us=!1;if(a)try{var Ei={};Object.defineProperty(Ei,"passive",{get:function(){Us=!0}}),window.addEventListener("test",Ei,Ei),window.removeEventListener("test",Ei,Ei)}catch{Us=!1}function ks(u,h,m,b,C,T,D,H,Q){var de=Array.prototype.slice.call(arguments,3);try{h.apply(m,de)}catch(Se){this.onError(Se)}}var Dr=!1,Qr=null,Xt=!1,hr=null,Al={onError:function(u){Dr=!0,Qr=u}};function zd(u,h,m,b,C,T,D,H,Q){Dr=!1,Qr=null,ks.apply(Al,arguments)}function Da(u,h,m,b,C,T,D,H,Q){if(zd.apply(this,arguments),Dr){if(Dr){var de=Qr;Dr=!1,Qr=null}else throw Error(n(198));Xt||(Xt=!0,hr=de)}}function Bn(u){var h=u,m=u;if(u.alternate)for(;h.return;)h=h.return;else{u=h;do h=u,(h.flags&4098)!==0&&(m=h.return),u=h.return;while(u)}return h.tag===3?m:null}function Ri(u){if(u.tag===13){var h=u.memoizedState;if(h===null&&(u=u.alternate,u!==null&&(h=u.memoizedState)),h!==null)return h.dehydrated}return null}function Ko(u){if(Bn(u)!==u)throw Error(n(188))}function qu(u){var h=u.alternate;if(!h){if(h=Bn(u),h===null)throw Error(n(188));return h!==u?null:u}for(var m=u,b=h;;){var C=m.return;if(C===null)break;var T=C.alternate;if(T===null){if(b=C.return,b!==null){m=b;continue}break}if(C.child===T.child){for(T=C.child;T;){if(T===m)return Ko(C),u;if(T===b)return Ko(C),h;T=T.sibling}throw Error(n(188))}if(m.return!==b.return)m=C,b=T;else{for(var D=!1,H=C.child;H;){if(H===m){D=!0,m=C,b=T;break}if(H===b){D=!0,b=C,m=T;break}H=H.sibling}if(!D){for(H=T.child;H;){if(H===m){D=!0,m=T,b=C;break}if(H===b){D=!0,b=T,m=C;break}H=H.sibling}if(!D)throw Error(n(189))}}if(m.alternate!==b)throw Error(n(190))}if(m.tag!==3)throw Error(n(188));return m.stateNode.current===m?u:h}function Oa(u){return u=qu(u),u!==null?Fa(u):null}function Fa(u){if(u.tag===5||u.tag===6)return u;for(u=u.child;u!==null;){var h=Fa(u);if(h!==null)return h;u=u.sibling}return null}var Dl=e.unstable_scheduleCallback,Mn=e.unstable_cancelCallback,Zr=e.unstable_shouldYield,js=e.unstable_requestPaint,Ut=e.unstable_now,Ol=e.unstable_getCurrentPriorityLevel,vo=e.unstable_ImmediatePriority,_i=e.unstable_UserBlockingPriority,tr=e.unstable_NormalPriority,Yu=e.unstable_LowPriority,Pi=e.unstable_IdlePriority,Vn=null,nr=null;function Bd(u){if(nr&&typeof nr.onCommitFiberRoot=="function")try{nr.onCommitFiberRoot(Vn,u,void 0,(u.current.flags&128)===128)}catch{}}var fr=Math.clz32?Math.clz32:Vd,Fl=Math.log,Md=Math.LN2;function Vd(u){return u>>>=0,u===0?32:31-(Fl(u)/Md|0)|0}var Ai=64,Di=4194304;function Xo(u){switch(u&-u){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return u&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return u&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return u}}function Oi(u,h){var m=u.pendingLanes;if(m===0)return 0;var b=0,C=u.suspendedLanes,T=u.pingedLanes,D=m&268435455;if(D!==0){var H=D&~C;H!==0?b=Xo(H):(T&=D,T!==0&&(b=Xo(T)))}else D=m&~C,D!==0?b=Xo(D):T!==0&&(b=Xo(T));if(b===0)return 0;if(h!==0&&h!==b&&(h&C)===0&&(C=b&-b,T=h&-h,C>=T||C===16&&(T&4194240)!==0))return h;if((b&4)!==0&&(b|=m&16),h=u.entangledLanes,h!==0)for(u=u.entanglements,h&=b;0<h;)m=31-fr(h),C=1<<m,b|=u[m],h&=~C;return b}function wn(u,h){switch(u){case 1:case 2:case 4:return h+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return h+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function La(u,h){for(var m=u.suspendedLanes,b=u.pingedLanes,C=u.expirationTimes,T=u.pendingLanes;0<T;){var D=31-fr(T),H=1<<D,Q=C[D];Q===-1?((H&m)===0||(H&b)!==0)&&(C[D]=wn(H,h)):Q<=h&&(u.expiredLanes|=H),T&=~H}}function za(u){return u=u.pendingLanes&-1073741825,u!==0?u:u&1073741824?1073741824:0}function Fi(){var u=Ai;return Ai<<=1,(Ai&4194240)===0&&(Ai=64),u}function Li(u){for(var h=[],m=0;31>m;m++)h.push(u);return h}function qo(u,h,m){u.pendingLanes|=h,h!==536870912&&(u.suspendedLanes=0,u.pingedLanes=0),u=u.eventTimes,h=31-fr(h),u[h]=m}function Wd(u,h){var m=u.pendingLanes&~h;u.pendingLanes=h,u.suspendedLanes=0,u.pingedLanes=0,u.expiredLanes&=h,u.mutableReadLanes&=h,u.entangledLanes&=h,h=u.entanglements;var b=u.eventTimes;for(u=u.expirationTimes;0<m;){var C=31-fr(m),T=1<<C;h[C]=0,b[C]=-1,u[C]=-1,m&=~T}}function Ll(u,h){var m=u.entangledLanes|=h;for(u=u.entanglements;m;){var b=31-fr(m),C=1<<b;C&h|u[b]&h&&(u[b]|=h),m&=~C}}var St=0;function zl(u){return u&=-u,1<u?4<u?(u&268435455)!==0?16:536870912:4:1}var zi,Ba,Bi,Yo,Qu,Bl=!1,bo=[],Jr=null,pr=null,Wn=null,Mi=new Map,Qo=new Map,es=[],Zu="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function ts(u,h){switch(u){case"focusin":case"focusout":Jr=null;break;case"dragenter":case"dragleave":pr=null;break;case"mouseover":case"mouseout":Wn=null;break;case"pointerover":case"pointerout":Mi.delete(h.pointerId);break;case"gotpointercapture":case"lostpointercapture":Qo.delete(h.pointerId)}}function ns(u,h,m,b,C,T){return u===null||u.nativeEvent!==T?(u={blockedOn:h,domEventName:m,eventSystemFlags:b,nativeEvent:T,targetContainers:[C]},h!==null&&(h=Jd(h),h!==null&&Ba(h)),u):(u.eventSystemFlags|=b,h=u.targetContainers,C!==null&&h.indexOf(C)===-1&&h.push(C),u)}function Ju(u,h,m,b,C){switch(h){case"focusin":return Jr=ns(Jr,u,h,m,b,C),!0;case"dragenter":return pr=ns(pr,u,h,m,b,C),!0;case"mouseover":return Wn=ns(Wn,u,h,m,b,C),!0;case"pointerover":var T=C.pointerId;return Mi.set(T,ns(Mi.get(T)||null,u,h,m,b,C)),!0;case"gotpointercapture":return T=C.pointerId,Qo.set(T,ns(Qo.get(T)||null,u,h,m,b,C)),!0}return!1}function wo(u){var h=Gl(u.target);if(h!==null){var m=Bn(h);if(m!==null){if(h=m.tag,h===13){if(h=Ri(m),h!==null){u.blockedOn=h,Qu(u.priority,function(){Bi(m)});return}}else if(h===3&&m.stateNode.current.memoizedState.isDehydrated){u.blockedOn=m.tag===3?m.stateNode.containerInfo:null;return}}}u.blockedOn=null}function Un(u){if(u.blockedOn!==null)return!1;for(var h=u.targetContainers;0<h.length;){var m=It(u.domEventName,u.eventSystemFlags,h[0],u.nativeEvent);if(m===null){m=u.nativeEvent;var b=new m.constructor(m.type,m);Go=b,m.target.dispatchEvent(b),Go=null}else return h=Jd(m),h!==null&&Ba(h),u.blockedOn=m,!1;h.shift()}return!0}function Ml(u,h,m){Un(u)&&m.delete(h)}function Ud(){Bl=!1,Jr!==null&&Un(Jr)&&(Jr=null),pr!==null&&Un(pr)&&(pr=null),Wn!==null&&Un(Wn)&&(Wn=null),Mi.forEach(Ml),Qo.forEach(Ml)}function Zo(u,h){u.blockedOn===h&&(u.blockedOn=null,Bl||(Bl=!0,e.unstable_scheduleCallback(e.unstable_NormalPriority,Ud)))}function So(u){function h(C){return Zo(C,u)}if(0<bo.length){Zo(bo[0],u);for(var m=1;m<bo.length;m++){var b=bo[m];b.blockedOn===u&&(b.blockedOn=null)}}for(Jr!==null&&Zo(Jr,u),pr!==null&&Zo(pr,u),Wn!==null&&Zo(Wn,u),Mi.forEach(h),Qo.forEach(h),m=0;m<es.length;m++)b=es[m],b.blockedOn===u&&(b.blockedOn=null);for(;0<es.length&&(m=es[0],m.blockedOn===null);)wo(m),m.blockedOn===null&&es.shift()}var Gs=R.ReactCurrentBatchConfig,U=!0;function ee(u,h,m,b){var C=St,T=Gs.transition;Gs.transition=null;try{St=1,Fe(u,h,m,b)}finally{St=C,Gs.transition=T}}function he(u,h,m,b){var C=St,T=Gs.transition;Gs.transition=null;try{St=4,Fe(u,h,m,b)}finally{St=C,Gs.transition=T}}function Fe(u,h,m,b){if(U){var C=It(u,h,m,b);if(C===null)Gy(u,h,b,ht,m),ts(u,b);else if(Ju(C,u,h,m,b))b.stopPropagation();else if(ts(u,b),h&4&&-1<Zu.indexOf(u)){for(;C!==null;){var T=Jd(C);if(T!==null&&zi(T),T=It(u,h,m,b),T===null&&Gy(u,h,b,ht,m),T===C)break;C=T}C!==null&&b.stopPropagation()}else Gy(u,h,b,null,m)}}var ht=null;function It(u,h,m,b){if(ht=null,u=$s(b),u=Gl(u),u!==null)if(h=Bn(u),h===null)u=null;else if(m=h.tag,m===13){if(u=Ri(h),u!==null)return u;u=null}else if(m===3){if(h.stateNode.current.memoizedState.isDehydrated)return h.tag===3?h.stateNode.containerInfo:null;u=null}else h!==u&&(u=null);return ht=u,null}function Nt(u){switch(u){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Ol()){case vo:return 1;case _i:return 4;case tr:case Yu:return 16;case Pi:return 536870912;default:return 16}default:return 16}}var at=null,_t=null,jn=null;function Gn(){if(jn)return jn;var u,h=_t,m=h.length,b,C="value"in at?at.value:at.textContent,T=C.length;for(u=0;u<m&&h[u]===C[u];u++);var D=m-u;for(b=1;b<=D&&h[m-b]===C[T-b];b++);return jn=C.slice(u,1<b?1-b:void 0)}function Or(u){var h=u.keyCode;return"charCode"in u?(u=u.charCode,u===0&&h===13&&(u=13)):u=h,u===10&&(u=13),32<=u||u===13?u:0}function Co(){return!0}function Ma(){return!1}function Rn(u){function h(m,b,C,T,D){this._reactName=m,this._targetInst=C,this.type=b,this.nativeEvent=T,this.target=D,this.currentTarget=null;for(var H in u)u.hasOwnProperty(H)&&(m=u[H],this[H]=m?m(T):T[H]);return this.isDefaultPrevented=(T.defaultPrevented!=null?T.defaultPrevented:T.returnValue===!1)?Co:Ma,this.isPropagationStopped=Ma,this}return ae(h.prototype,{preventDefault:function(){this.defaultPrevented=!0;var m=this.nativeEvent;m&&(m.preventDefault?m.preventDefault():typeof m.returnValue!="unknown"&&(m.returnValue=!1),this.isDefaultPrevented=Co)},stopPropagation:function(){var m=this.nativeEvent;m&&(m.stopPropagation?m.stopPropagation():typeof m.cancelBubble!="unknown"&&(m.cancelBubble=!0),this.isPropagationStopped=Co)},persist:function(){},isPersistent:Co}),h}var Va={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(u){return u.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},jd=Rn(Va),Vi=ae({},Va,{view:0,detail:0}),Gd=Rn(Vi),ec,Hd,Vl,tc=ae({},Vi,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:k,button:0,buttons:0,relatedTarget:function(u){return u.relatedTarget===void 0?u.fromElement===u.srcElement?u.toElement:u.fromElement:u.relatedTarget},movementX:function(u){return"movementX"in u?u.movementX:(u!==Vl&&(Vl&&u.type==="mousemove"?(ec=u.screenX-Vl.screenX,Hd=u.screenY-Vl.screenY):Hd=ec=0,Vl=u),ec)},movementY:function(u){return"movementY"in u?u.movementY:Hd}}),op=Rn(tc),ip=ae({},tc,{dataTransfer:0}),Ny=Rn(ip),Ey=ae({},Vi,{relatedTarget:0}),Wl=Rn(Ey),Ry=ae({},Va,{animationName:0,elapsedTime:0,pseudoElement:0}),_y=Rn(Ry),Py=ae({},Va,{clipboardData:function(u){return"clipboardData"in u?u.clipboardData:window.clipboardData}}),nc=Rn(Py),Ay=ae({},Va,{data:0}),ap=Rn(Ay),Dy={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},lp={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},up={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function v(u){var h=this.nativeEvent;return h.getModifierState?h.getModifierState(u):(u=up[u])?!!h[u]:!1}function k(){return v}var E=ae({},Vi,{key:function(u){if(u.key){var h=Dy[u.key]||u.key;if(h!=="Unidentified")return h}return u.type==="keypress"?(u=Or(u),u===13?"Enter":String.fromCharCode(u)):u.type==="keydown"||u.type==="keyup"?lp[u.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:k,charCode:function(u){return u.type==="keypress"?Or(u):0},keyCode:function(u){return u.type==="keydown"||u.type==="keyup"?u.keyCode:0},which:function(u){return u.type==="keypress"?Or(u):u.type==="keydown"||u.type==="keyup"?u.keyCode:0}}),A=Rn(E),W=ae({},tc,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),G=Rn(W),j=ae({},Vi,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:k}),Z=Rn(j),ce=ae({},Va,{propertyName:0,elapsedTime:0,pseudoElement:0}),Ce=Rn(ce),_e=ae({},tc,{deltaX:function(u){return"deltaX"in u?u.deltaX:"wheelDeltaX"in u?-u.wheelDeltaX:0},deltaY:function(u){return"deltaY"in u?u.deltaY:"wheelDeltaY"in u?-u.wheelDeltaY:"wheelDelta"in u?-u.wheelDelta:0},deltaZ:0,deltaMode:0}),Ze=Rn(_e),He=[9,13,27,32],Ae=a&&"CompositionEvent"in window,Ke=null;a&&"documentMode"in document&&(Ke=document.documentMode);var ft=a&&"TextEvent"in window&&!Ke,qt=a&&(!Ae||Ke&&8<Ke&&11>=Ke),jt=" ",Tn=!1;function Fr(u,h){switch(u){case"keyup":return He.indexOf(h.keyCode)!==-1;case"keydown":return h.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function rr(u){return u=u.detail,typeof u=="object"&&"data"in u?u.data:null}var yt=!1;function _n(u,h){switch(u){case"compositionend":return rr(h);case"keypress":return h.which!==32?null:(Tn=!0,jt);case"textInput":return u=h.data,u===jt&&Tn?null:u;default:return null}}function Jo(u,h){if(yt)return u==="compositionend"||!Ae&&Fr(u,h)?(u=Gn(),jn=_t=at=null,yt=!1,u):null;switch(u){case"paste":return null;case"keypress":if(!(h.ctrlKey||h.altKey||h.metaKey)||h.ctrlKey&&h.altKey){if(h.char&&1<h.char.length)return h.char;if(h.which)return String.fromCharCode(h.which)}return null;case"compositionend":return qt&&h.locale!=="ko"?null:h.data;default:return null}}var Oy={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function cp(u){var h=u&&u.nodeName&&u.nodeName.toLowerCase();return h==="input"?!!Oy[u.type]:h==="textarea"}function dp(u,h,m,b){_l(b),h=gp(h,"onChange"),0<h.length&&(m=new jd("onChange","change",null,m,b),u.push({event:m,listeners:h}))}var Ul=null,jl=null;function rc(u){a$(u,0)}function hp(u){var h=lc(u);if(ki(h))return u}function a4(u,h){if(u==="change")return h}var jC=!1;if(a){var Fy;if(a){var Ly="oninput"in document;if(!Ly){var GC=document.createElement("div");GC.setAttribute("oninput","return;"),Ly=typeof GC.oninput=="function"}Fy=Ly}else Fy=!1;jC=Fy&&(!document.documentMode||9<document.documentMode)}function HC(){Ul&&(Ul.detachEvent("onpropertychange",KC),jl=Ul=null)}function KC(u){if(u.propertyName==="value"&&hp(jl)){var h=[];dp(h,jl,u,$s(u)),er(rc,h)}}function l4(u,h,m){u==="focusin"?(HC(),Ul=h,jl=m,Ul.attachEvent("onpropertychange",KC)):u==="focusout"&&HC()}function u4(u){if(u==="selectionchange"||u==="keyup"||u==="keydown")return hp(jl)}function c4(u,h){if(u==="click")return hp(h)}function d4(u,h){if(u==="input"||u==="change")return hp(h)}function h4(u,h){return u===h&&(u!==0||1/u===1/h)||u!==u&&h!==h}var $o=typeof Object.is=="function"?Object.is:h4;function Kd(u,h){if($o(u,h))return!0;if(typeof u!="object"||u===null||typeof h!="object"||h===null)return!1;var m=Object.keys(u),b=Object.keys(h);if(m.length!==b.length)return!1;for(b=0;b<m.length;b++){var C=m[b];if(!l.call(h,C)||!$o(u[C],h[C]))return!1}return!0}function XC(u){for(;u&&u.firstChild;)u=u.firstChild;return u}function qC(u,h){var m=XC(u);u=0;for(var b;m;){if(m.nodeType===3){if(b=u+m.textContent.length,u<=h&&b>=h)return{node:m,offset:h-u};u=b}e:{for(;m;){if(m.nextSibling){m=m.nextSibling;break e}m=m.parentNode}m=void 0}m=XC(m)}}function YC(u,h){return u&&h?u===h?!0:u&&u.nodeType===3?!1:h&&h.nodeType===3?YC(u,h.parentNode):"contains"in u?u.contains(h):u.compareDocumentPosition?!!(u.compareDocumentPosition(h)&16):!1:!1}function QC(){for(var u=window,h=zt();h instanceof u.HTMLIFrameElement;){try{var m=typeof h.contentWindow.location.href=="string"}catch{m=!1}if(m)u=h.contentWindow;else break;h=zt(u.document)}return h}function zy(u){var h=u&&u.nodeName&&u.nodeName.toLowerCase();return h&&(h==="input"&&(u.type==="text"||u.type==="search"||u.type==="tel"||u.type==="url"||u.type==="password")||h==="textarea"||u.contentEditable==="true")}function f4(u){var h=QC(),m=u.focusedElem,b=u.selectionRange;if(h!==m&&m&&m.ownerDocument&&YC(m.ownerDocument.documentElement,m)){if(b!==null&&zy(m)){if(h=b.start,u=b.end,u===void 0&&(u=h),"selectionStart"in m)m.selectionStart=h,m.selectionEnd=Math.min(u,m.value.length);else if(u=(h=m.ownerDocument||document)&&h.defaultView||window,u.getSelection){u=u.getSelection();var C=m.textContent.length,T=Math.min(b.start,C);b=b.end===void 0?T:Math.min(b.end,C),!u.extend&&T>b&&(C=b,b=T,T=C),C=qC(m,T);var D=qC(m,b);C&&D&&(u.rangeCount!==1||u.anchorNode!==C.node||u.anchorOffset!==C.offset||u.focusNode!==D.node||u.focusOffset!==D.offset)&&(h=h.createRange(),h.setStart(C.node,C.offset),u.removeAllRanges(),T>b?(u.addRange(h),u.extend(D.node,D.offset)):(h.setEnd(D.node,D.offset),u.addRange(h)))}}for(h=[],u=m;u=u.parentNode;)u.nodeType===1&&h.push({element:u,left:u.scrollLeft,top:u.scrollTop});for(typeof m.focus=="function"&&m.focus(),m=0;m<h.length;m++)u=h[m],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}}var p4=a&&"documentMode"in document&&11>=document.documentMode,sc=null,By=null,Xd=null,My=!1;function ZC(u,h,m){var b=m.window===m?m.document:m.nodeType===9?m:m.ownerDocument;My||sc==null||sc!==zt(b)||(b=sc,"selectionStart"in b&&zy(b)?b={start:b.selectionStart,end:b.selectionEnd}:(b=(b.ownerDocument&&b.ownerDocument.defaultView||window).getSelection(),b={anchorNode:b.anchorNode,anchorOffset:b.anchorOffset,focusNode:b.focusNode,focusOffset:b.focusOffset}),Xd&&Kd(Xd,b)||(Xd=b,b=gp(By,"onSelect"),0<b.length&&(h=new jd("onSelect","select",null,h,m),u.push({event:h,listeners:b}),h.target=sc)))}function fp(u,h){var m={};return m[u.toLowerCase()]=h.toLowerCase(),m["Webkit"+u]="webkit"+h,m["Moz"+u]="moz"+h,m}var oc={animationend:fp("Animation","AnimationEnd"),animationiteration:fp("Animation","AnimationIteration"),animationstart:fp("Animation","AnimationStart"),transitionend:fp("Transition","TransitionEnd")},Vy={},JC={};a&&(JC=document.createElement("div").style,"AnimationEvent"in window||(delete oc.animationend.animation,delete oc.animationiteration.animation,delete oc.animationstart.animation),"TransitionEvent"in window||delete oc.transitionend.transition);function pp(u){if(Vy[u])return Vy[u];if(!oc[u])return u;var h=oc[u],m;for(m in h)if(h.hasOwnProperty(m)&&m in JC)return Vy[u]=h[m];return u}var e$=pp("animationend"),t$=pp("animationiteration"),n$=pp("animationstart"),r$=pp("transitionend"),s$=new Map,o$="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Wa(u,h){s$.set(u,h),o(h,[u])}for(var Wy=0;Wy<o$.length;Wy++){var Uy=o$[Wy],m4=Uy.toLowerCase(),g4=Uy[0].toUpperCase()+Uy.slice(1);Wa(m4,"on"+g4)}Wa(e$,"onAnimationEnd"),Wa(t$,"onAnimationIteration"),Wa(n$,"onAnimationStart"),Wa("dblclick","onDoubleClick"),Wa("focusin","onFocus"),Wa("focusout","onBlur"),Wa(r$,"onTransitionEnd"),i("onMouseEnter",["mouseout","mouseover"]),i("onMouseLeave",["mouseout","mouseover"]),i("onPointerEnter",["pointerout","pointerover"]),i("onPointerLeave",["pointerout","pointerover"]),o("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),o("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),o("onBeforeInput",["compositionend","keypress","textInput","paste"]),o("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),o("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),o("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var qd="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),y4=new Set("cancel close invalid load scroll toggle".split(" ").concat(qd));function i$(u,h,m){var b=u.type||"unknown-event";u.currentTarget=m,Da(b,h,void 0,u),u.currentTarget=null}function a$(u,h){h=(h&4)!==0;for(var m=0;m<u.length;m++){var b=u[m],C=b.event;b=b.listeners;e:{var T=void 0;if(h)for(var D=b.length-1;0<=D;D--){var H=b[D],Q=H.instance,de=H.currentTarget;if(H=H.listener,Q!==T&&C.isPropagationStopped())break e;i$(C,H,de),T=Q}else for(D=0;D<b.length;D++){if(H=b[D],Q=H.instance,de=H.currentTarget,H=H.listener,Q!==T&&C.isPropagationStopped())break e;i$(C,H,de),T=Q}}}if(Xt)throw u=hr,Xt=!1,hr=null,u}function on(u,h){var m=h[Qy];m===void 0&&(m=h[Qy]=new Set);var b=u+"__bubble";m.has(b)||(l$(h,u,2,!1),m.add(b))}function jy(u,h,m){var b=0;h&&(b|=4),l$(m,u,b,h)}var mp="_reactListening"+Math.random().toString(36).slice(2);function Yd(u){if(!u[mp]){u[mp]=!0,r.forEach(function(m){m!=="selectionchange"&&(y4.has(m)||jy(m,!1,u),jy(m,!0,u))});var h=u.nodeType===9?u:u.ownerDocument;h===null||h[mp]||(h[mp]=!0,jy("selectionchange",!1,h))}}function l$(u,h,m,b){switch(Nt(h)){case 1:var C=ee;break;case 4:C=he;break;default:C=Fe}m=C.bind(null,h,m,u),C=void 0,!Us||h!=="touchstart"&&h!=="touchmove"&&h!=="wheel"||(C=!0),b?C!==void 0?u.addEventListener(h,m,{capture:!0,passive:C}):u.addEventListener(h,m,!0):C!==void 0?u.addEventListener(h,m,{passive:C}):u.addEventListener(h,m,!1)}function Gy(u,h,m,b,C){var T=b;if((h&1)===0&&(h&2)===0&&b!==null)e:for(;;){if(b===null)return;var D=b.tag;if(D===3||D===4){var H=b.stateNode.containerInfo;if(H===C||H.nodeType===8&&H.parentNode===C)break;if(D===4)for(D=b.return;D!==null;){var Q=D.tag;if((Q===3||Q===4)&&(Q=D.stateNode.containerInfo,Q===C||Q.nodeType===8&&Q.parentNode===C))return;D=D.return}for(;H!==null;){if(D=Gl(H),D===null)return;if(Q=D.tag,Q===5||Q===6){b=T=D;continue e}H=H.parentNode}}b=b.return}er(function(){var de=T,Se=$s(m),ke=[];e:{var be=s$.get(u);if(be!==void 0){var Le=jd,Me=u;switch(u){case"keypress":if(Or(m)===0)break e;case"keydown":case"keyup":Le=A;break;case"focusin":Me="focus",Le=Wl;break;case"focusout":Me="blur",Le=Wl;break;case"beforeblur":case"afterblur":Le=Wl;break;case"click":if(m.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":Le=op;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":Le=Ny;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":Le=Z;break;case e$:case t$:case n$:Le=_y;break;case r$:Le=Ce;break;case"scroll":Le=Gd;break;case"wheel":Le=Ze;break;case"copy":case"cut":case"paste":Le=nc;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":Le=G}var Ue=(h&4)!==0,Sn=!Ue&&u==="scroll",oe=Ue?be!==null?be+"Capture":null:be;Ue=[];for(var te=de,le;te!==null;){le=te;var Ie=le.stateNode;if(le.tag===5&&Ie!==null&&(le=Ie,oe!==null&&(Ie=Ni(te,oe),Ie!=null&&Ue.push(Qd(te,Ie,le)))),Sn)break;te=te.return}0<Ue.length&&(be=new Le(be,Me,null,m,Se),ke.push({event:be,listeners:Ue}))}}if((h&7)===0){e:{if(be=u==="mouseover"||u==="pointerover",Le=u==="mouseout"||u==="pointerout",be&&m!==Go&&(Me=m.relatedTarget||m.fromElement)&&(Gl(Me)||Me[Wi]))break e;if((Le||be)&&(be=Se.window===Se?Se:(be=Se.ownerDocument)?be.defaultView||be.parentWindow:window,Le?(Me=m.relatedTarget||m.toElement,Le=de,Me=Me?Gl(Me):null,Me!==null&&(Sn=Bn(Me),Me!==Sn||Me.tag!==5&&Me.tag!==6)&&(Me=null)):(Le=null,Me=de),Le!==Me)){if(Ue=op,Ie="onMouseLeave",oe="onMouseEnter",te="mouse",(u==="pointerout"||u==="pointerover")&&(Ue=G,Ie="onPointerLeave",oe="onPointerEnter",te="pointer"),Sn=Le==null?be:lc(Le),le=Me==null?be:lc(Me),be=new Ue(Ie,te+"leave",Le,m,Se),be.target=Sn,be.relatedTarget=le,Ie=null,Gl(Se)===de&&(Ue=new Ue(oe,te+"enter",Me,m,Se),Ue.target=le,Ue.relatedTarget=Sn,Ie=Ue),Sn=Ie,Le&&Me)t:{for(Ue=Le,oe=Me,te=0,le=Ue;le;le=ic(le))te++;for(le=0,Ie=oe;Ie;Ie=ic(Ie))le++;for(;0<te-le;)Ue=ic(Ue),te--;for(;0<le-te;)oe=ic(oe),le--;for(;te--;){if(Ue===oe||oe!==null&&Ue===oe.alternate)break t;Ue=ic(Ue),oe=ic(oe)}Ue=null}else Ue=null;Le!==null&&u$(ke,be,Le,Ue,!1),Me!==null&&Sn!==null&&u$(ke,Sn,Me,Ue,!0)}}e:{if(be=de?lc(de):window,Le=be.nodeName&&be.nodeName.toLowerCase(),Le==="select"||Le==="input"&&be.type==="file")var je=a4;else if(cp(be))if(jC)je=d4;else{je=u4;var Xe=l4}else(Le=be.nodeName)&&Le.toLowerCase()==="input"&&(be.type==="checkbox"||be.type==="radio")&&(je=c4);if(je&&(je=je(u,de))){dp(ke,je,m,Se);break e}Xe&&Xe(u,be,de),u==="focusout"&&(Xe=be._wrapperState)&&Xe.controlled&&be.type==="number"&&Na(be,"number",be.value)}switch(Xe=de?lc(de):window,u){case"focusin":(cp(Xe)||Xe.contentEditable==="true")&&(sc=Xe,By=de,Xd=null);break;case"focusout":Xd=By=sc=null;break;case"mousedown":My=!0;break;case"contextmenu":case"mouseup":case"dragend":My=!1,ZC(ke,m,Se);break;case"selectionchange":if(p4)break;case"keydown":case"keyup":ZC(ke,m,Se)}var qe;if(Ae)e:{switch(u){case"compositionstart":var st="onCompositionStart";break e;case"compositionend":st="onCompositionEnd";break e;case"compositionupdate":st="onCompositionUpdate";break e}st=void 0}else yt?Fr(u,m)&&(st="onCompositionEnd"):u==="keydown"&&m.keyCode===229&&(st="onCompositionStart");st&&(qt&&m.locale!=="ko"&&(yt||st!=="onCompositionStart"?st==="onCompositionEnd"&&yt&&(qe=Gn()):(at=Se,_t="value"in at?at.value:at.textContent,yt=!0)),Xe=gp(de,st),0<Xe.length&&(st=new ap(st,u,null,m,Se),ke.push({event:st,listeners:Xe}),qe?st.data=qe:(qe=rr(m),qe!==null&&(st.data=qe)))),(qe=ft?_n(u,m):Jo(u,m))&&(de=gp(de,"onBeforeInput"),0<de.length&&(Se=new ap("onBeforeInput","beforeinput",null,m,Se),ke.push({event:Se,listeners:de}),Se.data=qe))}a$(ke,h)})}function Qd(u,h,m){return{instance:u,listener:h,currentTarget:m}}function gp(u,h){for(var m=h+"Capture",b=[];u!==null;){var C=u,T=C.stateNode;C.tag===5&&T!==null&&(C=T,T=Ni(u,m),T!=null&&b.unshift(Qd(u,T,C)),T=Ni(u,h),T!=null&&b.push(Qd(u,T,C))),u=u.return}return b}function ic(u){if(u===null)return null;do u=u.return;while(u&&u.tag!==5);return u||null}function u$(u,h,m,b,C){for(var T=h._reactName,D=[];m!==null&&m!==b;){var H=m,Q=H.alternate,de=H.stateNode;if(Q!==null&&Q===b)break;H.tag===5&&de!==null&&(H=de,C?(Q=Ni(m,T),Q!=null&&D.unshift(Qd(m,Q,H))):C||(Q=Ni(m,T),Q!=null&&D.push(Qd(m,Q,H)))),m=m.return}D.length!==0&&u.push({event:h,listeners:D})}var x4=/\r\n?/g,v4=/\u0000|\uFFFD/g;function c$(u){return(typeof u=="string"?u:""+u).replace(x4,`
`).replace(v4,"")}function yp(u,h,m){if(h=c$(h),c$(u)!==h&&m)throw Error(n(425))}function xp(){}var Hy=null,Ky=null;function Xy(u,h){return u==="textarea"||u==="noscript"||typeof h.children=="string"||typeof h.children=="number"||typeof h.dangerouslySetInnerHTML=="object"&&h.dangerouslySetInnerHTML!==null&&h.dangerouslySetInnerHTML.__html!=null}var qy=typeof setTimeout=="function"?setTimeout:void 0,b4=typeof clearTimeout=="function"?clearTimeout:void 0,d$=typeof Promise=="function"?Promise:void 0,w4=typeof queueMicrotask=="function"?queueMicrotask:typeof d$<"u"?function(u){return d$.resolve(null).then(u).catch(S4)}:qy;function S4(u){setTimeout(function(){throw u})}function Yy(u,h){var m=h,b=0;do{var C=m.nextSibling;if(u.removeChild(m),C&&C.nodeType===8)if(m=C.data,m==="/$"){if(b===0){u.removeChild(C),So(h);return}b--}else m!=="$"&&m!=="$?"&&m!=="$!"||b++;m=C}while(m);So(h)}function Ua(u){for(;u!=null;u=u.nextSibling){var h=u.nodeType;if(h===1||h===3)break;if(h===8){if(h=u.data,h==="$"||h==="$!"||h==="$?")break;if(h==="/$")return null}}return u}function h$(u){u=u.previousSibling;for(var h=0;u;){if(u.nodeType===8){var m=u.data;if(m==="$"||m==="$!"||m==="$?"){if(h===0)return u;h--}else m==="/$"&&h++}u=u.previousSibling}return null}var ac=Math.random().toString(36).slice(2),ei="__reactFiber$"+ac,Zd="__reactProps$"+ac,Wi="__reactContainer$"+ac,Qy="__reactEvents$"+ac,C4="__reactListeners$"+ac,$4="__reactHandles$"+ac;function Gl(u){var h=u[ei];if(h)return h;for(var m=u.parentNode;m;){if(h=m[Wi]||m[ei]){if(m=h.alternate,h.child!==null||m!==null&&m.child!==null)for(u=h$(u);u!==null;){if(m=u[ei])return m;u=h$(u)}return h}u=m,m=u.parentNode}return null}function Jd(u){return u=u[ei]||u[Wi],!u||u.tag!==5&&u.tag!==6&&u.tag!==13&&u.tag!==3?null:u}function lc(u){if(u.tag===5||u.tag===6)return u.stateNode;throw Error(n(33))}function vp(u){return u[Zd]||null}var Zy=[],uc=-1;function ja(u){return{current:u}}function an(u){0>uc||(u.current=Zy[uc],Zy[uc]=null,uc--)}function Jt(u,h){uc++,Zy[uc]=u.current,u.current=h}var Ga={},mr=ja(Ga),rs=ja(!1),Hl=Ga;function cc(u,h){var m=u.type.contextTypes;if(!m)return Ga;var b=u.stateNode;if(b&&b.__reactInternalMemoizedUnmaskedChildContext===h)return b.__reactInternalMemoizedMaskedChildContext;var C={},T;for(T in m)C[T]=h[T];return b&&(u=u.stateNode,u.__reactInternalMemoizedUnmaskedChildContext=h,u.__reactInternalMemoizedMaskedChildContext=C),C}function ss(u){return u=u.childContextTypes,u!=null}function bp(){an(rs),an(mr)}function f$(u,h,m){if(mr.current!==Ga)throw Error(n(168));Jt(mr,h),Jt(rs,m)}function p$(u,h,m){var b=u.stateNode;if(h=h.childContextTypes,typeof b.getChildContext!="function")return m;b=b.getChildContext();for(var C in b)if(!(C in h))throw Error(n(108,Tt(u)||"Unknown",C));return ae({},m,b)}function wp(u){return u=(u=u.stateNode)&&u.__reactInternalMemoizedMergedChildContext||Ga,Hl=mr.current,Jt(mr,u),Jt(rs,rs.current),!0}function m$(u,h,m){var b=u.stateNode;if(!b)throw Error(n(169));m?(u=p$(u,h,Hl),b.__reactInternalMemoizedMergedChildContext=u,an(rs),an(mr),Jt(mr,u)):an(rs),Jt(rs,m)}var Ui=null,Sp=!1,Jy=!1;function g$(u){Ui===null?Ui=[u]:Ui.push(u)}function k4(u){Sp=!0,g$(u)}function Ha(){if(!Jy&&Ui!==null){Jy=!0;var u=0,h=St;try{var m=Ui;for(St=1;u<m.length;u++){var b=m[u];do b=b(!0);while(b!==null)}Ui=null,Sp=!1}catch(C){throw Ui!==null&&(Ui=Ui.slice(u+1)),Dl(vo,Ha),C}finally{St=h,Jy=!1}}return null}var dc=[],hc=0,Cp=null,$p=0,Hs=[],Ks=0,Kl=null,ji=1,Gi="";function Xl(u,h){dc[hc++]=$p,dc[hc++]=Cp,Cp=u,$p=h}function y$(u,h,m){Hs[Ks++]=ji,Hs[Ks++]=Gi,Hs[Ks++]=Kl,Kl=u;var b=ji;u=Gi;var C=32-fr(b)-1;b&=~(1<<C),m+=1;var T=32-fr(h)+C;if(30<T){var D=C-C%5;T=(b&(1<<D)-1).toString(32),b>>=D,C-=D,ji=1<<32-fr(h)+C|m<<C|b,Gi=T+u}else ji=1<<T|m<<C|b,Gi=u}function e0(u){u.return!==null&&(Xl(u,1),y$(u,1,0))}function t0(u){for(;u===Cp;)Cp=dc[--hc],dc[hc]=null,$p=dc[--hc],dc[hc]=null;for(;u===Kl;)Kl=Hs[--Ks],Hs[Ks]=null,Gi=Hs[--Ks],Hs[Ks]=null,ji=Hs[--Ks],Hs[Ks]=null}var Ts=null,Is=null,un=!1,ko=null;function x$(u,h){var m=Qs(5,null,null,0);m.elementType="DELETED",m.stateNode=h,m.return=u,h=u.deletions,h===null?(u.deletions=[m],u.flags|=16):h.push(m)}function v$(u,h){switch(u.tag){case 5:var m=u.type;return h=h.nodeType!==1||m.toLowerCase()!==h.nodeName.toLowerCase()?null:h,h!==null?(u.stateNode=h,Ts=u,Is=Ua(h.firstChild),!0):!1;case 6:return h=u.pendingProps===""||h.nodeType!==3?null:h,h!==null?(u.stateNode=h,Ts=u,Is=null,!0):!1;case 13:return h=h.nodeType!==8?null:h,h!==null?(m=Kl!==null?{id:ji,overflow:Gi}:null,u.memoizedState={dehydrated:h,treeContext:m,retryLane:1073741824},m=Qs(18,null,null,0),m.stateNode=h,m.return=u,u.child=m,Ts=u,Is=null,!0):!1;default:return!1}}function n0(u){return(u.mode&1)!==0&&(u.flags&128)===0}function r0(u){if(un){var h=Is;if(h){var m=h;if(!v$(u,h)){if(n0(u))throw Error(n(418));h=Ua(m.nextSibling);var b=Ts;h&&v$(u,h)?x$(b,m):(u.flags=u.flags&-4097|2,un=!1,Ts=u)}}else{if(n0(u))throw Error(n(418));u.flags=u.flags&-4097|2,un=!1,Ts=u}}}function b$(u){for(u=u.return;u!==null&&u.tag!==5&&u.tag!==3&&u.tag!==13;)u=u.return;Ts=u}function kp(u){if(u!==Ts)return!1;if(!un)return b$(u),un=!0,!1;var h;if((h=u.tag!==3)&&!(h=u.tag!==5)&&(h=u.type,h=h!=="head"&&h!=="body"&&!Xy(u.type,u.memoizedProps)),h&&(h=Is)){if(n0(u))throw w$(),Error(n(418));for(;h;)x$(u,h),h=Ua(h.nextSibling)}if(b$(u),u.tag===13){if(u=u.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(n(317));e:{for(u=u.nextSibling,h=0;u;){if(u.nodeType===8){var m=u.data;if(m==="/$"){if(h===0){Is=Ua(u.nextSibling);break e}h--}else m!=="$"&&m!=="$!"&&m!=="$?"||h++}u=u.nextSibling}Is=null}}else Is=Ts?Ua(u.stateNode.nextSibling):null;return!0}function w$(){for(var u=Is;u;)u=Ua(u.nextSibling)}function fc(){Is=Ts=null,un=!1}function s0(u){ko===null?ko=[u]:ko.push(u)}var T4=R.ReactCurrentBatchConfig;function eh(u,h,m){if(u=m.ref,u!==null&&typeof u!="function"&&typeof u!="object"){if(m._owner){if(m=m._owner,m){if(m.tag!==1)throw Error(n(309));var b=m.stateNode}if(!b)throw Error(n(147,u));var C=b,T=""+u;return h!==null&&h.ref!==null&&typeof h.ref=="function"&&h.ref._stringRef===T?h.ref:(h=function(D){var H=C.refs;D===null?delete H[T]:H[T]=D},h._stringRef=T,h)}if(typeof u!="string")throw Error(n(284));if(!m._owner)throw Error(n(290,u))}return u}function Tp(u,h){throw u=Object.prototype.toString.call(h),Error(n(31,u==="[object Object]"?"object with keys {"+Object.keys(h).join(", ")+"}":u))}function S$(u){var h=u._init;return h(u._payload)}function C$(u){function h(oe,te){if(u){var le=oe.deletions;le===null?(oe.deletions=[te],oe.flags|=16):le.push(te)}}function m(oe,te){if(!u)return null;for(;te!==null;)h(oe,te),te=te.sibling;return null}function b(oe,te){for(oe=new Map;te!==null;)te.key!==null?oe.set(te.key,te):oe.set(te.index,te),te=te.sibling;return oe}function C(oe,te){return oe=el(oe,te),oe.index=0,oe.sibling=null,oe}function T(oe,te,le){return oe.index=le,u?(le=oe.alternate,le!==null?(le=le.index,le<te?(oe.flags|=2,te):le):(oe.flags|=2,te)):(oe.flags|=1048576,te)}function D(oe){return u&&oe.alternate===null&&(oe.flags|=2),oe}function H(oe,te,le,Ie){return te===null||te.tag!==6?(te=q0(le,oe.mode,Ie),te.return=oe,te):(te=C(te,le),te.return=oe,te)}function Q(oe,te,le,Ie){var je=le.type;return je===F?Se(oe,te,le.props.children,Ie,le.key):te!==null&&(te.elementType===je||typeof je=="object"&&je!==null&&je.$$typeof===ve&&S$(je)===te.type)?(Ie=C(te,le.props),Ie.ref=eh(oe,te,le),Ie.return=oe,Ie):(Ie=Yp(le.type,le.key,le.props,null,oe.mode,Ie),Ie.ref=eh(oe,te,le),Ie.return=oe,Ie)}function de(oe,te,le,Ie){return te===null||te.tag!==4||te.stateNode.containerInfo!==le.containerInfo||te.stateNode.implementation!==le.implementation?(te=Y0(le,oe.mode,Ie),te.return=oe,te):(te=C(te,le.children||[]),te.return=oe,te)}function Se(oe,te,le,Ie,je){return te===null||te.tag!==7?(te=nu(le,oe.mode,Ie,je),te.return=oe,te):(te=C(te,le),te.return=oe,te)}function ke(oe,te,le){if(typeof te=="string"&&te!==""||typeof te=="number")return te=q0(""+te,oe.mode,le),te.return=oe,te;if(typeof te=="object"&&te!==null){switch(te.$$typeof){case _:return le=Yp(te.type,te.key,te.props,null,oe.mode,le),le.ref=eh(oe,null,te),le.return=oe,le;case O:return te=Y0(te,oe.mode,le),te.return=oe,te;case ve:var Ie=te._init;return ke(oe,Ie(te._payload),le)}if(ws(te)||xe(te))return te=nu(te,oe.mode,le,null),te.return=oe,te;Tp(oe,te)}return null}function be(oe,te,le,Ie){var je=te!==null?te.key:null;if(typeof le=="string"&&le!==""||typeof le=="number")return je!==null?null:H(oe,te,""+le,Ie);if(typeof le=="object"&&le!==null){switch(le.$$typeof){case _:return le.key===je?Q(oe,te,le,Ie):null;case O:return le.key===je?de(oe,te,le,Ie):null;case ve:return je=le._init,be(oe,te,je(le._payload),Ie)}if(ws(le)||xe(le))return je!==null?null:Se(oe,te,le,Ie,null);Tp(oe,le)}return null}function Le(oe,te,le,Ie,je){if(typeof Ie=="string"&&Ie!==""||typeof Ie=="number")return oe=oe.get(le)||null,H(te,oe,""+Ie,je);if(typeof Ie=="object"&&Ie!==null){switch(Ie.$$typeof){case _:return oe=oe.get(Ie.key===null?le:Ie.key)||null,Q(te,oe,Ie,je);case O:return oe=oe.get(Ie.key===null?le:Ie.key)||null,de(te,oe,Ie,je);case ve:var Xe=Ie._init;return Le(oe,te,le,Xe(Ie._payload),je)}if(ws(Ie)||xe(Ie))return oe=oe.get(le)||null,Se(te,oe,Ie,je,null);Tp(te,Ie)}return null}function Me(oe,te,le,Ie){for(var je=null,Xe=null,qe=te,st=te=0,Xn=null;qe!==null&&st<le.length;st++){qe.index>st?(Xn=qe,qe=null):Xn=qe.sibling;var Rt=be(oe,qe,le[st],Ie);if(Rt===null){qe===null&&(qe=Xn);break}u&&qe&&Rt.alternate===null&&h(oe,qe),te=T(Rt,te,st),Xe===null?je=Rt:Xe.sibling=Rt,Xe=Rt,qe=Xn}if(st===le.length)return m(oe,qe),un&&Xl(oe,st),je;if(qe===null){for(;st<le.length;st++)qe=ke(oe,le[st],Ie),qe!==null&&(te=T(qe,te,st),Xe===null?je=qe:Xe.sibling=qe,Xe=qe);return un&&Xl(oe,st),je}for(qe=b(oe,qe);st<le.length;st++)Xn=Le(qe,oe,st,le[st],Ie),Xn!==null&&(u&&Xn.alternate!==null&&qe.delete(Xn.key===null?st:Xn.key),te=T(Xn,te,st),Xe===null?je=Xn:Xe.sibling=Xn,Xe=Xn);return u&&qe.forEach(function(tl){return h(oe,tl)}),un&&Xl(oe,st),je}function Ue(oe,te,le,Ie){var je=xe(le);if(typeof je!="function")throw Error(n(150));if(le=je.call(le),le==null)throw Error(n(151));for(var Xe=je=null,qe=te,st=te=0,Xn=null,Rt=le.next();qe!==null&&!Rt.done;st++,Rt=le.next()){qe.index>st?(Xn=qe,qe=null):Xn=qe.sibling;var tl=be(oe,qe,Rt.value,Ie);if(tl===null){qe===null&&(qe=Xn);break}u&&qe&&tl.alternate===null&&h(oe,qe),te=T(tl,te,st),Xe===null?je=tl:Xe.sibling=tl,Xe=tl,qe=Xn}if(Rt.done)return m(oe,qe),un&&Xl(oe,st),je;if(qe===null){for(;!Rt.done;st++,Rt=le.next())Rt=ke(oe,Rt.value,Ie),Rt!==null&&(te=T(Rt,te,st),Xe===null?je=Rt:Xe.sibling=Rt,Xe=Rt);return un&&Xl(oe,st),je}for(qe=b(oe,qe);!Rt.done;st++,Rt=le.next())Rt=Le(qe,oe,st,Rt.value,Ie),Rt!==null&&(u&&Rt.alternate!==null&&qe.delete(Rt.key===null?st:Rt.key),te=T(Rt,te,st),Xe===null?je=Rt:Xe.sibling=Rt,Xe=Rt);return u&&qe.forEach(function(oL){return h(oe,oL)}),un&&Xl(oe,st),je}function Sn(oe,te,le,Ie){if(typeof le=="object"&&le!==null&&le.type===F&&le.key===null&&(le=le.props.children),typeof le=="object"&&le!==null){switch(le.$$typeof){case _:e:{for(var je=le.key,Xe=te;Xe!==null;){if(Xe.key===je){if(je=le.type,je===F){if(Xe.tag===7){m(oe,Xe.sibling),te=C(Xe,le.props.children),te.return=oe,oe=te;break e}}else if(Xe.elementType===je||typeof je=="object"&&je!==null&&je.$$typeof===ve&&S$(je)===Xe.type){m(oe,Xe.sibling),te=C(Xe,le.props),te.ref=eh(oe,Xe,le),te.return=oe,oe=te;break e}m(oe,Xe);break}else h(oe,Xe);Xe=Xe.sibling}le.type===F?(te=nu(le.props.children,oe.mode,Ie,le.key),te.return=oe,oe=te):(Ie=Yp(le.type,le.key,le.props,null,oe.mode,Ie),Ie.ref=eh(oe,te,le),Ie.return=oe,oe=Ie)}return D(oe);case O:e:{for(Xe=le.key;te!==null;){if(te.key===Xe)if(te.tag===4&&te.stateNode.containerInfo===le.containerInfo&&te.stateNode.implementation===le.implementation){m(oe,te.sibling),te=C(te,le.children||[]),te.return=oe,oe=te;break e}else{m(oe,te);break}else h(oe,te);te=te.sibling}te=Y0(le,oe.mode,Ie),te.return=oe,oe=te}return D(oe);case ve:return Xe=le._init,Sn(oe,te,Xe(le._payload),Ie)}if(ws(le))return Me(oe,te,le,Ie);if(xe(le))return Ue(oe,te,le,Ie);Tp(oe,le)}return typeof le=="string"&&le!==""||typeof le=="number"?(le=""+le,te!==null&&te.tag===6?(m(oe,te.sibling),te=C(te,le),te.return=oe,oe=te):(m(oe,te),te=q0(le,oe.mode,Ie),te.return=oe,oe=te),D(oe)):m(oe,te)}return Sn}var pc=C$(!0),$$=C$(!1),Ip=ja(null),Np=null,mc=null,o0=null;function i0(){o0=mc=Np=null}function a0(u){var h=Ip.current;an(Ip),u._currentValue=h}function l0(u,h,m){for(;u!==null;){var b=u.alternate;if((u.childLanes&h)!==h?(u.childLanes|=h,b!==null&&(b.childLanes|=h)):b!==null&&(b.childLanes&h)!==h&&(b.childLanes|=h),u===m)break;u=u.return}}function gc(u,h){Np=u,o0=mc=null,u=u.dependencies,u!==null&&u.firstContext!==null&&((u.lanes&h)!==0&&(os=!0),u.firstContext=null)}function Xs(u){var h=u._currentValue;if(o0!==u)if(u={context:u,memoizedValue:h,next:null},mc===null){if(Np===null)throw Error(n(308));mc=u,Np.dependencies={lanes:0,firstContext:u}}else mc=mc.next=u;return h}var ql=null;function u0(u){ql===null?ql=[u]:ql.push(u)}function k$(u,h,m,b){var C=h.interleaved;return C===null?(m.next=m,u0(h)):(m.next=C.next,C.next=m),h.interleaved=m,Hi(u,b)}function Hi(u,h){u.lanes|=h;var m=u.alternate;for(m!==null&&(m.lanes|=h),m=u,u=u.return;u!==null;)u.childLanes|=h,m=u.alternate,m!==null&&(m.childLanes|=h),m=u,u=u.return;return m.tag===3?m.stateNode:null}var Ka=!1;function c0(u){u.updateQueue={baseState:u.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function T$(u,h){u=u.updateQueue,h.updateQueue===u&&(h.updateQueue={baseState:u.baseState,firstBaseUpdate:u.firstBaseUpdate,lastBaseUpdate:u.lastBaseUpdate,shared:u.shared,effects:u.effects})}function Ki(u,h){return{eventTime:u,lane:h,tag:0,payload:null,callback:null,next:null}}function Xa(u,h,m){var b=u.updateQueue;if(b===null)return null;if(b=b.shared,(Et&2)!==0){var C=b.pending;return C===null?h.next=h:(h.next=C.next,C.next=h),b.pending=h,Hi(u,m)}return C=b.interleaved,C===null?(h.next=h,u0(b)):(h.next=C.next,C.next=h),b.interleaved=h,Hi(u,m)}function Ep(u,h,m){if(h=h.updateQueue,h!==null&&(h=h.shared,(m&4194240)!==0)){var b=h.lanes;b&=u.pendingLanes,m|=b,h.lanes=m,Ll(u,m)}}function I$(u,h){var m=u.updateQueue,b=u.alternate;if(b!==null&&(b=b.updateQueue,m===b)){var C=null,T=null;if(m=m.firstBaseUpdate,m!==null){do{var D={eventTime:m.eventTime,lane:m.lane,tag:m.tag,payload:m.payload,callback:m.callback,next:null};T===null?C=T=D:T=T.next=D,m=m.next}while(m!==null);T===null?C=T=h:T=T.next=h}else C=T=h;m={baseState:b.baseState,firstBaseUpdate:C,lastBaseUpdate:T,shared:b.shared,effects:b.effects},u.updateQueue=m;return}u=m.lastBaseUpdate,u===null?m.firstBaseUpdate=h:u.next=h,m.lastBaseUpdate=h}function Rp(u,h,m,b){var C=u.updateQueue;Ka=!1;var T=C.firstBaseUpdate,D=C.lastBaseUpdate,H=C.shared.pending;if(H!==null){C.shared.pending=null;var Q=H,de=Q.next;Q.next=null,D===null?T=de:D.next=de,D=Q;var Se=u.alternate;Se!==null&&(Se=Se.updateQueue,H=Se.lastBaseUpdate,H!==D&&(H===null?Se.firstBaseUpdate=de:H.next=de,Se.lastBaseUpdate=Q))}if(T!==null){var ke=C.baseState;D=0,Se=de=Q=null,H=T;do{var be=H.lane,Le=H.eventTime;if((b&be)===be){Se!==null&&(Se=Se.next={eventTime:Le,lane:0,tag:H.tag,payload:H.payload,callback:H.callback,next:null});e:{var Me=u,Ue=H;switch(be=h,Le=m,Ue.tag){case 1:if(Me=Ue.payload,typeof Me=="function"){ke=Me.call(Le,ke,be);break e}ke=Me;break e;case 3:Me.flags=Me.flags&-65537|128;case 0:if(Me=Ue.payload,be=typeof Me=="function"?Me.call(Le,ke,be):Me,be==null)break e;ke=ae({},ke,be);break e;case 2:Ka=!0}}H.callback!==null&&H.lane!==0&&(u.flags|=64,be=C.effects,be===null?C.effects=[H]:be.push(H))}else Le={eventTime:Le,lane:be,tag:H.tag,payload:H.payload,callback:H.callback,next:null},Se===null?(de=Se=Le,Q=ke):Se=Se.next=Le,D|=be;if(H=H.next,H===null){if(H=C.shared.pending,H===null)break;be=H,H=be.next,be.next=null,C.lastBaseUpdate=be,C.shared.pending=null}}while(!0);if(Se===null&&(Q=ke),C.baseState=Q,C.firstBaseUpdate=de,C.lastBaseUpdate=Se,h=C.shared.interleaved,h!==null){C=h;do D|=C.lane,C=C.next;while(C!==h)}else T===null&&(C.shared.lanes=0);Zl|=D,u.lanes=D,u.memoizedState=ke}}function N$(u,h,m){if(u=h.effects,h.effects=null,u!==null)for(h=0;h<u.length;h++){var b=u[h],C=b.callback;if(C!==null){if(b.callback=null,b=m,typeof C!="function")throw Error(n(191,C));C.call(b)}}}var th={},ti=ja(th),nh=ja(th),rh=ja(th);function Yl(u){if(u===th)throw Error(n(174));return u}function d0(u,h){switch(Jt(rh,h),Jt(nh,u),Jt(ti,th),u=h.nodeType,u){case 9:case 11:h=(h=h.documentElement)?h.namespaceURI:Ii(null,"");break;default:u=u===8?h.parentNode:h,h=u.namespaceURI||null,u=u.tagName,h=Ii(h,u)}an(ti),Jt(ti,h)}function yc(){an(ti),an(nh),an(rh)}function E$(u){Yl(rh.current);var h=Yl(ti.current),m=Ii(h,u.type);h!==m&&(Jt(nh,u),Jt(ti,m))}function h0(u){nh.current===u&&(an(ti),an(nh))}var dn=ja(0);function _p(u){for(var h=u;h!==null;){if(h.tag===13){var m=h.memoizedState;if(m!==null&&(m=m.dehydrated,m===null||m.data==="$?"||m.data==="$!"))return h}else if(h.tag===19&&h.memoizedProps.revealOrder!==void 0){if((h.flags&128)!==0)return h}else if(h.child!==null){h.child.return=h,h=h.child;continue}if(h===u)break;for(;h.sibling===null;){if(h.return===null||h.return===u)return null;h=h.return}h.sibling.return=h.return,h=h.sibling}return null}var f0=[];function p0(){for(var u=0;u<f0.length;u++)f0[u]._workInProgressVersionPrimary=null;f0.length=0}var Pp=R.ReactCurrentDispatcher,m0=R.ReactCurrentBatchConfig,Ql=0,hn=null,Pn=null,Hn=null,Ap=!1,sh=!1,oh=0,I4=0;function gr(){throw Error(n(321))}function g0(u,h){if(h===null)return!1;for(var m=0;m<h.length&&m<u.length;m++)if(!$o(u[m],h[m]))return!1;return!0}function y0(u,h,m,b,C,T){if(Ql=T,hn=h,h.memoizedState=null,h.updateQueue=null,h.lanes=0,Pp.current=u===null||u.memoizedState===null?_4:P4,u=m(b,C),sh){T=0;do{if(sh=!1,oh=0,25<=T)throw Error(n(301));T+=1,Hn=Pn=null,h.updateQueue=null,Pp.current=A4,u=m(b,C)}while(sh)}if(Pp.current=Fp,h=Pn!==null&&Pn.next!==null,Ql=0,Hn=Pn=hn=null,Ap=!1,h)throw Error(n(300));return u}function x0(){var u=oh!==0;return oh=0,u}function ni(){var u={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Hn===null?hn.memoizedState=Hn=u:Hn=Hn.next=u,Hn}function qs(){if(Pn===null){var u=hn.alternate;u=u!==null?u.memoizedState:null}else u=Pn.next;var h=Hn===null?hn.memoizedState:Hn.next;if(h!==null)Hn=h,Pn=u;else{if(u===null)throw Error(n(310));Pn=u,u={memoizedState:Pn.memoizedState,baseState:Pn.baseState,baseQueue:Pn.baseQueue,queue:Pn.queue,next:null},Hn===null?hn.memoizedState=Hn=u:Hn=Hn.next=u}return Hn}function ih(u,h){return typeof h=="function"?h(u):h}function v0(u){var h=qs(),m=h.queue;if(m===null)throw Error(n(311));m.lastRenderedReducer=u;var b=Pn,C=b.baseQueue,T=m.pending;if(T!==null){if(C!==null){var D=C.next;C.next=T.next,T.next=D}b.baseQueue=C=T,m.pending=null}if(C!==null){T=C.next,b=b.baseState;var H=D=null,Q=null,de=T;do{var Se=de.lane;if((Ql&Se)===Se)Q!==null&&(Q=Q.next={lane:0,action:de.action,hasEagerState:de.hasEagerState,eagerState:de.eagerState,next:null}),b=de.hasEagerState?de.eagerState:u(b,de.action);else{var ke={lane:Se,action:de.action,hasEagerState:de.hasEagerState,eagerState:de.eagerState,next:null};Q===null?(H=Q=ke,D=b):Q=Q.next=ke,hn.lanes|=Se,Zl|=Se}de=de.next}while(de!==null&&de!==T);Q===null?D=b:Q.next=H,$o(b,h.memoizedState)||(os=!0),h.memoizedState=b,h.baseState=D,h.baseQueue=Q,m.lastRenderedState=b}if(u=m.interleaved,u!==null){C=u;do T=C.lane,hn.lanes|=T,Zl|=T,C=C.next;while(C!==u)}else C===null&&(m.lanes=0);return[h.memoizedState,m.dispatch]}function b0(u){var h=qs(),m=h.queue;if(m===null)throw Error(n(311));m.lastRenderedReducer=u;var b=m.dispatch,C=m.pending,T=h.memoizedState;if(C!==null){m.pending=null;var D=C=C.next;do T=u(T,D.action),D=D.next;while(D!==C);$o(T,h.memoizedState)||(os=!0),h.memoizedState=T,h.baseQueue===null&&(h.baseState=T),m.lastRenderedState=T}return[T,b]}function R$(){}function _$(u,h){var m=hn,b=qs(),C=h(),T=!$o(b.memoizedState,C);if(T&&(b.memoizedState=C,os=!0),b=b.queue,w0(D$.bind(null,m,b,u),[u]),b.getSnapshot!==h||T||Hn!==null&&Hn.memoizedState.tag&1){if(m.flags|=2048,ah(9,A$.bind(null,m,b,C,h),void 0,null),Kn===null)throw Error(n(349));(Ql&30)!==0||P$(m,h,C)}return C}function P$(u,h,m){u.flags|=16384,u={getSnapshot:h,value:m},h=hn.updateQueue,h===null?(h={lastEffect:null,stores:null},hn.updateQueue=h,h.stores=[u]):(m=h.stores,m===null?h.stores=[u]:m.push(u))}function A$(u,h,m,b){h.value=m,h.getSnapshot=b,O$(h)&&F$(u)}function D$(u,h,m){return m(function(){O$(h)&&F$(u)})}function O$(u){var h=u.getSnapshot;u=u.value;try{var m=h();return!$o(u,m)}catch{return!0}}function F$(u){var h=Hi(u,1);h!==null&&Eo(h,u,1,-1)}function L$(u){var h=ni();return typeof u=="function"&&(u=u()),h.memoizedState=h.baseState=u,u={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:ih,lastRenderedState:u},h.queue=u,u=u.dispatch=R4.bind(null,hn,u),[h.memoizedState,u]}function ah(u,h,m,b){return u={tag:u,create:h,destroy:m,deps:b,next:null},h=hn.updateQueue,h===null?(h={lastEffect:null,stores:null},hn.updateQueue=h,h.lastEffect=u.next=u):(m=h.lastEffect,m===null?h.lastEffect=u.next=u:(b=m.next,m.next=u,u.next=b,h.lastEffect=u)),u}function z$(){return qs().memoizedState}function Dp(u,h,m,b){var C=ni();hn.flags|=u,C.memoizedState=ah(1|h,m,void 0,b===void 0?null:b)}function Op(u,h,m,b){var C=qs();b=b===void 0?null:b;var T=void 0;if(Pn!==null){var D=Pn.memoizedState;if(T=D.destroy,b!==null&&g0(b,D.deps)){C.memoizedState=ah(h,m,T,b);return}}hn.flags|=u,C.memoizedState=ah(1|h,m,T,b)}function B$(u,h){return Dp(8390656,8,u,h)}function w0(u,h){return Op(2048,8,u,h)}function M$(u,h){return Op(4,2,u,h)}function V$(u,h){return Op(4,4,u,h)}function W$(u,h){if(typeof h=="function")return u=u(),h(u),function(){h(null)};if(h!=null)return u=u(),h.current=u,function(){h.current=null}}function U$(u,h,m){return m=m!=null?m.concat([u]):null,Op(4,4,W$.bind(null,h,u),m)}function S0(){}function j$(u,h){var m=qs();h=h===void 0?null:h;var b=m.memoizedState;return b!==null&&h!==null&&g0(h,b[1])?b[0]:(m.memoizedState=[u,h],u)}function G$(u,h){var m=qs();h=h===void 0?null:h;var b=m.memoizedState;return b!==null&&h!==null&&g0(h,b[1])?b[0]:(u=u(),m.memoizedState=[u,h],u)}function H$(u,h,m){return(Ql&21)===0?(u.baseState&&(u.baseState=!1,os=!0),u.memoizedState=m):($o(m,h)||(m=Fi(),hn.lanes|=m,Zl|=m,u.baseState=!0),h)}function N4(u,h){var m=St;St=m!==0&&4>m?m:4,u(!0);var b=m0.transition;m0.transition={};try{u(!1),h()}finally{St=m,m0.transition=b}}function K$(){return qs().memoizedState}function E4(u,h,m){var b=Za(u);if(m={lane:b,action:m,hasEagerState:!1,eagerState:null,next:null},X$(u))q$(h,m);else if(m=k$(u,h,m,b),m!==null){var C=zr();Eo(m,u,b,C),Y$(m,h,b)}}function R4(u,h,m){var b=Za(u),C={lane:b,action:m,hasEagerState:!1,eagerState:null,next:null};if(X$(u))q$(h,C);else{var T=u.alternate;if(u.lanes===0&&(T===null||T.lanes===0)&&(T=h.lastRenderedReducer,T!==null))try{var D=h.lastRenderedState,H=T(D,m);if(C.hasEagerState=!0,C.eagerState=H,$o(H,D)){var Q=h.interleaved;Q===null?(C.next=C,u0(h)):(C.next=Q.next,Q.next=C),h.interleaved=C;return}}catch{}finally{}m=k$(u,h,C,b),m!==null&&(C=zr(),Eo(m,u,b,C),Y$(m,h,b))}}function X$(u){var h=u.alternate;return u===hn||h!==null&&h===hn}function q$(u,h){sh=Ap=!0;var m=u.pending;m===null?h.next=h:(h.next=m.next,m.next=h),u.pending=h}function Y$(u,h,m){if((m&4194240)!==0){var b=h.lanes;b&=u.pendingLanes,m|=b,h.lanes=m,Ll(u,m)}}var Fp={readContext:Xs,useCallback:gr,useContext:gr,useEffect:gr,useImperativeHandle:gr,useInsertionEffect:gr,useLayoutEffect:gr,useMemo:gr,useReducer:gr,useRef:gr,useState:gr,useDebugValue:gr,useDeferredValue:gr,useTransition:gr,useMutableSource:gr,useSyncExternalStore:gr,useId:gr,unstable_isNewReconciler:!1},_4={readContext:Xs,useCallback:function(u,h){return ni().memoizedState=[u,h===void 0?null:h],u},useContext:Xs,useEffect:B$,useImperativeHandle:function(u,h,m){return m=m!=null?m.concat([u]):null,Dp(4194308,4,W$.bind(null,h,u),m)},useLayoutEffect:function(u,h){return Dp(4194308,4,u,h)},useInsertionEffect:function(u,h){return Dp(4,2,u,h)},useMemo:function(u,h){var m=ni();return h=h===void 0?null:h,u=u(),m.memoizedState=[u,h],u},useReducer:function(u,h,m){var b=ni();return h=m!==void 0?m(h):h,b.memoizedState=b.baseState=h,u={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:u,lastRenderedState:h},b.queue=u,u=u.dispatch=E4.bind(null,hn,u),[b.memoizedState,u]},useRef:function(u){var h=ni();return u={current:u},h.memoizedState=u},useState:L$,useDebugValue:S0,useDeferredValue:function(u){return ni().memoizedState=u},useTransition:function(){var u=L$(!1),h=u[0];return u=N4.bind(null,u[1]),ni().memoizedState=u,[h,u]},useMutableSource:function(){},useSyncExternalStore:function(u,h,m){var b=hn,C=ni();if(un){if(m===void 0)throw Error(n(407));m=m()}else{if(m=h(),Kn===null)throw Error(n(349));(Ql&30)!==0||P$(b,h,m)}C.memoizedState=m;var T={value:m,getSnapshot:h};return C.queue=T,B$(D$.bind(null,b,T,u),[u]),b.flags|=2048,ah(9,A$.bind(null,b,T,m,h),void 0,null),m},useId:function(){var u=ni(),h=Kn.identifierPrefix;if(un){var m=Gi,b=ji;m=(b&~(1<<32-fr(b)-1)).toString(32)+m,h=":"+h+"R"+m,m=oh++,0<m&&(h+="H"+m.toString(32)),h+=":"}else m=I4++,h=":"+h+"r"+m.toString(32)+":";return u.memoizedState=h},unstable_isNewReconciler:!1},P4={readContext:Xs,useCallback:j$,useContext:Xs,useEffect:w0,useImperativeHandle:U$,useInsertionEffect:M$,useLayoutEffect:V$,useMemo:G$,useReducer:v0,useRef:z$,useState:function(){return v0(ih)},useDebugValue:S0,useDeferredValue:function(u){var h=qs();return H$(h,Pn.memoizedState,u)},useTransition:function(){var u=v0(ih)[0],h=qs().memoizedState;return[u,h]},useMutableSource:R$,useSyncExternalStore:_$,useId:K$,unstable_isNewReconciler:!1},A4={readContext:Xs,useCallback:j$,useContext:Xs,useEffect:w0,useImperativeHandle:U$,useInsertionEffect:M$,useLayoutEffect:V$,useMemo:G$,useReducer:b0,useRef:z$,useState:function(){return b0(ih)},useDebugValue:S0,useDeferredValue:function(u){var h=qs();return Pn===null?h.memoizedState=u:H$(h,Pn.memoizedState,u)},useTransition:function(){var u=b0(ih)[0],h=qs().memoizedState;return[u,h]},useMutableSource:R$,useSyncExternalStore:_$,useId:K$,unstable_isNewReconciler:!1};function To(u,h){if(u&&u.defaultProps){h=ae({},h),u=u.defaultProps;for(var m in u)h[m]===void 0&&(h[m]=u[m]);return h}return h}function C0(u,h,m,b){h=u.memoizedState,m=m(b,h),m=m==null?h:ae({},h,m),u.memoizedState=m,u.lanes===0&&(u.updateQueue.baseState=m)}var Lp={isMounted:function(u){return(u=u._reactInternals)?Bn(u)===u:!1},enqueueSetState:function(u,h,m){u=u._reactInternals;var b=zr(),C=Za(u),T=Ki(b,C);T.payload=h,m!=null&&(T.callback=m),h=Xa(u,T,C),h!==null&&(Eo(h,u,C,b),Ep(h,u,C))},enqueueReplaceState:function(u,h,m){u=u._reactInternals;var b=zr(),C=Za(u),T=Ki(b,C);T.tag=1,T.payload=h,m!=null&&(T.callback=m),h=Xa(u,T,C),h!==null&&(Eo(h,u,C,b),Ep(h,u,C))},enqueueForceUpdate:function(u,h){u=u._reactInternals;var m=zr(),b=Za(u),C=Ki(m,b);C.tag=2,h!=null&&(C.callback=h),h=Xa(u,C,b),h!==null&&(Eo(h,u,b,m),Ep(h,u,b))}};function Q$(u,h,m,b,C,T,D){return u=u.stateNode,typeof u.shouldComponentUpdate=="function"?u.shouldComponentUpdate(b,T,D):h.prototype&&h.prototype.isPureReactComponent?!Kd(m,b)||!Kd(C,T):!0}function Z$(u,h,m){var b=!1,C=Ga,T=h.contextType;return typeof T=="object"&&T!==null?T=Xs(T):(C=ss(h)?Hl:mr.current,b=h.contextTypes,T=(b=b!=null)?cc(u,C):Ga),h=new h(m,T),u.memoizedState=h.state!==null&&h.state!==void 0?h.state:null,h.updater=Lp,u.stateNode=h,h._reactInternals=u,b&&(u=u.stateNode,u.__reactInternalMemoizedUnmaskedChildContext=C,u.__reactInternalMemoizedMaskedChildContext=T),h}function J$(u,h,m,b){u=h.state,typeof h.componentWillReceiveProps=="function"&&h.componentWillReceiveProps(m,b),typeof h.UNSAFE_componentWillReceiveProps=="function"&&h.UNSAFE_componentWillReceiveProps(m,b),h.state!==u&&Lp.enqueueReplaceState(h,h.state,null)}function $0(u,h,m,b){var C=u.stateNode;C.props=m,C.state=u.memoizedState,C.refs={},c0(u);var T=h.contextType;typeof T=="object"&&T!==null?C.context=Xs(T):(T=ss(h)?Hl:mr.current,C.context=cc(u,T)),C.state=u.memoizedState,T=h.getDerivedStateFromProps,typeof T=="function"&&(C0(u,h,T,m),C.state=u.memoizedState),typeof h.getDerivedStateFromProps=="function"||typeof C.getSnapshotBeforeUpdate=="function"||typeof C.UNSAFE_componentWillMount!="function"&&typeof C.componentWillMount!="function"||(h=C.state,typeof C.componentWillMount=="function"&&C.componentWillMount(),typeof C.UNSAFE_componentWillMount=="function"&&C.UNSAFE_componentWillMount(),h!==C.state&&Lp.enqueueReplaceState(C,C.state,null),Rp(u,m,C,b),C.state=u.memoizedState),typeof C.componentDidMount=="function"&&(u.flags|=4194308)}function xc(u,h){try{var m="",b=h;do m+=et(b),b=b.return;while(b);var C=m}catch(T){C=`
Error generating stack: `+T.message+`
`+T.stack}return{value:u,source:h,stack:C,digest:null}}function k0(u,h,m){return{value:u,source:null,stack:m??null,digest:h??null}}function T0(u,h){try{console.error(h.value)}catch(m){setTimeout(function(){throw m})}}var D4=typeof WeakMap=="function"?WeakMap:Map;function ek(u,h,m){m=Ki(-1,m),m.tag=3,m.payload={element:null};var b=h.value;return m.callback=function(){jp||(jp=!0,V0=b),T0(u,h)},m}function tk(u,h,m){m=Ki(-1,m),m.tag=3;var b=u.type.getDerivedStateFromError;if(typeof b=="function"){var C=h.value;m.payload=function(){return b(C)},m.callback=function(){T0(u,h)}}var T=u.stateNode;return T!==null&&typeof T.componentDidCatch=="function"&&(m.callback=function(){T0(u,h),typeof b!="function"&&(Ya===null?Ya=new Set([this]):Ya.add(this));var D=h.stack;this.componentDidCatch(h.value,{componentStack:D!==null?D:""})}),m}function nk(u,h,m){var b=u.pingCache;if(b===null){b=u.pingCache=new D4;var C=new Set;b.set(h,C)}else C=b.get(h),C===void 0&&(C=new Set,b.set(h,C));C.has(m)||(C.add(m),u=X4.bind(null,u,h,m),h.then(u,u))}function rk(u){do{var h;if((h=u.tag===13)&&(h=u.memoizedState,h=h!==null?h.dehydrated!==null:!0),h)return u;u=u.return}while(u!==null);return null}function sk(u,h,m,b,C){return(u.mode&1)===0?(u===h?u.flags|=65536:(u.flags|=128,m.flags|=131072,m.flags&=-52805,m.tag===1&&(m.alternate===null?m.tag=17:(h=Ki(-1,1),h.tag=2,Xa(m,h,1))),m.lanes|=1),u):(u.flags|=65536,u.lanes=C,u)}var O4=R.ReactCurrentOwner,os=!1;function Lr(u,h,m,b){h.child=u===null?$$(h,null,m,b):pc(h,u.child,m,b)}function ok(u,h,m,b,C){m=m.render;var T=h.ref;return gc(h,C),b=y0(u,h,m,b,T,C),m=x0(),u!==null&&!os?(h.updateQueue=u.updateQueue,h.flags&=-2053,u.lanes&=~C,Xi(u,h,C)):(un&&m&&e0(h),h.flags|=1,Lr(u,h,b,C),h.child)}function ik(u,h,m,b,C){if(u===null){var T=m.type;return typeof T=="function"&&!X0(T)&&T.defaultProps===void 0&&m.compare===null&&m.defaultProps===void 0?(h.tag=15,h.type=T,ak(u,h,T,b,C)):(u=Yp(m.type,null,b,h,h.mode,C),u.ref=h.ref,u.return=h,h.child=u)}if(T=u.child,(u.lanes&C)===0){var D=T.memoizedProps;if(m=m.compare,m=m!==null?m:Kd,m(D,b)&&u.ref===h.ref)return Xi(u,h,C)}return h.flags|=1,u=el(T,b),u.ref=h.ref,u.return=h,h.child=u}function ak(u,h,m,b,C){if(u!==null){var T=u.memoizedProps;if(Kd(T,b)&&u.ref===h.ref)if(os=!1,h.pendingProps=b=T,(u.lanes&C)!==0)(u.flags&131072)!==0&&(os=!0);else return h.lanes=u.lanes,Xi(u,h,C)}return I0(u,h,m,b,C)}function lk(u,h,m){var b=h.pendingProps,C=b.children,T=u!==null?u.memoizedState:null;if(b.mode==="hidden")if((h.mode&1)===0)h.memoizedState={baseLanes:0,cachePool:null,transitions:null},Jt(bc,Ns),Ns|=m;else{if((m&1073741824)===0)return u=T!==null?T.baseLanes|m:m,h.lanes=h.childLanes=1073741824,h.memoizedState={baseLanes:u,cachePool:null,transitions:null},h.updateQueue=null,Jt(bc,Ns),Ns|=u,null;h.memoizedState={baseLanes:0,cachePool:null,transitions:null},b=T!==null?T.baseLanes:m,Jt(bc,Ns),Ns|=b}else T!==null?(b=T.baseLanes|m,h.memoizedState=null):b=m,Jt(bc,Ns),Ns|=b;return Lr(u,h,C,m),h.child}function uk(u,h){var m=h.ref;(u===null&&m!==null||u!==null&&u.ref!==m)&&(h.flags|=512,h.flags|=2097152)}function I0(u,h,m,b,C){var T=ss(m)?Hl:mr.current;return T=cc(h,T),gc(h,C),m=y0(u,h,m,b,T,C),b=x0(),u!==null&&!os?(h.updateQueue=u.updateQueue,h.flags&=-2053,u.lanes&=~C,Xi(u,h,C)):(un&&b&&e0(h),h.flags|=1,Lr(u,h,m,C),h.child)}function ck(u,h,m,b,C){if(ss(m)){var T=!0;wp(h)}else T=!1;if(gc(h,C),h.stateNode===null)Bp(u,h),Z$(h,m,b),$0(h,m,b,C),b=!0;else if(u===null){var D=h.stateNode,H=h.memoizedProps;D.props=H;var Q=D.context,de=m.contextType;typeof de=="object"&&de!==null?de=Xs(de):(de=ss(m)?Hl:mr.current,de=cc(h,de));var Se=m.getDerivedStateFromProps,ke=typeof Se=="function"||typeof D.getSnapshotBeforeUpdate=="function";ke||typeof D.UNSAFE_componentWillReceiveProps!="function"&&typeof D.componentWillReceiveProps!="function"||(H!==b||Q!==de)&&J$(h,D,b,de),Ka=!1;var be=h.memoizedState;D.state=be,Rp(h,b,D,C),Q=h.memoizedState,H!==b||be!==Q||rs.current||Ka?(typeof Se=="function"&&(C0(h,m,Se,b),Q=h.memoizedState),(H=Ka||Q$(h,m,H,b,be,Q,de))?(ke||typeof D.UNSAFE_componentWillMount!="function"&&typeof D.componentWillMount!="function"||(typeof D.componentWillMount=="function"&&D.componentWillMount(),typeof D.UNSAFE_componentWillMount=="function"&&D.UNSAFE_componentWillMount()),typeof D.componentDidMount=="function"&&(h.flags|=4194308)):(typeof D.componentDidMount=="function"&&(h.flags|=4194308),h.memoizedProps=b,h.memoizedState=Q),D.props=b,D.state=Q,D.context=de,b=H):(typeof D.componentDidMount=="function"&&(h.flags|=4194308),b=!1)}else{D=h.stateNode,T$(u,h),H=h.memoizedProps,de=h.type===h.elementType?H:To(h.type,H),D.props=de,ke=h.pendingProps,be=D.context,Q=m.contextType,typeof Q=="object"&&Q!==null?Q=Xs(Q):(Q=ss(m)?Hl:mr.current,Q=cc(h,Q));var Le=m.getDerivedStateFromProps;(Se=typeof Le=="function"||typeof D.getSnapshotBeforeUpdate=="function")||typeof D.UNSAFE_componentWillReceiveProps!="function"&&typeof D.componentWillReceiveProps!="function"||(H!==ke||be!==Q)&&J$(h,D,b,Q),Ka=!1,be=h.memoizedState,D.state=be,Rp(h,b,D,C);var Me=h.memoizedState;H!==ke||be!==Me||rs.current||Ka?(typeof Le=="function"&&(C0(h,m,Le,b),Me=h.memoizedState),(de=Ka||Q$(h,m,de,b,be,Me,Q)||!1)?(Se||typeof D.UNSAFE_componentWillUpdate!="function"&&typeof D.componentWillUpdate!="function"||(typeof D.componentWillUpdate=="function"&&D.componentWillUpdate(b,Me,Q),typeof D.UNSAFE_componentWillUpdate=="function"&&D.UNSAFE_componentWillUpdate(b,Me,Q)),typeof D.componentDidUpdate=="function"&&(h.flags|=4),typeof D.getSnapshotBeforeUpdate=="function"&&(h.flags|=1024)):(typeof D.componentDidUpdate!="function"||H===u.memoizedProps&&be===u.memoizedState||(h.flags|=4),typeof D.getSnapshotBeforeUpdate!="function"||H===u.memoizedProps&&be===u.memoizedState||(h.flags|=1024),h.memoizedProps=b,h.memoizedState=Me),D.props=b,D.state=Me,D.context=Q,b=de):(typeof D.componentDidUpdate!="function"||H===u.memoizedProps&&be===u.memoizedState||(h.flags|=4),typeof D.getSnapshotBeforeUpdate!="function"||H===u.memoizedProps&&be===u.memoizedState||(h.flags|=1024),b=!1)}return N0(u,h,m,b,T,C)}function N0(u,h,m,b,C,T){uk(u,h);var D=(h.flags&128)!==0;if(!b&&!D)return C&&m$(h,m,!1),Xi(u,h,T);b=h.stateNode,O4.current=h;var H=D&&typeof m.getDerivedStateFromError!="function"?null:b.render();return h.flags|=1,u!==null&&D?(h.child=pc(h,u.child,null,T),h.child=pc(h,null,H,T)):Lr(u,h,H,T),h.memoizedState=b.state,C&&m$(h,m,!0),h.child}function dk(u){var h=u.stateNode;h.pendingContext?f$(u,h.pendingContext,h.pendingContext!==h.context):h.context&&f$(u,h.context,!1),d0(u,h.containerInfo)}function hk(u,h,m,b,C){return fc(),s0(C),h.flags|=256,Lr(u,h,m,b),h.child}var E0={dehydrated:null,treeContext:null,retryLane:0};function R0(u){return{baseLanes:u,cachePool:null,transitions:null}}function fk(u,h,m){var b=h.pendingProps,C=dn.current,T=!1,D=(h.flags&128)!==0,H;if((H=D)||(H=u!==null&&u.memoizedState===null?!1:(C&2)!==0),H?(T=!0,h.flags&=-129):(u===null||u.memoizedState!==null)&&(C|=1),Jt(dn,C&1),u===null)return r0(h),u=h.memoizedState,u!==null&&(u=u.dehydrated,u!==null)?((h.mode&1)===0?h.lanes=1:u.data==="$!"?h.lanes=8:h.lanes=1073741824,null):(D=b.children,u=b.fallback,T?(b=h.mode,T=h.child,D={mode:"hidden",children:D},(b&1)===0&&T!==null?(T.childLanes=0,T.pendingProps=D):T=Qp(D,b,0,null),u=nu(u,b,m,null),T.return=h,u.return=h,T.sibling=u,h.child=T,h.child.memoizedState=R0(m),h.memoizedState=E0,u):_0(h,D));if(C=u.memoizedState,C!==null&&(H=C.dehydrated,H!==null))return F4(u,h,D,b,H,C,m);if(T){T=b.fallback,D=h.mode,C=u.child,H=C.sibling;var Q={mode:"hidden",children:b.children};return(D&1)===0&&h.child!==C?(b=h.child,b.childLanes=0,b.pendingProps=Q,h.deletions=null):(b=el(C,Q),b.subtreeFlags=C.subtreeFlags&14680064),H!==null?T=el(H,T):(T=nu(T,D,m,null),T.flags|=2),T.return=h,b.return=h,b.sibling=T,h.child=b,b=T,T=h.child,D=u.child.memoizedState,D=D===null?R0(m):{baseLanes:D.baseLanes|m,cachePool:null,transitions:D.transitions},T.memoizedState=D,T.childLanes=u.childLanes&~m,h.memoizedState=E0,b}return T=u.child,u=T.sibling,b=el(T,{mode:"visible",children:b.children}),(h.mode&1)===0&&(b.lanes=m),b.return=h,b.sibling=null,u!==null&&(m=h.deletions,m===null?(h.deletions=[u],h.flags|=16):m.push(u)),h.child=b,h.memoizedState=null,b}function _0(u,h){return h=Qp({mode:"visible",children:h},u.mode,0,null),h.return=u,u.child=h}function zp(u,h,m,b){return b!==null&&s0(b),pc(h,u.child,null,m),u=_0(h,h.pendingProps.children),u.flags|=2,h.memoizedState=null,u}function F4(u,h,m,b,C,T,D){if(m)return h.flags&256?(h.flags&=-257,b=k0(Error(n(422))),zp(u,h,D,b)):h.memoizedState!==null?(h.child=u.child,h.flags|=128,null):(T=b.fallback,C=h.mode,b=Qp({mode:"visible",children:b.children},C,0,null),T=nu(T,C,D,null),T.flags|=2,b.return=h,T.return=h,b.sibling=T,h.child=b,(h.mode&1)!==0&&pc(h,u.child,null,D),h.child.memoizedState=R0(D),h.memoizedState=E0,T);if((h.mode&1)===0)return zp(u,h,D,null);if(C.data==="$!"){if(b=C.nextSibling&&C.nextSibling.dataset,b)var H=b.dgst;return b=H,T=Error(n(419)),b=k0(T,b,void 0),zp(u,h,D,b)}if(H=(D&u.childLanes)!==0,os||H){if(b=Kn,b!==null){switch(D&-D){case 4:C=2;break;case 16:C=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:C=32;break;case 536870912:C=268435456;break;default:C=0}C=(C&(b.suspendedLanes|D))!==0?0:C,C!==0&&C!==T.retryLane&&(T.retryLane=C,Hi(u,C),Eo(b,u,C,-1))}return K0(),b=k0(Error(n(421))),zp(u,h,D,b)}return C.data==="$?"?(h.flags|=128,h.child=u.child,h=q4.bind(null,u),C._reactRetry=h,null):(u=T.treeContext,Is=Ua(C.nextSibling),Ts=h,un=!0,ko=null,u!==null&&(Hs[Ks++]=ji,Hs[Ks++]=Gi,Hs[Ks++]=Kl,ji=u.id,Gi=u.overflow,Kl=h),h=_0(h,b.children),h.flags|=4096,h)}function pk(u,h,m){u.lanes|=h;var b=u.alternate;b!==null&&(b.lanes|=h),l0(u.return,h,m)}function P0(u,h,m,b,C){var T=u.memoizedState;T===null?u.memoizedState={isBackwards:h,rendering:null,renderingStartTime:0,last:b,tail:m,tailMode:C}:(T.isBackwards=h,T.rendering=null,T.renderingStartTime=0,T.last=b,T.tail=m,T.tailMode=C)}function mk(u,h,m){var b=h.pendingProps,C=b.revealOrder,T=b.tail;if(Lr(u,h,b.children,m),b=dn.current,(b&2)!==0)b=b&1|2,h.flags|=128;else{if(u!==null&&(u.flags&128)!==0)e:for(u=h.child;u!==null;){if(u.tag===13)u.memoizedState!==null&&pk(u,m,h);else if(u.tag===19)pk(u,m,h);else if(u.child!==null){u.child.return=u,u=u.child;continue}if(u===h)break e;for(;u.sibling===null;){if(u.return===null||u.return===h)break e;u=u.return}u.sibling.return=u.return,u=u.sibling}b&=1}if(Jt(dn,b),(h.mode&1)===0)h.memoizedState=null;else switch(C){case"forwards":for(m=h.child,C=null;m!==null;)u=m.alternate,u!==null&&_p(u)===null&&(C=m),m=m.sibling;m=C,m===null?(C=h.child,h.child=null):(C=m.sibling,m.sibling=null),P0(h,!1,C,m,T);break;case"backwards":for(m=null,C=h.child,h.child=null;C!==null;){if(u=C.alternate,u!==null&&_p(u)===null){h.child=C;break}u=C.sibling,C.sibling=m,m=C,C=u}P0(h,!0,m,null,T);break;case"together":P0(h,!1,null,null,void 0);break;default:h.memoizedState=null}return h.child}function Bp(u,h){(h.mode&1)===0&&u!==null&&(u.alternate=null,h.alternate=null,h.flags|=2)}function Xi(u,h,m){if(u!==null&&(h.dependencies=u.dependencies),Zl|=h.lanes,(m&h.childLanes)===0)return null;if(u!==null&&h.child!==u.child)throw Error(n(153));if(h.child!==null){for(u=h.child,m=el(u,u.pendingProps),h.child=m,m.return=h;u.sibling!==null;)u=u.sibling,m=m.sibling=el(u,u.pendingProps),m.return=h;m.sibling=null}return h.child}function L4(u,h,m){switch(h.tag){case 3:dk(h),fc();break;case 5:E$(h);break;case 1:ss(h.type)&&wp(h);break;case 4:d0(h,h.stateNode.containerInfo);break;case 10:var b=h.type._context,C=h.memoizedProps.value;Jt(Ip,b._currentValue),b._currentValue=C;break;case 13:if(b=h.memoizedState,b!==null)return b.dehydrated!==null?(Jt(dn,dn.current&1),h.flags|=128,null):(m&h.child.childLanes)!==0?fk(u,h,m):(Jt(dn,dn.current&1),u=Xi(u,h,m),u!==null?u.sibling:null);Jt(dn,dn.current&1);break;case 19:if(b=(m&h.childLanes)!==0,(u.flags&128)!==0){if(b)return mk(u,h,m);h.flags|=128}if(C=h.memoizedState,C!==null&&(C.rendering=null,C.tail=null,C.lastEffect=null),Jt(dn,dn.current),b)break;return null;case 22:case 23:return h.lanes=0,lk(u,h,m)}return Xi(u,h,m)}var gk,A0,yk,xk;gk=function(u,h){for(var m=h.child;m!==null;){if(m.tag===5||m.tag===6)u.appendChild(m.stateNode);else if(m.tag!==4&&m.child!==null){m.child.return=m,m=m.child;continue}if(m===h)break;for(;m.sibling===null;){if(m.return===null||m.return===h)return;m=m.return}m.sibling.return=m.return,m=m.sibling}},A0=function(){},yk=function(u,h,m,b){var C=u.memoizedProps;if(C!==b){u=h.stateNode,Yl(ti.current);var T=null;switch(m){case"input":C=sn(u,C),b=sn(u,b),T=[];break;case"select":C=ae({},C,{value:void 0}),b=ae({},b,{value:void 0}),T=[];break;case"textarea":C=Bs(u,C),b=Bs(u,b),T=[];break;default:typeof C.onClick!="function"&&typeof b.onClick=="function"&&(u.onclick=xp)}jo(m,b);var D;m=null;for(de in C)if(!b.hasOwnProperty(de)&&C.hasOwnProperty(de)&&C[de]!=null)if(de==="style"){var H=C[de];for(D in H)H.hasOwnProperty(D)&&(m||(m={}),m[D]="")}else de!=="dangerouslySetInnerHTML"&&de!=="children"&&de!=="suppressContentEditableWarning"&&de!=="suppressHydrationWarning"&&de!=="autoFocus"&&(s.hasOwnProperty(de)?T||(T=[]):(T=T||[]).push(de,null));for(de in b){var Q=b[de];if(H=C!=null?C[de]:void 0,b.hasOwnProperty(de)&&Q!==H&&(Q!=null||H!=null))if(de==="style")if(H){for(D in H)!H.hasOwnProperty(D)||Q&&Q.hasOwnProperty(D)||(m||(m={}),m[D]="");for(D in Q)Q.hasOwnProperty(D)&&H[D]!==Q[D]&&(m||(m={}),m[D]=Q[D])}else m||(T||(T=[]),T.push(de,m)),m=Q;else de==="dangerouslySetInnerHTML"?(Q=Q?Q.__html:void 0,H=H?H.__html:void 0,Q!=null&&H!==Q&&(T=T||[]).push(de,Q)):de==="children"?typeof Q!="string"&&typeof Q!="number"||(T=T||[]).push(de,""+Q):de!=="suppressContentEditableWarning"&&de!=="suppressHydrationWarning"&&(s.hasOwnProperty(de)?(Q!=null&&de==="onScroll"&&on("scroll",u),T||H===Q||(T=[])):(T=T||[]).push(de,Q))}m&&(T=T||[]).push("style",m);var de=T;(h.updateQueue=de)&&(h.flags|=4)}},xk=function(u,h,m,b){m!==b&&(h.flags|=4)};function lh(u,h){if(!un)switch(u.tailMode){case"hidden":h=u.tail;for(var m=null;h!==null;)h.alternate!==null&&(m=h),h=h.sibling;m===null?u.tail=null:m.sibling=null;break;case"collapsed":m=u.tail;for(var b=null;m!==null;)m.alternate!==null&&(b=m),m=m.sibling;b===null?h||u.tail===null?u.tail=null:u.tail.sibling=null:b.sibling=null}}function yr(u){var h=u.alternate!==null&&u.alternate.child===u.child,m=0,b=0;if(h)for(var C=u.child;C!==null;)m|=C.lanes|C.childLanes,b|=C.subtreeFlags&14680064,b|=C.flags&14680064,C.return=u,C=C.sibling;else for(C=u.child;C!==null;)m|=C.lanes|C.childLanes,b|=C.subtreeFlags,b|=C.flags,C.return=u,C=C.sibling;return u.subtreeFlags|=b,u.childLanes=m,h}function z4(u,h,m){var b=h.pendingProps;switch(t0(h),h.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return yr(h),null;case 1:return ss(h.type)&&bp(),yr(h),null;case 3:return b=h.stateNode,yc(),an(rs),an(mr),p0(),b.pendingContext&&(b.context=b.pendingContext,b.pendingContext=null),(u===null||u.child===null)&&(kp(h)?h.flags|=4:u===null||u.memoizedState.isDehydrated&&(h.flags&256)===0||(h.flags|=1024,ko!==null&&(j0(ko),ko=null))),A0(u,h),yr(h),null;case 5:h0(h);var C=Yl(rh.current);if(m=h.type,u!==null&&h.stateNode!=null)yk(u,h,m,b,C),u.ref!==h.ref&&(h.flags|=512,h.flags|=2097152);else{if(!b){if(h.stateNode===null)throw Error(n(166));return yr(h),null}if(u=Yl(ti.current),kp(h)){b=h.stateNode,m=h.type;var T=h.memoizedProps;switch(b[ei]=h,b[Zd]=T,u=(h.mode&1)!==0,m){case"dialog":on("cancel",b),on("close",b);break;case"iframe":case"object":case"embed":on("load",b);break;case"video":case"audio":for(C=0;C<qd.length;C++)on(qd[C],b);break;case"source":on("error",b);break;case"img":case"image":case"link":on("error",b),on("load",b);break;case"details":on("toggle",b);break;case"input":Pr(b,T),on("invalid",b);break;case"select":b._wrapperState={wasMultiple:!!T.multiple},on("invalid",b);break;case"textarea":qr(b,T),on("invalid",b)}jo(m,T),C=null;for(var D in T)if(T.hasOwnProperty(D)){var H=T[D];D==="children"?typeof H=="string"?b.textContent!==H&&(T.suppressHydrationWarning!==!0&&yp(b.textContent,H,u),C=["children",H]):typeof H=="number"&&b.textContent!==""+H&&(T.suppressHydrationWarning!==!0&&yp(b.textContent,H,u),C=["children",""+H]):s.hasOwnProperty(D)&&H!=null&&D==="onScroll"&&on("scroll",b)}switch(m){case"input":_r(b),El(b,T,!0);break;case"textarea":_r(b),Ea(b);break;case"select":case"option":break;default:typeof T.onClick=="function"&&(b.onclick=xp)}b=C,h.updateQueue=b,b!==null&&(h.flags|=4)}else{D=C.nodeType===9?C:C.ownerDocument,u==="http://www.w3.org/1999/xhtml"&&(u=Ti(m)),u==="http://www.w3.org/1999/xhtml"?m==="script"?(u=D.createElement("div"),u.innerHTML="<script><\/script>",u=u.removeChild(u.firstChild)):typeof b.is=="string"?u=D.createElement(m,{is:b.is}):(u=D.createElement(m),m==="select"&&(D=u,b.multiple?D.multiple=!0:b.size&&(D.size=b.size))):u=D.createElementNS(u,m),u[ei]=h,u[Zd]=b,gk(u,h,!1,!1),h.stateNode=u;e:{switch(D=Pa(m,b),m){case"dialog":on("cancel",u),on("close",u),C=b;break;case"iframe":case"object":case"embed":on("load",u),C=b;break;case"video":case"audio":for(C=0;C<qd.length;C++)on(qd[C],u);C=b;break;case"source":on("error",u),C=b;break;case"img":case"image":case"link":on("error",u),on("load",u),C=b;break;case"details":on("toggle",u),C=b;break;case"input":Pr(u,b),C=sn(u,b),on("invalid",u);break;case"option":C=b;break;case"select":u._wrapperState={wasMultiple:!!b.multiple},C=ae({},b,{value:void 0}),on("invalid",u);break;case"textarea":qr(u,b),C=Bs(u,b),on("invalid",u);break;default:C=b}jo(m,C),H=C;for(T in H)if(H.hasOwnProperty(T)){var Q=H[T];T==="style"?_a(u,Q):T==="dangerouslySetInnerHTML"?(Q=Q?Q.__html:void 0,Q!=null&&Ra(u,Q)):T==="children"?typeof Q=="string"?(m!=="textarea"||Q!=="")&&Wo(u,Q):typeof Q=="number"&&Wo(u,""+Q):T!=="suppressContentEditableWarning"&&T!=="suppressHydrationWarning"&&T!=="autoFocus"&&(s.hasOwnProperty(T)?Q!=null&&T==="onScroll"&&on("scroll",u):Q!=null&&I(u,T,Q,D))}switch(m){case"input":_r(u),El(u,b,!1);break;case"textarea":_r(u),Ea(u);break;case"option":b.value!=null&&u.setAttribute("value",""+dt(b.value));break;case"select":u.multiple=!!b.multiple,T=b.value,T!=null?Ss(u,!!b.multiple,T,!1):b.defaultValue!=null&&Ss(u,!!b.multiple,b.defaultValue,!0);break;default:typeof C.onClick=="function"&&(u.onclick=xp)}switch(m){case"button":case"input":case"select":case"textarea":b=!!b.autoFocus;break e;case"img":b=!0;break e;default:b=!1}}b&&(h.flags|=4)}h.ref!==null&&(h.flags|=512,h.flags|=2097152)}return yr(h),null;case 6:if(u&&h.stateNode!=null)xk(u,h,u.memoizedProps,b);else{if(typeof b!="string"&&h.stateNode===null)throw Error(n(166));if(m=Yl(rh.current),Yl(ti.current),kp(h)){if(b=h.stateNode,m=h.memoizedProps,b[ei]=h,(T=b.nodeValue!==m)&&(u=Ts,u!==null))switch(u.tag){case 3:yp(b.nodeValue,m,(u.mode&1)!==0);break;case 5:u.memoizedProps.suppressHydrationWarning!==!0&&yp(b.nodeValue,m,(u.mode&1)!==0)}T&&(h.flags|=4)}else b=(m.nodeType===9?m:m.ownerDocument).createTextNode(b),b[ei]=h,h.stateNode=b}return yr(h),null;case 13:if(an(dn),b=h.memoizedState,u===null||u.memoizedState!==null&&u.memoizedState.dehydrated!==null){if(un&&Is!==null&&(h.mode&1)!==0&&(h.flags&128)===0)w$(),fc(),h.flags|=98560,T=!1;else if(T=kp(h),b!==null&&b.dehydrated!==null){if(u===null){if(!T)throw Error(n(318));if(T=h.memoizedState,T=T!==null?T.dehydrated:null,!T)throw Error(n(317));T[ei]=h}else fc(),(h.flags&128)===0&&(h.memoizedState=null),h.flags|=4;yr(h),T=!1}else ko!==null&&(j0(ko),ko=null),T=!0;if(!T)return h.flags&65536?h:null}return(h.flags&128)!==0?(h.lanes=m,h):(b=b!==null,b!==(u!==null&&u.memoizedState!==null)&&b&&(h.child.flags|=8192,(h.mode&1)!==0&&(u===null||(dn.current&1)!==0?An===0&&(An=3):K0())),h.updateQueue!==null&&(h.flags|=4),yr(h),null);case 4:return yc(),A0(u,h),u===null&&Yd(h.stateNode.containerInfo),yr(h),null;case 10:return a0(h.type._context),yr(h),null;case 17:return ss(h.type)&&bp(),yr(h),null;case 19:if(an(dn),T=h.memoizedState,T===null)return yr(h),null;if(b=(h.flags&128)!==0,D=T.rendering,D===null)if(b)lh(T,!1);else{if(An!==0||u!==null&&(u.flags&128)!==0)for(u=h.child;u!==null;){if(D=_p(u),D!==null){for(h.flags|=128,lh(T,!1),b=D.updateQueue,b!==null&&(h.updateQueue=b,h.flags|=4),h.subtreeFlags=0,b=m,m=h.child;m!==null;)T=m,u=b,T.flags&=14680066,D=T.alternate,D===null?(T.childLanes=0,T.lanes=u,T.child=null,T.subtreeFlags=0,T.memoizedProps=null,T.memoizedState=null,T.updateQueue=null,T.dependencies=null,T.stateNode=null):(T.childLanes=D.childLanes,T.lanes=D.lanes,T.child=D.child,T.subtreeFlags=0,T.deletions=null,T.memoizedProps=D.memoizedProps,T.memoizedState=D.memoizedState,T.updateQueue=D.updateQueue,T.type=D.type,u=D.dependencies,T.dependencies=u===null?null:{lanes:u.lanes,firstContext:u.firstContext}),m=m.sibling;return Jt(dn,dn.current&1|2),h.child}u=u.sibling}T.tail!==null&&Ut()>wc&&(h.flags|=128,b=!0,lh(T,!1),h.lanes=4194304)}else{if(!b)if(u=_p(D),u!==null){if(h.flags|=128,b=!0,m=u.updateQueue,m!==null&&(h.updateQueue=m,h.flags|=4),lh(T,!0),T.tail===null&&T.tailMode==="hidden"&&!D.alternate&&!un)return yr(h),null}else 2*Ut()-T.renderingStartTime>wc&&m!==1073741824&&(h.flags|=128,b=!0,lh(T,!1),h.lanes=4194304);T.isBackwards?(D.sibling=h.child,h.child=D):(m=T.last,m!==null?m.sibling=D:h.child=D,T.last=D)}return T.tail!==null?(h=T.tail,T.rendering=h,T.tail=h.sibling,T.renderingStartTime=Ut(),h.sibling=null,m=dn.current,Jt(dn,b?m&1|2:m&1),h):(yr(h),null);case 22:case 23:return H0(),b=h.memoizedState!==null,u!==null&&u.memoizedState!==null!==b&&(h.flags|=8192),b&&(h.mode&1)!==0?(Ns&1073741824)!==0&&(yr(h),h.subtreeFlags&6&&(h.flags|=8192)):yr(h),null;case 24:return null;case 25:return null}throw Error(n(156,h.tag))}function B4(u,h){switch(t0(h),h.tag){case 1:return ss(h.type)&&bp(),u=h.flags,u&65536?(h.flags=u&-65537|128,h):null;case 3:return yc(),an(rs),an(mr),p0(),u=h.flags,(u&65536)!==0&&(u&128)===0?(h.flags=u&-65537|128,h):null;case 5:return h0(h),null;case 13:if(an(dn),u=h.memoizedState,u!==null&&u.dehydrated!==null){if(h.alternate===null)throw Error(n(340));fc()}return u=h.flags,u&65536?(h.flags=u&-65537|128,h):null;case 19:return an(dn),null;case 4:return yc(),null;case 10:return a0(h.type._context),null;case 22:case 23:return H0(),null;case 24:return null;default:return null}}var Mp=!1,xr=!1,M4=typeof WeakSet=="function"?WeakSet:Set,ze=null;function vc(u,h){var m=u.ref;if(m!==null)if(typeof m=="function")try{m(null)}catch(b){xn(u,h,b)}else m.current=null}function D0(u,h,m){try{m()}catch(b){xn(u,h,b)}}var vk=!1;function V4(u,h){if(Hy=U,u=QC(),zy(u)){if("selectionStart"in u)var m={start:u.selectionStart,end:u.selectionEnd};else e:{m=(m=u.ownerDocument)&&m.defaultView||window;var b=m.getSelection&&m.getSelection();if(b&&b.rangeCount!==0){m=b.anchorNode;var C=b.anchorOffset,T=b.focusNode;b=b.focusOffset;try{m.nodeType,T.nodeType}catch{m=null;break e}var D=0,H=-1,Q=-1,de=0,Se=0,ke=u,be=null;t:for(;;){for(var Le;ke!==m||C!==0&&ke.nodeType!==3||(H=D+C),ke!==T||b!==0&&ke.nodeType!==3||(Q=D+b),ke.nodeType===3&&(D+=ke.nodeValue.length),(Le=ke.firstChild)!==null;)be=ke,ke=Le;for(;;){if(ke===u)break t;if(be===m&&++de===C&&(H=D),be===T&&++Se===b&&(Q=D),(Le=ke.nextSibling)!==null)break;ke=be,be=ke.parentNode}ke=Le}m=H===-1||Q===-1?null:{start:H,end:Q}}else m=null}m=m||{start:0,end:0}}else m=null;for(Ky={focusedElem:u,selectionRange:m},U=!1,ze=h;ze!==null;)if(h=ze,u=h.child,(h.subtreeFlags&1028)!==0&&u!==null)u.return=h,ze=u;else for(;ze!==null;){h=ze;try{var Me=h.alternate;if((h.flags&1024)!==0)switch(h.tag){case 0:case 11:case 15:break;case 1:if(Me!==null){var Ue=Me.memoizedProps,Sn=Me.memoizedState,oe=h.stateNode,te=oe.getSnapshotBeforeUpdate(h.elementType===h.type?Ue:To(h.type,Ue),Sn);oe.__reactInternalSnapshotBeforeUpdate=te}break;case 3:var le=h.stateNode.containerInfo;le.nodeType===1?le.textContent="":le.nodeType===9&&le.documentElement&&le.removeChild(le.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(n(163))}}catch(Ie){xn(h,h.return,Ie)}if(u=h.sibling,u!==null){u.return=h.return,ze=u;break}ze=h.return}return Me=vk,vk=!1,Me}function uh(u,h,m){var b=h.updateQueue;if(b=b!==null?b.lastEffect:null,b!==null){var C=b=b.next;do{if((C.tag&u)===u){var T=C.destroy;C.destroy=void 0,T!==void 0&&D0(h,m,T)}C=C.next}while(C!==b)}}function Vp(u,h){if(h=h.updateQueue,h=h!==null?h.lastEffect:null,h!==null){var m=h=h.next;do{if((m.tag&u)===u){var b=m.create;m.destroy=b()}m=m.next}while(m!==h)}}function O0(u){var h=u.ref;if(h!==null){var m=u.stateNode;switch(u.tag){case 5:u=m;break;default:u=m}typeof h=="function"?h(u):h.current=u}}function bk(u){var h=u.alternate;h!==null&&(u.alternate=null,bk(h)),u.child=null,u.deletions=null,u.sibling=null,u.tag===5&&(h=u.stateNode,h!==null&&(delete h[ei],delete h[Zd],delete h[Qy],delete h[C4],delete h[$4])),u.stateNode=null,u.return=null,u.dependencies=null,u.memoizedProps=null,u.memoizedState=null,u.pendingProps=null,u.stateNode=null,u.updateQueue=null}function wk(u){return u.tag===5||u.tag===3||u.tag===4}function Sk(u){e:for(;;){for(;u.sibling===null;){if(u.return===null||wk(u.return))return null;u=u.return}for(u.sibling.return=u.return,u=u.sibling;u.tag!==5&&u.tag!==6&&u.tag!==18;){if(u.flags&2||u.child===null||u.tag===4)continue e;u.child.return=u,u=u.child}if(!(u.flags&2))return u.stateNode}}function F0(u,h,m){var b=u.tag;if(b===5||b===6)u=u.stateNode,h?m.nodeType===8?m.parentNode.insertBefore(u,h):m.insertBefore(u,h):(m.nodeType===8?(h=m.parentNode,h.insertBefore(u,m)):(h=m,h.appendChild(u)),m=m._reactRootContainer,m!=null||h.onclick!==null||(h.onclick=xp));else if(b!==4&&(u=u.child,u!==null))for(F0(u,h,m),u=u.sibling;u!==null;)F0(u,h,m),u=u.sibling}function L0(u,h,m){var b=u.tag;if(b===5||b===6)u=u.stateNode,h?m.insertBefore(u,h):m.appendChild(u);else if(b!==4&&(u=u.child,u!==null))for(L0(u,h,m),u=u.sibling;u!==null;)L0(u,h,m),u=u.sibling}var sr=null,Io=!1;function qa(u,h,m){for(m=m.child;m!==null;)Ck(u,h,m),m=m.sibling}function Ck(u,h,m){if(nr&&typeof nr.onCommitFiberUnmount=="function")try{nr.onCommitFiberUnmount(Vn,m)}catch{}switch(m.tag){case 5:xr||vc(m,h);case 6:var b=sr,C=Io;sr=null,qa(u,h,m),sr=b,Io=C,sr!==null&&(Io?(u=sr,m=m.stateNode,u.nodeType===8?u.parentNode.removeChild(m):u.removeChild(m)):sr.removeChild(m.stateNode));break;case 18:sr!==null&&(Io?(u=sr,m=m.stateNode,u.nodeType===8?Yy(u.parentNode,m):u.nodeType===1&&Yy(u,m),So(u)):Yy(sr,m.stateNode));break;case 4:b=sr,C=Io,sr=m.stateNode.containerInfo,Io=!0,qa(u,h,m),sr=b,Io=C;break;case 0:case 11:case 14:case 15:if(!xr&&(b=m.updateQueue,b!==null&&(b=b.lastEffect,b!==null))){C=b=b.next;do{var T=C,D=T.destroy;T=T.tag,D!==void 0&&((T&2)!==0||(T&4)!==0)&&D0(m,h,D),C=C.next}while(C!==b)}qa(u,h,m);break;case 1:if(!xr&&(vc(m,h),b=m.stateNode,typeof b.componentWillUnmount=="function"))try{b.props=m.memoizedProps,b.state=m.memoizedState,b.componentWillUnmount()}catch(H){xn(m,h,H)}qa(u,h,m);break;case 21:qa(u,h,m);break;case 22:m.mode&1?(xr=(b=xr)||m.memoizedState!==null,qa(u,h,m),xr=b):qa(u,h,m);break;default:qa(u,h,m)}}function $k(u){var h=u.updateQueue;if(h!==null){u.updateQueue=null;var m=u.stateNode;m===null&&(m=u.stateNode=new M4),h.forEach(function(b){var C=Y4.bind(null,u,b);m.has(b)||(m.add(b),b.then(C,C))})}}function No(u,h){var m=h.deletions;if(m!==null)for(var b=0;b<m.length;b++){var C=m[b];try{var T=u,D=h,H=D;e:for(;H!==null;){switch(H.tag){case 5:sr=H.stateNode,Io=!1;break e;case 3:sr=H.stateNode.containerInfo,Io=!0;break e;case 4:sr=H.stateNode.containerInfo,Io=!0;break e}H=H.return}if(sr===null)throw Error(n(160));Ck(T,D,C),sr=null,Io=!1;var Q=C.alternate;Q!==null&&(Q.return=null),C.return=null}catch(de){xn(C,h,de)}}if(h.subtreeFlags&12854)for(h=h.child;h!==null;)kk(h,u),h=h.sibling}function kk(u,h){var m=u.alternate,b=u.flags;switch(u.tag){case 0:case 11:case 14:case 15:if(No(h,u),ri(u),b&4){try{uh(3,u,u.return),Vp(3,u)}catch(Ue){xn(u,u.return,Ue)}try{uh(5,u,u.return)}catch(Ue){xn(u,u.return,Ue)}}break;case 1:No(h,u),ri(u),b&512&&m!==null&&vc(m,m.return);break;case 5:if(No(h,u),ri(u),b&512&&m!==null&&vc(m,m.return),u.flags&32){var C=u.stateNode;try{Wo(C,"")}catch(Ue){xn(u,u.return,Ue)}}if(b&4&&(C=u.stateNode,C!=null)){var T=u.memoizedProps,D=m!==null?m.memoizedProps:T,H=u.type,Q=u.updateQueue;if(u.updateQueue=null,Q!==null)try{H==="input"&&T.type==="radio"&&T.name!=null&&Vo(C,T),Pa(H,D);var de=Pa(H,T);for(D=0;D<Q.length;D+=2){var Se=Q[D],ke=Q[D+1];Se==="style"?_a(C,ke):Se==="dangerouslySetInnerHTML"?Ra(C,ke):Se==="children"?Wo(C,ke):I(C,Se,ke,de)}switch(H){case"input":Ia(C,T);break;case"textarea":Cs(C,T);break;case"select":var be=C._wrapperState.wasMultiple;C._wrapperState.wasMultiple=!!T.multiple;var Le=T.value;Le!=null?Ss(C,!!T.multiple,Le,!1):be!==!!T.multiple&&(T.defaultValue!=null?Ss(C,!!T.multiple,T.defaultValue,!0):Ss(C,!!T.multiple,T.multiple?[]:"",!1))}C[Zd]=T}catch(Ue){xn(u,u.return,Ue)}}break;case 6:if(No(h,u),ri(u),b&4){if(u.stateNode===null)throw Error(n(162));C=u.stateNode,T=u.memoizedProps;try{C.nodeValue=T}catch(Ue){xn(u,u.return,Ue)}}break;case 3:if(No(h,u),ri(u),b&4&&m!==null&&m.memoizedState.isDehydrated)try{So(h.containerInfo)}catch(Ue){xn(u,u.return,Ue)}break;case 4:No(h,u),ri(u);break;case 13:No(h,u),ri(u),C=u.child,C.flags&8192&&(T=C.memoizedState!==null,C.stateNode.isHidden=T,!T||C.alternate!==null&&C.alternate.memoizedState!==null||(M0=Ut())),b&4&&$k(u);break;case 22:if(Se=m!==null&&m.memoizedState!==null,u.mode&1?(xr=(de=xr)||Se,No(h,u),xr=de):No(h,u),ri(u),b&8192){if(de=u.memoizedState!==null,(u.stateNode.isHidden=de)&&!Se&&(u.mode&1)!==0)for(ze=u,Se=u.child;Se!==null;){for(ke=ze=Se;ze!==null;){switch(be=ze,Le=be.child,be.tag){case 0:case 11:case 14:case 15:uh(4,be,be.return);break;case 1:vc(be,be.return);var Me=be.stateNode;if(typeof Me.componentWillUnmount=="function"){b=be,m=be.return;try{h=b,Me.props=h.memoizedProps,Me.state=h.memoizedState,Me.componentWillUnmount()}catch(Ue){xn(b,m,Ue)}}break;case 5:vc(be,be.return);break;case 22:if(be.memoizedState!==null){Nk(ke);continue}}Le!==null?(Le.return=be,ze=Le):Nk(ke)}Se=Se.sibling}e:for(Se=null,ke=u;;){if(ke.tag===5){if(Se===null){Se=ke;try{C=ke.stateNode,de?(T=C.style,typeof T.setProperty=="function"?T.setProperty("display","none","important"):T.display="none"):(H=ke.stateNode,Q=ke.memoizedProps.style,D=Q!=null&&Q.hasOwnProperty("display")?Q.display:null,H.style.display=Uo("display",D))}catch(Ue){xn(u,u.return,Ue)}}}else if(ke.tag===6){if(Se===null)try{ke.stateNode.nodeValue=de?"":ke.memoizedProps}catch(Ue){xn(u,u.return,Ue)}}else if((ke.tag!==22&&ke.tag!==23||ke.memoizedState===null||ke===u)&&ke.child!==null){ke.child.return=ke,ke=ke.child;continue}if(ke===u)break e;for(;ke.sibling===null;){if(ke.return===null||ke.return===u)break e;Se===ke&&(Se=null),ke=ke.return}Se===ke&&(Se=null),ke.sibling.return=ke.return,ke=ke.sibling}}break;case 19:No(h,u),ri(u),b&4&&$k(u);break;case 21:break;default:No(h,u),ri(u)}}function ri(u){var h=u.flags;if(h&2){try{e:{for(var m=u.return;m!==null;){if(wk(m)){var b=m;break e}m=m.return}throw Error(n(160))}switch(b.tag){case 5:var C=b.stateNode;b.flags&32&&(Wo(C,""),b.flags&=-33);var T=Sk(u);L0(u,T,C);break;case 3:case 4:var D=b.stateNode.containerInfo,H=Sk(u);F0(u,H,D);break;default:throw Error(n(161))}}catch(Q){xn(u,u.return,Q)}u.flags&=-3}h&4096&&(u.flags&=-4097)}function W4(u,h,m){ze=u,Tk(u)}function Tk(u,h,m){for(var b=(u.mode&1)!==0;ze!==null;){var C=ze,T=C.child;if(C.tag===22&&b){var D=C.memoizedState!==null||Mp;if(!D){var H=C.alternate,Q=H!==null&&H.memoizedState!==null||xr;H=Mp;var de=xr;if(Mp=D,(xr=Q)&&!de)for(ze=C;ze!==null;)D=ze,Q=D.child,D.tag===22&&D.memoizedState!==null?Ek(C):Q!==null?(Q.return=D,ze=Q):Ek(C);for(;T!==null;)ze=T,Tk(T),T=T.sibling;ze=C,Mp=H,xr=de}Ik(u)}else(C.subtreeFlags&8772)!==0&&T!==null?(T.return=C,ze=T):Ik(u)}}function Ik(u){for(;ze!==null;){var h=ze;if((h.flags&8772)!==0){var m=h.alternate;try{if((h.flags&8772)!==0)switch(h.tag){case 0:case 11:case 15:xr||Vp(5,h);break;case 1:var b=h.stateNode;if(h.flags&4&&!xr)if(m===null)b.componentDidMount();else{var C=h.elementType===h.type?m.memoizedProps:To(h.type,m.memoizedProps);b.componentDidUpdate(C,m.memoizedState,b.__reactInternalSnapshotBeforeUpdate)}var T=h.updateQueue;T!==null&&N$(h,T,b);break;case 3:var D=h.updateQueue;if(D!==null){if(m=null,h.child!==null)switch(h.child.tag){case 5:m=h.child.stateNode;break;case 1:m=h.child.stateNode}N$(h,D,m)}break;case 5:var H=h.stateNode;if(m===null&&h.flags&4){m=H;var Q=h.memoizedProps;switch(h.type){case"button":case"input":case"select":case"textarea":Q.autoFocus&&m.focus();break;case"img":Q.src&&(m.src=Q.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(h.memoizedState===null){var de=h.alternate;if(de!==null){var Se=de.memoizedState;if(Se!==null){var ke=Se.dehydrated;ke!==null&&So(ke)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(n(163))}xr||h.flags&512&&O0(h)}catch(be){xn(h,h.return,be)}}if(h===u){ze=null;break}if(m=h.sibling,m!==null){m.return=h.return,ze=m;break}ze=h.return}}function Nk(u){for(;ze!==null;){var h=ze;if(h===u){ze=null;break}var m=h.sibling;if(m!==null){m.return=h.return,ze=m;break}ze=h.return}}function Ek(u){for(;ze!==null;){var h=ze;try{switch(h.tag){case 0:case 11:case 15:var m=h.return;try{Vp(4,h)}catch(Q){xn(h,m,Q)}break;case 1:var b=h.stateNode;if(typeof b.componentDidMount=="function"){var C=h.return;try{b.componentDidMount()}catch(Q){xn(h,C,Q)}}var T=h.return;try{O0(h)}catch(Q){xn(h,T,Q)}break;case 5:var D=h.return;try{O0(h)}catch(Q){xn(h,D,Q)}}}catch(Q){xn(h,h.return,Q)}if(h===u){ze=null;break}var H=h.sibling;if(H!==null){H.return=h.return,ze=H;break}ze=h.return}}var U4=Math.ceil,Wp=R.ReactCurrentDispatcher,z0=R.ReactCurrentOwner,Ys=R.ReactCurrentBatchConfig,Et=0,Kn=null,In=null,or=0,Ns=0,bc=ja(0),An=0,ch=null,Zl=0,Up=0,B0=0,dh=null,is=null,M0=0,wc=1/0,qi=null,jp=!1,V0=null,Ya=null,Gp=!1,Qa=null,Hp=0,hh=0,W0=null,Kp=-1,Xp=0;function zr(){return(Et&6)!==0?Ut():Kp!==-1?Kp:Kp=Ut()}function Za(u){return(u.mode&1)===0?1:(Et&2)!==0&&or!==0?or&-or:T4.transition!==null?(Xp===0&&(Xp=Fi()),Xp):(u=St,u!==0||(u=window.event,u=u===void 0?16:Nt(u.type)),u)}function Eo(u,h,m,b){if(50<hh)throw hh=0,W0=null,Error(n(185));qo(u,m,b),((Et&2)===0||u!==Kn)&&(u===Kn&&((Et&2)===0&&(Up|=m),An===4&&Ja(u,or)),as(u,b),m===1&&Et===0&&(h.mode&1)===0&&(wc=Ut()+500,Sp&&Ha()))}function as(u,h){var m=u.callbackNode;La(u,h);var b=Oi(u,u===Kn?or:0);if(b===0)m!==null&&Mn(m),u.callbackNode=null,u.callbackPriority=0;else if(h=b&-b,u.callbackPriority!==h){if(m!=null&&Mn(m),h===1)u.tag===0?k4(_k.bind(null,u)):g$(_k.bind(null,u)),w4(function(){(Et&6)===0&&Ha()}),m=null;else{switch(zl(b)){case 1:m=vo;break;case 4:m=_i;break;case 16:m=tr;break;case 536870912:m=Pi;break;default:m=tr}m=Bk(m,Rk.bind(null,u))}u.callbackPriority=h,u.callbackNode=m}}function Rk(u,h){if(Kp=-1,Xp=0,(Et&6)!==0)throw Error(n(327));var m=u.callbackNode;if(Sc()&&u.callbackNode!==m)return null;var b=Oi(u,u===Kn?or:0);if(b===0)return null;if((b&30)!==0||(b&u.expiredLanes)!==0||h)h=qp(u,b);else{h=b;var C=Et;Et|=2;var T=Ak();(Kn!==u||or!==h)&&(qi=null,wc=Ut()+500,eu(u,h));do try{H4();break}catch(H){Pk(u,H)}while(!0);i0(),Wp.current=T,Et=C,In!==null?h=0:(Kn=null,or=0,h=An)}if(h!==0){if(h===2&&(C=za(u),C!==0&&(b=C,h=U0(u,C))),h===1)throw m=ch,eu(u,0),Ja(u,b),as(u,Ut()),m;if(h===6)Ja(u,b);else{if(C=u.current.alternate,(b&30)===0&&!j4(C)&&(h=qp(u,b),h===2&&(T=za(u),T!==0&&(b=T,h=U0(u,T))),h===1))throw m=ch,eu(u,0),Ja(u,b),as(u,Ut()),m;switch(u.finishedWork=C,u.finishedLanes=b,h){case 0:case 1:throw Error(n(345));case 2:tu(u,is,qi);break;case 3:if(Ja(u,b),(b&130023424)===b&&(h=M0+500-Ut(),10<h)){if(Oi(u,0)!==0)break;if(C=u.suspendedLanes,(C&b)!==b){zr(),u.pingedLanes|=u.suspendedLanes&C;break}u.timeoutHandle=qy(tu.bind(null,u,is,qi),h);break}tu(u,is,qi);break;case 4:if(Ja(u,b),(b&4194240)===b)break;for(h=u.eventTimes,C=-1;0<b;){var D=31-fr(b);T=1<<D,D=h[D],D>C&&(C=D),b&=~T}if(b=C,b=Ut()-b,b=(120>b?120:480>b?480:1080>b?1080:1920>b?1920:3e3>b?3e3:4320>b?4320:1960*U4(b/1960))-b,10<b){u.timeoutHandle=qy(tu.bind(null,u,is,qi),b);break}tu(u,is,qi);break;case 5:tu(u,is,qi);break;default:throw Error(n(329))}}}return as(u,Ut()),u.callbackNode===m?Rk.bind(null,u):null}function U0(u,h){var m=dh;return u.current.memoizedState.isDehydrated&&(eu(u,h).flags|=256),u=qp(u,h),u!==2&&(h=is,is=m,h!==null&&j0(h)),u}function j0(u){is===null?is=u:is.push.apply(is,u)}function j4(u){for(var h=u;;){if(h.flags&16384){var m=h.updateQueue;if(m!==null&&(m=m.stores,m!==null))for(var b=0;b<m.length;b++){var C=m[b],T=C.getSnapshot;C=C.value;try{if(!$o(T(),C))return!1}catch{return!1}}}if(m=h.child,h.subtreeFlags&16384&&m!==null)m.return=h,h=m;else{if(h===u)break;for(;h.sibling===null;){if(h.return===null||h.return===u)return!0;h=h.return}h.sibling.return=h.return,h=h.sibling}}return!0}function Ja(u,h){for(h&=~B0,h&=~Up,u.suspendedLanes|=h,u.pingedLanes&=~h,u=u.expirationTimes;0<h;){var m=31-fr(h),b=1<<m;u[m]=-1,h&=~b}}function _k(u){if((Et&6)!==0)throw Error(n(327));Sc();var h=Oi(u,0);if((h&1)===0)return as(u,Ut()),null;var m=qp(u,h);if(u.tag!==0&&m===2){var b=za(u);b!==0&&(h=b,m=U0(u,b))}if(m===1)throw m=ch,eu(u,0),Ja(u,h),as(u,Ut()),m;if(m===6)throw Error(n(345));return u.finishedWork=u.current.alternate,u.finishedLanes=h,tu(u,is,qi),as(u,Ut()),null}function G0(u,h){var m=Et;Et|=1;try{return u(h)}finally{Et=m,Et===0&&(wc=Ut()+500,Sp&&Ha())}}function Jl(u){Qa!==null&&Qa.tag===0&&(Et&6)===0&&Sc();var h=Et;Et|=1;var m=Ys.transition,b=St;try{if(Ys.transition=null,St=1,u)return u()}finally{St=b,Ys.transition=m,Et=h,(Et&6)===0&&Ha()}}function H0(){Ns=bc.current,an(bc)}function eu(u,h){u.finishedWork=null,u.finishedLanes=0;var m=u.timeoutHandle;if(m!==-1&&(u.timeoutHandle=-1,b4(m)),In!==null)for(m=In.return;m!==null;){var b=m;switch(t0(b),b.tag){case 1:b=b.type.childContextTypes,b!=null&&bp();break;case 3:yc(),an(rs),an(mr),p0();break;case 5:h0(b);break;case 4:yc();break;case 13:an(dn);break;case 19:an(dn);break;case 10:a0(b.type._context);break;case 22:case 23:H0()}m=m.return}if(Kn=u,In=u=el(u.current,null),or=Ns=h,An=0,ch=null,B0=Up=Zl=0,is=dh=null,ql!==null){for(h=0;h<ql.length;h++)if(m=ql[h],b=m.interleaved,b!==null){m.interleaved=null;var C=b.next,T=m.pending;if(T!==null){var D=T.next;T.next=C,b.next=D}m.pending=b}ql=null}return u}function Pk(u,h){do{var m=In;try{if(i0(),Pp.current=Fp,Ap){for(var b=hn.memoizedState;b!==null;){var C=b.queue;C!==null&&(C.pending=null),b=b.next}Ap=!1}if(Ql=0,Hn=Pn=hn=null,sh=!1,oh=0,z0.current=null,m===null||m.return===null){An=1,ch=h,In=null;break}e:{var T=u,D=m.return,H=m,Q=h;if(h=or,H.flags|=32768,Q!==null&&typeof Q=="object"&&typeof Q.then=="function"){var de=Q,Se=H,ke=Se.tag;if((Se.mode&1)===0&&(ke===0||ke===11||ke===15)){var be=Se.alternate;be?(Se.updateQueue=be.updateQueue,Se.memoizedState=be.memoizedState,Se.lanes=be.lanes):(Se.updateQueue=null,Se.memoizedState=null)}var Le=rk(D);if(Le!==null){Le.flags&=-257,sk(Le,D,H,T,h),Le.mode&1&&nk(T,de,h),h=Le,Q=de;var Me=h.updateQueue;if(Me===null){var Ue=new Set;Ue.add(Q),h.updateQueue=Ue}else Me.add(Q);break e}else{if((h&1)===0){nk(T,de,h),K0();break e}Q=Error(n(426))}}else if(un&&H.mode&1){var Sn=rk(D);if(Sn!==null){(Sn.flags&65536)===0&&(Sn.flags|=256),sk(Sn,D,H,T,h),s0(xc(Q,H));break e}}T=Q=xc(Q,H),An!==4&&(An=2),dh===null?dh=[T]:dh.push(T),T=D;do{switch(T.tag){case 3:T.flags|=65536,h&=-h,T.lanes|=h;var oe=ek(T,Q,h);I$(T,oe);break e;case 1:H=Q;var te=T.type,le=T.stateNode;if((T.flags&128)===0&&(typeof te.getDerivedStateFromError=="function"||le!==null&&typeof le.componentDidCatch=="function"&&(Ya===null||!Ya.has(le)))){T.flags|=65536,h&=-h,T.lanes|=h;var Ie=tk(T,H,h);I$(T,Ie);break e}}T=T.return}while(T!==null)}Ok(m)}catch(je){h=je,In===m&&m!==null&&(In=m=m.return);continue}break}while(!0)}function Ak(){var u=Wp.current;return Wp.current=Fp,u===null?Fp:u}function K0(){(An===0||An===3||An===2)&&(An=4),Kn===null||(Zl&268435455)===0&&(Up&268435455)===0||Ja(Kn,or)}function qp(u,h){var m=Et;Et|=2;var b=Ak();(Kn!==u||or!==h)&&(qi=null,eu(u,h));do try{G4();break}catch(C){Pk(u,C)}while(!0);if(i0(),Et=m,Wp.current=b,In!==null)throw Error(n(261));return Kn=null,or=0,An}function G4(){for(;In!==null;)Dk(In)}function H4(){for(;In!==null&&!Zr();)Dk(In)}function Dk(u){var h=zk(u.alternate,u,Ns);u.memoizedProps=u.pendingProps,h===null?Ok(u):In=h,z0.current=null}function Ok(u){var h=u;do{var m=h.alternate;if(u=h.return,(h.flags&32768)===0){if(m=z4(m,h,Ns),m!==null){In=m;return}}else{if(m=B4(m,h),m!==null){m.flags&=32767,In=m;return}if(u!==null)u.flags|=32768,u.subtreeFlags=0,u.deletions=null;else{An=6,In=null;return}}if(h=h.sibling,h!==null){In=h;return}In=h=u}while(h!==null);An===0&&(An=5)}function tu(u,h,m){var b=St,C=Ys.transition;try{Ys.transition=null,St=1,K4(u,h,m,b)}finally{Ys.transition=C,St=b}return null}function K4(u,h,m,b){do Sc();while(Qa!==null);if((Et&6)!==0)throw Error(n(327));m=u.finishedWork;var C=u.finishedLanes;if(m===null)return null;if(u.finishedWork=null,u.finishedLanes=0,m===u.current)throw Error(n(177));u.callbackNode=null,u.callbackPriority=0;var T=m.lanes|m.childLanes;if(Wd(u,T),u===Kn&&(In=Kn=null,or=0),(m.subtreeFlags&2064)===0&&(m.flags&2064)===0||Gp||(Gp=!0,Bk(tr,function(){return Sc(),null})),T=(m.flags&15990)!==0,(m.subtreeFlags&15990)!==0||T){T=Ys.transition,Ys.transition=null;var D=St;St=1;var H=Et;Et|=4,z0.current=null,V4(u,m),kk(m,u),f4(Ky),U=!!Hy,Ky=Hy=null,u.current=m,W4(m),js(),Et=H,St=D,Ys.transition=T}else u.current=m;if(Gp&&(Gp=!1,Qa=u,Hp=C),T=u.pendingLanes,T===0&&(Ya=null),Bd(m.stateNode),as(u,Ut()),h!==null)for(b=u.onRecoverableError,m=0;m<h.length;m++)C=h[m],b(C.value,{componentStack:C.stack,digest:C.digest});if(jp)throw jp=!1,u=V0,V0=null,u;return(Hp&1)!==0&&u.tag!==0&&Sc(),T=u.pendingLanes,(T&1)!==0?u===W0?hh++:(hh=0,W0=u):hh=0,Ha(),null}function Sc(){if(Qa!==null){var u=zl(Hp),h=Ys.transition,m=St;try{if(Ys.transition=null,St=16>u?16:u,Qa===null)var b=!1;else{if(u=Qa,Qa=null,Hp=0,(Et&6)!==0)throw Error(n(331));var C=Et;for(Et|=4,ze=u.current;ze!==null;){var T=ze,D=T.child;if((ze.flags&16)!==0){var H=T.deletions;if(H!==null){for(var Q=0;Q<H.length;Q++){var de=H[Q];for(ze=de;ze!==null;){var Se=ze;switch(Se.tag){case 0:case 11:case 15:uh(8,Se,T)}var ke=Se.child;if(ke!==null)ke.return=Se,ze=ke;else for(;ze!==null;){Se=ze;var be=Se.sibling,Le=Se.return;if(bk(Se),Se===de){ze=null;break}if(be!==null){be.return=Le,ze=be;break}ze=Le}}}var Me=T.alternate;if(Me!==null){var Ue=Me.child;if(Ue!==null){Me.child=null;do{var Sn=Ue.sibling;Ue.sibling=null,Ue=Sn}while(Ue!==null)}}ze=T}}if((T.subtreeFlags&2064)!==0&&D!==null)D.return=T,ze=D;else e:for(;ze!==null;){if(T=ze,(T.flags&2048)!==0)switch(T.tag){case 0:case 11:case 15:uh(9,T,T.return)}var oe=T.sibling;if(oe!==null){oe.return=T.return,ze=oe;break e}ze=T.return}}var te=u.current;for(ze=te;ze!==null;){D=ze;var le=D.child;if((D.subtreeFlags&2064)!==0&&le!==null)le.return=D,ze=le;else e:for(D=te;ze!==null;){if(H=ze,(H.flags&2048)!==0)try{switch(H.tag){case 0:case 11:case 15:Vp(9,H)}}catch(je){xn(H,H.return,je)}if(H===D){ze=null;break e}var Ie=H.sibling;if(Ie!==null){Ie.return=H.return,ze=Ie;break e}ze=H.return}}if(Et=C,Ha(),nr&&typeof nr.onPostCommitFiberRoot=="function")try{nr.onPostCommitFiberRoot(Vn,u)}catch{}b=!0}return b}finally{St=m,Ys.transition=h}}return!1}function Fk(u,h,m){h=xc(m,h),h=ek(u,h,1),u=Xa(u,h,1),h=zr(),u!==null&&(qo(u,1,h),as(u,h))}function xn(u,h,m){if(u.tag===3)Fk(u,u,m);else for(;h!==null;){if(h.tag===3){Fk(h,u,m);break}else if(h.tag===1){var b=h.stateNode;if(typeof h.type.getDerivedStateFromError=="function"||typeof b.componentDidCatch=="function"&&(Ya===null||!Ya.has(b))){u=xc(m,u),u=tk(h,u,1),h=Xa(h,u,1),u=zr(),h!==null&&(qo(h,1,u),as(h,u));break}}h=h.return}}function X4(u,h,m){var b=u.pingCache;b!==null&&b.delete(h),h=zr(),u.pingedLanes|=u.suspendedLanes&m,Kn===u&&(or&m)===m&&(An===4||An===3&&(or&130023424)===or&&500>Ut()-M0?eu(u,0):B0|=m),as(u,h)}function Lk(u,h){h===0&&((u.mode&1)===0?h=1:(h=Di,Di<<=1,(Di&130023424)===0&&(Di=4194304)));var m=zr();u=Hi(u,h),u!==null&&(qo(u,h,m),as(u,m))}function q4(u){var h=u.memoizedState,m=0;h!==null&&(m=h.retryLane),Lk(u,m)}function Y4(u,h){var m=0;switch(u.tag){case 13:var b=u.stateNode,C=u.memoizedState;C!==null&&(m=C.retryLane);break;case 19:b=u.stateNode;break;default:throw Error(n(314))}b!==null&&b.delete(h),Lk(u,m)}var zk;zk=function(u,h,m){if(u!==null)if(u.memoizedProps!==h.pendingProps||rs.current)os=!0;else{if((u.lanes&m)===0&&(h.flags&128)===0)return os=!1,L4(u,h,m);os=(u.flags&131072)!==0}else os=!1,un&&(h.flags&1048576)!==0&&y$(h,$p,h.index);switch(h.lanes=0,h.tag){case 2:var b=h.type;Bp(u,h),u=h.pendingProps;var C=cc(h,mr.current);gc(h,m),C=y0(null,h,b,u,C,m);var T=x0();return h.flags|=1,typeof C=="object"&&C!==null&&typeof C.render=="function"&&C.$$typeof===void 0?(h.tag=1,h.memoizedState=null,h.updateQueue=null,ss(b)?(T=!0,wp(h)):T=!1,h.memoizedState=C.state!==null&&C.state!==void 0?C.state:null,c0(h),C.updater=Lp,h.stateNode=C,C._reactInternals=h,$0(h,b,u,m),h=N0(null,h,b,!0,T,m)):(h.tag=0,un&&T&&e0(h),Lr(null,h,C,m),h=h.child),h;case 16:b=h.elementType;e:{switch(Bp(u,h),u=h.pendingProps,C=b._init,b=C(b._payload),h.type=b,C=h.tag=Z4(b),u=To(b,u),C){case 0:h=I0(null,h,b,u,m);break e;case 1:h=ck(null,h,b,u,m);break e;case 11:h=ok(null,h,b,u,m);break e;case 14:h=ik(null,h,b,To(b.type,u),m);break e}throw Error(n(306,b,""))}return h;case 0:return b=h.type,C=h.pendingProps,C=h.elementType===b?C:To(b,C),I0(u,h,b,C,m);case 1:return b=h.type,C=h.pendingProps,C=h.elementType===b?C:To(b,C),ck(u,h,b,C,m);case 3:e:{if(dk(h),u===null)throw Error(n(387));b=h.pendingProps,T=h.memoizedState,C=T.element,T$(u,h),Rp(h,b,null,m);var D=h.memoizedState;if(b=D.element,T.isDehydrated)if(T={element:b,isDehydrated:!1,cache:D.cache,pendingSuspenseBoundaries:D.pendingSuspenseBoundaries,transitions:D.transitions},h.updateQueue.baseState=T,h.memoizedState=T,h.flags&256){C=xc(Error(n(423)),h),h=hk(u,h,b,m,C);break e}else if(b!==C){C=xc(Error(n(424)),h),h=hk(u,h,b,m,C);break e}else for(Is=Ua(h.stateNode.containerInfo.firstChild),Ts=h,un=!0,ko=null,m=$$(h,null,b,m),h.child=m;m;)m.flags=m.flags&-3|4096,m=m.sibling;else{if(fc(),b===C){h=Xi(u,h,m);break e}Lr(u,h,b,m)}h=h.child}return h;case 5:return E$(h),u===null&&r0(h),b=h.type,C=h.pendingProps,T=u!==null?u.memoizedProps:null,D=C.children,Xy(b,C)?D=null:T!==null&&Xy(b,T)&&(h.flags|=32),uk(u,h),Lr(u,h,D,m),h.child;case 6:return u===null&&r0(h),null;case 13:return fk(u,h,m);case 4:return d0(h,h.stateNode.containerInfo),b=h.pendingProps,u===null?h.child=pc(h,null,b,m):Lr(u,h,b,m),h.child;case 11:return b=h.type,C=h.pendingProps,C=h.elementType===b?C:To(b,C),ok(u,h,b,C,m);case 7:return Lr(u,h,h.pendingProps,m),h.child;case 8:return Lr(u,h,h.pendingProps.children,m),h.child;case 12:return Lr(u,h,h.pendingProps.children,m),h.child;case 10:e:{if(b=h.type._context,C=h.pendingProps,T=h.memoizedProps,D=C.value,Jt(Ip,b._currentValue),b._currentValue=D,T!==null)if($o(T.value,D)){if(T.children===C.children&&!rs.current){h=Xi(u,h,m);break e}}else for(T=h.child,T!==null&&(T.return=h);T!==null;){var H=T.dependencies;if(H!==null){D=T.child;for(var Q=H.firstContext;Q!==null;){if(Q.context===b){if(T.tag===1){Q=Ki(-1,m&-m),Q.tag=2;var de=T.updateQueue;if(de!==null){de=de.shared;var Se=de.pending;Se===null?Q.next=Q:(Q.next=Se.next,Se.next=Q),de.pending=Q}}T.lanes|=m,Q=T.alternate,Q!==null&&(Q.lanes|=m),l0(T.return,m,h),H.lanes|=m;break}Q=Q.next}}else if(T.tag===10)D=T.type===h.type?null:T.child;else if(T.tag===18){if(D=T.return,D===null)throw Error(n(341));D.lanes|=m,H=D.alternate,H!==null&&(H.lanes|=m),l0(D,m,h),D=T.sibling}else D=T.child;if(D!==null)D.return=T;else for(D=T;D!==null;){if(D===h){D=null;break}if(T=D.sibling,T!==null){T.return=D.return,D=T;break}D=D.return}T=D}Lr(u,h,C.children,m),h=h.child}return h;case 9:return C=h.type,b=h.pendingProps.children,gc(h,m),C=Xs(C),b=b(C),h.flags|=1,Lr(u,h,b,m),h.child;case 14:return b=h.type,C=To(b,h.pendingProps),C=To(b.type,C),ik(u,h,b,C,m);case 15:return ak(u,h,h.type,h.pendingProps,m);case 17:return b=h.type,C=h.pendingProps,C=h.elementType===b?C:To(b,C),Bp(u,h),h.tag=1,ss(b)?(u=!0,wp(h)):u=!1,gc(h,m),Z$(h,b,C),$0(h,b,C,m),N0(null,h,b,!0,u,m);case 19:return mk(u,h,m);case 22:return lk(u,h,m)}throw Error(n(156,h.tag))};function Bk(u,h){return Dl(u,h)}function Q4(u,h,m,b){this.tag=u,this.key=m,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=h,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=b,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Qs(u,h,m,b){return new Q4(u,h,m,b)}function X0(u){return u=u.prototype,!(!u||!u.isReactComponent)}function Z4(u){if(typeof u=="function")return X0(u)?1:0;if(u!=null){if(u=u.$$typeof,u===re)return 11;if(u===ge)return 14}return 2}function el(u,h){var m=u.alternate;return m===null?(m=Qs(u.tag,h,u.key,u.mode),m.elementType=u.elementType,m.type=u.type,m.stateNode=u.stateNode,m.alternate=u,u.alternate=m):(m.pendingProps=h,m.type=u.type,m.flags=0,m.subtreeFlags=0,m.deletions=null),m.flags=u.flags&14680064,m.childLanes=u.childLanes,m.lanes=u.lanes,m.child=u.child,m.memoizedProps=u.memoizedProps,m.memoizedState=u.memoizedState,m.updateQueue=u.updateQueue,h=u.dependencies,m.dependencies=h===null?null:{lanes:h.lanes,firstContext:h.firstContext},m.sibling=u.sibling,m.index=u.index,m.ref=u.ref,m}function Yp(u,h,m,b,C,T){var D=2;if(b=u,typeof u=="function")X0(u)&&(D=1);else if(typeof u=="string")D=5;else e:switch(u){case F:return nu(m.children,C,T,h);case B:D=8,C|=8;break;case M:return u=Qs(12,m,h,C|2),u.elementType=M,u.lanes=T,u;case ie:return u=Qs(13,m,h,C),u.elementType=ie,u.lanes=T,u;case me:return u=Qs(19,m,h,C),u.elementType=me,u.lanes=T,u;case $e:return Qp(m,C,T,h);default:if(typeof u=="object"&&u!==null)switch(u.$$typeof){case V:D=10;break e;case P:D=9;break e;case re:D=11;break e;case ge:D=14;break e;case ve:D=16,b=null;break e}throw Error(n(130,u==null?u:typeof u,""))}return h=Qs(D,m,h,C),h.elementType=u,h.type=b,h.lanes=T,h}function nu(u,h,m,b){return u=Qs(7,u,b,h),u.lanes=m,u}function Qp(u,h,m,b){return u=Qs(22,u,b,h),u.elementType=$e,u.lanes=m,u.stateNode={isHidden:!1},u}function q0(u,h,m){return u=Qs(6,u,null,h),u.lanes=m,u}function Y0(u,h,m){return h=Qs(4,u.children!==null?u.children:[],u.key,h),h.lanes=m,h.stateNode={containerInfo:u.containerInfo,pendingChildren:null,implementation:u.implementation},h}function J4(u,h,m,b,C){this.tag=h,this.containerInfo=u,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=Li(0),this.expirationTimes=Li(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Li(0),this.identifierPrefix=b,this.onRecoverableError=C,this.mutableSourceEagerHydrationData=null}function Q0(u,h,m,b,C,T,D,H,Q){return u=new J4(u,h,m,H,Q),h===1?(h=1,T===!0&&(h|=8)):h=0,T=Qs(3,null,null,h),u.current=T,T.stateNode=u,T.memoizedState={element:b,isDehydrated:m,cache:null,transitions:null,pendingSuspenseBoundaries:null},c0(T),u}function eL(u,h,m){var b=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:O,key:b==null?null:""+b,children:u,containerInfo:h,implementation:m}}function Mk(u){if(!u)return Ga;u=u._reactInternals;e:{if(Bn(u)!==u||u.tag!==1)throw Error(n(170));var h=u;do{switch(h.tag){case 3:h=h.stateNode.context;break e;case 1:if(ss(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break e}}h=h.return}while(h!==null);throw Error(n(171))}if(u.tag===1){var m=u.type;if(ss(m))return p$(u,m,h)}return h}function Vk(u,h,m,b,C,T,D,H,Q){return u=Q0(m,b,!0,u,C,T,D,H,Q),u.context=Mk(null),m=u.current,b=zr(),C=Za(m),T=Ki(b,C),T.callback=h??null,Xa(m,T,C),u.current.lanes=C,qo(u,C,b),as(u,b),u}function Zp(u,h,m,b){var C=h.current,T=zr(),D=Za(C);return m=Mk(m),h.context===null?h.context=m:h.pendingContext=m,h=Ki(T,D),h.payload={element:u},b=b===void 0?null:b,b!==null&&(h.callback=b),u=Xa(C,h,D),u!==null&&(Eo(u,C,D,T),Ep(u,C,D)),D}function Jp(u){if(u=u.current,!u.child)return null;switch(u.child.tag){case 5:return u.child.stateNode;default:return u.child.stateNode}}function Wk(u,h){if(u=u.memoizedState,u!==null&&u.dehydrated!==null){var m=u.retryLane;u.retryLane=m!==0&&m<h?m:h}}function Z0(u,h){Wk(u,h),(u=u.alternate)&&Wk(u,h)}function tL(){return null}var Uk=typeof reportError=="function"?reportError:function(u){console.error(u)};function J0(u){this._internalRoot=u}em.prototype.render=J0.prototype.render=function(u){var h=this._internalRoot;if(h===null)throw Error(n(409));Zp(u,h,null,null)},em.prototype.unmount=J0.prototype.unmount=function(){var u=this._internalRoot;if(u!==null){this._internalRoot=null;var h=u.containerInfo;Jl(function(){Zp(null,u,null,null)}),h[Wi]=null}};function em(u){this._internalRoot=u}em.prototype.unstable_scheduleHydration=function(u){if(u){var h=Yo();u={blockedOn:null,target:u,priority:h};for(var m=0;m<es.length&&h!==0&&h<es[m].priority;m++);es.splice(m,0,u),m===0&&wo(u)}};function e1(u){return!(!u||u.nodeType!==1&&u.nodeType!==9&&u.nodeType!==11)}function tm(u){return!(!u||u.nodeType!==1&&u.nodeType!==9&&u.nodeType!==11&&(u.nodeType!==8||u.nodeValue!==" react-mount-point-unstable "))}function jk(){}function nL(u,h,m,b,C){if(C){if(typeof b=="function"){var T=b;b=function(){var de=Jp(D);T.call(de)}}var D=Vk(h,b,u,0,null,!1,!1,"",jk);return u._reactRootContainer=D,u[Wi]=D.current,Yd(u.nodeType===8?u.parentNode:u),Jl(),D}for(;C=u.lastChild;)u.removeChild(C);if(typeof b=="function"){var H=b;b=function(){var de=Jp(Q);H.call(de)}}var Q=Q0(u,0,!1,null,null,!1,!1,"",jk);return u._reactRootContainer=Q,u[Wi]=Q.current,Yd(u.nodeType===8?u.parentNode:u),Jl(function(){Zp(h,Q,m,b)}),Q}function nm(u,h,m,b,C){var T=m._reactRootContainer;if(T){var D=T;if(typeof C=="function"){var H=C;C=function(){var Q=Jp(D);H.call(Q)}}Zp(h,D,u,C)}else D=nL(m,h,u,C,b);return Jp(D)}zi=function(u){switch(u.tag){case 3:var h=u.stateNode;if(h.current.memoizedState.isDehydrated){var m=Xo(h.pendingLanes);m!==0&&(Ll(h,m|1),as(h,Ut()),(Et&6)===0&&(wc=Ut()+500,Ha()))}break;case 13:Jl(function(){var b=Hi(u,1);if(b!==null){var C=zr();Eo(b,u,1,C)}}),Z0(u,1)}},Ba=function(u){if(u.tag===13){var h=Hi(u,134217728);if(h!==null){var m=zr();Eo(h,u,134217728,m)}Z0(u,134217728)}},Bi=function(u){if(u.tag===13){var h=Za(u),m=Hi(u,h);if(m!==null){var b=zr();Eo(m,u,h,b)}Z0(u,h)}},Yo=function(){return St},Qu=function(u,h){var m=St;try{return St=u,h()}finally{St=m}},Vs=function(u,h,m){switch(h){case"input":if(Ia(u,m),h=m.name,m.type==="radio"&&h!=null){for(m=u;m.parentNode;)m=m.parentNode;for(m=m.querySelectorAll("input[name="+JSON.stringify(""+h)+'][type="radio"]'),h=0;h<m.length;h++){var b=m[h];if(b!==u&&b.form===u.form){var C=vp(b);if(!C)throw Error(n(90));ki(b),Ia(b,C)}}}break;case"textarea":Cs(u,m);break;case"select":h=m.value,h!=null&&Ss(u,!!m.multiple,h,!1)}},Aa=G0,Pl=Jl;var rL={usingClientEntryPoint:!1,Events:[Jd,lc,vp,_l,Ws,G0]},fh={findFiberByHostInstance:Gl,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},sL={bundleType:fh.bundleType,version:fh.version,rendererPackageName:fh.rendererPackageName,rendererConfig:fh.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:R.ReactCurrentDispatcher,findHostInstanceByFiber:function(u){return u=Oa(u),u===null?null:u.stateNode},findFiberByHostInstance:fh.findFiberByHostInstance||tL,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var rm=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!rm.isDisabled&&rm.supportsFiber)try{Vn=rm.inject(sL),nr=rm}catch{}}return ls.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=rL,ls.createPortal=function(u,h){var m=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!e1(h))throw Error(n(200));return eL(u,h,null,m)},ls.createRoot=function(u,h){if(!e1(u))throw Error(n(299));var m=!1,b="",C=Uk;return h!=null&&(h.unstable_strictMode===!0&&(m=!0),h.identifierPrefix!==void 0&&(b=h.identifierPrefix),h.onRecoverableError!==void 0&&(C=h.onRecoverableError)),h=Q0(u,1,!1,null,null,m,!1,b,C),u[Wi]=h.current,Yd(u.nodeType===8?u.parentNode:u),new J0(h)},ls.findDOMNode=function(u){if(u==null)return null;if(u.nodeType===1)return u;var h=u._reactInternals;if(h===void 0)throw typeof u.render=="function"?Error(n(188)):(u=Object.keys(u).join(","),Error(n(268,u)));return u=Oa(h),u=u===null?null:u.stateNode,u},ls.flushSync=function(u){return Jl(u)},ls.hydrate=function(u,h,m){if(!tm(h))throw Error(n(200));return nm(null,u,h,!0,m)},ls.hydrateRoot=function(u,h,m){if(!e1(u))throw Error(n(405));var b=m!=null&&m.hydratedSources||null,C=!1,T="",D=Uk;if(m!=null&&(m.unstable_strictMode===!0&&(C=!0),m.identifierPrefix!==void 0&&(T=m.identifierPrefix),m.onRecoverableError!==void 0&&(D=m.onRecoverableError)),h=Vk(h,null,u,1,m??null,C,!1,T,D),u[Wi]=h.current,Yd(u),b)for(u=0;u<b.length;u++)m=b[u],C=m._getVersion,C=C(m._source),h.mutableSourceEagerHydrationData==null?h.mutableSourceEagerHydrationData=[m,C]:h.mutableSourceEagerHydrationData.push(m,C);return new em(h)},ls.render=function(u,h,m){if(!tm(h))throw Error(n(200));return nm(null,u,h,!1,m)},ls.unmountComponentAtNode=function(u){if(!tm(u))throw Error(n(40));return u._reactRootContainer?(Jl(function(){nm(null,null,u,!1,function(){u._reactRootContainer=null,u[Wi]=null})}),!0):!1},ls.unstable_batchedUpdates=G0,ls.unstable_renderSubtreeIntoContainer=function(u,h,m,b){if(!tm(m))throw Error(n(200));if(u==null||u._reactInternals===void 0)throw Error(n(38));return nm(u,h,m,!1,b)},ls.version="18.3.1-next-f1338f8080-20240426",ls}var Jk;function BE(){if(Jk)return r1.exports;Jk=1;function t(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t)}catch(e){console.error(e)}}return t(),r1.exports=hL(),r1.exports}var eT;function fL(){if(eT)return sm;eT=1;var t=BE();return sm.createRoot=t.createRoot,sm.hydrateRoot=t.hydrateRoot,sm}var pL=fL();const mL=Af(pL),gL="/tapfit-app/assets/body_measurement-Be1IKEjH.png";function yL(){return!!(globalThis!=null&&globalThis.document)}function xL(t,...e){if(t==null)throw new TypeError("Cannot convert undefined or null to object");const n={...t};for(const r of e)if(r!=null)for(const s in r)Object.prototype.hasOwnProperty.call(r,s)&&(s in n&&delete n[s],n[s]=r[s]);return n}const ii=t=>t?"":void 0,i1=t=>t?!0:void 0;function px(t){return Array.isArray(t)}function Wr(t){const e=typeof t;return t!=null&&(e==="object"||e==="function")&&!px(t)}function vL(t){const e=t==null?0:t.length;return e?t[e-1]:void 0}function bL(t){const e=parseFloat(t.toString()),n=t.toString().replace(String(e),"");return{unitless:!n,value:e,unit:n}}function mx(t){if(t==null)return t;const{unitless:e}=bL(t);return e||typeof t=="number"?`${t}px`:t}const ME=(t,e)=>parseInt(t[1],10)>parseInt(e[1],10)?1:-1,jv=t=>Object.fromEntries(Object.entries(t).sort(ME));function tT(t){const e=jv(t);return Object.assign(Object.values(e),e)}function wL(t){const e=Object.keys(jv(t));return new Set(e)}function nT(t){if(!t)return t;t=mx(t)??t;const e=-.02;return typeof t=="number"?`${t+e}`:t.replace(/(\d+\.?\d*)/u,n=>`${parseFloat(n)+e}`)}function $h(t,e){const n=["@media screen"];return t&&n.push("and",`(min-width: ${mx(t)})`),e&&n.push("and",`(max-width: ${mx(e)})`),n.join(" ")}function SL(t){if(!t)return null;t.base=t.base??"0px";const e=tT(t),n=Object.entries(t).sort(ME).map(([o,i],a,l)=>{let[,c]=l[a+1]??[];return c=parseFloat(c)>0?nT(c):void 0,{_minW:nT(i),breakpoint:o,minW:i,maxW:c,maxWQuery:$h(null,c),minWQuery:$h(i),minMaxQuery:$h(i,c)}}),r=wL(t),s=Array.from(r.values());return{keys:r,normalized:e,isResponsive(o){const i=Object.keys(o);return i.length>0&&i.every(a=>r.has(a))},asObject:jv(t),asArray:tT(t),details:n,get(o){return n.find(i=>i.breakpoint===o)},media:[null,...e.map(o=>$h(o)).slice(1)],toArrayValue(o){if(!Wr(o))throw new Error("toArrayValue: value must be an object");const i=s.map(a=>o[a]??null);for(;vL(i)===null;)i.pop();return i},toObjectValue(o){if(!Array.isArray(o))throw new Error("toObjectValue: value must be an array");return o.reduce((i,a,l)=>{const c=s[l];return c!=null&&a!=null&&(i[c]=a),i},{})}}}function rT(...t){return function(n){t.some(r=>(r==null||r(n),n==null?void 0:n.defaultPrevented))}}function Gv(t){return J.Children.toArray(t).filter(e=>J.isValidElement(e))}function Vg(t){const e=Object.assign({},t);for(let n in e)e[n]===void 0&&delete e[n];return e}function CL(t,e){return`${t} returned \`undefined\`. Seems you forgot to wrap component within ${e}`}function Kr(t={}){const{name:e,strict:n=!0,hookName:r="useContext",providerName:s="Provider",errorMessage:o,defaultValue:i}=t,a=J.createContext(i);a.displayName=e;function l(){var d;const c=J.useContext(a);if(!c&&n){const f=new Error(o??CL(r,s));throw f.name="ContextError",(d=Error.captureStackTrace)==null||d.call(Error,f,l),f}return c}return[a.Provider,l,a]}const Lt=(...t)=>t.filter(Boolean).join(" ");function $L(t,e,n,r){const s=typeof e=="string"?e.split("."):[e];for(r=0;r<s.length&&t;r+=1)t=t[s[r]];return t===void 0?n:t}const kL=t=>{const e=new WeakMap;return(r,s,o,i)=>{if(typeof r>"u")return t(r,s,o);e.has(r)||e.set(r,new Map);const a=e.get(r);if(a.has(s))return a.get(s);const l=t(r,s,o,i);return a.set(s,l),l}},VE=kL($L),TL=t=>t.default||t;function Hv(t,e=[]){const n=Object.assign({},t);for(const r of e)r in n&&delete n[r];return n}function IL(t,e){const n={};for(const r of e)r in t&&(n[r]=t[r]);return n}function Kv(t,e){return Array.isArray(t)?t.map(n=>n===null?null:e(n)):Wr(t)?Object.keys(t).reduce((n,r)=>(n[r]=e(t[r]),n),{}):t!=null?e(t):null}const NL=t=>typeof t=="function";function so(t,...e){return NL(t)?t(...e):t}function EL(t,...e){const n=Object.getOwnPropertyDescriptors(t),r=Object.keys(n),s=i=>{const a={};for(let l=0;l<i.length;l++){const c=i[l];n[c]&&(Object.defineProperty(a,c,n[c]),delete n[c])}return a},o=i=>s(Array.isArray(i)?i:r.filter(i));return e.map(o).concat(s(r))}function sT(t,e,n={}){const{stop:r,getKey:s}=n;function o(i,a=[]){if(Wr(i)||Array.isArray(i)){const l={};for(const[c,d]of Object.entries(i)){const f=(s==null?void 0:s(c))??c,p=[...a,f];if(r!=null&&r(i,p))return e(i,a);l[f]=o(d,p)}return l}return e(i,a)}return o(t)}var kh={exports:{}};kh.exports;var oT;function RL(){return oT||(oT=1,function(t,e){var n=200,r="__lodash_hash_undefined__",s=800,o=16,i=9007199254740991,a="[object Arguments]",l="[object Array]",c="[object AsyncFunction]",d="[object Boolean]",f="[object Date]",p="[object Error]",g="[object Function]",y="[object GeneratorFunction]",x="[object Map]",w="[object Number]",S="[object Null]",$="[object Object]",I="[object Proxy]",R="[object RegExp]",_="[object Set]",O="[object String]",F="[object Undefined]",B="[object WeakMap]",M="[object ArrayBuffer]",V="[object DataView]",P="[object Float32Array]",re="[object Float64Array]",ie="[object Int8Array]",me="[object Int16Array]",ge="[object Int32Array]",ve="[object Uint8Array]",$e="[object Uint8ClampedArray]",fe="[object Uint16Array]",xe="[object Uint32Array]",ae=/[\\^$.*+?()[\]{}|]/g,q=/^\[object .+?Constructor\]$/,ue=/^(?:0|[1-9]\d*)$/,we={};we[P]=we[re]=we[ie]=we[me]=we[ge]=we[ve]=we[$e]=we[fe]=we[xe]=!0,we[a]=we[l]=we[M]=we[d]=we[V]=we[f]=we[p]=we[g]=we[x]=we[w]=we[$]=we[R]=we[_]=we[O]=we[B]=!1;var Ge=typeof Pc=="object"&&Pc&&Pc.Object===Object&&Pc,et=typeof self=="object"&&self&&self.Object===Object&&self,tt=Ge||et||Function("return this")(),Tt=e&&!e.nodeType&&e,dt=Tt&&!0&&t&&!t.nodeType&&t,vt=dt&&dt.exports===Tt,rn=vt&&Ge.process,_r=function(){try{var U=dt&&dt.require&&dt.require("util").types;return U||rn&&rn.binding&&rn.binding("util")}catch{}}(),ki=_r&&_r.isTypedArray;function zt(U,ee,he){switch(he.length){case 0:return U.call(ee);case 1:return U.call(ee,he[0]);case 2:return U.call(ee,he[0],he[1]);case 3:return U.call(ee,he[0],he[1],he[2])}return U.apply(ee,he)}function sn(U,ee){for(var he=-1,Fe=Array(U);++he<U;)Fe[he]=ee(he);return Fe}function Pr(U){return function(ee){return U(ee)}}function Vo(U,ee){return U==null?void 0:U[ee]}function Ia(U,ee){return function(he){return U(ee(he))}}var El=Array.prototype,Na=Function.prototype,ws=Object.prototype,Ss=tt["__core-js_shared__"],Bs=Na.toString,qr=ws.hasOwnProperty,Cs=function(){var U=/[^.]+$/.exec(Ss&&Ss.keys&&Ss.keys.IE_PROTO||"");return U?"Symbol(src)_1."+U:""}(),Ea=ws.toString,Ti=Bs.call(Object),Ii=RegExp("^"+Bs.call(qr).replace(ae,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),go=vt?tt.Buffer:void 0,Ra=tt.Symbol,Wo=tt.Uint8Array;go&&go.allocUnsafe;var yo=Ia(Object.getPrototypeOf,Object),Rl=Object.create,Uo=ws.propertyIsEnumerable,_a=El.splice,Ms=Ra?Ra.toStringTag:void 0,jo=function(){try{var U=La(Object,"defineProperty");return U({},"",{}),U}catch{}}(),Pa=go?go.isBuffer:void 0,Go=Math.max,$s=Date.now,Vs=La(tt,"Map"),Ar=La(Object,"create"),xo=function(){function U(){}return function(ee){if(!ts(ee))return{};if(Rl)return Rl(ee);U.prototype=ee;var he=new U;return U.prototype=void 0,he}}();function Yr(U){var ee=-1,he=U==null?0:U.length;for(this.clear();++ee<he;){var Fe=U[ee];this.set(Fe[0],Fe[1])}}function _l(){this.__data__=Ar?Ar(null):{},this.size=0}function Ws(U){var ee=this.has(U)&&delete this.__data__[U];return this.size-=ee?1:0,ee}function Aa(U){var ee=this.__data__;if(Ar){var he=ee[U];return he===r?void 0:he}return qr.call(ee,U)?ee[U]:void 0}function Pl(U){var ee=this.__data__;return Ar?ee[U]!==void 0:qr.call(ee,U)}function Ho(U,ee){var he=this.__data__;return this.size+=this.has(U)?0:1,he[U]=Ar&&ee===void 0?r:ee,this}Yr.prototype.clear=_l,Yr.prototype.delete=Ws,Yr.prototype.get=Aa,Yr.prototype.has=Pl,Yr.prototype.set=Ho;function er(U){var ee=-1,he=U==null?0:U.length;for(this.clear();++ee<he;){var Fe=U[ee];this.set(Fe[0],Fe[1])}}function Ni(){this.__data__=[],this.size=0}function Us(U){var ee=this.__data__,he=js(ee,U);if(he<0)return!1;var Fe=ee.length-1;return he==Fe?ee.pop():_a.call(ee,he,1),--this.size,!0}function Ei(U){var ee=this.__data__,he=js(ee,U);return he<0?void 0:ee[he][1]}function ks(U){return js(this.__data__,U)>-1}function Dr(U,ee){var he=this.__data__,Fe=js(he,U);return Fe<0?(++this.size,he.push([U,ee])):he[Fe][1]=ee,this}er.prototype.clear=Ni,er.prototype.delete=Us,er.prototype.get=Ei,er.prototype.has=ks,er.prototype.set=Dr;function Qr(U){var ee=-1,he=U==null?0:U.length;for(this.clear();++ee<he;){var Fe=U[ee];this.set(Fe[0],Fe[1])}}function Xt(){this.size=0,this.__data__={hash:new Yr,map:new(Vs||er),string:new Yr}}function hr(U){var ee=wn(this,U).delete(U);return this.size-=ee?1:0,ee}function Al(U){return wn(this,U).get(U)}function zd(U){return wn(this,U).has(U)}function Da(U,ee){var he=wn(this,U),Fe=he.size;return he.set(U,ee),this.size+=he.size==Fe?0:1,this}Qr.prototype.clear=Xt,Qr.prototype.delete=hr,Qr.prototype.get=Al,Qr.prototype.has=zd,Qr.prototype.set=Da;function Bn(U){var ee=this.__data__=new er(U);this.size=ee.size}function Ri(){this.__data__=new er,this.size=0}function Ko(U){var ee=this.__data__,he=ee.delete(U);return this.size=ee.size,he}function qu(U){return this.__data__.get(U)}function Oa(U){return this.__data__.has(U)}function Fa(U,ee){var he=this.__data__;if(he instanceof er){var Fe=he.__data__;if(!Vs||Fe.length<n-1)return Fe.push([U,ee]),this.size=++he.size,this;he=this.__data__=new Qr(Fe)}return he.set(U,ee),this.size=he.size,this}Bn.prototype.clear=Ri,Bn.prototype.delete=Ko,Bn.prototype.get=qu,Bn.prototype.has=Oa,Bn.prototype.set=Fa;function Dl(U,ee){var he=pr(U),Fe=!he&&Jr(U),ht=!he&&!Fe&&Qo(U),It=!he&&!Fe&&!ht&&wo(U),Nt=he||Fe||ht||It,at=Nt?sn(U.length,String):[],_t=at.length;for(var jn in U)Nt&&(jn=="length"||ht&&(jn=="offset"||jn=="parent")||It&&(jn=="buffer"||jn=="byteLength"||jn=="byteOffset")||Li(jn,_t))||at.push(jn);return at}function Mn(U,ee,he){(he!==void 0&&!bo(U[ee],he)||he===void 0&&!(ee in U))&&Ut(U,ee,he)}function Zr(U,ee,he){var Fe=U[ee];(!(qr.call(U,ee)&&bo(Fe,he))||he===void 0&&!(ee in U))&&Ut(U,ee,he)}function js(U,ee){for(var he=U.length;he--;)if(bo(U[he][0],ee))return he;return-1}function Ut(U,ee,he){ee=="__proto__"&&jo?jo(U,ee,{configurable:!0,enumerable:!0,value:he,writable:!0}):U[ee]=he}var Ol=Oi();function vo(U){return U==null?U===void 0?F:S:Ms&&Ms in Object(U)?za(U):zi(U)}function _i(U){return ns(U)&&vo(U)==a}function tr(U){if(!ts(U)||Ll(U))return!1;var ee=es(U)?Ii:q;return ee.test(Bl(U))}function Yu(U){return ns(U)&&Zu(U.length)&&!!we[vo(U)]}function Pi(U){if(!ts(U))return zl(U);var ee=St(U),he=[];for(var Fe in U)Fe=="constructor"&&(ee||!qr.call(U,Fe))||he.push(Fe);return he}function Vn(U,ee,he,Fe,ht){U!==ee&&Ol(ee,function(It,Nt){if(ht||(ht=new Bn),ts(It))nr(U,ee,Nt,he,Vn,Fe,ht);else{var at=Fe?Fe(Bi(U,Nt),It,Nt+"",U,ee,ht):void 0;at===void 0&&(at=It),Mn(U,Nt,at)}},Ml)}function nr(U,ee,he,Fe,ht,It,Nt){var at=Bi(U,he),_t=Bi(ee,he),jn=Nt.get(_t);if(jn){Mn(U,he,jn);return}var Gn=It?It(at,_t,he+"",U,ee,Nt):void 0,Or=Gn===void 0;if(Or){var Co=pr(_t),Ma=!Co&&Qo(_t),Rn=!Co&&!Ma&&wo(_t);Gn=_t,Co||Ma||Rn?pr(at)?Gn=at:Mi(at)?Gn=Ai(at):Ma?(Or=!1,Gn=Fl(_t)):Rn?(Or=!1,Gn=Vd(_t)):Gn=[]:Ju(_t)||Jr(_t)?(Gn=at,Jr(at)?Gn=Un(at):(!ts(at)||es(at))&&(Gn=Fi(_t))):Or=!1}Or&&(Nt.set(_t,Gn),ht(Gn,_t,Fe,It,Nt),Nt.delete(_t)),Mn(U,he,Gn)}function Bd(U,ee){return Yo(Ba(U,ee,So),U+"")}var fr=jo?function(U,ee){return jo(U,"toString",{configurable:!0,enumerable:!1,value:Zo(ee),writable:!0})}:So;function Fl(U,ee){return U.slice()}function Md(U){var ee=new U.constructor(U.byteLength);return new Wo(ee).set(new Wo(U)),ee}function Vd(U,ee){var he=Md(U.buffer);return new U.constructor(he,U.byteOffset,U.length)}function Ai(U,ee){var he=-1,Fe=U.length;for(ee||(ee=Array(Fe));++he<Fe;)ee[he]=U[he];return ee}function Di(U,ee,he,Fe){var ht=!he;he||(he={});for(var It=-1,Nt=ee.length;++It<Nt;){var at=ee[It],_t=void 0;_t===void 0&&(_t=U[at]),ht?Ut(he,at,_t):Zr(he,at,_t)}return he}function Xo(U){return Bd(function(ee,he){var Fe=-1,ht=he.length,It=ht>1?he[ht-1]:void 0,Nt=ht>2?he[2]:void 0;for(It=U.length>3&&typeof It=="function"?(ht--,It):void 0,Nt&&qo(he[0],he[1],Nt)&&(It=ht<3?void 0:It,ht=1),ee=Object(ee);++Fe<ht;){var at=he[Fe];at&&U(ee,at,Fe,It)}return ee})}function Oi(U){return function(ee,he,Fe){for(var ht=-1,It=Object(ee),Nt=Fe(ee),at=Nt.length;at--;){var _t=Nt[++ht];if(he(It[_t],_t,It)===!1)break}return ee}}function wn(U,ee){var he=U.__data__;return Wd(ee)?he[typeof ee=="string"?"string":"hash"]:he.map}function La(U,ee){var he=Vo(U,ee);return tr(he)?he:void 0}function za(U){var ee=qr.call(U,Ms),he=U[Ms];try{U[Ms]=void 0;var Fe=!0}catch{}var ht=Ea.call(U);return Fe&&(ee?U[Ms]=he:delete U[Ms]),ht}function Fi(U){return typeof U.constructor=="function"&&!St(U)?xo(yo(U)):{}}function Li(U,ee){var he=typeof U;return ee=ee??i,!!ee&&(he=="number"||he!="symbol"&&ue.test(U))&&U>-1&&U%1==0&&U<ee}function qo(U,ee,he){if(!ts(he))return!1;var Fe=typeof ee;return(Fe=="number"?Wn(he)&&Li(ee,he.length):Fe=="string"&&ee in he)?bo(he[ee],U):!1}function Wd(U){var ee=typeof U;return ee=="string"||ee=="number"||ee=="symbol"||ee=="boolean"?U!=="__proto__":U===null}function Ll(U){return!!Cs&&Cs in U}function St(U){var ee=U&&U.constructor,he=typeof ee=="function"&&ee.prototype||ws;return U===he}function zl(U){var ee=[];if(U!=null)for(var he in Object(U))ee.push(he);return ee}function zi(U){return Ea.call(U)}function Ba(U,ee,he){return ee=Go(ee===void 0?U.length-1:ee,0),function(){for(var Fe=arguments,ht=-1,It=Go(Fe.length-ee,0),Nt=Array(It);++ht<It;)Nt[ht]=Fe[ee+ht];ht=-1;for(var at=Array(ee+1);++ht<ee;)at[ht]=Fe[ht];return at[ee]=he(Nt),zt(U,this,at)}}function Bi(U,ee){if(!(ee==="constructor"&&typeof U[ee]=="function")&&ee!="__proto__")return U[ee]}var Yo=Qu(fr);function Qu(U){var ee=0,he=0;return function(){var Fe=$s(),ht=o-(Fe-he);if(he=Fe,ht>0){if(++ee>=s)return arguments[0]}else ee=0;return U.apply(void 0,arguments)}}function Bl(U){if(U!=null){try{return Bs.call(U)}catch{}try{return U+""}catch{}}return""}function bo(U,ee){return U===ee||U!==U&&ee!==ee}var Jr=_i(function(){return arguments}())?_i:function(U){return ns(U)&&qr.call(U,"callee")&&!Uo.call(U,"callee")},pr=Array.isArray;function Wn(U){return U!=null&&Zu(U.length)&&!es(U)}function Mi(U){return ns(U)&&Wn(U)}var Qo=Pa||Gs;function es(U){if(!ts(U))return!1;var ee=vo(U);return ee==g||ee==y||ee==c||ee==I}function Zu(U){return typeof U=="number"&&U>-1&&U%1==0&&U<=i}function ts(U){var ee=typeof U;return U!=null&&(ee=="object"||ee=="function")}function ns(U){return U!=null&&typeof U=="object"}function Ju(U){if(!ns(U)||vo(U)!=$)return!1;var ee=yo(U);if(ee===null)return!0;var he=qr.call(ee,"constructor")&&ee.constructor;return typeof he=="function"&&he instanceof he&&Bs.call(he)==Ti}var wo=ki?Pr(ki):Yu;function Un(U){return Di(U,Ml(U))}function Ml(U){return Wn(U)?Dl(U):Pi(U)}var Ud=Xo(function(U,ee,he,Fe){Vn(U,ee,he,Fe)});function Zo(U){return function(){return U}}function So(U){return U}function Gs(){return!1}t.exports=Ud}(kh,kh.exports)),kh.exports}var _L=RL();const oo=Af(_L);function PL(t,e=[]){const n=J.useRef(t);return J.useEffect(()=>{n.current=t}),J.useCallback((...r)=>{var s;return(s=n.current)==null?void 0:s.call(n,...r)},e)}const ng=globalThis!=null&&globalThis.document?J.useLayoutEffect:J.useEffect,iT=(t,e)=>{const n=J.useRef(!1),r=J.useRef(!1);J.useEffect(()=>{if(n.current&&r.current)return t();r.current=!0},e),J.useEffect(()=>(n.current=!0,()=>{n.current=!1}),[])};function AL(t,e){if(t!=null){if(typeof t=="function"){t(e);return}try{t.current=e}catch{throw new Error(`Cannot assign value '${e}' to ref '${t}'`)}}}function gx(...t){return e=>{t.forEach(n=>{AL(n,e)})}}function DL(...t){return J.useMemo(()=>gx(...t),t)}function OL(t,e){const n=PL(t);J.useEffect(()=>{if(e==null)return;let r=null;return r=window.setTimeout(()=>{n()},e),()=>{r&&window.clearTimeout(r)}},[e,n])}const Dn={open:(t,e)=>`${t}[data-open], ${t}[open], ${t}[data-state=open] ${e}`,closed:(t,e)=>`${t}[data-closed], ${t}[data-state=closed] ${e}`,hover:(t,e)=>`${t}:hover ${e}, ${t}[data-hover] ${e}`,focus:(t,e)=>`${t}:focus ${e}, ${t}[data-focus] ${e}`,focusVisible:(t,e)=>`${t}:focus-visible ${e}`,focusWithin:(t,e)=>`${t}:focus-within ${e}`,active:(t,e)=>`${t}:active ${e}, ${t}[data-active] ${e}`,disabled:(t,e)=>`${t}:disabled ${e}, ${t}[data-disabled] ${e}`,invalid:(t,e)=>`${t}:invalid ${e}, ${t}[data-invalid] ${e}`,checked:(t,e)=>`${t}:checked ${e}, ${t}[data-checked] ${e}`,placeholderShown:(t,e)=>`${t}:placeholder-shown ${e}`},si=t=>WE(e=>t(e,"&"),"[role=group]","[data-group]",".group"),Yi=t=>WE(e=>t(e,"~ &"),"[data-peer]",".peer"),WE=(t,...e)=>e.map(t).join(", "),jc={_hover:"&:hover, &[data-hover]",_active:"&:active, &[data-active]",_focus:"&:focus, &[data-focus]",_highlighted:"&[data-highlighted]",_focusWithin:"&:focus-within, &[data-focus-within]",_focusVisible:"&:focus-visible, &[data-focus-visible]",_disabled:"&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]",_readOnly:"&[aria-readonly=true], &[readonly], &[data-readonly]",_before:"&::before",_after:"&::after",_empty:"&:empty, &[data-empty]",_expanded:"&[aria-expanded=true], &[data-expanded], &[data-state=expanded]",_checked:"&[aria-checked=true], &[data-checked], &[data-state=checked]",_grabbed:"&[aria-grabbed=true], &[data-grabbed]",_pressed:"&[aria-pressed=true], &[data-pressed]",_invalid:"&[aria-invalid=true], &[data-invalid]",_valid:"&[data-valid], &[data-state=valid]",_loading:"&[data-loading], &[aria-busy=true]",_selected:"&[aria-selected=true], &[data-selected]",_hidden:"&[hidden], &[data-hidden]",_autofill:"&:-webkit-autofill",_even:"&:nth-of-type(even)",_odd:"&:nth-of-type(odd)",_first:"&:first-of-type",_firstLetter:"&::first-letter",_last:"&:last-of-type",_notFirst:"&:not(:first-of-type)",_notLast:"&:not(:last-of-type)",_visited:"&:visited",_activeLink:"&[aria-current=page]",_activeStep:"&[aria-current=step]",_indeterminate:"&:indeterminate, &[aria-checked=mixed], &[data-indeterminate], &[data-state=indeterminate]",_groupOpen:si(Dn.open),_groupClosed:si(Dn.closed),_groupHover:si(Dn.hover),_peerHover:Yi(Dn.hover),_groupFocus:si(Dn.focus),_peerFocus:Yi(Dn.focus),_groupFocusVisible:si(Dn.focusVisible),_peerFocusVisible:Yi(Dn.focusVisible),_groupActive:si(Dn.active),_peerActive:Yi(Dn.active),_groupDisabled:si(Dn.disabled),_peerDisabled:Yi(Dn.disabled),_groupInvalid:si(Dn.invalid),_peerInvalid:Yi(Dn.invalid),_groupChecked:si(Dn.checked),_peerChecked:Yi(Dn.checked),_groupFocusWithin:si(Dn.focusWithin),_peerFocusWithin:Yi(Dn.focusWithin),_peerPlaceholderShown:Yi(Dn.placeholderShown),_placeholder:"&::placeholder, &[data-placeholder]",_placeholderShown:"&:placeholder-shown, &[data-placeholder-shown]",_fullScreen:"&:fullscreen, &[data-fullscreen]",_selection:"&::selection",_rtl:"[dir=rtl] &, &[dir=rtl]",_ltr:"[dir=ltr] &, &[dir=ltr]",_mediaDark:"@media (prefers-color-scheme: dark)",_mediaReduceMotion:"@media (prefers-reduced-motion: reduce)",_dark:".chakra-ui-dark &:not([data-theme]),[data-theme=dark] &:not([data-theme]),&[data-theme=dark]",_light:".chakra-ui-light &:not([data-theme]),[data-theme=light] &:not([data-theme]),&[data-theme=light]",_horizontal:"&[data-orientation=horizontal]",_vertical:"&[data-orientation=vertical]",_open:"&[data-open], &[open], &[data-state=open]",_closed:"&[data-closed], &[data-state=closed]",_complete:"&[data-complete]",_incomplete:"&[data-incomplete]",_current:"&[data-current]"},UE=Object.keys(jc),FL=t=>/!(important)?$/.test(t),aT=t=>typeof t=="string"?t.replace(/!(important)?$/,"").trim():t,LL=(t,e)=>n=>{const r=String(e),s=FL(r),o=aT(r),i=t?`${t}.${o}`:o;let a=Wr(n.__cssMap)&&i in n.__cssMap?n.__cssMap[i].varRef:e;return a=aT(a),s?`${a} !important`:a};function Xv(t){const{scale:e,transform:n,compose:r}=t;return(o,i)=>{const a=LL(e,o)(i);let l=(n==null?void 0:n(a,i))??a;return r&&(l=r(l,i)),l}}const om=(...t)=>e=>t.reduce((n,r)=>r(n),e);function Zs(t,e){return n=>{const r={property:n,scale:t};return r.transform=Xv({scale:t,transform:e}),r}}const zL=({rtl:t,ltr:e})=>n=>n.direction==="rtl"?t:e;function BL(t){const{property:e,scale:n,transform:r}=t;return{scale:n,property:zL(e),transform:n?Xv({scale:n,compose:r}):r}}const jE=["rotate(var(--chakra-rotate, 0))","scaleX(var(--chakra-scale-x, 1))","scaleY(var(--chakra-scale-y, 1))","skewX(var(--chakra-skew-x, 0))","skewY(var(--chakra-skew-y, 0))"];function ML(){return["translateX(var(--chakra-translate-x, 0))","translateY(var(--chakra-translate-y, 0))",...jE].join(" ")}function VL(){return["translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)",...jE].join(" ")}const WL={"--chakra-blur":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-brightness":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-contrast":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-grayscale":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-hue-rotate":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-invert":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-saturate":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-sepia":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-drop-shadow":"var(--chakra-empty,/*!*/ /*!*/)",filter:["var(--chakra-blur)","var(--chakra-brightness)","var(--chakra-contrast)","var(--chakra-grayscale)","var(--chakra-hue-rotate)","var(--chakra-invert)","var(--chakra-saturate)","var(--chakra-sepia)","var(--chakra-drop-shadow)"].join(" ")},UL={backdropFilter:["var(--chakra-backdrop-blur)","var(--chakra-backdrop-brightness)","var(--chakra-backdrop-contrast)","var(--chakra-backdrop-grayscale)","var(--chakra-backdrop-hue-rotate)","var(--chakra-backdrop-invert)","var(--chakra-backdrop-opacity)","var(--chakra-backdrop-saturate)","var(--chakra-backdrop-sepia)"].join(" "),"--chakra-backdrop-blur":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-brightness":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-contrast":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-grayscale":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-hue-rotate":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-invert":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-opacity":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-saturate":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-sepia":"var(--chakra-empty,/*!*/ /*!*/)"};function jL(t){return{"--chakra-ring-offset-shadow":"var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)","--chakra-ring-shadow":"var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)","--chakra-ring-width":t,boxShadow:["var(--chakra-ring-offset-shadow)","var(--chakra-ring-shadow)","var(--chakra-shadow, 0 0 #0000)"].join(", ")}}const GL={"row-reverse":{space:"--chakra-space-x-reverse",divide:"--chakra-divide-x-reverse"},"column-reverse":{space:"--chakra-space-y-reverse",divide:"--chakra-divide-y-reverse"}},yx={"to-t":"to top","to-tr":"to top right","to-r":"to right","to-br":"to bottom right","to-b":"to bottom","to-bl":"to bottom left","to-l":"to left","to-tl":"to top left"},HL=new Set(Object.values(yx)),xx=new Set(["none","-moz-initial","inherit","initial","revert","unset"]),KL=t=>t.trim();function XL(t,e){if(t==null||xx.has(t))return t;if(!(vx(t)||xx.has(t)))return`url('${t}')`;const s=/(^[a-z-A-Z]+)\((.*)\)/g.exec(t),o=s==null?void 0:s[1],i=s==null?void 0:s[2];if(!o||!i)return t;const a=o.includes("-gradient")?o:`${o}-gradient`,[l,...c]=i.split(",").map(KL).filter(Boolean);if((c==null?void 0:c.length)===0)return t;const d=l in yx?yx[l]:l;c.unshift(d);const f=c.map(p=>{if(HL.has(p))return p;const g=p.indexOf(" "),[y,x]=g!==-1?[p.substr(0,g),p.substr(g+1)]:[p],w=vx(x)?x:x&&x.split(" "),S=`colors.${y}`,$=S in e.__cssMap?e.__cssMap[S].varRef:y;return w?[$,...Array.isArray(w)?w:[w]].join(" "):$});return`${a}(${f.join(", ")})`}const vx=t=>typeof t=="string"&&t.includes("(")&&t.includes(")"),qL=(t,e)=>XL(t,e??{});function YL(t){return/^var\(--.+\)$/.test(t)}const QL=t=>{const e=parseFloat(t.toString()),n=t.toString().replace(String(e),"");return{unitless:!n,value:e,unit:n}},oi=t=>e=>`${t}(${e})`,Ct={filter(t){return t!=="auto"?t:WL},backdropFilter(t){return t!=="auto"?t:UL},ring(t){return jL(Ct.px(t))},bgClip(t){return t==="text"?{color:"transparent",backgroundClip:"text"}:{backgroundClip:t}},transform(t){return t==="auto"?ML():t==="auto-gpu"?VL():t},vh(t){return t==="$100vh"?"var(--chakra-vh)":t},px(t){if(t==null)return t;const{unitless:e}=QL(t);return e||typeof t=="number"?`${t}px`:t},fraction(t){return typeof t!="number"||t>1?t:`${t*100}%`},float(t,e){const n={left:"right",right:"left"};return e.direction==="rtl"?n[t]:t},degree(t){if(YL(t)||t==null)return t;const e=typeof t=="string"&&!t.endsWith("deg");return typeof t=="number"||e?`${t}deg`:t},gradient:qL,blur:oi("blur"),opacity:oi("opacity"),brightness:oi("brightness"),contrast:oi("contrast"),dropShadow:oi("drop-shadow"),grayscale:oi("grayscale"),hueRotate:t=>oi("hue-rotate")(Ct.degree(t)),invert:oi("invert"),saturate:oi("saturate"),sepia:oi("sepia"),bgImage(t){return t==null||vx(t)||xx.has(t)?t:`url(${t})`},outline(t){const e=String(t)==="0"||String(t)==="none";return t!==null&&e?{outline:"2px solid transparent",outlineOffset:"2px"}:{outline:t}},flexDirection(t){const{space:e,divide:n}=GL[t]??{},r={flexDirection:t};return e&&(r[e]=1),n&&(r[n]=1),r}},ne={borderWidths:Zs("borderWidths"),borderStyles:Zs("borderStyles"),colors:Zs("colors"),borders:Zs("borders"),gradients:Zs("gradients",Ct.gradient),radii:Zs("radii",Ct.px),space:Zs("space",om(Ct.vh,Ct.px)),spaceT:Zs("space",om(Ct.vh,Ct.px)),degreeT(t){return{property:t,transform:Ct.degree}},prop(t,e,n){return{property:t,scale:e,...e&&{transform:Xv({scale:e,transform:n})}}},propT(t,e){return{property:t,transform:e}},sizes:Zs("sizes",om(Ct.vh,Ct.px)),sizesT:Zs("sizes",om(Ct.vh,Ct.fraction)),shadows:Zs("shadows"),logical:BL,blur:Zs("blur",Ct.blur)},Em={background:ne.colors("background"),backgroundColor:ne.colors("backgroundColor"),backgroundImage:ne.gradients("backgroundImage"),backgroundSize:!0,backgroundPosition:!0,backgroundRepeat:!0,backgroundAttachment:!0,backgroundClip:{transform:Ct.bgClip},bgSize:ne.prop("backgroundSize"),bgPosition:ne.prop("backgroundPosition"),bg:ne.colors("background"),bgColor:ne.colors("backgroundColor"),bgPos:ne.prop("backgroundPosition"),bgRepeat:ne.prop("backgroundRepeat"),bgAttachment:ne.prop("backgroundAttachment"),bgGradient:ne.gradients("backgroundImage"),bgClip:{transform:Ct.bgClip}};Object.assign(Em,{bgImage:Em.backgroundImage,bgImg:Em.backgroundImage});const Pt={border:ne.borders("border"),borderWidth:ne.borderWidths("borderWidth"),borderStyle:ne.borderStyles("borderStyle"),borderColor:ne.colors("borderColor"),borderRadius:ne.radii("borderRadius"),borderTop:ne.borders("borderTop"),borderBlockStart:ne.borders("borderBlockStart"),borderTopLeftRadius:ne.radii("borderTopLeftRadius"),borderStartStartRadius:ne.logical({scale:"radii",property:{ltr:"borderTopLeftRadius",rtl:"borderTopRightRadius"}}),borderEndStartRadius:ne.logical({scale:"radii",property:{ltr:"borderBottomLeftRadius",rtl:"borderBottomRightRadius"}}),borderTopRightRadius:ne.radii("borderTopRightRadius"),borderStartEndRadius:ne.logical({scale:"radii",property:{ltr:"borderTopRightRadius",rtl:"borderTopLeftRadius"}}),borderEndEndRadius:ne.logical({scale:"radii",property:{ltr:"borderBottomRightRadius",rtl:"borderBottomLeftRadius"}}),borderRight:ne.borders("borderRight"),borderInlineEnd:ne.borders("borderInlineEnd"),borderBottom:ne.borders("borderBottom"),borderBlockEnd:ne.borders("borderBlockEnd"),borderBottomLeftRadius:ne.radii("borderBottomLeftRadius"),borderBottomRightRadius:ne.radii("borderBottomRightRadius"),borderLeft:ne.borders("borderLeft"),borderInlineStart:{property:"borderInlineStart",scale:"borders"},borderInlineStartRadius:ne.logical({scale:"radii",property:{ltr:["borderTopLeftRadius","borderBottomLeftRadius"],rtl:["borderTopRightRadius","borderBottomRightRadius"]}}),borderInlineEndRadius:ne.logical({scale:"radii",property:{ltr:["borderTopRightRadius","borderBottomRightRadius"],rtl:["borderTopLeftRadius","borderBottomLeftRadius"]}}),borderX:ne.borders(["borderLeft","borderRight"]),borderInline:ne.borders("borderInline"),borderY:ne.borders(["borderTop","borderBottom"]),borderBlock:ne.borders("borderBlock"),borderTopWidth:ne.borderWidths("borderTopWidth"),borderBlockStartWidth:ne.borderWidths("borderBlockStartWidth"),borderTopColor:ne.colors("borderTopColor"),borderBlockStartColor:ne.colors("borderBlockStartColor"),borderTopStyle:ne.borderStyles("borderTopStyle"),borderBlockStartStyle:ne.borderStyles("borderBlockStartStyle"),borderBottomWidth:ne.borderWidths("borderBottomWidth"),borderBlockEndWidth:ne.borderWidths("borderBlockEndWidth"),borderBottomColor:ne.colors("borderBottomColor"),borderBlockEndColor:ne.colors("borderBlockEndColor"),borderBottomStyle:ne.borderStyles("borderBottomStyle"),borderBlockEndStyle:ne.borderStyles("borderBlockEndStyle"),borderLeftWidth:ne.borderWidths("borderLeftWidth"),borderInlineStartWidth:ne.borderWidths("borderInlineStartWidth"),borderLeftColor:ne.colors("borderLeftColor"),borderInlineStartColor:ne.colors("borderInlineStartColor"),borderLeftStyle:ne.borderStyles("borderLeftStyle"),borderInlineStartStyle:ne.borderStyles("borderInlineStartStyle"),borderRightWidth:ne.borderWidths("borderRightWidth"),borderInlineEndWidth:ne.borderWidths("borderInlineEndWidth"),borderRightColor:ne.colors("borderRightColor"),borderInlineEndColor:ne.colors("borderInlineEndColor"),borderRightStyle:ne.borderStyles("borderRightStyle"),borderInlineEndStyle:ne.borderStyles("borderInlineEndStyle"),borderTopRadius:ne.radii(["borderTopLeftRadius","borderTopRightRadius"]),borderBottomRadius:ne.radii(["borderBottomLeftRadius","borderBottomRightRadius"]),borderLeftRadius:ne.radii(["borderTopLeftRadius","borderBottomLeftRadius"]),borderRightRadius:ne.radii(["borderTopRightRadius","borderBottomRightRadius"])};Object.assign(Pt,{rounded:Pt.borderRadius,roundedTop:Pt.borderTopRadius,roundedTopLeft:Pt.borderTopLeftRadius,roundedTopRight:Pt.borderTopRightRadius,roundedTopStart:Pt.borderStartStartRadius,roundedTopEnd:Pt.borderStartEndRadius,roundedBottom:Pt.borderBottomRadius,roundedBottomLeft:Pt.borderBottomLeftRadius,roundedBottomRight:Pt.borderBottomRightRadius,roundedBottomStart:Pt.borderEndStartRadius,roundedBottomEnd:Pt.borderEndEndRadius,roundedLeft:Pt.borderLeftRadius,roundedRight:Pt.borderRightRadius,roundedStart:Pt.borderInlineStartRadius,roundedEnd:Pt.borderInlineEndRadius,borderStart:Pt.borderInlineStart,borderEnd:Pt.borderInlineEnd,borderTopStartRadius:Pt.borderStartStartRadius,borderTopEndRadius:Pt.borderStartEndRadius,borderBottomStartRadius:Pt.borderEndStartRadius,borderBottomEndRadius:Pt.borderEndEndRadius,borderStartRadius:Pt.borderInlineStartRadius,borderEndRadius:Pt.borderInlineEndRadius,borderStartWidth:Pt.borderInlineStartWidth,borderEndWidth:Pt.borderInlineEndWidth,borderStartColor:Pt.borderInlineStartColor,borderEndColor:Pt.borderInlineEndColor,borderStartStyle:Pt.borderInlineStartStyle,borderEndStyle:Pt.borderInlineEndStyle});const ZL={color:ne.colors("color"),textColor:ne.colors("color"),fill:ne.colors("fill"),stroke:ne.colors("stroke"),accentColor:ne.colors("accentColor"),textFillColor:ne.colors("textFillColor")},rg={alignItems:!0,alignContent:!0,justifyItems:!0,justifyContent:!0,flexWrap:!0,flexDirection:{transform:Ct.flexDirection},flex:!0,flexFlow:!0,flexGrow:!0,flexShrink:!0,flexBasis:ne.sizes("flexBasis"),justifySelf:!0,alignSelf:!0,order:!0,placeItems:!0,placeContent:!0,placeSelf:!0,gap:ne.space("gap"),rowGap:ne.space("rowGap"),columnGap:ne.space("columnGap")};Object.assign(rg,{flexDir:rg.flexDirection});const to={width:ne.sizesT("width"),inlineSize:ne.sizesT("inlineSize"),height:ne.sizes("height"),blockSize:ne.sizes("blockSize"),boxSize:ne.sizes(["width","height"]),minWidth:ne.sizes("minWidth"),minInlineSize:ne.sizes("minInlineSize"),minHeight:ne.sizes("minHeight"),minBlockSize:ne.sizes("minBlockSize"),maxWidth:ne.sizes("maxWidth"),maxInlineSize:ne.sizes("maxInlineSize"),maxHeight:ne.sizes("maxHeight"),maxBlockSize:ne.sizes("maxBlockSize"),overflow:!0,overflowX:!0,overflowY:!0,overscrollBehavior:!0,overscrollBehaviorX:!0,overscrollBehaviorY:!0,display:!0,aspectRatio:!0,hideFrom:{scale:"breakpoints",transform:(t,e)=>{var s,o;return{[`@media screen and (min-width: ${((o=(s=e.__breakpoints)==null?void 0:s.get(t))==null?void 0:o.minW)??t})`]:{display:"none"}}}},hideBelow:{scale:"breakpoints",transform:(t,e)=>{var s,o;return{[`@media screen and (max-width: ${((o=(s=e.__breakpoints)==null?void 0:s.get(t))==null?void 0:o._minW)??t})`]:{display:"none"}}}},verticalAlign:!0,boxSizing:!0,boxDecorationBreak:!0,float:ne.propT("float",Ct.float),objectFit:!0,objectPosition:!0,visibility:!0,isolation:!0};Object.assign(to,{w:to.width,h:to.height,minW:to.minWidth,maxW:to.maxWidth,minH:to.minHeight,maxH:to.maxHeight,overscroll:to.overscrollBehavior,overscrollX:to.overscrollBehaviorX,overscrollY:to.overscrollBehaviorY});const JL={filter:{transform:Ct.filter},blur:ne.blur("--chakra-blur"),brightness:ne.propT("--chakra-brightness",Ct.brightness),contrast:ne.propT("--chakra-contrast",Ct.contrast),hueRotate:ne.propT("--chakra-hue-rotate",Ct.hueRotate),invert:ne.propT("--chakra-invert",Ct.invert),saturate:ne.propT("--chakra-saturate",Ct.saturate),dropShadow:ne.propT("--chakra-drop-shadow",Ct.dropShadow),backdropFilter:{transform:Ct.backdropFilter},backdropBlur:ne.blur("--chakra-backdrop-blur"),backdropBrightness:ne.propT("--chakra-backdrop-brightness",Ct.brightness),backdropContrast:ne.propT("--chakra-backdrop-contrast",Ct.contrast),backdropHueRotate:ne.propT("--chakra-backdrop-hue-rotate",Ct.hueRotate),backdropInvert:ne.propT("--chakra-backdrop-invert",Ct.invert),backdropSaturate:ne.propT("--chakra-backdrop-saturate",Ct.saturate)},ez={ring:{transform:Ct.ring},ringColor:ne.colors("--chakra-ring-color"),ringOffset:ne.prop("--chakra-ring-offset-width"),ringOffsetColor:ne.colors("--chakra-ring-offset-color"),ringInset:ne.prop("--chakra-ring-inset")},tz={appearance:!0,cursor:!0,resize:!0,userSelect:!0,pointerEvents:!0,outline:{transform:Ct.outline},outlineOffset:!0,outlineColor:ne.colors("outlineColor")},GE={gridGap:ne.space("gridGap"),gridColumnGap:ne.space("gridColumnGap"),gridRowGap:ne.space("gridRowGap"),gridColumn:!0,gridRow:!0,gridAutoFlow:!0,gridAutoColumns:!0,gridColumnStart:!0,gridColumnEnd:!0,gridRowStart:!0,gridRowEnd:!0,gridAutoRows:!0,gridTemplate:!0,gridTemplateColumns:!0,gridTemplateRows:!0,gridTemplateAreas:!0,gridArea:!0};function nz(t,e,n,r){const s=typeof e=="string"?e.split("."):[e];for(r=0;r<s.length&&t;r+=1)t=t[s[r]];return t===void 0?n:t}const rz=t=>{const e=new WeakMap;return(r,s,o,i)=>{if(typeof r>"u")return t(r,s,o);e.has(r)||e.set(r,new Map);const a=e.get(r);if(a.has(s))return a.get(s);const l=t(r,s,o,i);return a.set(s,l),l}},sz=rz(nz),oz={border:"0px",clip:"rect(0, 0, 0, 0)",width:"1px",height:"1px",margin:"-1px",padding:"0px",overflow:"hidden",whiteSpace:"nowrap",position:"absolute"},iz={position:"static",width:"auto",height:"auto",clip:"auto",padding:"0",margin:"0",overflow:"visible",whiteSpace:"normal"},a1=(t,e,n)=>{const r={},s=sz(t,e,{});for(const o in s)o in n&&n[o]!=null||(r[o]=s[o]);return r},az={srOnly:{transform(t){return t===!0?oz:t==="focusable"?iz:{}}},layerStyle:{processResult:!0,transform:(t,e,n)=>a1(e,`layerStyles.${t}`,n)},textStyle:{processResult:!0,transform:(t,e,n)=>a1(e,`textStyles.${t}`,n)},apply:{processResult:!0,transform:(t,e,n)=>a1(e,t,n)}},Bh={position:!0,pos:ne.prop("position"),zIndex:ne.prop("zIndex","zIndices"),inset:ne.spaceT("inset"),insetX:ne.spaceT(["left","right"]),insetInline:ne.spaceT("insetInline"),insetY:ne.spaceT(["top","bottom"]),insetBlock:ne.spaceT("insetBlock"),top:ne.spaceT("top"),insetBlockStart:ne.spaceT("insetBlockStart"),bottom:ne.spaceT("bottom"),insetBlockEnd:ne.spaceT("insetBlockEnd"),left:ne.spaceT("left"),insetInlineStart:ne.logical({scale:"space",property:{ltr:"left",rtl:"right"}}),right:ne.spaceT("right"),insetInlineEnd:ne.logical({scale:"space",property:{ltr:"right",rtl:"left"}})};Object.assign(Bh,{insetStart:Bh.insetInlineStart,insetEnd:Bh.insetInlineEnd});const bx={boxShadow:ne.shadows("boxShadow"),mixBlendMode:!0,blendMode:ne.prop("mixBlendMode"),backgroundBlendMode:!0,bgBlendMode:ne.prop("backgroundBlendMode"),opacity:!0};Object.assign(bx,{shadow:bx.boxShadow});const ln={margin:ne.spaceT("margin"),marginTop:ne.spaceT("marginTop"),marginBlockStart:ne.spaceT("marginBlockStart"),marginRight:ne.spaceT("marginRight"),marginInlineEnd:ne.spaceT("marginInlineEnd"),marginBottom:ne.spaceT("marginBottom"),marginBlockEnd:ne.spaceT("marginBlockEnd"),marginLeft:ne.spaceT("marginLeft"),marginInlineStart:ne.spaceT("marginInlineStart"),marginX:ne.spaceT(["marginInlineStart","marginInlineEnd"]),marginInline:ne.spaceT("marginInline"),marginY:ne.spaceT(["marginTop","marginBottom"]),marginBlock:ne.spaceT("marginBlock"),padding:ne.space("padding"),paddingTop:ne.space("paddingTop"),paddingBlockStart:ne.space("paddingBlockStart"),paddingRight:ne.space("paddingRight"),paddingBottom:ne.space("paddingBottom"),paddingBlockEnd:ne.space("paddingBlockEnd"),paddingLeft:ne.space("paddingLeft"),paddingInlineStart:ne.space("paddingInlineStart"),paddingInlineEnd:ne.space("paddingInlineEnd"),paddingX:ne.space(["paddingInlineStart","paddingInlineEnd"]),paddingInline:ne.space("paddingInline"),paddingY:ne.space(["paddingTop","paddingBottom"]),paddingBlock:ne.space("paddingBlock")};Object.assign(ln,{m:ln.margin,mt:ln.marginTop,mr:ln.marginRight,me:ln.marginInlineEnd,marginEnd:ln.marginInlineEnd,mb:ln.marginBottom,ml:ln.marginLeft,ms:ln.marginInlineStart,marginStart:ln.marginInlineStart,mx:ln.marginX,my:ln.marginY,p:ln.padding,pt:ln.paddingTop,py:ln.paddingY,px:ln.paddingX,pb:ln.paddingBottom,pl:ln.paddingLeft,ps:ln.paddingInlineStart,paddingStart:ln.paddingInlineStart,pr:ln.paddingRight,pe:ln.paddingInlineEnd,paddingEnd:ln.paddingInlineEnd});const lz={scrollBehavior:!0,scrollSnapAlign:!0,scrollSnapStop:!0,scrollSnapType:!0,scrollMargin:ne.spaceT("scrollMargin"),scrollMarginTop:ne.spaceT("scrollMarginTop"),scrollMarginBottom:ne.spaceT("scrollMarginBottom"),scrollMarginLeft:ne.spaceT("scrollMarginLeft"),scrollMarginRight:ne.spaceT("scrollMarginRight"),scrollMarginX:ne.spaceT(["scrollMarginLeft","scrollMarginRight"]),scrollMarginY:ne.spaceT(["scrollMarginTop","scrollMarginBottom"]),scrollPadding:ne.spaceT("scrollPadding"),scrollPaddingTop:ne.spaceT("scrollPaddingTop"),scrollPaddingBottom:ne.spaceT("scrollPaddingBottom"),scrollPaddingLeft:ne.spaceT("scrollPaddingLeft"),scrollPaddingRight:ne.spaceT("scrollPaddingRight"),scrollPaddingX:ne.spaceT(["scrollPaddingLeft","scrollPaddingRight"]),scrollPaddingY:ne.spaceT(["scrollPaddingTop","scrollPaddingBottom"])},uz={fontFamily:ne.prop("fontFamily","fonts"),fontSize:ne.prop("fontSize","fontSizes",Ct.px),fontWeight:ne.prop("fontWeight","fontWeights"),lineHeight:ne.prop("lineHeight","lineHeights"),letterSpacing:ne.prop("letterSpacing","letterSpacings"),textAlign:!0,fontStyle:!0,textIndent:!0,wordBreak:!0,overflowWrap:!0,textOverflow:!0,textTransform:!0,whiteSpace:!0,isTruncated:{transform(t){if(t===!0)return{overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"}}},noOfLines:{static:{overflow:"hidden",textOverflow:"ellipsis",display:"-webkit-box",WebkitBoxOrient:"vertical",WebkitLineClamp:"var(--chakra-line-clamp)"},property:"--chakra-line-clamp"}},cz={textDecorationColor:ne.colors("textDecorationColor"),textDecoration:!0,textDecor:{property:"textDecoration"},textDecorationLine:!0,textDecorationStyle:!0,textDecorationThickness:!0,textUnderlineOffset:!0,textShadow:ne.shadows("textShadow")},dz={clipPath:!0,transform:ne.propT("transform",Ct.transform),transformOrigin:!0,translateX:ne.spaceT("--chakra-translate-x"),translateY:ne.spaceT("--chakra-translate-y"),skewX:ne.degreeT("--chakra-skew-x"),skewY:ne.degreeT("--chakra-skew-y"),scaleX:ne.prop("--chakra-scale-x"),scaleY:ne.prop("--chakra-scale-y"),scale:ne.prop(["--chakra-scale-x","--chakra-scale-y"]),rotate:ne.degreeT("--chakra-rotate")},hz={listStyleType:!0,listStylePosition:!0,listStylePos:ne.prop("listStylePosition"),listStyleImage:!0,listStyleImg:ne.prop("listStyleImage")},fz={transition:!0,transitionDelay:!0,animation:!0,willChange:!0,transitionDuration:ne.prop("transitionDuration","transition.duration"),transitionProperty:ne.prop("transitionProperty","transition.property"),transitionTimingFunction:ne.prop("transitionTimingFunction","transition.easing")},qv=oo({},Em,Pt,ZL,rg,to,JL,ez,tz,GE,az,Bh,bx,ln,lz,uz,cz,dz,hz,fz);Object.assign({},ln,to,rg,GE,Bh);const pz=[...Object.keys(qv),...UE],mz={...qv,...jc},gz=t=>t in mz,yz=t=>e=>{if(!e.__breakpoints)return t;const{isResponsive:n,toArrayValue:r,media:s}=e.__breakpoints,o={};for(const i in t){let a=so(t[i],e);if(a==null)continue;if(a=Wr(a)&&n(a)?r(a):a,!Array.isArray(a)){o[i]=a;continue}const l=a.slice(0,s.length).length;for(let c=0;c<l;c+=1){const d=s==null?void 0:s[c];if(!d){o[i]=a[c];continue}o[d]=o[d]||{},a[c]!=null&&(o[d][i]=a[c])}}return o};function xz(t){const e=[];let n="",r=!1;for(let s=0;s<t.length;s++){const o=t[s];o==="("?(r=!0,n+=o):o===")"?(r=!1,n+=o):o===","&&!r?(e.push(n),n=""):n+=o}return n=n.trim(),n&&e.push(n),e}function vz(t){return/^var\(--.+\)$/.test(t)}const bz=(t,e)=>t.startsWith("--")&&typeof e=="string"&&!vz(e),wz=(t,e)=>{if(e==null)return e;const n=i=>{var a,l;return(l=(a=t.__cssMap)==null?void 0:a[i])==null?void 0:l.varRef},r=i=>n(i)??i,[s,o]=xz(e);return e=n(s)??r(o)??r(e),e};function Sz(t){const{configs:e={},pseudos:n={},theme:r}=t,s=(o,i=!1)=>{var d;const a=so(o,r),l=yz(a)(r);let c={};for(let f in l){const p=l[f];let g=so(p,r);f in n&&(f=n[f]),bz(f,g)&&(g=wz(r,g));let y=e[f];if(y===!0&&(y={property:f}),Wr(g)){c[f]=c[f]??{},c[f]=oo({},c[f],s(g,!0));continue}let x=((d=y==null?void 0:y.transform)==null?void 0:d.call(y,g,r,a))??g;x=y!=null&&y.processResult?s(x,!0):x;const w=so(y==null?void 0:y.property,r);if(!i&&(y!=null&&y.static)){const S=so(y.static,r);c=oo({},c,S)}if(w&&Array.isArray(w)){for(const S of w)c[S]=x;continue}if(w){w==="&"&&Wr(x)?c=oo({},c,x):c[w]=x;continue}if(Wr(x)){c=oo({},c,x);continue}c[f]=x}return c};return s}const HE=t=>e=>Sz({theme:e,pseudos:jc,configs:qv})(t);function tn(t){return{definePartsStyle(e){return e},defineMultiStyleConfig(e){return{parts:t,...e}}}}function Cz(t,e){if(Array.isArray(t))return t;if(Wr(t))return e(t);if(t!=null)return[t]}function $z(t,e){for(let n=e+1;n<t.length;n++)if(t[n]!=null)return n;return-1}function kz(t){const e=t.__breakpoints;return function(r,s,o,i){var p,g;if(!e)return;const a={},l=Cz(o,e.toArrayValue);if(!l)return a;const c=l.length,d=c===1,f=!!r.parts;for(let y=0;y<c;y++){const x=e.details[y],w=e.details[$z(l,y)],S=$h(x.minW,w==null?void 0:w._minW),$=so((p=r[s])==null?void 0:p[l[y]],i);if($){if(f){(g=r.parts)==null||g.forEach(I=>{oo(a,{[I]:d?$[I]:{[S]:$[I]}})});continue}if(!f){d?oo(a,$):a[S]=$;continue}a[S]=$}}return a}}function Tz(t){return e=>{const{variant:n,size:r,theme:s}=e,o=kz(s);return oo({},so(t.baseStyle??{},e),o(t,"sizes",r,e),o(t,"variants",n,e))}}function Nr(t){return Hv(t,["styleConfig","size","variant","colorScheme"])}function KE(t){return Wr(t)&&t.reference?t.reference:String(t)}const Wg=(t,...e)=>e.map(KE).join(` ${t} `).replace(/calc/g,""),lT=(...t)=>`calc(${Wg("+",...t)})`,uT=(...t)=>`calc(${Wg("-",...t)})`,wx=(...t)=>`calc(${Wg("*",...t)})`,cT=(...t)=>`calc(${Wg("/",...t)})`,dT=t=>{const e=KE(t);return e!=null&&!Number.isNaN(parseFloat(e))?String(e).startsWith("-")?String(e).slice(1):`-${e}`:wx(e,-1)},Ji=Object.assign(t=>({add:(...e)=>Ji(lT(t,...e)),subtract:(...e)=>Ji(uT(t,...e)),multiply:(...e)=>Ji(wx(t,...e)),divide:(...e)=>Ji(cT(t,...e)),negate:()=>Ji(dT(t)),toString:()=>t.toString()}),{add:lT,subtract:uT,multiply:wx,divide:cT,negate:dT});function Iz(t,e="-"){return t.replace(/\s+/g,e)}function Nz(t){const e=Iz(t.toString());return Rz(Ez(e))}function Ez(t){return t.includes("\\.")?t:!Number.isInteger(parseFloat(t.toString()))?t.replace(".","\\."):t}function Rz(t){return t.replace(/[!-,/:-@[-^`{-~]/g,"\\$&")}function _z(t,e=""){return[e,t].filter(Boolean).join("-")}function Pz(t,e){return`var(${t}${e?`, ${e}`:""})`}function Az(t,e=""){return Nz(`--${_z(t,e)}`)}function Qe(t,e,n){const r=Az(t,n);return{variable:r,reference:Pz(r,e)}}function Dz(t,e){const n={};for(const r of e){if(Array.isArray(r)){const[s,o]=r;n[s]=Qe(`${t}-${s}`,o);continue}n[r]=Qe(`${t}-${r}`)}return n}const Oz=["colors","borders","borderWidths","borderStyles","fonts","fontSizes","fontWeights","gradients","letterSpacings","lineHeights","radii","space","shadows","sizes","zIndices","transition","blur","breakpoints"];function Fz(t){return IL(t,Oz)}function Lz(t){return t.semanticTokens}function zz(t){const{__cssMap:e,__cssVars:n,__breakpoints:r,...s}=t;return s}function Bz(t){const e=Fz(t),n=Lz(t),r=o=>UE.includes(o)||o==="default",s={};return sT(e,(o,i)=>{o!=null&&(s[i.join(".")]={isSemantic:!1,value:o})}),sT(n,(o,i)=>{o!=null&&(s[i.join(".")]={isSemantic:!0,value:o})},{stop:o=>Object.keys(o).every(r)}),s}function hT(t,e){return Qe(String(t).replace(/\./g,"-"),void 0,e)}function Mz(t){var i;const e=Bz(t),n=(i=t.config)==null?void 0:i.cssVarPrefix;let r={};const s={};function o(a,l){const d=[String(a).split(".")[0],l].join(".");if(!e[d])return l;const{reference:p}=hT(d,n);return p}for(const[a,l]of Object.entries(e)){const{isSemantic:c,value:d}=l,{variable:f,reference:p}=hT(a,n);if(!c){if(a.startsWith("space")){const y=a.split("."),[x,...w]=y,S=`${x}.-${w.join(".")}`,$=Ji.negate(d),I=Ji.negate(p);s[S]={value:$,var:f,varRef:I}}r[f]=d,s[a]={value:d,var:f,varRef:p};continue}const g=Wr(d)?d:{default:d};r=oo(r,Object.entries(g).reduce((y,[x,w])=>{if(!w)return y;const S=o(a,`${w}`);if(x==="default")return y[f]=S,y;const $=(jc==null?void 0:jc[x])??x;return y[$]={[f]:S},y},{})),s[a]={value:p,var:f,varRef:p}}return{cssVars:r,cssMap:s}}function Vz(t){const e=zz(t),{cssMap:n,cssVars:r}=Mz(e);return Object.assign(e,{__cssVars:{...{"--chakra-ring-inset":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-ring-offset-width":"0px","--chakra-ring-offset-color":"#fff","--chakra-ring-color":"rgba(66, 153, 225, 0.6)","--chakra-ring-offset-shadow":"0 0 #0000","--chakra-ring-shadow":"0 0 #0000","--chakra-space-x-reverse":"0","--chakra-space-y-reverse":"0"},...r},__cssMap:n,__breakpoints:SL(e.breakpoints)}),e}function Ft(t,e={}){let n=!1;function r(){if(!n){n=!0;return}throw new Error("[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?")}function s(...d){r();for(const f of d)e[f]=l(f);return Ft(t,e)}function o(...d){for(const f of d)f in e||(e[f]=l(f));return Ft(t,e)}function i(){return Object.fromEntries(Object.entries(e).map(([f,p])=>[f,p.selector]))}function a(){return Object.fromEntries(Object.entries(e).map(([f,p])=>[f,p.className]))}function l(d){const g=`chakra-${(["container","root"].includes(d??"")?[t]:[t,d]).filter(Boolean).join("__")}`;return{className:g,selector:`.${g}`,toString:()=>d}}return{parts:s,toPart:l,extend:o,selectors:i,classnames:a,get keys(){return Object.keys(e)},__type:{}}}const Wz=Ft("accordion").parts("root","container","button","panel","icon"),Uz=Ft("alert").parts("title","description","container","icon","spinner"),jz=Ft("avatar").parts("label","badge","container","excessLabel","group"),Gz=Ft("breadcrumb").parts("link","item","container","separator");Ft("button").parts();const Hz=Ft("checkbox").parts("control","icon","container","label");Ft("progress").parts("track","filledTrack","label");const Kz=Ft("drawer").parts("overlay","dialogContainer","dialog","header","closeButton","body","footer"),Xz=Ft("editable").parts("preview","input","textarea"),qz=Ft("form").parts("container","requiredIndicator","helperText"),Yz=Ft("formError").parts("text","icon"),Qz=Ft("input").parts("addon","field","element","group"),Zz=Ft("list").parts("container","item","icon"),Jz=Ft("menu").parts("button","list","item","groupTitle","icon","command","divider"),eB=Ft("modal").parts("overlay","dialogContainer","dialog","header","closeButton","body","footer"),tB=Ft("numberinput").parts("root","field","stepperGroup","stepper");Ft("pininput").parts("field");const nB=Ft("popover").parts("content","header","body","footer","popper","arrow","closeButton"),rB=Ft("progress").parts("label","filledTrack","track"),sB=Ft("radio").parts("container","control","label"),oB=Ft("select").parts("field","icon"),iB=Ft("slider").parts("container","track","thumb","filledTrack","mark"),aB=Ft("stat").parts("container","label","helpText","number","icon"),lB=Ft("switch").parts("container","track","thumb","label"),uB=Ft("table").parts("table","thead","tbody","tr","th","td","tfoot","caption"),cB=Ft("tabs").parts("root","tab","tablist","tabpanel","tabpanels","indicator"),dB=Ft("tag").parts("container","label","closeButton"),hB=Ft("card").parts("container","header","body","footer");Ft("stepper").parts("stepper","step","title","description","indicator","separator","icon","number");const{definePartsStyle:fB,defineMultiStyleConfig:pB}=tn(Wz.keys),mB={borderTopWidth:"1px",borderColor:"inherit",_last:{borderBottomWidth:"1px"}},gB={transitionProperty:"common",transitionDuration:"normal",fontSize:"md",_focusVisible:{boxShadow:"outline"},_hover:{bg:"blackAlpha.50"},_disabled:{opacity:.4,cursor:"not-allowed"},px:"4",py:"2"},yB={pt:"2",px:"4",pb:"5"},xB={fontSize:"1.25em"},vB=fB({container:mB,button:gB,panel:yB,icon:xB}),bB=pB({baseStyle:vB});function gu(t,e,n){return Math.min(Math.max(t,n),e)}class wB extends Error{constructor(e){super(`Failed to parse color: "${e}"`)}}var Th=wB;function Yv(t){if(typeof t!="string")throw new Th(t);if(t.trim().toLowerCase()==="transparent")return[0,0,0,0];let e=t.trim();e=EB.test(t)?$B(t):t;const n=kB.exec(e);if(n){const i=Array.from(n).slice(1);return[...i.slice(0,3).map(a=>parseInt(ef(a,2),16)),parseInt(ef(i[3]||"f",2),16)/255]}const r=TB.exec(e);if(r){const i=Array.from(r).slice(1);return[...i.slice(0,3).map(a=>parseInt(a,16)),parseInt(i[3]||"ff",16)/255]}const s=IB.exec(e);if(s){const i=Array.from(s).slice(1);return[...i.slice(0,3).map(a=>parseInt(a,10)),parseFloat(i[3]||"1")]}const o=NB.exec(e);if(o){const[i,a,l,c]=Array.from(o).slice(1).map(parseFloat);if(gu(0,100,a)!==a)throw new Th(t);if(gu(0,100,l)!==l)throw new Th(t);return[...RB(i,a,l),Number.isNaN(c)?1:c]}throw new Th(t)}function SB(t){let e=5381,n=t.length;for(;n;)e=e*33^t.charCodeAt(--n);return(e>>>0)%2341}const fT=t=>parseInt(t.replace(/_/g,""),36),CB="1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((t,e)=>{const n=fT(e.substring(0,3)),r=fT(e.substring(3)).toString(16);let s="";for(let o=0;o<6-r.length;o++)s+="0";return t[n]=`${s}${r}`,t},{});function $B(t){const e=t.toLowerCase().trim(),n=CB[SB(e)];if(!n)throw new Th(t);return`#${n}`}const ef=(t,e)=>Array.from(Array(e)).map(()=>t).join(""),kB=new RegExp(`^#${ef("([a-f0-9])",3)}([a-f0-9])?$`,"i"),TB=new RegExp(`^#${ef("([a-f0-9]{2})",3)}([a-f0-9]{2})?$`,"i"),IB=new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${ef(",\\s*(\\d+)\\s*",2)}(?:,\\s*([\\d.]+))?\\s*\\)$`,"i"),NB=/^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i,EB=/^[a-z]+$/i,pT=t=>Math.round(t*255),RB=(t,e,n)=>{let r=n/100;if(e===0)return[r,r,r].map(pT);const s=(t%360+360)%360/60,o=(1-Math.abs(2*r-1))*(e/100),i=o*(1-Math.abs(s%2-1));let a=0,l=0,c=0;s>=0&&s<1?(a=o,l=i):s>=1&&s<2?(a=i,l=o):s>=2&&s<3?(l=o,c=i):s>=3&&s<4?(l=i,c=o):s>=4&&s<5?(a=i,c=o):s>=5&&s<6&&(a=o,c=i);const d=r-o/2,f=a+d,p=l+d,g=c+d;return[f,p,g].map(pT)};function _B(t,e,n,r){return`rgba(${gu(0,255,t).toFixed()}, ${gu(0,255,e).toFixed()}, ${gu(0,255,n).toFixed()}, ${parseFloat(gu(0,1,r).toFixed(3))})`}function PB(t,e){const[n,r,s,o]=Yv(t);return _B(n,r,s,o-e)}function AB(t){const[e,n,r,s]=Yv(t);let o=i=>{const a=gu(0,255,i).toString(16);return a.length===1?`0${a}`:a};return`#${o(e)}${o(n)}${o(r)}${s<1?o(Math.round(s*255)):""}`}const DB=t=>Object.keys(t).length===0;function OB(t,e,n,r,s){for(e=e.split?e.split("."):e,r=0;r<e.length;r++)t=t?t[e[r]]:s;return t===s?n:t}const Mr=(t,e,n)=>{const r=OB(t,`colors.${e}`,e);try{return AB(r),r}catch{return n??"#000000"}},FB=t=>{const[e,n,r]=Yv(t);return(e*299+n*587+r*114)/1e3},LB=t=>e=>{const n=Mr(e,t);return FB(n)<128?"dark":"light"},zB=t=>e=>LB(t)(e)==="dark",ed=(t,e)=>n=>{const r=Mr(n,t);return PB(r,1-e)};function mT(t="1rem",e="rgba(255, 255, 255, 0.15)"){return{backgroundImage:`linear-gradient(
    45deg,
    ${e} 25%,
    transparent 25%,
    transparent 50%,
    ${e} 50%,
    ${e} 75%,
    transparent 75%,
    transparent
  )`,backgroundSize:`${t} ${t}`}}const BB=()=>`#${Math.floor(Math.random()*16777215).toString(16).padEnd(6,"0")}`;function MB(t){const e=BB();return!t||DB(t)?e:t.string&&t.colors?WB(t.string,t.colors):t.string&&!t.colors?VB(t.string):t.colors&&!t.string?UB(t.colors):e}function VB(t){let e=0;if(t.length===0)return e.toString();for(let r=0;r<t.length;r+=1)e=t.charCodeAt(r)+((e<<5)-e),e=e&e;let n="#";for(let r=0;r<3;r+=1){const s=e>>r*8&255;n+=`00${s.toString(16)}`.substr(-2)}return n}function WB(t,e){let n=0;if(t.length===0)return e[0];for(let r=0;r<t.length;r+=1)n=t.charCodeAt(r)+((n<<5)-n),n=n&n;return n=(n%e.length+e.length)%e.length,e[n]}function UB(t){return t[Math.floor(Math.random()*t.length)]}function Ye(t,e){return n=>n.colorMode==="dark"?e:t}function Qv(t){const{orientation:e,vertical:n,horizontal:r}=t;return e?e==="vertical"?n:r:{}}function XE(t){return Wr(t)&&t.reference?t.reference:String(t)}const Ug=(t,...e)=>e.map(XE).join(` ${t} `).replace(/calc/g,""),gT=(...t)=>`calc(${Ug("+",...t)})`,yT=(...t)=>`calc(${Ug("-",...t)})`,Sx=(...t)=>`calc(${Ug("*",...t)})`,xT=(...t)=>`calc(${Ug("/",...t)})`,vT=t=>{const e=XE(t);return e!=null&&!Number.isNaN(parseFloat(e))?String(e).startsWith("-")?String(e).slice(1):`-${e}`:Sx(e,-1)},ea=Object.assign(t=>({add:(...e)=>ea(gT(t,...e)),subtract:(...e)=>ea(yT(t,...e)),multiply:(...e)=>ea(Sx(t,...e)),divide:(...e)=>ea(xT(t,...e)),negate:()=>ea(vT(t)),toString:()=>t.toString()}),{add:gT,subtract:yT,multiply:Sx,divide:xT,negate:vT});function jB(t){return!Number.isInteger(parseFloat(t.toString()))}function GB(t,e="-"){return t.replace(/\s+/g,e)}function qE(t){const e=GB(t.toString());return e.includes("\\.")?t:jB(t)?e.replace(".","\\."):t}function HB(t,e=""){return[e,qE(t)].filter(Boolean).join("-")}function KB(t,e){return`var(${qE(t)}${e?`, ${e}`:""})`}function XB(t,e=""){return`--${HB(t,e)}`}function Ln(t,e){const n=XB(t,e==null?void 0:e.prefix);return{variable:n,reference:KB(n,qB(e==null?void 0:e.fallback))}}function qB(t){return t==null?void 0:t.reference}const{definePartsStyle:Df,defineMultiStyleConfig:YB}=tn(Uz.keys),As=Qe("alert-fg"),ua=Qe("alert-bg"),QB=Df({container:{bg:ua.reference,px:"4",py:"3"},title:{fontWeight:"bold",lineHeight:"6",marginEnd:"2"},description:{lineHeight:"6"},icon:{color:As.reference,flexShrink:0,marginEnd:"3",w:"5",h:"6"},spinner:{color:As.reference,flexShrink:0,marginEnd:"3",w:"5",h:"5"}});function Zv(t){const{theme:e,colorScheme:n}=t,r=ed(`${n}.200`,.16)(e);return{light:`colors.${n}.100`,dark:r}}const ZB=Df(t=>{const{colorScheme:e}=t,n=Zv(t);return{container:{[As.variable]:`colors.${e}.600`,[ua.variable]:n.light,_dark:{[As.variable]:`colors.${e}.200`,[ua.variable]:n.dark}}}}),JB=Df(t=>{const{colorScheme:e}=t,n=Zv(t);return{container:{[As.variable]:`colors.${e}.600`,[ua.variable]:n.light,_dark:{[As.variable]:`colors.${e}.200`,[ua.variable]:n.dark},paddingStart:"3",borderStartWidth:"4px",borderStartColor:As.reference}}}),eM=Df(t=>{const{colorScheme:e}=t,n=Zv(t);return{container:{[As.variable]:`colors.${e}.600`,[ua.variable]:n.light,_dark:{[As.variable]:`colors.${e}.200`,[ua.variable]:n.dark},pt:"2",borderTopWidth:"4px",borderTopColor:As.reference}}}),tM=Df(t=>{const{colorScheme:e}=t;return{container:{[As.variable]:"colors.white",[ua.variable]:`colors.${e}.600`,_dark:{[As.variable]:"colors.gray.900",[ua.variable]:`colors.${e}.200`},color:As.reference}}}),nM={subtle:ZB,"left-accent":JB,"top-accent":eM,solid:tM},rM=YB({baseStyle:QB,variants:nM,defaultProps:{variant:"subtle",colorScheme:"blue"}}),YE={px:"1px",.5:"0.125rem",1:"0.25rem",1.5:"0.375rem",2:"0.5rem",2.5:"0.625rem",3:"0.75rem",3.5:"0.875rem",4:"1rem",5:"1.25rem",6:"1.5rem",7:"1.75rem",8:"2rem",9:"2.25rem",10:"2.5rem",12:"3rem",14:"3.5rem",16:"4rem",20:"5rem",24:"6rem",28:"7rem",32:"8rem",36:"9rem",40:"10rem",44:"11rem",48:"12rem",52:"13rem",56:"14rem",60:"15rem",64:"16rem",72:"18rem",80:"20rem",96:"24rem"},sM={max:"max-content",min:"min-content",full:"100%","3xs":"14rem","2xs":"16rem",xs:"20rem",sm:"24rem",md:"28rem",lg:"32rem",xl:"36rem","2xl":"42rem","3xl":"48rem","4xl":"56rem","5xl":"64rem","6xl":"72rem","7xl":"80rem","8xl":"90rem",prose:"60ch"},oM={sm:"640px",md:"768px",lg:"1024px",xl:"1280px"},QE={...YE,...sM,container:oM},iM=t=>typeof t=="function";function Ur(t,...e){return iM(t)?t(...e):t}const{definePartsStyle:ZE,defineMultiStyleConfig:aM}=tn(jz.keys),Gc=Qe("avatar-border-color"),Mh=Qe("avatar-bg"),tf=Qe("avatar-font-size"),td=Qe("avatar-size"),lM={borderRadius:"full",border:"0.2em solid",borderColor:Gc.reference,[Gc.variable]:"white",_dark:{[Gc.variable]:"colors.gray.800"}},uM={bg:Mh.reference,fontSize:tf.reference,width:td.reference,height:td.reference,lineHeight:"1",[Mh.variable]:"colors.gray.200",_dark:{[Mh.variable]:"colors.whiteAlpha.400"}},cM=t=>{const{name:e,theme:n}=t,r=e?MB({string:e}):"colors.gray.400",s=zB(r)(n);let o="white";return s||(o="gray.800"),{bg:Mh.reference,fontSize:tf.reference,color:o,borderColor:Gc.reference,verticalAlign:"top",width:td.reference,height:td.reference,"&:not([data-loaded])":{[Mh.variable]:r},[Gc.variable]:"colors.white",_dark:{[Gc.variable]:"colors.gray.800"}}},dM={fontSize:tf.reference,lineHeight:"1"},hM=ZE(t=>({badge:Ur(lM,t),excessLabel:Ur(uM,t),container:Ur(cM,t),label:dM}));function nl(t){const e=t!=="100%"?QE[t]:void 0;return ZE({container:{[td.variable]:e??t,[tf.variable]:`calc(${e??t} / 2.5)`},excessLabel:{[td.variable]:e??t,[tf.variable]:`calc(${e??t} / 2.5)`}})}const fM={"2xs":nl(4),xs:nl(6),sm:nl(8),md:nl(12),lg:nl(16),xl:nl(24),"2xl":nl(32),full:nl("100%")},pM=aM({baseStyle:hM,sizes:fM,defaultProps:{size:"md"}}),$n=Dz("badge",["bg","color","shadow"]),mM={px:1,textTransform:"uppercase",fontSize:"xs",borderRadius:"sm",fontWeight:"bold",bg:$n.bg.reference,color:$n.color.reference,boxShadow:$n.shadow.reference},gM=t=>{const{colorScheme:e,theme:n}=t,r=ed(`${e}.500`,.6)(n);return{[$n.bg.variable]:`colors.${e}.500`,[$n.color.variable]:"colors.white",_dark:{[$n.bg.variable]:r,[$n.color.variable]:"colors.whiteAlpha.800"}}},yM=t=>{const{colorScheme:e,theme:n}=t,r=ed(`${e}.200`,.16)(n);return{[$n.bg.variable]:`colors.${e}.100`,[$n.color.variable]:`colors.${e}.800`,_dark:{[$n.bg.variable]:r,[$n.color.variable]:`colors.${e}.200`}}},xM=t=>{const{colorScheme:e,theme:n}=t,r=ed(`${e}.200`,.8)(n);return{[$n.color.variable]:`colors.${e}.500`,_dark:{[$n.color.variable]:r},[$n.shadow.variable]:`inset 0 0 0px 1px ${$n.color.reference}`}},vM={solid:gM,subtle:yM,outline:xM},Vh={baseStyle:mM,variants:vM,defaultProps:{variant:"subtle",colorScheme:"gray"}},{defineMultiStyleConfig:bM,definePartsStyle:wM}=tn(Gz.keys),l1=Qe("breadcrumb-link-decor"),SM={transitionProperty:"common",transitionDuration:"fast",transitionTimingFunction:"ease-out",outline:"none",color:"inherit",textDecoration:l1.reference,[l1.variable]:"none","&:not([aria-current=page])":{cursor:"pointer",_hover:{[l1.variable]:"underline"},_focusVisible:{boxShadow:"outline"}}},CM=wM({link:SM}),$M=bM({baseStyle:CM}),kM={lineHeight:"1.2",borderRadius:"md",fontWeight:"semibold",transitionProperty:"common",transitionDuration:"normal",_focusVisible:{boxShadow:"outline"},_disabled:{opacity:.4,cursor:"not-allowed",boxShadow:"none"},_hover:{_disabled:{bg:"initial"}}},JE=t=>{const{colorScheme:e,theme:n}=t;if(e==="gray")return{color:Ye("gray.800","whiteAlpha.900")(t),_hover:{bg:Ye("gray.100","whiteAlpha.200")(t)},_active:{bg:Ye("gray.200","whiteAlpha.300")(t)}};const r=ed(`${e}.200`,.12)(n),s=ed(`${e}.200`,.24)(n);return{color:Ye(`${e}.600`,`${e}.200`)(t),bg:"transparent",_hover:{bg:Ye(`${e}.50`,r)(t)},_active:{bg:Ye(`${e}.100`,s)(t)}}},TM=t=>{const{colorScheme:e}=t,n=Ye("gray.200","whiteAlpha.300")(t);return{border:"1px solid",borderColor:e==="gray"?n:"currentColor",".chakra-button__group[data-attached][data-orientation=horizontal] > &:not(:last-of-type)":{marginEnd:"-1px"},".chakra-button__group[data-attached][data-orientation=vertical] > &:not(:last-of-type)":{marginBottom:"-1px"},...Ur(JE,t)}},IM={yellow:{bg:"yellow.400",color:"black",hoverBg:"yellow.500",activeBg:"yellow.600"},cyan:{bg:"cyan.400",color:"black",hoverBg:"cyan.500",activeBg:"cyan.600"}},NM=t=>{const{colorScheme:e}=t;if(e==="gray"){const a=Ye("gray.100","whiteAlpha.200")(t);return{bg:a,color:Ye("gray.800","whiteAlpha.900")(t),_hover:{bg:Ye("gray.200","whiteAlpha.300")(t),_disabled:{bg:a}},_active:{bg:Ye("gray.300","whiteAlpha.400")(t)}}}const{bg:n=`${e}.500`,color:r="white",hoverBg:s=`${e}.600`,activeBg:o=`${e}.700`}=IM[e]??{},i=Ye(n,`${e}.200`)(t);return{bg:i,color:Ye(r,"gray.800")(t),_hover:{bg:Ye(s,`${e}.300`)(t),_disabled:{bg:i}},_active:{bg:Ye(o,`${e}.400`)(t)}}},EM=t=>{const{colorScheme:e}=t;return{padding:0,height:"auto",lineHeight:"normal",verticalAlign:"baseline",color:Ye(`${e}.500`,`${e}.200`)(t),_hover:{textDecoration:"underline",_disabled:{textDecoration:"none"}},_active:{color:Ye(`${e}.700`,`${e}.500`)(t)}}},RM={bg:"none",color:"inherit",display:"inline",lineHeight:"inherit",m:"0",p:"0"},_M={ghost:JE,outline:TM,solid:NM,link:EM,unstyled:RM},PM={lg:{h:"12",minW:"12",fontSize:"lg",px:"6"},md:{h:"10",minW:"10",fontSize:"md",px:"4"},sm:{h:"8",minW:"8",fontSize:"sm",px:"3"},xs:{h:"6",minW:"6",fontSize:"xs",px:"2"}},AM={baseStyle:kM,variants:_M,sizes:PM,defaultProps:{variant:"solid",size:"md",colorScheme:"gray"}},{definePartsStyle:Su,defineMultiStyleConfig:DM}=tn(hB.keys),sg=Qe("card-bg"),oa=Qe("card-padding"),eR=Qe("card-shadow"),Rm=Qe("card-radius"),tR=Qe("card-border-width","0"),nR=Qe("card-border-color"),OM=Su({container:{[sg.variable]:"colors.chakra-body-bg",backgroundColor:sg.reference,boxShadow:eR.reference,borderRadius:Rm.reference,color:"chakra-body-text",borderWidth:tR.reference,borderColor:nR.reference},body:{padding:oa.reference,flex:"1 1 0%"},header:{padding:oa.reference},footer:{padding:oa.reference}}),FM={sm:Su({container:{[Rm.variable]:"radii.base",[oa.variable]:"space.3"}}),md:Su({container:{[Rm.variable]:"radii.md",[oa.variable]:"space.5"}}),lg:Su({container:{[Rm.variable]:"radii.xl",[oa.variable]:"space.7"}})},LM={elevated:Su({container:{[eR.variable]:"shadows.base",_dark:{[sg.variable]:"colors.gray.700"}}}),outline:Su({container:{[tR.variable]:"1px",[nR.variable]:"colors.chakra-border-color"}}),filled:Su({container:{[sg.variable]:"colors.chakra-subtle-bg"}}),unstyled:{body:{[oa.variable]:0},header:{[oa.variable]:0},footer:{[oa.variable]:0}}},zM=DM({baseStyle:OM,variants:LM,sizes:FM,defaultProps:{variant:"elevated",size:"md"}}),{definePartsStyle:_m,defineMultiStyleConfig:BM}=tn(Hz.keys),Wh=Qe("checkbox-size"),MM=t=>{const{colorScheme:e}=t;return{w:Wh.reference,h:Wh.reference,transitionProperty:"box-shadow",transitionDuration:"normal",border:"2px solid",borderRadius:"sm",borderColor:"inherit",color:"white",_checked:{bg:Ye(`${e}.500`,`${e}.200`)(t),borderColor:Ye(`${e}.500`,`${e}.200`)(t),color:Ye("white","gray.900")(t),_hover:{bg:Ye(`${e}.600`,`${e}.300`)(t),borderColor:Ye(`${e}.600`,`${e}.300`)(t)},_disabled:{borderColor:Ye("gray.200","transparent")(t),bg:Ye("gray.200","whiteAlpha.300")(t),color:Ye("gray.500","whiteAlpha.500")(t)}},_indeterminate:{bg:Ye(`${e}.500`,`${e}.200`)(t),borderColor:Ye(`${e}.500`,`${e}.200`)(t),color:Ye("white","gray.900")(t)},_disabled:{bg:Ye("gray.100","whiteAlpha.100")(t),borderColor:Ye("gray.100","transparent")(t)},_focusVisible:{boxShadow:"outline"},_invalid:{borderColor:Ye("red.500","red.300")(t)}}},VM={_disabled:{cursor:"not-allowed"}},WM={userSelect:"none",_disabled:{opacity:.4}},UM={transitionProperty:"transform",transitionDuration:"normal"},jM=_m(t=>({icon:UM,container:VM,control:Ur(MM,t),label:WM})),GM={sm:_m({control:{[Wh.variable]:"sizes.3"},label:{fontSize:"sm"},icon:{fontSize:"3xs"}}),md:_m({control:{[Wh.variable]:"sizes.4"},label:{fontSize:"md"},icon:{fontSize:"2xs"}}),lg:_m({control:{[Wh.variable]:"sizes.5"},label:{fontSize:"lg"},icon:{fontSize:"2xs"}})},ol=BM({baseStyle:jM,sizes:GM,defaultProps:{size:"md",colorScheme:"blue"}}),Uh=Ln("close-button-size"),mh=Ln("close-button-bg"),HM={w:[Uh.reference],h:[Uh.reference],borderRadius:"md",transitionProperty:"common",transitionDuration:"normal",_disabled:{opacity:.4,cursor:"not-allowed",boxShadow:"none"},_hover:{[mh.variable]:"colors.blackAlpha.100",_dark:{[mh.variable]:"colors.whiteAlpha.100"}},_active:{[mh.variable]:"colors.blackAlpha.200",_dark:{[mh.variable]:"colors.whiteAlpha.200"}},_focusVisible:{boxShadow:"outline"},bg:mh.reference},KM={lg:{[Uh.variable]:"sizes.10",fontSize:"md"},md:{[Uh.variable]:"sizes.8",fontSize:"xs"},sm:{[Uh.variable]:"sizes.6",fontSize:"2xs"}},XM={baseStyle:HM,sizes:KM,defaultProps:{size:"md"}},{variants:qM,defaultProps:YM}=Vh,QM={fontFamily:"mono",fontSize:"sm",px:"0.2em",borderRadius:"sm",bg:$n.bg.reference,color:$n.color.reference,boxShadow:$n.shadow.reference},ZM={baseStyle:QM,variants:qM,defaultProps:YM},JM={w:"100%",mx:"auto",maxW:"prose",px:"4"},eV={baseStyle:JM},tV={opacity:.6,borderColor:"inherit"},nV={borderStyle:"solid"},rV={borderStyle:"dashed"},sV={solid:nV,dashed:rV},oV={baseStyle:tV,variants:sV,defaultProps:{variant:"solid"}},{definePartsStyle:Cx,defineMultiStyleConfig:iV}=tn(Kz.keys),u1=Qe("drawer-bg"),c1=Qe("drawer-box-shadow");function Cc(t){return Cx(t==="full"?{dialog:{maxW:"100vw",h:"100vh"}}:{dialog:{maxW:t}})}const aV={bg:"blackAlpha.600",zIndex:"modal"},lV={display:"flex",zIndex:"modal",justifyContent:"center"},uV=t=>{const{isFullHeight:e}=t;return{...e&&{height:"100vh"},zIndex:"modal",maxH:"100vh",color:"inherit",[u1.variable]:"colors.white",[c1.variable]:"shadows.lg",_dark:{[u1.variable]:"colors.gray.700",[c1.variable]:"shadows.dark-lg"},bg:u1.reference,boxShadow:c1.reference}},cV={px:"6",py:"4",fontSize:"xl",fontWeight:"semibold"},dV={position:"absolute",top:"2",insetEnd:"3"},hV={px:"6",py:"2",flex:"1",overflow:"auto"},fV={px:"6",py:"4"},pV=Cx(t=>({overlay:aV,dialogContainer:lV,dialog:Ur(uV,t),header:cV,closeButton:dV,body:hV,footer:fV})),mV={xs:Cc("xs"),sm:Cc("md"),md:Cc("lg"),lg:Cc("2xl"),xl:Cc("4xl"),full:Cc("full")},gV=iV({baseStyle:pV,sizes:mV,defaultProps:{size:"xs"}}),{definePartsStyle:yV,defineMultiStyleConfig:xV}=tn(Xz.keys),vV={borderRadius:"md",py:"1",transitionProperty:"common",transitionDuration:"normal"},bV={borderRadius:"md",py:"1",transitionProperty:"common",transitionDuration:"normal",width:"full",_focusVisible:{boxShadow:"outline"},_placeholder:{opacity:.6}},wV={borderRadius:"md",py:"1",transitionProperty:"common",transitionDuration:"normal",width:"full",_focusVisible:{boxShadow:"outline"},_placeholder:{opacity:.6}},SV=yV({preview:vV,input:bV,textarea:wV}),CV=xV({baseStyle:SV}),{definePartsStyle:$V,defineMultiStyleConfig:kV}=tn(qz.keys),Hc=Qe("form-control-color"),TV={marginStart:"1",[Hc.variable]:"colors.red.500",_dark:{[Hc.variable]:"colors.red.300"},color:Hc.reference},IV={mt:"2",[Hc.variable]:"colors.gray.600",_dark:{[Hc.variable]:"colors.whiteAlpha.600"},color:Hc.reference,lineHeight:"normal",fontSize:"sm"},NV=$V({container:{width:"100%",position:"relative"},requiredIndicator:TV,helperText:IV}),EV=kV({baseStyle:NV}),{definePartsStyle:RV,defineMultiStyleConfig:_V}=tn(Yz.keys),Kc=Qe("form-error-color"),PV={[Kc.variable]:"colors.red.500",_dark:{[Kc.variable]:"colors.red.300"},color:Kc.reference,mt:"2",fontSize:"sm",lineHeight:"normal"},AV={marginEnd:"0.5em",[Kc.variable]:"colors.red.500",_dark:{[Kc.variable]:"colors.red.300"},color:Kc.reference},DV=RV({text:PV,icon:AV}),OV=_V({baseStyle:DV}),FV={fontSize:"md",marginEnd:"3",mb:"2",fontWeight:"medium",transitionProperty:"common",transitionDuration:"normal",opacity:1,_disabled:{opacity:.4}},LV={baseStyle:FV},zV={fontFamily:"heading",fontWeight:"bold"},BV={"4xl":{fontSize:["6xl",null,"7xl"],lineHeight:1},"3xl":{fontSize:["5xl",null,"6xl"],lineHeight:1},"2xl":{fontSize:["4xl",null,"5xl"],lineHeight:[1.2,null,1]},xl:{fontSize:["3xl",null,"4xl"],lineHeight:[1.33,null,1.2]},lg:{fontSize:["2xl",null,"3xl"],lineHeight:[1.33,null,1.2]},md:{fontSize:"xl",lineHeight:1.2},sm:{fontSize:"md",lineHeight:1.2},xs:{fontSize:"sm",lineHeight:1.2}},MV={baseStyle:zV,sizes:BV,defaultProps:{size:"xl"}},{definePartsStyle:ra,defineMultiStyleConfig:VV}=tn(Qz.keys),Ac=Qe("input-height"),Dc=Qe("input-font-size"),Oc=Qe("input-padding"),Fc=Qe("input-border-radius"),WV=ra({addon:{height:Ac.reference,fontSize:Dc.reference,px:Oc.reference,borderRadius:Fc.reference},field:{width:"100%",height:Ac.reference,fontSize:Dc.reference,px:Oc.reference,borderRadius:Fc.reference,minWidth:0,outline:0,position:"relative",appearance:"none",transitionProperty:"common",transitionDuration:"normal",_disabled:{opacity:.4,cursor:"not-allowed"}}}),rl={lg:{[Dc.variable]:"fontSizes.lg",[Oc.variable]:"space.4",[Fc.variable]:"radii.md",[Ac.variable]:"sizes.12"},md:{[Dc.variable]:"fontSizes.md",[Oc.variable]:"space.4",[Fc.variable]:"radii.md",[Ac.variable]:"sizes.10"},sm:{[Dc.variable]:"fontSizes.sm",[Oc.variable]:"space.3",[Fc.variable]:"radii.sm",[Ac.variable]:"sizes.8"},xs:{[Dc.variable]:"fontSizes.xs",[Oc.variable]:"space.2",[Fc.variable]:"radii.sm",[Ac.variable]:"sizes.6"}},UV={lg:ra({field:rl.lg,group:rl.lg}),md:ra({field:rl.md,group:rl.md}),sm:ra({field:rl.sm,group:rl.sm}),xs:ra({field:rl.xs,group:rl.xs})};function Jv(t){const{focusBorderColor:e,errorBorderColor:n}=t;return{focusBorderColor:e||Ye("blue.500","blue.300")(t),errorBorderColor:n||Ye("red.500","red.300")(t)}}const jV=ra(t=>{const{theme:e}=t,{focusBorderColor:n,errorBorderColor:r}=Jv(t);return{field:{border:"1px solid",borderColor:"inherit",bg:"inherit",_hover:{borderColor:Ye("gray.300","whiteAlpha.400")(t)},_readOnly:{boxShadow:"none !important",userSelect:"all"},_invalid:{borderColor:Mr(e,r),boxShadow:`0 0 0 1px ${Mr(e,r)}`},_focusVisible:{zIndex:1,borderColor:Mr(e,n),boxShadow:`0 0 0 1px ${Mr(e,n)}`}},addon:{border:"1px solid",borderColor:Ye("inherit","whiteAlpha.50")(t),bg:Ye("gray.100","whiteAlpha.300")(t)}}}),GV=ra(t=>{const{theme:e}=t,{focusBorderColor:n,errorBorderColor:r}=Jv(t);return{field:{border:"2px solid",borderColor:"transparent",bg:Ye("gray.100","whiteAlpha.50")(t),_hover:{bg:Ye("gray.200","whiteAlpha.100")(t)},_readOnly:{boxShadow:"none !important",userSelect:"all"},_invalid:{borderColor:Mr(e,r)},_focusVisible:{bg:"transparent",borderColor:Mr(e,n)}},addon:{border:"2px solid",borderColor:"transparent",bg:Ye("gray.100","whiteAlpha.50")(t)}}}),HV=ra(t=>{const{theme:e}=t,{focusBorderColor:n,errorBorderColor:r}=Jv(t);return{field:{borderBottom:"1px solid",borderColor:"inherit",borderRadius:"0",px:"0",bg:"transparent",_readOnly:{boxShadow:"none !important",userSelect:"all"},_invalid:{borderColor:Mr(e,r),boxShadow:`0px 1px 0px 0px ${Mr(e,r)}`},_focusVisible:{borderColor:Mr(e,n),boxShadow:`0px 1px 0px 0px ${Mr(e,n)}`}},addon:{borderBottom:"2px solid",borderColor:"inherit",borderRadius:"0",px:"0",bg:"transparent"}}}),KV=ra({field:{bg:"transparent",px:"0",height:"auto"},addon:{bg:"transparent",px:"0",height:"auto"}}),XV={outline:jV,filled:GV,flushed:HV,unstyled:KV},Ot=VV({baseStyle:WV,sizes:UV,variants:XV,defaultProps:{size:"md",variant:"outline"}}),d1=Qe("kbd-bg"),qV={[d1.variable]:"colors.gray.100",_dark:{[d1.variable]:"colors.whiteAlpha.100"},bg:d1.reference,borderRadius:"md",borderWidth:"1px",borderBottomWidth:"3px",fontSize:"0.8em",fontWeight:"bold",lineHeight:"normal",px:"0.4em",whiteSpace:"nowrap"},YV={baseStyle:qV},QV={transitionProperty:"common",transitionDuration:"fast",transitionTimingFunction:"ease-out",cursor:"pointer",textDecoration:"none",outline:"none",color:"inherit",_hover:{textDecoration:"underline"},_focusVisible:{boxShadow:"outline"}},ZV={baseStyle:QV},{defineMultiStyleConfig:JV,definePartsStyle:e5}=tn(Zz.keys),t5={marginEnd:"2",display:"inline",verticalAlign:"text-bottom"},n5=e5({icon:t5}),r5=JV({baseStyle:n5}),{defineMultiStyleConfig:s5,definePartsStyle:o5}=tn(Jz.keys),li=Qe("menu-bg"),h1=Qe("menu-shadow"),i5={[li.variable]:"#fff",[h1.variable]:"shadows.sm",_dark:{[li.variable]:"colors.gray.700",[h1.variable]:"shadows.dark-lg"},color:"inherit",minW:"3xs",py:"2",zIndex:"dropdown",borderRadius:"md",borderWidth:"1px",bg:li.reference,boxShadow:h1.reference},a5={py:"1.5",px:"3",transitionProperty:"background",transitionDuration:"ultra-fast",transitionTimingFunction:"ease-in",_focus:{[li.variable]:"colors.gray.100",_dark:{[li.variable]:"colors.whiteAlpha.100"}},_active:{[li.variable]:"colors.gray.200",_dark:{[li.variable]:"colors.whiteAlpha.200"}},_expanded:{[li.variable]:"colors.gray.100",_dark:{[li.variable]:"colors.whiteAlpha.100"}},_disabled:{opacity:.4,cursor:"not-allowed"},bg:li.reference},l5={mx:4,my:2,fontWeight:"semibold",fontSize:"sm"},u5={display:"inline-flex",alignItems:"center",justifyContent:"center",flexShrink:0},c5={opacity:.6},d5={border:0,borderBottom:"1px solid",borderColor:"inherit",my:"2",opacity:.6},h5={transitionProperty:"common",transitionDuration:"normal"},f5=o5({button:h5,list:i5,item:a5,groupTitle:l5,icon:u5,command:c5,divider:d5}),p5=s5({baseStyle:f5}),{defineMultiStyleConfig:m5,definePartsStyle:$x}=tn(eB.keys),f1=Qe("modal-bg"),p1=Qe("modal-shadow"),g5={bg:"blackAlpha.600",zIndex:"modal"},y5=t=>{const{isCentered:e,scrollBehavior:n}=t;return{display:"flex",zIndex:"modal",justifyContent:"center",alignItems:e?"center":"flex-start",overflow:n==="inside"?"hidden":"auto",overscrollBehaviorY:"none"}},x5=t=>{const{isCentered:e,scrollBehavior:n}=t;return{borderRadius:"md",color:"inherit",my:e?"auto":"16",mx:e?"auto":void 0,zIndex:"modal",maxH:n==="inside"?"calc(100% - 7.5rem)":void 0,[f1.variable]:"colors.white",[p1.variable]:"shadows.lg",_dark:{[f1.variable]:"colors.gray.700",[p1.variable]:"shadows.dark-lg"},bg:f1.reference,boxShadow:p1.reference}},v5={px:"6",py:"4",fontSize:"xl",fontWeight:"semibold"},b5={position:"absolute",top:"2",insetEnd:"3"},w5=t=>{const{scrollBehavior:e}=t;return{px:"6",py:"2",flex:"1",overflow:e==="inside"?"auto":void 0}},S5={px:"6",py:"4"},C5=$x(t=>({overlay:g5,dialogContainer:Ur(y5,t),dialog:Ur(x5,t),header:v5,closeButton:b5,body:Ur(w5,t),footer:S5}));function Ro(t){return $x(t==="full"?{dialog:{maxW:"100vw",minH:"$100vh",my:"0",borderRadius:"0"}}:{dialog:{maxW:t}})}const $5={xs:Ro("xs"),sm:Ro("sm"),md:Ro("md"),lg:Ro("lg"),xl:Ro("xl"),"2xl":Ro("2xl"),"3xl":Ro("3xl"),"4xl":Ro("4xl"),"5xl":Ro("5xl"),"6xl":Ro("6xl"),full:Ro("full")},k5=m5({baseStyle:C5,sizes:$5,defaultProps:{size:"md"}}),rR={letterSpacings:{tighter:"-0.05em",tight:"-0.025em",normal:"0",wide:"0.025em",wider:"0.05em",widest:"0.1em"},lineHeights:{normal:"normal",none:1,shorter:1.25,short:1.375,base:1.5,tall:1.625,taller:"2",3:".75rem",4:"1rem",5:"1.25rem",6:"1.5rem",7:"1.75rem",8:"2rem",9:"2.25rem",10:"2.5rem"},fontWeights:{hairline:100,thin:200,light:300,normal:400,medium:500,semibold:600,bold:700,extrabold:800,black:900},fonts:{heading:'-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',body:'-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',mono:'SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace'},fontSizes:{"3xs":"0.45rem","2xs":"0.625rem",xs:"0.75rem",sm:"0.875rem",md:"1rem",lg:"1.125rem",xl:"1.25rem","2xl":"1.5rem","3xl":"1.875rem","4xl":"2.25rem","5xl":"3rem","6xl":"3.75rem","7xl":"4.5rem","8xl":"6rem","9xl":"8rem"}},{defineMultiStyleConfig:T5,definePartsStyle:sR}=tn(tB.keys),eb=Ln("number-input-stepper-width"),oR=Ln("number-input-input-padding"),I5=ea(eb).add("0.5rem").toString(),m1=Ln("number-input-bg"),g1=Ln("number-input-color"),y1=Ln("number-input-border-color"),N5={[eb.variable]:"sizes.6",[oR.variable]:I5},E5=t=>{var e;return((e=Ur(Ot.baseStyle,t))==null?void 0:e.field)??{}},R5={width:eb.reference},_5={borderStart:"1px solid",borderStartColor:y1.reference,color:g1.reference,bg:m1.reference,[g1.variable]:"colors.chakra-body-text",[y1.variable]:"colors.chakra-border-color",_dark:{[g1.variable]:"colors.whiteAlpha.800",[y1.variable]:"colors.whiteAlpha.300"},_active:{[m1.variable]:"colors.gray.200",_dark:{[m1.variable]:"colors.whiteAlpha.300"}},_disabled:{opacity:.4,cursor:"not-allowed"}},P5=sR(t=>({root:N5,field:Ur(E5,t)??{},stepperGroup:R5,stepper:_5}));function im(t){var o,i;const e=(o=Ot.sizes)==null?void 0:o[t],n={lg:"md",md:"md",sm:"sm",xs:"sm"},r=((i=e.field)==null?void 0:i.fontSize)??"md",s=rR.fontSizes[r];return sR({field:{...e.field,paddingInlineEnd:oR.reference,verticalAlign:"top"},stepper:{fontSize:ea(s).multiply(.75).toString(),_first:{borderTopEndRadius:n[t]},_last:{borderBottomEndRadius:n[t],mt:"-1px",borderTopWidth:1}}})}const A5={xs:im("xs"),sm:im("sm"),md:im("md"),lg:im("lg")},D5=T5({baseStyle:P5,sizes:A5,variants:Ot.variants,defaultProps:Ot.defaultProps});var wE;const O5={...(wE=Ot.baseStyle)==null?void 0:wE.field,textAlign:"center"},F5={lg:{fontSize:"lg",w:12,h:12,borderRadius:"md"},md:{fontSize:"md",w:10,h:10,borderRadius:"md"},sm:{fontSize:"sm",w:8,h:8,borderRadius:"sm"},xs:{fontSize:"xs",w:6,h:6,borderRadius:"sm"}};var SE;const L5={outline:t=>{var e,n;return((n=Ur((e=Ot.variants)==null?void 0:e.outline,t))==null?void 0:n.field)??{}},flushed:t=>{var e,n;return((n=Ur((e=Ot.variants)==null?void 0:e.flushed,t))==null?void 0:n.field)??{}},filled:t=>{var e,n;return((n=Ur((e=Ot.variants)==null?void 0:e.filled,t))==null?void 0:n.field)??{}},unstyled:((SE=Ot.variants)==null?void 0:SE.unstyled.field)??{}},z5={baseStyle:O5,sizes:F5,variants:L5,defaultProps:Ot.defaultProps},{defineMultiStyleConfig:B5,definePartsStyle:M5}=tn(nB.keys),am=Ln("popper-bg"),V5=Ln("popper-arrow-bg"),bT=Ln("popper-arrow-shadow-color"),W5={zIndex:"popover"},U5={[am.variable]:"colors.white",bg:am.reference,[V5.variable]:am.reference,[bT.variable]:"colors.gray.200",_dark:{[am.variable]:"colors.gray.700",[bT.variable]:"colors.whiteAlpha.300"},width:"xs",border:"1px solid",borderColor:"inherit",borderRadius:"md",boxShadow:"sm",zIndex:"inherit",_focusVisible:{outline:0,boxShadow:"outline"}},j5={px:3,py:2,borderBottomWidth:"1px"},G5={px:3,py:2},H5={px:3,py:2,borderTopWidth:"1px"},K5={position:"absolute",borderRadius:"md",top:1,insetEnd:2,padding:2},X5=M5({popper:W5,content:U5,header:j5,body:G5,footer:H5,closeButton:K5}),q5=B5({baseStyle:X5}),{defineMultiStyleConfig:Y5,definePartsStyle:Ih}=tn(rB.keys),Q5=t=>{const{colorScheme:e,theme:n,isIndeterminate:r,hasStripe:s}=t,o=Ye(mT(),mT("1rem","rgba(0,0,0,0.1)"))(t),i=Ye(`${e}.500`,`${e}.200`)(t),a=`linear-gradient(
    to right,
    transparent 0%,
    ${Mr(n,i)} 50%,
    transparent 100%
  )`;return{...!r&&s&&o,...r?{bgImage:a}:{bgColor:i}}},Z5={lineHeight:"1",fontSize:"0.25em",fontWeight:"bold",color:"white"},J5=t=>({bg:Ye("gray.100","whiteAlpha.300")(t)}),e6=t=>({transitionProperty:"common",transitionDuration:"slow",...Q5(t)}),t6=Ih(t=>({label:Z5,filledTrack:e6(t),track:J5(t)})),n6={xs:Ih({track:{h:"1"}}),sm:Ih({track:{h:"2"}}),md:Ih({track:{h:"3"}}),lg:Ih({track:{h:"4"}})},r6=Y5({sizes:n6,baseStyle:t6,defaultProps:{size:"md",colorScheme:"blue"}}),{defineMultiStyleConfig:s6,definePartsStyle:Pm}=tn(sB.keys),o6=t=>{var n;const e=(n=Ur(ol.baseStyle,t))==null?void 0:n.control;return{...e,borderRadius:"full",_checked:{...e==null?void 0:e._checked,_before:{content:'""',display:"inline-block",pos:"relative",w:"50%",h:"50%",borderRadius:"50%",bg:"currentColor"}}}},i6=Pm(t=>{var e,n;return{label:(e=ol.baseStyle)==null?void 0:e.call(ol,t).label,container:(n=ol.baseStyle)==null?void 0:n.call(ol,t).container,control:o6(t)}}),a6={md:Pm({control:{w:"4",h:"4"},label:{fontSize:"md"}}),lg:Pm({control:{w:"5",h:"5"},label:{fontSize:"lg"}}),sm:Pm({control:{width:"3",height:"3"},label:{fontSize:"sm"}})},l6=s6({baseStyle:i6,sizes:a6,defaultProps:{size:"md",colorScheme:"blue"}}),{defineMultiStyleConfig:u6,definePartsStyle:c6}=tn(oB.keys),lm=Qe("select-bg");var CE;const d6={...(CE=Ot.baseStyle)==null?void 0:CE.field,appearance:"none",paddingBottom:"1px",lineHeight:"normal",bg:lm.reference,[lm.variable]:"colors.white",_dark:{[lm.variable]:"colors.gray.700"},"> option, > optgroup":{bg:lm.reference}},h6={width:"6",height:"100%",insetEnd:"2",position:"relative",color:"currentColor",fontSize:"xl",_disabled:{opacity:.5}},f6=c6({field:d6,icon:h6}),um={paddingInlineEnd:"8"};var $E,kE,TE,IE,NE,EE,RE,_E;const p6={lg:{...($E=Ot.sizes)==null?void 0:$E.lg,field:{...(kE=Ot.sizes)==null?void 0:kE.lg.field,...um}},md:{...(TE=Ot.sizes)==null?void 0:TE.md,field:{...(IE=Ot.sizes)==null?void 0:IE.md.field,...um}},sm:{...(NE=Ot.sizes)==null?void 0:NE.sm,field:{...(EE=Ot.sizes)==null?void 0:EE.sm.field,...um}},xs:{...(RE=Ot.sizes)==null?void 0:RE.xs,field:{...(_E=Ot.sizes)==null?void 0:_E.xs.field,...um},icon:{insetEnd:"1"}}},m6=u6({baseStyle:f6,sizes:p6,variants:Ot.variants,defaultProps:Ot.defaultProps}),x1=Qe("skeleton-start-color"),v1=Qe("skeleton-end-color"),g6={[x1.variable]:"colors.gray.100",[v1.variable]:"colors.gray.400",_dark:{[x1.variable]:"colors.gray.800",[v1.variable]:"colors.gray.600"},background:x1.reference,borderColor:v1.reference,opacity:.7,borderRadius:"sm"},y6={baseStyle:g6},b1=Qe("skip-link-bg"),x6={borderRadius:"md",fontWeight:"semibold",_focusVisible:{boxShadow:"outline",padding:"4",position:"fixed",top:"6",insetStart:"6",[b1.variable]:"colors.white",_dark:{[b1.variable]:"colors.gray.700"},bg:b1.reference}},v6={baseStyle:x6},{defineMultiStyleConfig:b6,definePartsStyle:jg}=tn(iB.keys),Eu=Qe("slider-thumb-size"),nf=Qe("slider-track-size"),al=Qe("slider-bg"),w6=t=>{const{orientation:e}=t;return{display:"inline-block",position:"relative",cursor:"pointer",_disabled:{opacity:.6,cursor:"default",pointerEvents:"none"},...Qv({orientation:e,vertical:{h:"100%",px:Ji(Eu.reference).divide(2).toString()},horizontal:{w:"100%",py:Ji(Eu.reference).divide(2).toString()}})}},S6=t=>({...Qv({orientation:t.orientation,horizontal:{h:nf.reference},vertical:{w:nf.reference}}),overflow:"hidden",borderRadius:"sm",[al.variable]:"colors.gray.200",_dark:{[al.variable]:"colors.whiteAlpha.200"},_disabled:{[al.variable]:"colors.gray.300",_dark:{[al.variable]:"colors.whiteAlpha.300"}},bg:al.reference}),C6=t=>{const{orientation:e}=t;return{...Qv({orientation:e,vertical:{left:"50%",transform:"translateX(-50%)",_active:{transform:"translateX(-50%) scale(1.15)"}},horizontal:{top:"50%",transform:"translateY(-50%)",_active:{transform:"translateY(-50%) scale(1.15)"}}}),w:Eu.reference,h:Eu.reference,display:"flex",alignItems:"center",justifyContent:"center",position:"absolute",outline:0,zIndex:1,borderRadius:"full",bg:"white",boxShadow:"base",border:"1px solid",borderColor:"transparent",transitionProperty:"transform",transitionDuration:"normal",_focusVisible:{boxShadow:"outline"},_disabled:{bg:"gray.300"}}},$6=t=>{const{colorScheme:e}=t;return{width:"inherit",height:"inherit",[al.variable]:`colors.${e}.500`,_dark:{[al.variable]:`colors.${e}.200`},bg:al.reference}},k6=jg(t=>({container:w6(t),track:S6(t),thumb:C6(t),filledTrack:$6(t)})),T6=jg({container:{[Eu.variable]:"sizes.4",[nf.variable]:"sizes.1"}}),I6=jg({container:{[Eu.variable]:"sizes.3.5",[nf.variable]:"sizes.1"}}),N6=jg({container:{[Eu.variable]:"sizes.2.5",[nf.variable]:"sizes.0.5"}}),E6={lg:T6,md:I6,sm:N6},R6=b6({baseStyle:k6,sizes:E6,defaultProps:{size:"md",colorScheme:"blue"}}),cu=Ln("spinner-size"),_6={width:[cu.reference],height:[cu.reference]},P6={xs:{[cu.variable]:"sizes.3"},sm:{[cu.variable]:"sizes.4"},md:{[cu.variable]:"sizes.6"},lg:{[cu.variable]:"sizes.8"},xl:{[cu.variable]:"sizes.12"}},A6={baseStyle:_6,sizes:P6,defaultProps:{size:"md"}},{defineMultiStyleConfig:D6,definePartsStyle:iR}=tn(aB.keys),O6={fontWeight:"medium"},F6={opacity:.8,marginBottom:"2"},L6={verticalAlign:"baseline",fontWeight:"semibold"},z6={marginEnd:1,w:"3.5",h:"3.5",verticalAlign:"middle"},B6=iR({container:{},label:O6,helpText:F6,number:L6,icon:z6}),M6={md:iR({label:{fontSize:"sm"},helpText:{fontSize:"sm"},number:{fontSize:"2xl"}})},V6=D6({baseStyle:B6,sizes:M6,defaultProps:{size:"md"}}),{defineMultiStyleConfig:W6,definePartsStyle:Nh}=tn(["stepper","step","title","description","indicator","separator","icon","number"]),ta=Qe("stepper-indicator-size"),Lc=Qe("stepper-icon-size"),zc=Qe("stepper-title-font-size"),Eh=Qe("stepper-description-font-size"),gh=Qe("stepper-accent-color"),U6=Nh(({colorScheme:t})=>({stepper:{display:"flex",justifyContent:"space-between",gap:"4","&[data-orientation=vertical]":{flexDirection:"column",alignItems:"flex-start"},"&[data-orientation=horizontal]":{flexDirection:"row",alignItems:"center"},[gh.variable]:`colors.${t}.500`,_dark:{[gh.variable]:`colors.${t}.200`}},title:{fontSize:zc.reference,fontWeight:"medium"},description:{fontSize:Eh.reference,color:"chakra-subtle-text"},number:{fontSize:zc.reference},step:{flexShrink:0,position:"relative",display:"flex",gap:"2","&[data-orientation=horizontal]":{alignItems:"center"},flex:"1","&:last-of-type:not([data-stretch])":{flex:"initial"}},icon:{flexShrink:0,width:Lc.reference,height:Lc.reference},indicator:{flexShrink:0,borderRadius:"full",width:ta.reference,height:ta.reference,display:"flex",justifyContent:"center",alignItems:"center","&[data-status=active]":{borderWidth:"2px",borderColor:gh.reference},"&[data-status=complete]":{bg:gh.reference,color:"chakra-inverse-text"},"&[data-status=incomplete]":{borderWidth:"2px"}},separator:{bg:"chakra-border-color",flex:"1","&[data-status=complete]":{bg:gh.reference},"&[data-orientation=horizontal]":{width:"100%",height:"2px",marginStart:"2"},"&[data-orientation=vertical]":{width:"2px",position:"absolute",height:"100%",maxHeight:`calc(100% - ${ta.reference} - 8px)`,top:`calc(${ta.reference} + 4px)`,insetStart:`calc(${ta.reference} / 2 - 1px)`}}})),j6=W6({baseStyle:U6,sizes:{xs:Nh({stepper:{[ta.variable]:"sizes.4",[Lc.variable]:"sizes.3",[zc.variable]:"fontSizes.xs",[Eh.variable]:"fontSizes.xs"}}),sm:Nh({stepper:{[ta.variable]:"sizes.6",[Lc.variable]:"sizes.4",[zc.variable]:"fontSizes.sm",[Eh.variable]:"fontSizes.xs"}}),md:Nh({stepper:{[ta.variable]:"sizes.8",[Lc.variable]:"sizes.5",[zc.variable]:"fontSizes.md",[Eh.variable]:"fontSizes.sm"}}),lg:Nh({stepper:{[ta.variable]:"sizes.10",[Lc.variable]:"sizes.6",[zc.variable]:"fontSizes.lg",[Eh.variable]:"fontSizes.md"}})},defaultProps:{size:"md",colorScheme:"blue"}}),{defineMultiStyleConfig:G6,definePartsStyle:Am}=tn(lB.keys),jh=Ln("switch-track-width"),Cu=Ln("switch-track-height"),w1=Ln("switch-track-diff"),H6=ea.subtract(jh,Cu),kx=Ln("switch-thumb-x"),yh=Ln("switch-bg"),K6=t=>{const{colorScheme:e}=t;return{borderRadius:"full",p:"0.5",width:[jh.reference],height:[Cu.reference],transitionProperty:"common",transitionDuration:"fast",[yh.variable]:"colors.gray.300",_dark:{[yh.variable]:"colors.whiteAlpha.400"},_focusVisible:{boxShadow:"outline"},_disabled:{opacity:.4,cursor:"not-allowed"},_checked:{[yh.variable]:`colors.${e}.500`,_dark:{[yh.variable]:`colors.${e}.200`}},bg:yh.reference}},X6={bg:"white",transitionProperty:"transform",transitionDuration:"normal",borderRadius:"inherit",width:[Cu.reference],height:[Cu.reference],_checked:{transform:`translateX(${kx.reference})`}},q6=Am(t=>({container:{[w1.variable]:H6,[kx.variable]:w1.reference,_rtl:{[kx.variable]:ea(w1).negate().toString()}},track:K6(t),thumb:X6})),Y6={sm:Am({container:{[jh.variable]:"1.375rem",[Cu.variable]:"sizes.3"}}),md:Am({container:{[jh.variable]:"1.875rem",[Cu.variable]:"sizes.4"}}),lg:Am({container:{[jh.variable]:"2.875rem",[Cu.variable]:"sizes.6"}})},Q6=G6({baseStyle:q6,sizes:Y6,defaultProps:{size:"md",colorScheme:"blue"}}),{defineMultiStyleConfig:Z6,definePartsStyle:Xc}=tn(uB.keys),J6=Xc({table:{fontVariantNumeric:"lining-nums tabular-nums",borderCollapse:"collapse",width:"full"},th:{fontFamily:"heading",fontWeight:"bold",textTransform:"uppercase",letterSpacing:"wider",textAlign:"start"},td:{textAlign:"start"},caption:{mt:4,fontFamily:"heading",textAlign:"center",fontWeight:"medium"}}),og={"&[data-is-numeric=true]":{textAlign:"end"}},eW=Xc(t=>{const{colorScheme:e}=t;return{th:{color:Ye("gray.600","gray.400")(t),borderBottom:"1px",borderColor:Ye(`${e}.100`,`${e}.700`)(t),...og},td:{borderBottom:"1px",borderColor:Ye(`${e}.100`,`${e}.700`)(t),...og},caption:{color:Ye("gray.600","gray.100")(t)},tfoot:{tr:{"&:last-of-type":{th:{borderBottomWidth:0}}}}}}),tW=Xc(t=>{const{colorScheme:e}=t;return{th:{color:Ye("gray.600","gray.400")(t),borderBottom:"1px",borderColor:Ye(`${e}.100`,`${e}.700`)(t),...og},td:{borderBottom:"1px",borderColor:Ye(`${e}.100`,`${e}.700`)(t),...og},caption:{color:Ye("gray.600","gray.100")(t)},tbody:{tr:{"&:nth-of-type(odd)":{"th, td":{borderBottomWidth:"1px",borderColor:Ye(`${e}.100`,`${e}.700`)(t)},td:{background:Ye(`${e}.100`,`${e}.700`)(t)}}}},tfoot:{tr:{"&:last-of-type":{th:{borderBottomWidth:0}}}}}}),nW={simple:eW,striped:tW,unstyled:{}},rW={sm:Xc({th:{px:"4",py:"1",lineHeight:"4",fontSize:"xs"},td:{px:"4",py:"2",fontSize:"sm",lineHeight:"4"},caption:{px:"4",py:"2",fontSize:"xs"}}),md:Xc({th:{px:"6",py:"3",lineHeight:"4",fontSize:"xs"},td:{px:"6",py:"4",lineHeight:"5"},caption:{px:"6",py:"2",fontSize:"sm"}}),lg:Xc({th:{px:"8",py:"4",lineHeight:"5",fontSize:"sm"},td:{px:"8",py:"5",lineHeight:"6"},caption:{px:"6",py:"2",fontSize:"md"}})},sW=Z6({baseStyle:J6,variants:nW,sizes:rW,defaultProps:{variant:"simple",size:"md",colorScheme:"gray"}}),fs=Qe("tabs-color"),Fo=Qe("tabs-bg"),cm=Qe("tabs-border-color"),{defineMultiStyleConfig:oW,definePartsStyle:pi}=tn(cB.keys),iW=t=>{const{orientation:e}=t;return{display:e==="vertical"?"flex":"block"}},aW=t=>{const{isFitted:e}=t;return{flex:e?1:void 0,transitionProperty:"common",transitionDuration:"normal",_focusVisible:{zIndex:1,boxShadow:"outline"},_disabled:{cursor:"not-allowed",opacity:.4}}},lW=t=>{const{align:e="start",orientation:n}=t;return{justifyContent:{end:"flex-end",center:"center",start:"flex-start"}[e],flexDirection:n==="vertical"?"column":"row"}},uW={p:4},cW=pi(t=>({root:iW(t),tab:aW(t),tablist:lW(t),tabpanel:uW})),dW={sm:pi({tab:{py:1,px:4,fontSize:"sm"}}),md:pi({tab:{fontSize:"md",py:2,px:4}}),lg:pi({tab:{fontSize:"lg",py:3,px:4}})},hW=pi(t=>{const{colorScheme:e,orientation:n}=t,r=n==="vertical",s=r?"borderStart":"borderBottom",o=r?"marginStart":"marginBottom";return{tablist:{[s]:"2px solid",borderColor:"inherit"},tab:{[s]:"2px solid",borderColor:"transparent",[o]:"-2px",_selected:{[fs.variable]:`colors.${e}.600`,_dark:{[fs.variable]:`colors.${e}.300`},borderColor:"currentColor"},_active:{[Fo.variable]:"colors.gray.200",_dark:{[Fo.variable]:"colors.whiteAlpha.300"}},_disabled:{_active:{bg:"none"}},color:fs.reference,bg:Fo.reference}}}),fW=pi(t=>{const{colorScheme:e}=t;return{tab:{borderTopRadius:"md",border:"1px solid",borderColor:"transparent",mb:"-1px",[cm.variable]:"transparent",_selected:{[fs.variable]:`colors.${e}.600`,[cm.variable]:"colors.white",_dark:{[fs.variable]:`colors.${e}.300`,[cm.variable]:"colors.gray.800"},borderColor:"inherit",borderBottomColor:cm.reference},color:fs.reference},tablist:{mb:"-1px",borderBottom:"1px solid",borderColor:"inherit"}}}),pW=pi(t=>{const{colorScheme:e}=t;return{tab:{border:"1px solid",borderColor:"inherit",[Fo.variable]:"colors.gray.50",_dark:{[Fo.variable]:"colors.whiteAlpha.50"},mb:"-1px",_notLast:{marginEnd:"-1px"},_selected:{[Fo.variable]:"colors.white",[fs.variable]:`colors.${e}.600`,_dark:{[Fo.variable]:"colors.gray.800",[fs.variable]:`colors.${e}.300`},borderColor:"inherit",borderTopColor:"currentColor",borderBottomColor:"transparent"},color:fs.reference,bg:Fo.reference},tablist:{mb:"-1px",borderBottom:"1px solid",borderColor:"inherit"}}}),mW=pi(t=>{const{colorScheme:e,theme:n}=t;return{tab:{borderRadius:"full",fontWeight:"semibold",color:"gray.600",_selected:{color:Mr(n,`${e}.700`),bg:Mr(n,`${e}.100`)}}}}),gW=pi(t=>{const{colorScheme:e}=t;return{tab:{borderRadius:"full",fontWeight:"semibold",[fs.variable]:"colors.gray.600",_dark:{[fs.variable]:"inherit"},_selected:{[fs.variable]:"colors.white",[Fo.variable]:`colors.${e}.600`,_dark:{[fs.variable]:"colors.gray.800",[Fo.variable]:`colors.${e}.300`}},color:fs.reference,bg:Fo.reference}}}),yW=pi({}),xW={line:hW,enclosed:fW,"enclosed-colored":pW,"soft-rounded":mW,"solid-rounded":gW,unstyled:yW},vW=oW({baseStyle:cW,sizes:dW,variants:xW,defaultProps:{size:"md",variant:"line",colorScheme:"blue"}}),{defineMultiStyleConfig:bW,definePartsStyle:$u}=tn(dB.keys),wT=Qe("tag-bg"),ST=Qe("tag-color"),S1=Qe("tag-shadow"),Dm=Qe("tag-min-height"),Om=Qe("tag-min-width"),Fm=Qe("tag-font-size"),Lm=Qe("tag-padding-inline"),wW={fontWeight:"medium",lineHeight:1.2,outline:0,[ST.variable]:$n.color.reference,[wT.variable]:$n.bg.reference,[S1.variable]:$n.shadow.reference,color:ST.reference,bg:wT.reference,boxShadow:S1.reference,borderRadius:"md",minH:Dm.reference,minW:Om.reference,fontSize:Fm.reference,px:Lm.reference,_focusVisible:{[S1.variable]:"shadows.outline"}},SW={lineHeight:1.2,overflow:"visible"},CW={fontSize:"lg",w:"5",h:"5",transitionProperty:"common",transitionDuration:"normal",borderRadius:"full",marginStart:"1.5",marginEnd:"-1",opacity:.5,_disabled:{opacity:.4},_focusVisible:{boxShadow:"outline",bg:"rgba(0, 0, 0, 0.14)"},_hover:{opacity:.8},_active:{opacity:1}},$W=$u({container:wW,label:SW,closeButton:CW}),kW={sm:$u({container:{[Dm.variable]:"sizes.5",[Om.variable]:"sizes.5",[Fm.variable]:"fontSizes.xs",[Lm.variable]:"space.2"},closeButton:{marginEnd:"-2px",marginStart:"0.35rem"}}),md:$u({container:{[Dm.variable]:"sizes.6",[Om.variable]:"sizes.6",[Fm.variable]:"fontSizes.sm",[Lm.variable]:"space.2"}}),lg:$u({container:{[Dm.variable]:"sizes.8",[Om.variable]:"sizes.8",[Fm.variable]:"fontSizes.md",[Lm.variable]:"space.3"}})},TW={subtle:$u(t=>{var e;return{container:(e=Vh.variants)==null?void 0:e.subtle(t)}}),solid:$u(t=>{var e;return{container:(e=Vh.variants)==null?void 0:e.solid(t)}}),outline:$u(t=>{var e;return{container:(e=Vh.variants)==null?void 0:e.outline(t)}})},IW=bW({variants:TW,baseStyle:$W,sizes:kW,defaultProps:{size:"md",variant:"subtle",colorScheme:"gray"}});var PE;const NW={...(PE=Ot.baseStyle)==null?void 0:PE.field,paddingY:"2",minHeight:"20",lineHeight:"short",verticalAlign:"top"};var AE;const EW={outline:t=>{var e;return((e=Ot.variants)==null?void 0:e.outline(t).field)??{}},flushed:t=>{var e;return((e=Ot.variants)==null?void 0:e.flushed(t).field)??{}},filled:t=>{var e;return((e=Ot.variants)==null?void 0:e.filled(t).field)??{}},unstyled:((AE=Ot.variants)==null?void 0:AE.unstyled.field)??{}};var DE,OE,FE,LE;const RW={xs:((DE=Ot.sizes)==null?void 0:DE.xs.field)??{},sm:((OE=Ot.sizes)==null?void 0:OE.sm.field)??{},md:((FE=Ot.sizes)==null?void 0:FE.md.field)??{},lg:((LE=Ot.sizes)==null?void 0:LE.lg.field)??{}},_W={baseStyle:NW,sizes:RW,variants:EW,defaultProps:{size:"md",variant:"outline"}},dm=Ln("tooltip-bg"),C1=Ln("tooltip-fg"),PW=Ln("popper-arrow-bg"),AW={bg:dm.reference,color:C1.reference,[dm.variable]:"colors.gray.700",[C1.variable]:"colors.whiteAlpha.900",_dark:{[dm.variable]:"colors.gray.300",[C1.variable]:"colors.gray.900"},[PW.variable]:dm.reference,px:"2",py:"0.5",borderRadius:"sm",fontWeight:"medium",fontSize:"sm",boxShadow:"md",maxW:"xs",zIndex:"tooltip"},DW={baseStyle:AW},OW={Accordion:bB,Alert:rM,Avatar:pM,Badge:Vh,Breadcrumb:$M,Button:AM,Checkbox:ol,CloseButton:XM,Code:ZM,Container:eV,Divider:oV,Drawer:gV,Editable:CV,Form:EV,FormError:OV,FormLabel:LV,Heading:MV,Input:Ot,Kbd:YV,Link:ZV,List:r5,Menu:p5,Modal:k5,NumberInput:D5,PinInput:z5,Popover:q5,Progress:r6,Radio:l6,Select:m6,Skeleton:y6,SkipLink:v6,Slider:R6,Spinner:A6,Stat:V6,Switch:Q6,Table:sW,Tabs:vW,Tag:IW,Textarea:_W,Tooltip:DW,Card:zM,Stepper:j6},FW={none:0,"1px":"1px solid","2px":"2px solid","4px":"4px solid","8px":"8px solid"},LW={base:"0em",sm:"30em",md:"48em",lg:"62em",xl:"80em","2xl":"96em"},zW={transparent:"transparent",current:"currentColor",black:"#000000",white:"#FFFFFF",whiteAlpha:{50:"rgba(255, 255, 255, 0.04)",100:"rgba(255, 255, 255, 0.06)",200:"rgba(255, 255, 255, 0.08)",300:"rgba(255, 255, 255, 0.16)",400:"rgba(255, 255, 255, 0.24)",500:"rgba(255, 255, 255, 0.36)",600:"rgba(255, 255, 255, 0.48)",700:"rgba(255, 255, 255, 0.64)",800:"rgba(255, 255, 255, 0.80)",900:"rgba(255, 255, 255, 0.92)"},blackAlpha:{50:"rgba(0, 0, 0, 0.04)",100:"rgba(0, 0, 0, 0.06)",200:"rgba(0, 0, 0, 0.08)",300:"rgba(0, 0, 0, 0.16)",400:"rgba(0, 0, 0, 0.24)",500:"rgba(0, 0, 0, 0.36)",600:"rgba(0, 0, 0, 0.48)",700:"rgba(0, 0, 0, 0.64)",800:"rgba(0, 0, 0, 0.80)",900:"rgba(0, 0, 0, 0.92)"},gray:{50:"#F7FAFC",100:"#EDF2F7",200:"#E2E8F0",300:"#CBD5E0",400:"#A0AEC0",500:"#718096",600:"#4A5568",700:"#2D3748",800:"#1A202C",900:"#171923"},red:{50:"#FFF5F5",100:"#FED7D7",200:"#FEB2B2",300:"#FC8181",400:"#F56565",500:"#E53E3E",600:"#C53030",700:"#9B2C2C",800:"#822727",900:"#63171B"},orange:{50:"#FFFAF0",100:"#FEEBC8",200:"#FBD38D",300:"#F6AD55",400:"#ED8936",500:"#DD6B20",600:"#C05621",700:"#9C4221",800:"#7B341E",900:"#652B19"},yellow:{50:"#FFFFF0",100:"#FEFCBF",200:"#FAF089",300:"#F6E05E",400:"#ECC94B",500:"#D69E2E",600:"#B7791F",700:"#975A16",800:"#744210",900:"#5F370E"},green:{50:"#F0FFF4",100:"#C6F6D5",200:"#9AE6B4",300:"#68D391",400:"#48BB78",500:"#38A169",600:"#2F855A",700:"#276749",800:"#22543D",900:"#1C4532"},teal:{50:"#E6FFFA",100:"#B2F5EA",200:"#81E6D9",300:"#4FD1C5",400:"#38B2AC",500:"#319795",600:"#2C7A7B",700:"#285E61",800:"#234E52",900:"#1D4044"},blue:{50:"#ebf8ff",100:"#bee3f8",200:"#90cdf4",300:"#63b3ed",400:"#4299e1",500:"#3182ce",600:"#2b6cb0",700:"#2c5282",800:"#2a4365",900:"#1A365D"},cyan:{50:"#EDFDFD",100:"#C4F1F9",200:"#9DECF9",300:"#76E4F7",400:"#0BC5EA",500:"#00B5D8",600:"#00A3C4",700:"#0987A0",800:"#086F83",900:"#065666"},purple:{50:"#FAF5FF",100:"#E9D8FD",200:"#D6BCFA",300:"#B794F4",400:"#9F7AEA",500:"#805AD5",600:"#6B46C1",700:"#553C9A",800:"#44337A",900:"#322659"},pink:{50:"#FFF5F7",100:"#FED7E2",200:"#FBB6CE",300:"#F687B3",400:"#ED64A6",500:"#D53F8C",600:"#B83280",700:"#97266D",800:"#702459",900:"#521B41"}},BW={none:"0",sm:"0.125rem",base:"0.25rem",md:"0.375rem",lg:"0.5rem",xl:"0.75rem","2xl":"1rem","3xl":"1.5rem",full:"9999px"},MW={xs:"0 0 0 1px rgba(0, 0, 0, 0.05)",sm:"0 1px 2px 0 rgba(0, 0, 0, 0.05)",base:"0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",md:"0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",lg:"0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",xl:"0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)","2xl":"0 25px 50px -12px rgba(0, 0, 0, 0.25)",outline:"0 0 0 3px rgba(66, 153, 225, 0.6)",inner:"inset 0 2px 4px 0 rgba(0,0,0,0.06)",none:"none","dark-lg":"rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px"},VW={common:"background-color, border-color, color, fill, stroke, opacity, box-shadow, transform",colors:"background-color, border-color, color, fill, stroke",dimensions:"width, height",position:"left, right, top, bottom",background:"background-color, background-image, background-position"},WW={"ease-in":"cubic-bezier(0.4, 0, 1, 1)","ease-out":"cubic-bezier(0, 0, 0.2, 1)","ease-in-out":"cubic-bezier(0.4, 0, 0.2, 1)"},UW={"ultra-fast":"50ms",faster:"100ms",fast:"150ms",normal:"200ms",slow:"300ms",slower:"400ms","ultra-slow":"500ms"},jW={property:VW,easing:WW,duration:UW},GW={hide:-1,auto:"auto",base:0,docked:10,dropdown:1e3,sticky:1100,banner:1200,overlay:1300,modal:1400,popover:1500,skipLink:1600,toast:1700,tooltip:1800},HW={none:0,sm:"4px",base:"8px",md:"12px",lg:"16px",xl:"24px","2xl":"40px","3xl":"64px"},KW={breakpoints:LW,zIndices:GW,radii:BW,blur:HW,colors:zW,...rR,sizes:QE,shadows:MW,space:YE,borders:FW,transition:jW},XW={colors:{"chakra-body-text":{_light:"gray.800",_dark:"whiteAlpha.900"},"chakra-body-bg":{_light:"white",_dark:"gray.800"},"chakra-border-color":{_light:"gray.200",_dark:"whiteAlpha.300"},"chakra-inverse-text":{_light:"white",_dark:"gray.800"},"chakra-subtle-bg":{_light:"gray.100",_dark:"gray.700"},"chakra-subtle-text":{_light:"gray.600",_dark:"gray.400"},"chakra-placeholder-color":{_light:"gray.500",_dark:"whiteAlpha.400"}}},qW={global:{body:{fontFamily:"body",color:"chakra-body-text",bg:"chakra-body-bg",transitionProperty:"background-color",transitionDuration:"normal",lineHeight:"base"},"*::placeholder":{color:"chakra-placeholder-color"},"*, *::before, &::after":{borderColor:"chakra-border-color"}}},YW=["borders","breakpoints","colors","components","config","direction","fonts","fontSizes","fontWeights","letterSpacings","lineHeights","radii","shadows","sizes","space","styles","transition","zIndices"];function QW(t){return Wr(t)?YW.every(e=>Object.prototype.hasOwnProperty.call(t,e)):!1}const ZW="ltr",JW={useSystemColorMode:!1,initialColorMode:"light",cssVarPrefix:"chakra"},aR={semanticTokens:XW,direction:ZW,...KW,components:OW,styles:qW,config:JW};function eU(t){if(t.sheet)return t.sheet;for(var e=0;e<document.styleSheets.length;e++)if(document.styleSheets[e].ownerNode===t)return document.styleSheets[e]}function tU(t){var e=document.createElement("style");return e.setAttribute("data-emotion",t.key),t.nonce!==void 0&&e.setAttribute("nonce",t.nonce),e.appendChild(document.createTextNode("")),e.setAttribute("data-s",""),e}var nU=function(){function t(n){var r=this;this._insertTag=function(s){var o;r.tags.length===0?r.insertionPoint?o=r.insertionPoint.nextSibling:r.prepend?o=r.container.firstChild:o=r.before:o=r.tags[r.tags.length-1].nextSibling,r.container.insertBefore(s,o),r.tags.push(s)},this.isSpeedy=n.speedy===void 0?!0:n.speedy,this.tags=[],this.ctr=0,this.nonce=n.nonce,this.key=n.key,this.container=n.container,this.prepend=n.prepend,this.insertionPoint=n.insertionPoint,this.before=null}var e=t.prototype;return e.hydrate=function(r){r.forEach(this._insertTag)},e.insert=function(r){this.ctr%(this.isSpeedy?65e3:1)===0&&this._insertTag(tU(this));var s=this.tags[this.tags.length-1];if(this.isSpeedy){var o=eU(s);try{o.insertRule(r,o.cssRules.length)}catch{}}else s.appendChild(document.createTextNode(r));this.ctr++},e.flush=function(){this.tags.forEach(function(r){var s;return(s=r.parentNode)==null?void 0:s.removeChild(r)}),this.tags=[],this.ctr=0},t}(),br="-ms-",ig="-moz-",At="-webkit-",lR="comm",tb="rule",nb="decl",rU="@import",uR="@keyframes",sU="@layer",oU=Math.abs,Gg=String.fromCharCode,iU=Object.assign;function aU(t,e){return ar(t,0)^45?(((e<<2^ar(t,0))<<2^ar(t,1))<<2^ar(t,2))<<2^ar(t,3):0}function cR(t){return t.trim()}function lU(t,e){return(t=e.exec(t))?t[0]:t}function Dt(t,e,n){return t.replace(e,n)}function Tx(t,e){return t.indexOf(e)}function ar(t,e){return t.charCodeAt(e)|0}function rf(t,e,n){return t.slice(e,n)}function ui(t){return t.length}function rb(t){return t.length}function hm(t,e){return e.push(t),t}function uU(t,e){return t.map(e).join("")}var Hg=1,nd=1,dR=0,ms=0,Nn=0,gd="";function Kg(t,e,n,r,s,o,i){return{value:t,root:e,parent:n,type:r,props:s,children:o,line:Hg,column:nd,length:i,return:""}}function xh(t,e){return iU(Kg("",null,null,"",null,null,0),t,{length:-t.length},e)}function cU(){return Nn}function dU(){return Nn=ms>0?ar(gd,--ms):0,nd--,Nn===10&&(nd=1,Hg--),Nn}function Ds(){return Nn=ms<dR?ar(gd,ms++):0,nd++,Nn===10&&(nd=1,Hg++),Nn}function mi(){return ar(gd,ms)}function zm(){return ms}function Of(t,e){return rf(gd,t,e)}function sf(t){switch(t){case 0:case 9:case 10:case 13:case 32:return 5;case 33:case 43:case 44:case 47:case 62:case 64:case 126:case 59:case 123:case 125:return 4;case 58:return 3;case 34:case 39:case 40:case 91:return 2;case 41:case 93:return 1}return 0}function hR(t){return Hg=nd=1,dR=ui(gd=t),ms=0,[]}function fR(t){return gd="",t}function Bm(t){return cR(Of(ms-1,Ix(t===91?t+2:t===40?t+1:t)))}function hU(t){for(;(Nn=mi())&&Nn<33;)Ds();return sf(t)>2||sf(Nn)>3?"":" "}function fU(t,e){for(;--e&&Ds()&&!(Nn<48||Nn>102||Nn>57&&Nn<65||Nn>70&&Nn<97););return Of(t,zm()+(e<6&&mi()==32&&Ds()==32))}function Ix(t){for(;Ds();)switch(Nn){case t:return ms;case 34:case 39:t!==34&&t!==39&&Ix(Nn);break;case 40:t===41&&Ix(t);break;case 92:Ds();break}return ms}function pU(t,e){for(;Ds()&&t+Nn!==57;)if(t+Nn===84&&mi()===47)break;return"/*"+Of(e,ms-1)+"*"+Gg(t===47?t:Ds())}function mU(t){for(;!sf(mi());)Ds();return Of(t,ms)}function gU(t){return fR(Mm("",null,null,null,[""],t=hR(t),0,[0],t))}function Mm(t,e,n,r,s,o,i,a,l){for(var c=0,d=0,f=i,p=0,g=0,y=0,x=1,w=1,S=1,$=0,I="",R=s,_=o,O=r,F=I;w;)switch(y=$,$=Ds()){case 40:if(y!=108&&ar(F,f-1)==58){Tx(F+=Dt(Bm($),"&","&\f"),"&\f")!=-1&&(S=-1);break}case 34:case 39:case 91:F+=Bm($);break;case 9:case 10:case 13:case 32:F+=hU(y);break;case 92:F+=fU(zm()-1,7);continue;case 47:switch(mi()){case 42:case 47:hm(yU(pU(Ds(),zm()),e,n),l);break;default:F+="/"}break;case 123*x:a[c++]=ui(F)*S;case 125*x:case 59:case 0:switch($){case 0:case 125:w=0;case 59+d:S==-1&&(F=Dt(F,/\f/g,"")),g>0&&ui(F)-f&&hm(g>32?$T(F+";",r,n,f-1):$T(Dt(F," ","")+";",r,n,f-2),l);break;case 59:F+=";";default:if(hm(O=CT(F,e,n,c,d,s,a,I,R=[],_=[],f),o),$===123)if(d===0)Mm(F,e,O,O,R,o,f,a,_);else switch(p===99&&ar(F,3)===110?100:p){case 100:case 108:case 109:case 115:Mm(t,O,O,r&&hm(CT(t,O,O,0,0,s,a,I,s,R=[],f),_),s,_,f,a,r?R:_);break;default:Mm(F,O,O,O,[""],_,0,a,_)}}c=d=g=0,x=S=1,I=F="",f=i;break;case 58:f=1+ui(F),g=y;default:if(x<1){if($==123)--x;else if($==125&&x++==0&&dU()==125)continue}switch(F+=Gg($),$*x){case 38:S=d>0?1:(F+="\f",-1);break;case 44:a[c++]=(ui(F)-1)*S,S=1;break;case 64:mi()===45&&(F+=Bm(Ds())),p=mi(),d=f=ui(I=F+=mU(zm())),$++;break;case 45:y===45&&ui(F)==2&&(x=0)}}return o}function CT(t,e,n,r,s,o,i,a,l,c,d){for(var f=s-1,p=s===0?o:[""],g=rb(p),y=0,x=0,w=0;y<r;++y)for(var S=0,$=rf(t,f+1,f=oU(x=i[y])),I=t;S<g;++S)(I=cR(x>0?p[S]+" "+$:Dt($,/&\f/g,p[S])))&&(l[w++]=I);return Kg(t,e,n,s===0?tb:a,l,c,d)}function yU(t,e,n){return Kg(t,e,n,lR,Gg(cU()),rf(t,2,-2),0)}function $T(t,e,n,r){return Kg(t,e,n,nb,rf(t,0,r),rf(t,r+1,-1),r)}function qc(t,e){for(var n="",r=rb(t),s=0;s<r;s++)n+=e(t[s],s,t,e)||"";return n}function xU(t,e,n,r){switch(t.type){case sU:if(t.children.length)break;case rU:case nb:return t.return=t.return||t.value;case lR:return"";case uR:return t.return=t.value+"{"+qc(t.children,r)+"}";case tb:t.value=t.props.join(",")}return ui(n=qc(t.children,r))?t.return=t.value+"{"+n+"}":""}function vU(t){var e=rb(t);return function(n,r,s,o){for(var i="",a=0;a<e;a++)i+=t[a](n,r,s,o)||"";return i}}function bU(t){return function(e){e.root||(e=e.return)&&t(e)}}var kT=function(e){var n=new WeakMap;return function(r){if(n.has(r))return n.get(r);var s=e(r);return n.set(r,s),s}};function pR(t){var e=Object.create(null);return function(n){return e[n]===void 0&&(e[n]=t(n)),e[n]}}var wU=function(e,n,r){for(var s=0,o=0;s=o,o=mi(),s===38&&o===12&&(n[r]=1),!sf(o);)Ds();return Of(e,ms)},SU=function(e,n){var r=-1,s=44;do switch(sf(s)){case 0:s===38&&mi()===12&&(n[r]=1),e[r]+=wU(ms-1,n,r);break;case 2:e[r]+=Bm(s);break;case 4:if(s===44){e[++r]=mi()===58?"&\f":"",n[r]=e[r].length;break}default:e[r]+=Gg(s)}while(s=Ds());return e},CU=function(e,n){return fR(SU(hR(e),n))},TT=new WeakMap,$U=function(e){if(!(e.type!=="rule"||!e.parent||e.length<1)){for(var n=e.value,r=e.parent,s=e.column===r.column&&e.line===r.line;r.type!=="rule";)if(r=r.parent,!r)return;if(!(e.props.length===1&&n.charCodeAt(0)!==58&&!TT.get(r))&&!s){TT.set(e,!0);for(var o=[],i=CU(n,o),a=r.props,l=0,c=0;l<i.length;l++)for(var d=0;d<a.length;d++,c++)e.props[c]=o[l]?i[l].replace(/&\f/g,a[d]):a[d]+" "+i[l]}}},kU=function(e){if(e.type==="decl"){var n=e.value;n.charCodeAt(0)===108&&n.charCodeAt(2)===98&&(e.return="",e.value="")}};function mR(t,e){switch(aU(t,e)){case 5103:return At+"print-"+t+t;case 5737:case 4201:case 3177:case 3433:case 1641:case 4457:case 2921:case 5572:case 6356:case 5844:case 3191:case 6645:case 3005:case 6391:case 5879:case 5623:case 6135:case 4599:case 4855:case 4215:case 6389:case 5109:case 5365:case 5621:case 3829:return At+t+t;case 5349:case 4246:case 4810:case 6968:case 2756:return At+t+ig+t+br+t+t;case 6828:case 4268:return At+t+br+t+t;case 6165:return At+t+br+"flex-"+t+t;case 5187:return At+t+Dt(t,/(\w+).+(:[^]+)/,At+"box-$1$2"+br+"flex-$1$2")+t;case 5443:return At+t+br+"flex-item-"+Dt(t,/flex-|-self/,"")+t;case 4675:return At+t+br+"flex-line-pack"+Dt(t,/align-content|flex-|-self/,"")+t;case 5548:return At+t+br+Dt(t,"shrink","negative")+t;case 5292:return At+t+br+Dt(t,"basis","preferred-size")+t;case 6060:return At+"box-"+Dt(t,"-grow","")+At+t+br+Dt(t,"grow","positive")+t;case 4554:return At+Dt(t,/([^-])(transform)/g,"$1"+At+"$2")+t;case 6187:return Dt(Dt(Dt(t,/(zoom-|grab)/,At+"$1"),/(image-set)/,At+"$1"),t,"")+t;case 5495:case 3959:return Dt(t,/(image-set\([^]*)/,At+"$1$`$1");case 4968:return Dt(Dt(t,/(.+:)(flex-)?(.*)/,At+"box-pack:$3"+br+"flex-pack:$3"),/s.+-b[^;]+/,"justify")+At+t+t;case 4095:case 3583:case 4068:case 2532:return Dt(t,/(.+)-inline(.+)/,At+"$1$2")+t;case 8116:case 7059:case 5753:case 5535:case 5445:case 5701:case 4933:case 4677:case 5533:case 5789:case 5021:case 4765:if(ui(t)-1-e>6)switch(ar(t,e+1)){case 109:if(ar(t,e+4)!==45)break;case 102:return Dt(t,/(.+:)(.+)-([^]+)/,"$1"+At+"$2-$3$1"+ig+(ar(t,e+3)==108?"$3":"$2-$3"))+t;case 115:return~Tx(t,"stretch")?mR(Dt(t,"stretch","fill-available"),e)+t:t}break;case 4949:if(ar(t,e+1)!==115)break;case 6444:switch(ar(t,ui(t)-3-(~Tx(t,"!important")&&10))){case 107:return Dt(t,":",":"+At)+t;case 101:return Dt(t,/(.+:)([^;!]+)(;|!.+)?/,"$1"+At+(ar(t,14)===45?"inline-":"")+"box$3$1"+At+"$2$3$1"+br+"$2box$3")+t}break;case 5936:switch(ar(t,e+11)){case 114:return At+t+br+Dt(t,/[svh]\w+-[tblr]{2}/,"tb")+t;case 108:return At+t+br+Dt(t,/[svh]\w+-[tblr]{2}/,"tb-rl")+t;case 45:return At+t+br+Dt(t,/[svh]\w+-[tblr]{2}/,"lr")+t}return At+t+br+t+t}return t}var TU=function(e,n,r,s){if(e.length>-1&&!e.return)switch(e.type){case nb:e.return=mR(e.value,e.length);break;case uR:return qc([xh(e,{value:Dt(e.value,"@","@"+At)})],s);case tb:if(e.length)return uU(e.props,function(o){switch(lU(o,/(::plac\w+|:read-\w+)/)){case":read-only":case":read-write":return qc([xh(e,{props:[Dt(o,/:(read-\w+)/,":"+ig+"$1")]})],s);case"::placeholder":return qc([xh(e,{props:[Dt(o,/:(plac\w+)/,":"+At+"input-$1")]}),xh(e,{props:[Dt(o,/:(plac\w+)/,":"+ig+"$1")]}),xh(e,{props:[Dt(o,/:(plac\w+)/,br+"input-$1")]})],s)}return""})}},IU=[TU],NU=function(e){var n=e.key;if(n==="css"){var r=document.querySelectorAll("style[data-emotion]:not([data-s])");Array.prototype.forEach.call(r,function(x){var w=x.getAttribute("data-emotion");w.indexOf(" ")!==-1&&(document.head.appendChild(x),x.setAttribute("data-s",""))})}var s=e.stylisPlugins||IU,o={},i,a=[];i=e.container||document.head,Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="'+n+' "]'),function(x){for(var w=x.getAttribute("data-emotion").split(" "),S=1;S<w.length;S++)o[w[S]]=!0;a.push(x)});var l,c=[$U,kU];{var d,f=[xU,bU(function(x){d.insert(x)})],p=vU(c.concat(s,f)),g=function(w){return qc(gU(w),p)};l=function(w,S,$,I){d=$,g(w?w+"{"+S.styles+"}":S.styles),I&&(y.inserted[S.name]=!0)}}var y={key:n,sheet:new nU({key:n,container:i,nonce:e.nonce,speedy:e.speedy,prepend:e.prepend,insertionPoint:e.insertionPoint}),nonce:e.nonce,inserted:o,registered:{},insert:l};return y.sheet.hydrate(a),y};function ag(){return ag=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)({}).hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},ag.apply(null,arguments)}var $1={exports:{}},Bt={};/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var IT;function EU(){if(IT)return Bt;IT=1;var t=typeof Symbol=="function"&&Symbol.for,e=t?Symbol.for("react.element"):60103,n=t?Symbol.for("react.portal"):60106,r=t?Symbol.for("react.fragment"):60107,s=t?Symbol.for("react.strict_mode"):60108,o=t?Symbol.for("react.profiler"):60114,i=t?Symbol.for("react.provider"):60109,a=t?Symbol.for("react.context"):60110,l=t?Symbol.for("react.async_mode"):60111,c=t?Symbol.for("react.concurrent_mode"):60111,d=t?Symbol.for("react.forward_ref"):60112,f=t?Symbol.for("react.suspense"):60113,p=t?Symbol.for("react.suspense_list"):60120,g=t?Symbol.for("react.memo"):60115,y=t?Symbol.for("react.lazy"):60116,x=t?Symbol.for("react.block"):60121,w=t?Symbol.for("react.fundamental"):60117,S=t?Symbol.for("react.responder"):60118,$=t?Symbol.for("react.scope"):60119;function I(_){if(typeof _=="object"&&_!==null){var O=_.$$typeof;switch(O){case e:switch(_=_.type,_){case l:case c:case r:case o:case s:case f:return _;default:switch(_=_&&_.$$typeof,_){case a:case d:case y:case g:case i:return _;default:return O}}case n:return O}}}function R(_){return I(_)===c}return Bt.AsyncMode=l,Bt.ConcurrentMode=c,Bt.ContextConsumer=a,Bt.ContextProvider=i,Bt.Element=e,Bt.ForwardRef=d,Bt.Fragment=r,Bt.Lazy=y,Bt.Memo=g,Bt.Portal=n,Bt.Profiler=o,Bt.StrictMode=s,Bt.Suspense=f,Bt.isAsyncMode=function(_){return R(_)||I(_)===l},Bt.isConcurrentMode=R,Bt.isContextConsumer=function(_){return I(_)===a},Bt.isContextProvider=function(_){return I(_)===i},Bt.isElement=function(_){return typeof _=="object"&&_!==null&&_.$$typeof===e},Bt.isForwardRef=function(_){return I(_)===d},Bt.isFragment=function(_){return I(_)===r},Bt.isLazy=function(_){return I(_)===y},Bt.isMemo=function(_){return I(_)===g},Bt.isPortal=function(_){return I(_)===n},Bt.isProfiler=function(_){return I(_)===o},Bt.isStrictMode=function(_){return I(_)===s},Bt.isSuspense=function(_){return I(_)===f},Bt.isValidElementType=function(_){return typeof _=="string"||typeof _=="function"||_===r||_===c||_===o||_===s||_===f||_===p||typeof _=="object"&&_!==null&&(_.$$typeof===y||_.$$typeof===g||_.$$typeof===i||_.$$typeof===a||_.$$typeof===d||_.$$typeof===w||_.$$typeof===S||_.$$typeof===$||_.$$typeof===x)},Bt.typeOf=I,Bt}var NT;function RU(){return NT||(NT=1,$1.exports=EU()),$1.exports}var k1,ET;function _U(){if(ET)return k1;ET=1;var t=RU(),e={childContextTypes:!0,contextType:!0,contextTypes:!0,defaultProps:!0,displayName:!0,getDefaultProps:!0,getDerivedStateFromError:!0,getDerivedStateFromProps:!0,mixins:!0,propTypes:!0,type:!0},n={name:!0,length:!0,prototype:!0,caller:!0,callee:!0,arguments:!0,arity:!0},r={$$typeof:!0,render:!0,defaultProps:!0,displayName:!0,propTypes:!0},s={$$typeof:!0,compare:!0,defaultProps:!0,displayName:!0,propTypes:!0,type:!0},o={};o[t.ForwardRef]=r,o[t.Memo]=s;function i(y){return t.isMemo(y)?s:o[y.$$typeof]||e}var a=Object.defineProperty,l=Object.getOwnPropertyNames,c=Object.getOwnPropertySymbols,d=Object.getOwnPropertyDescriptor,f=Object.getPrototypeOf,p=Object.prototype;function g(y,x,w){if(typeof x!="string"){if(p){var S=f(x);S&&S!==p&&g(y,S,w)}var $=l(x);c&&($=$.concat(c(x)));for(var I=i(y),R=i(x),_=0;_<$.length;++_){var O=$[_];if(!n[O]&&!(w&&w[O])&&!(R&&R[O])&&!(I&&I[O])){var F=d(x,O);try{a(y,O,F)}catch{}}}}return y}return k1=g,k1}_U();var PU=!0;function gR(t,e,n){var r="";return n.split(" ").forEach(function(s){t[s]!==void 0?e.push(t[s]+";"):s&&(r+=s+" ")}),r}var sb=function(e,n,r){var s=e.key+"-"+n.name;(r===!1||PU===!1)&&e.registered[s]===void 0&&(e.registered[s]=n.styles)},ob=function(e,n,r){sb(e,n,r);var s=e.key+"-"+n.name;if(e.inserted[n.name]===void 0){var o=n;do e.insert(n===o?"."+s:"",o,e.sheet,!0),o=o.next;while(o!==void 0)}};function AU(t){for(var e=0,n,r=0,s=t.length;s>=4;++r,s-=4)n=t.charCodeAt(r)&255|(t.charCodeAt(++r)&255)<<8|(t.charCodeAt(++r)&255)<<16|(t.charCodeAt(++r)&255)<<24,n=(n&65535)*1540483477+((n>>>16)*59797<<16),n^=n>>>24,e=(n&65535)*1540483477+((n>>>16)*59797<<16)^(e&65535)*1540483477+((e>>>16)*59797<<16);switch(s){case 3:e^=(t.charCodeAt(r+2)&255)<<16;case 2:e^=(t.charCodeAt(r+1)&255)<<8;case 1:e^=t.charCodeAt(r)&255,e=(e&65535)*1540483477+((e>>>16)*59797<<16)}return e^=e>>>13,e=(e&65535)*1540483477+((e>>>16)*59797<<16),((e^e>>>15)>>>0).toString(36)}var DU={animationIterationCount:1,aspectRatio:1,borderImageOutset:1,borderImageSlice:1,borderImageWidth:1,boxFlex:1,boxFlexGroup:1,boxOrdinalGroup:1,columnCount:1,columns:1,flex:1,flexGrow:1,flexPositive:1,flexShrink:1,flexNegative:1,flexOrder:1,gridRow:1,gridRowEnd:1,gridRowSpan:1,gridRowStart:1,gridColumn:1,gridColumnEnd:1,gridColumnSpan:1,gridColumnStart:1,msGridRow:1,msGridRowSpan:1,msGridColumn:1,msGridColumnSpan:1,fontWeight:1,lineHeight:1,opacity:1,order:1,orphans:1,scale:1,tabSize:1,widows:1,zIndex:1,zoom:1,WebkitLineClamp:1,fillOpacity:1,floodOpacity:1,stopOpacity:1,strokeDasharray:1,strokeDashoffset:1,strokeMiterlimit:1,strokeOpacity:1,strokeWidth:1},OU=/[A-Z]|^ms/g,FU=/_EMO_([^_]+?)_([^]*?)_EMO_/g,yR=function(e){return e.charCodeAt(1)===45},RT=function(e){return e!=null&&typeof e!="boolean"},T1=pR(function(t){return yR(t)?t:t.replace(OU,"-$&").toLowerCase()}),_T=function(e,n){switch(e){case"animation":case"animationName":if(typeof n=="string")return n.replace(FU,function(r,s,o){return ci={name:s,styles:o,next:ci},s})}return DU[e]!==1&&!yR(e)&&typeof n=="number"&&n!==0?n+"px":n};function of(t,e,n){if(n==null)return"";var r=n;if(r.__emotion_styles!==void 0)return r;switch(typeof n){case"boolean":return"";case"object":{var s=n;if(s.anim===1)return ci={name:s.name,styles:s.styles,next:ci},s.name;var o=n;if(o.styles!==void 0){var i=o.next;if(i!==void 0)for(;i!==void 0;)ci={name:i.name,styles:i.styles,next:ci},i=i.next;var a=o.styles+";";return a}return LU(t,e,n)}case"function":{if(t!==void 0){var l=ci,c=n(t);return ci=l,of(t,e,c)}break}}var d=n;if(e==null)return d;var f=e[d];return f!==void 0?f:d}function LU(t,e,n){var r="";if(Array.isArray(n))for(var s=0;s<n.length;s++)r+=of(t,e,n[s])+";";else for(var o in n){var i=n[o];if(typeof i!="object"){var a=i;e!=null&&e[a]!==void 0?r+=o+"{"+e[a]+"}":RT(a)&&(r+=T1(o)+":"+_T(o,a)+";")}else if(Array.isArray(i)&&typeof i[0]=="string"&&(e==null||e[i[0]]===void 0))for(var l=0;l<i.length;l++)RT(i[l])&&(r+=T1(o)+":"+_T(o,i[l])+";");else{var c=of(t,e,i);switch(o){case"animation":case"animationName":{r+=T1(o)+":"+c+";";break}default:r+=o+"{"+c+"}"}}}return r}var PT=/label:\s*([^\s;{]+)\s*(;|$)/g,ci;function Xg(t,e,n){if(t.length===1&&typeof t[0]=="object"&&t[0]!==null&&t[0].styles!==void 0)return t[0];var r=!0,s="";ci=void 0;var o=t[0];if(o==null||o.raw===void 0)r=!1,s+=of(n,e,o);else{var i=o;s+=i[0]}for(var a=1;a<t.length;a++)if(s+=of(n,e,t[a]),r){var l=o;s+=l[a]}PT.lastIndex=0;for(var c="",d;(d=PT.exec(s))!==null;)c+="-"+d[1];var f=AU(s)+c;return{name:f,styles:s,next:ci}}var zU=function(e){return e()},xR=qk.useInsertionEffect?qk.useInsertionEffect:!1,vR=xR||zU,AT=xR||J.useLayoutEffect,ib=J.createContext(typeof HTMLElement<"u"?NU({key:"css"}):null);ib.Provider;var BU=function(){return J.useContext(ib)},ab=function(e){return J.forwardRef(function(n,r){var s=J.useContext(ib);return e(n,s,r)})},rd=J.createContext({}),MU=function(e,n){if(typeof n=="function"){var r=n(e);return r}return ag({},e,n)},VU=kT(function(t){return kT(function(e){return MU(t,e)})}),WU=function(e){var n=J.useContext(rd);return e.theme!==n&&(n=VU(n)(e.theme)),J.createElement(rd.Provider,{value:n},e.children)},lb={}.hasOwnProperty,Nx="__EMOTION_TYPE_PLEASE_DO_NOT_USE__",UU=function(e,n){var r={};for(var s in n)lb.call(n,s)&&(r[s]=n[s]);return r[Nx]=e,r},jU=function(e){var n=e.cache,r=e.serialized,s=e.isStringTag;return sb(n,r,s),vR(function(){return ob(n,r,s)}),null},GU=ab(function(t,e,n){var r=t.css;typeof r=="string"&&e.registered[r]!==void 0&&(r=e.registered[r]);var s=t[Nx],o=[r],i="";typeof t.className=="string"?i=gR(e.registered,o,t.className):t.className!=null&&(i=t.className+" ");var a=Xg(o,void 0,J.useContext(rd));i+=e.key+"-"+a.name;var l={};for(var c in t)lb.call(t,c)&&c!=="css"&&c!==Nx&&(l[c]=t[c]);return l.className=i,n&&(l.ref=n),J.createElement(J.Fragment,null,J.createElement(jU,{cache:e,serialized:a,isStringTag:typeof s=="string"}),J.createElement(s,l))}),HU=GU,DT=function(e,n){var r=arguments;if(n==null||!lb.call(n,"css"))return J.createElement.apply(void 0,r);var s=r.length,o=new Array(s);o[0]=HU,o[1]=UU(e,n);for(var i=2;i<s;i++)o[i]=r[i];return J.createElement.apply(null,o)};(function(t){var e;e||(e=t.JSX||(t.JSX={}))})(DT||(DT={}));var qg=ab(function(t,e){var n=t.styles,r=Xg([n],void 0,J.useContext(rd)),s=J.useRef();return AT(function(){var o=e.key+"-global",i=new e.sheet.constructor({key:o,nonce:e.sheet.nonce,container:e.sheet.container,speedy:e.sheet.isSpeedy}),a=!1,l=document.querySelector('style[data-emotion="'+o+" "+r.name+'"]');return e.sheet.tags.length&&(i.before=e.sheet.tags[0]),l!==null&&(a=!0,l.setAttribute("data-emotion",o),i.hydrate([l])),s.current=[i,a],function(){i.flush()}},[e]),AT(function(){var o=s.current,i=o[0],a=o[1];if(a){o[1]=!1;return}if(r.next!==void 0&&ob(e,r.next,!0),i.tags.length){var l=i.tags[i.tags.length-1].nextElementSibling;i.before=l,i.flush()}e.insert("",r,i,!1)},[e,r.name]),null});function KU(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];return Xg(e)}function Ff(){var t=KU.apply(void 0,arguments),e="animation-"+t.name;return{name:e,styles:"@keyframes "+e+"{"+t.styles+"}",anim:1,toString:function(){return"_EMO_"+this.name+"_"+this.styles+"_EMO_"}}}const ub=J.createContext({});ub.displayName="ColorModeContext";function cb(){const t=J.useContext(ub);if(t===void 0)throw new Error("useColorMode must be used within a ColorModeProvider");return t}const fm={light:"chakra-ui-light",dark:"chakra-ui-dark"};function XU(t={}){const{preventTransition:e=!0,nonce:n}=t,r={setDataset:s=>{const o=e?r.preventTransition():void 0;document.documentElement.dataset.theme=s,document.documentElement.style.colorScheme=s,o==null||o()},setClassName(s){document.body.classList.add(s?fm.dark:fm.light),document.body.classList.remove(s?fm.light:fm.dark)},query(){return window.matchMedia("(prefers-color-scheme: dark)")},getSystemTheme(s){return r.query().matches??s==="dark"?"dark":"light"},addListener(s){const o=r.query(),i=a=>{s(a.matches?"dark":"light")};return typeof o.addListener=="function"?o.addListener(i):o.addEventListener("change",i),()=>{typeof o.removeListener=="function"?o.removeListener(i):o.removeEventListener("change",i)}},preventTransition(){const s=document.createElement("style");return s.appendChild(document.createTextNode("*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")),n!==void 0&&(s.nonce=n),document.head.appendChild(s),()=>{window.getComputedStyle(document.body),requestAnimationFrame(()=>{requestAnimationFrame(()=>{document.head.removeChild(s)})})}}};return r}const qU="chakra-ui-color-mode";function YU(t){return{ssr:!1,type:"localStorage",get(e){if(!(globalThis!=null&&globalThis.document))return e;let n;try{n=localStorage.getItem(t)||e}catch{}return n||e},set(e){try{localStorage.setItem(t,e)}catch{}}}}const QU=YU(qU),OT=()=>{},ZU=yL()?J.useLayoutEffect:J.useEffect;function FT(t,e){return t.type==="cookie"&&t.ssr?t.get(e):e}const bR=function(e){const{value:n,children:r,options:{useSystemColorMode:s,initialColorMode:o,disableTransitionOnChange:i}={},colorModeManager:a=QU}=e,l=BU(),c=o==="dark"?"dark":"light",[d,f]=J.useState(()=>FT(a,c)),[p,g]=J.useState(()=>FT(a)),{getSystemTheme:y,setClassName:x,setDataset:w,addListener:S}=J.useMemo(()=>XU({preventTransition:i,nonce:l==null?void 0:l.nonce}),[i,l==null?void 0:l.nonce]),$=o==="system"&&!d?p:d,I=J.useCallback(O=>{const F=O==="system"?y():O;f(F),x(F==="dark"),w(F),a.set(F)},[a,y,x,w]);ZU(()=>{o==="system"&&g(y())},[]),J.useEffect(()=>{const O=a.get();if(O){I(O);return}if(o==="system"){I("system");return}I(c)},[a,c,o,I]);const R=J.useCallback(()=>{I($==="dark"?"light":"dark")},[$,I]);J.useEffect(()=>{if(s)return S(I)},[s,S,I]);const _=J.useMemo(()=>({colorMode:n??$,toggleColorMode:n?OT:R,setColorMode:n?OT:I,forced:n!==void 0}),[$,R,I,n]);return K.jsx(ub.Provider,{value:_,children:r})};bR.displayName="ColorModeProvider";const wR=String.raw,SR=wR`
  :root,
  :host {
    --chakra-vh: 100vh;
  }

  @supports (height: -webkit-fill-available) {
    :root,
    :host {
      --chakra-vh: -webkit-fill-available;
    }
  }

  @supports (height: -moz-fill-available) {
    :root,
    :host {
      --chakra-vh: -moz-fill-available;
    }
  }

  @supports (height: 100dvh) {
    :root,
    :host {
      --chakra-vh: 100dvh;
    }
  }
`,JU=()=>K.jsx(qg,{styles:SR}),e8=({scope:t=""})=>K.jsx(qg,{styles:wR`
      html {
        line-height: 1.5;
        -webkit-text-size-adjust: 100%;
        font-family: system-ui, sans-serif;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        -moz-osx-font-smoothing: grayscale;
        touch-action: manipulation;
      }

      body {
        position: relative;
        min-height: 100%;
        margin: 0;
        font-feature-settings: "kern";
      }

      ${t} :where(*, *::before, *::after) {
        border-width: 0;
        border-style: solid;
        box-sizing: border-box;
        word-wrap: break-word;
      }

      main {
        display: block;
      }

      ${t} hr {
        border-top-width: 1px;
        box-sizing: content-box;
        height: 0;
        overflow: visible;
      }

      ${t} :where(pre, code, kbd,samp) {
        font-family: SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: 1em;
      }

      ${t} a {
        background-color: transparent;
        color: inherit;
        text-decoration: inherit;
      }

      ${t} abbr[title] {
        border-bottom: none;
        text-decoration: underline;
        -webkit-text-decoration: underline dotted;
        text-decoration: underline dotted;
      }

      ${t} :where(b, strong) {
        font-weight: bold;
      }

      ${t} small {
        font-size: 80%;
      }

      ${t} :where(sub,sup) {
        font-size: 75%;
        line-height: 0;
        position: relative;
        vertical-align: baseline;
      }

      ${t} sub {
        bottom: -0.25em;
      }

      ${t} sup {
        top: -0.5em;
      }

      ${t} img {
        border-style: none;
      }

      ${t} :where(button, input, optgroup, select, textarea) {
        font-family: inherit;
        font-size: 100%;
        line-height: 1.15;
        margin: 0;
      }

      ${t} :where(button, input) {
        overflow: visible;
      }

      ${t} :where(button, select) {
        text-transform: none;
      }

      ${t} :where(
          button::-moz-focus-inner,
          [type="button"]::-moz-focus-inner,
          [type="reset"]::-moz-focus-inner,
          [type="submit"]::-moz-focus-inner
        ) {
        border-style: none;
        padding: 0;
      }

      ${t} fieldset {
        padding: 0.35em 0.75em 0.625em;
      }

      ${t} legend {
        box-sizing: border-box;
        color: inherit;
        display: table;
        max-width: 100%;
        padding: 0;
        white-space: normal;
      }

      ${t} progress {
        vertical-align: baseline;
      }

      ${t} textarea {
        overflow: auto;
      }

      ${t} :where([type="checkbox"], [type="radio"]) {
        box-sizing: border-box;
        padding: 0;
      }

      ${t} input[type="number"]::-webkit-inner-spin-button,
      ${t} input[type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none !important;
      }

      ${t} input[type="number"] {
        -moz-appearance: textfield;
      }

      ${t} input[type="search"] {
        -webkit-appearance: textfield;
        outline-offset: -2px;
      }

      ${t} input[type="search"]::-webkit-search-decoration {
        -webkit-appearance: none !important;
      }

      ${t} ::-webkit-file-upload-button {
        -webkit-appearance: button;
        font: inherit;
      }

      ${t} details {
        display: block;
      }

      ${t} summary {
        display: list-item;
      }

      template {
        display: none;
      }

      [hidden] {
        display: none !important;
      }

      ${t} :where(
          blockquote,
          dl,
          dd,
          h1,
          h2,
          h3,
          h4,
          h5,
          h6,
          hr,
          figure,
          p,
          pre
        ) {
        margin: 0;
      }

      ${t} button {
        background: transparent;
        padding: 0;
      }

      ${t} fieldset {
        margin: 0;
        padding: 0;
      }

      ${t} :where(ol, ul) {
        margin: 0;
        padding: 0;
      }

      ${t} textarea {
        resize: vertical;
      }

      ${t} :where(button, [role="button"]) {
        cursor: pointer;
      }

      ${t} button::-moz-focus-inner {
        border: 0 !important;
      }

      ${t} table {
        border-collapse: collapse;
      }

      ${t} :where(h1, h2, h3, h4, h5, h6) {
        font-size: inherit;
        font-weight: inherit;
      }

      ${t} :where(button, input, optgroup, select, textarea) {
        padding: 0;
        line-height: inherit;
        color: inherit;
      }

      ${t} :where(img, svg, video, canvas, audio, iframe, embed, object) {
        display: block;
      }

      ${t} :where(img, video) {
        max-width: 100%;
        height: auto;
      }

      [data-js-focus-visible]
        :focus:not([data-focus-visible-added]):not(
          [data-focus-visible-disabled]
        ) {
        outline: none;
        box-shadow: none;
      }

      ${t} select::-ms-expand {
        display: none;
      }

      ${SR}
    `});function t8(t){const{cssVarsRoot:e,theme:n,children:r}=t,s=J.useMemo(()=>Vz(n),[n]);return K.jsxs(WU,{theme:s,children:[K.jsx(n8,{root:e}),r]})}function n8({root:t=":host, :root"}){const e=[t,"[data-theme]"].join(",");return K.jsx(qg,{styles:n=>({[e]:n.__cssVars})})}Kr({name:"StylesContext",errorMessage:"useStyles: `styles` is undefined. Seems you forgot to wrap the components in `<StylesProvider />` "});function r8(t){return Kr({name:`${t}StylesContext`,errorMessage:`useStyles: "styles" is undefined. Seems you forgot to wrap the components in "<${t} />" `})}function s8(){const{colorMode:t}=cb();return K.jsx(qg,{styles:e=>{const n=VE(e,"styles.global"),r=so(n,{theme:e,colorMode:t});return r?HE(r)(e):void 0}})}const[o8,i8]=Kr({strict:!1,name:"PortalManagerContext"});function CR(t){const{children:e,zIndex:n}=t;return K.jsx(o8,{value:{zIndex:n},children:e})}CR.displayName="PortalManager";const $R=J.createContext({getDocument(){return document},getWindow(){return window}});$R.displayName="EnvironmentContext";function kR(t){const{children:e,environment:n,disabled:r}=t,s=J.useRef(null),o=J.useMemo(()=>n||{getDocument:()=>{var a;return((a=s.current)==null?void 0:a.ownerDocument)??document},getWindow:()=>{var a;return((a=s.current)==null?void 0:a.ownerDocument.defaultView)??window}},[n]),i=!r||!n;return K.jsxs($R.Provider,{value:o,children:[e,i&&K.jsx("span",{id:"__chakra_env",hidden:!0,ref:s})]})}kR.displayName="EnvironmentProvider";const a8=t=>{const{children:e,colorModeManager:n,portalZIndex:r,resetScope:s,resetCSS:o=!0,theme:i={},environment:a,cssVarsRoot:l,disableEnvironment:c,disableGlobalStyle:d}=t,f=K.jsx(kR,{environment:a,disabled:c,children:e});return K.jsx(t8,{theme:i,cssVarsRoot:l,children:K.jsxs(bR,{colorModeManager:n,options:i.config,children:[o?K.jsx(e8,{scope:s}):K.jsx(JU,{}),!d&&K.jsx(s8,{}),r?K.jsx(CR,{zIndex:r,children:f}):f]})})},db=J.createContext({});function hb(t){const e=J.useRef(null);return e.current===null&&(e.current=t()),e.current}const fb=typeof window<"u",TR=fb?J.useLayoutEffect:J.useEffect,Lf=J.createContext(null),pb=J.createContext({transformPagePoint:t=>t,isStatic:!1,reducedMotion:"never"});class l8 extends J.Component{getSnapshotBeforeUpdate(e){const n=this.props.childRef.current;if(n&&e.isPresent&&!this.props.isPresent){const r=n.offsetParent,s=r instanceof HTMLElement&&r.offsetWidth||0,o=this.props.sizeRef.current;o.height=n.offsetHeight||0,o.width=n.offsetWidth||0,o.top=n.offsetTop,o.left=n.offsetLeft,o.right=s-o.width-o.left}return null}componentDidUpdate(){}render(){return this.props.children}}function u8({children:t,isPresent:e,anchorX:n}){const r=J.useId(),s=J.useRef(null),o=J.useRef({width:0,height:0,top:0,left:0,right:0}),{nonce:i}=J.useContext(pb);return J.useInsertionEffect(()=>{const{width:a,height:l,top:c,left:d,right:f}=o.current;if(e||!s.current||!a||!l)return;const p=n==="left"?`left: ${d}`:`right: ${f}`;s.current.dataset.motionPopId=r;const g=document.createElement("style");return i&&(g.nonce=i),document.head.appendChild(g),g.sheet&&g.sheet.insertRule(`
          [data-motion-pop-id="${r}"] {
            position: absolute !important;
            width: ${a}px !important;
            height: ${l}px !important;
            ${p}px !important;
            top: ${c}px !important;
          }
        `),()=>{document.head.removeChild(g)}},[e]),K.jsx(l8,{isPresent:e,childRef:s,sizeRef:o,children:J.cloneElement(t,{ref:s})})}const c8=({children:t,initial:e,isPresent:n,onExitComplete:r,custom:s,presenceAffectsLayout:o,mode:i,anchorX:a})=>{const l=hb(d8),c=J.useId();let d=!0,f=J.useMemo(()=>(d=!1,{id:c,initial:e,isPresent:n,custom:s,onExitComplete:p=>{l.set(p,!0);for(const g of l.values())if(!g)return;r&&r()},register:p=>(l.set(p,!1),()=>l.delete(p))}),[n,l,r]);return o&&d&&(f={...f}),J.useMemo(()=>{l.forEach((p,g)=>l.set(g,!1))},[n]),J.useEffect(()=>{!n&&!l.size&&r&&r()},[n]),i==="popLayout"&&(t=K.jsx(u8,{isPresent:n,anchorX:a,children:t})),K.jsx(Lf.Provider,{value:f,children:t})};function d8(){return new Map}function IR(t=!0){const e=J.useContext(Lf);if(e===null)return[!0,null];const{isPresent:n,onExitComplete:r,register:s}=e,o=J.useId();J.useEffect(()=>{if(t)return s(o)},[t]);const i=J.useCallback(()=>t&&r&&r(o),[o,r,t]);return!n&&r?[!1,i]:[!0]}function h8(){return f8(J.useContext(Lf))}function f8(t){return t===null?!0:t.isPresent}const pm=t=>t.key||"";function LT(t){const e=[];return J.Children.forEach(t,n=>{J.isValidElement(n)&&e.push(n)}),e}const mb=({children:t,custom:e,initial:n=!0,onExitComplete:r,presenceAffectsLayout:s=!0,mode:o="sync",propagate:i=!1,anchorX:a="left"})=>{const[l,c]=IR(i),d=J.useMemo(()=>LT(t),[t]),f=i&&!l?[]:d.map(pm),p=J.useRef(!0),g=J.useRef(d),y=hb(()=>new Map),[x,w]=J.useState(d),[S,$]=J.useState(d);TR(()=>{p.current=!1,g.current=d;for(let _=0;_<S.length;_++){const O=pm(S[_]);f.includes(O)?y.delete(O):y.get(O)!==!0&&y.set(O,!1)}},[S,f.length,f.join("-")]);const I=[];if(d!==x){let _=[...d];for(let O=0;O<S.length;O++){const F=S[O],B=pm(F);f.includes(B)||(_.splice(O,0,F),I.push(F))}return o==="wait"&&I.length&&(_=I),$(LT(_)),w(d),null}const{forceRender:R}=J.useContext(db);return K.jsx(K.Fragment,{children:S.map(_=>{const O=pm(_),F=i&&!l?!1:d===S||f.includes(O),B=()=>{if(y.has(O))y.set(O,!0);else return;let M=!0;y.forEach(V=>{V||(M=!1)}),M&&(R==null||R(),$(g.current),i&&(c==null||c()),r&&r())};return K.jsx(c8,{isPresent:F,initial:!p.current||n?void 0:!1,custom:e,presenceAffectsLayout:s,mode:o,onExitComplete:F?void 0:B,anchorX:a,children:_},O)})})};function gb(t,e){t.indexOf(e)===-1&&t.push(e)}function yb(t,e){const n=t.indexOf(e);n>-1&&t.splice(n,1)}const ca=(t,e,n)=>n>e?e:n<t?t:n;let xb=()=>{};const da={},NR=t=>/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t),ER=t=>/^0[^.\s]+$/u.test(t);function vb(t){let e;return()=>(e===void 0&&(e=t()),e)}const ao=t=>t,p8=(t,e)=>n=>e(t(n)),zf=(...t)=>t.reduce(p8),af=(t,e,n)=>{const r=e-t;return r===0?1:(n-t)/r};class bb{constructor(){this.subscriptions=[]}add(e){return gb(this.subscriptions,e),()=>yb(this.subscriptions,e)}notify(e,n,r){const s=this.subscriptions.length;if(s)if(s===1)this.subscriptions[0](e,n,r);else for(let o=0;o<s;o++){const i=this.subscriptions[o];i&&i(e,n,r)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}const gi=t=>t*1e3,yi=t=>t/1e3;function RR(t,e){return e?t*(1e3/e):0}const _R=(t,e,n)=>(((1-3*n+3*e)*t+(3*n-6*e))*t+3*e)*t,m8=1e-7,g8=12;function y8(t,e,n,r,s){let o,i,a=0;do i=e+(n-e)/2,o=_R(i,r,s)-t,o>0?n=i:e=i;while(Math.abs(o)>m8&&++a<g8);return i}function Bf(t,e,n,r){if(t===e&&n===r)return ao;const s=o=>y8(o,0,1,t,n);return o=>o===0||o===1?o:_R(s(o),e,r)}const PR=t=>e=>e<=.5?t(2*e)/2:(2-t(2*(1-e)))/2,AR=t=>e=>1-t(1-e),DR=Bf(.33,1.53,.69,.99),wb=AR(DR),OR=PR(wb),FR=t=>(t*=2)<1?.5*wb(t):.5*(2-Math.pow(2,-10*(t-1))),Sb=t=>1-Math.sin(Math.acos(t)),LR=AR(Sb),zR=PR(Sb),x8=Bf(.42,0,1,1),v8=Bf(0,0,.58,1),BR=Bf(.42,0,.58,1),b8=t=>Array.isArray(t)&&typeof t[0]!="number",MR=t=>Array.isArray(t)&&typeof t[0]=="number",w8={linear:ao,easeIn:x8,easeInOut:BR,easeOut:v8,circIn:Sb,circInOut:zR,circOut:LR,backIn:wb,backInOut:OR,backOut:DR,anticipate:FR},S8=t=>typeof t=="string",zT=t=>{if(MR(t)){xb(t.length===4);const[e,n,r,s]=t;return Bf(e,n,r,s)}else if(S8(t))return w8[t];return t},mm=["setup","read","resolveKeyframes","preUpdate","update","preRender","render","postRender"],BT={value:null};function C8(t,e){let n=new Set,r=new Set,s=!1,o=!1;const i=new WeakSet;let a={delta:0,timestamp:0,isProcessing:!1},l=0;function c(f){i.has(f)&&(d.schedule(f),t()),l++,f(a)}const d={schedule:(f,p=!1,g=!1)=>{const x=g&&s?n:r;return p&&i.add(f),x.has(f)||x.add(f),f},cancel:f=>{r.delete(f),i.delete(f)},process:f=>{if(a=f,s){o=!0;return}s=!0,[n,r]=[r,n],n.forEach(c),e&&BT.value&&BT.value.frameloop[e].push(l),l=0,n.clear(),s=!1,o&&(o=!1,d.process(f))}};return d}const $8=40;function VR(t,e){let n=!1,r=!0;const s={delta:0,timestamp:0,isProcessing:!1},o=()=>n=!0,i=mm.reduce((I,R)=>(I[R]=C8(o,e?R:void 0),I),{}),{setup:a,read:l,resolveKeyframes:c,preUpdate:d,update:f,preRender:p,render:g,postRender:y}=i,x=()=>{const I=da.useManualTiming?s.timestamp:performance.now();n=!1,da.useManualTiming||(s.delta=r?1e3/60:Math.max(Math.min(I-s.timestamp,$8),1)),s.timestamp=I,s.isProcessing=!0,a.process(s),l.process(s),c.process(s),d.process(s),f.process(s),p.process(s),g.process(s),y.process(s),s.isProcessing=!1,n&&e&&(r=!1,t(x))},w=()=>{n=!0,r=!0,s.isProcessing||t(x)};return{schedule:mm.reduce((I,R)=>{const _=i[R];return I[R]=(O,F=!1,B=!1)=>(n||w(),_.schedule(O,F,B)),I},{}),cancel:I=>{for(let R=0;R<mm.length;R++)i[mm[R]].cancel(I)},state:s,steps:i}}const{schedule:mn,cancel:ml,state:ir,steps:I1}=VR(typeof requestAnimationFrame<"u"?requestAnimationFrame:ao,!0);let Vm;function k8(){Vm=void 0}const ps={now:()=>(Vm===void 0&&ps.set(ir.isProcessing||da.useManualTiming?ir.timestamp:performance.now()),Vm),set:t=>{Vm=t,queueMicrotask(k8)}},WR=t=>e=>typeof e=="string"&&e.startsWith(t),Cb=WR("--"),T8=WR("var(--"),$b=t=>T8(t)?I8.test(t.split("/*")[0].trim()):!1,I8=/var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,yd={test:t=>typeof t=="number",parse:parseFloat,transform:t=>t},lf={...yd,transform:t=>ca(0,1,t)},gm={...yd,default:1},Gh=t=>Math.round(t*1e5)/1e5,kb=/-?(?:\d+(?:\.\d+)?|\.\d+)/gu;function N8(t){return t==null}const E8=/^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,Tb=(t,e)=>n=>!!(typeof n=="string"&&E8.test(n)&&n.startsWith(t)||e&&!N8(n)&&Object.prototype.hasOwnProperty.call(n,e)),UR=(t,e,n)=>r=>{if(typeof r!="string")return r;const[s,o,i,a]=r.match(kb);return{[t]:parseFloat(s),[e]:parseFloat(o),[n]:parseFloat(i),alpha:a!==void 0?parseFloat(a):1}},R8=t=>ca(0,255,t),N1={...yd,transform:t=>Math.round(R8(t))},yu={test:Tb("rgb","red"),parse:UR("red","green","blue"),transform:({red:t,green:e,blue:n,alpha:r=1})=>"rgba("+N1.transform(t)+", "+N1.transform(e)+", "+N1.transform(n)+", "+Gh(lf.transform(r))+")"};function _8(t){let e="",n="",r="",s="";return t.length>5?(e=t.substring(1,3),n=t.substring(3,5),r=t.substring(5,7),s=t.substring(7,9)):(e=t.substring(1,2),n=t.substring(2,3),r=t.substring(3,4),s=t.substring(4,5),e+=e,n+=n,r+=r,s+=s),{red:parseInt(e,16),green:parseInt(n,16),blue:parseInt(r,16),alpha:s?parseInt(s,16)/255:1}}const Ex={test:Tb("#"),parse:_8,transform:yu.transform},Mf=t=>({test:e=>typeof e=="string"&&e.endsWith(t)&&e.split(" ").length===1,parse:parseFloat,transform:e=>`${e}${t}`}),sl=Mf("deg"),xi=Mf("%"),rt=Mf("px"),P8=Mf("vh"),A8=Mf("vw"),MT={...xi,parse:t=>xi.parse(t)/100,transform:t=>xi.transform(t*100)},Bc={test:Tb("hsl","hue"),parse:UR("hue","saturation","lightness"),transform:({hue:t,saturation:e,lightness:n,alpha:r=1})=>"hsla("+Math.round(t)+", "+xi.transform(Gh(e))+", "+xi.transform(Gh(n))+", "+Gh(lf.transform(r))+")"},wr={test:t=>yu.test(t)||Ex.test(t)||Bc.test(t),parse:t=>yu.test(t)?yu.parse(t):Bc.test(t)?Bc.parse(t):Ex.parse(t),transform:t=>typeof t=="string"?t:t.hasOwnProperty("red")?yu.transform(t):Bc.transform(t)},D8=/(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;function O8(t){var e,n;return isNaN(t)&&typeof t=="string"&&(((e=t.match(kb))==null?void 0:e.length)||0)+(((n=t.match(D8))==null?void 0:n.length)||0)>0}const jR="number",GR="color",F8="var",L8="var(",VT="${}",z8=/var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;function uf(t){const e=t.toString(),n=[],r={color:[],number:[],var:[]},s=[];let o=0;const a=e.replace(z8,l=>(wr.test(l)?(r.color.push(o),s.push(GR),n.push(wr.parse(l))):l.startsWith(L8)?(r.var.push(o),s.push(F8),n.push(l)):(r.number.push(o),s.push(jR),n.push(parseFloat(l))),++o,VT)).split(VT);return{values:n,split:a,indexes:r,types:s}}function HR(t){return uf(t).values}function KR(t){const{split:e,types:n}=uf(t),r=e.length;return s=>{let o="";for(let i=0;i<r;i++)if(o+=e[i],s[i]!==void 0){const a=n[i];a===jR?o+=Gh(s[i]):a===GR?o+=wr.transform(s[i]):o+=s[i]}return o}}const B8=t=>typeof t=="number"?0:t;function M8(t){const e=HR(t);return KR(t)(e.map(B8))}const gl={test:O8,parse:HR,createTransformer:KR,getAnimatableNone:M8};function E1(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+(e-t)*6*n:n<1/2?e:n<2/3?t+(e-t)*(2/3-n)*6:t}function V8({hue:t,saturation:e,lightness:n,alpha:r}){t/=360,e/=100,n/=100;let s=0,o=0,i=0;if(!e)s=o=i=n;else{const a=n<.5?n*(1+e):n+e-n*e,l=2*n-a;s=E1(l,a,t+1/3),o=E1(l,a,t),i=E1(l,a,t-1/3)}return{red:Math.round(s*255),green:Math.round(o*255),blue:Math.round(i*255),alpha:r}}function lg(t,e){return n=>n>0?e:t}const pn=(t,e,n)=>t+(e-t)*n,R1=(t,e,n)=>{const r=t*t,s=n*(e*e-r)+r;return s<0?0:Math.sqrt(s)},W8=[Ex,yu,Bc],U8=t=>W8.find(e=>e.test(t));function WT(t){const e=U8(t);if(!e)return!1;let n=e.parse(t);return e===Bc&&(n=V8(n)),n}const UT=(t,e)=>{const n=WT(t),r=WT(e);if(!n||!r)return lg(t,e);const s={...n};return o=>(s.red=R1(n.red,r.red,o),s.green=R1(n.green,r.green,o),s.blue=R1(n.blue,r.blue,o),s.alpha=pn(n.alpha,r.alpha,o),yu.transform(s))},Rx=new Set(["none","hidden"]);function j8(t,e){return Rx.has(t)?n=>n<=0?t:e:n=>n>=1?e:t}function G8(t,e){return n=>pn(t,e,n)}function Ib(t){return typeof t=="number"?G8:typeof t=="string"?$b(t)?lg:wr.test(t)?UT:X8:Array.isArray(t)?XR:typeof t=="object"?wr.test(t)?UT:H8:lg}function XR(t,e){const n=[...t],r=n.length,s=t.map((o,i)=>Ib(o)(o,e[i]));return o=>{for(let i=0;i<r;i++)n[i]=s[i](o);return n}}function H8(t,e){const n={...t,...e},r={};for(const s in n)t[s]!==void 0&&e[s]!==void 0&&(r[s]=Ib(t[s])(t[s],e[s]));return s=>{for(const o in r)n[o]=r[o](s);return n}}function K8(t,e){const n=[],r={color:0,var:0,number:0};for(let s=0;s<e.values.length;s++){const o=e.types[s],i=t.indexes[o][r[o]],a=t.values[i]??0;n[s]=a,r[o]++}return n}const X8=(t,e)=>{const n=gl.createTransformer(e),r=uf(t),s=uf(e);return r.indexes.var.length===s.indexes.var.length&&r.indexes.color.length===s.indexes.color.length&&r.indexes.number.length>=s.indexes.number.length?Rx.has(t)&&!s.values.length||Rx.has(e)&&!r.values.length?j8(t,e):zf(XR(K8(r,s),s.values),n):lg(t,e)};function qR(t,e,n){return typeof t=="number"&&typeof e=="number"&&typeof n=="number"?pn(t,e,n):Ib(t)(t,e)}const q8=t=>{const e=({timestamp:n})=>t(n);return{start:()=>mn.update(e,!0),stop:()=>ml(e),now:()=>ir.isProcessing?ir.timestamp:ps.now()}},YR=(t,e,n=10)=>{let r="";const s=Math.max(Math.round(e/n),2);for(let o=0;o<s;o++)r+=t(o/(s-1))+", ";return`linear(${r.substring(0,r.length-2)})`},ug=2e4;function Nb(t){let e=0;const n=50;let r=t.next(e);for(;!r.done&&e<ug;)e+=n,r=t.next(e);return e>=ug?1/0:e}function Y8(t,e=100,n){const r=n({...t,keyframes:[0,e]}),s=Math.min(Nb(r),ug);return{type:"keyframes",ease:o=>r.next(s*o).value/e,duration:yi(s)}}const Q8=5;function QR(t,e,n){const r=Math.max(e-Q8,0);return RR(n-t(r),e-r)}const vn={stiffness:100,damping:10,mass:1,velocity:0,duration:800,bounce:.3,visualDuration:.3,restSpeed:{granular:.01,default:2},restDelta:{granular:.005,default:.5},minDuration:.01,maxDuration:10,minDamping:.05,maxDamping:1},jT=.001;function Z8({duration:t=vn.duration,bounce:e=vn.bounce,velocity:n=vn.velocity,mass:r=vn.mass}){let s,o,i=1-e;i=ca(vn.minDamping,vn.maxDamping,i),t=ca(vn.minDuration,vn.maxDuration,yi(t)),i<1?(s=c=>{const d=c*i,f=d*t,p=d-n,g=_x(c,i),y=Math.exp(-f);return jT-p/g*y},o=c=>{const f=c*i*t,p=f*n+n,g=Math.pow(i,2)*Math.pow(c,2)*t,y=Math.exp(-f),x=_x(Math.pow(c,2),i);return(-s(c)+jT>0?-1:1)*((p-g)*y)/x}):(s=c=>{const d=Math.exp(-c*t),f=(c-n)*t+1;return-.001+d*f},o=c=>{const d=Math.exp(-c*t),f=(n-c)*(t*t);return d*f});const a=5/t,l=ej(s,o,a);if(t=gi(t),isNaN(l))return{stiffness:vn.stiffness,damping:vn.damping,duration:t};{const c=Math.pow(l,2)*r;return{stiffness:c,damping:i*2*Math.sqrt(r*c),duration:t}}}const J8=12;function ej(t,e,n){let r=n;for(let s=1;s<J8;s++)r=r-t(r)/e(r);return r}function _x(t,e){return t*Math.sqrt(1-e*e)}const tj=["duration","bounce"],nj=["stiffness","damping","mass"];function GT(t,e){return e.some(n=>t[n]!==void 0)}function rj(t){let e={velocity:vn.velocity,stiffness:vn.stiffness,damping:vn.damping,mass:vn.mass,isResolvedFromDuration:!1,...t};if(!GT(t,nj)&&GT(t,tj))if(t.visualDuration){const n=t.visualDuration,r=2*Math.PI/(n*1.2),s=r*r,o=2*ca(.05,1,1-(t.bounce||0))*Math.sqrt(s);e={...e,mass:vn.mass,stiffness:s,damping:o}}else{const n=Z8(t);e={...e,...n,mass:vn.mass},e.isResolvedFromDuration=!0}return e}function cg(t=vn.visualDuration,e=vn.bounce){const n=typeof t!="object"?{visualDuration:t,keyframes:[0,1],bounce:e}:t;let{restSpeed:r,restDelta:s}=n;const o=n.keyframes[0],i=n.keyframes[n.keyframes.length-1],a={done:!1,value:o},{stiffness:l,damping:c,mass:d,duration:f,velocity:p,isResolvedFromDuration:g}=rj({...n,velocity:-yi(n.velocity||0)}),y=p||0,x=c/(2*Math.sqrt(l*d)),w=i-o,S=yi(Math.sqrt(l/d)),$=Math.abs(w)<5;r||(r=$?vn.restSpeed.granular:vn.restSpeed.default),s||(s=$?vn.restDelta.granular:vn.restDelta.default);let I;if(x<1){const _=_x(S,x);I=O=>{const F=Math.exp(-x*S*O);return i-F*((y+x*S*w)/_*Math.sin(_*O)+w*Math.cos(_*O))}}else if(x===1)I=_=>i-Math.exp(-S*_)*(w+(y+S*w)*_);else{const _=S*Math.sqrt(x*x-1);I=O=>{const F=Math.exp(-x*S*O),B=Math.min(_*O,300);return i-F*((y+x*S*w)*Math.sinh(B)+_*w*Math.cosh(B))/_}}const R={calculatedDuration:g&&f||null,next:_=>{const O=I(_);if(g)a.done=_>=f;else{let F=_===0?y:0;x<1&&(F=_===0?gi(y):QR(I,_,O));const B=Math.abs(F)<=r,M=Math.abs(i-O)<=s;a.done=B&&M}return a.value=a.done?i:O,a},toString:()=>{const _=Math.min(Nb(R),ug),O=YR(F=>R.next(_*F).value,_,30);return _+"ms "+O},toTransition:()=>{}};return R}cg.applyToOptions=t=>{const e=Y8(t,100,cg);return t.ease=e.ease,t.duration=gi(e.duration),t.type="keyframes",t};function Px({keyframes:t,velocity:e=0,power:n=.8,timeConstant:r=325,bounceDamping:s=10,bounceStiffness:o=500,modifyTarget:i,min:a,max:l,restDelta:c=.5,restSpeed:d}){const f=t[0],p={done:!1,value:f},g=B=>a!==void 0&&B<a||l!==void 0&&B>l,y=B=>a===void 0?l:l===void 0||Math.abs(a-B)<Math.abs(l-B)?a:l;let x=n*e;const w=f+x,S=i===void 0?w:i(w);S!==w&&(x=S-f);const $=B=>-x*Math.exp(-B/r),I=B=>S+$(B),R=B=>{const M=$(B),V=I(B);p.done=Math.abs(M)<=c,p.value=p.done?S:V};let _,O;const F=B=>{g(p.value)&&(_=B,O=cg({keyframes:[p.value,y(p.value)],velocity:QR(I,B,p.value),damping:s,stiffness:o,restDelta:c,restSpeed:d}))};return F(0),{calculatedDuration:null,next:B=>{let M=!1;return!O&&_===void 0&&(M=!0,R(B),F(B)),_!==void 0&&B>=_?O.next(B-_):(!M&&R(B),p)}}}function sj(t,e,n){const r=[],s=n||da.mix||qR,o=t.length-1;for(let i=0;i<o;i++){let a=s(t[i],t[i+1]);if(e){const l=Array.isArray(e)?e[i]||ao:e;a=zf(l,a)}r.push(a)}return r}function oj(t,e,{clamp:n=!0,ease:r,mixer:s}={}){const o=t.length;if(xb(o===e.length),o===1)return()=>e[0];if(o===2&&e[0]===e[1])return()=>e[1];const i=t[0]===t[1];t[0]>t[o-1]&&(t=[...t].reverse(),e=[...e].reverse());const a=sj(e,r,s),l=a.length,c=d=>{if(i&&d<t[0])return e[0];let f=0;if(l>1)for(;f<t.length-2&&!(d<t[f+1]);f++);const p=af(t[f],t[f+1],d);return a[f](p)};return n?d=>c(ca(t[0],t[o-1],d)):c}function ij(t,e){const n=t[t.length-1];for(let r=1;r<=e;r++){const s=af(0,e,r);t.push(pn(n,1,s))}}function aj(t){const e=[0];return ij(e,t.length-1),e}function lj(t,e){return t.map(n=>n*e)}function uj(t,e){return t.map(()=>e||BR).splice(0,t.length-1)}function Hh({duration:t=300,keyframes:e,times:n,ease:r="easeInOut"}){const s=b8(r)?r.map(zT):zT(r),o={done:!1,value:e[0]},i=lj(n&&n.length===e.length?n:aj(e),t),a=oj(i,e,{ease:Array.isArray(s)?s:uj(e,s)});return{calculatedDuration:t,next:l=>(o.value=a(l),o.done=l>=t,o)}}const cj=t=>t!==null;function Eb(t,{repeat:e,repeatType:n="loop"},r,s=1){const o=t.filter(cj),a=s<0||e&&n!=="loop"&&e%2===1?0:o.length-1;return!a||r===void 0?o[a]:r}const dj={decay:Px,inertia:Px,tween:Hh,keyframes:Hh,spring:cg};function ZR(t){typeof t.type=="string"&&(t.type=dj[t.type])}class Rb{constructor(){this.count=0,this.updateFinished()}get finished(){return this._finished}updateFinished(){this.count++,this._finished=new Promise(e=>{this.resolve=e})}notifyFinished(){this.resolve()}then(e,n){return this.finished.then(e,n)}}const hj=t=>t/100;class JR extends Rb{constructor(e){super(),this.state="idle",this.startTime=null,this.isStopped=!1,this.currentTime=0,this.holdTime=null,this.playbackSpeed=1,this.stop=()=>{const{motionValue:n}=this.options;if(n&&n.updatedAt!==ps.now()&&this.tick(ps.now()),this.isStopped=!0,this.state==="idle")return;this.teardown();const{onStop:r}=this.options;r&&r()},this.options=e,this.initAnimation(),this.play(),e.autoplay===!1&&this.pause()}initAnimation(){const{options:e}=this;ZR(e);const{type:n=Hh,repeat:r=0,repeatDelay:s=0,repeatType:o,velocity:i=0}=e;let{keyframes:a}=e;const l=n||Hh;l!==Hh&&typeof a[0]!="number"&&(this.mixKeyframes=zf(hj,qR(a[0],a[1])),a=[0,100]);const c=l({...e,keyframes:a});o==="mirror"&&(this.mirroredGenerator=l({...e,keyframes:[...a].reverse(),velocity:-i})),c.calculatedDuration===null&&(c.calculatedDuration=Nb(c));const{calculatedDuration:d}=c;this.calculatedDuration=d,this.resolvedDuration=d+s,this.totalDuration=this.resolvedDuration*(r+1)-s,this.generator=c}updateTime(e){const n=Math.round(e-this.startTime)*this.playbackSpeed;this.holdTime!==null?this.currentTime=this.holdTime:this.currentTime=n}tick(e,n=!1){const{generator:r,totalDuration:s,mixKeyframes:o,mirroredGenerator:i,resolvedDuration:a,calculatedDuration:l}=this;if(this.startTime===null)return r.next(0);const{delay:c=0,keyframes:d,repeat:f,repeatType:p,repeatDelay:g,type:y,onUpdate:x,finalKeyframe:w}=this.options;this.speed>0?this.startTime=Math.min(this.startTime,e):this.speed<0&&(this.startTime=Math.min(e-s/this.speed,this.startTime)),n?this.currentTime=e:this.updateTime(e);const S=this.currentTime-c*(this.playbackSpeed>=0?1:-1),$=this.playbackSpeed>=0?S<0:S>s;this.currentTime=Math.max(S,0),this.state==="finished"&&this.holdTime===null&&(this.currentTime=s);let I=this.currentTime,R=r;if(f){const B=Math.min(this.currentTime,s)/a;let M=Math.floor(B),V=B%1;!V&&B>=1&&(V=1),V===1&&M--,M=Math.min(M,f+1),!!(M%2)&&(p==="reverse"?(V=1-V,g&&(V-=g/a)):p==="mirror"&&(R=i)),I=ca(0,1,V)*a}const _=$?{done:!1,value:d[0]}:R.next(I);o&&(_.value=o(_.value));let{done:O}=_;!$&&l!==null&&(O=this.playbackSpeed>=0?this.currentTime>=s:this.currentTime<=0);const F=this.holdTime===null&&(this.state==="finished"||this.state==="running"&&O);return F&&y!==Px&&(_.value=Eb(d,this.options,w,this.speed)),x&&x(_.value),F&&this.finish(),_}then(e,n){return this.finished.then(e,n)}get duration(){return yi(this.calculatedDuration)}get time(){return yi(this.currentTime)}set time(e){e=gi(e),this.currentTime=e,this.startTime===null||this.holdTime!==null||this.playbackSpeed===0?this.holdTime=e:this.driver&&(this.startTime=this.driver.now()-e/this.playbackSpeed)}get speed(){return this.playbackSpeed}set speed(e){this.updateTime(ps.now());const n=this.playbackSpeed!==e;this.playbackSpeed=e,n&&(this.time=yi(this.currentTime))}play(){if(this.isStopped)return;const{driver:e=q8,onPlay:n,startTime:r}=this.options;this.driver||(this.driver=e(o=>this.tick(o))),n&&n();const s=this.driver.now();this.state==="finished"?(this.updateFinished(),this.startTime=s):this.holdTime!==null?this.startTime=s-this.holdTime:this.startTime||(this.startTime=r??s),this.state==="finished"&&this.speed<0&&(this.startTime+=this.calculatedDuration),this.holdTime=null,this.state="running",this.driver.start()}pause(){this.state="paused",this.updateTime(ps.now()),this.holdTime=this.currentTime}complete(){this.state!=="running"&&this.play(),this.state="finished",this.holdTime=null}finish(){this.teardown(),this.state="finished";const{onComplete:e}=this.options;e&&e()}cancel(){this.holdTime=null,this.startTime=0,this.tick(0),this.teardown()}teardown(){this.notifyFinished(),this.state="idle",this.stopDriver(),this.startTime=this.holdTime=null}stopDriver(){this.driver&&(this.driver.stop(),this.driver=void 0)}sample(e){return this.startTime=0,this.tick(e,!0)}attachTimeline(e){return this.options.allowFlatten&&(this.options.type="keyframes",this.options.ease="linear",this.initAnimation()),e.observe(this)}}function fj(t){for(let e=1;e<t.length;e++)t[e]??(t[e]=t[e-1])}const xu=t=>t*180/Math.PI,Ax=t=>{const e=xu(Math.atan2(t[1],t[0]));return Dx(e)},pj={x:4,y:5,translateX:4,translateY:5,scaleX:0,scaleY:3,scale:t=>(Math.abs(t[0])+Math.abs(t[3]))/2,rotate:Ax,rotateZ:Ax,skewX:t=>xu(Math.atan(t[1])),skewY:t=>xu(Math.atan(t[2])),skew:t=>(Math.abs(t[1])+Math.abs(t[2]))/2},Dx=t=>(t=t%360,t<0&&(t+=360),t),HT=Ax,KT=t=>Math.sqrt(t[0]*t[0]+t[1]*t[1]),XT=t=>Math.sqrt(t[4]*t[4]+t[5]*t[5]),mj={x:12,y:13,z:14,translateX:12,translateY:13,translateZ:14,scaleX:KT,scaleY:XT,scale:t=>(KT(t)+XT(t))/2,rotateX:t=>Dx(xu(Math.atan2(t[6],t[5]))),rotateY:t=>Dx(xu(Math.atan2(-t[2],t[0]))),rotateZ:HT,rotate:HT,skewX:t=>xu(Math.atan(t[4])),skewY:t=>xu(Math.atan(t[1])),skew:t=>(Math.abs(t[1])+Math.abs(t[4]))/2};function qT(t){return t.includes("scale")?1:0}function Ox(t,e){if(!t||t==="none")return qT(e);const n=t.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);let r,s;if(n)r=mj,s=n;else{const a=t.match(/^matrix\(([-\d.e\s,]+)\)$/u);r=pj,s=a}if(!s)return qT(e);const o=r[e],i=s[1].split(",").map(yj);return typeof o=="function"?o(i):i[o]}const gj=(t,e)=>{const{transform:n="none"}=getComputedStyle(t);return Ox(n,e)};function yj(t){return parseFloat(t.trim())}const xd=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],vd=new Set(xd),YT=t=>t===yd||t===rt,xj=new Set(["x","y","z"]),vj=xd.filter(t=>!xj.has(t));function bj(t){const e=[];return vj.forEach(n=>{const r=t.getValue(n);r!==void 0&&(e.push([n,r.get()]),r.set(n.startsWith("scale")?1:0))}),e}const sd={width:({x:t},{paddingLeft:e="0",paddingRight:n="0"})=>t.max-t.min-parseFloat(e)-parseFloat(n),height:({y:t},{paddingTop:e="0",paddingBottom:n="0"})=>t.max-t.min-parseFloat(e)-parseFloat(n),top:(t,{top:e})=>parseFloat(e),left:(t,{left:e})=>parseFloat(e),bottom:({y:t},{top:e})=>parseFloat(e)+(t.max-t.min),right:({x:t},{left:e})=>parseFloat(e)+(t.max-t.min),x:(t,{transform:e})=>Ox(e,"x"),y:(t,{transform:e})=>Ox(e,"y")};sd.translateX=sd.x;sd.translateY=sd.y;const ku=new Set;let Fx=!1,Lx=!1,zx=!1;function e_(){if(Lx){const t=Array.from(ku).filter(r=>r.needsMeasurement),e=new Set(t.map(r=>r.element)),n=new Map;e.forEach(r=>{const s=bj(r);s.length&&(n.set(r,s),r.render())}),t.forEach(r=>r.measureInitialState()),e.forEach(r=>{r.render();const s=n.get(r);s&&s.forEach(([o,i])=>{var a;(a=r.getValue(o))==null||a.set(i)})}),t.forEach(r=>r.measureEndState()),t.forEach(r=>{r.suspendedScrollY!==void 0&&window.scrollTo(0,r.suspendedScrollY)})}Lx=!1,Fx=!1,ku.forEach(t=>t.complete(zx)),ku.clear()}function t_(){ku.forEach(t=>{t.readKeyframes(),t.needsMeasurement&&(Lx=!0)})}function wj(){zx=!0,t_(),e_(),zx=!1}class _b{constructor(e,n,r,s,o,i=!1){this.isComplete=!1,this.isAsync=!1,this.needsMeasurement=!1,this.isScheduled=!1,this.unresolvedKeyframes=[...e],this.onComplete=n,this.name=r,this.motionValue=s,this.element=o,this.isAsync=i}scheduleResolve(){this.isScheduled=!0,this.isAsync?(ku.add(this),Fx||(Fx=!0,mn.read(t_),mn.resolveKeyframes(e_))):(this.readKeyframes(),this.complete())}readKeyframes(){const{unresolvedKeyframes:e,name:n,element:r,motionValue:s}=this;if(e[0]===null){const o=s==null?void 0:s.get(),i=e[e.length-1];if(o!==void 0)e[0]=o;else if(r&&n){const a=r.readValue(n,i);a!=null&&(e[0]=a)}e[0]===void 0&&(e[0]=i),s&&o===void 0&&s.set(e[0])}fj(e)}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(e=!1){this.isComplete=!0,this.onComplete(this.unresolvedKeyframes,this.finalKeyframe,e),ku.delete(this)}cancel(){this.isComplete||(this.isScheduled=!1,ku.delete(this))}resume(){this.isComplete||this.scheduleResolve()}}const Sj=t=>t.startsWith("--");function Cj(t,e,n){Sj(e)?t.style.setProperty(e,n):t.style[e]=n}const $j=vb(()=>window.ScrollTimeline!==void 0),kj={};function Tj(t,e){const n=vb(t);return()=>kj[e]??n()}const n_=Tj(()=>{try{document.createElement("div").animate({opacity:0},{easing:"linear(0, 1)"})}catch{return!1}return!0},"linearEasing"),Rh=([t,e,n,r])=>`cubic-bezier(${t}, ${e}, ${n}, ${r})`,QT={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:Rh([0,.65,.55,1]),circOut:Rh([.55,0,1,.45]),backIn:Rh([.31,.01,.66,-.59]),backOut:Rh([.33,1.53,.69,.99])};function r_(t,e){if(t)return typeof t=="function"?n_()?YR(t,e):"ease-out":MR(t)?Rh(t):Array.isArray(t)?t.map(n=>r_(n,e)||QT.easeOut):QT[t]}function Ij(t,e,n,{delay:r=0,duration:s=300,repeat:o=0,repeatType:i="loop",ease:a="easeOut",times:l}={},c=void 0){const d={[e]:n};l&&(d.offset=l);const f=r_(a,s);Array.isArray(f)&&(d.easing=f);const p={delay:r,duration:s,easing:Array.isArray(f)?"linear":f,fill:"both",iterations:o+1,direction:i==="reverse"?"alternate":"normal"};return c&&(p.pseudoElement=c),t.animate(d,p)}function s_(t){return typeof t=="function"&&"applyToOptions"in t}function Nj({type:t,...e}){return s_(t)&&n_()?t.applyToOptions(e):(e.duration??(e.duration=300),e.ease??(e.ease="easeOut"),e)}class Ej extends Rb{constructor(e){if(super(),this.finishedTime=null,this.isStopped=!1,!e)return;const{element:n,name:r,keyframes:s,pseudoElement:o,allowFlatten:i=!1,finalKeyframe:a,onComplete:l}=e;this.isPseudoElement=!!o,this.allowFlatten=i,this.options=e,xb(typeof e.type!="string");const c=Nj(e);this.animation=Ij(n,r,s,c,o),c.autoplay===!1&&this.animation.pause(),this.animation.onfinish=()=>{if(this.finishedTime=this.time,!o){const d=Eb(s,this.options,a,this.speed);this.updateMotionValue?this.updateMotionValue(d):Cj(n,r,d),this.animation.cancel()}l==null||l(),this.notifyFinished()},this.animation.oncancel=()=>this.notifyFinished()}play(){this.isStopped||(this.animation.play(),this.state==="finished"&&this.updateFinished())}pause(){this.animation.pause()}complete(){var e,n;(n=(e=this.animation).finish)==null||n.call(e)}cancel(){try{this.animation.cancel()}catch{}}stop(){if(this.isStopped)return;this.isStopped=!0;const{state:e}=this;e==="idle"||e==="finished"||(this.updateMotionValue?this.updateMotionValue():this.commitStyles(),this.isPseudoElement||this.cancel())}commitStyles(){var e,n;this.isPseudoElement||(n=(e=this.animation).commitStyles)==null||n.call(e)}get duration(){var n,r;const e=((r=(n=this.animation.effect)==null?void 0:n.getComputedTiming)==null?void 0:r.call(n).duration)||0;return yi(Number(e))}get time(){return yi(Number(this.animation.currentTime)||0)}set time(e){this.finishedTime=null,this.animation.currentTime=gi(e)}get speed(){return this.animation.playbackRate}set speed(e){e<0&&(this.finishedTime=null),this.animation.playbackRate=e}get state(){return this.finishedTime!==null?"finished":this.animation.playState}get startTime(){return Number(this.animation.startTime)}set startTime(e){this.animation.startTime=e}attachTimeline({timeline:e,observe:n}){var r;return this.allowFlatten&&((r=this.animation.effect)==null||r.updateTiming({easing:"linear"})),this.animation.onfinish=null,e&&$j()?(this.animation.timeline=e,ao):n(this)}}const o_={anticipate:FR,backInOut:OR,circInOut:zR};function Rj(t){return t in o_}function _j(t){typeof t.ease=="string"&&Rj(t.ease)&&(t.ease=o_[t.ease])}const ZT=10;class Pj extends Ej{constructor(e){_j(e),ZR(e),super(e),e.startTime&&(this.startTime=e.startTime),this.options=e}updateMotionValue(e){const{motionValue:n,onUpdate:r,onComplete:s,element:o,...i}=this.options;if(!n)return;if(e!==void 0){n.set(e);return}const a=new JR({...i,autoplay:!1}),l=gi(this.finishedTime??this.time);n.setWithVelocity(a.sample(l-ZT).value,a.sample(l).value,ZT),a.stop()}}const JT=(t,e)=>e==="zIndex"?!1:!!(typeof t=="number"||Array.isArray(t)||typeof t=="string"&&(gl.test(t)||t==="0")&&!t.startsWith("url("));function Aj(t){const e=t[0];if(t.length===1)return!0;for(let n=0;n<t.length;n++)if(t[n]!==e)return!0}function Dj(t,e,n,r){const s=t[0];if(s===null)return!1;if(e==="display"||e==="visibility")return!0;const o=t[t.length-1],i=JT(s,e),a=JT(o,e);return!i||!a?!1:Aj(t)||(n==="spring"||s_(n))&&r}const Oj=new Set(["opacity","clipPath","filter","transform"]),Fj=vb(()=>Object.hasOwnProperty.call(Element.prototype,"animate"));function Lj(t){const{motionValue:e,name:n,repeatDelay:r,repeatType:s,damping:o,type:i}=t;if(!e||!e.owner||!(e.owner.current instanceof HTMLElement))return!1;const{onUpdate:a,transformTemplate:l}=e.owner.getProps();return Fj()&&n&&Oj.has(n)&&(n!=="transform"||!l)&&!a&&!r&&s!=="mirror"&&o!==0&&i!=="inertia"}const zj=40;class Bj extends Rb{constructor({autoplay:e=!0,delay:n=0,type:r="keyframes",repeat:s=0,repeatDelay:o=0,repeatType:i="loop",keyframes:a,name:l,motionValue:c,element:d,...f}){var y;super(),this.stop=()=>{var x,w;this._animation?(this._animation.stop(),(x=this.stopTimeline)==null||x.call(this)):(w=this.keyframeResolver)==null||w.cancel()},this.createdAt=ps.now();const p={autoplay:e,delay:n,type:r,repeat:s,repeatDelay:o,repeatType:i,name:l,motionValue:c,element:d,...f},g=(d==null?void 0:d.KeyframeResolver)||_b;this.keyframeResolver=new g(a,(x,w,S)=>this.onKeyframesResolved(x,w,p,!S),l,c,d),(y=this.keyframeResolver)==null||y.scheduleResolve()}onKeyframesResolved(e,n,r,s){this.keyframeResolver=void 0;const{name:o,type:i,velocity:a,delay:l,isHandoff:c,onUpdate:d}=r;this.resolvedAt=ps.now(),Dj(e,o,i,a)||((da.instantAnimations||!l)&&(d==null||d(Eb(e,r,n))),e[0]=e[e.length-1],r.duration=0,r.repeat=0);const p={startTime:s?this.resolvedAt?this.resolvedAt-this.createdAt>zj?this.resolvedAt:this.createdAt:this.createdAt:void 0,finalKeyframe:n,...r,keyframes:e},g=!c&&Lj(p)?new Pj({...p,element:p.motionValue.owner.current}):new JR(p);g.finished.then(()=>this.notifyFinished()).catch(ao),this.pendingTimeline&&(this.stopTimeline=g.attachTimeline(this.pendingTimeline),this.pendingTimeline=void 0),this._animation=g}get finished(){return this._animation?this.animation.finished:this._finished}then(e,n){return this.finished.finally(e).then(()=>{})}get animation(){return this._animation||wj(),this._animation}get duration(){return this.animation.duration}get time(){return this.animation.time}set time(e){this.animation.time=e}get speed(){return this.animation.speed}get state(){return this.animation.state}set speed(e){this.animation.speed=e}get startTime(){return this.animation.startTime}attachTimeline(e){return this._animation?this.stopTimeline=this.animation.attachTimeline(e):this.pendingTimeline=e,()=>this.stop()}play(){this.animation.play()}pause(){this.animation.pause()}complete(){this.animation.complete()}cancel(){this.animation.cancel()}}const Mj=/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;function Vj(t){const e=Mj.exec(t);if(!e)return[,];const[,n,r,s]=e;return[`--${n??r}`,s]}function i_(t,e,n=1){const[r,s]=Vj(t);if(!r)return;const o=window.getComputedStyle(e).getPropertyValue(r);if(o){const i=o.trim();return NR(i)?parseFloat(i):i}return $b(s)?i_(s,e,n+1):s}function Pb(t,e){return(t==null?void 0:t[e])??(t==null?void 0:t.default)??t}const a_=new Set(["width","height","top","left","right","bottom",...xd]),Wj={test:t=>t==="auto",parse:t=>t},l_=t=>e=>e.test(t),u_=[yd,rt,xi,sl,A8,P8,Wj],eI=t=>u_.find(l_(t));function Uj(t){return typeof t=="number"?t===0:t!==null?t==="none"||t==="0"||ER(t):!0}const jj=new Set(["brightness","contrast","saturate","opacity"]);function Gj(t){const[e,n]=t.slice(0,-1).split("(");if(e==="drop-shadow")return t;const[r]=n.match(kb)||[];if(!r)return t;const s=n.replace(r,"");let o=jj.has(e)?1:0;return r!==n&&(o*=100),e+"("+o+s+")"}const Hj=/\b([a-z-]*)\(.*?\)/gu,Bx={...gl,getAnimatableNone:t=>{const e=t.match(Hj);return e?e.map(Gj).join(" "):t}},tI={...yd,transform:Math.round},Kj={rotate:sl,rotateX:sl,rotateY:sl,rotateZ:sl,scale:gm,scaleX:gm,scaleY:gm,scaleZ:gm,skew:sl,skewX:sl,skewY:sl,distance:rt,translateX:rt,translateY:rt,translateZ:rt,x:rt,y:rt,z:rt,perspective:rt,transformPerspective:rt,opacity:lf,originX:MT,originY:MT,originZ:rt},Ab={borderWidth:rt,borderTopWidth:rt,borderRightWidth:rt,borderBottomWidth:rt,borderLeftWidth:rt,borderRadius:rt,radius:rt,borderTopLeftRadius:rt,borderTopRightRadius:rt,borderBottomRightRadius:rt,borderBottomLeftRadius:rt,width:rt,maxWidth:rt,height:rt,maxHeight:rt,top:rt,right:rt,bottom:rt,left:rt,padding:rt,paddingTop:rt,paddingRight:rt,paddingBottom:rt,paddingLeft:rt,margin:rt,marginTop:rt,marginRight:rt,marginBottom:rt,marginLeft:rt,backgroundPositionX:rt,backgroundPositionY:rt,...Kj,zIndex:tI,fillOpacity:lf,strokeOpacity:lf,numOctaves:tI},Xj={...Ab,color:wr,backgroundColor:wr,outlineColor:wr,fill:wr,stroke:wr,borderColor:wr,borderTopColor:wr,borderRightColor:wr,borderBottomColor:wr,borderLeftColor:wr,filter:Bx,WebkitFilter:Bx},c_=t=>Xj[t];function d_(t,e){let n=c_(t);return n!==Bx&&(n=gl),n.getAnimatableNone?n.getAnimatableNone(e):void 0}const qj=new Set(["auto","none","0"]);function Yj(t,e,n){let r=0,s;for(;r<t.length&&!s;){const o=t[r];typeof o=="string"&&!qj.has(o)&&uf(o).values.length&&(s=t[r]),r++}if(s&&n)for(const o of e)t[o]=d_(n,s)}class Qj extends _b{constructor(e,n,r,s,o){super(e,n,r,s,o,!0)}readKeyframes(){const{unresolvedKeyframes:e,element:n,name:r}=this;if(!n||!n.current)return;super.readKeyframes();for(let l=0;l<e.length;l++){let c=e[l];if(typeof c=="string"&&(c=c.trim(),$b(c))){const d=i_(c,n.current);d!==void 0&&(e[l]=d),l===e.length-1&&(this.finalKeyframe=c)}}if(this.resolveNoneKeyframes(),!a_.has(r)||e.length!==2)return;const[s,o]=e,i=eI(s),a=eI(o);if(i!==a)if(YT(i)&&YT(a))for(let l=0;l<e.length;l++){const c=e[l];typeof c=="string"&&(e[l]=parseFloat(c))}else this.needsMeasurement=!0}resolveNoneKeyframes(){const{unresolvedKeyframes:e,name:n}=this,r=[];for(let s=0;s<e.length;s++)(e[s]===null||Uj(e[s]))&&r.push(s);r.length&&Yj(e,r,n)}measureInitialState(){const{element:e,unresolvedKeyframes:n,name:r}=this;if(!e||!e.current)return;r==="height"&&(this.suspendedScrollY=window.pageYOffset),this.measuredOrigin=sd[r](e.measureViewportBox(),window.getComputedStyle(e.current)),n[0]=this.measuredOrigin;const s=n[n.length-1];s!==void 0&&e.getValue(r,s).jump(s,!1)}measureEndState(){var a;const{element:e,name:n,unresolvedKeyframes:r}=this;if(!e||!e.current)return;const s=e.getValue(n);s&&s.jump(this.measuredOrigin,!1);const o=r.length-1,i=r[o];r[o]=sd[n](e.measureViewportBox(),window.getComputedStyle(e.current)),i!==null&&this.finalKeyframe===void 0&&(this.finalKeyframe=i),(a=this.removedTransforms)!=null&&a.length&&this.removedTransforms.forEach(([l,c])=>{e.getValue(l).set(c)}),this.resolveNoneKeyframes()}}function Zj(t,e,n){if(t instanceof EventTarget)return[t];if(typeof t=="string"){let r=document;const s=(n==null?void 0:n[t])??r.querySelectorAll(t);return s?Array.from(s):[]}return Array.from(t)}const{schedule:Db}=VR(queueMicrotask,!1),_o={x:!1,y:!1};function h_(){return _o.x||_o.y}function Jj(t){return t==="x"||t==="y"?_o[t]?null:(_o[t]=!0,()=>{_o[t]=!1}):_o.x||_o.y?null:(_o.x=_o.y=!0,()=>{_o.x=_o.y=!1})}function f_(t,e){const n=Zj(t),r=new AbortController,s={passive:!0,...e,signal:r.signal};return[n,s,()=>r.abort()]}function nI(t){return!(t.pointerType==="touch"||h_())}function eG(t,e,n={}){const[r,s,o]=f_(t,n),i=a=>{if(!nI(a))return;const{target:l}=a,c=e(l,a);if(typeof c!="function"||!l)return;const d=f=>{nI(f)&&(c(f),l.removeEventListener("pointerleave",d))};l.addEventListener("pointerleave",d,s)};return r.forEach(a=>{a.addEventListener("pointerenter",i,s)}),o}const p_=(t,e)=>e?t===e?!0:p_(t,e.parentElement):!1,Ob=t=>t.pointerType==="mouse"?typeof t.button!="number"||t.button<=0:t.isPrimary!==!1,tG=new Set(["BUTTON","INPUT","SELECT","TEXTAREA","A"]);function nG(t){return tG.has(t.tagName)||t.tabIndex!==-1}const _h=new WeakSet;function rI(t){return e=>{e.key==="Enter"&&t(e)}}function _1(t,e){t.dispatchEvent(new PointerEvent("pointer"+e,{isPrimary:!0,bubbles:!0}))}const rG=(t,e)=>{const n=t.currentTarget;if(!n)return;const r=rI(()=>{if(_h.has(n))return;_1(n,"down");const s=rI(()=>{_1(n,"up")}),o=()=>_1(n,"cancel");n.addEventListener("keyup",s,e),n.addEventListener("blur",o,e)});n.addEventListener("keydown",r,e),n.addEventListener("blur",()=>n.removeEventListener("keydown",r),e)};function sI(t){return Ob(t)&&!h_()}function sG(t,e,n={}){const[r,s,o]=f_(t,n),i=a=>{const l=a.currentTarget;if(!sI(a)||_h.has(l))return;_h.add(l);const c=e(l,a),d=(g,y)=>{window.removeEventListener("pointerup",f),window.removeEventListener("pointercancel",p),!(!sI(g)||!_h.has(l))&&(_h.delete(l),typeof c=="function"&&c(g,{success:y}))},f=g=>{d(g,l===window||l===document||n.useGlobalTarget||p_(l,g.target))},p=g=>{d(g,!1)};window.addEventListener("pointerup",f,s),window.addEventListener("pointercancel",p,s)};return r.forEach(a=>{(n.useGlobalTarget?window:a).addEventListener("pointerdown",i,s),a instanceof HTMLElement&&(a.addEventListener("focus",c=>rG(c,s)),!nG(a)&&!a.hasAttribute("tabindex")&&(a.tabIndex=0))}),o}const oI=30,oG=t=>!isNaN(parseFloat(t));class iG{constructor(e,n={}){this.version="12.9.1",this.canTrackVelocity=null,this.events={},this.updateAndNotify=(r,s=!0)=>{var i,a;const o=ps.now();this.updatedAt!==o&&this.setPrevFrameValue(),this.prev=this.current,this.setCurrent(r),this.current!==this.prev&&((i=this.events.change)==null||i.notify(this.current)),s&&((a=this.events.renderRequest)==null||a.notify(this.current))},this.hasAnimated=!1,this.setCurrent(e),this.owner=n.owner}setCurrent(e){this.current=e,this.updatedAt=ps.now(),this.canTrackVelocity===null&&e!==void 0&&(this.canTrackVelocity=oG(this.current))}setPrevFrameValue(e=this.current){this.prevFrameValue=e,this.prevUpdatedAt=this.updatedAt}onChange(e){return this.on("change",e)}on(e,n){this.events[e]||(this.events[e]=new bb);const r=this.events[e].add(n);return e==="change"?()=>{r(),mn.read(()=>{this.events.change.getSize()||this.stop()})}:r}clearListeners(){for(const e in this.events)this.events[e].clear()}attach(e,n){this.passiveEffect=e,this.stopPassiveEffect=n}set(e,n=!0){!n||!this.passiveEffect?this.updateAndNotify(e,n):this.passiveEffect(e,this.updateAndNotify)}setWithVelocity(e,n,r){this.set(n),this.prev=void 0,this.prevFrameValue=e,this.prevUpdatedAt=this.updatedAt-r}jump(e,n=!0){this.updateAndNotify(e),this.prev=e,this.prevUpdatedAt=this.prevFrameValue=void 0,n&&this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}get(){return this.current}getPrevious(){return this.prev}getVelocity(){const e=ps.now();if(!this.canTrackVelocity||this.prevFrameValue===void 0||e-this.updatedAt>oI)return 0;const n=Math.min(this.updatedAt-this.prevUpdatedAt,oI);return RR(parseFloat(this.current)-parseFloat(this.prevFrameValue),n)}start(e){return this.stop(),new Promise(n=>{this.hasAnimated=!0,this.animation=e(n),this.events.animationStart&&this.events.animationStart.notify()}).then(()=>{this.events.animationComplete&&this.events.animationComplete.notify(),this.clearAnimation()})}stop(){this.animation&&(this.animation.stop(),this.events.animationCancel&&this.events.animationCancel.notify()),this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){var e;(e=this.events.destroy)==null||e.notify(),this.clearListeners(),this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}}function cf(t,e){return new iG(t,e)}const aG=[...u_,wr,gl],lG=t=>aG.find(l_(t)),m_=(t,e)=>e&&typeof t=="number"?e.transform(t):t,g_=J.createContext({strict:!1}),iI={animation:["animate","variants","whileHover","whileTap","exit","whileInView","whileFocus","whileDrag"],exit:["exit"],drag:["drag","dragControls"],focus:["whileFocus"],hover:["whileHover","onHoverStart","onHoverEnd"],tap:["whileTap","onTap","onTapStart","onTapCancel"],pan:["onPan","onPanStart","onPanSessionStart","onPanEnd"],inView:["whileInView","onViewportEnter","onViewportLeave"],layout:["layout","layoutId"]},od={};for(const t in iI)od[t]={isEnabled:e=>iI[t].some(n=>!!e[n])};function uG(t){for(const e in t)od[e]={...od[e],...t[e]}}const cG=new Set(["animate","exit","variants","initial","style","values","variants","transition","transformTemplate","custom","inherit","onBeforeLayoutMeasure","onAnimationStart","onAnimationComplete","onUpdate","onDragStart","onDrag","onDragEnd","onMeasureDragConstraints","onDirectionLock","onDragTransitionEnd","_dragX","_dragY","onHoverStart","onHoverEnd","onViewportEnter","onViewportLeave","globalTapTarget","ignoreStrict","viewport"]);function dg(t){return t.startsWith("while")||t.startsWith("drag")&&t!=="draggable"||t.startsWith("layout")||t.startsWith("onTap")||t.startsWith("onPan")||t.startsWith("onLayout")||cG.has(t)}let y_=t=>!dg(t);function dG(t){t&&(y_=e=>e.startsWith("on")?!dg(e):t(e))}try{dG(require("@emotion/is-prop-valid").default)}catch{}function hG(t,e,n){const r={};for(const s in t)s==="values"&&typeof t.values=="object"||(y_(s)||n===!0&&dg(s)||!e&&!dg(s)||t.draggable&&s.startsWith("onDrag"))&&(r[s]=t[s]);return r}function fG(t){if(typeof Proxy>"u")return t;const e=new Map,n=(...r)=>t(...r);return new Proxy(n,{get:(r,s)=>s==="create"?t:(e.has(s)||e.set(s,t(s)),e.get(s))})}const Yg=J.createContext({});function Qg(t){return t!==null&&typeof t=="object"&&typeof t.start=="function"}function df(t){return typeof t=="string"||Array.isArray(t)}const Fb=["animate","whileInView","whileFocus","whileHover","whileTap","whileDrag","exit"],Lb=["initial",...Fb];function Zg(t){return Qg(t.animate)||Lb.some(e=>df(t[e]))}function x_(t){return!!(Zg(t)||t.variants)}function pG(t,e){if(Zg(t)){const{initial:n,animate:r}=t;return{initial:n===!1||df(n)?n:void 0,animate:df(r)?r:void 0}}return t.inherit!==!1?e:{}}function mG(t){const{initial:e,animate:n}=pG(t,J.useContext(Yg));return J.useMemo(()=>({initial:e,animate:n}),[aI(e),aI(n)])}function aI(t){return Array.isArray(t)?t.join(" "):t}const gG=Symbol.for("motionComponentSymbol");function Mc(t){return t&&typeof t=="object"&&Object.prototype.hasOwnProperty.call(t,"current")}function yG(t,e,n){return J.useCallback(r=>{r&&t.onMount&&t.onMount(r),e&&(r?e.mount(r):e.unmount()),n&&(typeof n=="function"?n(r):Mc(n)&&(n.current=r))},[e])}const zb=t=>t.replace(/([a-z])([A-Z])/gu,"$1-$2").toLowerCase(),xG="framerAppearId",v_="data-"+zb(xG),b_=J.createContext({});function vG(t,e,n,r,s){var x,w;const{visualElement:o}=J.useContext(Yg),i=J.useContext(g_),a=J.useContext(Lf),l=J.useContext(pb).reducedMotion,c=J.useRef(null);r=r||i.renderer,!c.current&&r&&(c.current=r(t,{visualState:e,parent:o,props:n,presenceContext:a,blockInitialAnimation:a?a.initial===!1:!1,reducedMotionConfig:l}));const d=c.current,f=J.useContext(b_);d&&!d.projection&&s&&(d.type==="html"||d.type==="svg")&&bG(c.current,n,s,f);const p=J.useRef(!1);J.useInsertionEffect(()=>{d&&p.current&&d.update(n,a)});const g=n[v_],y=J.useRef(!!g&&!((x=window.MotionHandoffIsComplete)!=null&&x.call(window,g))&&((w=window.MotionHasOptimisedAnimation)==null?void 0:w.call(window,g)));return TR(()=>{d&&(p.current=!0,window.MotionIsMounted=!0,d.updateFeatures(),Db.render(d.render),y.current&&d.animationState&&d.animationState.animateChanges())}),J.useEffect(()=>{d&&(!y.current&&d.animationState&&d.animationState.animateChanges(),y.current&&(queueMicrotask(()=>{var S;(S=window.MotionHandoffMarkAsComplete)==null||S.call(window,g)}),y.current=!1))}),d}function bG(t,e,n,r){const{layoutId:s,layout:o,drag:i,dragConstraints:a,layoutScroll:l,layoutRoot:c,layoutCrossfade:d}=e;t.projection=new n(t.latestValues,e["data-framer-portal-id"]?void 0:w_(t.parent)),t.projection.setOptions({layoutId:s,layout:o,alwaysMeasureLayout:!!i||a&&Mc(a),visualElement:t,animationType:typeof o=="string"?o:"both",initialPromotionConfig:r,crossfade:d,layoutScroll:l,layoutRoot:c})}function w_(t){if(t)return t.options.allowProjection!==!1?t.projection:w_(t.parent)}function wG({preloadedFeatures:t,createVisualElement:e,useRender:n,useVisualState:r,Component:s}){t&&uG(t);function o(a,l){let c;const d={...J.useContext(pb),...a,layoutId:SG(a)},{isStatic:f}=d,p=mG(a),g=r(a,f);if(!f&&fb){CG();const y=$G(d);c=y.MeasureLayout,p.visualElement=vG(s,g,d,e,y.ProjectionNode)}return K.jsxs(Yg.Provider,{value:p,children:[c&&p.visualElement?K.jsx(c,{visualElement:p.visualElement,...d}):null,n(s,a,yG(g,p.visualElement,l),g,f,p.visualElement)]})}o.displayName=`motion.${typeof s=="string"?s:`create(${s.displayName??s.name??""})`}`;const i=J.forwardRef(o);return i[gG]=s,i}function SG({layoutId:t}){const e=J.useContext(db).id;return e&&t!==void 0?e+"-"+t:t}function CG(t,e){J.useContext(g_).strict}function $G(t){const{drag:e,layout:n}=od;if(!e&&!n)return{};const r={...e,...n};return{MeasureLayout:e!=null&&e.isEnabled(t)||n!=null&&n.isEnabled(t)?r.MeasureLayout:void 0,ProjectionNode:r.ProjectionNode}}const hf={};function kG(t){for(const e in t)hf[e]=t[e],Cb(e)&&(hf[e].isCSSVariable=!0)}function S_(t,{layout:e,layoutId:n}){return vd.has(t)||t.startsWith("origin")||(e||n!==void 0)&&(!!hf[t]||t==="opacity")}const Tr=t=>!!(t&&t.getVelocity),TG={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},IG=xd.length;function NG(t,e,n){let r="",s=!0;for(let o=0;o<IG;o++){const i=xd[o],a=t[i];if(a===void 0)continue;let l=!0;if(typeof a=="number"?l=a===(i.startsWith("scale")?1:0):l=parseFloat(a)===0,!l||n){const c=m_(a,Ab[i]);if(!l){s=!1;const d=TG[i]||i;r+=`${d}(${c}) `}n&&(e[i]=c)}}return r=r.trim(),n?r=n(e,s?"":r):s&&(r="none"),r}function Bb(t,e,n){const{style:r,vars:s,transformOrigin:o}=t;let i=!1,a=!1;for(const l in e){const c=e[l];if(vd.has(l)){i=!0;continue}else if(Cb(l)){s[l]=c;continue}else{const d=m_(c,Ab[l]);l.startsWith("origin")?(a=!0,o[l]=d):r[l]=d}}if(e.transform||(i||n?r.transform=NG(e,t.transform,n):r.transform&&(r.transform="none")),a){const{originX:l="50%",originY:c="50%",originZ:d=0}=o;r.transformOrigin=`${l} ${c} ${d}`}}const Mb=()=>({style:{},transform:{},transformOrigin:{},vars:{}});function C_(t,e,n){for(const r in e)!Tr(e[r])&&!S_(r,n)&&(t[r]=e[r])}function EG({transformTemplate:t},e){return J.useMemo(()=>{const n=Mb();return Bb(n,e,t),Object.assign({},n.vars,n.style)},[e])}function RG(t,e){const n=t.style||{},r={};return C_(r,n,t),Object.assign(r,EG(t,e)),r}function _G(t,e){const n={},r=RG(t,e);return t.drag&&t.dragListener!==!1&&(n.draggable=!1,r.userSelect=r.WebkitUserSelect=r.WebkitTouchCallout="none",r.touchAction=t.drag===!0?"none":`pan-${t.drag==="x"?"y":"x"}`),t.tabIndex===void 0&&(t.onTap||t.onTapStart||t.whileTap)&&(n.tabIndex=0),n.style=r,n}const PG=["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","switch","symbol","svg","text","tspan","use","view"];function Vb(t){return typeof t!="string"||t.includes("-")?!1:!!(PG.indexOf(t)>-1||/[A-Z]/u.test(t))}const AG={offset:"stroke-dashoffset",array:"stroke-dasharray"},DG={offset:"strokeDashoffset",array:"strokeDasharray"};function OG(t,e,n=1,r=0,s=!0){t.pathLength=1;const o=s?AG:DG;t[o.offset]=rt.transform(-r);const i=rt.transform(e),a=rt.transform(n);t[o.array]=`${i} ${a}`}function $_(t,{attrX:e,attrY:n,attrScale:r,pathLength:s,pathSpacing:o=1,pathOffset:i=0,...a},l,c){if(Bb(t,a,c),l){t.style.viewBox&&(t.attrs.viewBox=t.style.viewBox);return}t.attrs=t.style,t.style={};const{attrs:d,style:f}=t;d.transform&&(f.transform=d.transform,delete d.transform),(f.transform||d.transformOrigin)&&(f.transformOrigin=d.transformOrigin??"50% 50%",delete d.transformOrigin),f.transform&&(f.transformBox="fill-box",delete d.transformBox),e!==void 0&&(d.x=e),n!==void 0&&(d.y=n),r!==void 0&&(d.scale=r),s!==void 0&&OG(d,s,o,i,!1)}const k_=()=>({...Mb(),attrs:{}}),T_=t=>typeof t=="string"&&t.toLowerCase()==="svg";function FG(t,e,n,r){const s=J.useMemo(()=>{const o=k_();return $_(o,e,T_(r),t.transformTemplate),{...o.attrs,style:{...o.style}}},[e]);if(t.style){const o={};C_(o,t.style,t),s.style={...o,...s.style}}return s}function LG(t=!1){return(n,r,s,{latestValues:o},i)=>{const l=(Vb(n)?FG:_G)(r,o,i,n),c=hG(r,typeof n=="string",t),d=n!==J.Fragment?{...c,...l,ref:s}:{},{children:f}=r,p=J.useMemo(()=>Tr(f)?f.get():f,[f]);return J.createElement(n,{...d,children:p})}}function lI(t){const e=[{},{}];return t==null||t.values.forEach((n,r)=>{e[0][r]=n.get(),e[1][r]=n.getVelocity()}),e}function Wb(t,e,n,r){if(typeof e=="function"){const[s,o]=lI(r);e=e(n!==void 0?n:t.custom,s,o)}if(typeof e=="string"&&(e=t.variants&&t.variants[e]),typeof e=="function"){const[s,o]=lI(r);e=e(n!==void 0?n:t.custom,s,o)}return e}function Wm(t){return Tr(t)?t.get():t}function zG({scrapeMotionValuesFromProps:t,createRenderState:e},n,r,s){return{latestValues:BG(n,r,s,t),renderState:e()}}const I_=t=>(e,n)=>{const r=J.useContext(Yg),s=J.useContext(Lf),o=()=>zG(t,e,r,s);return n?o():hb(o)};function BG(t,e,n,r){const s={},o=r(t,{});for(const p in o)s[p]=Wm(o[p]);let{initial:i,animate:a}=t;const l=Zg(t),c=x_(t);e&&c&&!l&&t.inherit!==!1&&(i===void 0&&(i=e.initial),a===void 0&&(a=e.animate));let d=n?n.initial===!1:!1;d=d||i===!1;const f=d?a:i;if(f&&typeof f!="boolean"&&!Qg(f)){const p=Array.isArray(f)?f:[f];for(let g=0;g<p.length;g++){const y=Wb(t,p[g]);if(y){const{transitionEnd:x,transition:w,...S}=y;for(const $ in S){let I=S[$];if(Array.isArray(I)){const R=d?I.length-1:0;I=I[R]}I!==null&&(s[$]=I)}for(const $ in x)s[$]=x[$]}}}return s}function Ub(t,e,n){var o;const{style:r}=t,s={};for(const i in r)(Tr(r[i])||e.style&&Tr(e.style[i])||S_(i,t)||((o=n==null?void 0:n.getValue(i))==null?void 0:o.liveStyle)!==void 0)&&(s[i]=r[i]);return s}const MG={useVisualState:I_({scrapeMotionValuesFromProps:Ub,createRenderState:Mb})};function N_(t,e,n){const r=Ub(t,e,n);for(const s in t)if(Tr(t[s])||Tr(e[s])){const o=xd.indexOf(s)!==-1?"attr"+s.charAt(0).toUpperCase()+s.substring(1):s;r[o]=t[s]}return r}const VG={useVisualState:I_({scrapeMotionValuesFromProps:N_,createRenderState:k_})};function WG(t,e){return function(r,{forwardMotionProps:s}={forwardMotionProps:!1}){const i={...Vb(r)?VG:MG,preloadedFeatures:t,useRender:LG(s),createVisualElement:e,Component:r};return wG(i)}}function ff(t,e,n){const r=t.getProps();return Wb(r,e,n!==void 0?n:r.custom,t)}const Mx=t=>Array.isArray(t);function UG(t,e,n){t.hasValue(e)?t.getValue(e).set(n):t.addValue(e,cf(n))}function jG(t){return Mx(t)?t[t.length-1]||0:t}function GG(t,e){const n=ff(t,e);let{transitionEnd:r={},transition:s={},...o}=n||{};o={...o,...r};for(const i in o){const a=jG(o[i]);UG(t,i,a)}}function HG(t){return!!(Tr(t)&&t.add)}function Vx(t,e){const n=t.getValue("willChange");if(HG(n))return n.add(e);if(!n&&da.WillChange){const r=new da.WillChange("auto");t.addValue("willChange",r),r.add(e)}}function E_(t){return t.props[v_]}const KG=t=>t!==null;function XG(t,{repeat:e,repeatType:n="loop"},r){const s=t.filter(KG),o=e&&n!=="loop"&&e%2===1?0:s.length-1;return s[o]}const qG={type:"spring",stiffness:500,damping:25,restSpeed:10},YG=t=>({type:"spring",stiffness:550,damping:t===0?2*Math.sqrt(550):30,restSpeed:10}),QG={type:"keyframes",duration:.8},ZG={type:"keyframes",ease:[.25,.1,.35,1],duration:.3},JG=(t,{keyframes:e})=>e.length>2?QG:vd.has(t)?t.startsWith("scale")?YG(e[1]):qG:ZG;function eH({when:t,delay:e,delayChildren:n,staggerChildren:r,staggerDirection:s,repeat:o,repeatType:i,repeatDelay:a,from:l,elapsed:c,...d}){return!!Object.keys(d).length}const jb=(t,e,n,r={},s,o)=>i=>{const a=Pb(r,t)||{},l=a.delay||r.delay||0;let{elapsed:c=0}=r;c=c-gi(l);const d={keyframes:Array.isArray(n)?n:[null,n],ease:"easeOut",velocity:e.getVelocity(),...a,delay:-c,onUpdate:p=>{e.set(p),a.onUpdate&&a.onUpdate(p)},onComplete:()=>{i(),a.onComplete&&a.onComplete()},name:t,motionValue:e,element:o?void 0:s};eH(a)||Object.assign(d,JG(t,d)),d.duration&&(d.duration=gi(d.duration)),d.repeatDelay&&(d.repeatDelay=gi(d.repeatDelay)),d.from!==void 0&&(d.keyframes[0]=d.from);let f=!1;if((d.type===!1||d.duration===0&&!d.repeatDelay)&&(d.duration=0,d.delay===0&&(f=!0)),(da.instantAnimations||da.skipAnimations)&&(f=!0,d.duration=0,d.delay=0),d.allowFlatten=!a.type&&!a.ease,f&&!o&&e.get()!==void 0){const p=XG(d.keyframes,a);if(p!==void 0){mn.update(()=>{d.onUpdate(p),d.onComplete()});return}}return new Bj(d)};function tH({protectedKeys:t,needsAnimating:e},n){const r=t.hasOwnProperty(n)&&e[n]!==!0;return e[n]=!1,r}function R_(t,e,{delay:n=0,transitionOverride:r,type:s}={}){let{transition:o=t.getDefaultTransition(),transitionEnd:i,...a}=e;r&&(o=r);const l=[],c=s&&t.animationState&&t.animationState.getState()[s];for(const d in a){const f=t.getValue(d,t.latestValues[d]??null),p=a[d];if(p===void 0||c&&tH(c,d))continue;const g={delay:n,...Pb(o||{},d)},y=f.get();if(y!==void 0&&!f.isAnimating&&!Array.isArray(p)&&p===y&&!g.velocity)continue;let x=!1;if(window.MotionHandoffAnimation){const S=E_(t);if(S){const $=window.MotionHandoffAnimation(S,d,mn);$!==null&&(g.startTime=$,x=!0)}}Vx(t,d),f.start(jb(d,f,p,t.shouldReduceMotion&&a_.has(d)?{type:!1}:g,t,x));const w=f.animation;w&&l.push(w)}return i&&Promise.all(l).then(()=>{mn.update(()=>{i&&GG(t,i)})}),l}function Wx(t,e,n={}){var l;const r=ff(t,e,n.type==="exit"?(l=t.presenceContext)==null?void 0:l.custom:void 0);let{transition:s=t.getDefaultTransition()||{}}=r||{};n.transitionOverride&&(s=n.transitionOverride);const o=r?()=>Promise.all(R_(t,r,n)):()=>Promise.resolve(),i=t.variantChildren&&t.variantChildren.size?(c=0)=>{const{delayChildren:d=0,staggerChildren:f,staggerDirection:p}=s;return nH(t,e,d+c,f,p,n)}:()=>Promise.resolve(),{when:a}=s;if(a){const[c,d]=a==="beforeChildren"?[o,i]:[i,o];return c().then(()=>d())}else return Promise.all([o(),i(n.delay)])}function nH(t,e,n=0,r=0,s=1,o){const i=[],a=(t.variantChildren.size-1)*r,l=s===1?(c=0)=>c*r:(c=0)=>a-c*r;return Array.from(t.variantChildren).sort(rH).forEach((c,d)=>{c.notify("AnimationStart",e),i.push(Wx(c,e,{...o,delay:n+l(d)}).then(()=>c.notify("AnimationComplete",e)))}),Promise.all(i)}function rH(t,e){return t.sortNodePosition(e)}function sH(t,e,n={}){t.notify("AnimationStart",e);let r;if(Array.isArray(e)){const s=e.map(o=>Wx(t,o,n));r=Promise.all(s)}else if(typeof e=="string")r=Wx(t,e,n);else{const s=typeof e=="function"?ff(t,e,n.custom):e;r=Promise.all(R_(t,s,n))}return r.then(()=>{t.notify("AnimationComplete",e)})}function __(t,e){if(!Array.isArray(e))return!1;const n=e.length;if(n!==t.length)return!1;for(let r=0;r<n;r++)if(e[r]!==t[r])return!1;return!0}const oH=Lb.length;function P_(t){if(!t)return;if(!t.isControllingVariants){const n=t.parent?P_(t.parent)||{}:{};return t.props.initial!==void 0&&(n.initial=t.props.initial),n}const e={};for(let n=0;n<oH;n++){const r=Lb[n],s=t.props[r];(df(s)||s===!1)&&(e[r]=s)}return e}const iH=[...Fb].reverse(),aH=Fb.length;function lH(t){return e=>Promise.all(e.map(({animation:n,options:r})=>sH(t,n,r)))}function uH(t){let e=lH(t),n=uI(),r=!0;const s=l=>(c,d)=>{var p;const f=ff(t,d,l==="exit"?(p=t.presenceContext)==null?void 0:p.custom:void 0);if(f){const{transition:g,transitionEnd:y,...x}=f;c={...c,...x,...y}}return c};function o(l){e=l(t)}function i(l){const{props:c}=t,d=P_(t.parent)||{},f=[],p=new Set;let g={},y=1/0;for(let w=0;w<aH;w++){const S=iH[w],$=n[S],I=c[S]!==void 0?c[S]:d[S],R=df(I),_=S===l?$.isActive:null;_===!1&&(y=w);let O=I===d[S]&&I!==c[S]&&R;if(O&&r&&t.manuallyAnimateOnMount&&(O=!1),$.protectedKeys={...g},!$.isActive&&_===null||!I&&!$.prevProp||Qg(I)||typeof I=="boolean")continue;const F=cH($.prevProp,I);let B=F||S===l&&$.isActive&&!O&&R||w>y&&R,M=!1;const V=Array.isArray(I)?I:[I];let P=V.reduce(s(S),{});_===!1&&(P={});const{prevResolvedValues:re={}}=$,ie={...re,...P},me=$e=>{B=!0,p.has($e)&&(M=!0,p.delete($e)),$.needsAnimating[$e]=!0;const fe=t.getValue($e);fe&&(fe.liveStyle=!1)};for(const $e in ie){const fe=P[$e],xe=re[$e];if(g.hasOwnProperty($e))continue;let ae=!1;Mx(fe)&&Mx(xe)?ae=!__(fe,xe):ae=fe!==xe,ae?fe!=null?me($e):p.add($e):fe!==void 0&&p.has($e)?me($e):$.protectedKeys[$e]=!0}$.prevProp=I,$.prevResolvedValues=P,$.isActive&&(g={...g,...P}),r&&t.blockInitialAnimation&&(B=!1),B&&(!(O&&F)||M)&&f.push(...V.map($e=>({animation:$e,options:{type:S}})))}if(p.size){const w={};if(typeof c.initial!="boolean"){const S=ff(t,Array.isArray(c.initial)?c.initial[0]:c.initial);S&&S.transition&&(w.transition=S.transition)}p.forEach(S=>{const $=t.getBaseTarget(S),I=t.getValue(S);I&&(I.liveStyle=!0),w[S]=$??null}),f.push({animation:w})}let x=!!f.length;return r&&(c.initial===!1||c.initial===c.animate)&&!t.manuallyAnimateOnMount&&(x=!1),r=!1,x?e(f):Promise.resolve()}function a(l,c){var f;if(n[l].isActive===c)return Promise.resolve();(f=t.variantChildren)==null||f.forEach(p=>{var g;return(g=p.animationState)==null?void 0:g.setActive(l,c)}),n[l].isActive=c;const d=i(l);for(const p in n)n[p].protectedKeys={};return d}return{animateChanges:i,setActive:a,setAnimateFunction:o,getState:()=>n,reset:()=>{n=uI(),r=!0}}}function cH(t,e){return typeof e=="string"?e!==t:Array.isArray(e)?!__(e,t):!1}function ru(t=!1){return{isActive:t,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function uI(){return{animate:ru(!0),whileInView:ru(),whileHover:ru(),whileTap:ru(),whileDrag:ru(),whileFocus:ru(),exit:ru()}}class wl{constructor(e){this.isMounted=!1,this.node=e}update(){}}class dH extends wl{constructor(e){super(e),e.animationState||(e.animationState=uH(e))}updateAnimationControlsSubscription(){const{animate:e}=this.node.getProps();Qg(e)&&(this.unmountControls=e.subscribe(this.node))}mount(){this.updateAnimationControlsSubscription()}update(){const{animate:e}=this.node.getProps(),{animate:n}=this.node.prevProps||{};e!==n&&this.updateAnimationControlsSubscription()}unmount(){var e;this.node.animationState.reset(),(e=this.unmountControls)==null||e.call(this)}}let hH=0;class fH extends wl{constructor(){super(...arguments),this.id=hH++}update(){if(!this.node.presenceContext)return;const{isPresent:e,onExitComplete:n}=this.node.presenceContext,{isPresent:r}=this.node.prevPresenceContext||{};if(!this.node.animationState||e===r)return;const s=this.node.animationState.setActive("exit",!e);n&&!e&&s.then(()=>{n(this.id)})}mount(){const{register:e,onExitComplete:n}=this.node.presenceContext||{};n&&n(this.id),e&&(this.unmount=e(this.id))}unmount(){}}const pH={animation:{Feature:dH},exit:{Feature:fH}};function pf(t,e,n,r={passive:!0}){return t.addEventListener(e,n,r),()=>t.removeEventListener(e,n)}function Vf(t){return{point:{x:t.pageX,y:t.pageY}}}const mH=t=>e=>Ob(e)&&t(e,Vf(e));function Kh(t,e,n,r){return pf(t,e,mH(n),r)}function A_({top:t,left:e,right:n,bottom:r}){return{x:{min:e,max:n},y:{min:t,max:r}}}function gH({x:t,y:e}){return{top:e.min,right:t.max,bottom:e.max,left:t.min}}function yH(t,e){if(!e)return t;const n=e({x:t.left,y:t.top}),r=e({x:t.right,y:t.bottom});return{top:n.y,left:n.x,bottom:r.y,right:r.x}}const D_=1e-4,xH=1-D_,vH=1+D_,O_=.01,bH=0-O_,wH=0+O_;function Vr(t){return t.max-t.min}function SH(t,e,n){return Math.abs(t-e)<=n}function cI(t,e,n,r=.5){t.origin=r,t.originPoint=pn(e.min,e.max,t.origin),t.scale=Vr(n)/Vr(e),t.translate=pn(n.min,n.max,t.origin)-t.originPoint,(t.scale>=xH&&t.scale<=vH||isNaN(t.scale))&&(t.scale=1),(t.translate>=bH&&t.translate<=wH||isNaN(t.translate))&&(t.translate=0)}function Xh(t,e,n,r){cI(t.x,e.x,n.x,r?r.originX:void 0),cI(t.y,e.y,n.y,r?r.originY:void 0)}function dI(t,e,n){t.min=n.min+e.min,t.max=t.min+Vr(e)}function CH(t,e,n){dI(t.x,e.x,n.x),dI(t.y,e.y,n.y)}function hI(t,e,n){t.min=e.min-n.min,t.max=t.min+Vr(e)}function qh(t,e,n){hI(t.x,e.x,n.x),hI(t.y,e.y,n.y)}const fI=()=>({translate:0,scale:1,origin:0,originPoint:0}),Vc=()=>({x:fI(),y:fI()}),pI=()=>({min:0,max:0}),Cn=()=>({x:pI(),y:pI()});function no(t){return[t("x"),t("y")]}function P1(t){return t===void 0||t===1}function Ux({scale:t,scaleX:e,scaleY:n}){return!P1(t)||!P1(e)||!P1(n)}function iu(t){return Ux(t)||F_(t)||t.z||t.rotate||t.rotateX||t.rotateY||t.skewX||t.skewY}function F_(t){return mI(t.x)||mI(t.y)}function mI(t){return t&&t!=="0%"}function hg(t,e,n){const r=t-n,s=e*r;return n+s}function gI(t,e,n,r,s){return s!==void 0&&(t=hg(t,s,r)),hg(t,n,r)+e}function jx(t,e=0,n=1,r,s){t.min=gI(t.min,e,n,r,s),t.max=gI(t.max,e,n,r,s)}function L_(t,{x:e,y:n}){jx(t.x,e.translate,e.scale,e.originPoint),jx(t.y,n.translate,n.scale,n.originPoint)}const yI=.999999999999,xI=1.0000000000001;function $H(t,e,n,r=!1){const s=n.length;if(!s)return;e.x=e.y=1;let o,i;for(let a=0;a<s;a++){o=n[a],i=o.projectionDelta;const{visualElement:l}=o.options;l&&l.props.style&&l.props.style.display==="contents"||(r&&o.options.layoutScroll&&o.scroll&&o!==o.root&&Uc(t,{x:-o.scroll.offset.x,y:-o.scroll.offset.y}),i&&(e.x*=i.x.scale,e.y*=i.y.scale,L_(t,i)),r&&iu(o.latestValues)&&Uc(t,o.latestValues))}e.x<xI&&e.x>yI&&(e.x=1),e.y<xI&&e.y>yI&&(e.y=1)}function Wc(t,e){t.min=t.min+e,t.max=t.max+e}function vI(t,e,n,r,s=.5){const o=pn(t.min,t.max,s);jx(t,e,n,o,r)}function Uc(t,e){vI(t.x,e.x,e.scaleX,e.scale,e.originX),vI(t.y,e.y,e.scaleY,e.scale,e.originY)}function z_(t,e){return A_(yH(t.getBoundingClientRect(),e))}function kH(t,e,n){const r=z_(t,n),{scroll:s}=e;return s&&(Wc(r.x,s.offset.x),Wc(r.y,s.offset.y)),r}const B_=({current:t})=>t?t.ownerDocument.defaultView:null,bI=(t,e)=>Math.abs(t-e);function TH(t,e){const n=bI(t.x,e.x),r=bI(t.y,e.y);return Math.sqrt(n**2+r**2)}class M_{constructor(e,n,{transformPagePoint:r,contextWindow:s,dragSnapToOrigin:o=!1}={}){if(this.startEvent=null,this.lastMoveEvent=null,this.lastMoveEventInfo=null,this.handlers={},this.contextWindow=window,this.updatePoint=()=>{if(!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const f=D1(this.lastMoveEventInfo,this.history),p=this.startEvent!==null,g=TH(f.offset,{x:0,y:0})>=3;if(!p&&!g)return;const{point:y}=f,{timestamp:x}=ir;this.history.push({...y,timestamp:x});const{onStart:w,onMove:S}=this.handlers;p||(w&&w(this.lastMoveEvent,f),this.startEvent=this.lastMoveEvent),S&&S(this.lastMoveEvent,f)},this.handlePointerMove=(f,p)=>{this.lastMoveEvent=f,this.lastMoveEventInfo=A1(p,this.transformPagePoint),mn.update(this.updatePoint,!0)},this.handlePointerUp=(f,p)=>{this.end();const{onEnd:g,onSessionEnd:y,resumeAnimation:x}=this.handlers;if(this.dragSnapToOrigin&&x&&x(),!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const w=D1(f.type==="pointercancel"?this.lastMoveEventInfo:A1(p,this.transformPagePoint),this.history);this.startEvent&&g&&g(f,w),y&&y(f,w)},!Ob(e))return;this.dragSnapToOrigin=o,this.handlers=n,this.transformPagePoint=r,this.contextWindow=s||window;const i=Vf(e),a=A1(i,this.transformPagePoint),{point:l}=a,{timestamp:c}=ir;this.history=[{...l,timestamp:c}];const{onSessionStart:d}=n;d&&d(e,D1(a,this.history)),this.removeListeners=zf(Kh(this.contextWindow,"pointermove",this.handlePointerMove),Kh(this.contextWindow,"pointerup",this.handlePointerUp),Kh(this.contextWindow,"pointercancel",this.handlePointerUp))}updateHandlers(e){this.handlers=e}end(){this.removeListeners&&this.removeListeners(),ml(this.updatePoint)}}function A1(t,e){return e?{point:e(t.point)}:t}function wI(t,e){return{x:t.x-e.x,y:t.y-e.y}}function D1({point:t},e){return{point:t,delta:wI(t,V_(e)),offset:wI(t,IH(e)),velocity:NH(e,.1)}}function IH(t){return t[0]}function V_(t){return t[t.length-1]}function NH(t,e){if(t.length<2)return{x:0,y:0};let n=t.length-1,r=null;const s=V_(t);for(;n>=0&&(r=t[n],!(s.timestamp-r.timestamp>gi(e)));)n--;if(!r)return{x:0,y:0};const o=yi(s.timestamp-r.timestamp);if(o===0)return{x:0,y:0};const i={x:(s.x-r.x)/o,y:(s.y-r.y)/o};return i.x===1/0&&(i.x=0),i.y===1/0&&(i.y=0),i}function EH(t,{min:e,max:n},r){return e!==void 0&&t<e?t=r?pn(e,t,r.min):Math.max(t,e):n!==void 0&&t>n&&(t=r?pn(n,t,r.max):Math.min(t,n)),t}function SI(t,e,n){return{min:e!==void 0?t.min+e:void 0,max:n!==void 0?t.max+n-(t.max-t.min):void 0}}function RH(t,{top:e,left:n,bottom:r,right:s}){return{x:SI(t.x,n,s),y:SI(t.y,e,r)}}function CI(t,e){let n=e.min-t.min,r=e.max-t.max;return e.max-e.min<t.max-t.min&&([n,r]=[r,n]),{min:n,max:r}}function _H(t,e){return{x:CI(t.x,e.x),y:CI(t.y,e.y)}}function PH(t,e){let n=.5;const r=Vr(t),s=Vr(e);return s>r?n=af(e.min,e.max-r,t.min):r>s&&(n=af(t.min,t.max-s,e.min)),ca(0,1,n)}function AH(t,e){const n={};return e.min!==void 0&&(n.min=e.min-t.min),e.max!==void 0&&(n.max=e.max-t.min),n}const Gx=.35;function DH(t=Gx){return t===!1?t=0:t===!0&&(t=Gx),{x:$I(t,"left","right"),y:$I(t,"top","bottom")}}function $I(t,e,n){return{min:kI(t,e),max:kI(t,n)}}function kI(t,e){return typeof t=="number"?t:t[e]||0}const OH=new WeakMap;class FH{constructor(e){this.openDragLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic=Cn(),this.visualElement=e}start(e,{snapToCursor:n=!1}={}){const{presenceContext:r}=this.visualElement;if(r&&r.isPresent===!1)return;const s=d=>{const{dragSnapToOrigin:f}=this.getProps();f?this.pauseAnimation():this.stopAnimation(),n&&this.snapToCursor(Vf(d).point)},o=(d,f)=>{const{drag:p,dragPropagation:g,onDragStart:y}=this.getProps();if(p&&!g&&(this.openDragLock&&this.openDragLock(),this.openDragLock=Jj(p),!this.openDragLock))return;this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),no(w=>{let S=this.getAxisMotionValue(w).get()||0;if(xi.test(S)){const{projection:$}=this.visualElement;if($&&$.layout){const I=$.layout.layoutBox[w];I&&(S=Vr(I)*(parseFloat(S)/100))}}this.originPoint[w]=S}),y&&mn.postRender(()=>y(d,f)),Vx(this.visualElement,"transform");const{animationState:x}=this.visualElement;x&&x.setActive("whileDrag",!0)},i=(d,f)=>{const{dragPropagation:p,dragDirectionLock:g,onDirectionLock:y,onDrag:x}=this.getProps();if(!p&&!this.openDragLock)return;const{offset:w}=f;if(g&&this.currentDirection===null){this.currentDirection=LH(w),this.currentDirection!==null&&y&&y(this.currentDirection);return}this.updateAxis("x",f.point,w),this.updateAxis("y",f.point,w),this.visualElement.render(),x&&x(d,f)},a=(d,f)=>this.stop(d,f),l=()=>no(d=>{var f;return this.getAnimationState(d)==="paused"&&((f=this.getAxisMotionValue(d).animation)==null?void 0:f.play())}),{dragSnapToOrigin:c}=this.getProps();this.panSession=new M_(e,{onSessionStart:s,onStart:o,onMove:i,onSessionEnd:a,resumeAnimation:l},{transformPagePoint:this.visualElement.getTransformPagePoint(),dragSnapToOrigin:c,contextWindow:B_(this.visualElement)})}stop(e,n){const r=this.isDragging;if(this.cancel(),!r)return;const{velocity:s}=n;this.startAnimation(s);const{onDragEnd:o}=this.getProps();o&&mn.postRender(()=>o(e,n))}cancel(){this.isDragging=!1;const{projection:e,animationState:n}=this.visualElement;e&&(e.isAnimationBlocked=!1),this.panSession&&this.panSession.end(),this.panSession=void 0;const{dragPropagation:r}=this.getProps();!r&&this.openDragLock&&(this.openDragLock(),this.openDragLock=null),n&&n.setActive("whileDrag",!1)}updateAxis(e,n,r){const{drag:s}=this.getProps();if(!r||!ym(e,s,this.currentDirection))return;const o=this.getAxisMotionValue(e);let i=this.originPoint[e]+r[e];this.constraints&&this.constraints[e]&&(i=EH(i,this.constraints[e],this.elastic[e])),o.set(i)}resolveConstraints(){var o;const{dragConstraints:e,dragElastic:n}=this.getProps(),r=this.visualElement.projection&&!this.visualElement.projection.layout?this.visualElement.projection.measure(!1):(o=this.visualElement.projection)==null?void 0:o.layout,s=this.constraints;e&&Mc(e)?this.constraints||(this.constraints=this.resolveRefConstraints()):e&&r?this.constraints=RH(r.layoutBox,e):this.constraints=!1,this.elastic=DH(n),s!==this.constraints&&r&&this.constraints&&!this.hasMutatedConstraints&&no(i=>{this.constraints!==!1&&this.getAxisMotionValue(i)&&(this.constraints[i]=AH(r.layoutBox[i],this.constraints[i]))})}resolveRefConstraints(){const{dragConstraints:e,onMeasureDragConstraints:n}=this.getProps();if(!e||!Mc(e))return!1;const r=e.current,{projection:s}=this.visualElement;if(!s||!s.layout)return!1;const o=kH(r,s.root,this.visualElement.getTransformPagePoint());let i=_H(s.layout.layoutBox,o);if(n){const a=n(gH(i));this.hasMutatedConstraints=!!a,a&&(i=A_(a))}return i}startAnimation(e){const{drag:n,dragMomentum:r,dragElastic:s,dragTransition:o,dragSnapToOrigin:i,onDragTransitionEnd:a}=this.getProps(),l=this.constraints||{},c=no(d=>{if(!ym(d,n,this.currentDirection))return;let f=l&&l[d]||{};i&&(f={min:0,max:0});const p=s?200:1e6,g=s?40:1e7,y={type:"inertia",velocity:r?e[d]:0,bounceStiffness:p,bounceDamping:g,timeConstant:750,restDelta:1,restSpeed:10,...o,...f};return this.startAxisValueAnimation(d,y)});return Promise.all(c).then(a)}startAxisValueAnimation(e,n){const r=this.getAxisMotionValue(e);return Vx(this.visualElement,e),r.start(jb(e,r,0,n,this.visualElement,!1))}stopAnimation(){no(e=>this.getAxisMotionValue(e).stop())}pauseAnimation(){no(e=>{var n;return(n=this.getAxisMotionValue(e).animation)==null?void 0:n.pause()})}getAnimationState(e){var n;return(n=this.getAxisMotionValue(e).animation)==null?void 0:n.state}getAxisMotionValue(e){const n=`_drag${e.toUpperCase()}`,r=this.visualElement.getProps(),s=r[n];return s||this.visualElement.getValue(e,(r.initial?r.initial[e]:void 0)||0)}snapToCursor(e){no(n=>{const{drag:r}=this.getProps();if(!ym(n,r,this.currentDirection))return;const{projection:s}=this.visualElement,o=this.getAxisMotionValue(n);if(s&&s.layout){const{min:i,max:a}=s.layout.layoutBox[n];o.set(e[n]-pn(i,a,.5))}})}scalePositionWithinConstraints(){if(!this.visualElement.current)return;const{drag:e,dragConstraints:n}=this.getProps(),{projection:r}=this.visualElement;if(!Mc(n)||!r||!this.constraints)return;this.stopAnimation();const s={x:0,y:0};no(i=>{const a=this.getAxisMotionValue(i);if(a&&this.constraints!==!1){const l=a.get();s[i]=PH({min:l,max:l},this.constraints[i])}});const{transformTemplate:o}=this.visualElement.getProps();this.visualElement.current.style.transform=o?o({},""):"none",r.root&&r.root.updateScroll(),r.updateLayout(),this.resolveConstraints(),no(i=>{if(!ym(i,e,null))return;const a=this.getAxisMotionValue(i),{min:l,max:c}=this.constraints[i];a.set(pn(l,c,s[i]))})}addListeners(){if(!this.visualElement.current)return;OH.set(this.visualElement,this);const e=this.visualElement.current,n=Kh(e,"pointerdown",l=>{const{drag:c,dragListener:d=!0}=this.getProps();c&&d&&this.start(l)}),r=()=>{const{dragConstraints:l}=this.getProps();Mc(l)&&l.current&&(this.constraints=this.resolveRefConstraints())},{projection:s}=this.visualElement,o=s.addEventListener("measure",r);s&&!s.layout&&(s.root&&s.root.updateScroll(),s.updateLayout()),mn.read(r);const i=pf(window,"resize",()=>this.scalePositionWithinConstraints()),a=s.addEventListener("didUpdate",({delta:l,hasLayoutChanged:c})=>{this.isDragging&&c&&(no(d=>{const f=this.getAxisMotionValue(d);f&&(this.originPoint[d]+=l[d].translate,f.set(f.get()+l[d].translate))}),this.visualElement.render())});return()=>{i(),n(),o(),a&&a()}}getProps(){const e=this.visualElement.getProps(),{drag:n=!1,dragDirectionLock:r=!1,dragPropagation:s=!1,dragConstraints:o=!1,dragElastic:i=Gx,dragMomentum:a=!0}=e;return{...e,drag:n,dragDirectionLock:r,dragPropagation:s,dragConstraints:o,dragElastic:i,dragMomentum:a}}}function ym(t,e,n){return(e===!0||e===t)&&(n===null||n===t)}function LH(t,e=10){let n=null;return Math.abs(t.y)>e?n="y":Math.abs(t.x)>e&&(n="x"),n}class zH extends wl{constructor(e){super(e),this.removeGroupControls=ao,this.removeListeners=ao,this.controls=new FH(e)}mount(){const{dragControls:e}=this.node.getProps();e&&(this.removeGroupControls=e.subscribe(this.controls)),this.removeListeners=this.controls.addListeners()||ao}unmount(){this.removeGroupControls(),this.removeListeners()}}const TI=t=>(e,n)=>{t&&mn.postRender(()=>t(e,n))};class BH extends wl{constructor(){super(...arguments),this.removePointerDownListener=ao}onPointerDown(e){this.session=new M_(e,this.createPanHandlers(),{transformPagePoint:this.node.getTransformPagePoint(),contextWindow:B_(this.node)})}createPanHandlers(){const{onPanSessionStart:e,onPanStart:n,onPan:r,onPanEnd:s}=this.node.getProps();return{onSessionStart:TI(e),onStart:TI(n),onMove:r,onEnd:(o,i)=>{delete this.session,s&&mn.postRender(()=>s(o,i))}}}mount(){this.removePointerDownListener=Kh(this.node.current,"pointerdown",e=>this.onPointerDown(e))}update(){this.session&&this.session.updateHandlers(this.createPanHandlers())}unmount(){this.removePointerDownListener(),this.session&&this.session.end()}}const Um={hasAnimatedSinceResize:!0,hasEverUpdated:!1};function II(t,e){return e.max===e.min?0:t/(e.max-e.min)*100}const vh={correct:(t,e)=>{if(!e.target)return t;if(typeof t=="string")if(rt.test(t))t=parseFloat(t);else return t;const n=II(t,e.target.x),r=II(t,e.target.y);return`${n}% ${r}%`}},MH={correct:(t,{treeScale:e,projectionDelta:n})=>{const r=t,s=gl.parse(t);if(s.length>5)return r;const o=gl.createTransformer(t),i=typeof s[0]!="number"?1:0,a=n.x.scale*e.x,l=n.y.scale*e.y;s[0+i]/=a,s[1+i]/=l;const c=pn(a,l,.5);return typeof s[2+i]=="number"&&(s[2+i]/=c),typeof s[3+i]=="number"&&(s[3+i]/=c),o(s)}};class VH extends J.Component{componentDidMount(){const{visualElement:e,layoutGroup:n,switchLayoutGroup:r,layoutId:s}=this.props,{projection:o}=e;kG(WH),o&&(n.group&&n.group.add(o),r&&r.register&&s&&r.register(o),o.root.didUpdate(),o.addEventListener("animationComplete",()=>{this.safeToRemove()}),o.setOptions({...o.options,onExitComplete:()=>this.safeToRemove()})),Um.hasEverUpdated=!0}getSnapshotBeforeUpdate(e){const{layoutDependency:n,visualElement:r,drag:s,isPresent:o}=this.props,i=r.projection;return i&&(i.isPresent=o,s||e.layoutDependency!==n||n===void 0||e.isPresent!==o?i.willUpdate():this.safeToRemove(),e.isPresent!==o&&(o?i.promote():i.relegate()||mn.postRender(()=>{const a=i.getStack();(!a||!a.members.length)&&this.safeToRemove()}))),null}componentDidUpdate(){const{projection:e}=this.props.visualElement;e&&(e.root.didUpdate(),Db.postRender(()=>{!e.currentAnimation&&e.isLead()&&this.safeToRemove()}))}componentWillUnmount(){const{visualElement:e,layoutGroup:n,switchLayoutGroup:r}=this.props,{projection:s}=e;s&&(s.scheduleCheckAfterUnmount(),n&&n.group&&n.group.remove(s),r&&r.deregister&&r.deregister(s))}safeToRemove(){const{safeToRemove:e}=this.props;e&&e()}render(){return null}}function W_(t){const[e,n]=IR(),r=J.useContext(db);return K.jsx(VH,{...t,layoutGroup:r,switchLayoutGroup:J.useContext(b_),isPresent:e,safeToRemove:n})}const WH={borderRadius:{...vh,applyTo:["borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]},borderTopLeftRadius:vh,borderTopRightRadius:vh,borderBottomLeftRadius:vh,borderBottomRightRadius:vh,boxShadow:MH};function UH(t,e,n){const r=Tr(t)?t:cf(t);return r.start(jb("",r,e,n)),r.animation}function jH(t){return t instanceof SVGElement&&t.tagName!=="svg"}const GH=(t,e)=>t.depth-e.depth;class HH{constructor(){this.children=[],this.isDirty=!1}add(e){gb(this.children,e),this.isDirty=!0}remove(e){yb(this.children,e),this.isDirty=!0}forEach(e){this.isDirty&&this.children.sort(GH),this.isDirty=!1,this.children.forEach(e)}}function KH(t,e){const n=ps.now(),r=({timestamp:s})=>{const o=s-n;o>=e&&(ml(r),t(o-e))};return mn.setup(r,!0),()=>ml(r)}const U_=["TopLeft","TopRight","BottomLeft","BottomRight"],XH=U_.length,NI=t=>typeof t=="string"?parseFloat(t):t,EI=t=>typeof t=="number"||rt.test(t);function qH(t,e,n,r,s,o){s?(t.opacity=pn(0,n.opacity??1,YH(r)),t.opacityExit=pn(e.opacity??1,0,QH(r))):o&&(t.opacity=pn(e.opacity??1,n.opacity??1,r));for(let i=0;i<XH;i++){const a=`border${U_[i]}Radius`;let l=RI(e,a),c=RI(n,a);if(l===void 0&&c===void 0)continue;l||(l=0),c||(c=0),l===0||c===0||EI(l)===EI(c)?(t[a]=Math.max(pn(NI(l),NI(c),r),0),(xi.test(c)||xi.test(l))&&(t[a]+="%")):t[a]=c}(e.rotate||n.rotate)&&(t.rotate=pn(e.rotate||0,n.rotate||0,r))}function RI(t,e){return t[e]!==void 0?t[e]:t.borderRadius}const YH=j_(0,.5,LR),QH=j_(.5,.95,ao);function j_(t,e,n){return r=>r<t?0:r>e?1:n(af(t,e,r))}function _I(t,e){t.min=e.min,t.max=e.max}function Js(t,e){_I(t.x,e.x),_I(t.y,e.y)}function PI(t,e){t.translate=e.translate,t.scale=e.scale,t.originPoint=e.originPoint,t.origin=e.origin}function AI(t,e,n,r,s){return t-=e,t=hg(t,1/n,r),s!==void 0&&(t=hg(t,1/s,r)),t}function ZH(t,e=0,n=1,r=.5,s,o=t,i=t){if(xi.test(e)&&(e=parseFloat(e),e=pn(i.min,i.max,e/100)-i.min),typeof e!="number")return;let a=pn(o.min,o.max,r);t===o&&(a-=e),t.min=AI(t.min,e,n,a,s),t.max=AI(t.max,e,n,a,s)}function DI(t,e,[n,r,s],o,i){ZH(t,e[n],e[r],e[s],e.scale,o,i)}const JH=["x","scaleX","originX"],e9=["y","scaleY","originY"];function OI(t,e,n,r){DI(t.x,e,JH,n?n.x:void 0,r?r.x:void 0),DI(t.y,e,e9,n?n.y:void 0,r?r.y:void 0)}function FI(t){return t.translate===0&&t.scale===1}function G_(t){return FI(t.x)&&FI(t.y)}function LI(t,e){return t.min===e.min&&t.max===e.max}function t9(t,e){return LI(t.x,e.x)&&LI(t.y,e.y)}function zI(t,e){return Math.round(t.min)===Math.round(e.min)&&Math.round(t.max)===Math.round(e.max)}function H_(t,e){return zI(t.x,e.x)&&zI(t.y,e.y)}function BI(t){return Vr(t.x)/Vr(t.y)}function MI(t,e){return t.translate===e.translate&&t.scale===e.scale&&t.originPoint===e.originPoint}class n9{constructor(){this.members=[]}add(e){gb(this.members,e),e.scheduleRender()}remove(e){if(yb(this.members,e),e===this.prevLead&&(this.prevLead=void 0),e===this.lead){const n=this.members[this.members.length-1];n&&this.promote(n)}}relegate(e){const n=this.members.findIndex(s=>e===s);if(n===0)return!1;let r;for(let s=n;s>=0;s--){const o=this.members[s];if(o.isPresent!==!1){r=o;break}}return r?(this.promote(r),!0):!1}promote(e,n){const r=this.lead;if(e!==r&&(this.prevLead=r,this.lead=e,e.show(),r)){r.instance&&r.scheduleRender(),e.scheduleRender(),e.resumeFrom=r,n&&(e.resumeFrom.preserveOpacity=!0),r.snapshot&&(e.snapshot=r.snapshot,e.snapshot.latestValues=r.animationValues||r.latestValues),e.root&&e.root.isUpdating&&(e.isLayoutDirty=!0);const{crossfade:s}=e.options;s===!1&&r.hide()}}exitAnimationComplete(){this.members.forEach(e=>{const{options:n,resumingFrom:r}=e;n.onExitComplete&&n.onExitComplete(),r&&r.options.onExitComplete&&r.options.onExitComplete()})}scheduleRender(){this.members.forEach(e=>{e.instance&&e.scheduleRender(!1)})}removeLeadSnapshot(){this.lead&&this.lead.snapshot&&(this.lead.snapshot=void 0)}}function r9(t,e,n){let r="";const s=t.x.translate/e.x,o=t.y.translate/e.y,i=(n==null?void 0:n.z)||0;if((s||o||i)&&(r=`translate3d(${s}px, ${o}px, ${i}px) `),(e.x!==1||e.y!==1)&&(r+=`scale(${1/e.x}, ${1/e.y}) `),n){const{transformPerspective:c,rotate:d,rotateX:f,rotateY:p,skewX:g,skewY:y}=n;c&&(r=`perspective(${c}px) ${r}`),d&&(r+=`rotate(${d}deg) `),f&&(r+=`rotateX(${f}deg) `),p&&(r+=`rotateY(${p}deg) `),g&&(r+=`skewX(${g}deg) `),y&&(r+=`skewY(${y}deg) `)}const a=t.x.scale*e.x,l=t.y.scale*e.y;return(a!==1||l!==1)&&(r+=`scale(${a}, ${l})`),r||"none"}const O1=["","X","Y","Z"],s9={visibility:"hidden"},VI=1e3;let o9=0;function F1(t,e,n,r){const{latestValues:s}=e;s[t]&&(n[t]=s[t],e.setStaticValue(t,0),r&&(r[t]=0))}function K_(t){if(t.hasCheckedOptimisedAppear=!0,t.root===t)return;const{visualElement:e}=t.options;if(!e)return;const n=E_(e);if(window.MotionHasOptimisedAnimation(n,"transform")){const{layout:s,layoutId:o}=t.options;window.MotionCancelOptimisedAnimation(n,"transform",mn,!(s||o))}const{parent:r}=t;r&&!r.hasCheckedOptimisedAppear&&K_(r)}function X_({attachResizeListener:t,defaultParent:e,measureScroll:n,checkIsScrollRoot:r,resetTransform:s}){return class{constructor(i={},a=e==null?void 0:e()){this.id=o9++,this.animationId=0,this.children=new Set,this.options={},this.isTreeAnimating=!1,this.isAnimationBlocked=!1,this.isLayoutDirty=!1,this.isProjectionDirty=!1,this.isSharedProjectionDirty=!1,this.isTransformDirty=!1,this.updateManuallyBlocked=!1,this.updateBlockedByResize=!1,this.isUpdating=!1,this.isSVG=!1,this.needsReset=!1,this.shouldResetTransform=!1,this.hasCheckedOptimisedAppear=!1,this.treeScale={x:1,y:1},this.eventHandlers=new Map,this.hasTreeAnimated=!1,this.updateScheduled=!1,this.scheduleUpdate=()=>this.update(),this.projectionUpdateScheduled=!1,this.checkUpdateFailed=()=>{this.isUpdating&&(this.isUpdating=!1,this.clearAllSnapshots())},this.updateProjection=()=>{this.projectionUpdateScheduled=!1,this.nodes.forEach(l9),this.nodes.forEach(f9),this.nodes.forEach(p9),this.nodes.forEach(u9)},this.resolvedRelativeTargetAt=0,this.hasProjected=!1,this.isVisible=!0,this.animationProgress=0,this.sharedNodes=new Map,this.latestValues=i,this.root=a?a.root||a:this,this.path=a?[...a.path,a]:[],this.parent=a,this.depth=a?a.depth+1:0;for(let l=0;l<this.path.length;l++)this.path[l].shouldResetTransform=!0;this.root===this&&(this.nodes=new HH)}addEventListener(i,a){return this.eventHandlers.has(i)||this.eventHandlers.set(i,new bb),this.eventHandlers.get(i).add(a)}notifyListeners(i,...a){const l=this.eventHandlers.get(i);l&&l.notify(...a)}hasListeners(i){return this.eventHandlers.has(i)}mount(i,a=this.root.hasTreeAnimated){if(this.instance)return;this.isSVG=jH(i),this.instance=i;const{layoutId:l,layout:c,visualElement:d}=this.options;if(d&&!d.current&&d.mount(i),this.root.nodes.add(this),this.parent&&this.parent.children.add(this),a&&(c||l)&&(this.isLayoutDirty=!0),t){let f;const p=()=>this.root.updateBlockedByResize=!1;t(i,()=>{this.root.updateBlockedByResize=!0,f&&f(),f=KH(p,250),Um.hasAnimatedSinceResize&&(Um.hasAnimatedSinceResize=!1,this.nodes.forEach(UI))})}l&&this.root.registerSharedNode(l,this),this.options.animate!==!1&&d&&(l||c)&&this.addEventListener("didUpdate",({delta:f,hasLayoutChanged:p,hasRelativeLayoutChanged:g,layout:y})=>{if(this.isTreeAnimationBlocked()){this.target=void 0,this.relativeTarget=void 0;return}const x=this.options.transition||d.getDefaultTransition()||v9,{onLayoutAnimationStart:w,onLayoutAnimationComplete:S}=d.getProps(),$=!this.targetLayout||!H_(this.targetLayout,y),I=!p&&g;if(this.options.layoutRoot||this.resumeFrom||I||p&&($||!this.currentAnimation)){this.resumeFrom&&(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0),this.setAnimationOrigin(f,I);const R={...Pb(x,"layout"),onPlay:w,onComplete:S};(d.shouldReduceMotion||this.options.layoutRoot)&&(R.delay=0,R.type=!1),this.startAnimation(R)}else p||UI(this),this.isLead()&&this.options.onExitComplete&&this.options.onExitComplete();this.targetLayout=y})}unmount(){this.options.layoutId&&this.willUpdate(),this.root.nodes.remove(this);const i=this.getStack();i&&i.remove(this),this.parent&&this.parent.children.delete(this),this.instance=void 0,ml(this.updateProjection)}blockUpdate(){this.updateManuallyBlocked=!0}unblockUpdate(){this.updateManuallyBlocked=!1}isUpdateBlocked(){return this.updateManuallyBlocked||this.updateBlockedByResize}isTreeAnimationBlocked(){return this.isAnimationBlocked||this.parent&&this.parent.isTreeAnimationBlocked()||!1}startUpdate(){this.isUpdateBlocked()||(this.isUpdating=!0,this.nodes&&this.nodes.forEach(m9),this.animationId++)}getTransformTemplate(){const{visualElement:i}=this.options;return i&&i.getProps().transformTemplate}willUpdate(i=!0){if(this.root.hasTreeAnimated=!0,this.root.isUpdateBlocked()){this.options.onExitComplete&&this.options.onExitComplete();return}if(window.MotionCancelOptimisedAnimation&&!this.hasCheckedOptimisedAppear&&K_(this),!this.root.isUpdating&&this.root.startUpdate(),this.isLayoutDirty)return;this.isLayoutDirty=!0;for(let d=0;d<this.path.length;d++){const f=this.path[d];f.shouldResetTransform=!0,f.updateScroll("snapshot"),f.options.layoutRoot&&f.willUpdate(!1)}const{layoutId:a,layout:l}=this.options;if(a===void 0&&!l)return;const c=this.getTransformTemplate();this.prevTransformTemplateValue=c?c(this.latestValues,""):void 0,this.updateSnapshot(),i&&this.notifyListeners("willUpdate")}update(){if(this.updateScheduled=!1,this.isUpdateBlocked()){this.unblockUpdate(),this.clearAllSnapshots(),this.nodes.forEach(WI);return}this.isUpdating||this.nodes.forEach(d9),this.isUpdating=!1,this.nodes.forEach(h9),this.nodes.forEach(i9),this.nodes.forEach(a9),this.clearAllSnapshots();const a=ps.now();ir.delta=ca(0,1e3/60,a-ir.timestamp),ir.timestamp=a,ir.isProcessing=!0,I1.update.process(ir),I1.preRender.process(ir),I1.render.process(ir),ir.isProcessing=!1}didUpdate(){this.updateScheduled||(this.updateScheduled=!0,Db.read(this.scheduleUpdate))}clearAllSnapshots(){this.nodes.forEach(c9),this.sharedNodes.forEach(g9)}scheduleUpdateProjection(){this.projectionUpdateScheduled||(this.projectionUpdateScheduled=!0,mn.preRender(this.updateProjection,!1,!0))}scheduleCheckAfterUnmount(){mn.postRender(()=>{this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()})}updateSnapshot(){this.snapshot||!this.instance||(this.snapshot=this.measure(),this.snapshot&&!Vr(this.snapshot.measuredBox.x)&&!Vr(this.snapshot.measuredBox.y)&&(this.snapshot=void 0))}updateLayout(){if(!this.instance||(this.updateScroll(),!(this.options.alwaysMeasureLayout&&this.isLead())&&!this.isLayoutDirty))return;if(this.resumeFrom&&!this.resumeFrom.instance)for(let l=0;l<this.path.length;l++)this.path[l].updateScroll();const i=this.layout;this.layout=this.measure(!1),this.layoutCorrected=Cn(),this.isLayoutDirty=!1,this.projectionDelta=void 0,this.notifyListeners("measure",this.layout.layoutBox);const{visualElement:a}=this.options;a&&a.notify("LayoutMeasure",this.layout.layoutBox,i?i.layoutBox:void 0)}updateScroll(i="measure"){let a=!!(this.options.layoutScroll&&this.instance);if(this.scroll&&this.scroll.animationId===this.root.animationId&&this.scroll.phase===i&&(a=!1),a){const l=r(this.instance);this.scroll={animationId:this.root.animationId,phase:i,isRoot:l,offset:n(this.instance),wasRoot:this.scroll?this.scroll.isRoot:l}}}resetTransform(){if(!s)return;const i=this.isLayoutDirty||this.shouldResetTransform||this.options.alwaysMeasureLayout,a=this.projectionDelta&&!G_(this.projectionDelta),l=this.getTransformTemplate(),c=l?l(this.latestValues,""):void 0,d=c!==this.prevTransformTemplateValue;i&&(a||iu(this.latestValues)||d)&&(s(this.instance,c),this.shouldResetTransform=!1,this.scheduleRender())}measure(i=!0){const a=this.measurePageBox();let l=this.removeElementScroll(a);return i&&(l=this.removeTransform(l)),b9(l),{animationId:this.root.animationId,measuredBox:a,layoutBox:l,latestValues:{},source:this.id}}measurePageBox(){var c;const{visualElement:i}=this.options;if(!i)return Cn();const a=i.measureViewportBox();if(!(((c=this.scroll)==null?void 0:c.wasRoot)||this.path.some(w9))){const{scroll:d}=this.root;d&&(Wc(a.x,d.offset.x),Wc(a.y,d.offset.y))}return a}removeElementScroll(i){var l;const a=Cn();if(Js(a,i),(l=this.scroll)!=null&&l.wasRoot)return a;for(let c=0;c<this.path.length;c++){const d=this.path[c],{scroll:f,options:p}=d;d!==this.root&&f&&p.layoutScroll&&(f.wasRoot&&Js(a,i),Wc(a.x,f.offset.x),Wc(a.y,f.offset.y))}return a}applyTransform(i,a=!1){const l=Cn();Js(l,i);for(let c=0;c<this.path.length;c++){const d=this.path[c];!a&&d.options.layoutScroll&&d.scroll&&d!==d.root&&Uc(l,{x:-d.scroll.offset.x,y:-d.scroll.offset.y}),iu(d.latestValues)&&Uc(l,d.latestValues)}return iu(this.latestValues)&&Uc(l,this.latestValues),l}removeTransform(i){const a=Cn();Js(a,i);for(let l=0;l<this.path.length;l++){const c=this.path[l];if(!c.instance||!iu(c.latestValues))continue;Ux(c.latestValues)&&c.updateSnapshot();const d=Cn(),f=c.measurePageBox();Js(d,f),OI(a,c.latestValues,c.snapshot?c.snapshot.layoutBox:void 0,d)}return iu(this.latestValues)&&OI(a,this.latestValues),a}setTargetDelta(i){this.targetDelta=i,this.root.scheduleUpdateProjection(),this.isProjectionDirty=!0}setOptions(i){this.options={...this.options,...i,crossfade:i.crossfade!==void 0?i.crossfade:!0}}clearMeasurements(){this.scroll=void 0,this.layout=void 0,this.snapshot=void 0,this.prevTransformTemplateValue=void 0,this.targetDelta=void 0,this.target=void 0,this.isLayoutDirty=!1}forceRelativeParentToResolveTarget(){this.relativeParent&&this.relativeParent.resolvedRelativeTargetAt!==ir.timestamp&&this.relativeParent.resolveTargetDelta(!0)}resolveTargetDelta(i=!1){var p;const a=this.getLead();this.isProjectionDirty||(this.isProjectionDirty=a.isProjectionDirty),this.isTransformDirty||(this.isTransformDirty=a.isTransformDirty),this.isSharedProjectionDirty||(this.isSharedProjectionDirty=a.isSharedProjectionDirty);const l=!!this.resumingFrom||this!==a;if(!(i||l&&this.isSharedProjectionDirty||this.isProjectionDirty||(p=this.parent)!=null&&p.isProjectionDirty||this.attemptToResolveRelativeTarget||this.root.updateBlockedByResize))return;const{layout:d,layoutId:f}=this.options;if(!(!this.layout||!(d||f))){if(this.resolvedRelativeTargetAt=ir.timestamp,!this.targetDelta&&!this.relativeTarget){const g=this.getClosestProjectingParent();g&&g.layout&&this.animationProgress!==1?(this.relativeParent=g,this.forceRelativeParentToResolveTarget(),this.relativeTarget=Cn(),this.relativeTargetOrigin=Cn(),qh(this.relativeTargetOrigin,this.layout.layoutBox,g.layout.layoutBox),Js(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}if(!(!this.relativeTarget&&!this.targetDelta)&&(this.target||(this.target=Cn(),this.targetWithTransforms=Cn()),this.relativeTarget&&this.relativeTargetOrigin&&this.relativeParent&&this.relativeParent.target?(this.forceRelativeParentToResolveTarget(),CH(this.target,this.relativeTarget,this.relativeParent.target)):this.targetDelta?(this.resumingFrom?this.target=this.applyTransform(this.layout.layoutBox):Js(this.target,this.layout.layoutBox),L_(this.target,this.targetDelta)):Js(this.target,this.layout.layoutBox),this.attemptToResolveRelativeTarget)){this.attemptToResolveRelativeTarget=!1;const g=this.getClosestProjectingParent();g&&!!g.resumingFrom==!!this.resumingFrom&&!g.options.layoutScroll&&g.target&&this.animationProgress!==1?(this.relativeParent=g,this.forceRelativeParentToResolveTarget(),this.relativeTarget=Cn(),this.relativeTargetOrigin=Cn(),qh(this.relativeTargetOrigin,this.target,g.target),Js(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}}}getClosestProjectingParent(){if(!(!this.parent||Ux(this.parent.latestValues)||F_(this.parent.latestValues)))return this.parent.isProjecting()?this.parent:this.parent.getClosestProjectingParent()}isProjecting(){return!!((this.relativeTarget||this.targetDelta||this.options.layoutRoot)&&this.layout)}calcProjection(){var y;const i=this.getLead(),a=!!this.resumingFrom||this!==i;let l=!0;if((this.isProjectionDirty||(y=this.parent)!=null&&y.isProjectionDirty)&&(l=!1),a&&(this.isSharedProjectionDirty||this.isTransformDirty)&&(l=!1),this.resolvedRelativeTargetAt===ir.timestamp&&(l=!1),l)return;const{layout:c,layoutId:d}=this.options;if(this.isTreeAnimating=!!(this.parent&&this.parent.isTreeAnimating||this.currentAnimation||this.pendingAnimation),this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0),!this.layout||!(c||d))return;Js(this.layoutCorrected,this.layout.layoutBox);const f=this.treeScale.x,p=this.treeScale.y;$H(this.layoutCorrected,this.treeScale,this.path,a),i.layout&&!i.target&&(this.treeScale.x!==1||this.treeScale.y!==1)&&(i.target=i.layout.layoutBox,i.targetWithTransforms=Cn());const{target:g}=i;if(!g){this.prevProjectionDelta&&(this.createProjectionDeltas(),this.scheduleRender());return}!this.projectionDelta||!this.prevProjectionDelta?this.createProjectionDeltas():(PI(this.prevProjectionDelta.x,this.projectionDelta.x),PI(this.prevProjectionDelta.y,this.projectionDelta.y)),Xh(this.projectionDelta,this.layoutCorrected,g,this.latestValues),(this.treeScale.x!==f||this.treeScale.y!==p||!MI(this.projectionDelta.x,this.prevProjectionDelta.x)||!MI(this.projectionDelta.y,this.prevProjectionDelta.y))&&(this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",g))}hide(){this.isVisible=!1}show(){this.isVisible=!0}scheduleRender(i=!0){var a;if((a=this.options.visualElement)==null||a.scheduleRender(),i){const l=this.getStack();l&&l.scheduleRender()}this.resumingFrom&&!this.resumingFrom.instance&&(this.resumingFrom=void 0)}createProjectionDeltas(){this.prevProjectionDelta=Vc(),this.projectionDelta=Vc(),this.projectionDeltaWithTransform=Vc()}setAnimationOrigin(i,a=!1){const l=this.snapshot,c=l?l.latestValues:{},d={...this.latestValues},f=Vc();(!this.relativeParent||!this.relativeParent.options.layoutRoot)&&(this.relativeTarget=this.relativeTargetOrigin=void 0),this.attemptToResolveRelativeTarget=!a;const p=Cn(),g=l?l.source:void 0,y=this.layout?this.layout.source:void 0,x=g!==y,w=this.getStack(),S=!w||w.members.length<=1,$=!!(x&&!S&&this.options.crossfade===!0&&!this.path.some(x9));this.animationProgress=0;let I;this.mixTargetDelta=R=>{const _=R/1e3;jI(f.x,i.x,_),jI(f.y,i.y,_),this.setTargetDelta(f),this.relativeTarget&&this.relativeTargetOrigin&&this.layout&&this.relativeParent&&this.relativeParent.layout&&(qh(p,this.layout.layoutBox,this.relativeParent.layout.layoutBox),y9(this.relativeTarget,this.relativeTargetOrigin,p,_),I&&t9(this.relativeTarget,I)&&(this.isProjectionDirty=!1),I||(I=Cn()),Js(I,this.relativeTarget)),x&&(this.animationValues=d,qH(d,c,this.latestValues,_,$,S)),this.root.scheduleUpdateProjection(),this.scheduleRender(),this.animationProgress=_},this.mixTargetDelta(this.options.layoutRoot?1e3:0)}startAnimation(i){this.notifyListeners("animationStart"),this.currentAnimation&&this.currentAnimation.stop(),this.resumingFrom&&this.resumingFrom.currentAnimation&&this.resumingFrom.currentAnimation.stop(),this.pendingAnimation&&(ml(this.pendingAnimation),this.pendingAnimation=void 0),this.pendingAnimation=mn.update(()=>{Um.hasAnimatedSinceResize=!0,this.currentAnimation=UH(0,VI,{...i,onUpdate:a=>{this.mixTargetDelta(a),i.onUpdate&&i.onUpdate(a)},onStop:()=>{},onComplete:()=>{i.onComplete&&i.onComplete(),this.completeAnimation()}}),this.resumingFrom&&(this.resumingFrom.currentAnimation=this.currentAnimation),this.pendingAnimation=void 0})}completeAnimation(){this.resumingFrom&&(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0);const i=this.getStack();i&&i.exitAnimationComplete(),this.resumingFrom=this.currentAnimation=this.animationValues=void 0,this.notifyListeners("animationComplete")}finishAnimation(){this.currentAnimation&&(this.mixTargetDelta&&this.mixTargetDelta(VI),this.currentAnimation.stop()),this.completeAnimation()}applyTransformsToTarget(){const i=this.getLead();let{targetWithTransforms:a,target:l,layout:c,latestValues:d}=i;if(!(!a||!l||!c)){if(this!==i&&this.layout&&c&&q_(this.options.animationType,this.layout.layoutBox,c.layoutBox)){l=this.target||Cn();const f=Vr(this.layout.layoutBox.x);l.x.min=i.target.x.min,l.x.max=l.x.min+f;const p=Vr(this.layout.layoutBox.y);l.y.min=i.target.y.min,l.y.max=l.y.min+p}Js(a,l),Uc(a,d),Xh(this.projectionDeltaWithTransform,this.layoutCorrected,a,d)}}registerSharedNode(i,a){this.sharedNodes.has(i)||this.sharedNodes.set(i,new n9),this.sharedNodes.get(i).add(a);const c=a.options.initialPromotionConfig;a.promote({transition:c?c.transition:void 0,preserveFollowOpacity:c&&c.shouldPreserveFollowOpacity?c.shouldPreserveFollowOpacity(a):void 0})}isLead(){const i=this.getStack();return i?i.lead===this:!0}getLead(){var a;const{layoutId:i}=this.options;return i?((a=this.getStack())==null?void 0:a.lead)||this:this}getPrevLead(){var a;const{layoutId:i}=this.options;return i?(a=this.getStack())==null?void 0:a.prevLead:void 0}getStack(){const{layoutId:i}=this.options;if(i)return this.root.sharedNodes.get(i)}promote({needsReset:i,transition:a,preserveFollowOpacity:l}={}){const c=this.getStack();c&&c.promote(this,l),i&&(this.projectionDelta=void 0,this.needsReset=!0),a&&this.setOptions({transition:a})}relegate(){const i=this.getStack();return i?i.relegate(this):!1}resetSkewAndRotation(){const{visualElement:i}=this.options;if(!i)return;let a=!1;const{latestValues:l}=i;if((l.z||l.rotate||l.rotateX||l.rotateY||l.rotateZ||l.skewX||l.skewY)&&(a=!0),!a)return;const c={};l.z&&F1("z",i,c,this.animationValues);for(let d=0;d<O1.length;d++)F1(`rotate${O1[d]}`,i,c,this.animationValues),F1(`skew${O1[d]}`,i,c,this.animationValues);i.render();for(const d in c)i.setStaticValue(d,c[d]),this.animationValues&&(this.animationValues[d]=c[d]);i.scheduleRender()}getProjectionStyles(i){if(!this.instance||this.isSVG)return;if(!this.isVisible)return s9;const a={visibility:""},l=this.getTransformTemplate();if(this.needsReset)return this.needsReset=!1,a.opacity="",a.pointerEvents=Wm(i==null?void 0:i.pointerEvents)||"",a.transform=l?l(this.latestValues,""):"none",a;const c=this.getLead();if(!this.projectionDelta||!this.layout||!c.target){const g={};return this.options.layoutId&&(g.opacity=this.latestValues.opacity!==void 0?this.latestValues.opacity:1,g.pointerEvents=Wm(i==null?void 0:i.pointerEvents)||""),this.hasProjected&&!iu(this.latestValues)&&(g.transform=l?l({},""):"none",this.hasProjected=!1),g}const d=c.animationValues||c.latestValues;this.applyTransformsToTarget(),a.transform=r9(this.projectionDeltaWithTransform,this.treeScale,d),l&&(a.transform=l(d,a.transform));const{x:f,y:p}=this.projectionDelta;a.transformOrigin=`${f.origin*100}% ${p.origin*100}% 0`,c.animationValues?a.opacity=c===this?d.opacity??this.latestValues.opacity??1:this.preserveOpacity?this.latestValues.opacity:d.opacityExit:a.opacity=c===this?d.opacity!==void 0?d.opacity:"":d.opacityExit!==void 0?d.opacityExit:0;for(const g in hf){if(d[g]===void 0)continue;const{correct:y,applyTo:x,isCSSVariable:w}=hf[g],S=a.transform==="none"?d[g]:y(d[g],c);if(x){const $=x.length;for(let I=0;I<$;I++)a[x[I]]=S}else w?this.options.visualElement.renderState.vars[g]=S:a[g]=S}return this.options.layoutId&&(a.pointerEvents=c===this?Wm(i==null?void 0:i.pointerEvents)||"":"none"),a}clearSnapshot(){this.resumeFrom=this.snapshot=void 0}resetTree(){this.root.nodes.forEach(i=>{var a;return(a=i.currentAnimation)==null?void 0:a.stop()}),this.root.nodes.forEach(WI),this.root.sharedNodes.clear()}}}function i9(t){t.updateLayout()}function a9(t){var n;const e=((n=t.resumeFrom)==null?void 0:n.snapshot)||t.snapshot;if(t.isLead()&&t.layout&&e&&t.hasListeners("didUpdate")){const{layoutBox:r,measuredBox:s}=t.layout,{animationType:o}=t.options,i=e.source!==t.layout.source;o==="size"?no(f=>{const p=i?e.measuredBox[f]:e.layoutBox[f],g=Vr(p);p.min=r[f].min,p.max=p.min+g}):q_(o,e.layoutBox,r)&&no(f=>{const p=i?e.measuredBox[f]:e.layoutBox[f],g=Vr(r[f]);p.max=p.min+g,t.relativeTarget&&!t.currentAnimation&&(t.isProjectionDirty=!0,t.relativeTarget[f].max=t.relativeTarget[f].min+g)});const a=Vc();Xh(a,r,e.layoutBox);const l=Vc();i?Xh(l,t.applyTransform(s,!0),e.measuredBox):Xh(l,r,e.layoutBox);const c=!G_(a);let d=!1;if(!t.resumeFrom){const f=t.getClosestProjectingParent();if(f&&!f.resumeFrom){const{snapshot:p,layout:g}=f;if(p&&g){const y=Cn();qh(y,e.layoutBox,p.layoutBox);const x=Cn();qh(x,r,g.layoutBox),H_(y,x)||(d=!0),f.options.layoutRoot&&(t.relativeTarget=x,t.relativeTargetOrigin=y,t.relativeParent=f)}}}t.notifyListeners("didUpdate",{layout:r,snapshot:e,delta:l,layoutDelta:a,hasLayoutChanged:c,hasRelativeLayoutChanged:d})}else if(t.isLead()){const{onExitComplete:r}=t.options;r&&r()}t.options.transition=void 0}function l9(t){t.parent&&(t.isProjecting()||(t.isProjectionDirty=t.parent.isProjectionDirty),t.isSharedProjectionDirty||(t.isSharedProjectionDirty=!!(t.isProjectionDirty||t.parent.isProjectionDirty||t.parent.isSharedProjectionDirty)),t.isTransformDirty||(t.isTransformDirty=t.parent.isTransformDirty))}function u9(t){t.isProjectionDirty=t.isSharedProjectionDirty=t.isTransformDirty=!1}function c9(t){t.clearSnapshot()}function WI(t){t.clearMeasurements()}function d9(t){t.isLayoutDirty=!1}function h9(t){const{visualElement:e}=t.options;e&&e.getProps().onBeforeLayoutMeasure&&e.notify("BeforeLayoutMeasure"),t.resetTransform()}function UI(t){t.finishAnimation(),t.targetDelta=t.relativeTarget=t.target=void 0,t.isProjectionDirty=!0}function f9(t){t.resolveTargetDelta()}function p9(t){t.calcProjection()}function m9(t){t.resetSkewAndRotation()}function g9(t){t.removeLeadSnapshot()}function jI(t,e,n){t.translate=pn(e.translate,0,n),t.scale=pn(e.scale,1,n),t.origin=e.origin,t.originPoint=e.originPoint}function GI(t,e,n,r){t.min=pn(e.min,n.min,r),t.max=pn(e.max,n.max,r)}function y9(t,e,n,r){GI(t.x,e.x,n.x,r),GI(t.y,e.y,n.y,r)}function x9(t){return t.animationValues&&t.animationValues.opacityExit!==void 0}const v9={duration:.45,ease:[.4,0,.1,1]},HI=t=>typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().includes(t),KI=HI("applewebkit/")&&!HI("chrome/")?Math.round:ao;function XI(t){t.min=KI(t.min),t.max=KI(t.max)}function b9(t){XI(t.x),XI(t.y)}function q_(t,e,n){return t==="position"||t==="preserve-aspect"&&!SH(BI(e),BI(n),.2)}function w9(t){var e;return t!==t.root&&((e=t.scroll)==null?void 0:e.wasRoot)}const S9=X_({attachResizeListener:(t,e)=>pf(t,"resize",e),measureScroll:()=>({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=>!0}),L1={current:void 0},Y_=X_({measureScroll:t=>({x:t.scrollLeft,y:t.scrollTop}),defaultParent:()=>{if(!L1.current){const t=new S9({});t.mount(window),t.setOptions({layoutScroll:!0}),L1.current=t}return L1.current},resetTransform:(t,e)=>{t.style.transform=e!==void 0?e:"none"},checkIsScrollRoot:t=>window.getComputedStyle(t).position==="fixed"}),C9={pan:{Feature:BH},drag:{Feature:zH,ProjectionNode:Y_,MeasureLayout:W_}};function qI(t,e,n){const{props:r}=t;t.animationState&&r.whileHover&&t.animationState.setActive("whileHover",n==="Start");const s="onHover"+n,o=r[s];o&&mn.postRender(()=>o(e,Vf(e)))}class $9 extends wl{mount(){const{current:e}=this.node;e&&(this.unmount=eG(e,(n,r)=>(qI(this.node,r,"Start"),s=>qI(this.node,s,"End"))))}unmount(){}}class k9 extends wl{constructor(){super(...arguments),this.isActive=!1}onFocus(){let e=!1;try{e=this.node.current.matches(":focus-visible")}catch{e=!0}!e||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}onBlur(){!this.isActive||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}mount(){this.unmount=zf(pf(this.node.current,"focus",()=>this.onFocus()),pf(this.node.current,"blur",()=>this.onBlur()))}unmount(){}}function YI(t,e,n){const{props:r}=t;if(t.current instanceof HTMLButtonElement&&t.current.disabled)return;t.animationState&&r.whileTap&&t.animationState.setActive("whileTap",n==="Start");const s="onTap"+(n==="End"?"":n),o=r[s];o&&mn.postRender(()=>o(e,Vf(e)))}class T9 extends wl{mount(){const{current:e}=this.node;e&&(this.unmount=sG(e,(n,r)=>(YI(this.node,r,"Start"),(s,{success:o})=>YI(this.node,s,o?"End":"Cancel")),{useGlobalTarget:this.node.props.globalTapTarget}))}unmount(){}}const Hx=new WeakMap,z1=new WeakMap,I9=t=>{const e=Hx.get(t.target);e&&e(t)},N9=t=>{t.forEach(I9)};function E9({root:t,...e}){const n=t||document;z1.has(n)||z1.set(n,{});const r=z1.get(n),s=JSON.stringify(e);return r[s]||(r[s]=new IntersectionObserver(N9,{root:t,...e})),r[s]}function R9(t,e,n){const r=E9(e);return Hx.set(t,n),r.observe(t),()=>{Hx.delete(t),r.unobserve(t)}}const _9={some:0,all:1};class P9 extends wl{constructor(){super(...arguments),this.hasEnteredView=!1,this.isInView=!1}startObserver(){this.unmount();const{viewport:e={}}=this.node.getProps(),{root:n,margin:r,amount:s="some",once:o}=e,i={root:n?n.current:void 0,rootMargin:r,threshold:typeof s=="number"?s:_9[s]},a=l=>{const{isIntersecting:c}=l;if(this.isInView===c||(this.isInView=c,o&&!c&&this.hasEnteredView))return;c&&(this.hasEnteredView=!0),this.node.animationState&&this.node.animationState.setActive("whileInView",c);const{onViewportEnter:d,onViewportLeave:f}=this.node.getProps(),p=c?d:f;p&&p(l)};return R9(this.node.current,i,a)}mount(){this.startObserver()}update(){if(typeof IntersectionObserver>"u")return;const{props:e,prevProps:n}=this.node;["amount","margin","root"].some(A9(e,n))&&this.startObserver()}unmount(){}}function A9({viewport:t={}},{viewport:e={}}={}){return n=>t[n]!==e[n]}const D9={inView:{Feature:P9},tap:{Feature:T9},focus:{Feature:k9},hover:{Feature:$9}},O9={layout:{ProjectionNode:Y_,MeasureLayout:W_}},Kx={current:null},Q_={current:!1};function F9(){if(Q_.current=!0,!!fb)if(window.matchMedia){const t=window.matchMedia("(prefers-reduced-motion)"),e=()=>Kx.current=t.matches;t.addListener(e),e()}else Kx.current=!1}const L9=new WeakMap;function z9(t,e,n){for(const r in e){const s=e[r],o=n[r];if(Tr(s))t.addValue(r,s);else if(Tr(o))t.addValue(r,cf(s,{owner:t}));else if(o!==s)if(t.hasValue(r)){const i=t.getValue(r);i.liveStyle===!0?i.jump(s):i.hasAnimated||i.set(s)}else{const i=t.getStaticValue(r);t.addValue(r,cf(i!==void 0?i:s,{owner:t}))}}for(const r in n)e[r]===void 0&&t.removeValue(r);return e}const QI=["AnimationStart","AnimationComplete","Update","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"];class B9{scrapeMotionValuesFromProps(e,n,r){return{}}constructor({parent:e,props:n,presenceContext:r,reducedMotionConfig:s,blockInitialAnimation:o,visualState:i},a={}){this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.KeyframeResolver=_b,this.features={},this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=()=>this.notify("Update",this.latestValues),this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))},this.renderScheduledAt=0,this.scheduleRender=()=>{const p=ps.now();this.renderScheduledAt<p&&(this.renderScheduledAt=p,mn.render(this.render,!1,!0))};const{latestValues:l,renderState:c}=i;this.latestValues=l,this.baseTarget={...l},this.initialValues=n.initial?{...l}:{},this.renderState=c,this.parent=e,this.props=n,this.presenceContext=r,this.depth=e?e.depth+1:0,this.reducedMotionConfig=s,this.options=a,this.blockInitialAnimation=!!o,this.isControllingVariants=Zg(n),this.isVariantNode=x_(n),this.isVariantNode&&(this.variantChildren=new Set),this.manuallyAnimateOnMount=!!(e&&e.current);const{willChange:d,...f}=this.scrapeMotionValuesFromProps(n,{},this);for(const p in f){const g=f[p];l[p]!==void 0&&Tr(g)&&g.set(l[p],!1)}}mount(e){this.current=e,L9.set(e,this),this.projection&&!this.projection.instance&&this.projection.mount(e),this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=this.parent.addVariantChild(this)),this.values.forEach((n,r)=>this.bindToMotionValue(r,n)),Q_.current||F9(),this.shouldReduceMotion=this.reducedMotionConfig==="never"?!1:this.reducedMotionConfig==="always"?!0:Kx.current,this.parent&&this.parent.children.add(this),this.update(this.props,this.presenceContext)}unmount(){this.projection&&this.projection.unmount(),ml(this.notifyUpdate),ml(this.render),this.valueSubscriptions.forEach(e=>e()),this.valueSubscriptions.clear(),this.removeFromVariantTree&&this.removeFromVariantTree(),this.parent&&this.parent.children.delete(this);for(const e in this.events)this.events[e].clear();for(const e in this.features){const n=this.features[e];n&&(n.unmount(),n.isMounted=!1)}this.current=null}bindToMotionValue(e,n){this.valueSubscriptions.has(e)&&this.valueSubscriptions.get(e)();const r=vd.has(e);r&&this.onBindTransform&&this.onBindTransform();const s=n.on("change",a=>{this.latestValues[e]=a,this.props.onUpdate&&mn.preRender(this.notifyUpdate),r&&this.projection&&(this.projection.isTransformDirty=!0)}),o=n.on("renderRequest",this.scheduleRender);let i;window.MotionCheckAppearSync&&(i=window.MotionCheckAppearSync(this,e,n)),this.valueSubscriptions.set(e,()=>{s(),o(),i&&i(),n.owner&&n.stop()})}sortNodePosition(e){return!this.current||!this.sortInstanceNodePosition||this.type!==e.type?0:this.sortInstanceNodePosition(this.current,e.current)}updateFeatures(){let e="animation";for(e in od){const n=od[e];if(!n)continue;const{isEnabled:r,Feature:s}=n;if(!this.features[e]&&s&&r(this.props)&&(this.features[e]=new s(this)),this.features[e]){const o=this.features[e];o.isMounted?o.update():(o.mount(),o.isMounted=!0)}}}triggerBuild(){this.build(this.renderState,this.latestValues,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):Cn()}getStaticValue(e){return this.latestValues[e]}setStaticValue(e,n){this.latestValues[e]=n}update(e,n){(e.transformTemplate||this.props.transformTemplate)&&this.scheduleRender(),this.prevProps=this.props,this.props=e,this.prevPresenceContext=this.presenceContext,this.presenceContext=n;for(let r=0;r<QI.length;r++){const s=QI[r];this.propEventSubscriptions[s]&&(this.propEventSubscriptions[s](),delete this.propEventSubscriptions[s]);const o="on"+s,i=e[o];i&&(this.propEventSubscriptions[s]=this.on(s,i))}this.prevMotionValues=z9(this,this.scrapeMotionValuesFromProps(e,this.prevProps,this),this.prevMotionValues),this.handleChildMotionValue&&this.handleChildMotionValue()}getProps(){return this.props}getVariant(e){return this.props.variants?this.props.variants[e]:void 0}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():void 0}addVariantChild(e){const n=this.getClosestVariantNode();if(n)return n.variantChildren&&n.variantChildren.add(e),()=>n.variantChildren.delete(e)}addValue(e,n){const r=this.values.get(e);n!==r&&(r&&this.removeValue(e),this.bindToMotionValue(e,n),this.values.set(e,n),this.latestValues[e]=n.get())}removeValue(e){this.values.delete(e);const n=this.valueSubscriptions.get(e);n&&(n(),this.valueSubscriptions.delete(e)),delete this.latestValues[e],this.removeValueFromRenderState(e,this.renderState)}hasValue(e){return this.values.has(e)}getValue(e,n){if(this.props.values&&this.props.values[e])return this.props.values[e];let r=this.values.get(e);return r===void 0&&n!==void 0&&(r=cf(n===null?void 0:n,{owner:this}),this.addValue(e,r)),r}readValue(e,n){let r=this.latestValues[e]!==void 0||!this.current?this.latestValues[e]:this.getBaseTargetFromProps(this.props,e)??this.readValueFromInstance(this.current,e,this.options);return r!=null&&(typeof r=="string"&&(NR(r)||ER(r))?r=parseFloat(r):!lG(r)&&gl.test(n)&&(r=d_(e,n)),this.setBaseTarget(e,Tr(r)?r.get():r)),Tr(r)?r.get():r}setBaseTarget(e,n){this.baseTarget[e]=n}getBaseTarget(e){var o;const{initial:n}=this.props;let r;if(typeof n=="string"||typeof n=="object"){const i=Wb(this.props,n,(o=this.presenceContext)==null?void 0:o.custom);i&&(r=i[e])}if(n&&r!==void 0)return r;const s=this.getBaseTargetFromProps(this.props,e);return s!==void 0&&!Tr(s)?s:this.initialValues[e]!==void 0&&r===void 0?void 0:this.baseTarget[e]}on(e,n){return this.events[e]||(this.events[e]=new bb),this.events[e].add(n)}notify(e,...n){this.events[e]&&this.events[e].notify(...n)}}class Z_ extends B9{constructor(){super(...arguments),this.KeyframeResolver=Qj}sortInstanceNodePosition(e,n){return e.compareDocumentPosition(n)&2?1:-1}getBaseTargetFromProps(e,n){return e.style?e.style[n]:void 0}removeValueFromRenderState(e,{vars:n,style:r}){delete n[e],delete r[e]}handleChildMotionValue(){this.childSubscription&&(this.childSubscription(),delete this.childSubscription);const{children:e}=this.props;Tr(e)&&(this.childSubscription=e.on("change",n=>{this.current&&(this.current.textContent=`${n}`)}))}}function J_(t,{style:e,vars:n},r,s){Object.assign(t.style,e,s&&s.getProjectionStyles(r));for(const o in n)t.style.setProperty(o,n[o])}function M9(t){return window.getComputedStyle(t)}class V9 extends Z_{constructor(){super(...arguments),this.type="html",this.renderInstance=J_}readValueFromInstance(e,n){if(vd.has(n))return gj(e,n);{const r=M9(e),s=(Cb(n)?r.getPropertyValue(n):r[n])||0;return typeof s=="string"?s.trim():s}}measureInstanceViewportBox(e,{transformPagePoint:n}){return z_(e,n)}build(e,n,r){Bb(e,n,r.transformTemplate)}scrapeMotionValuesFromProps(e,n,r){return Ub(e,n,r)}}const eP=new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength","startOffset","textLength","lengthAdjust"]);function W9(t,e,n,r){J_(t,e,void 0,r);for(const s in e.attrs)t.setAttribute(eP.has(s)?s:zb(s),e.attrs[s])}class U9 extends Z_{constructor(){super(...arguments),this.type="svg",this.isSVGTag=!1,this.measureInstanceViewportBox=Cn}getBaseTargetFromProps(e,n){return e[n]}readValueFromInstance(e,n){if(vd.has(n)){const r=c_(n);return r&&r.default||0}return n=eP.has(n)?n:zb(n),e.getAttribute(n)}scrapeMotionValuesFromProps(e,n,r){return N_(e,n,r)}build(e,n,r){$_(e,n,this.isSVGTag,r.transformTemplate)}renderInstance(e,n,r,s){W9(e,n,r,s)}mount(e){this.isSVGTag=T_(e.tagName),super.mount(e)}}const j9=(t,e)=>Vb(t)?new U9(e):new V9(e,{allowProjection:t!==J.Fragment}),G9=WG({...pH,...D9,...C9,...O9},j9),Wf=fG(G9),H9=(t,e)=>t.find(n=>n.id===e);function ZI(t,e){const n=tP(t,e),r=n?t[n].findIndex(s=>s.id===e):-1;return{position:n,index:r}}function tP(t,e){for(const[n,r]of Object.entries(t))if(H9(r,e))return n}function K9(t){const e=t.includes("right"),n=t.includes("left");let r="center";return e&&(r="flex-end"),n&&(r="flex-start"),{display:"flex",flexDirection:"column",alignItems:r}}function X9(t){const n=t==="top"||t==="bottom"?"0 auto":void 0,r=t.includes("top")?"env(safe-area-inset-top, 0px)":void 0,s=t.includes("bottom")?"env(safe-area-inset-bottom, 0px)":void 0,o=t.includes("left")?void 0:"env(safe-area-inset-right, 0px)",i=t.includes("right")?void 0:"env(safe-area-inset-left, 0px)";return{position:"fixed",zIndex:"var(--toast-z-index, 5500)",pointerEvents:"none",display:"flex",flexDirection:"column",margin:n,top:r,bottom:s,right:o,left:i}}var q9=/^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,Y9=pR(function(t){return q9.test(t)||t.charCodeAt(0)===111&&t.charCodeAt(1)===110&&t.charCodeAt(2)<91}),Q9=Y9,Z9=function(e){return e!=="theme"},JI=function(e){return typeof e=="string"&&e.charCodeAt(0)>96?Q9:Z9},e3=function(e,n,r){var s;if(n){var o=n.shouldForwardProp;s=e.__emotion_forwardProp&&o?function(i){return e.__emotion_forwardProp(i)&&o(i)}:o}return typeof s!="function"&&r&&(s=e.__emotion_forwardProp),s},J9=function(e){var n=e.cache,r=e.serialized,s=e.isStringTag;return sb(n,r,s),vR(function(){return ob(n,r,s)}),null},e7=function t(e,n){var r=e.__emotion_real===e,s=r&&e.__emotion_base||e,o,i;n!==void 0&&(o=n.label,i=n.target);var a=e3(e,n,r),l=a||JI(s),c=!l("as");return function(){var d=arguments,f=r&&e.__emotion_styles!==void 0?e.__emotion_styles.slice(0):[];if(o!==void 0&&f.push("label:"+o+";"),d[0]==null||d[0].raw===void 0)f.push.apply(f,d);else{var p=d[0];f.push(p[0]);for(var g=d.length,y=1;y<g;y++)f.push(d[y],p[y])}var x=ab(function(w,S,$){var I=c&&w.as||s,R="",_=[],O=w;if(w.theme==null){O={};for(var F in w)O[F]=w[F];O.theme=J.useContext(rd)}typeof w.className=="string"?R=gR(S.registered,_,w.className):w.className!=null&&(R=w.className+" ");var B=Xg(f.concat(_),S.registered,O);R+=S.key+"-"+B.name,i!==void 0&&(R+=" "+i);var M=c&&a===void 0?JI(I):l,V={};for(var P in w)c&&P==="as"||M(P)&&(V[P]=w[P]);return V.className=R,$&&(V.ref=$),J.createElement(J.Fragment,null,J.createElement(J9,{cache:S,serialized:B,isStringTag:typeof I=="string"}),J.createElement(I,V))});return x.displayName=o!==void 0?o:"Styled("+(typeof s=="string"?s:s.displayName||s.name||"Component")+")",x.defaultProps=e.defaultProps,x.__emotion_real=x,x.__emotion_base=s,x.__emotion_styles=f,x.__emotion_forwardProp=a,Object.defineProperty(x,"toString",{value:function(){return"."+i}}),x.withComponent=function(w,S){var $=t(w,ag({},n,S,{shouldForwardProp:e3(x,S,!0)}));return $.apply(void 0,f)},x}},t7=["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","marquee","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr","circle","clipPath","defs","ellipse","foreignObject","g","image","line","linearGradient","mask","path","pattern","polygon","polyline","radialGradient","rect","stop","svg","text","tspan"],Xx=e7.bind(null);t7.forEach(function(t){Xx[t]=Xx(t)});const n7=new Set([...pz,"textStyle","layerStyle","apply","noOfLines","focusBorderColor","errorBorderColor","as","__css","css","sx"]),r7=new Set(["htmlWidth","htmlHeight","htmlSize","htmlTranslate"]);function s7(t){return(r7.has(t)||!n7.has(t))&&t[0]!=="_"}const o7=TL(Xx),i7=({baseStyle:t})=>e=>{const{theme:n,css:r,__css:s,sx:o,...i}=e,[a]=EL(i,gz),l=so(t,e),c=xL({},s,l,Vg(a),o),d=HE(c)(e.theme);return r?[d,r]:d};function B1(t,e){const{baseStyle:n,...r}=e??{};r.shouldForwardProp||(r.shouldForwardProp=s7);const s=i7({baseStyle:n}),o=o7(t,r)(s);return J.forwardRef(function(l,c){const{children:d,...f}=l,{colorMode:p,forced:g}=cb(),y=g?p:void 0;return J.createElement(o,{ref:c,"data-theme":y,...f},d)})}function a7(){const t=new Map;return new Proxy(B1,{apply(e,n,r){return B1(...r)},get(e,n){return t.has(n)||t.set(n,B1(n)),t.get(n)}})}const it=a7(),l7={initial:t=>{const{position:e}=t,n=["top","bottom"].includes(e)?"y":"x";let r=["top-right","bottom-right"].includes(e)?1:-1;return e==="bottom"&&(r=1),{opacity:0,[n]:r*24}},animate:{opacity:1,y:0,x:0,scale:1,transition:{duration:.4,ease:[.4,0,.2,1]}},exit:{opacity:0,scale:.85,transition:{duration:.2,ease:[.4,0,1,1]}}},nP=J.memo(t=>{const{id:e,message:n,onCloseComplete:r,onRequestRemove:s,requestClose:o=!1,position:i="bottom",duration:a=5e3,containerStyle:l,motionVariants:c=l7,toastSpacing:d="0.5rem"}=t,[f,p]=J.useState(a),g=h8();iT(()=>{g||r==null||r()},[g]),iT(()=>{p(a)},[a]);const y=()=>p(null),x=()=>p(a),w=()=>{g&&s()};J.useEffect(()=>{g&&o&&s()},[g,o,s]),OL(w,f);const S=J.useMemo(()=>({pointerEvents:"auto",maxWidth:560,minWidth:300,margin:d,...l}),[l,d]),$=J.useMemo(()=>K9(i),[i]);return K.jsx(Wf.div,{layout:!0,className:"chakra-toast",variants:c,initial:"initial",animate:"animate",exit:"exit",onHoverStart:y,onHoverEnd:x,custom:{position:i},style:$,children:K.jsx(it.div,{role:"status","aria-atomic":"true",className:"chakra-toast__inner",__css:S,children:so(n,{id:e,onClose:w})})})});nP.displayName="ToastComponent";function lt(t){return J.forwardRef(t)}var M1,t3;function u7(){if(t3)return M1;t3=1;var t=typeof Element<"u",e=typeof Map=="function",n=typeof Set=="function",r=typeof ArrayBuffer=="function"&&!!ArrayBuffer.isView;function s(o,i){if(o===i)return!0;if(o&&i&&typeof o=="object"&&typeof i=="object"){if(o.constructor!==i.constructor)return!1;var a,l,c;if(Array.isArray(o)){if(a=o.length,a!=i.length)return!1;for(l=a;l--!==0;)if(!s(o[l],i[l]))return!1;return!0}var d;if(e&&o instanceof Map&&i instanceof Map){if(o.size!==i.size)return!1;for(d=o.entries();!(l=d.next()).done;)if(!i.has(l.value[0]))return!1;for(d=o.entries();!(l=d.next()).done;)if(!s(l.value[1],i.get(l.value[0])))return!1;return!0}if(n&&o instanceof Set&&i instanceof Set){if(o.size!==i.size)return!1;for(d=o.entries();!(l=d.next()).done;)if(!i.has(l.value[0]))return!1;return!0}if(r&&ArrayBuffer.isView(o)&&ArrayBuffer.isView(i)){if(a=o.length,a!=i.length)return!1;for(l=a;l--!==0;)if(o[l]!==i[l])return!1;return!0}if(o.constructor===RegExp)return o.source===i.source&&o.flags===i.flags;if(o.valueOf!==Object.prototype.valueOf&&typeof o.valueOf=="function"&&typeof i.valueOf=="function")return o.valueOf()===i.valueOf();if(o.toString!==Object.prototype.toString&&typeof o.toString=="function"&&typeof i.toString=="function")return o.toString()===i.toString();if(c=Object.keys(o),a=c.length,a!==Object.keys(i).length)return!1;for(l=a;l--!==0;)if(!Object.prototype.hasOwnProperty.call(i,c[l]))return!1;if(t&&o instanceof Element)return!1;for(l=a;l--!==0;)if(!((c[l]==="_owner"||c[l]==="__v"||c[l]==="__o")&&o.$$typeof)&&!s(o[c[l]],i[c[l]]))return!1;return!0}return o!==o&&i!==i}return M1=function(i,a){try{return s(i,a)}catch(l){if((l.message||"").match(/stack|recursion/i))return console.warn("react-fast-compare cannot handle circular refs"),!1;throw l}},M1}var c7=u7();const d7=Af(c7);function rP(){const t=J.useContext(rd);if(!t)throw Error("useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`");return t}function sP(){const t=cb(),e=rP();return{...t,theme:e}}function h7(t,e,n){if(e==null)return e;const r=s=>{var o,i;return(i=(o=t.__cssMap)==null?void 0:o[s])==null?void 0:i.value};return r(e)??r(n)??n}function f7(t,e,n){const r=Array.isArray(e)?e:[e],s=Array.isArray(n)?n:[n];return o=>{const i=s.filter(Boolean),a=r.map((l,c)=>{const d=`${t}.${l}`;return h7(o,d,i[c]??l)});return Array.isArray(e)?a:a[0]}}function oP(t,e={}){const{styleConfig:n,...r}=e,{theme:s,colorMode:o}=sP(),i=t?VE(s,`components.${t}`):void 0,a=n||i,l=oo({theme:s,colorMode:o},(a==null?void 0:a.defaultProps)??{},Vg(Hv(r,["children"])),(d,f)=>d?void 0:f),c=J.useRef({});if(a){const f=Tz(a)(l);d7(c.current,f)||(c.current=f)}return c.current}function Sl(t,e={}){return oP(t,e)}function ba(t,e={}){return oP(t,e)}const n3={path:K.jsxs("g",{stroke:"currentColor",strokeWidth:"1.5",children:[K.jsx("path",{strokeLinecap:"round",fill:"none",d:"M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25"}),K.jsx("path",{fill:"currentColor",strokeLinecap:"round",d:"M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0"}),K.jsx("circle",{fill:"none",strokeMiterlimit:"10",cx:"12",cy:"12",r:"11.25"})]}),viewBox:"0 0 24 24"},wa=lt((t,e)=>{const{as:n,viewBox:r,color:s="currentColor",focusable:o=!1,children:i,className:a,__css:l,...c}=t,d=Lt("chakra-icon",a),f=Sl("Icon",t),p={w:"1em",h:"1em",display:"inline-block",lineHeight:"1em",flexShrink:0,color:s,...l,...f},g={ref:e,focusable:o,className:d,__css:p},y=r??n3.viewBox;if(n&&typeof n!="string")return K.jsx(it.svg,{as:n,...g,...c});const x=i??n3.path;return K.jsx(it.svg,{verticalAlign:"middle",viewBox:y,...g,...c,children:x})});wa.displayName="Icon";function p7(t){return K.jsx(wa,{viewBox:"0 0 24 24",...t,children:K.jsx("path",{fill:"currentColor",d:"M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z"})})}function m7(t){return K.jsx(wa,{viewBox:"0 0 24 24",...t,children:K.jsx("path",{fill:"currentColor",d:"M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z"})})}function r3(t){return K.jsx(wa,{viewBox:"0 0 24 24",...t,children:K.jsx("path",{fill:"currentColor",d:"M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"})})}const g7=Ff({"0%":{transform:"rotate(0deg)"},"100%":{transform:"rotate(360deg)"}}),Uf=lt((t,e)=>{const n=Sl("Spinner",t),{label:r="Loading...",thickness:s="2px",speed:o="0.45s",emptyColor:i="transparent",className:a,...l}=Nr(t),c=Lt("chakra-spinner",a),d={display:"inline-block",borderColor:"currentColor",borderStyle:"solid",borderRadius:"99999px",borderWidth:s,borderBottomColor:i,borderLeftColor:i,animation:`${g7} ${o} linear infinite`,...n};return K.jsx(it.div,{ref:e,__css:d,className:c,...l,children:r&&K.jsx(it.span,{srOnly:!0,children:r})})});Uf.displayName="Spinner";const[y7,Gb]=Kr({name:"AlertContext",hookName:"useAlertContext",providerName:"<Alert />"}),[x7,Hb]=Kr({name:"AlertStylesContext",hookName:"useAlertStyles",providerName:"<Alert />"}),iP={info:{icon:m7,colorScheme:"blue"},warning:{icon:r3,colorScheme:"orange"},success:{icon:p7,colorScheme:"green"},error:{icon:r3,colorScheme:"red"},loading:{icon:Uf,colorScheme:"blue"}};function v7(t){return iP[t].colorScheme}function b7(t){return iP[t].icon}const Kb=lt(function(e,n){const{status:r="info",addRole:s=!0,...o}=Nr(e),i=e.colorScheme??v7(r),a=ba("Alert",{...e,colorScheme:i}),l={width:"100%",display:"flex",alignItems:"center",position:"relative",overflow:"hidden",...a.container};return K.jsx(y7,{value:{status:r},children:K.jsx(x7,{value:a,children:K.jsx(it.div,{"data-status":r,role:s?"alert":void 0,ref:n,...o,className:Lt("chakra-alert",e.className),__css:l})})})});Kb.displayName="Alert";function Xb(t){const{status:e}=Gb(),n=b7(e),r=Hb(),s=e==="loading"?r.spinner:r.icon;return K.jsx(it.span,{display:"inherit","data-status":e,...t,className:Lt("chakra-alert__icon",t.className),__css:s,children:t.children||K.jsx(n,{h:"100%",w:"100%"})})}Xb.displayName="AlertIcon";const aP=lt(function(e,n){const r=Hb(),{status:s}=Gb();return K.jsx(it.div,{ref:n,"data-status":s,...e,className:Lt("chakra-alert__title",e.className),__css:r.title})});aP.displayName="AlertTitle";const lP=lt(function(e,n){const{status:r}=Gb(),s=Hb(),o={display:"inline",...s.description};return K.jsx(it.div,{ref:n,"data-status":r,...e,className:Lt("chakra-alert__desc",e.className),__css:o})});lP.displayName="AlertDescription";function w7(t){return K.jsx(wa,{focusable:"false","aria-hidden":!0,...t,children:K.jsx("path",{fill:"currentColor",d:"M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z"})})}const uP=lt(function(e,n){const r=Sl("CloseButton",e),{children:s,isDisabled:o,__css:i,...a}=Nr(e),l={outline:0,display:"flex",alignItems:"center",justifyContent:"center",flexShrink:0};return K.jsx(it.button,{type:"button","aria-label":"Close",ref:n,disabled:o,__css:{...l,...r,...i},...a,children:s||K.jsx(w7,{width:"1em",height:"1em"})})});uP.displayName="CloseButton";const S7=t=>{const{status:e,variant:n="solid",id:r,title:s,isClosable:o,onClose:i,description:a,colorScheme:l,icon:c}=t,d=r?{root:`toast-${r}`,title:`toast-${r}-title`,description:`toast-${r}-description`}:void 0;return K.jsxs(Kb,{addRole:!1,status:e,variant:n,id:d==null?void 0:d.root,alignItems:"start",borderRadius:"md",boxShadow:"lg",paddingEnd:8,textAlign:"start",width:"auto",colorScheme:l,children:[K.jsx(Xb,{children:c}),K.jsxs(it.div,{flex:"1",maxWidth:"100%",children:[s&&K.jsx(aP,{id:d==null?void 0:d.title,children:s}),a&&K.jsx(lP,{id:d==null?void 0:d.description,display:"block",children:a})]}),o&&K.jsx(uP,{size:"sm",onClick:i,position:"absolute",insetEnd:1,top:1})]})};function cP(t={}){const{render:e,toastComponent:n=S7}=t;return s=>typeof e=="function"?e({...s,...t}):K.jsx(n,{...s,...t})}const C7={top:[],"top-left":[],"top-right":[],"bottom-left":[],bottom:[],"bottom-right":[]},di=$7(C7);function $7(t){let e=t;const n=new Set,r=s=>{e=s(e),n.forEach(o=>o())};return{getState:()=>e,subscribe:s=>(n.add(s),()=>{r(()=>t),n.delete(s)}),removeToast:(s,o)=>{r(i=>({...i,[o]:i[o].filter(a=>a.id!=s)}))},notify:(s,o)=>{const i=k7(s,o),{position:a,id:l}=i;return r(c=>{const f=a.includes("top")?[i,...c[a]??[]]:[...c[a]??[],i];return{...c,[a]:f}}),l},update:(s,o)=>{s&&r(i=>{const a={...i},{position:l,index:c}=ZI(a,s);return l&&c!==-1&&(a[l][c]={...a[l][c],...o,message:cP(o)}),a})},closeAll:({positions:s}={})=>{r(o=>(s??["bottom","bottom-right","bottom-left","top","top-left","top-right"]).reduce((l,c)=>(l[c]=o[c].map(d=>({...d,requestClose:!0})),l),{...o}))},close:s=>{r(o=>{const i=tP(o,s);return i?{...o,[i]:o[i].map(a=>a.id==s?{...a,requestClose:!0}:a)}:o})},isActive:s=>!!ZI(di.getState(),s).position}}let s3=0;function k7(t,e={}){s3+=1;const n=e.id??s3,r=e.position??"bottom";return{id:n,message:t,position:r,duration:e.duration,onCloseComplete:e.onCloseComplete,onRequestRemove:()=>di.removeToast(String(n),r),status:e.status,requestClose:!1,containerStyle:e.containerStyle}}var dP=BE();const[hP,T7]=Kr({strict:!1,name:"PortalContext"}),qb="chakra-portal",I7=".chakra-portal",N7=t=>K.jsx("div",{className:"chakra-portal-zIndex",style:{position:"absolute",zIndex:t.zIndex,top:0,left:0,right:0},children:t.children}),E7=t=>{const{appendToParentPortal:e,children:n}=t,[r,s]=J.useState(null),o=J.useRef(null),[,i]=J.useState({});J.useEffect(()=>i({}),[]);const a=T7(),l=i8();ng(()=>{if(!r)return;const d=r.ownerDocument,f=e?a??d.body:d.body;if(!f)return;o.current=d.createElement("div"),o.current.className=qb,f.appendChild(o.current),i({});const p=o.current;return()=>{f.contains(p)&&f.removeChild(p)}},[r]);const c=l!=null&&l.zIndex?K.jsx(N7,{zIndex:l==null?void 0:l.zIndex,children:n}):n;return o.current?dP.createPortal(K.jsx(hP,{value:o.current,children:c}),o.current):K.jsx("span",{ref:d=>{d&&s(d)}})},R7=t=>{const{children:e,containerRef:n,appendToParentPortal:r}=t,s=n.current,o=s??(typeof window<"u"?document.body:void 0),i=J.useMemo(()=>{const l=s==null?void 0:s.ownerDocument.createElement("div");return l&&(l.className=qb),l},[s]),[,a]=J.useState({});return ng(()=>a({}),[]),ng(()=>{if(!(!i||!o))return o.appendChild(i),()=>{o.removeChild(i)}},[i,o]),o&&i?dP.createPortal(K.jsx(hP,{value:r?i:null,children:e}),i):null};function Jg(t){const e={appendToParentPortal:!0,...t},{containerRef:n,...r}=e;return n?K.jsx(R7,{containerRef:n,...r}):K.jsx(E7,{...r})}Jg.className=qb;Jg.selector=I7;Jg.displayName="Portal";const[_7,P7]=Kr({name:"ToastOptionsContext",strict:!1}),A7=t=>{const e=J.useSyncExternalStore(di.subscribe,di.getState,di.getState),{motionVariants:n,component:r=nP,portalProps:s,animatePresenceProps:o}=t,a=Object.keys(e).map(l=>{const c=e[l];return K.jsx("div",{role:"region","aria-live":"polite","aria-label":`Notifications-${l}`,id:`chakra-toast-manager-${l}`,style:X9(l),children:K.jsx(mb,{...o,initial:!1,children:c.map(d=>K.jsx(r,{motionVariants:n,...d},d.id))})},l)});return K.jsx(Jg,{...s,children:a})},D7=t=>function({children:n,theme:r=t,toastOptions:s,...o}){return K.jsxs(a8,{theme:r,...o,children:[K.jsx(_7,{value:s==null?void 0:s.defaultOptions,children:n}),K.jsx(A7,{...s})]})},O7=D7(aR),o3={easeIn:[.4,0,1,1],easeOut:[0,0,.2,1]},fg={enter:{duration:.2,ease:o3.easeOut},exit:{duration:.1,ease:o3.easeIn}},pg={enter:(t,e)=>({...t,delay:typeof e=="number"?e:e==null?void 0:e.enter}),exit:(t,e)=>({...t,delay:typeof e=="number"?e:e==null?void 0:e.exit})};function F7(t){const{loading:e,src:n,srcSet:r,onLoad:s,onError:o,crossOrigin:i,sizes:a,ignoreFallback:l}=t,[c,d]=J.useState("pending");J.useEffect(()=>{d(n?"loading":"pending")},[n]);const f=J.useRef(null),p=J.useCallback(()=>{if(!n)return;g();const y=new Image;y.src=n,i&&(y.crossOrigin=i),r&&(y.srcset=r),a&&(y.sizes=a),e&&(y.loading=e),y.onload=x=>{g(),d("loaded"),s==null||s(x)},y.onerror=x=>{g(),d("failed"),o==null||o(x)},f.current=y},[n,i,r,a,s,o,e]),g=()=>{f.current&&(f.current.onload=null,f.current.onerror=null,f.current=null)};return ng(()=>{if(!l)return c==="loading"&&p(),()=>{g()}},[c,p,l]),l?"loaded":c}const L7=(t,e)=>t!=="loaded"&&e==="beforeLoadOrError"||t==="failed"&&e==="onError",Ao=it("div");Ao.displayName="Box";const fP=lt(function(e,n){const{size:r,centerContent:s=!0,...o}=e,i=s?{display:"flex",alignItems:"center",justifyContent:"center"}:{};return K.jsx(Ao,{ref:n,boxSize:r,__css:{...i,flexShrink:0,flexGrow:0},...o})});fP.displayName="Square";const pP=lt(function(e,n){const{size:r,...s}=e;return K.jsx(fP,{size:r,ref:n,borderRadius:"9999px",...s})});pP.displayName="Circle";const[PTe,z7]=Kr({strict:!1,name:"ButtonGroupContext"});function Ph(t){const{children:e,className:n,...r}=t,s=J.isValidElement(e)?J.cloneElement(e,{"aria-hidden":!0,focusable:!1}):e,o=Lt("chakra-button__icon",n);return K.jsx(it.span,{display:"inline-flex",alignSelf:"center",flexShrink:0,...r,className:o,children:s})}Ph.displayName="ButtonIcon";function qx(t){const{label:e,placement:n,spacing:r="0.5rem",children:s=K.jsx(Uf,{color:"currentColor",width:"1em",height:"1em"}),className:o,__css:i,...a}=t,l=Lt("chakra-button__spinner",o),c=n==="start"?"marginEnd":"marginStart",d=J.useMemo(()=>({display:"flex",alignItems:"center",position:e?"relative":"absolute",[c]:e?r:0,fontSize:"1em",lineHeight:"normal",...i}),[i,e,c,r]);return K.jsx(it.div,{className:l,...a,__css:d,children:s})}qx.displayName="ButtonSpinner";function B7(t){const[e,n]=J.useState(!t);return{ref:J.useCallback(o=>{o&&n(o.tagName==="BUTTON")},[]),type:e?"button":void 0}}const bd=lt((t,e)=>{const n=z7(),r=Sl("Button",{...n,...t}),{isDisabled:s=n==null?void 0:n.isDisabled,isLoading:o,isActive:i,children:a,leftIcon:l,rightIcon:c,loadingText:d,iconSpacing:f="0.5rem",type:p,spinner:g,spinnerPlacement:y="start",className:x,as:w,shouldWrapChildren:S,...$}=Nr(t),I=J.useMemo(()=>{const F={...r==null?void 0:r._focus,zIndex:1};return{display:"inline-flex",appearance:"none",alignItems:"center",justifyContent:"center",userSelect:"none",position:"relative",whiteSpace:"nowrap",verticalAlign:"middle",outline:"none",...r,...!!n&&{_focus:F}}},[r,n]),{ref:R,type:_}=B7(w),O={rightIcon:c,leftIcon:l,iconSpacing:f,children:a,shouldWrapChildren:S};return K.jsxs(it.button,{disabled:s||o,ref:DL(e,R),as:w,type:p??_,"data-active":ii(i),"data-loading":ii(o),__css:I,className:Lt("chakra-button",x),...$,children:[o&&y==="start"&&K.jsx(qx,{className:"chakra-button__spinner--start",label:d,placement:"start",spacing:f,children:g}),o?d||K.jsx(it.span,{opacity:0,children:K.jsx(i3,{...O})}):K.jsx(i3,{...O}),o&&y==="end"&&K.jsx(qx,{className:"chakra-button__spinner--end",label:d,placement:"end",spacing:f,children:g})]})});bd.displayName="Button";function i3(t){const{leftIcon:e,rightIcon:n,children:r,iconSpacing:s,shouldWrapChildren:o}=t;return o?K.jsxs("span",{style:{display:"contents"},children:[e&&K.jsx(Ph,{marginEnd:s,children:e}),r,n&&K.jsx(Ph,{marginStart:s,children:n})]}):K.jsxs(K.Fragment,{children:[e&&K.jsx(Ph,{marginEnd:s,children:e}),r,n&&K.jsx(Ph,{marginStart:s,children:n})]})}const[M7,mP]=r8("Card"),V7=lt(function(e,n){const{className:r,children:s,direction:o="column",justify:i,align:a,...l}=Nr(e),c=ba("Card",e);return K.jsx(it.div,{ref:n,className:Lt("chakra-card",r),__css:{display:"flex",flexDirection:o,justifyContent:i,alignItems:a,position:"relative",minWidth:0,wordWrap:"break-word",...c.container},...l,children:K.jsx(M7,{value:c,children:s})})}),W7=lt(function(e,n){const{className:r,...s}=e,o=mP();return K.jsx(it.div,{ref:n,className:Lt("chakra-card__body",r),__css:o.body,...s})}),U7=lt(function(e,n){const{className:r,...s}=e,o=mP();return K.jsx(it.div,{ref:n,className:Lt("chakra-card__header",r),__css:o.header,...s})}),gP=it("div",{baseStyle:{display:"flex",alignItems:"center",justifyContent:"center"}});gP.displayName="Center";const j7={horizontal:{insetStart:"50%",transform:"translateX(-50%)"},vertical:{top:"50%",transform:"translateY(-50%)"},both:{insetStart:"50%",top:"50%",transform:"translate(-50%, -50%)"}};lt(function(e,n){const{axis:r="both",...s}=e;return K.jsx(it.div,{ref:n,__css:j7[r],...s,position:"absolute"})});const[G7,yP]=Kr({name:"FormControlStylesContext",errorMessage:`useFormControlStyles returned is 'undefined'. Seems you forgot to wrap the components in "<FormControl />" `}),[H7,wd]=Kr({strict:!1,name:"FormControlContext"});function K7(t){const{id:e,isRequired:n,isInvalid:r,isDisabled:s,isReadOnly:o,...i}=t,a=J.useId(),l=e||`field-${a}`,c=`${l}-label`,d=`${l}-feedback`,f=`${l}-helptext`,[p,g]=J.useState(!1),[y,x]=J.useState(!1),[w,S]=J.useState(!1),$=J.useCallback((F={},B=null)=>({id:f,...F,ref:gx(B,M=>{M&&x(!0)})}),[f]),I=J.useCallback((F={},B=null)=>({...F,ref:B,"data-focus":ii(w),"data-disabled":ii(s),"data-invalid":ii(r),"data-readonly":ii(o),id:F.id!==void 0?F.id:c,htmlFor:F.htmlFor!==void 0?F.htmlFor:l}),[l,s,w,r,o,c]),R=J.useCallback((F={},B=null)=>({id:d,...F,ref:gx(B,M=>{M&&g(!0)}),"aria-live":"polite"}),[d]),_=J.useCallback((F={},B=null)=>({...F,...i,ref:B,role:"group","data-focus":ii(w),"data-disabled":ii(s),"data-invalid":ii(r),"data-readonly":ii(o)}),[i,s,w,r,o]),O=J.useCallback((F={},B=null)=>({...F,ref:B,role:"presentation","aria-hidden":!0,children:F.children||"*"}),[]);return{isRequired:!!n,isInvalid:!!r,isReadOnly:!!o,isDisabled:!!s,isFocused:!!w,onFocus:()=>S(!0),onBlur:()=>S(!1),hasFeedbackText:p,setHasFeedbackText:g,hasHelpText:y,setHasHelpText:x,id:l,labelId:c,feedbackId:d,helpTextId:f,htmlProps:i,getHelpTextProps:$,getErrorMessageProps:R,getRootProps:_,getLabelProps:I,getRequiredIndicatorProps:O}}const xP=lt(function(e,n){const r=ba("Form",e),s=Nr(e),{getRootProps:o,htmlProps:i,...a}=K7(s),l=Lt("chakra-form-control",e.className);return K.jsx(H7,{value:a,children:K.jsx(G7,{value:r,children:K.jsx(it.div,{...o({},n),className:l,__css:r.container})})})});xP.displayName="FormControl";const X7=lt(function(e,n){const r=wd(),s=yP(),o=Lt("chakra-form__helper-text",e.className);return K.jsx(it.div,{...r==null?void 0:r.getHelpTextProps(e,n),__css:s.helperText,className:o})});X7.displayName="FormHelperText";function q7(t){const{isDisabled:e,isInvalid:n,isReadOnly:r,isRequired:s,...o}=Y7(t);return{...o,disabled:e,readOnly:r,required:s,"aria-invalid":i1(n),"aria-required":i1(s),"aria-readonly":i1(r)}}function Y7(t){const e=wd(),{id:n,disabled:r,readOnly:s,required:o,isRequired:i,isInvalid:a,isReadOnly:l,isDisabled:c,onFocus:d,onBlur:f,...p}=t,g=t["aria-describedby"]?[t["aria-describedby"]]:[];return e!=null&&e.hasFeedbackText&&(e!=null&&e.isInvalid)&&g.push(e.feedbackId),e!=null&&e.hasHelpText&&g.push(e.helpTextId),{...p,"aria-describedby":g.join(" ")||void 0,id:n??(e==null?void 0:e.id),isDisabled:r??c??(e==null?void 0:e.isDisabled),isReadOnly:s??l??(e==null?void 0:e.isReadOnly),isRequired:o??i??(e==null?void 0:e.isRequired),isInvalid:a??(e==null?void 0:e.isInvalid),onFocus:rT(e==null?void 0:e.onFocus,d),onBlur:rT(e==null?void 0:e.onBlur,f)}}const jf=lt(function(e,n){const{className:r,centerContent:s,...o}=Nr(e),i=Sl("Container",e);return K.jsx(it.div,{ref:n,className:Lt("chakra-container",r),...o,__css:{...i,...s&&{display:"flex",flexDirection:"column",alignItems:"center"}}})});jf.displayName="Container";function Ah(t){return typeof t=="function"}function Q7(...t){return e=>t.reduce((n,r)=>r(n),e)}const Z7=t=>function(...n){let r=[...n],s=n[n.length-1];return QW(s)&&r.length>1?r=r.slice(0,r.length-1):s=t,Q7(...r.map(o=>i=>Ah(o)?o(i):eK(i,o)))(s)},J7=Z7(aR);function eK(...t){return oo({},...t,vP)}function vP(t,e,n,r){if((Ah(t)||Ah(e))&&Object.prototype.hasOwnProperty.call(r,n))return(...s)=>{const o=Ah(t)?t(...s):t,i=Ah(e)?e(...s):e;return oo({},o,i,vP)};if(Wr(t)&&px(e)||px(t)&&Wr(e))return e}const[tK,nK]=Kr({name:"FormErrorStylesContext",errorMessage:`useFormErrorStyles returned is 'undefined'. Seems you forgot to wrap the components in "<FormError />" `}),bP=lt((t,e)=>{const n=ba("FormError",t),r=Nr(t),s=wd();return s!=null&&s.isInvalid?K.jsx(tK,{value:n,children:K.jsx(it.div,{...s==null?void 0:s.getErrorMessageProps(r,e),className:Lt("chakra-form__error-message",t.className),__css:{display:"flex",alignItems:"center",...n.text}})}):null});bP.displayName="FormErrorMessage";const rK=lt((t,e)=>{const n=nK(),r=wd();if(!(r!=null&&r.isInvalid))return null;const s=Lt("chakra-form__error-icon",t.className);return K.jsx(wa,{ref:e,"aria-hidden":!0,...t,__css:n.icon,className:s,children:K.jsx("path",{fill:"currentColor",d:"M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"})})});rK.displayName="FormErrorIcon";const wP=lt(function(e,n){const r=Sl("FormLabel",e),s=Nr(e),{className:o,children:i,requiredIndicator:a=K.jsx(SP,{}),optionalIndicator:l=null,...c}=s,d=wd(),f=(d==null?void 0:d.getLabelProps(c,n))??{ref:n,...c};return K.jsxs(it.label,{...f,className:Lt("chakra-form__label",s.className),__css:{display:"block",textAlign:"start",...r},children:[i,d!=null&&d.isRequired?a:l]})});wP.displayName="FormLabel";const SP=lt(function(e,n){const r=wd(),s=yP();if(!(r!=null&&r.isRequired))return null;const o=Lt("chakra-form__required-indicator",e.className);return K.jsx(it.span,{...r==null?void 0:r.getRequiredIndicatorProps(e,n),__css:s.requiredIndicator,className:o})});SP.displayName="RequiredIndicator";const CP=lt(function(e,n){const{templateAreas:r,gap:s,rowGap:o,columnGap:i,column:a,row:l,autoFlow:c,autoRows:d,templateRows:f,autoColumns:p,templateColumns:g,...y}=e,x={display:"grid",gridTemplateAreas:r,gridGap:s,gridRowGap:o,gridColumnGap:i,gridAutoColumns:p,gridColumn:a,gridRow:l,gridAutoFlow:c,gridAutoRows:d,gridTemplateRows:f,gridTemplateColumns:g};return K.jsx(it.div,{ref:n,__css:x,...y})});CP.displayName="Grid";const $P=lt(function(e,n){const{columns:r,spacingX:s,spacingY:o,spacing:i,minChildWidth:a,...l}=e,c=rP(),d=a?oK(a,c):iK(r);return K.jsx(CP,{ref:n,gap:i,columnGap:s,rowGap:o,templateColumns:d,...l})});$P.displayName="SimpleGrid";function sK(t){return typeof t=="number"?`${t}px`:t}function oK(t,e){return Kv(t,n=>{const r=f7("sizes",n,sK(n))(e);return n===null?null:`repeat(auto-fit, minmax(${r}, 1fr))`})}function iK(t){return Kv(t,e=>e===null?null:`repeat(${e}, minmax(0, 1fr))`)}const Yx=lt(function(e,n){const{htmlWidth:r,htmlHeight:s,alt:o,...i}=e;return K.jsx("img",{width:r,height:s,ref:n,alt:o,...i})});Yx.displayName="NativeImage";const kP=lt(function(e,n){const{fallbackSrc:r,fallback:s,src:o,srcSet:i,align:a,fit:l,loading:c,ignoreFallback:d,crossOrigin:f,fallbackStrategy:p="beforeLoadOrError",referrerPolicy:g,...y}=e,x=r!==void 0||s!==void 0,w=c!=null||d||!x,S=F7({...e,crossOrigin:f,ignoreFallback:w}),$=L7(S,p),I={ref:n,objectFit:l,objectPosition:a,...w?y:Hv(y,["onError","onLoad"])};return $?s||K.jsx(it.img,{as:Yx,className:"chakra-image__placeholder",src:r,...I}):K.jsx(it.img,{as:Yx,src:o,srcSet:i,crossOrigin:f,loading:c,referrerPolicy:g,className:"chakra-image",...I})});kP.displayName="Image";const Yb=lt(function(e,n){const{htmlSize:r,...s}=e,o=ba("Input",s),i=Nr(s),a=q7(i),l=Lt("chakra-input",e.className);return K.jsx(it.input,{size:r,...a,__css:o.field,ref:n,className:l})});Yb.displayName="Input";Yb.id="Input";const[aK,lK]=Kr({name:"InputGroupStylesContext",errorMessage:`useInputGroupStyles returned is 'undefined'. Seems you forgot to wrap the components in "<InputGroup />" `}),TP=lt(function(e,n){const r=ba("Input",e),{children:s,className:o,...i}=Nr(e),a=Lt("chakra-input__group",o),l={},c=Gv(s),d=r.field;c.forEach(p=>{r&&(d&&p.type.id==="InputLeftElement"&&(l.paddingStart=d.height??d.h),d&&p.type.id==="InputRightElement"&&(l.paddingEnd=d.height??d.h),p.type.id==="InputRightAddon"&&(l.borderEndRadius=0),p.type.id==="InputLeftAddon"&&(l.borderStartRadius=0))});const f=c.map(p=>{var y,x;const g=Vg({size:((y=p.props)==null?void 0:y.size)||e.size,variant:((x=p.props)==null?void 0:x.variant)||e.variant});return p.type.id!=="Input"?J.cloneElement(p,g):J.cloneElement(p,Object.assign(g,l,p.props))});return K.jsx(it.div,{className:a,ref:n,__css:{width:"100%",display:"flex",position:"relative",isolation:"isolate",...r.group},"data-group":!0,...i,children:K.jsx(aK,{value:r,children:f})})});TP.displayName="InputGroup";const uK={left:{marginEnd:"-1px",borderEndRadius:0,borderEndColor:"transparent"},right:{marginStart:"-1px",borderStartRadius:0,borderStartColor:"transparent"}},cK=it("div",{baseStyle:{flex:"0 0 auto",width:"auto",display:"flex",alignItems:"center",whiteSpace:"nowrap"}}),Qb=lt(function(e,n){const{placement:r="left",...s}=e,o=uK[r]??{},i=lK();return K.jsx(cK,{ref:n,...s,__css:{...i.addon,...o}})});Qb.displayName="InputAddon";const IP=lt(function(e,n){return K.jsx(Qb,{ref:n,placement:"left",...e,className:Lt("chakra-input__left-addon",e.className)})});IP.displayName="InputLeftAddon";IP.id="InputLeftAddon";const Zb=lt(function(e,n){return K.jsx(Qb,{ref:n,placement:"right",...e,className:Lt("chakra-input__right-addon",e.className)})});Zb.displayName="InputRightAddon";Zb.id="InputRightAddon";const[dK,NP]=Kr({name:"ListStylesContext",errorMessage:`useListStyles returned is 'undefined'. Seems you forgot to wrap the components in "<List />" `}),ey=lt(function(e,n){const r=ba("List",e),{children:s,styleType:o="none",stylePosition:i,spacing:a,...l}=Nr(e),c=Gv(s),f=a?{["& > *:not(style) ~ *:not(style)"]:{mt:a}}:{};return K.jsx(dK,{value:r,children:K.jsx(it.ul,{ref:n,listStyleType:o,listStylePosition:i,role:"list",__css:{...r.container,...f},...l,children:c})})});ey.displayName="List";const hK=lt((t,e)=>{const{as:n,...r}=t;return K.jsx(ey,{ref:e,as:"ol",styleType:"decimal",marginStart:"1em",...r})});hK.displayName="OrderedList";const fK=lt(function(e,n){const{as:r,...s}=e;return K.jsx(ey,{ref:n,as:"ul",styleType:"initial",marginStart:"1em",...s})});fK.displayName="UnorderedList";const EP=lt(function(e,n){const r=NP();return K.jsx(it.li,{ref:n,...e,__css:r.item})});EP.displayName="ListItem";const au=lt(function(e,n){const r=NP();return K.jsx(wa,{ref:n,role:"presentation",...e,__css:r.icon})});au.displayName="ListIcon";const pK={exit:({reverse:t,initialScale:e,transition:n,transitionEnd:r,delay:s})=>({opacity:0,...t?{scale:e,transitionEnd:r==null?void 0:r.exit}:{transitionEnd:{scale:e,...r==null?void 0:r.exit}},transition:(n==null?void 0:n.exit)??pg.exit(fg.exit,s)}),enter:({transitionEnd:t,transition:e,delay:n})=>({opacity:1,scale:1,transition:(e==null?void 0:e.enter)??pg.enter(fg.enter,n),transitionEnd:t==null?void 0:t.enter})},mK={initial:"exit",animate:"enter",exit:"exit",variants:pK},RP=J.forwardRef(function(e,n){const{unmountOnExit:r,in:s,reverse:o=!0,initialScale:i=.95,className:a,transition:l,transitionEnd:c,delay:d,animatePresenceProps:f,...p}=e,g=r?s&&r:!0,y=s||r?"enter":"exit",x={initialScale:i,reverse:o,transition:l,transitionEnd:c,delay:d};return K.jsx(mb,{...f,custom:x,children:g&&K.jsx(Wf.div,{ref:n,className:Lt("chakra-offset-slide",a),...mK,animate:y,custom:x,...p})})});RP.displayName="ScaleFade";const gK={enter:({transition:t,transitionEnd:e,delay:n}={})=>({opacity:1,transition:(t==null?void 0:t.enter)??pg.enter(fg.enter,n),transitionEnd:e==null?void 0:e.enter}),exit:({transition:t,transitionEnd:e,delay:n}={})=>({opacity:0,transition:(t==null?void 0:t.exit)??pg.exit(fg.exit,n),transitionEnd:e==null?void 0:e.exit})},yK={initial:"exit",animate:"enter",exit:"exit",variants:gK},_P=J.forwardRef(function(e,n){const{unmountOnExit:r,in:s,className:o,transition:i,transitionEnd:a,delay:l,animatePresenceProps:c,...d}=e,f=s||r?"enter":"exit",p=r?s&&r:!0,g={transition:i,transitionEnd:a,delay:l};return K.jsx(mb,{...c,custom:g,children:p&&K.jsx(Wf.div,{ref:n,className:Lt("chakra-fade",o),custom:g,...yK,animate:f,...d})})});_P.displayName="Fade";function xK(t,e,n){return(t-e)*100/(n-e)}Ff({"0%":{strokeDasharray:"1, 400",strokeDashoffset:"0"},"50%":{strokeDasharray:"400, 400",strokeDashoffset:"-100"},"100%":{strokeDasharray:"400, 400",strokeDashoffset:"-260"}});Ff({"0%":{transform:"rotate(0deg)"},"100%":{transform:"rotate(360deg)"}});const vK=Ff({"0%":{left:"-40%"},"100%":{left:"100%"}}),bK=Ff({from:{backgroundPosition:"1rem 0"},to:{backgroundPosition:"0 0"}});function wK(t){const{value:e=0,min:n,max:r,valueText:s,getValueText:o,isIndeterminate:i,role:a="progressbar"}=t,l=xK(e,n,r);return{bind:{"data-indeterminate":i?"":void 0,"aria-valuemax":r,"aria-valuemin":n,"aria-valuenow":i?void 0:e,"aria-valuetext":(()=>{if(e!=null)return typeof o=="function"?o(e,l):s})(),role:a},percent:l,value:e}}const[SK,CK]=Kr({name:"ProgressStylesContext",errorMessage:`useProgressStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Progress />" `}),$K=lt((t,e)=>{const{min:n,max:r,value:s,isIndeterminate:o,role:i,...a}=t,l=wK({value:s,min:n,max:r,isIndeterminate:o,role:i}),d={height:"100%",...CK().filledTrack};return K.jsx(it.div,{ref:e,style:{width:`${l.percent}%`,...a.style},...l.bind,...a,__css:d})}),PP=lt((t,e)=>{var F;const{value:n,min:r=0,max:s=100,hasStripe:o,isAnimated:i,children:a,borderRadius:l,isIndeterminate:c,"aria-label":d,"aria-labelledby":f,"aria-valuetext":p,title:g,role:y,...x}=Nr(t),w=ba("Progress",t),S=l??((F=w.track)==null?void 0:F.borderRadius),$={animation:`${bK} 1s linear infinite`},_={...!c&&o&&i&&$,...c&&{position:"absolute",willChange:"left",minWidth:"50%",animation:`${vK} 1s ease infinite normal none running`}},O={overflow:"hidden",position:"relative",...w.track};return K.jsx(it.div,{ref:e,borderRadius:S,__css:O,...x,children:K.jsxs(SK,{value:w,children:[K.jsx($K,{"aria-label":d,"aria-labelledby":f,"aria-valuetext":p,min:r,max:s,value:n,isIndeterminate:c,css:_,borderRadius:S,title:g,role:y}),a]})})});PP.displayName="Progress";const AP=t=>K.jsx(it.div,{className:"chakra-stack__item",...t,__css:{display:"inline-block",flex:"0 0 auto",minWidth:0,...t.__css}});AP.displayName="StackItem";function kK(t){const{spacing:e,direction:n}=t,r={column:{my:e,mx:0,borderLeftWidth:0,borderBottomWidth:"1px"},"column-reverse":{my:e,mx:0,borderLeftWidth:0,borderBottomWidth:"1px"},row:{mx:e,my:0,borderLeftWidth:"1px",borderBottomWidth:0},"row-reverse":{mx:e,my:0,borderLeftWidth:"1px",borderBottomWidth:0}};return{"&":Kv(n,s=>r[s])}}const DP=lt((t,e)=>{const{isInline:n,direction:r,align:s,justify:o,spacing:i="0.5rem",wrap:a,children:l,divider:c,className:d,shouldWrapChildren:f,...p}=t,g=n?"row":r??"column",y=J.useMemo(()=>kK({spacing:i,direction:g}),[i,g]),x=!!c,w=!f&&!x,S=J.useMemo(()=>{const I=Gv(l);return w?I:I.map((R,_)=>{const O=typeof R.key<"u"?R.key:_,F=_+1===I.length,M=f?K.jsx(AP,{children:R},O):R;if(!x)return M;const V=J.cloneElement(c,{__css:y}),P=F?null:V;return K.jsxs(J.Fragment,{children:[M,P]},O)})},[c,y,x,w,f,l]),$=Lt("chakra-stack",d);return K.jsx(it.div,{ref:e,display:"flex",alignItems:s,justifyContent:o,flexDirection:g,flexWrap:a,gap:x?void 0:i,className:$,...p,children:S})});DP.displayName="Stack";const ia=lt((t,e)=>K.jsx(DP,{align:"center",...t,direction:"column",ref:e}));ia.displayName="VStack";const[TK,OP]=Kr({name:"StatStylesContext",errorMessage:`useStatStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Stat />" `}),FP=lt(function(e,n){const r=ba("Stat",e),s={position:"relative",flex:"1 1 0%",...r.container},{className:o,children:i,...a}=Nr(e);return K.jsx(TK,{value:r,children:K.jsx(it.div,{ref:n,...a,className:Lt("chakra-stat",o),__css:s,children:K.jsx("dl",{children:i})})})});FP.displayName="Stat";const LP=lt(function(e,n){const r=OP();return K.jsx(it.dt,{ref:n,...e,className:Lt("chakra-stat__label",e.className),__css:r.label})});LP.displayName="StatLabel";const zP=lt(function(e,n){const r=OP();return K.jsx(it.dd,{ref:n,...e,className:Lt("chakra-stat__number",e.className),__css:{...r.number,fontFeatureSettings:"pnum",fontVariantNumeric:"proportional-nums"}})});zP.displayName="StatNumber";function IK(t,e){const n=t??"bottom",s={"top-start":{ltr:"top-left",rtl:"top-right"},"top-end":{ltr:"top-right",rtl:"top-left"},"bottom-start":{ltr:"bottom-left",rtl:"bottom-right"},"bottom-end":{ltr:"bottom-right",rtl:"bottom-left"}}[n];return(s==null?void 0:s[e])??n}function NK(t,e){const n=s=>({...e,...s,position:IK((s==null?void 0:s.position)??(e==null?void 0:e.position),t)}),r=s=>{const o=n(s),i=cP(o);return di.notify(i,o)};return r.update=(s,o)=>{di.update(s,n(o))},r.promise=(s,o)=>{const i=r({...o.loading,status:"loading",duration:null});s.then(a=>r.update(i,{status:"success",duration:5e3,...so(o.success,a)})).catch(a=>r.update(i,{status:"error",duration:5e3,...so(o.error,a)}))},r.closeAll=di.closeAll,r.close=di.close,r.isActive=di.isActive,r}function BP(t){const{theme:e}=sP(),n=P7();return J.useMemo(()=>NK(e.direction,{...n,...t}),[t,e.direction,n])}const Sd=lt(function(e,n){const r=Sl("Heading",e),{className:s,...o}=Nr(e);return K.jsx(it.h2,{ref:n,className:Lt("chakra-heading",e.className),...o,__css:r})});Sd.displayName="Heading";const Sr=lt(function(e,n){const r=Sl("Text",e),{className:s,align:o,decoration:i,casing:a,...l}=Nr(e),c=Vg({textAlign:e.align,textDecoration:e.decoration,textTransform:e.casing});return K.jsx(it.p,{ref:n,className:Lt("chakra-text",e.className),...c,...l,__css:r})});Sr.displayName="Text";function EK({onNavigate:t}){const e=()=>{console.log("Start button clicked! Navigating..."),t("INSTRUCTIONS")};return K.jsx(Ao,{textAlign:"center",p:8,minHeight:"80vh",display:"flex",alignItems:"center",justifyContent:"center",children:K.jsxs(ia,{spacing:6,children:[K.jsx(kP,{src:gL,alt:"TapFit Logo",boxSize:"100px"}),K.jsx(Sd,{as:"h1",size:"2xl",children:"Welcome to TapFit!"}),K.jsx(Sr,{fontSize:"lg",maxWidth:"450px",color:"gray.600",children:"Get ready to capture your pose and see relevant measurements."}),K.jsx(bd,{colorScheme:"blue",size:"lg",onClick:e,children:"Start"})]})})}var MP={color:void 0,size:void 0,className:void 0,style:void 0,attr:void 0},a3=sa.createContext&&sa.createContext(MP),RK=["attr","size","title"];function _K(t,e){if(t==null)return{};var n=PK(t,e),r,s;if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(s=0;s<o.length;s++)r=o[s],!(e.indexOf(r)>=0)&&Object.prototype.propertyIsEnumerable.call(t,r)&&(n[r]=t[r])}return n}function PK(t,e){if(t==null)return{};var n={};for(var r in t)if(Object.prototype.hasOwnProperty.call(t,r)){if(e.indexOf(r)>=0)continue;n[r]=t[r]}return n}function mg(){return mg=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},mg.apply(this,arguments)}function l3(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter(function(s){return Object.getOwnPropertyDescriptor(t,s).enumerable})),n.push.apply(n,r)}return n}function gg(t){for(var e=1;e<arguments.length;e++){var n=arguments[e]!=null?arguments[e]:{};e%2?l3(Object(n),!0).forEach(function(r){AK(t,r,n[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):l3(Object(n)).forEach(function(r){Object.defineProperty(t,r,Object.getOwnPropertyDescriptor(n,r))})}return t}function AK(t,e,n){return e=DK(e),e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function DK(t){var e=OK(t,"string");return typeof e=="symbol"?e:e+""}function OK(t,e){if(typeof t!="object"||!t)return t;var n=t[Symbol.toPrimitive];if(n!==void 0){var r=n.call(t,e);if(typeof r!="object")return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return(e==="string"?String:Number)(t)}function VP(t){return t&&t.map((e,n)=>sa.createElement(e.tag,gg({key:n},e.attr),VP(e.child)))}function Qn(t){return e=>sa.createElement(FK,mg({attr:gg({},t.attr)},e),VP(t.child))}function FK(t){var e=n=>{var{attr:r,size:s,title:o}=t,i=_K(t,RK),a=s||n.size||"1em",l;return n.className&&(l=n.className),t.className&&(l=(l?l+" ":"")+t.className),sa.createElement("svg",mg({stroke:"currentColor",fill:"currentColor",strokeWidth:"0"},n.attr,r,i,{className:l,style:gg(gg({color:t.color||n.color},n.style),t.style),height:a,width:a,xmlns:"http://www.w3.org/2000/svg"}),o&&sa.createElement("title",null,o),t.children)};return a3!==void 0?sa.createElement(a3.Consumer,null,n=>e(n)):e(MP)}function LK(t){return Qn({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"48",d:"M244 400 100 256l144-144M120 256h292"},child:[]}]})(t)}function zK(t){return Qn({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"48",d:"m268 112 144 144-144 144m124-144H100"},child:[]}]})(t)}function Qx(t){return Qn({attr:{viewBox:"0 0 512 512"},child:[{tag:"circle",attr:{cx:"256",cy:"56",r:"40",fill:"none",strokeMiterlimit:"10",strokeWidth:"32"},child:[]},{tag:"path",attr:{fill:"none",strokeMiterlimit:"10",strokeWidth:"32",d:"m199.3 295.62-30.4 172.2a24 24 0 0 0 19.5 27.8 23.76 23.76 0 0 0 27.6-19.5l21-119.9v.2s5.2-32.5 17.5-32.5h3.1c12.5 0 17.5 32.5 17.5 32.5v-.1l21 119.9a23.92 23.92 0 1 0 47.1-8.4l-30.4-172.2-4.9-29.7c-2.9-18.1-4.2-47.6.5-59.7 4-10.4 14.13-14.2 23.2-14.2H424a24 24 0 0 0 0-48H88a24 24 0 0 0 0 48h92.5c9.23 0 19.2 3.8 23.2 14.2 4.7 12.1 3.4 41.6.5 59.7z"},child:[]}]})(t)}function BK(t){return Qn({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"m350.54 148.68-26.62-42.06C318.31 100.08 310.62 96 302 96h-92c-8.62 0-16.31 4.08-21.92 10.62l-26.62 42.06C155.85 155.23 148.62 160 140 160H80a32 32 0 0 0-32 32v192a32 32 0 0 0 32 32h352a32 32 0 0 0 32-32V192a32 32 0 0 0-32-32h-59c-8.65 0-16.85-4.77-22.46-11.32z"},child:[]},{tag:"circle",attr:{cx:"256",cy:"272",r:"80",fill:"none",strokeMiterlimit:"10",strokeWidth:"32"},child:[]},{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M124 158v-22h-24v22"},child:[]}]})(t)}function MK(t){return Qn({attr:{viewBox:"0 0 512 512"},child:[{tag:"circle",attr:{cx:"104",cy:"152",r:"56",fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32"},child:[]},{tag:"circle",attr:{cx:"104",cy:"360",r:"56",fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32"},child:[]},{tag:"path",attr:{fill:"none",strokeLinecap:"square",strokeMiterlimit:"10",strokeWidth:"32",d:"m157 175-11 15 37 15s3.46-6.42 7-10z"},child:[]},{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeMiterlimit:"10",strokeWidth:"32",d:"M154.17 334.43 460 162c-2.5-6.7-28-12-64-4-29.12 6.47-121.16 29.05-159.16 56.05C205.85 236.06 227 272 192 298c-25.61 19-44.43 22.82-44.43 22.82zm190.3-56.19L295 306.67c14.23 6.74 65.54 33.27 117 36.33 14.92.89 30 .39 39-6z"},child:[]},{tag:"circle",attr:{cx:"256",cy:"240",r:"32",fill:"none",strokeMiterlimit:"10",strokeWidth:"32"},child:[]}]})(t)}function VK(t){return Qn({attr:{viewBox:"0 0 512 512"},child:[{tag:"circle",attr:{cx:"256",cy:"256",r:"192",fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32"},child:[]}]})(t)}function WK(t){return Qn({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M80 320V144a32 32 0 0 1 32-32h0a32 32 0 0 1 32 32v112m0 0V80a32 32 0 0 1 32-32h0a32 32 0 0 1 32 32v160m64 1V96a32 32 0 0 1 32-32h0a32 32 0 0 1 32 32v224m-128-80V48a32 32 0 0 1 32-32h0a32 32 0 0 1 32 32v192"},child:[]},{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M80 320c0 117.4 64 176 152 176s123.71-39.6 144-88l52.71-144c6.66-18.05 3.64-34.79-11.87-43.6h0c-15.52-8.82-35.91-4.28-44.31 11.68L336 320"},child:[]}]})(t)}function UK(t){return Qn({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeMiterlimit:"10",strokeWidth:"32",d:"M208 208v264a23.73 23.73 0 0 0 24 24h0a23.73 23.73 0 0 0 24-24"},child:[]},{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeMiterlimit:"10",strokeWidth:"32",d:"M256 336v136a23.73 23.73 0 0 0 24 24h0a23.73 23.73 0 0 0 24-24V208"},child:[]},{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeMiterlimit:"10",strokeWidth:"32",d:"M208 192v88a23.72 23.72 0 0 1-24 24h0a23.72 23.72 0 0 1-24-24v-88a48 48 0 0 1 48-48h96a48 48 0 0 1 48 48v88a23.72 23.72 0 0 1-24 24h0a23.72 23.72 0 0 1-24-24v-88"},child:[]},{tag:"circle",attr:{cx:"256",cy:"56",r:"40",fill:"none",strokeLinecap:"round",strokeMiterlimit:"10",strokeWidth:"32"},child:[]}]})(t)}function jK(t){return Qn({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M344 144c-3.92 52.87-44 96-88 96s-84.15-43.12-88-96c-4-55 35-96 88-96s92 42 88 96z"},child:[]},{tag:"path",attr:{fill:"none",strokeMiterlimit:"10",strokeWidth:"32",d:"M256 304c-87 0-175.3 48-191.64 138.6C62.39 453.52 68.57 464 80 464h352c11.44 0 17.62-10.48 15.65-21.4C431.3 352 343 304 256 304z"},child:[]}]})(t)}function GK(t){return Qn({attr:{viewBox:"0 0 512 512"},child:[{tag:"rect",attr:{width:"256",height:"480",x:"128",y:"16",fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",rx:"48",ry:"48"},child:[]},{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M176 16h24a8 8 0 0 1 8 8h0a16 16 0 0 0 16 16h64a16 16 0 0 0 16-16h0a8 8 0 0 1 8-8h24"},child:[]}]})(t)}function Zx(t){return Qn({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M304 96h112v112m-10.23-101.8L111.98 400.02M208 416H96V304"},child:[]}]})(t)}function HK(t){return Qn({attr:{viewBox:"0 0 512 512"},child:[{tag:"rect",attr:{width:"416",height:"416",x:"48",y:"48",fill:"none",strokeLinejoin:"round",strokeWidth:"32",rx:"96"},child:[]},{tag:"path",attr:{fill:"none",strokeLinejoin:"round",strokeWidth:"32",d:"M388.94 151.56c-24.46-22.28-68.72-51.4-132.94-51.4s-108.48 29.12-132.94 51.4a34.66 34.66 0 0 0-3.06 48.08l33.32 39.21a26.07 26.07 0 0 0 33.6 5.21c15.92-9.83 40.91-21.64 69.1-21.64s53.18 11.81 69.1 21.64a26.07 26.07 0 0 0 33.6-5.21L392 199.64a34.66 34.66 0 0 0-3.06-48.08z"},child:[]}]})(t)}function KK(t){return Qn({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M336 448h56a56 56 0 0 0 56-56v-56m0-160v-56a56 56 0 0 0-56-56h-56M176 448h-56a56 56 0 0 1-56-56v-56m0-160v-56a56 56 0 0 1 56-56h56"},child:[]}]})(t)}function WP(t){return Qn({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M314.56 48s-22.78 8-58.56 8-58.56-8-58.56-8a31.94 31.94 0 0 0-10.57 1.8L32 104l16.63 88 48.88 5.52a24 24 0 0 1 21.29 24.58L112 464h288l-6.8-241.9a24 24 0 0 1 21.29-24.58l48.88-5.52L480 104 325.13 49.8a31.94 31.94 0 0 0-10.57-1.8zm18.75 4.66a80 80 0 0 1-154.62 0"},child:[]}]})(t)}function XK(t){return Qn({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M416 448H96a32.09 32.09 0 0 1-32-32V96a32.09 32.09 0 0 1 32-32h320a32.09 32.09 0 0 1 32 32v320a32.09 32.09 0 0 1-32 32z"},child:[]}]})(t)}function qK(t){return Qn({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"m304 48 112 112-112 112m94.87-112H96m112 304L96 352l112-112m-94 112h302"},child:[]}]})(t)}function YK(t){return Qn({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M48 448 256 64l208 384H48z"},child:[]}]})(t)}function u3(t){return Qn({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"m314.21 482.32-56.77-114.74-44.89-57.39a72.82 72.82 0 0 1-10.13-37.05V144h15.67a40.22 40.22 0 0 1 40.23 40.22v183.36M127.9 293.05v-74.52S165.16 144 202.42 144M370.1 274.42 304 231M170.53 478.36 224 400"},child:[]},{tag:"circle",attr:{cx:"258.32",cy:"69.48",r:"37.26",fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32"},child:[]}]})(t)}const $c=Wf(EP);function QK({onNavigate:t}){const e=()=>{console.log("Next button clicked! Navigating to Height Input..."),t("HEIGHT_INPUT")},n={hidden:{opacity:0,y:10},visible:{opacity:1,y:0}};return K.jsx(jf,{maxW:"container.md",py:{base:8,md:12},bg:"gray.50",borderRadius:"md",boxShadow:"sm",children:K.jsxs(ia,{spacing:6,align:"stretch",children:[K.jsx(Sd,{as:"h1",size:"xl",textAlign:"center",color:"teal.600",children:"How to Use TapFit"}),K.jsx(Sr,{textAlign:"center",fontSize:"lg",color:"gray.700",children:"Follow these steps for accurate results:"}),K.jsxs(ey,{spacing:5,px:{base:2,md:4},children:[" ",K.jsxs($c,{display:"flex",alignItems:"start",variants:n,initial:"hidden",animate:"visible",transition:{duration:.3,delay:.1},children:[K.jsx(au,{as:WP,color:"teal.500",w:6,h:6,mt:1,mr:2}),K.jsxs(Ao,{children:[" ",K.jsx(Sr,{as:"span",fontWeight:"bold",color:"teal.700",children:"Preparation: "}),"Wear form-fitting clothing. Ensure good, even lighting without strong shadows. Find a clear space with a plain background if possible."]})]}),K.jsxs($c,{display:"flex",alignItems:"start",variants:n,initial:"hidden",animate:"visible",transition:{duration:.3,delay:.2},children:[K.jsx(au,{as:GK,color:"teal.500",w:6,h:6,mt:1,mr:2}),K.jsxs(Ao,{children:[K.jsx(Sr,{as:"span",fontWeight:"bold",color:"teal.700",children:"Phone Placement: "}),"Place your phone upright on a stable surface (like a table or tripod) around waist height. Ensure the camera lens is clean."]})]}),K.jsxs($c,{display:"flex",alignItems:"start",variants:n,initial:"hidden",animate:"visible",transition:{duration:.3,delay:.3},children:[K.jsx(au,{as:Zx,color:"teal.500",w:6,h:6,mt:1,mr:2}),K.jsxs(Ao,{children:[K.jsx(Sr,{as:"span",fontWeight:"bold",color:"teal.700",children:"Distance: "}),"Stand far enough back so your entire body, from head to toe, is clearly visible within the camera frame."]})]}),K.jsxs($c,{display:"flex",alignItems:"start",variants:n,initial:"hidden",animate:"visible",transition:{duration:.3,delay:.4},children:[K.jsx(au,{as:Qx,color:"teal.500",w:6,h:6,mt:1,mr:2}),K.jsxs(Ao,{children:[K.jsx(Sr,{as:"span",fontWeight:"bold",color:"teal.700",children:"Front Pose: "}),"Stand facing the camera directly. Keep your feet shoulder-width apart, arms relaxed at your sides (not touching your body), and look straight ahead. Hold still."]})]}),K.jsxs($c,{display:"flex",alignItems:"start",variants:n,initial:"hidden",animate:"visible",transition:{duration:.3,delay:.5},children:[K.jsx(au,{as:qK,color:"teal.500",w:6,h:6,mt:1,mr:2}),K.jsxs(Ao,{children:[K.jsx(Sr,{as:"span",fontWeight:"bold",color:"teal.700",children:"Side Pose: "}),"Turn 90 degrees (either left or right, but be consistent if asked again). Stand straight with your feet together, arms relaxed at your sides, and look straight ahead. Hold still."]})]}),K.jsxs($c,{display:"flex",alignItems:"start",variants:n,initial:"hidden",animate:"visible",transition:{duration:.3,delay:.6},children:[K.jsx(au,{as:BK,color:"teal.500",w:6,h:6,mt:1,mr:2}),K.jsxs(Ao,{children:[K.jsx(Sr,{as:"span",fontWeight:"bold",color:"teal.700",children:"Capture: "}),"The app will guide you to capture both poses. You may need to retake if the pose isn't clear or your full body isn't visible."]})]})]}),K.jsx(bd,{colorScheme:"green",size:"lg",onClick:e,alignSelf:"center",mt:4,_hover:{bg:"green.600",transform:"translateY(-2px)",boxShadow:"lg"},children:"Next"})]})})}const ZK=Wf(Ao);function JK({onNavigate:t}){const[e,n]=J.useState(""),[r,s]=J.useState(""),o=BP(),i=c=>{n(c.target.value),r&&s("")},a=()=>{const c=parseFloat(e);if(!e||isNaN(c)){s("Please enter your height.");return}if(c<140||c>180){console.log(`Validation failed: ${c} is out of range (140-180)`),s("Height must be between 140 cm and 180 cm.");return}s(""),console.log("Height submitted:",c),localStorage.setItem("userHeight",c.toString()),o({title:"Height Saved.",description:`Your height is set to ${c} cm.`,status:"success",duration:3e3,isClosable:!0}),t("CAMERA")},l={hidden:{opacity:0,y:20},visible:{opacity:1,y:0,transition:{duration:.5}}};return K.jsx(jf,{maxW:"container.sm",py:{base:8,md:12},display:"flex",alignItems:"center",minHeight:"80vh",children:K.jsx(ZK,{bg:"white",p:{base:6,md:8},boxShadow:"md",borderRadius:"lg",width:"100%",variants:l,initial:"hidden",animate:"visible",children:K.jsxs(ia,{spacing:5,align:"stretch",children:[" ",K.jsx(wa,{as:HK,boxSize:{base:"40px",md:"50px"},color:"blue.500",alignSelf:"center",mb:-1}),K.jsx(Sd,{as:"h1",size:"lg",textAlign:"center",children:"Enter Your Height"}),K.jsx(Sr,{textAlign:"center",color:"gray.600",children:"Please enter your height in centimeters (cm). This is required for measurement analysis."}),K.jsxs(xP,{isInvalid:!!r,id:"height-input",children:[K.jsx(wP,{children:"Height"}),K.jsxs(TP,{children:[K.jsx(Yb,{type:"number",placeholder:"e.g., 165",value:e,onChange:i,min:"140",max:"180"}),K.jsx(Zb,{children:"cm"})]}),r&&K.jsx(bP,{children:r})]}),K.jsx(bd,{colorScheme:"blue",size:"lg",onClick:a,mt:4,rightIcon:K.jsx(zK,{}),children:"Next: Capture Pose"})]})})})}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eX=1e-7,tX=1e-4;class UP{constructor(e,n){this.backend=e,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,n){this.dataIdsCount++,this.data.set(e,n)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Jb{refCount(e){return us("refCount")}incRef(e){return us("incRef")}timerAvailable(){return!0}time(e){return us("time")}read(e){return us("read")}readSync(e){return us("readSync")}readToGPU(e,n){return us("readToGPU")}numDataIds(){return us("numDataIds")}disposeData(e,n){return us("disposeData")}write(e,n,r){return us("write")}move(e,n,r,s,o){return us("move")}createTensorFromGPUData(e,n,r){return us("createTensorFromGPUData")}memory(){return us("memory")}floatPrecision(){return us("floatPrecision")}epsilon(){return this.floatPrecision()===32?eX:tX}dispose(){return us("dispose")}}function us(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yg(t,e,n){return Math.max(t,Math.min(e,n))}function ew(t){return t%2===0?t:t+1}function bh(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function jP(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function z(t,e){if(!t)throw new Error(typeof e=="string"?e:e())}function xs(t,e,n=""){z(Vt(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function Cd(t){z(t!=null,()=>"The input to the tensor constructor must be a non-null value.")}function pe(t){if(t.length===0)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function c3(t){return t.length===0}function nX(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==null&&e[n]!==null&&t[n]!==e[n])return!1;return!0}function Vt(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function id(t){return t%1===0}function Jx(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function Yc(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function d3(t,e=s=>0,n,r){return new Promise((s,o)=>{let i=0;const a=()=>{if(t()){s();return}i++;const l=e(i);if(n!=null&&i>=n){o();return}r!=null?r(a,l):setTimeout(a,l)};a()})}function GP(t,e){let n=1,r=-1;for(let o=0;o<t.length;++o)if(t[o]>=0)n*=t[o];else if(t[o]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(t[o]<0)throw Error(`Shapes can not be < 0. Found ${t[o]} at dim ${o}`);if(r===-1){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(n===0)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const s=t.slice();return s[r]=e/n,s}function nn(t,e){const n=e.length;return t=t==null?e.map((r,s)=>s):[].concat(t),z(t.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),z(t.every(r=>id(r)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(r=>r<0?n+r:r)}function Cl(t,e){const n=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,o=e==null||s?null:nn(e,t).sort();let i=0;for(let a=0;a<t.length;++a){if(o!=null){if(o[i]===a&&t[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${t[a]}' is not 1`);(o[i]==null||o[i]>a)&&t[a]===1&&(n.push(t[a]),r.push(a)),o[i]<=a&&i++}t[a]!==1&&(n.push(t[a]),r.push(a))}return{newShape:n,keptDims:r}}function Si(t,e){return En(t,e)}function En(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else if(t==="string")n=new Array(e);else throw new Error(`Unknown data type ${t}`);return n}function rX(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function sX(t){return t==="bool"||t==="complex64"||t==="float32"||t==="int32"||t==="string"}function HP(t,e){return!(e==="complex64"||e==="float32"&&t!=="complex64"||e==="int32"&&t!=="float32"&&t!=="complex64"||e==="bool"&&t==="bool")}function xg(t){if(t==="float32"||t==="int32")return 4;if(t==="complex64")return 8;if(t==="bool")return 1;throw new Error(`Unknown dtype ${t}`)}function oX(t){if(t==null)return 0;let e=0;return t.forEach(n=>e+=n.length),e}function Gf(t){return typeof t=="string"||t instanceof String}function iX(t){return typeof t=="boolean"}function aX(t){return typeof t=="number"}function $d(t){return Array.isArray(t)?$d(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":aX(t)?"float32":Gf(t)?"string":iX(t)?"bool":"float32"}function ev(t){return!!(t&&t.constructor&&t.call&&t.apply)}function tv(t,e){for(let n=e;n<t;++n)if(t%n===0)return n;return t}function gn(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function KP(t,e,n,r=!1){const s=new Array;if(e.length===1){const o=e[0]*(r?2:1);for(let i=0;i<o;i++)s[i]=n[t+i]}else{const o=e[0],i=e.slice(1),a=i.reduce((l,c)=>l*c)*(r?2:1);for(let l=0;l<o;l++)s[l]=KP(t+l*a,i,n,r)}return s}function nv(t,e,n=!1){if(t.length===0)return e[0];const r=t.reduce((s,o)=>s*o)*(n?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return KP(0,t,e,n)}function V1(t,e){if(Array.isArray(t))return t;if(e==="float32")return t instanceof Float32Array?t:new Float32Array(t);if(e==="int32")return t instanceof Int32Array?t:new Int32Array(t);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(t));throw new Error(`Unknown dtype ${e}`)}function XP(t,e){const n=ha(t,e);for(let r=0;r<n.length;r++)n[r]=1;return n}function ha(t,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool")return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function Fs(t){t.forEach(e=>{z(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function rv(t,e,n){if(e===0)return 0;if(e===1)return t[0];let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=n[s]*t[s];return r}function tw(t,e,n){if(e===0)return[];if(e===1)return[t];const r=new Array(e);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(t/n[s]),t-=r[s]*n[s];return r[r.length-1]=t,r}function Ru(t){return t&&t.then&&typeof t.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h3="tfjsflags";class lX{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=uX,this.populateURLFlags()}setPlatform(e,n){this.platform!=null&&(se().getBool("IS_TEST")||se().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=n}registerFlag(e,n,r){if(this.flagRegistry[e]={evaluationFn:n,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];se().getBool("IS_TEST")||se().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const n=this.evaluateFlag(e);if(Ru(n))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=n,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,n){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=n,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(n)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);h3 in e&&e[h3].split(",").forEach(r=>{const[s,o]=r.split(":");this.urlFlags[s]=dX(s,o)})}}function uX(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(cX(e,r[0],r[1]),r.join("="))),e}function cX(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}function dX(t,e){const n=e.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:e}function se(){return qP}let qP=null;function hX(t){qP=t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let W1;function YP(){if(W1==null){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else if(typeof self<"u")t=self;else throw new Error("Could not find a global object");W1=t}return W1}function fX(){const t=YP();return t._tfGlobals==null&&(t._tfGlobals=new Map),t._tfGlobals}function nw(t,e){const n=fX();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const rw="Abs",sw="Acos",ow="Acosh",ty="Add",iw="AddN",aw="All",lw="Any",uw="ArgMax",cw="ArgMin",dw="Asin",hw="Asinh",fw="Atan",pw="Atanh",mw="Atan2",gw="AvgPool",QP="AvgPoolGrad",yw="AvgPool3D",ZP="AvgPool3DGrad",xw="BatchMatMul",vw="BatchToSpaceND",bw="Bincount",JP="BitwiseAnd",ww="BroadcastArgs",ny="Cast",Sw="Ceil",Cw="ClipByValue",$w="Complex",kw="ComplexAbs",Tw="Concat",Iw="Conv2D",Nw="Conv2DBackpropFilter",Ew="Conv2DBackpropInput",Rw="Conv3D",eA="Conv3DBackpropFilterV2",_w="Conv3DBackpropInputV2",Pw="Cos",Aw="Cosh",Dw="Cumprod",Ow="Cumsum",Fw="CropAndResize",Lw="DenseBincount",zw="DepthToSpace",Bw="DepthwiseConv2dNative",Mw="DepthwiseConv2dNativeBackpropFilter",Vw="DepthwiseConv2dNativeBackpropInput",Ww="Diag",Uw="Dilation2D",pX="Dilation2DBackpropInput",mX="Dilation2DBackpropFilter",tA="Draw",jw="RealDiv",Gw="Einsum",Hw="Elu",nA="EluGrad",Kw="Erf",Xw="Equal",qw="Exp",Yw="ExpandDims",Qw="Expm1",Zw="FFT",Jw="Fill",e2="FlipLeftRight",t2="Floor",n2="FloorDiv",r2="FusedBatchNorm",s2="GatherV2",o2="GatherNd",i2="Greater",a2="GreaterEqual",ry="Identity",l2="IFFT",u2="Imag",c2="IsFinite",d2="IsInf",h2="IsNan",f2="LeakyRelu",p2="Less",m2="LessEqual",g2="LinSpace",y2="Log",x2="Log1p",v2="LogicalAnd",b2="LogicalNot",w2="LogicalOr",S2="LRN",rA="LRNGrad",C2="Max",$2="Maximum",k2="MaxPool",sA="MaxPoolGrad",T2="MaxPool3D",oA="MaxPool3DGrad",I2="MaxPoolWithArgmax",N2="Mean",E2="Min",R2="Minimum",_2="MirrorPad",P2="Mod",A2="Multinomial",D2="Multiply",O2="Neg",F2="NotEqual",L2="NonMaxSuppressionV3",iA="NonMaxSuppressionV4",z2="NonMaxSuppressionV5",B2="OnesLike",M2="OneHot",V2="Pack",W2="PadV2",U2="Pow",j2="Prelu",G2="Prod",aA="RaggedGather",lA="RaggedRange",uA="RaggedTensorToTensor",H2="Range",K2="Real",X2="Reciprocal",q2="Relu",Y2="Reshape",Q2="ResizeNearestNeighbor",cA="ResizeNearestNeighborGrad",Z2="ResizeBilinear",dA="ResizeBilinearGrad",J2="Relu6",eS="Reverse",tS="Round",nS="Rsqrt",rS="ScatterNd",sS="TensorScatterUpdate",oS="SearchSorted",iS="Select",aS="Selu",lS="Slice",uS="Sin",cS="Sinh",dS="Sign",hS="Sigmoid",fS="Softplus",pS="Sqrt",mS="Sum",gS="SpaceToBatchND",yS="SplitV",xS="Softmax",hA="SparseFillEmptyRows",fA="SparseReshape",vS="SparseSegmentMean",bS="SparseSegmentSum",wS="SparseToDense",SS="SquaredDifference",pA="Square",mA="StaticRegexReplace",CS="StridedSlice",$S="StringNGrams",gA="StringSplit",yA="StringToHashBucketFast",kS="Sub",TS="Tan",IS="Tanh",sy="Tile",NS="TopK",ES="Transform",Yh="Transpose",xA="Unique",RS="Unpack",_S="UnsortedSegmentSum",PS="ZerosLike",AS="Step",vg="FromPixels",DS="RotateWithOffset",bg="_FusedMatMul",wg="FusedConv2D",Sg="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lo(...t){se().getBool("IS_TEST")||se().getBool("PROD")||console.warn(...t)}function gX(...t){se().getBool("IS_TEST")||se().getBool("PROD")||console.log(...t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cg=nw("kernelRegistry",()=>new Map),yX=nw("gradRegistry",()=>new Map);function $g(t,e){const n=bA(t,e);return Cg.get(n)}function f3(t){return yX.get(t)}function p3(t){const e=Cg.entries(),n=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[o,i]=s,[a]=o.split("_");a===t&&n.push(i)}return n}function vA(t){const{kernelName:e,backendName:n}=t,r=bA(e,n);Cg.has(r)&&Lo(`The kernel '${e}' for backend '${n}' is already registered`),Cg.set(r,t)}function bA(t,e){return`${e}_${t}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wA(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}var U1,m3;function xX(){if(m3)return U1;m3=1,U1=e;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(V,P,re){this.low=V|0,this.high=P|0,this.unsigned=!!re}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function n(V){return(V&&V.__isLong__)===!0}e.isLong=n;var r={},s={};function o(V,P){var re,ie,me;return P?(V>>>=0,(me=0<=V&&V<256)&&(ie=s[V],ie)?ie:(re=a(V,(V|0)<0?-1:0,!0),me&&(s[V]=re),re)):(V|=0,(me=-128<=V&&V<128)&&(ie=r[V],ie)?ie:(re=a(V,V<0?-1:0,!1),me&&(r[V]=re),re))}e.fromInt=o;function i(V,P){if(isNaN(V))return P?$:S;if(P){if(V<0)return $;if(V>=y)return F}else{if(V<=-9223372036854776e3)return B;if(V+1>=x)return O}return V<0?i(-V,P).neg():a(V%g|0,V/g|0,P)}e.fromNumber=i;function a(V,P,re){return new e(V,P,re)}e.fromBits=a;var l=Math.pow;function c(V,P,re){if(V.length===0)throw Error("empty string");if(V==="NaN"||V==="Infinity"||V==="+Infinity"||V==="-Infinity")return S;if(typeof P=="number"?(re=P,P=!1):P=!!P,re=re||10,re<2||36<re)throw RangeError("radix");var ie;if((ie=V.indexOf("-"))>0)throw Error("interior hyphen");if(ie===0)return c(V.substring(1),P,re).neg();for(var me=i(l(re,8)),ge=S,ve=0;ve<V.length;ve+=8){var $e=Math.min(8,V.length-ve),fe=parseInt(V.substring(ve,ve+$e),re);if($e<8){var xe=i(l(re,$e));ge=ge.mul(xe).add(i(fe))}else ge=ge.mul(me),ge=ge.add(i(fe))}return ge.unsigned=P,ge}e.fromString=c;function d(V,P){return typeof V=="number"?i(V,P):typeof V=="string"?c(V,P):a(V.low,V.high,typeof P=="boolean"?P:V.unsigned)}e.fromValue=d;var f=65536,p=1<<24,g=f*f,y=g*g,x=y/2,w=o(p),S=o(0);e.ZERO=S;var $=o(0,!0);e.UZERO=$;var I=o(1);e.ONE=I;var R=o(1,!0);e.UONE=R;var _=o(-1);e.NEG_ONE=_;var O=a(-1,2147483647,!1);e.MAX_VALUE=O;var F=a(-1,-1,!0);e.MAX_UNSIGNED_VALUE=F;var B=a(0,-2147483648,!1);e.MIN_VALUE=B;var M=e.prototype;return M.toInt=function(){return this.unsigned?this.low>>>0:this.low},M.toNumber=function(){return this.unsigned?(this.high>>>0)*g+(this.low>>>0):this.high*g+(this.low>>>0)},M.toString=function(P){if(P=P||10,P<2||36<P)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(B)){var re=i(P),ie=this.div(re),me=ie.mul(re).sub(this);return ie.toString(P)+me.toInt().toString(P)}else return"-"+this.neg().toString(P);for(var ge=i(l(P,6),this.unsigned),ve=this,$e="";;){var fe=ve.div(ge),xe=ve.sub(fe.mul(ge)).toInt()>>>0,ae=xe.toString(P);if(ve=fe,ve.isZero())return ae+$e;for(;ae.length<6;)ae="0"+ae;$e=""+ae+$e}},M.getHighBits=function(){return this.high},M.getHighBitsUnsigned=function(){return this.high>>>0},M.getLowBits=function(){return this.low},M.getLowBitsUnsigned=function(){return this.low>>>0},M.getNumBitsAbs=function(){if(this.isNegative())return this.eq(B)?64:this.neg().getNumBitsAbs();for(var P=this.high!=0?this.high:this.low,re=31;re>0&&(P&1<<re)==0;re--);return this.high!=0?re+33:re+1},M.isZero=function(){return this.high===0&&this.low===0},M.eqz=M.isZero,M.isNegative=function(){return!this.unsigned&&this.high<0},M.isPositive=function(){return this.unsigned||this.high>=0},M.isOdd=function(){return(this.low&1)===1},M.isEven=function(){return(this.low&1)===0},M.equals=function(P){return n(P)||(P=d(P)),this.unsigned!==P.unsigned&&this.high>>>31===1&&P.high>>>31===1?!1:this.high===P.high&&this.low===P.low},M.eq=M.equals,M.notEquals=function(P){return!this.eq(P)},M.neq=M.notEquals,M.ne=M.notEquals,M.lessThan=function(P){return this.comp(P)<0},M.lt=M.lessThan,M.lessThanOrEqual=function(P){return this.comp(P)<=0},M.lte=M.lessThanOrEqual,M.le=M.lessThanOrEqual,M.greaterThan=function(P){return this.comp(P)>0},M.gt=M.greaterThan,M.greaterThanOrEqual=function(P){return this.comp(P)>=0},M.gte=M.greaterThanOrEqual,M.ge=M.greaterThanOrEqual,M.compare=function(P){if(n(P)||(P=d(P)),this.eq(P))return 0;var re=this.isNegative(),ie=P.isNegative();return re&&!ie?-1:!re&&ie?1:this.unsigned?P.high>>>0>this.high>>>0||P.high===this.high&&P.low>>>0>this.low>>>0?-1:1:this.sub(P).isNegative()?-1:1},M.comp=M.compare,M.negate=function(){return!this.unsigned&&this.eq(B)?B:this.not().add(I)},M.neg=M.negate,M.add=function(P){n(P)||(P=d(P));var re=this.high>>>16,ie=this.high&65535,me=this.low>>>16,ge=this.low&65535,ve=P.high>>>16,$e=P.high&65535,fe=P.low>>>16,xe=P.low&65535,ae=0,q=0,ue=0,we=0;return we+=ge+xe,ue+=we>>>16,we&=65535,ue+=me+fe,q+=ue>>>16,ue&=65535,q+=ie+$e,ae+=q>>>16,q&=65535,ae+=re+ve,ae&=65535,a(ue<<16|we,ae<<16|q,this.unsigned)},M.subtract=function(P){return n(P)||(P=d(P)),this.add(P.neg())},M.sub=M.subtract,M.multiply=function(P){if(this.isZero())return S;if(n(P)||(P=d(P)),t){var re=t.mul(this.low,this.high,P.low,P.high);return a(re,t.get_high(),this.unsigned)}if(P.isZero())return S;if(this.eq(B))return P.isOdd()?B:S;if(P.eq(B))return this.isOdd()?B:S;if(this.isNegative())return P.isNegative()?this.neg().mul(P.neg()):this.neg().mul(P).neg();if(P.isNegative())return this.mul(P.neg()).neg();if(this.lt(w)&&P.lt(w))return i(this.toNumber()*P.toNumber(),this.unsigned);var ie=this.high>>>16,me=this.high&65535,ge=this.low>>>16,ve=this.low&65535,$e=P.high>>>16,fe=P.high&65535,xe=P.low>>>16,ae=P.low&65535,q=0,ue=0,we=0,Ge=0;return Ge+=ve*ae,we+=Ge>>>16,Ge&=65535,we+=ge*ae,ue+=we>>>16,we&=65535,we+=ve*xe,ue+=we>>>16,we&=65535,ue+=me*ae,q+=ue>>>16,ue&=65535,ue+=ge*xe,q+=ue>>>16,ue&=65535,ue+=ve*fe,q+=ue>>>16,ue&=65535,q+=ie*ae+me*xe+ge*fe+ve*$e,q&=65535,a(we<<16|Ge,q<<16|ue,this.unsigned)},M.mul=M.multiply,M.divide=function(P){if(n(P)||(P=d(P)),P.isZero())throw Error("division by zero");if(t){if(!this.unsigned&&this.high===-2147483648&&P.low===-1&&P.high===-1)return this;var re=(this.unsigned?t.div_u:t.div_s)(this.low,this.high,P.low,P.high);return a(re,t.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?$:S;var ie,me,ge;if(this.unsigned){if(P.unsigned||(P=P.toUnsigned()),P.gt(this))return $;if(P.gt(this.shru(1)))return R;ge=$}else{if(this.eq(B)){if(P.eq(I)||P.eq(_))return B;if(P.eq(B))return I;var ve=this.shr(1);return ie=ve.div(P).shl(1),ie.eq(S)?P.isNegative()?I:_:(me=this.sub(P.mul(ie)),ge=ie.add(me.div(P)),ge)}else if(P.eq(B))return this.unsigned?$:S;if(this.isNegative())return P.isNegative()?this.neg().div(P.neg()):this.neg().div(P).neg();if(P.isNegative())return this.div(P.neg()).neg();ge=S}for(me=this;me.gte(P);){ie=Math.max(1,Math.floor(me.toNumber()/P.toNumber()));for(var $e=Math.ceil(Math.log(ie)/Math.LN2),fe=$e<=48?1:l(2,$e-48),xe=i(ie),ae=xe.mul(P);ae.isNegative()||ae.gt(me);)ie-=fe,xe=i(ie,this.unsigned),ae=xe.mul(P);xe.isZero()&&(xe=I),ge=ge.add(xe),me=me.sub(ae)}return ge},M.div=M.divide,M.modulo=function(P){if(n(P)||(P=d(P)),t){var re=(this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,P.low,P.high);return a(re,t.get_high(),this.unsigned)}return this.sub(this.div(P).mul(P))},M.mod=M.modulo,M.rem=M.modulo,M.not=function(){return a(~this.low,~this.high,this.unsigned)},M.and=function(P){return n(P)||(P=d(P)),a(this.low&P.low,this.high&P.high,this.unsigned)},M.or=function(P){return n(P)||(P=d(P)),a(this.low|P.low,this.high|P.high,this.unsigned)},M.xor=function(P){return n(P)||(P=d(P)),a(this.low^P.low,this.high^P.high,this.unsigned)},M.shiftLeft=function(P){return n(P)&&(P=P.toInt()),(P&=63)===0?this:P<32?a(this.low<<P,this.high<<P|this.low>>>32-P,this.unsigned):a(0,this.low<<P-32,this.unsigned)},M.shl=M.shiftLeft,M.shiftRight=function(P){return n(P)&&(P=P.toInt()),(P&=63)===0?this:P<32?a(this.low>>>P|this.high<<32-P,this.high>>P,this.unsigned):a(this.high>>P-32,this.high>=0?0:-1,this.unsigned)},M.shr=M.shiftRight,M.shiftRightUnsigned=function(P){if(n(P)&&(P=P.toInt()),P&=63,P===0)return this;var re=this.high;if(P<32){var ie=this.low;return a(ie>>>P|re<<32-P,re>>>P,this.unsigned)}else return P===32?a(re,0,this.unsigned):a(re>>>P-32,0,this.unsigned)},M.shru=M.shiftRightUnsigned,M.shr_u=M.shiftRightUnsigned,M.toSigned=function(){return this.unsigned?a(this.low,this.high,!1):this},M.toUnsigned=function(){return this.unsigned?this:a(this.low,this.high,!0)},M.toBytes=function(P){return P?this.toBytesLE():this.toBytesBE()},M.toBytesLE=function(){var P=this.high,re=this.low;return[re&255,re>>>8&255,re>>>16&255,re>>>24,P&255,P>>>8&255,P>>>16&255,P>>>24]},M.toBytesBE=function(){var P=this.high,re=this.low;return[P>>>24,P>>>16&255,P>>>8&255,P&255,re>>>24,re>>>16&255,re>>>8&255,re&255]},e.fromBytes=function(P,re,ie){return ie?e.fromBytesLE(P,re):e.fromBytesBE(P,re)},e.fromBytesLE=function(P,re){return new e(P[0]|P[1]<<8|P[2]<<16|P[3]<<24,P[4]|P[5]<<8|P[6]<<16|P[7]<<24,re)},e.fromBytesBE=function(P,re){return new e(P[4]<<24|P[5]<<16|P[6]<<8|P[7],P[0]<<24|P[1]<<16|P[2]<<8|P[3],re)},U1}var SA=xX();const CA=Af(SA),vX=zE({__proto__:null,default:CA},[SA]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const du=CA||vX;function oy(t){return du.fromString(t,!0,16)}const $A=oy("c3a5c85c97cb3127"),lu=oy("b492b66fbe98f273"),$r=oy("9ae16a3b2f90404f");function sv(t){return t.xor(t.shru(47))}function kA(t,e,n){const r=t.slice(e,e+n);return du.fromBytes(Array.from(r),!0,!0)}function Zt(t,e){return kA(t,e,8)}function g3(t,e){return kA(t,e,4)}function On(t,e){return e===0?t:t.shru(e).or(t.shl(64-e))}function dl(t,e,n=oy("9ddfea08eb382d69")){let r=t.xor(e).mul(n);r=r.xor(r.shru(47));let s=e.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function bX(t,e,n,r,s,o){s=s.add(t),o=On(o.add(s).add(r),21);const i=s;return s=s.add(e),s=s.add(n),o=o.add(On(s,44)),[s.add(r),o.add(i)]}function xm(t,e,n,r){return bX(Zt(t,e),Zt(t,e+8),Zt(t,e+16),Zt(t,e+24),n,r)}function wX(t,e=t.length){if(e>=8){const n=$r.add(e*2),r=Zt(t,0).add($r),s=Zt(t,e-8),o=On(s,37).mul(n).add(r),i=On(r,25).add(s).mul(n);return dl(o,i,n)}if(e>=4){const n=$r.add(e*2),r=g3(t,0);return dl(r.shl(3).add(e),g3(t,e-4),n)}if(e>0){const n=t[0],r=t[e>>1],s=t[e-1],o=n+(r<<8),i=e+(s<<2);return sv($r.mul(o).xor($A.mul(i))).mul($r)}return $r}function SX(t,e=t.length){const n=$r.add(e*2),r=Zt(t,0).mul(lu),s=Zt(t,8),o=Zt(t,e-8).mul(n),i=Zt(t,e-16).mul($r);return dl(On(r.add(s),43).add(On(o,30)).add(i),r.add(On(s.add($r),18)).add(o),n)}function CX(t,e=t.length){const n=$r.add(e*2),r=Zt(t,0).mul($r),s=Zt(t,8),o=Zt(t,e-8).mul(n),i=Zt(t,e-16).mul($r),a=On(r.add(s),43).add(On(o,30)).add(i),l=dl(a,r.add(On(s.add($r),18)).add(o),n),c=Zt(t,16).mul(n),d=Zt(t,24),f=a.add(Zt(t,e-32)).mul(n),p=l.add(Zt(t,e-24)).mul(n);return dl(On(c.add(d),43).add(On(f,30)).add(p),c.add(On(d.add(r),18)).add(f),n)}function $X(t,e=t.length){const n=du.fromNumber(81,!0);if(e<=32)return e<=16?wX(t,e):SX(t,e);if(e<=64)return CX(t,e);let r=n,s=n.mul(lu).add(113),o=sv(s.mul($r).add(113)).mul($r),i=[du.UZERO,du.UZERO],a=[du.UZERO,du.UZERO];r=r.mul($r).add(Zt(t,0));let l=0;const c=(e-1>>6)*64,d=c+(e-1&63)-63;do r=On(r.add(s).add(i[0]).add(Zt(t,l+8)),37).mul(lu),s=On(s.add(i[1]).add(Zt(t,l+48)),42).mul(lu),r=r.xor(a[1]),s=s.add(i[0]).add(Zt(t,l+40)),o=On(o.add(a[0]),33).mul(lu),i=xm(t,l,i[1].mul(lu),r.add(a[0])),a=xm(t,l+32,o.add(a[1]),s.add(Zt(t,l+16))),[o,r]=[r,o],l+=64;while(l!==c);const f=lu.add(o.and(255).shl(1));return l=d,a[0]=a[0].add(e-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),r=On(r.add(s).add(i[0]).add(Zt(t,l+8)),37).mul(f),s=On(s.add(i[1]).add(Zt(t,l+48)),42).mul(f),r=r.xor(a[1].mul(9)),s=s.add(i[0].mul(9).add(Zt(t,l+40))),o=On(o.add(a[0]),33).mul(f),i=xm(t,l,i[1].mul(f),r.add(a[0])),a=xm(t,l+32,o.add(a[1]),s.add(Zt(t,l+16))),[o,r]=[r,o],dl(dl(i[0],a[0],f).add(sv(s).mul($A)).add(o),dl(i[1],a[1],f).add(r),f)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kd(t,e){return e==="string"?hl(t):iy([t],e)}function kX(t,e){return t instanceof Float32Array&&e==="float32"||t instanceof Int32Array&&e==="int32"||t instanceof Uint8Array&&e==="bool"}function iy(t,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=pa(t)),se().getBool("DEBUG")&&rX(t,e),kX(t,e))return t;if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool"){const n=new Uint8Array(t.length);for(let r=0;r<n.length;++r)Math.round(t[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${e}`)}function Po(){return se().platform.now()}function hl(t,e="utf-8"){return e=e||"utf-8",se().platform.encode(t,e)}function fa(t,e="utf-8"){return e=e||"utf-8",se().platform.decode(t,e)}function co(t){return se().platform.isTypedArray!=null?se().platform.isTypedArray(t):wA(t)}function pa(t,e=[],n=!1){if(e==null&&(e=[]),typeof t=="boolean"||typeof t=="number"||typeof t=="string"||Ru(t)||t==null||co(t)&&n)e.push(t);else if(Array.isArray(t)||co(t))for(let r=0;r<t.length;++r)pa(t[r],e,n);else{let r=-1;for(const s of Object.keys(t))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)pa(t[s],e,n)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TX{constructor(e,n){this.backendTimer=e,this.logger=n,n==null&&(this.logger=new NX)}profileKernel(e,n,r){let s;const o=()=>{s=r()};let i;const a=Po();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(o);else{o();for(const c of s)c.dataSync();i=Promise.resolve({kernelMs:Po()-a})}if(se().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<s.length;c++){const d=s[c];d.data().then(f=>{IX(f,d.dtype,e)})}return{kernelName:e,outputs:s,inputs:n,timeMs:i.then(c=>c.kernelMs),extraInfo:i.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:n,outputs:r,timeMs:s,inputs:o,extraInfo:i}=e;r.forEach(a=>{Promise.all([a.data(),s,i]).then(l=>{this.logger.logKernelProfile(n,a,l[0],l[1],o,l[2])})})}}function IX(t,e,n){if(e!=="float32")return!1;for(let r=0;r<t.length;r++){const s=t[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${n}'`),!0}return!1}class NX{logKernelProfile(e,n,r,s,o,i){const a=typeof s=="number"?Yc(`${s}ms`,9):s.error,l=Yc(e,25),c=n.rank,d=n.size,f=Yc(n.shape.toString(),14);let p="";for(const g in o){const y=o[g];if(y!=null){const x=y.shape||n.shape,w=x.length;p+=`${g}: ${w}D ${w>0?x:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${f}	%c${d}	%c${p}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EX(t,e,n){const r={},s={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<t.length;l++){const c=t[l],d=c.inputs;for(const f in d){const p=d[f];let g=!1;for(let y=0;y<e.length;y++)if(r[p.id]){c.outputs.forEach(x=>r[x.id]=!0),g=!0,s[c.id]=!0;break}if(g)break}}const o={};o[n.id]=!0;const i={};for(let l=t.length-1;l>=0;l--){const c=t[l],d=c.inputs;for(let f=0;f<c.outputs.length;f++)if(o[c.outputs[f].id]){for(const p in d)o[d[p].id]=!0,i[c.id]=!0;break}}const a=[];for(let l=0;l<t.length;l++){const c=t[l];if(s[c.id]&&i[c.id]){const d={};for(const p in c.inputs){const g=c.inputs[p];r[g.id]&&(d[p]=g)}const f=Object.assign({},c);f.inputs=d,f.outputs=c.outputs,a.push(f)}}return a}function RX(t,e,n,r){for(let s=e.length-1;s>=0;s--){const o=e[s],i=[];if(o.outputs.forEach(l=>{const c=t[l.id];c!=null?i.push(c):i.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const a=o.gradient(i);for(const l in o.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=n(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const d=o.inputs[l];if(!Vt(c.shape,d.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${d.shape}'`);if(t[d.id]==null)t[d.id]=c;else{const f=t[d.id];t[d.id]=r(f,c),f.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y3=20,wh=3,j1=7;function _X(t,e,n,r){const s=gn(e),o=PX(t,e,n,s),i=e.length,a=jm(t,e,n,s,o),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function PX(t,e,n,r){const s=pe(e),o=r[r.length-1],i=new Array(o).fill(0),a=e.length,l=n==="complex64"?Oh(t):t;if(a>1)for(let c=0;c<s/o;c++){const d=c*o;for(let f=0;f<o;f++)i[f]=Math.max(i[f],Dh(l[d+f],0,n).length)}return i}function Dh(t,e,n){let r;return Array.isArray(t)?r=`${parseFloat(t[0].toFixed(j1))} + ${parseFloat(t[1].toFixed(j1))}j`:Gf(t)?r=`'${t}'`:n==="bool"?r=TA(t):r=parseFloat(t.toFixed(j1)).toString(),Yc(r,e)}function TA(t){return t===0?"false":"true"}function jm(t,e,n,r,s,o=!0){const i=n==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(n==="complex64"){const x=Oh(t);return[Dh(x[0],0,n)]}return n==="bool"?[TA(t[0])]:[t[0].toString()]}if(l===1){if(a>y3){const w=wh*i;let S=Array.from(t.slice(0,w)),$=Array.from(t.slice((a-wh)*i,a*i));return n==="complex64"&&(S=Oh(S),$=Oh($)),["["+S.map((I,R)=>Dh(I,s[R],n)).join(", ")+", ..., "+$.map((I,R)=>Dh(I,s[a-wh+R],n)).join(", ")+"]"]}return["["+(n==="complex64"?Oh(t):Array.from(t)).map((w,S)=>Dh(w,s[S],n)).join(", ")+"]"]}const c=e.slice(1),d=r.slice(1),f=r[0]*i,p=[];if(a>y3){for(let x=0;x<wh;x++){const w=x*f,S=w+f;p.push(...jm(t.slice(w,S),c,n,d,s,!1))}p.push("...");for(let x=a-wh;x<a;x++){const w=x*f,S=w+f;p.push(...jm(t.slice(w,S),c,n,d,s,x===a-1))}}else for(let x=0;x<a;x++){const w=x*f,S=w+f;p.push(...jm(t.slice(w,S),c,n,d,s,x===a-1))}const g=l===2?",":"";p[0]="["+(a>0?p[0]+g:"");for(let x=1;x<p.length-1;x++)p[x]=" "+p[x]+g;let y=`,
`;for(let x=2;x<l;x++)y+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(o?"":y),p}function Oh(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ad{constructor(e,n,r){if(this.dtype=n,this.shape=e.slice(),this.size=pe(e),r!=null){const s=r.length;z(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||En(n,this.size),this.strides=gn(e)}set(e,...n){n.length===0&&(n=[0]),z(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const r=this.locToIndex(n);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let n=0;for(const s of e){if(s<0||s>=this.shape[n]){const o=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(o)}n++}let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=this.strides[s]*e[s];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return n}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const n=new Array(this.shape.length);for(let r=0;r<n.length-1;++r)n[r]=Math.floor(e/this.strides[r]),e-=n[r]*this.strides[r];return n[n.length-1]=e,n}get rank(){return this.shape.length}toTensor(){return Do().makeTensor(this.values,this.shape,this.dtype)}}let Do=null,Ec=null;function AX(t){Do=t}function DX(t){Ec=t}class fn{constructor(e,n,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=n||"float32",this.size=pe(e),this.strides=gn(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Ec.buffer(this.shape,this.dtype,e)}bufferSync(){return Ec.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return nv(this.shape,e,this.dtype==="complex64")}arraySync(){return nv(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Do().read(this.dataId);if(this.dtype==="string"){const n=await e;try{return n.map(r=>fa(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Do().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Do().readSync(this.dataId);if(this.dtype==="string")try{return e.map(n=>fa(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Do().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Do().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Ec.print(this,e)}clone(){return this.throwIfDisposed(),Ec.clone(this)}toString(e=!1){const n=this.dataSync();return _X(n,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Ec.cast(this,e)}variable(e=!0,n,r){return this.throwIfDisposed(),Do().makeVariable(this,e,n,r)}}Object.defineProperty(fn,Symbol.hasInstance,{value:t=>!!t&&t.data!=null&&t.dataSync!=null&&t.throwIfDisposed!=null});function IA(){return nw("Tensor",()=>fn)}IA();class kg extends fn{constructor(e,n,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=n,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Vt(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Do().disposeTensor(this),this.dataId=e.dataId,Do().incRef(this,null)}dispose(){Do().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(kg,Symbol.hasInstance,{value:t=>t instanceof fn&&t.assign!=null&&t.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var x3;(function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"})(x3||(x3={}));var ov;(function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"})(ov||(ov={}));var iv;(function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"})(iv||(iv={}));var av;(function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"})(av||(av={}));var lv;(function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"})(lv||(lv={}));const OX={float32:av,int32:ov,bool:iv,complex64:lv};function Gr(t,e){if(t==="string"||e==="string"){if(t==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return OX[t][e]}function ay(t){return Gr(t,"int32")}function NA(t){return t!=null&&typeof t=="object"&&"texture"in t&&t.texture instanceof WebGLTexture}function EA(t){return typeof GPUBuffer<"u"&&t!=null&&typeof t=="object"&&"buffer"in t&&t.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yn(t,e){if(t.dtype===e.dtype)return[t,e];const n=Gr(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function FX(t,e){z(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function RA(t){const e=[];return _A(t,e,new Set),e}function _A(t,e,n){if(t==null)return;if(t instanceof fn){e.push(t);return}if(!LX(t))return;const r=t;for(const s in r){const o=r[s];n.has(o)||(n.add(o),_A(o,e,n))}}function LX(t){return Array.isArray(t)||typeof t=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G1(t){return t.kernelName!=null}class v3{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class ld{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new v3}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:n}=this.initializeBackend(e);if(n)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,n,r=1){return e in this.registryFactory?(Lo(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:n,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:n,asyncInit:r}=this.initializeBackend(e);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new TX(this.backendInstance),!0}setupRegisteredKernels(){p3(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){p3(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const n=this.registryFactory[e];if(n==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=n.factory();if(r&&!(r instanceof Jb)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,o=r.then(i=>s<this.pendingBackendInitId?!1:(this.registry[e]=i,this.pendingBackendInit=null,!0)).catch(i=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,Lo(`Initialization of backend ${e} failed`),Lo(i.stack||i.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return Lo(`Initialization of backend ${e} failed`),Lo(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,n)=>this.registryFactory[n].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n],{success:s,asyncInit:o}=this.initializeBackend(r);if(o||s)return{name:r,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,n){const r=this.state.tensorInfo.get(n),s=r.backend,o=this.readSync(n),i=s.refCount(n);s.disposeData(n,!0),r.backend=e,e.move(n,o,r.shape,r.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,n){let r=null;if(n==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");n=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=n(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,n,r){e();try{const s=r();return n(),s}catch(s){throw n(),s}}nextTensorId(){return ld.nextTensorId++}nextVariableId(){return ld.nextVariableId++}clone(e){const n=Y.runKernel(ry,{x:e}),r={x:e},s=i=>({x:()=>{const a="float32",l={x:i},c={dtype:a};return Y.runKernel(ny,l,c)}}),o=[];return this.addTapeNode(this.state.activeScope.name,r,[n],s,o,{}),n}runKernel(e,n,r){if(this.backendName==null&&this.backend,!($g(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,n,r){const s=this.backend.numDataIds();let o=0;r.forEach(l=>{o+=l.dtype==="complex64"?3:1});const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=s-n-o-i;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let n,r=[];const s=this.isTapeOn(),o=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const c=G1(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(G1(e)){const{kernelName:y,inputs:x,attrs:w}=e;this.backendName==null&&this.backend;const S=$g(y,this.backendName);z(S!=null,()=>`Cannot find registered kernel '${y}' for backend '${this.backendName}'`),a=()=>{const $=this.backend.numDataIds();l=S.kernelFunc({inputs:x,attrs:w,backend:this.backend});const I=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(y,$,I);const R=I.map(_=>_.rank!=null?_:this.makeTensorFromTensorInfo(_));if(s){const _=this.getTensorsForGradient(y,x,R);r=this.saveTensorsForBackwardMode(_)}return R}}else{const{forwardFunc:y}=e,x=w=>{s&&(r=w.map(S=>this.keep(this.clone(S))))};a=()=>{const w=this.backend.numDataIds();l=this.tidy(()=>y(this.backend,x));const S=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,w,S),S}}const{inputs:d,attrs:f}=e,p=G1(e)?null:e.backwardsFunc;let g;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=a():(g=this.profiler.profileKernel(c,d,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(g),n=g.outputs)}),s&&this.addTapeNode(c,d,n,p,r,f),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(y=>d[y]!=null?d[y].shape:null),outputShapes:n.map(y=>y.shape),kernelTimeMs:g.timeMs,extraInfo:g.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,n,r){const s=f3(e);if(s!=null){const o=s.inputsToSave||[],i=s.outputsToSave||[];let a;s.saveAllInputs?(z(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(n).map(c=>n[c])):a=o.map(c=>n[c]);const l=r.filter((c,d)=>i[d]);return a.concat(l)}return[]}makeTensor(e,n,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let o=e;r==="string"&&Gf(e[0])&&(o=e.map(l=>hl(l)));const i=s.write(o,n,r),a=new fn(n,r,i,this.nextTensorId());if(this.trackTensor(a,s),r==="string"){const l=this.state.tensorInfo.get(i),c=oX(o);this.state.numBytes+=c-l.bytes,l.bytes=c}return a}makeTensorFromDataId(e,n,r,s){r=r||"float32";const o={dataId:e,shape:n,dtype:r};return this.makeTensorFromTensorInfo(o,s)}makeTensorFromTensorInfo(e,n){const{dataId:r,shape:s,dtype:o}=e,i=new fn(s,o,r,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(e,n=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const o=new kg(e,n,r,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,n){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*xg(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:n||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof kg||this.track(e)}incRef(e,n){this.trackTensor(e,n),this.backend.incRef(e.dataId)}removeDataId(e,n){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===n&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const n=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*xg(e.dtype);this.state.numBytes-=r}n.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,n.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const n=this.state.registeredVariables[e];this.disposeVariable(n)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,n,r,s,o,i){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:n,outputs:r,saved:o},l=f3(e);l!=null&&(s=l.gradFunc),s!=null&&(a.gradient=c=>(c=c.map((d,f)=>{if(d==null){const p=r[f],g=ha(p.size,p.dtype);return this.makeTensor(g,p.shape,p.dtype)}return d}),s(c.length>1?c:c[0],o,i))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(n.name=e),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(e){const n=RA(e),r=new Set(n.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const i=this.state.activeScope.track[o];!i.kept&&!r.has(i.id)&&i.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(o=>{!o.kept&&o.scopeId===s.id&&this.track(o)})}gradients(e,n,r,s=!1){if(z(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));z(o instanceof fn,()=>"The result y returned by f() must be a tensor.");const i=EX(this.state.activeTape,n,o);if(!s&&i.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[o.id]=r??zX(o.shape),RX(a,i,c=>this.tidy(c),BX);const l=n.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const d of c.saved)d.dispose()}),this.state.activeTape=null),{value:o,grads:l}})}customGrad(e){return z(ev(e),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{z(n.every(a=>a instanceof fn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};n.forEach((a,l)=>{s[l]=a});const o=(a,l)=>(r=e(...n,l),z(r.value instanceof fn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),z(ev(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),i=(a,l)=>{const c=r.gradFunc(a,l),d=Array.isArray(c)?c:[c];z(d.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),z(d.every(p=>p instanceof fn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const f={};return d.forEach((p,g)=>{f[g]=()=>p}),f};return this.runKernelFunc({forwardFunc:o,backwardsFunc:i,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,n){return this.state.tensorInfo.get(e).backend.readToGPU(e,n)}async time(e){const n=Po(),r=await this.backend.time(e);return r.wallMs=Po()-n,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new v3;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}ld.nextTensorId=0;ld.nextVariableId=0;function zX(t){const e=XP(pe(t),"float32");return Y.makeTensor(e,t,"float32")}function PA(){const t=YP();if(t._tfengine==null){const e=new lX(t);t._tfengine=new ld(e)}return hX(t._tfengine.ENV),AX(()=>t._tfengine),t._tfengine}const Y=PA();function BX(t,e){const n={a:t,b:e};return Y.runKernel(ty,n)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MX(){return typeof navigator<"u"&&navigator!=null}function AA(t){if(t||MX()){if(t||(t=navigator),t.product==="ReactNative")return!0;const e=t.userAgent||t.vendor||(typeof window<"u"?window.opera:"");if(!e){const n=t;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function DA(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hr=se();Hr.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Hr.registerFlag("IS_BROWSER",()=>DA());Hr.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Hr.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Hr.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Hr.registerFlag("PROD",()=>!1);Hr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Hr.getBool("DEBUG"));Hr.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Hr.registerFlag("IS_TEST",()=>!1);Hr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Hr.getBool("DEBUG"));Hr.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Hr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Hr.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $l(t,e){let n=t;if(co(t))return e==="string"?[]:[t.length];if(NA(t)){const s=t.channels||"RGBA";return[t.height,t.width*s.length]}else if(EA(t))return[t.buffer.size/(e==null?4:xg(e))];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||co(n)&&e!=="string";)r.push(n.length),n=n[0];return Array.isArray(t)&&se().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&OA(t,r,[]),r}function OA(t,e,n){if(n=n||[],!Array.isArray(t)&&!co(t)){z(e.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}z(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),z(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const r=e.slice(1);for(let s=0;s<t.length;++s)OA(t[s],r,n.concat(s))}function b3(t,e,n,r){if(t!=="string_or_numeric"){if(t==null)throw new Error("Expected dtype cannot be null.");if(t!=="numeric"&&t!==e||t==="numeric"&&e==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}}function L(t,e,n,r="numeric"){if(t instanceof IA())return b3(r,t.dtype,e,n),t;let s=$d(t);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),b3(r,s,e,n),t==null||!co(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string"){const l=t==null?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${l}'`)}const o=$l(t,s);!co(t)&&!Array.isArray(t)&&(t=[t]);const a=s!=="string"?iy(t,s):pa(t,[],!0);return Y.makeTensor(a,o,s)}function Tg(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((o,i)=>L(o,`${e}[${i}]`,n,r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FA="__op";function X(t){const e=Object.keys(t);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+FA;const s=(...o)=>{Y.startScope(n);try{const i=r(...o);return Ru(i)&&console.error("Cannot return a Promise inside of tidy."),Y.endScope(i),i}catch(i){throw Y.endScope(null),i}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VX(t,e){const n=L(t,"real","complex"),r=L(e,"imag","complex");xs(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return Y.runKernel($w,s)}const yl=X({complex_:VX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kl(t,e,n,r){if(r==null)r=$d(t);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(EA(t)||NA(t)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return Y.backend.createTensorFromGPUData(t,e||n,r)}if(!co(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Fs(e);const s=pe(e),o=pe(n);z(s===o,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${o}`);for(let i=0;i<n.length;++i){const a=n[i],l=i===n.length-1?a!==pe(e.slice(i)):!0;z(n[i]===e[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return!co(t)&&!Array.isArray(t)&&(t=[t]),e=e||n,t=r!=="string"?iy(t,r):pa(t,[],!0),Y.makeTensor(t,e,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vi(t,e,n){const r=$l(t,n);return kl(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _u={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Bo{static join(e){return new Bo(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(r=>co(r)?r.buffer:r),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let n=0;for(let r=0;r<e.length;r++){const s=e[r];r!==e.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const o=n+s.byteLength;this.shards.push({buffer:s,start:n,end:o}),n=o}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,n=isNaN(Number(n))?0:n,e=Math.max(0,e),n=Math.min(this.byteLength,n),n<=e)return new ArrayBuffer(0);const r=this.findShardForByte(e);if(r===-1)throw new Error(`Could not find start shard for byte ${e}`);const s=n-e,o=new ArrayBuffer(s),i=new Uint8Array(o);let a=0;for(let l=r;l<this.shards.length;l++){const c=this.shards[l],f=e+a-c.start,p=a,y=Math.min(n,c.end)-c.start,x=new Uint8Array(c.buffer,f,y-f);if(i.set(x,p),a+=x.length,n<c.end)break}return o}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function n(s){return e<s.start?-1:e>=s.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const r=WX(this.shards,n);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function WX(t,e){let n=0,r=t.length;for(;n<=r;){const s=Math.floor((r-n)/2)+n,o=e(t[s]);if(o===0)return s;o<0?r=s:n=s+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hs(){return Y}function nt(t,e){return Y.tidy(t,e)}function Mt(t){RA(t).forEach(n=>n.dispose())}function hi(t){return Y.keep(t)}function UX(t){return Y.setBackend(t)}function jX(){return Y.ready()}function mf(){return Y.backendName}function LA(t,e,n=1){return Y.registerBackend(t,e,n)}function ud(){return Y.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xl=4;async function GX(t,e){const n=[],r=[],s=Array.isArray(t)?t.map(i=>i.name):Object.keys(t);for(let i=0;i<s.length;++i){const a=s[i],l=Array.isArray(t)?t[i].tensor:t[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const c={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const d=new Promise(async f=>{const p=await l.bytes(),g=p.reduce((w,S)=>w+S.length,0)+xl*p.length,y=new Uint8Array(g);let x=0;for(let w=0;w<p.length;w++){const S=p[w],$=new Uint8Array(new Uint32Array([S.length]).buffer);y.set($,x),x+=xl,y.set(S,x),x+=S.length}f(y)});r.push(d)}else r.push(l.data());e!=null&&(c.group=e),n.push(c)}const o=await Promise.all(r);return{data:XX(o),specs:n}}function zA(t,e){const n=new Bo(t),r={};let s=0;for(const o of e){const i=HX(o,(a,l)=>n.slice(s+a,s+l));r[o.name]=BA(o,n.slice(s,s+i)),s+=i}return r}function HX(t,e){const n=pe(t.shape);let r;if("quantization"in t){const s=t.quantization;r=_u[s.dtype]}else if(t.dtype==="string"){let s=0;for(let o=0;o<n;o++)s+=xl+new Uint32Array(e(s,s+xl))[0];return s}else r=_u[t.dtype];return n*r}async function KX(t,e){const n=pe(t.shape);let r;if("quantization"in t){const s=t.quantization;r=_u[s.dtype]}else if(t.dtype==="string"){let s=0;for(let o=0;o<n;o++)s+=xl+new Uint32Array(await e(s,s+xl))[0];return s}else r=_u[t.dtype];return n*r}function BA(t,e){const n=t.name,r=t.dtype,s=t.shape,o=pe(s);let i,a=0;if("quantization"in t){const l=t.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${t.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${t.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${t.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const c=_u[l.dtype],d=l.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(r==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){i=new Float32Array(d.length);for(let f=0;f<d.length;f++){const p=d[f];i[f]=p*l.scale+l.min}}else if(l.dtype==="float16")i=tq()(d);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(r==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(d.length);for(let f=0;f<d.length;f++){const p=d[f];i[f]=Math.round(p*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);a+=o*c}else if(r==="string"){const l=pe(t.shape);i=[];for(let c=0;c<l;c++){const d=new Uint32Array(e.slice(a,a+xl))[0];a+=xl;const f=new Uint8Array(e.slice(a,a+d));i.push(f),a+=d}}else{const l=_u[r];if(r==="float32")i=new Float32Array(e);else if(r==="int32")i=new Int32Array(e);else if(r==="bool")i=new Uint8Array(e);else if(r==="complex64"){i=new Float32Array(e);const c=new Float32Array(i.length/2),d=new Float32Array(i.length/2);for(let y=0;y<c.length;y++)c[y]=i[y*2],d[y]=i[y*2+1];const f=vi(c,s,"float32"),p=vi(d,s,"float32"),g=yl(f,p);return f.dispose(),p.dispose(),g}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);a+=o*l}return vi(i,s,r)}async function w3(t,e,n){let r=new Uint8Array(e);for(;r.byteLength<n;){const{done:s,value:o}=await t.read();if(s&&o==null){const a=n-r.byteLength;throw new Error(`Reader is done but ${a} bytes are still expected`)}const i=new Uint8Array(r.length+o.byteLength);i.set(r,0),i.set(new Uint8Array(o),r.length),r=i}return r.buffer}async function MA(t,e){const n={},r=t.getReader();let s=new ArrayBuffer(0);for(const o of e){const i=await KX(o,async(c,d)=>(s=await w3(r,s,d),s.slice(c,d)));s=await w3(r,s,i);const a=s.slice(0,i);s=s.slice(i);const l=BA(o,a);if(n[o.name]=l,mf()==="webgpu"){const c=ud();"uploadToGPU"in c&&pe(l.shape)>=se().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&c.uploadToGPU(l.dataId)}}return n}function XX(t){if(t===null)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(o=>{if(e+=o.byteLength,n.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const r=new Uint8Array(e);let s=0;return n.forEach(o=>{r.set(new Uint8Array(o.buffer),s),s+=o.byteLength}),r.buffer}const OS=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function S3(t){return OS?Buffer.byteLength(t,"utf8"):new Blob([t]).size}function qX(t){if(OS)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let r=0,s=e.length;r<s;r++)n+=String.fromCharCode(e[r]);return btoa(n)}function YX(t){if(OS){const r=Buffer.from(t,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n.set([e.charCodeAt(r)],r);return n.buffer}function QX(t){return Bo.join(t)}function C3(t){const e="/";for(t=t.trim();t.endsWith(e);)t=t.slice(0,t.length-1);const n=t.split(e);return n[n.length-1]}function VA(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return t.signature!=null&&(n.signature=t.signature),t.userDefinedMetadata!=null&&(n.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(n.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(n.initializerSignature=t.initializerSignature),t.trainingConfig!=null&&(n.trainingConfig=t.trainingConfig),n}function WA(t,e,n){const r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(t.trainingConfig!=null&&(r.trainingConfig=t.trainingConfig),t.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=n}return t.signature!=null&&(r.signature=t.signature),t.userDefinedMetadata!=null&&(r.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(r.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(r.initializerSignature=t.initializerSignature),r}async function FS(t,e){let n,r;return t.weightsManifest!=null&&([n,r]=await e(t.weightsManifest)),WA(t,n,r)}function Hf(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology==null?0:S3(JSON.stringify(t.modelTopology)),weightSpecsBytes:t.weightSpecs==null?0:S3(JSON.stringify(t.weightSpecs)),weightDataBytes:t.weightData==null?0:new Bo(t.weightData).byteLength}}function uv(t){const e=[];for(const n of t)e.push(...n.weights);return e}function ZX(){const t=n=>{let r=n<<13,s=0;for(;(r&8388608)===0;)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}function JX(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}function eq(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}function tq(){const t=ZX(),e=JX(),n=eq();return r=>{const s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let i=0;i<r.length;i++){const a=r[i],l=t[n[a>>10]+(a&1023)]+e[a>>10];o[i]=l}return new Float32Array(s)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return cn.instance==null&&(cn.instance=new cn),cn.instance}static registerSaveRouter(e){cn.getInstance().saveRouters.push(e)}static registerLoadRouter(e){cn.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return cn.getHandlers(e,"save")}static getLoadHandlers(e,n){return cn.getHandlers(e,"load",n)}static getHandlers(e,n,r){const s=[];return(n==="load"?cn.getInstance().loadRouters:cn.getInstance().saveRouters).forEach(i=>{const a=i(e,r);a!==null&&s.push(a)}),s}}const nq=t=>cn.registerSaveRouter(t),rq=t=>cn.registerLoadRouter(t),sq=t=>cn.getSaveHandlers(t),oq=(t,e)=>cn.getLoadHandlers(t,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cv="tensorflowjs",dv=1,vu="models_store",ll="model_info_store";function UA(){if(!se().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t=typeof window>"u"?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function hv(t){const e=t.result;e.createObjectStore(vu,{keyPath:"modelPath"}),e.createObjectStore(ll,{keyPath:"modelPath"})}class Pu{constructor(e){if(this.indexedDB=UA(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,n){return new Promise((r,s)=>{const o=this.indexedDB.open(cv,dv);o.onupgradeneeded=()=>hv(o),o.onsuccess=()=>{const i=o.result;if(n==null){const a=i.transaction(vu,"readonly"),c=a.objectStore(vu).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return i.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(c.result.modelArtifacts)},c.onerror=d=>(i.close(),s(c.error)),a.oncomplete=()=>i.close()}else{n.weightData=Bo.join(n.weightData);const a=Hf(n),l=i.transaction(ll,"readwrite");let c=l.objectStore(ll),d;try{d=c.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(p){return s(p)}let f;d.onsuccess=()=>{f=i.transaction(vu,"readwrite");const p=f.objectStore(vu);let g;try{g=p.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:a})}catch(y){return s(y)}g.onsuccess=()=>r({modelArtifactsInfo:a}),g.onerror=y=>{c=l.objectStore(ll);const x=c.delete(this.modelPath);x.onsuccess=()=>(i.close(),s(g.error)),x.onerror=w=>(i.close(),s(g.error))}},d.onerror=p=>(i.close(),s(d.error)),l.oncomplete=()=>{f==null?i.close():f.oncomplete=()=>i.close()}}},o.onerror=i=>s(o.error)})}}Pu.URL_SCHEME="indexeddb://";const jA=t=>se().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Pu.URL_SCHEME)?iq(t.slice(Pu.URL_SCHEME.length)):null;cn.registerSaveRouter(jA);cn.registerLoadRouter(jA);function iq(t){return new Pu(t)}function aq(t){return t.startsWith(Pu.URL_SCHEME)?t.slice(Pu.URL_SCHEME.length):t}class lq{constructor(){this.indexedDB=UA()}async listModels(){return new Promise((e,n)=>{const r=this.indexedDB.open(cv,dv);r.onupgradeneeded=()=>hv(r),r.onsuccess=()=>{const s=r.result,o=s.transaction(ll,"readonly"),a=o.objectStore(ll).getAll();a.onsuccess=()=>{const l={};for(const c of a.result)l[c.modelPath]=c.modelArtifactsInfo;e(l)},a.onerror=l=>(s.close(),n(a.error)),o.oncomplete=()=>s.close()},r.onerror=s=>n(r.error)})}async removeModel(e){return e=aq(e),new Promise((n,r)=>{const s=this.indexedDB.open(cv,dv);s.onupgradeneeded=()=>hv(s),s.onsuccess=()=>{const o=s.result,i=o.transaction(ll,"readwrite"),a=i.objectStore(ll),l=a.get(e);let c;l.onsuccess=()=>{if(l.result==null)return o.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const d=a.delete(e),f=()=>{c=o.transaction(vu,"readwrite");const g=c.objectStore(vu).delete(e);g.onsuccess=()=>n(l.result.modelArtifactsInfo),g.onerror=y=>r(l.error)};d.onsuccess=f,d.onerror=p=>(f(),o.close(),r(l.error))}},l.onerror=d=>(o.close(),r(l.error)),i.oncomplete=()=>{c==null?o.close():c.oncomplete=()=>o.close()}},s.onerror=o=>r(s.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const na="/",Rc="tensorflowjs_models",GA="info",uq="model_topology",cq="weight_specs",dq="weight_data",hq="model_metadata";function HA(t){return{info:[Rc,t,GA].join(na),topology:[Rc,t,uq].join(na),weightSpecs:[Rc,t,cq].join(na),weightData:[Rc,t,dq].join(na),modelMetadata:[Rc,t,hq].join(na)}}function KA(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function fq(t){const e=t.split(na);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(na)}function pq(t){return t.startsWith(Au.URL_SCHEME)?t.slice(Au.URL_SCHEME.length):t}class Au{constructor(e){if(!se().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=HA(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=Hf(e),o=Bo.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,qX(o));const i={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:s}}catch{throw KA(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=s;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const a=JSON.parse(o);n.format=a.format,n.generatedBy=a.generatedBy,n.convertedBy=a.convertedBy,a.signature!=null&&(n.signature=a.signature),a.userDefinedMetadata!=null&&(n.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(n.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(n.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(n.trainingConfig=a.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=YX(i),n}}Au.URL_SCHEME="localstorage://";const XA=t=>se().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Au.URL_SCHEME)?mq(t.slice(Au.URL_SCHEME.length)):null;cn.registerSaveRouter(XA);cn.registerLoadRouter(XA);function mq(t){return new Au(t)}class gq{constructor(){z(se().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),z(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},n=Rc+na,r=na+GA;for(let s=0;s<this.LS.length;++s){const o=this.LS.key(s);if(o.startsWith(n)&&o.endsWith(r)){const i=fq(o);e[i]=JSON.parse(this.LS.getItem(o))}}return e}async removeModel(e){e=pq(e);const n=HA(e);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return KA(n),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qc="://";class Cr{constructor(){this.managers={}}static getInstance(){return Cr.instance==null&&(Cr.instance=new Cr),Cr.instance}static registerManager(e,n){z(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Qc)&&(e=e.slice(0,e.indexOf(Qc))),z(e.length>0,()=>"scheme must not be an empty string.");const r=Cr.getInstance();z(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=n}static getManager(e){const n=Cr.getInstance().managers[e];if(n==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return n}static getSchemes(){return Object.keys(Cr.getInstance().managers)}}function Gm(t){if(t.indexOf(Qc)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Cr.getSchemes().join(",")}`);return{scheme:t.split(Qc)[0],path:t.split(Qc)[1]}}async function qA(t,e,n=!1){z(t!==e,()=>`Old path and new path are the same: '${t}'`);const r=cn.getLoadHandlers(t);z(r.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),z(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${t}.`);const s=r[0],o=cn.getSaveHandlers(e);z(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),z(o.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const i=o[0],a=Gm(t).scheme,l=Gm(t).path,c=a===Gm(t).scheme,d=await s.load();n&&c&&await Cr.getManager(a).removeModel(l);const f=await i.save(d);return n&&!c&&await Cr.getManager(a).removeModel(l),f.modelArtifactsInfo}async function yq(){const t=Cr.getSchemes(),e={};for(const n of t){const r=await Cr.getManager(n).listModels();for(const s in r){const o=n+Qc+s;e[o]=r[s]}}return e}async function xq(t){const e=Gm(t);return Cr.getManager(e.scheme).removeModel(e.path)}async function vq(t,e){return qA(t,e,!1)}async function bq(t,e){return qA(t,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wq{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,n){return fetch(e,n)}now(){return performance.now()}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,n){return new TextDecoder(n).decode(e)}setTimeoutCustom(e,n){if(typeof window>"u"||!se().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,n);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const s=this.functionRefs[r.data.index];s(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return wA(e)}}if(se().get("IS_BROWSER")){se().setPlatform("browser",new wq);try{Cr.registerManager(Au.URL_SCHEME,new gq)}catch{}try{Cr.registerManager(Pu.URL_SCHEME,new lq)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sq={importFetch:()=>require("node-fetch")};let H1;class Cq{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,n){return se().global.fetch!=null?se().global.fetch(e,n):(H1==null&&(H1=Sq.importFetch()),H1(e,n))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(e)}decode(e,n){return e.length===0?"":new this.util.TextDecoder(n).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}se().get("IS_NODE")&&!se().get("IS_BROWSER")&&se().setPlatform("node",new Cq);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wt(t,e="float32",n){return e=e||"float32",Fs(t),new ad(t,e,n)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $q(t,e){const n=L(t,"x","cast");if(!sX(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&n.dtype!=="string"||e!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:e};return Y.runKernel(ny,r,s)}const Qt=X({cast_:$q});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kq(t){const n={x:L(t,"x","clone","string_or_numeric")};return Y.runKernel(ry,n)}const fl=X({clone_:kq});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YA(t,e=!1){console.log(t.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */PA();const Tq={buffer:Wt,cast:Qt,clone:fl,print:YA};DX(Tq);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iq(t,e){let n=L(t,"a","add"),r=L(e,"b","add");[n,r]=yn(n,r);const s={a:n,b:r};return Y.runKernel(ty,s)}const We=X({add_:Iq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nq(t,e){let n=L(t,"a","floorDiv"),r=L(e,"b","floorDiv");[n,r]=yn(n,r);const s={a:n,b:r};return Y.runKernel(n2,s)}const QA=X({floorDiv_:Nq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eq(t,e){let n=L(t,"a","div"),r=L(e,"b","div");if([n,r]=yn(n,r),n.dtype==="int32"&&r.dtype==="int32")return QA(n,r);const s={a:n,b:r},o={};return Y.runKernel(jw,s,o)}const gt=X({div_:Eq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rq(t,e){let n=L(t,"a","mul"),r=L(e,"b","mul");[n,r]=yn(n,r);const s={a:n,b:r};return Y.runKernel(D2,s)}const Te=X({mul_:Rq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _q(t){const e=L(t,"x","abs");if(e.dtype==="complex64"){const n={x:e};return Y.runKernel(kw,n)}else{const n={x:e};return Y.runKernel(rw,n)}}const Rs=X({abs_:_q});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pq(t){const n={x:L(t,"x","acos")};return Y.runKernel(sw,n)}const Aq=X({acos_:Pq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dq(t){const n={x:L(t,"x","acosh")};return Y.runKernel(ow,n)}const Oq=X({acosh_:Dq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fq(t){z(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),z(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const e=t.map((s,o)=>L(s,`tensors${o}`,"addN")),n=e[0];e.forEach(s=>{if(s.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(s=>{if(!Vt(s.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return Y.runKernel(iw,r)}const Lq=X({addN_:Fq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zq(t,e=null,n=!1){const s={x:L(t,"x","all","bool")},o={axis:e,keepDims:n};return Y.runKernel(aw,s,o)}const Bq=X({all_:zq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mq(t,e=null,n=!1){const s={x:L(t,"x","any","bool")},o={axis:e,keepDims:n};return Y.runKernel(lw,s,o)}const Vq=X({any_:Mq});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wq(t,e=0){const r={x:L(t,"x","argMax")},s={axis:e};return Y.runKernel(uw,r,s)}const ZA=X({argMax_:Wq});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uq(t,e=0){const r={x:L(t,"x","argMin")},s={axis:e};return Y.runKernel(cw,r,s)}const jq=X({argMin_:Uq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gq(t){const n={x:L(t,"x","asin")};return Y.runKernel(dw,n)}const Hq=X({asin_:Gq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kq(t){const n={x:L(t,"x","asinh")};return Y.runKernel(hw,n)}const Xq=X({asinh_:Kq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qq(t){const n={x:L(t,"x","atan")};return Y.runKernel(fw,n)}const Yq=X({atan_:qq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qq(t,e){let n=L(t,"a","atan2"),r=L(e,"b","atan2");[n,r]=yn(n,r);const s={a:n,b:r};return Y.runKernel(mw,s)}const Zq=X({atan2_:Qq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jq(t){const n={x:L(t,"x","atanh")};return Y.runKernel(pw,n)}const eY=X({atanh_:Jq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kf(t,e,n,r,s="NHWC",o){const i=t[3],a=[...e,i],l=Mo(s);return kn(t,a,n,o,r,null,null,l)}function fo(t,e,n,r,s,o,i="channelsLast"){const[a,l]=gf(e);let c;if(i==="channelsLast")c=[a,l,t[3],t[3]];else if(i==="channelsFirst")c=[a,l,t[1],t[1]];else throw new Error(`Unknown dataFormat ${i}`);return kn(t,c,n,r,s,o,!1,i)}function Sa(t,e,n,r,s,o,i="NDHWC"){const[a,l,c]=fv(e);let d,f;if(i==="NDHWC")f="channelsLast",d=[a,l,c,t[4],t[4]];else if(i==="NCDHW")f="channelsFirst",d=[a,l,c,t[1],t[1]];else throw new Error(`Unknown dataFormat ${i}`);return Tl(t,d,n,r,s,!1,f,o)}function kn(t,e,n,r,s,o,i=!1,a="channelsLast"){let[l,c,d,f]=[-1,-1,-1,-1];if(a==="channelsLast")[l,c,d,f]=t;else if(a==="channelsFirst")[l,f,c,d]=t;else throw new Error(`Unknown dataFormat ${a}`);const[p,g,,y]=e,[x,w]=gf(n),[S,$]=gf(r),I=Zc(p,S),R=Zc(g,$),{padInfo:_,outHeight:O,outWidth:F}=rY(s,c,d,x,w,I,R,o,a),B=i?y*f:y;let M;return a==="channelsFirst"?M=[l,B,O,F]:a==="channelsLast"&&(M=[l,O,F,B]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:d,inChannels:f,outHeight:O,outWidth:F,outChannels:B,padInfo:_,strideHeight:x,strideWidth:w,filterHeight:p,filterWidth:g,effectiveFilterHeight:I,effectiveFilterWidth:R,dilationHeight:S,dilationWidth:$,inShape:t,outShape:M,filterShape:e}}function Tl(t,e,n,r,s,o=!1,i="channelsLast",a){let[l,c,d,f,p]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,c,d,f,p]=t;else if(i==="channelsFirst")[l,p,c,d,f]=t;else throw new Error(`Unknown dataFormat ${i}`);const[g,y,x,,w]=e,[S,$,I]=fv(n),[R,_,O]=fv(r),F=Zc(g,R),B=Zc(y,_),M=Zc(x,O),{padInfo:V,outDepth:P,outHeight:re,outWidth:ie}=sY(s,c,d,f,S,$,I,F,B,M,a),me=o?w*p:w;let ge;return i==="channelsFirst"?ge=[l,me,P,re,ie]:i==="channelsLast"&&(ge=[l,P,re,ie,me]),{batchSize:l,dataFormat:i,inDepth:c,inHeight:d,inWidth:f,inChannels:p,outDepth:P,outHeight:re,outWidth:ie,outChannels:me,padInfo:V,strideDepth:S,strideHeight:$,strideWidth:I,filterDepth:g,filterHeight:y,filterWidth:x,effectiveFilterDepth:F,effectiveFilterHeight:B,effectiveFilterWidth:M,dilationDepth:R,dilationHeight:_,dilationWidth:O,inShape:t,outShape:ge,filterShape:e}}function tY(t,e,n,r,s){r==null&&(r=LS(t,e,n));const o=t[0],i=t[1],a=yf((o-e+2*r)/n+1,s),l=yf((i-e+2*r)/n+1,s);return[a,l]}function nY(t,e,n,r,s,o){s==null&&(s=LS(t,e[0],r[0]));const i=[0,0,0,n];for(let a=0;a<3;a++)t[a]+2*s>=e[a]&&(i[a]=yf((t[a]-e[a]+2*s)/r[a]+1,o));return i}function LS(t,e,n,r=1){const s=Zc(e,r);return Math.floor((t[0]*(n-1)-n+s)/2)}function gf(t){return typeof t=="number"?[t,t,t]:t.length===2?[t[0],t[1],1]:t}function fv(t){return typeof t=="number"?[t,t,t]:t}function Zc(t,e){return e<=1?t:t+(t-1)*(e-1)}function rY(t,e,n,r,s,o,i,a,l){let c,d,f;if(typeof t=="number"){c={top:t,bottom:t,left:t,right:t,type:t===0?"VALID":"NUMBER"};const g=tY([e,n],o,r,t,a);d=g[0],f=g[1]}else if(t==="same"){d=Math.ceil(e/r),f=Math.ceil(n/s);const p=Math.max(0,(d-1)*r+o-e),g=Math.max(0,(f-1)*s+i-n),y=Math.floor(p/2),x=p-y,w=Math.floor(g/2),S=g-w;c={top:y,bottom:x,left:w,right:S,type:"SAME"}}else if(t==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},d=Math.ceil((e-o+1)/r),f=Math.ceil((n-i+1)/s);else if(typeof t=="object"){const p=l==="channelsLast"?t[1][0]:t[2][0],g=l==="channelsLast"?t[1][1]:t[2][1],y=l==="channelsLast"?t[2][0]:t[3][0],x=l==="channelsLast"?t[2][1]:t[3][1];c={top:p,bottom:g,left:y,right:x,type:p===0&&g===0&&y===0&&x===0?"VALID":"EXPLICIT"},d=yf((e-o+p+g)/r+1,a),f=yf((n-i+y+x)/s+1,a)}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:c,outHeight:d,outWidth:f}}function sY(t,e,n,r,s,o,i,a,l,c,d){let f,p,g,y;if(t==="valid"&&(t=0),typeof t=="number"){f={top:t,bottom:t,left:t,right:t,front:t,back:t,type:t===0?"VALID":"NUMBER"};const w=nY([e,n,r,1],[a,l,c],1,[s,o,i],t,d);p=w[0],g=w[1],y=w[2]}else if(t==="same"){p=Math.ceil(e/s),g=Math.ceil(n/o),y=Math.ceil(r/i);const x=(p-1)*s+a-e,w=(g-1)*o+l-n,S=(y-1)*i+c-r,$=Math.floor(x/2),I=x-$,R=Math.floor(w/2),_=w-R,O=Math.floor(S/2),F=S-O;f={top:R,bottom:_,left:O,right:F,front:$,back:I,type:"SAME"}}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:f,outDepth:p,outHeight:g,outWidth:y}}function yf(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function xf(t){const[e,n,r]=gf(t);return e===1&&n===1&&r===1}function Er(t,e){return xf(t)||xf(e)}function Du(t){return gf(t).every(e=>e>0)}function Mo(t){if(t==="NHWC")return"channelsLast";if(t==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function po(t,e,n){if(n!=null){if(typeof e=="string")throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if(typeof e=="number")z(id(e),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(s=>{z(id(s),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${s}.`)})});else throw Error(`Error in ${t}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oY(t,e){const r={x:L(t,"x","reshape","string_or_numeric")},s={shape:e};return Y.runKernel(Y2,r,s)}const ye=X({reshape_:oY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iY(t,e,n,r,s){const o=L(t,"x","avgPool","float32"),i=1;z(Er(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let a=o,l=!1;o.rank===3&&(l=!0,a=ye(o,[1,o.shape[0],o.shape[1],o.shape[2]])),z(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),po("avgPool",r,s);const c={x:a},d={filterSize:e,strides:n,pad:r,dimRoundingMode:s};let f=Y.runKernel(gw,c,d);return f=Qt(f,o.dtype),l?ye(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const JA=X({avgPool_:iY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aY(t,e,n,r,s,o="NDHWC"){const i=L(t,"x","avgPool3d","float32");let a=i,l=!1;i.rank===4&&(l=!0,a=ye(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),z(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),z(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),z(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),po("avgPool3d",r,s);const c={x:a},d={filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:o};let f=Y.runKernel(yw,c,d);return f=Qt(f,a.dtype),l?ye(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const lY=X({avgPool3d_:aY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uY(t,e=0){z(t.length>=1,()=>"Pass at least one tensor to concat");const n=Tg(t,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),n.length===1)return fl(n[0]);const r=n,s={axis:e};return Y.runKernel(Tw,r,s)}const Fn=X({concat_:uY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cY(t,e,n=!1,r=!1){let s=L(t,"a","matMul"),o=L(e,"b","matMul");[s,o]=yn(s,o);const i={a:s,b:o},a={transposeA:n,transposeB:r};return Y.runKernel(xw,i,a)}const Ht=X({matMul_:cY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dY(t){const n={x:L(t,"x","sigmoid","float32")};return Y.runKernel(hS,n)}const aa=X({sigmoid_:dY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hY(t,e,n){const r=L(t,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},o={begin:e,size:n};return Y.runKernel(lS,s,o)}const pt=X({slice_:hY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fY(t){const n={x:L(t,"x","tanh","float32")};return Y.runKernel(IS,n)}const pv=X({tanh_:fY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pY(t,e,n,r,s,o){const i=L(t,"forgetBias","basicLSTMCell"),a=L(e,"lstmKernel","basicLSTMCell"),l=L(n,"lstmBias","basicLSTMCell"),c=L(r,"data","basicLSTMCell"),d=L(s,"c","basicLSTMCell"),f=L(o,"h","basicLSTMCell"),p=Fn([c,f],1),g=Ht(p,a),y=We(g,l),x=y.shape[0],w=y.shape[1]/4,S=[x,w],$=pt(y,[0,0],S),I=pt(y,[0,w],S),R=pt(y,[0,w*2],S),_=pt(y,[0,w*3],S),O=We(Te(aa($),pv(I)),Te(d,aa(We(i,R)))),F=Te(pv(O),aa(_));return[O,F]}const mY=X({basicLSTMCell_:pY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gY(t,e,n){const r=L(t,"x","batchToSpaceND"),s=e.reduce((a,l)=>a*l);z(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),z(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),z(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const o={x:r},i={blockShape:e,crops:n};return Y.runKernel(vw,o,i)}const eD=X({batchToSpaceND_:gY});function yY(t){let e;return t.rank===0||t.rank===1?e=ye(t,[1,1,1,t.size]):t.rank===2?e=ye(t,[1,1,t.shape[0],t.shape[1]]):t.rank===3?e=ye(t,[1,t.shape[0],t.shape[1],t.shape[2]]):e=t,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xY(t,e,n,r,s,o){o==null&&(o=.001);const i=L(t,"x","batchNorm"),a=L(e,"mean","batchNorm"),l=L(n,"variance","batchNorm");let c;s!=null&&(c=L(s,"scale","batchNorm"));let d;r!=null&&(d=L(r,"offset","batchNorm")),z(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),z(d==null||a.rank===d.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),z(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const p={x:yY(i),scale:c,offset:d,mean:a,variance:l},g={varianceEpsilon:o},y=Y.runKernel(r2,p,g);return ye(y,i.shape)}const ly=X({batchNorm_:xY});function vY(t,e,n,r,s,o){const i=L(t,"x","batchNorm"),a=L(e,"mean","batchNorm"),l=L(n,"variance","batchNorm");let c;s!=null&&(c=L(s,"scale","batchNorm"));let d;return r!=null&&(d=L(r,"offset","batchNorm")),z(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),z(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),z(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&z(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),d!=null&&z(d.rank===2||d.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${d.rank}.`),ly(i,a,l,d,c,o)}const bY=X({batchNorm2d_:vY});function wY(t,e,n,r,s,o){const i=L(t,"x","batchNorm"),a=L(e,"mean","batchNorm"),l=L(n,"variance","batchNorm");let c;s!=null&&(c=L(s,"scale","batchNorm"));let d;return r!=null&&(d=L(r,"offset","batchNorm")),z(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),z(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),z(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&z(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),d!=null&&z(d.rank===3||d.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${d.rank}.`),ly(i,a,l,d,c,o)}const SY=X({batchNorm3d_:wY});function CY(t,e,n,r,s,o){const i=L(t,"x","batchNorm"),a=L(e,"mean","batchNorm"),l=L(n,"variance","batchNorm");let c;s!=null&&(c=L(s,"scale","batchNorm"));let d;return r!=null&&(d=L(r,"offset","batchNorm")),z(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),z(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),z(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&z(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),d!=null&&z(d.rank===4||d.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${d.rank}.`),ly(i,a,l,d,c,o)}const $Y=X({batchNorm4d_:CY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kY(t,e,n){const r=L(t,"x","bincount"),s=L(e,"weights","bincount");z(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),z(n>=0,()=>`size must be non-negative, but got ${n}.`),z(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const o={x:r,weights:s},i={size:n};return Y.runKernel(bw,o,i)}const tD=X({bincount_:kY});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TY(t,e){const n=L(t,"x","bitwiseAnd"),r=L(e,"y","bitwiseAnd");if(!Vt(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if(n.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);const s={a:n,b:r};return Y.runKernel(JP,s)}const IY=X({bitwiseAnd_:TY});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NY(t,e){const n=L(t,"s0","broadcastArgs","int32"),r=L(e,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:n,s1:r};return Y.runKernel(ww,s)}const EY=X({broadcastArgs_:NY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RY(t,e){let n=L(t,"broadcastTo","x");const r=n.shape;if(Fs(e),e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const c=n.shape.slice();for(;c.length<e.length;)c.unshift(1);n=ye(n,c)}const s=n.shape,o=Array.from(e);for(let c=e.length-1;c>=0;c--)if(s[c]===e[c])o[c]=1;else if(n.shape[c]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(o.map((c,d)=>c>1?d:-1).filter(c=>c>=0).length===0)return fl(n);const a={x:n},l={reps:o};return Y.runKernel(sy,a,l)}const Qh=X({broadcastTo_:RY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Y(t){const n={x:L(t,"x","ceil","float32")};return Y.runKernel(Sw,n)}const PY=X({ceil_:_Y});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xf(t,e,n){Fs(t),n=n||$d(e);const r={shape:t,value:e,dtype:n};return Y.runKernel(Jw,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AY(t,e,n){const r=L(t,"x","clipByValue");if(z(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`),e===n)return Xf(r.shape,e,r.dtype);const s={x:r},o={clipValueMin:e,clipValueMax:n};return Y.runKernel(Cw,s,o)}const nD=X({clipByValue_:AY});function DY(t){return Fn(t,0)}const OY=X({concat1d_:DY});function FY(t,e){return Fn(t,e)}const LY=X({concat2d_:FY});function zY(t,e){return Fn(t,e)}const BY=X({concat3d_:zY});function MY(t,e){return Fn(t,e)}const VY=X({concat4d_:MY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WY(t,e,n,r,s="NHWC",o=[1,1],i){const a=L(t,"x","conv2d","float32"),l=L(e,"filter","conv2d","float32");let c=a,d=!1;a.rank===3&&(d=!0,c=ye(a,[1,a.shape[0],a.shape[1],a.shape[2]])),z(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),z(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),po("conv2d",r,i);const f=s==="NHWC"?c.shape[3]:c.shape[1];z(f===l.shape[2],()=>`Error in conv2d: depth of input (${f}) must match input depth for filter ${l.shape[2]}.`),z(Er(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),z(Du(o),()=>"Error in conv2D: Dilated rates should be larger than 0."),z(Du(n),()=>"Error in conv2D: Strides should be larger than 0.");const p={x:c,filter:l},g={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i},y=Y.runKernel(Iw,p,g);return d?ye(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const uy=X({conv2d_:WY});function UY(t,e,n,r,s="NWC",o=1,i){const a=L(t,"x","conv1d"),l=L(e,"filter","conv1d");let c=a,d=!1;a.rank===2&&(d=!0,c=ye(a,[1,a.shape[0],a.shape[1]])),z(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),z(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),po("conv1d",r,i),z(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),z(Er(n,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${o}'`),z(Du(o),()=>"Error in conv1D: Dilated rates should be larger than 0."),z(Du(n),()=>"Error in conv1D: Stride should be larger than 0."),z(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const f=ye(l,[1,l.shape[0],l.shape[1],l.shape[2]]),p=ye(c,[c.shape[0],1,c.shape[1],c.shape[2]]),w=uy(p,f,[1,n],r,"NHWC",[1,o],i);return d?ye(w,[w.shape[2],w.shape[3]]):ye(w,[w.shape[0],w.shape[2],w.shape[3]])}const jY=X({conv1d_:UY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GY(t,e,n,r,s,o="NHWC",i){z(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let a=t,l=e,c=!1;e.rank===3&&(c=!0,l=ye(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,t[0],t[1],t[2]]),z(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),z(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),z(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const d=o==="NHWC"?a[3]:a[1],f=o==="NHWC"?l.shape[3]:l.shape[1];z(d===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${d}) must match input depth for filter ${n.shape[2]}.`),z(f===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${f}) must match output depth for filter ${n.shape[3]}.`),po("conv2dDerInput",s,i);const p={dy:l,filter:n},g={strides:r,pad:s,dataFormat:o,dimRoundingMode:i,inputShape:a},y=Y.runKernel(Ew,p,g);return c?ye(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const rD=X({conv2DBackpropInput_:GY});function HY(t,e,n,r,s,o){const i=L(t,"x","conv2dTranspose"),a=L(e,"filter","conv2dTranspose");return rD(n,i,a,r,s,"NHWC",o)}const KY=X({conv2dTranspose_:HY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XY(t,e,n,r,s="NDHWC",o=[1,1,1]){const i=L(t,"x","conv3d"),a=L(e,"filter","conv3d");let l=i,c=!1;i.rank===4&&(c=!0,l=ye(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),z(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),z(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),z(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),z(Er(n,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),z(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),z(Du(o),()=>"Error in conv3D: Dilated rates should be larger than 0."),z(Du(n),()=>"Error in conv3D: Strides should be larger than 0.");const d={x:l,filter:a},f={strides:n,pad:r,dataFormat:s,dilations:o},p=Y.runKernel(Rw,d,f);return c?ye(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const qY=X({conv3d_:XY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YY(t,e,n,r,s){z(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let o=t,i=e,a=!1;e.rank===4&&(a=!0,i=ye(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),o=[1,t[0],t[1],t[2],t[3]]);const l=o[4],c=i.shape[4];z(o.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),z(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),z(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),z(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),z(c===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[4]}.`);const d={dy:i,filter:n},f={pad:s,strides:r,inputShape:o},p=Y.runKernel(_w,d,f);return a?ye(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const QY=X({conv3DBackpropInput_:YY});function ZY(t,e,n,r,s){const o=L(t,"x","conv3dTranspose"),i=L(e,"filter","conv3dTranspose");return QY(n,o,i,r,s)}const JY=X({conv3dTranspose_:ZY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eQ(t){const n={x:L(t,"x","cos","float32")};return Y.runKernel(Pw,n)}const tQ=X({cos_:eQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nQ(t){const n={x:L(t,"x","cosh","float32")};return Y.runKernel(Aw,n)}const rQ=X({cosh_:nQ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sQ(t,e=0,n=!1,r=!1){const o={x:L(t,"x","cumprod")},i={axis:e,exclusive:n,reverse:r};return Y.runKernel(Dw,o,i)}const oQ=X({cumprod_:sQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iQ(t,e=0,n=!1,r=!1){const o={x:L(t,"x","cumsum")},i={axis:e,exclusive:n,reverse:r};return Y.runKernel(Ow,o,i)}const aQ=X({cumsum_:iQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lQ(t,e,n,r=!1){const s=L(t,"x","denseBincount"),o=L(e,"weights","denseBincount");z(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),z(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),z(n>=0,()=>`size must be non-negative, but got ${n}.`),z(o.size===s.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`);const i={x:s,weights:o},a={size:n,binaryOutput:r};return Y.runKernel(Lw,i,a)}const uQ=X({denseBincount_:lQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cQ(t,e,n="NHWC"){const r=L(t,"x","depthToSpace","float32"),s=n==="NHWC"?r.shape[1]:r.shape[2],o=n==="NHWC"?r.shape[2]:r.shape[3],i=n==="NHWC"?r.shape[3]:r.shape[1];z(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),z(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${r.shape}`),z(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e} for depthToSpace with input shape
        ${r.shape}`),z(i%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${i} for depthToSpace with input shape ${r.shape}`);const a={x:r},l={blockSize:e,dataFormat:n};return Y.runKernel(zw,a,l)}const dQ=X({depthToSpace_:cQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hQ(t,e,n,r,s="NHWC",o=[1,1],i){const a=L(t,"x","depthwiseConv2d","float32"),l=L(e,"filter","depthwiseConv2d","float32");let c=a,d=!1;a.rank===3&&(d=!0,c=ye(a,[1,a.shape[0],a.shape[1],a.shape[2]])),z(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),z(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const f=s==="NHWC"?c.shape[3]:c.shape[1];z(f===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${f}) must match the inChannels dimension in filter ${l.shape[2]}.`),po("depthwiseConv2d",r,i);const p={x:c,filter:l},g={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i},y=Y.runKernel(Bw,p,g);return d?ye(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const zS=X({depthwiseConv2d_:hQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fQ(t){const n={x:L(t,"x","diag")};return Y.runKernel(Ww,n)}const pQ=X({diag_:fQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mQ(t,e,n,r,s=[1,1],o="NHWC"){const i=L(t,"x","dilation2d"),a=L(e,"filter","dilation2d");z(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),z(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),z(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let l=i,c=!1;i.rank===3&&(l=ye(i,[1,i.shape[0],i.shape[1],i.shape[2]]),c=!0),z(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const d={x:l,filter:a},f={strides:n,pad:r,dilations:s},p=Y.runKernel(Uw,d,f);return c?ye(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const gQ=X({dilation2d_:mQ});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cd(t,e){const n=t.length,r=[];for(let s=0;s<n;s++){const o=n-1-s,i=t[o]||1;(e[e.length-1-s]||1)>1&&i===1&&r.unshift(o)}return r}function sD(t,e){const n=[];for(let r=0;r<e.length;r++){const s=t[t.length-r-1],o=e.length-r-1,i=e[o];(s==null||s===1&&i>1)&&n.unshift(o)}return n}function ct(t,e){const n=Math.max(t.length,e.length),r=new Array(n);for(let s=0;s<n;s++){let o=t[t.length-s-1];o==null&&(o=1);let i=e[e.length-s-1];if(i==null&&(i=1),o===1)r[n-s-1]=i;else if(i===1)r[n-s-1]=o;else if(o!==i){const a=`Operands could not be broadcast together with shapes ${t} and ${e}.`;throw Error(a)}else r[n-s-1]=o}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yQ(t,e){let n=L(t,"a","equal","string_or_numeric"),r=L(e,"b","equal","string_or_numeric");[n,r]=yn(n,r),ct(n.shape,r.shape);const s={a:n,b:r};return Y.runKernel(Xw,s)}const oD=X({equal_:yQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xQ(t,e,n){const r=L(e,"a","where"),s=L(n,"b","where"),o=L(t,"condition","where","bool"),i=ct(ct(o.shape,r.shape),s.shape),a=Qh(o,i),l=Qh(r,i),c=Qh(s,i),d={condition:a,t:l,e:c};return Y.runKernel(iS,d)}const pl=X({where_:xQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vQ(t){const n={x:L(t,"x","zerosLike")};return Y.runKernel(PS,n)}const Os=X({zerosLike_:vQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bQ(t,e){let n=L(t,"a","div"),r=L(e,"b","div");[n,r]=yn(n,r);const s=gt(n,r),o=Os(s),i=oD(r,o);return pl(i,o,s)}const wQ=X({divNoNan_:bQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SQ(t,e){const n=L(t,"t1","dot"),r=L(e,"t2","dot");z((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);const s=n.rank===1?n.size:n.shape[1],o=r.rank===1?r.size:r.shape[0];if(z(s===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${o}.`),n.rank===1&&r.rank===1){const i=ye(n,[1,-1]),a=ye(r,[-1,1]),l=Ht(i,a);return ye(l,[])}else if(n.rank===1&&r.rank===2){const i=ye(n,[1,-1]),a=ye(r,[r.shape[0],r.shape[1]]),l=Ht(i,a);return ye(l,[l.size])}else if(n.rank===2&&r.rank===1){const i=ye(r,[-1,1]),a=Ht(n,i);return ye(a,[a.size])}else{const i=ye(r,[r.shape[0],r.shape[1]]);return Ht(n,i)}}const CQ=X({dot_:SQ});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Q(t,...e){const n=e.map((s,o)=>L(s,`tensors${o}`,"einsum")),r={equation:t};return Y.runKernel(Gw,n,r)}const _c=X({einsum_:$Q});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kQ(t){const n={x:L(t,"x","elu","float32")};return Y.runKernel(Hw,n)}const iD=X({elu_:kQ});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TQ(t,e){const n=L(t,"x","ensureShape","string_or_numeric");if(!nX(n.shape,e))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${e}`);return t}const IQ=X({ensureShape_:TQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NQ(t){let e=L(t,"x","erf");z(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Qt(e,"float32"));const n={x:e};return Y.runKernel(Kw,n)}const EQ=X({erf_:NQ});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BS(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function aD(t,e,n){const r=t.length+e.length,s=[];let o=0,i=0;for(let a=0;a<r;a++)n.indexOf(a)===-1?s.push(t[o++]):s.push(e[i++]);return s}function Ls(t,e){const n=[],r=t.length;for(let o=0;o<r;o++)e.indexOf(o)===-1&&n.push(t[o]);const s=e.map(o=>t[o]);return[n,s]}function vs(t,e){const n=e.map(r=>1);return aD(t,n,e)}function bs(t,e,n){z(BS(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function ur(t,e){if(BS(t,e))return null;const n=[];for(let r=0;r<e;++r)t.indexOf(r)===-1&&n.push(r);return t.forEach(r=>n.push(r)),n}function qf(t){return t.map((e,n)=>[n,e]).sort((e,n)=>e[1]-n[1]).map(e=>e[0])}function cr(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RQ(t,e=null,n=!1){const s={x:L(t,"x","max")},o={reductionIndices:e,keepDims:n};return Y.runKernel(C2,s,o)}const Jc=X({max_:RQ});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Q(t,e=null,n=!1){const s={x:L(t,"x","min")},o={axis:e,keepDims:n};return Y.runKernel(E2,s,o)}const mv=X({min_:_Q});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PQ(t,e){let n=L(t,"base","pow"),r=L(e,"exp","pow");[n,r]=yn(n,r);const s={a:n,b:r};return Y.runKernel(U2,s)}const vf=X({pow_:PQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mt(t,e){if((co(t)&&e!=="string"||Array.isArray(t))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&co(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return kl(t,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AQ(t){const n={x:L(t,"x","sqrt","float32")};return Y.runKernel(pS,n)}const ma=X({sqrt_:AQ});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DQ(t){const e=L(t,"x","square"),n={};return Y.runKernel("Square",{x:e},n)}const lo=X({square_:DQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OQ(t,e=null,n=!1){let r=L(t,"x","sum");r.dtype==="bool"&&(r=Qt(r,"int32"));const s={x:r},o={axis:e,keepDims:n};return Y.runKernel(mS,s,o)}const en=X({sum_:OQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FQ(t,e="euclidean",n=null,r=!1){t=L(t,"x","norm");const s=lD(t,e,n);let o=s.shape;if(r){const i=nn(n,t.shape);o=vs(s.shape,i)}return ye(s,o)}function lD(t,e,n=null){if(t.rank===0)return Rs(t);if(t.rank!==1&&n===null)return lD(ye(t,[-1]),e,n);if(t.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(e===1)return en(Rs(t),n);if(e===1/0)return Jc(Rs(t),n);if(e===-1/0)return mv(Rs(t),n);if(e==="euclidean"||e===2)return ma(en(vf(Rs(t),mt(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&n.length===2){if(e===1)return Jc(en(Rs(t),n[0]),n[1]-1);if(e===1/0)return Jc(en(Rs(t),n[1]),n[0]);if(e===-1/0)return mv(en(Rs(t),n[1]),n[0]);if(e==="fro"||e==="euclidean")return ma(en(lo(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const cy=X({norm_:FQ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LQ(t,e=null,n=!1){return cy(t,"euclidean",e,n)}const zQ=X({euclideanNorm_:LQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BQ(t){const n={x:L(t,"x","exp")};return Y.runKernel(qw,n)}const ga=X({exp_:BQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MQ(t,e=0){const n=L(t,"x","expandDims","string_or_numeric");z(e<=n.rank,()=>"Axis must be <= rank of the tensor");const r={input:n},s={dim:e};return Y.runKernel(Yw,r,s)}const _s=X({expandDims_:MQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VQ(t){const n={x:L(t,"x","expm1")};return Y.runKernel(Qw,n)}const WQ=X({expm1_:VQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UQ(t,e){const n=L(t,"x","tile","string_or_numeric");z(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`);const r={x:n},s={reps:e};return Y.runKernel(sy,r,s)}const Zh=X({tile_:UQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jQ(t,e,n,r="float32"){e==null&&(e=t);const s=Wt([t,e],r),o=t<=e?t:e;for(let a=0;a<o;++a)s.set(1,a,a);const i=ye(s.toTensor(),[t,e]);if(n==null)return i;if(n.length===1)return Zh(_s(i,0),[n[0],1,1]);if(n.length===2)return Zh(_s(_s(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return Zh(_s(_s(_s(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const uD=X({eye_:jQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GQ(t){const n={x:L(t,"x","floor","float32")};return Y.runKernel(t2,n)}const cD=X({floor_:GQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HQ(t,e,n=0,r=0){const s=L(t,"x","gather"),o=L(e,"indices","gather","int32"),i={x:s,indices:o},a={axis:n,batchDims:r};return Y.runKernel(s2,i,a)}const dD=X({gather_:HQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KQ(t,e){let n=L(t,"a","greater","string_or_numeric"),r=L(e,"b","greater","string_or_numeric");[n,r]=yn(n,r),ct(n.shape,r.shape);const s={a:n,b:r};return Y.runKernel(i2,s)}const dy=X({greater_:KQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XQ(t,e){let n=L(t,"a","greaterEqual","string_or_numeric"),r=L(e,"b","greaterEqual","string_or_numeric");[n,r]=yn(n,r),ct(n.shape,r.shape);const s={a:n,b:r};return Y.runKernel(a2,s)}const hD=X({greaterEqual_:XQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qQ(t){const n={input:L(t,"input","imag")};return Y.runKernel(u2,n)}const hy=X({imag_:qQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YQ(t){const n={x:L(t,"x","isFinite")};return Y.runKernel(c2,n)}const QQ=X({isFinite_:YQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZQ(t){const n={x:L(t,"x","isInf")};return Y.runKernel(d2,n)}const JQ=X({isInf_:ZQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eZ(t){const n={x:L(t,"x","isNaN")};return Y.runKernel(h2,n)}const tZ=X({isNaN_:eZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nZ(t,e=.2){const r={x:L(t,"x","leakyRelu")},s={alpha:e};return Y.runKernel(f2,r,s)}const fD=X({leakyRelu_:nZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rZ(t,e){let n=L(t,"a","less","string_or_numeric"),r=L(e,"b","less","string_or_numeric");[n,r]=yn(n,r),ct(n.shape,r.shape);const s={a:n,b:r};return Y.runKernel(p2,s)}const gv=X({less_:rZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sZ(t,e){let n=L(t,"a","lessEqual","string_or_numeric"),r=L(e,"b","lessEqual","string_or_numeric");[n,r]=yn(n,r),ct(n.shape,r.shape);const s={a:n,b:r};return Y.runKernel(m2,s)}const MS=X({lessEqual_:sZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oZ(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:t,stop:e,num:n};return Y.runKernel(g2,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iZ(t,e=5,n=1,r=1,s=.5){const o=L(t,"x","localResponseNormalization");z(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),z(id(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let i=o,a=!1;o.rank===3&&(a=!0,i=ye(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const l={x:i},c={depthRadius:e,bias:n,alpha:r,beta:s},d=Y.runKernel(S2,l,c);return a?ye(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const aZ=X({localResponseNormalization_:iZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lZ(t){const n={x:L(t,"x","log","float32")};return Y.runKernel(y2,n)}const bf=X({log_:lZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uZ(t){const n={x:L(t,"x","log1p")};return Y.runKernel(x2,n)}const pD=X({log1p_:uZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cZ(t,e){z(ev(t),()=>"The f passed in variableGrads(f) must be a function"),z(e==null||Array.isArray(e)&&e.every(c=>c instanceof kg),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=e!=null;if(!n){e=[];for(const c in Y.registeredVariables)e.push(Y.registeredVariables[c])}const r=n?e.filter(c=>!c.trainable):null,s=e.length;e=e.filter(c=>c.trainable),z(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const o=!0,{value:i,grads:a}=Y.gradients(t,e,null,o);z(a.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),z(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const l={};return e.forEach((c,d)=>{a[d]!=null&&(l[c.name]=a[d])}),r!=null&&r.forEach(c=>l[c.name]=null),{value:i,grads:l}}function ya(t){return Y.customGrad(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dZ(t){const n={x:L(t,"x","neg")};return Y.runKernel(O2,n)}const bi=X({neg_:dZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hZ(t){const n={x:L(t,"x","softplus")};return Y.runKernel(fS,n)}const mD=X({softplus_:hZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fZ(t){const e=L(t,"x","logSigmoid");return ya(r=>({value:bi(mD(bi(r))),gradFunc:i=>Te(i,aa(bi(r)))}))(e)}const pZ=X({logSigmoid_:fZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mZ(t,e){let n=L(t,"a","sub"),r=L(e,"b","sub");[n,r]=yn(n,r);const s={a:n,b:r};return Y.runKernel(kS,s)}const ot=X({sub_:mZ});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gZ(t,e=-1){const n=L(t,"logits","logSoftmax");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return ya((s,o)=>{const a=Jc(s,e,!0),l=ot(s,a),c=ot(Qt(l,"float32"),bf(en(ga(l),e,!0)));return o([c]),{value:c,gradFunc:(f,p)=>{const[g]=p,y=!0,x=ga(g);return ot(f,Te(en(f,e,y),x))}}})(n)}const yZ=X({logSoftmax_:gZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xZ(t,e=null,n=!1){const r=L(t,"x","logSumExp"),s=nn(e,r.shape),o=Jc(r,s,!0),i=ot(r,o),a=ga(i),l=en(a,s),c=bf(l),d=We(ye(o,c.shape),c);if(n){const f=vs(d.shape,s);return ye(d,f)}return d}const gD=X({logSumExp_:xZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vZ(t,e){const n=L(t,"a","logicalAnd","bool"),r=L(e,"b","logicalAnd","bool");ct(n.shape,r.shape);const s={a:n,b:r};return Y.runKernel(v2,s)}const Ig=X({logicalAnd_:vZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bZ(t){const n={x:L(t,"x","logicalNot","bool")};return Y.runKernel(b2,n)}const yD=X({logicalNot_:bZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wZ(t,e){const n=L(t,"a","logicalOr","bool"),r=L(e,"b","logicalOr","bool");ct(n.shape,r.shape);const s={a:n,b:r};return Y.runKernel(w2,s)}const xD=X({logicalOr_:wZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SZ(t,e){const n=L(t,"a","logicalXor","bool"),r=L(e,"b","logicalXor","bool");return ct(n.shape,r.shape),Ig(xD(t,e),yD(Ig(t,e)))}const CZ=X({logicalXor_:SZ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vm=2147483648;function $Z(t,e,n="left"){const r=L(t,"sortedSequence","searchSorted"),s=L(e,"values","searchSorted"),o=r.shape[r.shape.length-1],i=s.shape[s.shape.length-1],a=ye(r,[-1,o]),l=ye(s,[-1,i]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(pe(l.shape)>=vm)throw new Error(`values tensor size must less than ${vm}`);if(a.shape[1]>=vm)throw new Error(`trailing dim_size must less than ${vm} for int32 output type, was ${a.shape[1]}`);const c={sortedSequence:a,values:l},d={side:n};return Y.runKernel(oS,c,d)}const VS=X({searchSorted_:$Z});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kZ(t,e){return VS(t,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TZ(t,e,n,r,s){const o=L(t,"x","maxPool"),i=1;let a=o,l=!1;o.rank===3&&(l=!0,a=ye(o,[1,o.shape[0],o.shape[1],o.shape[2]])),z(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),z(Er(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),po("maxPool",r,s);const c={x:a},d={filterSize:e,strides:n,pad:r,dimRoundingMode:s},f=Y.runKernel(k2,c,d);return l?ye(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const vD=X({maxPool_:TZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IZ(t,e=[1,1,1],n,r,s,o="NDHWC"){const i=L(t,"x","maxPool3d");let a=i,l=!1;i.rank===4&&(l=!0,a=ye(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),z(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),z(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),po("maxPool3d",r,s);const c={x:a},d={filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:o},f=Y.runKernel(T2,c,d);return l?ye(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const NZ=X({maxPool3d_:IZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EZ(t,e,n,r,s=!1){const i={x:L(t,"x","maxPoolWithArgmax")},a={filterSize:e,strides:n,pad:r,includeBatchInIndex:s},l=Y.runKernel(I2,i,a);return{result:l[0],indexes:l[1]}}const RZ=X({maxPoolWithArgmax_:EZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Z(t,e){let n=L(t,"a","maximum"),r=L(e,"b","maximum");[n,r]=yn(n,r),n.dtype==="bool"&&(n=Qt(n,"int32"),r=Qt(r,"int32")),ct(n.shape,r.shape);const s={a:n,b:r};return Y.runKernel($2,s)}const bD=X({maximum_:_Z});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PZ(t,e=null,n=!1){const s={x:L(t,"x","mean")},o={axis:e,keepDims:n};return Y.runKernel(N2,s,o)}const Ng=X({mean_:PZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xa(t,e="float32"){if(Fs(t),e==="complex64"){const r=xa(t,"float32"),s=xa(t,"float32");return yl(r,s)}const n=ha(pe(t),e);return Y.makeTensor(n,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bu(t,e="float32"){if(Fs(t),e==="complex64"){const r=bu(t,"float32"),s=xa(t,"float32");return yl(r,s)}const n=XP(pe(t),e);return Y.makeTensor(n,t,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AZ(t,e,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(t===void 0)return[];let r=L(t,"x","meshgrid",t instanceof fn?t.dtype:"float32");if(e===void 0)return[r];let s=L(e,"y","meshgrid",e instanceof fn?e.dtype:"float32");const o=pe(r.shape),i=pe(s.shape);return n==="xy"?(r=ye(r,[1,-1]),s=ye(s,[-1,1]),[Ht(bu([i,1],r.dtype),r),Ht(s,bu([1,o],s.dtype))]):(r=ye(r,[-1,1]),s=ye(s,[1,-1]),[Ht(r,bu([1,i],r.dtype)),Ht(bu([o,1],s.dtype),s)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DZ(t,e){let n=L(t,"a","minimum"),r=L(e,"b","minimum");[n,r]=yn(n,r),n.dtype==="bool"&&(n=Qt(n,"int32"),r=Qt(r,"int32")),ct(n.shape,r.shape);const s={a:n,b:r};return Y.runKernel(R2,s)}const wf=X({minimum_:DZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OZ(t,e,n){z(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const r=L(t,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");z(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const s=n==="reflect"?1:0;for(let a=0;a<r.rank;a++)z(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),z(e[a][0]>=0&&e[a][0]<=r.shape[a]-s&&e[a][1]>=0&&e[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);const o={paddings:e,mode:n},i={x:r};return Y.runKernel(_2,i,o)}const wD=X({mirrorPad_:OZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FZ(t,e){let n=L(t,"a","mod"),r=L(e,"b","mod");[n,r]=yn(n,r);const s={a:n,b:r};return Y.runKernel(P2,s)}const LZ=X({mod_:FZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zZ(t,e=null,n=!1){t=L(t,"x","moments");const r=nn(e,t.shape),s=Ng(t,r,n);let o=s.shape;n||(o=vs(s.shape,r));const i=lo(ot(Qt(t,"float32"),ye(s,o))),a=Ng(i,r,n);return{mean:s,variance:a}}const BZ=X({moments_:zZ});function MZ(t,e,n,r){const s=L(e,"data","multiRNNCell"),o=Tg(n,"c","multiRNNCell"),i=Tg(r,"h","multiRNNCell");let a=s;const l=[];for(let f=0;f<t.length;f++){const p=t[f](a,o[f],i[f]);l.push(p[0]),l.push(p[1]),a=p[1]}const c=[],d=[];for(let f=0;f<l.length;f+=2)c.push(l[f]),d.push(l[f+1]);return[c,d]}const VZ=X({multiRNNCell_:MZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WZ(t,e,n,r=!1){const s=L(t,"logits","multinomial"),o=s.size,i=s.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const l={logits:i===1?ye(s,[1,-1]):s},c={numSamples:e,seed:n,normalized:r},d=Y.runKernel(A2,l,c);return i===1?ye(d,[d.size]):d}const UZ=X({multinomial_:WZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jZ(t,e){let n=L(t,"a","notEqual","string_or_numeric"),r=L(e,"b","notEqual","string_or_numeric");[n,r]=yn(n,r),ct(n.shape,r.shape);const s={a:n,b:r};return Y.runKernel(F2,s)}const SD=X({notEqual_:jZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GZ(t,e,n=1,r=0,s="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const i={indices:L(t,"indices","oneHot","int32")},a={dtype:s,depth:e,onValue:n,offValue:r};return Y.runKernel(M2,i,a)}const HZ=X({oneHot_:GZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KZ(t){const n={x:L(t,"x","onesLike")};return Y.runKernel(B2,n)}const XZ=X({onesLike_:KZ});function qZ(t,e){const n=L(t,"v1","outerProduct"),r=L(e,"v2","outerProduct");z(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);const s=ye(n,[-1,1]),o=ye(r,[1,-1]);return Ht(s,o)}const YZ=X({outerProduct_:qZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QZ(t,e,n=0){const r=L(t,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:n},o={x:r};return Y.runKernel(W2,o,s)}const vl=X({pad_:QZ});function ZZ(t,e,n=0){return z(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),vl(t,[e],n)}const JZ=X({pad1d_:ZZ});function eJ(t,e,n=0){return z(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),vl(t,e,n)}const tJ=X({pad2d_:eJ});function nJ(t,e,n=0){return z(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),vl(t,e,n)}const rJ=X({pad3d_:nJ});function sJ(t,e,n=0){return z(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),vl(t,e,n)}const oJ=X({pad4d_:sJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iJ(t,e,n){const r=L(t,"x","spaceToBatchND");z(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),z(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),z(r.shape.reduce((i,a,l)=>l>0&&l<=e.length?i&&(a+n[l-1][0]+n[l-1][1])%e[l-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:r},o={blockShape:e,paddings:n};return Y.runKernel(gS,s,o)}const CD=X({spaceToBatchND_:iJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aJ(t,e,n,r,s,o,i){s==null&&(s=[1,1]),o==null&&(o=1),r===0&&(r="valid");const a=L(t,"x","maxPool");let l=a,c=!1;a.rank===3&&(c=!0,l=ye(a,[1,a.shape[0],a.shape[1],a.shape[2]])),z(Er(o,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${s}'`);const d=fo(l.shape,e,o,s,r),f=[d.dilationHeight,d.dilationWidth];let p;r==="same"?p=uJ([d.filterHeight,d.filterWidth],f):p=[[0,0],[0,0]];const g=f[0]===1&&f[1]===1,[y,x]=lJ([d.inHeight,d.inWidth],f,p),w=g?r:"valid",S=g?l:CD(l,f,y),I=(n==="avg"?()=>JA(S,e,o,w,i):()=>vD(S,e,o,w,i))(),R=g?I:eD(I,f,x);return c?ye(R,[R.shape[1],R.shape[2],R.shape[3]]):R}function lJ(t,e,n){const r=n.map(d=>d[0]),s=n.map(d=>d[1]),o=t.concat(r,s),i=e.map((d,f)=>(d-o[f]%d)%d),a=s.map((d,f)=>d+i[f]),l=e.map((d,f)=>[r[f],a[f]]),c=e.map((d,f)=>[0,i[f]]);return[l,c]}function uJ(t,e){const r=t.map((i,a)=>i+(i-1)*(e[a]-1)).map(i=>i-1),s=r.map(i=>Math.floor(i/2)),o=r.map((i,a)=>i-s[a]);return r.map((i,a)=>[s[a],o[a]])}const cJ=X({pool_:aJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dJ(t,e){const n=L(t,"x","prelu"),r=L(e,"alpha","prelu"),s={x:n,alpha:r};return Y.runKernel(j2,s)}const $D=X({prelu_:dJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hJ(t,e=null,n=!1){let r=L(t,"x","prod");r.dtype==="bool"&&(r=Qt(r,"int32"));const s={x:r},o={axis:e,keepDims:n};return Y.runKernel(G2,s,o)}const fJ=X({prod_:hJ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pJ(t,e,n,r){const s=t.map((d,f)=>L(d,`tensors${f}`,"raggedGather","int32")),o=L(e,"paramsDenseValues","raggedGather"),i=L(n,"indices","raggedGather","int32"),a={paramsNestedSplits:s,paramsDenseValues:o,indices:i},l={outputRaggedRank:r},c=Y.runKernel(aA,a,l);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}const mJ=X({raggedGather_:pJ});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gJ(t,e,n){const r=L(t,"starts","raggedRange"),s=L(e,"limits","raggedRange",r.dtype),o=L(n,"deltas","raggedRange",r.dtype),i={starts:r,limits:s,deltas:o},a=Y.runKernel(lA,i);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}const yJ=X({raggedRange_:gJ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xJ(t,e,n,r,s){const o=L(t,"shape","raggedTensorToTensor","int32"),i=L(e,"values","raggedTensorToTensor"),a=L(n,"defaultValue","raggedTensorToTensor",i.dtype),l=r.map((f,p)=>L(f,`tensors${p}`,"raggedTensorToTensor","int32")),c={shape:o,values:i,defaultValue:a,rowPartitionTensors:l},d={rowPartitionTypes:s};return Y.runKernel(uA,c,d)}const vJ=X({raggedTensorToTensor_:xJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bJ(t,e,n){Fs(t);const r=pe(t);let s=null;if(n==null||n==="float32")s=new Float32Array(r);else if(n==="int32")s=new Int32Array(r);else if(n==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let o=0;o<r;o++)s[o]=e();return Y.makeTensor(s,t,n)}const wJ=X({rand_:bJ});var Hm={exports:{}},SJ=Hm.exports,$3;function CJ(){return $3||($3=1,function(t){(function(e,n,r){function s(l){var c=this,d=a();c.next=function(){var f=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=f-(c.c=f|0)},c.c=1,c.s0=d(" "),c.s1=d(" "),c.s2=d(" "),c.s0-=d(l),c.s0<0&&(c.s0+=1),c.s1-=d(l),c.s1<0&&(c.s1+=1),c.s2-=d(l),c.s2<0&&(c.s2+=1),d=null}function o(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function i(l,c){var d=new s(l),f=c&&c.state,p=d.next;return p.int32=function(){return d.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,f&&(typeof f=="object"&&o(f,d),p.state=function(){return o(d,{})}),p}function a(){var l=4022871197,c=function(d){d=String(d);for(var f=0;f<d.length;f++){l+=d.charCodeAt(f);var p=.02519603282416938*l;l=p>>>0,p-=l,p*=l,l=p>>>0,p-=l,l+=p*4294967296}return(l>>>0)*23283064365386963e-26};return c}n&&n.exports?n.exports=i:this.alea=i})(SJ,t)}(Hm)),Hm.exports}var Km={exports:{}},$J=Km.exports,k3;function kJ(){return k3||(k3=1,function(t){(function(e,n,r){function s(a){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var f=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^f^f>>>8},a===(a|0)?l.x=a:c+=a;for(var d=0;d<c.length+64;d++)l.x^=c.charCodeAt(d)|0,l.next()}function o(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function i(a,l){var c=new s(a),d=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(p+g)/(1<<21);while(y===0);return y},f.int32=c.next,f.quick=f,d&&(typeof d=="object"&&o(d,c),f.state=function(){return o(c,{})}),f}n&&n.exports?n.exports=i:this.xor128=i})($J,t)}(Km)),Km.exports}var Xm={exports:{}},TJ=Xm.exports,T3;function IJ(){return T3||(T3=1,function(t){(function(e,n,r){function s(a){var l=this,c="";l.next=function(){var f=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(f^f<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:c+=a;for(var d=0;d<c.length+64;d++)l.x^=c.charCodeAt(d)|0,d==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function o(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function i(a,l){var c=new s(a),d=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(p+g)/(1<<21);while(y===0);return y},f.int32=c.next,f.quick=f,d&&(typeof d=="object"&&o(d,c),f.state=function(){return o(c,{})}),f}n&&n.exports?n.exports=i:this.xorwow=i})(TJ,t)}(Xm)),Xm.exports}var qm={exports:{}},NJ=qm.exports,I3;function EJ(){return I3||(I3=1,function(t){(function(e,n,r){function s(a){var l=this;l.next=function(){var d=l.x,f=l.i,p,g;return p=d[f],p^=p>>>7,g=p^p<<24,p=d[f+1&7],g^=p^p>>>10,p=d[f+3&7],g^=p^p>>>3,p=d[f+4&7],g^=p^p<<7,p=d[f+7&7],p=p^p<<13,g^=p^p<<9,d[f]=g,l.i=f+1&7,g};function c(d,f){var p,g=[];if(f===(f|0))g[0]=f;else for(f=""+f,p=0;p<f.length;++p)g[p&7]=g[p&7]<<15^f.charCodeAt(p)+g[p+1&7]<<13;for(;g.length<8;)g.push(0);for(p=0;p<8&&g[p]===0;++p);for(p==8?g[7]=-1:g[p],d.x=g,d.i=0,p=256;p>0;--p)d.next()}c(l,a)}function o(a,l){return l.x=a.x.slice(),l.i=a.i,l}function i(a,l){a==null&&(a=+new Date);var c=new s(a),d=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(p+g)/(1<<21);while(y===0);return y},f.int32=c.next,f.quick=f,d&&(d.x&&o(d,c),f.state=function(){return o(c,{})}),f}n&&n.exports?n.exports=i:this.xorshift7=i})(NJ,t)}(qm)),qm.exports}var Ym={exports:{}},RJ=Ym.exports,N3;function _J(){return N3||(N3=1,function(t){(function(e,n,r){function s(a){var l=this;l.next=function(){var d=l.w,f=l.X,p=l.i,g,y;return l.w=d=d+1640531527|0,y=f[p+34&127],g=f[p=p+1&127],y^=y<<13,g^=g<<17,y^=y>>>15,g^=g>>>12,y=f[p]=y^g,l.i=p,y+(d^d>>>16)|0};function c(d,f){var p,g,y,x,w,S=[],$=128;for(f===(f|0)?(g=f,f=null):(f=f+"\0",g=0,$=Math.max($,f.length)),y=0,x=-32;x<$;++x)f&&(g^=f.charCodeAt((x+32)%f.length)),x===0&&(w=g),g^=g<<10,g^=g>>>15,g^=g<<4,g^=g>>>13,x>=0&&(w=w+1640531527|0,p=S[x&127]^=g+w,y=p==0?y+1:0);for(y>=128&&(S[(f&&f.length||0)&127]=-1),y=127,x=4*128;x>0;--x)g=S[y+34&127],p=S[y=y+1&127],g^=g<<13,p^=p<<17,g^=g>>>15,p^=p>>>12,S[y]=g^p;d.w=w,d.X=S,d.i=y}c(l,a)}function o(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function i(a,l){a==null&&(a=+new Date);var c=new s(a),d=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(p+g)/(1<<21);while(y===0);return y},f.int32=c.next,f.quick=f,d&&(d.X&&o(d,c),f.state=function(){return o(c,{})}),f}n&&n.exports?n.exports=i:this.xor4096=i})(RJ,t)}(Ym)),Ym.exports}var Qm={exports:{}},PJ=Qm.exports,E3;function AJ(){return E3||(E3=1,function(t){(function(e,n,r){function s(a){var l=this,c="";l.next=function(){var f=l.b,p=l.c,g=l.d,y=l.a;return f=f<<25^f>>>7^p,p=p-g|0,g=g<<24^g>>>8^y,y=y-f|0,l.b=f=f<<20^f>>>12^p,l.c=p=p-g|0,l.d=g<<16^p>>>16^y,l.a=y-f|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):c+=a;for(var d=0;d<c.length+20;d++)l.b^=c.charCodeAt(d)|0,l.next()}function o(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function i(a,l){var c=new s(a),d=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(p+g)/(1<<21);while(y===0);return y},f.int32=c.next,f.quick=f,d&&(typeof d=="object"&&o(d,c),f.state=function(){return o(c,{})}),f}n&&n.exports?n.exports=i:this.tychei=i})(PJ,t)}(Qm)),Qm.exports}var Zm={exports:{}};const DJ={},OJ=Object.freeze(Object.defineProperty({__proto__:null,default:DJ},Symbol.toStringTag,{value:"Module"})),FJ=iL(OJ);var LJ=Zm.exports,R3;function zJ(){return R3||(R3=1,function(t){(function(e,n,r){var s=256,o=6,i=52,a="random",l=r.pow(s,o),c=r.pow(2,i),d=c*2,f=s-1,p;function g(R,_,O){var F=[];_=_==!0?{entropy:!0}:_||{};var B=S(w(_.entropy?[R,I(n)]:R??$(),3),F),M=new y(F),V=function(){for(var P=M.g(o),re=l,ie=0;P<c;)P=(P+ie)*s,re*=s,ie=M.g(1);for(;P>=d;)P/=2,re/=2,ie>>>=1;return(P+ie)/re};return V.int32=function(){return M.g(4)|0},V.quick=function(){return M.g(4)/4294967296},V.double=V,S(I(M.S),n),(_.pass||O||function(P,re,ie,me){return me&&(me.S&&x(me,M),P.state=function(){return x(M,{})}),ie?(r[a]=P,re):P})(V,B,"global"in _?_.global:this==r,_.state)}function y(R){var _,O=R.length,F=this,B=0,M=F.i=F.j=0,V=F.S=[];for(O||(R=[O++]);B<s;)V[B]=B++;for(B=0;B<s;B++)V[B]=V[M=f&M+R[B%O]+(_=V[B])],V[M]=_;(F.g=function(P){for(var re,ie=0,me=F.i,ge=F.j,ve=F.S;P--;)re=ve[me=f&me+1],ie=ie*s+ve[f&(ve[me]=ve[ge=f&ge+re])+(ve[ge]=re)];return F.i=me,F.j=ge,ie})(s)}function x(R,_){return _.i=R.i,_.j=R.j,_.S=R.S.slice(),_}function w(R,_){var O=[],F=typeof R,B;if(_&&F=="object")for(B in R)try{O.push(w(R[B],_-1))}catch{}return O.length?O:F=="string"?R:R+"\0"}function S(R,_){for(var O=R+"",F,B=0;B<O.length;)_[f&B]=f&(F^=_[f&B]*19)+O.charCodeAt(B++);return I(_)}function $(){try{var R;return p&&(R=p.randomBytes)?R=R(s):(R=new Uint8Array(s),(e.crypto||e.msCrypto).getRandomValues(R)),I(R)}catch{var _=e.navigator,O=_&&_.plugins;return[+new Date,e,O,e.screen,I(n)]}}function I(R){return String.fromCharCode.apply(0,R)}if(S(r.random(),n),t.exports){t.exports=g;try{p=FJ}catch{}}else r["seed"+a]=g})(typeof self<"u"?self:LJ,[],Math)}(Zm)),Zm.exports}var K1,_3;function BJ(){if(_3)return K1;_3=1;var t=CJ(),e=kJ(),n=IJ(),r=EJ(),s=_J(),o=AJ(),i=zJ();return i.alea=t,i.xor128=e,i.xorwow=n,i.xorshift7=r,i.xor4096=s,i.tychei=o,K1=i,K1}var WS=BJ();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class US{constructor(e,n,r,s,o){this.mean=e,this.stdDev=n,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const i=o||Math.random();this.random=WS.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,n,r=!1;for(;!r;){let s,o,i;do s=2*this.random()-1,o=2*this.random()-1,i=s*s+o*o;while(i>=1||i===0);const a=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*s*a,n=this.mean+this.stdDev*o*a,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class MJ{constructor(e,n,r,s){this.alpha=e,this.beta=1/n,this.dtype=r;const o=s||Math.random();this.randu=WS.alea(o.toString()),this.randn=new US(0,1,r,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,n,r,s,o,i;for(;;){do s=this.randn.nextValue(),i=1+this.c*s;while(i<=0);if(i*=i*i,e=s*s,n=1-.331*e*e,r=.5*e+this.d*(1-i+Math.log(i)),o=this.randu(),o<n||Math.log(o)<r)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class VJ{constructor(e=0,n=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=n-e,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${n} <= 1 and dtype is not float`);this.random=WS.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WJ(t,e,n=1,r="float32",s){if(Fs(t),n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);const o=new MJ(e,n,r,s),i=Wt(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const UJ=X({randomGamma_:WJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jJ(t,e=0,n=1,r,s){if(Fs(t),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const o=new US(e,n,r,!1,s),i=Wt(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const kD=X({randomNormal_:jJ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GJ(t,e,n){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return kD(t,0,1,e,n)}const HJ=X({randomStandardNormal_:GJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KJ(t,e=0,n=1,r="float32",s){Fs(t);const o=Wt(t,r),i=new VJ(e,n,null,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const jS=X({randomUniform_:KJ});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XJ(t,e,n,r){return jS(t,e,n,"int32",r)}const qJ=X({randomUniformInt_:XJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sf(t,e,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");const s={start:t,stop:e,step:n,dtype:r};return Y.runKernel(H2,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YJ(t){const n={input:L(t,"input","real")};return Y.runKernel(K2,n)}const Cf=X({real_:YJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QJ(t){const n={x:L(t,"x","reciprocal")};return Y.runKernel(X2,n)}const ZJ=X({reciprocal_:QJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JJ(t){const n={x:L(t,"x","relu")};return Y.runKernel(q2,n)}const fy=X({relu_:JJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eee(t){const n={x:L(t,"x","relu6")};return Y.runKernel(J2,n)}const TD=X({relu6_:eee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tee(t,e){const r={x:L(t,"x","reverse")},s={dims:e};return Y.runKernel(eS,r,s)}const Ou=X({reverse_:tee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nee(t){const e=L(t,"x","reverse");return z(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Ou(e,0)}const ree=X({reverse1d_:nee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function see(t,e){const n=L(t,"x","reverse");return z(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),Ou(n,e)}const oee=X({reverse2d_:see});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iee(t,e){const n=L(t,"x","reverse");return z(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),Ou(n,e)}const aee=X({reverse3d_:iee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lee(t,e){const n=L(t,"x","reverse");return z(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),Ou(n,e)}const uee=X({reverse4d_:lee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cee(t){const n={x:L(t,"x","round")};return Y.runKernel(tS,n)}const ID=X({round_:cee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dee(t){const n={x:L(t,"x","rsqrt","float32")};return Y.runKernel(nS,n)}const hee=X({rsqrt_:dee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fee(t){const n={x:L(t,"x","selu")};return Y.runKernel(aS,n)}const pee=X({selu_:fee});function mee(t,e,n,r,s,o=[1,1],i="NHWC"){const a=L(t,"x","separableConv2d"),l=L(e,"depthwiseFilter","separableConv2d"),c=L(n,"pointwiseFilter","separableConv2d");let d=a,f=!1;if(a.rank===3&&(f=!0,d=ye(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");z(d.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${d.rank}.`),z(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),z(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),z(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),z(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const p=l.shape[2],g=l.shape[3];z(c.shape[2]===p*g,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*g}, but got ${c.shape[2]}.`);const y=zS(d,l,r,s,i,o),w=uy(y,c,1,"valid",i);return f?ye(w,[w.shape[1],w.shape[2],w.shape[3]]):w}const gee=X({separableConv2d_:mee});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function yee(t,e){const n=L(t,"x","setdiff1d"),r=L(e,"y","setdiff1d");z(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),z(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),z(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await n.data(),o=await r.data(),i=new Set(o);let a=0;for(let d=0;d<s.length;d++)i.has(s[d])||a++;const l=new ad([a],n.dtype),c=new ad([a],"int32");for(let d=0,f=0;d<s.length;d++)i.has(s[d])||(l.values[f]=s[d],c.values[f]=d,f++);return[l.toTensor(),c.toTensor()]}const xee=yee;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vee(t){const n={x:L(t,"x","sign")};return Y.runKernel(dS,n)}const bee=X({sign_:vee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wee(t){const n={x:L(t,"x","sin","float32")};return Y.runKernel(uS,n)}const See=X({sin_:wee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cee(t){const n={x:L(t,"x","sinh")};return Y.runKernel(cS,n)}const $ee=X({sinh_:Cee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kee(t,e,n){const r=L(t,"x","slice1d");return z(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),pt(r,[e],[n])}const Tee=X({slice1d_:kee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iee(t,e,n){const r=L(t,"x","slice2d");return z(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),pt(r,e,n)}const Nee=X({slice2d_:Iee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eee(t,e,n){const r=L(t,"x","slice3d");return z(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),pt(r,e,n)}const Ree=X({slice3d_:Eee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ee(t,e,n){const r=L(t,"x","slice4d");return z(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),pt(r,e,n)}const Pee=X({slice4d_:_ee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aee(t,e=-1){const n=L(t,"logits","softmax","float32");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const r={logits:n},s={dim:e};return Y.runKernel(xS,r,s)}const Dee=X({softmax_:Aee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oee(t){z(t.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);const e={input:t};return Y.runKernel(Zw,e)}const GS=X({fft_:Oee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fee(t){z(t.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);const e={input:t};return Y.runKernel(l2,e)}const Eg=X({ifft_:Fee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lee(t){const e=t.shape[t.shape.length-1],n=t.size/e;let r;if(e<=2){const s=ye(t,[n,e]);r=Eg(s)}else{const s=[n,2*(e-1)],o=ye(Cf(t),[n,e]),i=ye(hy(t),[n,e]),a=Ou(pt(o,[0,1],[n,e-2]),1),l=Te(Ou(pt(i,[0,1],[n,e-2]),1),mt(-1)),c=Fn([o,a],1),d=Fn([i,l],1),f=ye(yl(c,d),[s[0],s[1]]);r=Eg(f)}if(r=Cf(r),t.rank===3&&t.shape[0]!==0){const s=r,o=t.shape[0];r=ye(r,[o,r.shape[0]/o,r.shape[1]]),s.dispose()}return r}const ND=X({irfft_:Lee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zee(t,e,n=0){const s={x:L(t,"x","split")},o={numOrSizeSplits:e,axis:n};return Y.runKernel(yS,s,o)}const $f=X({split_:zee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bee(t,e){z(t.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const r=t.size/n;let s;if(e!=null&&e<n){const y=t.shape.map(w=>0),x=t.shape.map(w=>w);x[t.shape.length-1]=e,s=pt(t,y,x),n=e}else if(e!=null&&e>n){const y=t.shape.map(x=>x);y[t.shape.length-1]=e-n,s=Fn([t,xa(y)],t.shape.length-1),n=e}else s=t;const o=Os(s),i=ye(yl(s,o),[r,n]),a=GS(i),l=Math.floor(n/2)+1,c=Cf(a),d=hy(a),f=$f(c,[l,n-l],c.shape.length-1),p=$f(d,[l,n-l],d.shape.length-1),g=s.shape.slice();return g[s.shape.length-1]=l,ye(yl(f[0],p[0]),g)}const HS=X({rfft_:Bee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mee(t,e){let n=L(t,"a","squaredDifference"),r=L(e,"b","squaredDifference");[n,r]=yn(n,r),ct(n.shape,r.shape);const s={a:n,b:r},o={};return Y.runKernel(SS,s,o)}const ED=X({squaredDifference_:Mee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vee(t,e){const n=L(t,"x","squeeze","string_or_numeric");return ye(n,Cl(n.shape,e).newShape)}const Gt=X({squeeze_:Vee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wee(t,e=0){const n=Tg(t,"tensors","stack","string_or_numeric");z(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&z(e<=n[0].rank,()=>"Axis must be <= rank of the tensor");const r=n,s={axis:e};return Y.runKernel(V2,r,s)}const va=X({stack_:Wee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uee(t,e=0){const r={x:L(t,"x","step")},s={alpha:e};return Y.runKernel(AS,r,s)}const RD=X({step_:Uee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jee(t,e,n,r,s=0,o=0,i=0,a=0,l=0){const d={x:L(t,"x","stridedSlice","string_or_numeric")},f={begin:e,end:n,strides:r,beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};return Y.runKernel(CS,d,f)}const Gee=X({stridedSlice_:jee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hee(t){const n={x:L(t,"x","tan","float32")};return Y.runKernel(TS,n)}const Kee=X({tan_:Hee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lr(t,e){Cd(t);const n=$l(t,e);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return kl(t,null,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uo(t,e,n){if(Cd(t),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=$l(t,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return kl(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _D(t,e,n){if(Cd(t),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=$l(t,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return kl(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xee(t,e,n){if(Cd(t),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=$l(t,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return kl(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qee(t,e,n){if(Cd(t),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const r=$l(t,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return kl(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yee(t,e,n){if(Cd(t),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const r=$l(t,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,kl(t,e,r,n)}function PD(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(o+` update.rank < ${s}. `);if(t.length<r+(n.rank-s))throw new Error(o+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+t.length-r)throw new Error(o+` update.rank != ${s+t.length-r}`);for(let i=0;i<s;++i)if(n.shape[i]!==e.shape[i])throw new Error(o+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${e.shape[i]}).`);for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==t[i+r])throw new Error(o+` updates.shape[${i+s}] (${n.shape[i+s]}) != shape[${i+s}] (${t[i+s]})`)}function KS(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(t.size===0)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}PD(n,e,t)}function Bu(t,e,n){const r=e.shape.length,s=r>1?e.shape[r-1]:1,o=n.length;let i=1;for(let f=s;f<o;++f)i*=n[f];const a=s<1?1:s,l=pe(e.shape)/a,c=[...gn(n.slice(0,s)),1],d=pe(n);return{sliceRank:s,numUpdates:l,sliceSize:i,strides:c,outputSize:d}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qee(t,e,n){const r=L(t,"tensor","tensorScatterupdate"),s=L(e,"indices","tensorScatterupdate","int32"),o=L(n,"updates","tensorScatterupdate");if(KS(o,s,r.shape),r.dtype!==o.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${o.dtype}.`);const i={tensor:r,indices:s,updates:o},a={};return Y.runKernel(sS,i,a)}const Zee=X({tensorScatterUpdate_:Qee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jee(t,e=1,n=!0){const r=L(t,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const o={x:r},i={k:e,sorted:n},[a,l]=Y.runKernel(NS,o,i);return{values:a,indices:l}}const ete=X({topk_:Jee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tte(t,e=0,n=1,r,s){if(Fs(t),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const o=new US(e,n,r,!0,s),i=Wt(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const nte=X({truncatedNormal_:tte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rte(t,e=0){const n=L(t,"x","unique","string_or_numeric");z(n.rank>0,()=>"The input tensor must be at least 1D");const r={x:n},s={axis:e},[o,i]=Y.runKernel(xA,r,s);return{values:o,indices:i}}const ste=X({unique_:rte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ote(t,e,n){const r=L(t,"x","unsortedSegmentSum"),s=L(e,"segmentIds","unsortedSegmentSum","int32");z(id(n),()=>"numSegments must be of dtype int");const o={x:r,segmentIds:s},i={numSegments:n};return Y.runKernel(_S,o,i)}const ite=X({unsortedSegmentSum_:ote});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ate(t,e=0){const n=L(t,"x","unstack","string_or_numeric");z(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`);const r={value:n},s={axis:e};return Y.runKernel(RS,r,s)}const Mu=X({unstack_:ate});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lte(t,e){return VS(t,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ute(t,e=!0,n,r){return Y.makeVariable(t,e,n,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AD(t,e){const n=[];for(let o=0;o<e.length;o++)e[o]&&n.push(o);const r=Wt(t,"int32"),s=Wt([n.length,t.length],"int32");for(let o=0;o<n.length;o++){const i=r.indexToLoc(n[o]),a=o*t.length;s.values.set(i,a)}return s.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function cte(t){const e=L(t,"condition","whereAsync","bool"),n=await e.data(),r=AD(e.shape,n);return t!==e&&e.dispose(),r}const DD=cte;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function dte(t,e,n){const r=L(t,"tensor","boolMask"),s=L(e,"mask","boolMask","bool"),o=n??0,i=s.rank,a=r.shape;z(i>0,()=>"mask cannot be scalar"),xs(a.slice(o,o+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let x=o;x<o+i;x++)l*=a[x];const c=a.slice(0,o).concat([l],a.slice(o+i)),d=ye(r,c),f=ye(s,[-1]),p=await DD(f),g=Gt(p,[1]),y=dD(d,g,o);return t!==r&&r.dispose(),e!==s&&s.dispose(),g.dispose(),d.dispose(),f.dispose(),p.dispose(),y}const hte=dte;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fte(t,e,n){const r=L(t,"x","transpose");if(e==null&&(e=r.shape.map((i,a)=>a).reverse()),z(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(i=>{z(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();const s={x:r},o={perm:e};return r.dtype==="complex64"?nt(()=>{let i=Cf(r),a=hy(r);return i=Y.runKernel(Yh,{x:i},o),a=Y.runKernel(Yh,{x:a},o),n&&(a=bi(a)),yl(i,a)}):Y.runKernel(Yh,s,o)}const yv=X({transpose_:fte});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pte(t,e,n,r,s=!0){const o=L(t,"v","movingAverage"),i=L(e,"x","movingAverage"),a=L(n,"decay","movingAverage");FX(o,i),z(Vt(o.shape,i.shape),()=>"Shape mismatch in v and x");const l=mt(1),c=ot(l,a);let d=Te(ot(i,o),c);if(s){z(r!=null,()=>"When using zeroDebias: true, step is required.");const f=L(r,"step","movingAverage");d=gt(d,ot(l,vf(a,f)))}return We(o,d)}const mte=X({movingAverage_:pte});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gte(t,e,n){Fs(n);const r=L(t,"indices","scatterND","int32"),s=L(e,"updates","scatterND");KS(s,r,n);const o={indices:r,updates:s},i={shape:n};return Y.runKernel(rS,o,i)}const yte=X({scatterND_:gte});function xte(t,e,n,r){if(t.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const s=t.rank>0?t.shape[0]:1,o=t.rank>1?t.shape[1]:1;if(n.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${o}.`);const i=e.size;if(!(e.rank===0||e.rank===1&&i===s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vte(t,e,n,r=0){Fs(n);const s=L(t,"sparseIndices","sparseToDense","int32"),o=L(e,"sparseValues","sparseToDense","string_or_numeric"),i=L(r,"defaultValue","sparseToDense",o.dtype);xte(s,o,n,i);const a={sparseIndices:s,sparseValues:o,defaultValue:i},l={outputShape:n};return Y.runKernel(wS,a,l)}const bte=X({sparseToDense_:vte});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wte(t,e){const n=L(e,"indices","gatherND","int32"),s={params:L(t,"x","gatherND","string_or_numeric"),indices:n};return Y.runKernel(o2,s)}const Ste=X({gatherND_:wte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cte(t,e){if(e==null)return t.shape.slice();if(Vt(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)e[r]==null&&t.shape[r]!=null?n.push(t.shape[r]):n.push(e[r]);return n}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $te(t,e,n,r){const s=L(t,"x","dropout");if(z(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),z(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return t instanceof fn?s.clone():s;const o=Cte(s,n),i=1-e,a=gt(cD(We(jS(o,0,1,"float32",r),i)),i);return Te(s,a)}const kte=X({dropout_:$te});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OD(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function XS(t,e,n){const r=1-t%2,s=new Float32Array(t);for(let o=0;o<t;++o){const i=2*Math.PI*o/(t+r-1);s[o]=e-n*Math.cos(i)}return lr(s,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Tte(t,e,n=1){const r=L(t,"predictions","inTopK"),s=L(e,"targets","inTopK");z(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),z(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),xs(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=r.shape[r.shape.length-1];z(n>0&&n<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${n}`);const i=await r.data(),a=await s.data(),[l,c]=[i.length/o,o],d=Si("bool",l);for(let f=0;f<l;f++){const p=f*c,g=i.subarray(p,p+c),y=[];for(let x=0;x<g.length;x++)y.push({value:g[x],index:x});y.sort((x,w)=>w.value-x.value),d[f]=0;for(let x=0;x<n;x++)if(y[x].index===a[f]){d[f]=1;break}}return t!==r&&r.dispose(),e!==s&&s.dispose(),vi(d,s.shape,"bool")}const Ite=Tte;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nte(t,e,n,r,s,o="NHWC",i){let a=t;t.rank===3&&(a=ye(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=ye(e,[1,e.shape[0],e.shape[1],e.shape[2]])),z(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),z(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),z(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const c=o==="NHWC"?a.shape[3]:a.shape[1],d=o==="NHWC"?l.shape[3]:l.shape[1];z(c===n[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${n[2]}.`),z(d===n[3],()=>`Error in conv2dDerFilter: depth of dy (${d}) must match output depth for filter (${n[3]}).`),po("conv2dDerFilter",s,i);const f={x:a,dy:l},p={strides:r,pad:s,dataFormat:o,dimRoundingMode:i,filterShape:n};return Y.runKernel(Nw,f,p)}const Ete=X({conv2DBackpropFilter_:Nte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function py(t,e,n){if(n==null||n==="linear")return t;if(n==="relu")return Te(t,RD(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function my(t,e){let n=e;const r=sD(t.shape,e.shape);return r.length>0&&(n=en(n,r)),ye(n,t.shape)}function gy(t,e,n,r){if(e==="linear")return t;if(e==="relu")return fy(t);if(e==="elu")return iD(t);if(e==="relu6")return TD(t);if(e==="prelu")return $D(t,n);if(e==="leakyrelu")return fD(t,r);if(e==="sigmoid")return aa(t);throw new Error(`Unknown fused activation ${e}.`)}const yy=(t,e)=>!(t>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rte({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:d}){if(l=l||"linear",yy(Y.state.gradientDepth,l)===!1){z(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let O=uy(t,e,n,r,s,o,i);return a!=null&&(O=We(O,a)),gy(O,l,c,d)}const f=L(t,"x","conv2d","float32"),p=L(e,"filter","conv2d","float32");let g=f,y=!1;f.rank===3&&(y=!0,g=ye(f,[1,f.shape[0],f.shape[1],f.shape[2]])),z(g.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${g.rank}.`),z(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),po("fused conv2d",r,i);const x=s==="NHWC"?g.shape[3]:g.shape[1];z(p.shape[2]===x,()=>`Error in conv2d: depth of input (${x}) must match input depth for filter ${p.shape[2]}.`),z(Er(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);const w=kn(g.shape,p.shape,n,o,r,i);let S;a!=null&&(S=L(a,"bias","fused conv2d"),[S]=yn(S,f),s==="NHWC"?ct(w.outShape,S.shape):(z(S.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${S.shape.length}.`),z(S.shape.length===0||S.shape[0]===w.outChannels||S.shape[0]===1,()=>`Error in fused conv2d: bias shape (${S.shape}) is not compatible with the number of output channels (${w.outChannels})`)));let $;if(c!=null){const O=c.shape;if(z(O.length<=1||O.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${O.length}.`),O.length===1)z(O[0]===1||O[0]===w.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${O}) is not compatible with the number of output channels (${w.outChannels}).`);else if(O.length===3)try{ct(O,w.outShape)}catch{const B=`Error in fused conv2d: PReLU activation weights (${O}) is not compatible with the output shape of the conv2d (${w.outShape}).`;throw Error(B)}$=L(c,"prelu weights","fused conv2d")}const I=(O,F)=>{z(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[B,M,V,P]=F,re=py(O,V,l);z(xf(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const ie=rD(M.shape,re,B,n,r),me=Ete(M,re,B.shape,n,r),ge=[ie,me];if(P!=null){const ve=my(P,re);ge.push(ve)}return ge},R={x:g,filter:p,bias:S,preluActivationWeights:$},_={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:d};return a==null?ya((F,B,M)=>{let V=Y.runKernel(wg,R,_);return M([B,F,V]),y&&(V=ye(V,[V.shape[1],V.shape[2],V.shape[3]])),{value:V,gradFunc:I}})(g,p):ya((F,B,M,V)=>{let P=Y.runKernel(wg,R,_);return V([B,F,P,M]),y&&(P=ye(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:I}})(g,p,S)}const _te=X({fusedConv2d_:Rte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pte(t,e,n,r,s,o=[1,1],i){let a=t;t.rank===3&&(a=ye(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=ye(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:a,dy:l},d={strides:r,pad:s,dimRoundingMode:i,dilations:o,filterShape:n};return Y.runKernel(Mw,c,d)}const Ate=X({depthwiseConv2dNativeBackpropFilter_:Pte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dte(t,e,n,r,s,o=[1,1],i){let a=e,l=!1;e.rank===3&&(l=!0,a=ye(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:a,filter:n},d={strides:r,pad:s,dimRoundingMode:i,dilations:o,inputShape:t},f=Y.runKernel(Vw,c,d);return l?ye(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Ote=X({depthwiseConv2dNativeBackpropInput_:Dte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fte({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:d}){if(yy(Y.state.gradientDepth,l)===!1){let _=zS(t,e,n,r,s,o,i);return a!=null&&(_=We(_,a)),gy(_,l,c,d)}const f=L(t,"x","depthwiseConv2d","float32"),p=L(e,"filter","depthwiseConv2d","float32");let g=f,y=!1;f.rank===3&&(y=!0,g=ye(f,[1,f.shape[0],f.shape[1],f.shape[2]])),z(g.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${g.rank}.`),z(p.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),z(g.shape[3]===p.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${g.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),o==null&&(o=[1,1]),z(Er(n,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),po("fused depthwiseConv2d",r,i);const x=kn(g.shape,p.shape,n,o,r,i,!0);let w;a!=null&&(w=L(a,"bias","fused conv2d"),[w]=yn(w,f),ct(x.outShape,w.shape));let S;c!=null&&(S=L(c,"prelu weights","fused depthwiseConv2d"));const $=(_,O)=>{z(xf(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[F,B,M,V]=O,P=py(_,M,l),re=Ote(B.shape,P,F,n,r,o,i),ie=Ate(B,P,F.shape,n,r,o,i);if(V!=null){const me=my(w,P);return[re,ie,me]}return[re,ie]},I={x:g,filter:p,bias:w,preluActivationWeights:S},R={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:d};return a==null?ya((O,F,B)=>{let M=Y.runKernel(Sg,I,R);return B([F,O,M]),y&&(M=ye(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:$}})(g,p):ya((O,F,B,M)=>{let V=Y.runKernel(Sg,I,R);return M([F,O,V,B]),y&&(V=ye(V,[V.shape[1],V.shape[2],V.shape[3]])),{value:V,gradFunc:$}})(g,p,w)}const Lte=X({fusedDepthwiseConv2d_:Fte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zte({a:t,b:e,transposeA:n=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(yy(Y.state.gradientDepth,o)===!1){let P=Ht(t,e,n,r);return s!=null&&(P=We(P,s)),gy(P,o,i,a)}let l=L(t,"a","fused matMul"),c=L(e,"b","fused matMul");[l,c]=yn(l,c);const d=n?l.shape[l.rank-2]:l.shape[l.rank-1],f=r?c.shape[c.rank-1]:c.shape[c.rank-2],p=n?l.shape[l.rank-1]:l.shape[l.rank-2],g=r?c.shape[c.rank-2]:c.shape[c.rank-1],y=l.shape.slice(0,-2),x=c.shape.slice(0,-2),w=pe(y),S=pe(x);z(d===f,()=>`Error in fused matMul: inner shapes (${d}) and (${f}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${n} and transposeB=${r} must match.`);const I=ct(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([p,g]),R=n?ye(l,[w,d,p]):ye(l,[w,p,d]),_=r?ye(c,[S,g,f]):ye(c,[S,f,g]);let O;s!=null&&(O=L(s,"bias","fused matMul"),[O]=yn(O,l),ct(I,O.shape));let F;i!=null&&(F=L(i,"prelu weights","fused matMul"));const B=(P,re)=>{const[ie,me,ge,ve]=re,$e=py(ye(P,ge.shape),ge,o);let fe,xe;if(!n&&!r?(fe=Ht($e,me,!1,!0),xe=Ht(ie,$e,!0,!1)):!n&&r?(fe=Ht($e,me,!1,!1),xe=Ht($e,ie,!0,!1)):n&&!r?(fe=Ht(me,$e,!1,!0),xe=Ht(ie,$e,!1,!1)):(fe=Ht(me,$e,!0,!0),xe=Ht($e,ie,!0,!0)),s!=null){const ae=my(ve,$e);return[fe,xe,ae]}else return[fe,xe]},M={a:R,b:_,bias:O,preluActivationWeights:F},V={transposeA:n,transposeB:r,activation:o,leakyreluAlpha:a};return s==null?ya((re,ie,me)=>{const ge=Y.runKernel(bg,M,V);return me([re,ie,ge]),{value:ye(ge,I),gradFunc:B}})(R,_):ya((re,ie,me,ge)=>{const ve=Y.runKernel(bg,M,V);return ge([re,ie,ve,me]),{value:ye(ve,I),gradFunc:B}})(R,_,O)}const Bte=X({fusedMatMul_:zte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mte=Object.freeze(Object.defineProperty({__proto__:null,conv2d:_te,depthwiseConv2d:Lte,matMul:Bte},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vte(t){return XS(t,.54,.46)}const Wte=X({hammingWindow_:Vte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ute(t){return XS(t,.5,.5)}const FD=X({hannWindow_:Ute});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jte(t,e,n,r=!1,s=0){let o=0;const i=[];for(;o+e<=t.size;)i.push(pt(t,o,e)),o+=n;if(r)for(;o<t.size;){const a=o+e-t.size,l=Fn([pt(t,o,e-a),Xf([a],s)]);i.push(l),o+=n}return i.length===0?uo([],[0,e]):ye(Fn(i),[i.length,e])}const LD=X({frame_:jte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gte(t,e,n,r,s=FD){r==null&&(r=OD(e));const o=LD(t,e,n),i=Te(o,s(e));return HS(i,r)}const Hte=X({stft_:Gte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kte(t,e,n,r,s="bilinear",o=0){const i=L(t,"image","cropAndResize"),a=L(e,"boxes","cropAndResize","float32"),l=L(n,"boxInd","cropAndResize","int32"),c=a.shape[0];z(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),z(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),z(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),z(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),z(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),z(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const d={image:i,boxes:a,boxInd:l},f={method:s,extrapolationValue:o,cropSize:r};return Y.runKernel(Fw,d,f)}const Xte=X({cropAndResize_:Kte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qte(t){const e=L(t,"image","flipLeftRight","float32");z(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const n={image:e};return Y.runKernel(e2,n,{})}const Yte=X({flipLeftRight_:qte});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qte(t){const e=L(t,"image","grayscaleToRGB"),n=e.rank-1,r=e.shape[n];z(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),z(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,n),s[n]=3,Zh(e,s)}const Zte=X({grayscaleToRGB_:Qte});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jte(t){const e=L(t,"image","RGBToGrayscale"),n=e.rank-1,r=e.shape[n];z(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),z(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const s=e.dtype,o=Qt(e,"float32"),i=lr([.2989,.587,.114]);let a;switch(e.rank){case 2:a=_c("ij,j->i",o,i);break;case 3:a=_c("ijk,k->ij",o,i);break;case 4:a=_c("ijkl,l->ijk",o,i);break;case 5:a=_c("ijklm,m->ijkl",o,i);break;case 6:a=_c("ijklmn,n->ijklm",o,i);break;default:throw new Error("Not a valid tensor rank.")}return a=_s(a,-1),Qt(a,s)}const ene=X({rgbToGrayscale_:Jte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tne(t,e,n=0,r=.5){const s=L(t,"image","rotateWithOffset","float32");z(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const o={image:s},i={radians:e,fillValue:n,center:r};return Y.runKernel(DS,o,i)}const nne=X({rotateWithOffset_:tne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Td(t,e,n,r,s,o){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),o==null&&(o=0);const i=t.shape[0];return n=Math.min(n,i),z(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),z(t.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),z(t.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),z(e.rank===1,()=>"scores must be a 1D tensor"),z(e.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${e.shape[0]}`),z(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rne(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const o=L(t,"boxes","nonMaxSuppression","float32"),i=L(e,"scores","nonMaxSuppression","float32"),a=Td(o,i,n,r,s);n=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return Y.runKernel(L2,{boxes:o,scores:i},l)}const sne=X({nonMaxSuppression_:rne});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function one(t,e,n){const r=ine(t,e,n),s=r<0?-(r+1):r;t.splice(s,0,e)}function ine(t,e,n){return lne(t,e,n||ane)}function ane(t,e){return t>e?1:t<e?-1:0}function lne(t,e,n){let r=0,s=t.length,o=0,i=!1;for(;r<s;){o=r+(s-r>>>1);const a=n(e,t[o]);a>0?r=o+1:(s=o,i=!a)}return i?r:-r-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qS(t,e,n,r,s){return QS(t,e,n,r,s,0)}function zD(t,e,n,r,s,o){return QS(t,e,n,r,s,0,!1,o,!0)}function YS(t,e,n,r,s,o){return QS(t,e,n,r,s,o,!0)}function QS(t,e,n,r,s,o,i=!1,a=!1,l=!1){const c=[];for(let w=0;w<e.length;w++)e[w]>s&&c.push({score:e[w],boxIndex:w,suppressBeginIndex:0});c.sort(P3);const d=o>0?-.5/o:0,f=[],p=[];for(;f.length<n&&c.length>0;){const w=c.pop(),{score:S,boxIndex:$,suppressBeginIndex:I}=w;if(S<s)break;let R=!1;for(let _=f.length-1;_>=I;--_){const O=une(t,$,f[_]);if(O>=r){R=!0;break}if(w.score=w.score*cne(r,d,O),w.score<=s)break}w.suppressBeginIndex=f.length,R||(w.score===S?(f.push($),p.push(w.score)):w.score>s&&one(c,w,P3))}const g=f.length,y=n-g;a&&y>0&&(f.push(...new Array(y).fill(0)),p.push(...new Array(y).fill(0)));const x={selectedIndices:f};return i&&(x.selectedScores=p),l&&(x.validOutputs=g),x}function une(t,e,n){const r=t.subarray(e*4,e*4+4),s=t.subarray(n*4,n*4+4),o=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(s[0],s[2]),d=Math.min(s[1],s[3]),f=Math.max(s[0],s[2]),p=Math.max(s[1],s[3]),g=(a-o)*(l-i),y=(f-c)*(p-d);if(g<=0||y<=0)return 0;const x=Math.max(o,c),w=Math.max(i,d),S=Math.min(a,f),$=Math.min(l,p),I=Math.max(S-x,0)*Math.max($-w,0);return I/(g+y-I)}function cne(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function P3(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function dne(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const o=L(t,"boxes","nonMaxSuppressionAsync"),i=L(e,"scores","nonMaxSuppressionAsync"),a=Td(o,i,n,r,s);n=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l=await Promise.all([o.data(),i.data()]),c=l[0],d=l[1],{selectedIndices:f}=qS(c,d,n,r,s);return o!==t&&o.dispose(),i!==e&&i.dispose(),lr(f,"int32")}const hne=dne;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fne(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=L(t,"boxes","nonMaxSuppression"),a=L(e,"scores","nonMaxSuppression"),l=Td(i,a,n,r,s,o);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,o=l.softNmsSigma;const c={boxes:i,scores:a},d={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:o},f=Y.runKernel(z2,c,d);return{selectedIndices:f[0],selectedScores:f[1]}}const pne=X({nonMaxSuppressionWithScore_:fne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function mne(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=L(t,"boxes","nonMaxSuppressionAsync"),a=L(e,"scores","nonMaxSuppressionAsync"),l=Td(i,a,n,r,s,o);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,o=l.softNmsSigma;const c=await Promise.all([i.data(),a.data()]),d=c[0],f=c[1],{selectedIndices:p,selectedScores:g}=YS(d,f,n,r,s,o);return i!==t&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:lr(p,"int32"),selectedScores:lr(g)}}const gne=mne;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yne(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=L(t,"boxes","nonMaxSuppression"),a=L(e,"scores","nonMaxSuppression"),l=Td(i,a,n,r,s,null),c=l.maxOutputSize,d=l.iouThreshold,f=l.scoreThreshold,p={boxes:i,scores:a},g={maxOutputSize:c,iouThreshold:d,scoreThreshold:f,padToMaxOutputSize:o},y=Y.runKernel(iA,p,g);return{selectedIndices:y[0],validOutputs:y[1]}}const xne=X({nonMaxSuppressionPadded_:yne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function vne(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=L(t,"boxes","nonMaxSuppressionAsync"),a=L(e,"scores","nonMaxSuppressionAsync"),l=Td(i,a,n,r,s,null),c=l.maxOutputSize,d=l.iouThreshold,f=l.scoreThreshold,[p,g]=await Promise.all([i.data(),a.data()]),{selectedIndices:y,validOutputs:x}=zD(p,g,c,d,f,o);return i!==t&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:lr(y,"int32"),validOutputs:mt(x,"int32")}}const bne=vne;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wne(t,e,n=!1,r=!1){const s=L(t,"images","resizeBilinear");z(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),z(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),z(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;s.rank===3&&(i=!0,o=ye(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:o},l={alignCorners:n,halfPixelCenters:r,size:e},c=Y.runKernel(Z2,a,l);return i?ye(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Sne=X({resizeBilinear_:wne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cne(t,e,n=!1,r=!1){const s=L(t,"images","resizeNearestNeighbor");z(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),z(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),z(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),z(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;s.rank===3&&(i=!0,o=ye(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:o},l={alignCorners:n,halfPixelCenters:r,size:e},c=Y.runKernel(Q2,a,l);return i?ye(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const $ne=X({resizeNearestNeighbor_:Cne});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kne(t,e="binary",n=!1,r=.5){const s=L(t,"image","threshold"),o=.2989,i=.587,a=.114,l=s.shape[0]*s.shape[1];let c=Te(lr([r]),255),d,f,p,g;if(z(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),z(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),z(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),z(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[d,f,p]=$f(s,[1,1,1],-1);const w=Te(d,o),S=Te(f,i),$=Te(p,a);g=We(We(w,S),$)}else g=t;if(e==="otsu"){const w=tD(Qt(ID(g),"int32"),vi([]),256);c=Tne(w,l)}const y=n?MS(g,c):dy(g,c);return Qt(Te(y,255),"int32")}function Tne(t,e){let n=lr([-1]),r=lr([0]),s=lr([0]),o,i,a,l,c,d;for(let f=0;f<t.size-1;f++){o=pt(t,0,f+1),i=pt(t,f+1),c=gt(en(o),e),d=gt(en(i),e);const p=en(Te(o,Sf(0,o.size)));a=gt(p,en(o));const g=Xf(i.shape,o.size),y=We(Sf(0,i.size),g),x=Te(i,y);l=gt(en(x),en(i));const w=ot(a,l),S=ot(a,l),$=Te(c,d);s=Te(Te($,w),S);const I=dy(s,r);r=pl(I,s,r),n=pl(I,lr([f]),n)}return n}const Ine=X({threshold_:kne});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nne(t,e,n="nearest",r="constant",s=0,o){const i=L(t,"image","transform","float32"),a=L(e,"transforms","transform","float32");z(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),z(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),z(o==null||o.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);const l={image:i,transforms:a},c={interpolation:n,fillMode:r,fillValue:s,outputShape:o};return Y.runKernel(ES,l,c)}const Ene=X({transform_:Nne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rne(t,e,n){const r=L(t,"a","bandPart");z(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[o,i]=r.shape.slice(-2);let a,l;typeof e=="number"?(z(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),z(e<=o,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${o}).`),a=L(e<0?o:e,"numLower","bandPart")):(z(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=pl(gv(e,0),o,wf(e,o))),typeof n=="number"?(z(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),z(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),l=L(n<0?i:n,"numUpper","bandPart")):(z(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=pl(gv(n,0),i,wf(n,i)));const c=ye(Sf(0,o,1,"int32"),[-1,1]),d=Sf(0,i,1,"int32"),f=ot(c,d),p=Ig(MS(f,a),hD(f,bi(l))),g=xa([o,i],r.dtype);return ye(va(Mu(ye(r,[-1,o,i])).map(y=>pl(p,y,g))),s)}const _ne=X({bandPart_:Rne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pne(t){let e;if(Array.isArray(t)){e=!1,z(t!=null&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=t[0].shape[0];for(let o=1;o<t.length;++o)z(t[o].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[o].shape[0]} vs. ${s})`)}else e=!0,t=$f(t,t.shape[0],0).map(s=>Gt(s,[0]));z(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],r=t;for(let s=0;s<t.length;++s)n.push(Y.tidy(()=>{let o=r[s];if(s>0)for(let i=0;i<s;++i){const a=Te(en(Te(n[i],o)),n[i]);o=ot(o,a)}return gt(o,cy(o,"euclidean"))}));return e?va(n,0):n}const Ane=X({gramSchmidt_:Pne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dne(t,e=!1){if(z(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),t.rank===2)return A3(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((l,c)=>l*c),r=Mu(ye(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),s=[],o=[];r.forEach(l=>{const[c,d]=A3(l,e);s.push(c),o.push(d)});const i=ye(va(s,0),t.shape),a=ye(va(o,0),t.shape);return[i,a]}}function A3(t,e=!1){return Y.tidy(()=>{z(t.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],r=t.shape[1];let s=uD(n),o=fl(t);const i=uo([[1]],[1,1]);let a=fl(i);const l=n>=r?r:n;for(let c=0;c<l;++c){const d=o,f=a,p=s;[a,o,s]=Y.tidy(()=>{const g=pt(o,[c,c],[n-c,1]),y=cy(g),x=pt(o,[c,c],[1,1]),w=pl(dy(x,0),uo([[-1]]),uo([[1]])),S=ot(x,Te(w,y)),$=gt(g,S);$.shape[0]===1?a=fl(i):a=Fn([i,pt($,[1,0],[$.shape[0]-1,$.shape[1]])],0);const I=bi(gt(Ht(w,S),y)),R=pt(o,[c,0],[n-c,r]),_=Te(I,a),O=yv(a);if(c===0)o=ot(R,Ht(_,Ht(O,R)));else{const M=ot(R,Ht(_,Ht(O,R)));o=Fn([pt(o,[0,0],[c,r]),M],0)}const F=yv(_),B=pt(s,[0,c],[n,s.shape[1]-c]);if(c===0)s=ot(B,Ht(Ht(B,a),F));else{const M=ot(B,Ht(Ht(B,a),F));s=Fn([pt(s,[0,0],[n,c]),M],1)}return[a,o,s]}),Mt([d,f,p])}return!e&&n>r&&(s=pt(s,[0,0],[n,r]),o=pt(o,[0,0],[r,r])),[s,o]})}const One=X({qr_:Dne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Br;(function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Br||(Br={}));function Fne(t,e,n=Br.SUM_BY_NONZERO_WEIGHTS){const r=L(t,"losses","computeWeightedLoss");let s=null;e!=null&&(s=L(e,"weights","computeWeightedLoss"));const o=s==null?r:Te(r,s);if(n===Br.NONE)return o;if(n===Br.SUM)return en(o);if(n===Br.MEAN){if(s==null)return Ng(o);{const i=r.size/s.size,a=gt(en(o),en(s));return i>1?gt(a,mt(i)):a}}if(n===Br.SUM_BY_NONZERO_WEIGHTS){if(s==null)return gt(en(o),mt(r.size));{const i=Te(s,bu(r.shape)),a=Qt(en(SD(i,mt(0))),"float32");return gt(en(o),a)}}throw Error(`Unknown reduction: ${n}`)}const Ca=X({computeWeightedLoss_:Fne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lne(t,e,n,r=Br.SUM_BY_NONZERO_WEIGHTS){const s=L(t,"labels","absoluteDifference"),o=L(e,"predictions","absoluteDifference");let i=null;n!=null&&(i=L(n,"weights","absoluteDifference")),xs(s.shape,o.shape,"Error in absoluteDifference: ");const a=Rs(ot(s,o));return Ca(a,i,r)}const zne=X({absoluteDifference_:Lne});function Bne(t,e,n,r,s=Br.SUM_BY_NONZERO_WEIGHTS){const o=L(t,"labels","cosineDistance"),i=L(e,"predictions","cosineDistance");let a=null;r!=null&&(a=L(r,"weights","cosineDistance")),xs(o.shape,i.shape,"Error in cosineDistance: ");const l=mt(1),c=ot(l,en(Te(o,i),n,!0));return Ca(c,a,s)}const Mne=X({cosineDistance_:Bne});function Vne(t,e,n,r=Br.SUM_BY_NONZERO_WEIGHTS){let s=L(t,"labels","hingeLoss");const o=L(e,"predictions","hingeLoss");let i=null;n!=null&&(i=L(n,"weights","hingeLoss")),xs(s.shape,o.shape,"Error in hingeLoss: ");const a=mt(1);s=ot(Te(mt(2),s),a);const l=fy(ot(a,Te(s,o)));return Ca(l,i,r)}const Wne=X({hingeLoss_:Vne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Une(t,e,n,r=1,s=Br.SUM_BY_NONZERO_WEIGHTS){const o=L(t,"labels","huberLoss"),i=L(e,"predictions","huberLoss");let a=null;n!=null&&(a=L(n,"weights","huberLoss")),xs(o.shape,i.shape,"Error in huberLoss: ");const l=mt(r),c=Rs(ot(i,o)),d=wf(c,l),f=ot(c,d),p=We(Te(mt(.5),lo(d)),Te(l,f));return Ca(p,a,s)}const jne=X({huberLoss_:Une});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gne(t,e,n,r=1e-7,s=Br.SUM_BY_NONZERO_WEIGHTS){const o=L(t,"labels","logLoss"),i=L(e,"predictions","logLoss");let a=null;n!=null&&(a=L(n,"weights","logLoss")),xs(o.shape,i.shape,"Error in logLoss: ");const l=mt(1),c=mt(r),d=bi(Te(o,bf(We(i,c)))),f=Te(ot(l,o),bf(We(ot(l,i),c))),p=ot(d,f);return Ca(p,a,s)}const Hne=X({logLoss_:Gne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kne(t,e,n,r=Br.SUM_BY_NONZERO_WEIGHTS){const s=L(t,"labels","meanSquaredError"),o=L(e,"predictions","meanSquaredError");let i=null;n!=null&&(i=L(n,"weights","meanSquaredError")),xs(s.shape,o.shape,"Error in meanSquaredError: ");const a=ED(s,o);return Ca(a,i,r)}const Xne=X({meanSquaredError_:Kne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qne(t,e){const n=L(t,"labels","sigmoidCrossEntropyWithLogits"),r=L(e,"logits","sigmoidCrossEntropyWithLogits");xs(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=fy(r),o=Te(r,n),i=pD(ga(bi(Rs(r))));return We(ot(s,o),i)}function Yne(t,e,n,r=0,s=Br.SUM_BY_NONZERO_WEIGHTS){let o=L(t,"multiClassLabels","sigmoidCrossEntropy");const i=L(e,"logits","sigmoidCrossEntropy");let a=null;if(n!=null&&(a=L(n,"weights","sigmoidCrossEntropy")),xs(o.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const c=mt(r),d=mt(1),f=mt(.5);o=We(Te(o,ot(d,c)),Te(f,c))}const l=qne(o,i);return Ca(l,a,s)}const Qne=X({sigmoidCrossEntropy_:Yne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zne(t,e,n=-1){if(n===-1&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return ya((s,o,i)=>{const l=gD(o,[n],!0),c=ot(Qt(o,"float32"),l);i([s,c]);const d=bi(Te(c,s));return{value:en(d,[n]),gradFunc:(g,y)=>{const[x,w]=y,S=vs(g.shape,[n]);return[Te(ye(g,S),ot(Qt(x,"float32"),ga(w))),Te(ye(g,S),ot(ga(w),Qt(x,"float32")))]}}})(t,e)}function Jne(t,e,n,r=0,s=Br.SUM_BY_NONZERO_WEIGHTS){let o=L(t,"onehotLabels","softmaxCrossEntropy");const i=L(e,"logits","softmaxCrossEntropy");let a=null;if(n!=null&&(a=L(n,"weights","softmaxCrossEntropy")),xs(o.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const c=mt(r),d=mt(1),f=mt(o.shape[1]);o=We(Te(o,ot(d,c)),gt(c,f))}const l=Zne(o,i);return Ca(l,a,s)}const ere=X({softmaxCrossEntropy_:Jne});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tre(t,e,n,r){const s=L(t,"indices","sparseFillEmptyRows","int32"),o=L(e,"values","sparseFillEmptyRows"),i=L(n,"denseShape","sparseFillEmptyRows","int32"),a=L(r,"defaultValue","sparseFillEmptyRows",o.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(o.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const l={indices:s,values:o,denseShape:i,defaultValue:a},c=Y.runKernel(hA,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const nre=X({sparseFillEmptyRows_:tre});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rre(t,e,n){const r=L(t,"inputIndices","sparseReshape","int32"),s=L(e,"inputShape","sparseReshape","int32"),o=L(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(o.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const i={inputIndices:r,inputShape:s,newShape:o},a=Y.runKernel(fA,i);return{outputIndices:a[0],outputShape:a[1]}}const sre=X({sparseReshape_:rre});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ore(t,e,n){const r=L(t,"data","sparseSegmentMean"),s=L(e,"indices","sparseSegmentMean","int32"),o=L(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${o.shape}`);const i={data:r,indices:s,segmentIds:o};return Y.runKernel(vS,i)}const ire=X({sparseSegmentMean_:ore});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function are(t,e,n){const r=L(t,"data","sparseSegmentSum"),s=L(e,"indices","sparseSegmentSum","int32"),o=L(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${o.shape}`);const i={data:r,indices:s,segmentIds:o};return Y.runKernel(bS,i)}const lre=X({sparseSegmentSum_:are});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ure(t,e,n,r,s,o,i,a){const l=L(t,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=L(e,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const d={separator:n,nGramWidths:r,leftPad:s,rightPad:o,padWidth:i,preserveShortSequences:a},f={data:l,dataSplits:c},p=Y.runKernel($S,f,d);return{nGrams:p[0],nGramsSplits:p[1]}}const cre=X({stringNGrams_:ure});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dre(t,e,n=!0){const r=L(t,"input","stringSplit","string"),s=L(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const o={skipEmpty:n},i={input:r,delimiter:s},a=Y.runKernel(gA,i,o);return{indices:a[0],values:a[1],shape:a[2]}}const hre=X({stringSplit_:dre});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fre(t,e){const n=L(t,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return Y.runKernel(yA,s,r)}const pre=X({stringToHashBucketFast_:fre});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mre(t,e,n,r=!0){const s=L(t,"input","staticRegexReplace","string"),o={pattern:e,rewrite:n,replaceGlobal:r};return Y.runKernel(mA,{x:s},o)}const gre=X({staticRegexReplace_:mre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yre={fft:GS,ifft:Eg,rfft:HS,irfft:ND},xre={hammingWindow:Wte,hannWindow:FD,frame:LD,stft:Hte},Tu={flipLeftRight:Yte,grayscaleToRGB:Zte,resizeNearestNeighbor:$ne,resizeBilinear:Sne,rgbToGrayscale:ene,rotateWithOffset:nne,cropAndResize:Xte,nonMaxSuppression:sne,nonMaxSuppressionAsync:hne,nonMaxSuppressionWithScore:pne,nonMaxSuppressionWithScoreAsync:gne,nonMaxSuppressionPadded:xne,nonMaxSuppressionPaddedAsync:bne,threshold:Ine,transform:Ene},vre={bandPart:_ne,gramSchmidt:Ane,qr:One},bre={absoluteDifference:zne,computeWeightedLoss:Ca,cosineDistance:Mne,hingeLoss:Wne,huberLoss:jne,logLoss:Hne,meanSquaredError:Xne,sigmoidCrossEntropy:Qne,softmaxCrossEntropy:ere},wre={sparseFillEmptyRows:nre,sparseReshape:sre,sparseSegmentMean:ire,sparseSegmentSum:lre},Sre={stringNGrams:cre,stringSplit:hre,stringToHashBucketFast:pre,staticRegexReplace:gre};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cre=new Map,$re=new Map;class kre{getClassName(){return this.constructor.className}static fromConfig(e,n){return new e(n)}}class hu{constructor(){this.classNameMap={}}static getMap(){return hu.instance==null&&(hu.instance=new hu),hu.instance}static register(e){hu.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Tre(t,e,n){z(t.className!=null,()=>"Class being registered does not have the static className property defined."),z(typeof t.className=="string",()=>"className is required to be a string, but got type "+typeof t.className),z(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof n>"u"&&(n=t.className);const r=n,s=e+">"+r;return hu.register(t),Cre.set(s,t),$re.set(t,s),t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vu extends kre{minimize(e,n=!1,r){const{value:s,grads:o}=this.computeGradients(e,r);if(r!=null){const i=r.map(a=>({name:a.name,tensor:o[a.name]}));this.applyGradients(i)}else this.applyGradients(o);return Mt(o),n?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,n){return cZ(e,n)}dispose(){this.iterations_!=null&&Mt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:mt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Vu,Symbol.hasInstance,{value:t=>t.minimize!=null&&t.computeGradients!=null&&t.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ire extends Vu{static get className(){return"Adadelta"}constructor(e,n,r=null){super(),this.learningRate=e,this.rho=n,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=Y.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=Y.registeredVariables[r],i=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:nt(()=>Os(o).variable(i))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:nt(()=>Os(o).variable(i))});const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const l=this.accumulatedGrads[s].variable,c=this.accumulatedUpdates[s].variable;nt(()=>{const d=We(Te(l,this.rho),Te(lo(a),1-this.rho)),f=Te(gt(ma(We(c,this.epsilon)),ma(We(l,this.epsilon))),a),p=We(Te(c,this.rho),Te(lo(f),1-this.rho));l.assign(d),c.assign(p);const g=We(Te(f,-this.learningRate),o);o.assign(g)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Mt(this.accumulatedGrads.map(e=>e.variable)),Mt(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=e.length/2,r=!1;this.accumulatedGrads=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.rho,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nre extends Vu{static get className(){return"Adagrad"}constructor(e,n=.1){super(),this.learningRate=e,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=Y.registeredVariables[r];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:nt(()=>Xf(o.shape,this.initialAccumulatorValue).variable(!1))});const i=Array.isArray(e)?e[s].tensor:e[r];if(i==null)return;const a=this.accumulatedGrads[s].variable;nt(()=>{const l=We(a,lo(i));a.assign(l);const c=We(Te(gt(i,ma(We(l,Y.backend.epsilon()))),-this.learningRate),o);o.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Mt(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,n){return new e(n.learningRate,n.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ere extends Vu{static get className(){return"Adam"}constructor(e,n,r,s=null){super(),this.learningRate=e,this.beta1=n,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],nt(()=>{this.accBeta1=mt(n).variable(),this.accBeta2=mt(r).variable()}),s==null&&(this.epsilon=Y.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);nt(()=>{const r=ot(1,this.accBeta1),s=ot(1,this.accBeta2);n.forEach((o,i)=>{const a=Y.registeredVariables[o],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:nt(()=>Os(a).variable(l))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${o}/v`,variable:nt(()=>Os(a).variable(l))});const c=Array.isArray(e)?e[i].tensor:e[o];if(c==null)return;const d=this.accumulatedFirstMoment[i].variable,f=this.accumulatedSecondMoment[i].variable,p=We(Te(d,this.beta1),Te(c,1-this.beta1)),g=We(Te(f,this.beta2),Te(lo(c),1-this.beta2)),y=gt(p,r),x=gt(g,s);d.assign(p),f.assign(g);const w=We(Te(gt(y,We(ma(x),this.epsilon)),-this.learningRate),a);a.assign(w)}),this.accBeta1.assign(Te(this.accBeta1,this.beta1)),this.accBeta2.assign(Te(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Mt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Mt(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e),nt(()=>{this.accBeta1.assign(vf(this.beta1,this.iterations_+1)),this.accBeta2.assign(vf(this.beta2,this.iterations_+1))});const n=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rre extends Vu{static get className(){return"Adamax"}constructor(e,n,r,s=null,o=0){super(),this.learningRate=e,this.beta1=n,this.beta2=r,this.epsilon=s,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],nt(()=>{this.iteration=mt(0).variable(),this.accBeta1=mt(n).variable()}),s==null&&(this.epsilon=Y.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);nt(()=>{const r=ot(1,this.accBeta1),s=gt(-this.learningRate,We(Te(this.iteration,this.decay),1));n.forEach((o,i)=>{const a=Y.registeredVariables[o],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:Os(a).variable(l)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${o}/v`,variable:Os(a).variable(l)});const c=Array.isArray(e)?e[i].tensor:e[o];if(c==null)return;const d=this.accumulatedFirstMoment[i].variable,f=this.accumulatedWeightedInfNorm[i].variable,p=We(Te(d,this.beta1),Te(c,1-this.beta1)),g=Te(f,this.beta2),y=Rs(c),x=bD(g,y);d.assign(p),f.assign(x);const w=We(Te(gt(s,r),gt(p,We(x,this.epsilon))),a);a.assign(w)}),this.iteration.assign(We(this.iteration,1)),this.accBeta1.assign(Te(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Mt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Mt(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BD extends Vu{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=Array.isArray(e)?e[s].tensor:e[r];if(o==null)return;const i=Y.registeredVariables[r];nt(()=>{const a=We(Te(this.c,o),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=hi(mt(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,n){return new e(n.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _re extends BD{static get className(){return"Momentum"}constructor(e,n,r=!1){super(e),this.learningRate=e,this.momentum=n,this.useNesterov=r,this.accumulations=[],this.m=mt(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=Y.registeredVariables[r];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:nt(()=>Os(o).variable(!1))});const i=this.accumulations[s].variable,a=Array.isArray(e)?e[s].tensor:e[r];a!=null&&nt(()=>{let l;const c=We(Te(this.m,i),a);this.useNesterov?l=We(Te(this.c,We(a,Te(c,this.m))),o):l=We(Te(this.c,c),o),i.assign(c),o.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Mt(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,n){return new e(n.learningRate,n.momentum,n.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pre extends Vu{static get className(){return"RMSProp"}constructor(e,n=.9,r=0,s=null,o=!1){if(super(),this.learningRate=e,this.decay=n,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,s==null&&(this.epsilon=Y.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=Y.registeredVariables[r],i=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:nt(()=>Os(o).variable(i))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:nt(()=>Os(o).variable(i))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:nt(()=>Os(o).variable(i))});const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const l=this.accumulatedMeanSquares[s].variable,c=this.accumulatedMoments[s].variable;nt(()=>{const d=We(Te(l,this.decay),Te(lo(a),1-this.decay));if(this.centered){const f=this.accumulatedMeanGrads[s].variable,p=We(Te(f,this.decay),Te(a,1-this.decay)),g=gt(Te(a,this.learningRate),ma(ot(d,We(lo(p),this.epsilon)))),y=We(Te(c,this.momentum),g);l.assign(d),f.assign(p),c.assign(y);const x=ot(o,y);o.assign(x)}else{const f=We(Te(l,this.decay),Te(lo(a),1-this.decay)),p=We(Te(c,this.momentum),gt(Te(a,this.learningRate),ma(We(f,this.epsilon))));l.assign(f),c.assign(p);const g=ot(o,p);o.assign(g)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Mt(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Mt(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Mt(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(n*2,n*3).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,n){return new e(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Are=[Ire,Nre,Ere,Rre,_re,Pre,BD];function Dre(){for(const t of Are)Tre(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ore="model",Fre=".json",Lre=".weights.bin";function D3(t){return new Promise(e=>setTimeout(e)).then(t)}class Fu{constructor(e){if(!se().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Fu.URL_SCHEME)&&(e=e.slice(Fu.URL_SCHEME.length)),(e==null||e.length===0)&&(e=Ore),this.modelJsonFileName=e+Fre,this.weightDataFileName=e+Lre}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=Bo.join(e.weightData),r=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],o=VA(e,s),i=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=i,await D3(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=r,await D3(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Hf(e)}}}}Fu.URL_SCHEME="downloads://";class zre{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,n)=>{const r=new FileReader;r.onload=s=>{const o=JSON.parse(s.target.result),i=o.modelTopology;if(i==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(o.weightsManifest==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:i});return}const l=FS(o,c=>this.loadWeights(c));e(l)},r.onerror=s=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(e){const n=[],r=[];for(const i of e)n.push(...i.weights),r.push(...i.paths);const s=this.checkManifestAndWeightFiles(e),o=r.map(i=>this.loadWeightsFile(i,s[i]));return Promise.all(o).then(i=>[n,i])}loadWeightsFile(e,n){return new Promise((r,s)=>{const o=new FileReader;o.onload=i=>{const a=i.target.result;r(a)},o.onerror=i=>s(`Failed to weights data from file of path '${e}'.`),o.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(e){const n=[],r=this.weightsFiles.map(o=>C3(o.name)),s={};for(const o of e)o.paths.forEach(i=>{const a=C3(i);if(n.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(n.push(a),r.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);s[i]=this.weightsFiles[r.indexOf(a)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}const Bre=t=>se().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Fu.URL_SCHEME)?Mre(t.slice(Fu.URL_SCHEME.length)):null;cn.registerSaveRouter(Bre);function Mre(t="model"){return new Fu(t)}function Vre(t){return new zre(t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O3(t,e,n,r){i(t),n=n??0,r=r??1,a(n,r);let s=0;const o=l=>(l.then(c=>{const d=n+ ++s/t.length*(r-n);return e(d),c}),l);function i(l){z(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,c){z(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),z(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),z(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(t.map(o))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function MD(t,e){e==null&&(e={});const n=e.fetchFunc==null?se().platform.fetch:e.fetchFunc,r=t.map(f=>n(f,e.requestInit,{isBinary:!0})),a=(e.onProgress==null?await Promise.all(r):await O3(r,e.onProgress,0,.5)).map(f=>f.arrayBuffer());return e.onProgress==null?await Promise.all(a):await O3(a,e.onProgress,.5,1)}function Wre(t,e){var n;const r=e.fetchFunc==null?se().platform.fetch:e.fetchFunc;let s=0,o;return(n=e.onProgress)===null||n===void 0||n.call(e,0),new ReadableStream({pull:async i=>{for(var a;s<t.length;){o||(o=(await r(t[s],e.requestInit,{isBinary:!0})).body.getReader());const{done:l,value:c}=await o.read();if(l){s++,o=void 0,(a=e.onProgress)===null||a===void 0||a.call(e,s/t.length);continue}i.enqueue(c);return}i.close()}})}async function Ure(t,e="",n,r){return VD(i=>MD(i,{requestInit:r}))(t,e,n)}function VD(t){return async(e,n="",r)=>{const s=e.map(()=>!1),o={},i=r!=null?r.map(()=>!1):[],a=[];if(e.forEach((g,y)=>{let x=0;g.weights.forEach(w=>{const S="quantization"in w?w.quantization.dtype:w.dtype,$=_u[S]*pe(w.shape),I=()=>{s[y]=!0,o[y]==null&&(o[y]=[]),o[y].push({manifestEntry:w,groupOffset:x,sizeBytes:$})};r!=null?r.forEach((R,_)=>{R===w.name&&(I(),i[_]=!0)}):I(),a.push(w.name),x+=$})}),!i.every(g=>g)){const g=r.filter((y,x)=>!i[x]);throw new Error(`Could not find weights in manifest with names: ${g.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const l=s.reduce((g,y,x)=>(y&&g.push(x),g),[]),c=[];l.forEach(g=>{e[g].paths.forEach(y=>{const x=n+(n.endsWith("/")?"":"/")+y;c.push(x)})});const d=await t(c),f={};let p=0;return l.forEach(g=>{const y=e[g].paths.length,x=new Bo(d.slice(p,p+y));o[g].forEach(S=>{const $=x.slice(S.groupOffset,S.groupOffset+S.sizeBytes),I=zA($,[S.manifestEntry]);for(const R in I)f[R]=I[R]}),p+=y}),f}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jre="application/octet-stream",Gre="application/json";class ZS{constructor(e,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(z(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=se().platform.fetch,z(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&z(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{},this.loadOptions=n}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=VA(e,r);if(n.body.append("model.json",new Blob([JSON.stringify(s)],{type:Gre}),"model.json"),e.weightData!=null){const i=Bo.join(e.weightData);n.body.append("model.weights.bin",new Blob([i],{type:jre}),"model.weights.bin")}const o=await this.fetch(this.path,n);if(o.ok)return{modelArtifactsInfo:Hf(e),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await e.json()}catch{let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}const r=n.modelTopology,s=n.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return n}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return FS(e,n=>this.loadWeights(n))}async loadStream(){const e=await this.loadModelJSON(),n=await this.getWeightUrls(e.weightsManifest),r=uv(e.weightsManifest),s=()=>Wre(n,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:r,getWeightStream:s})}async getWeightUrls(e){const n=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=Hre(n),o=this.weightPathPrefix||r,i=[],a=[];for(const l of e)for(const c of l.paths)this.weightUrlConverter!=null?a.push(this.weightUrlConverter(c)):i.push(o+c+s);return this.weightUrlConverter&&i.push(...await Promise.all(a)),i}async loadWeights(e){const n=await this.getWeightUrls(e),r=uv(e),s=await MD(n,this.loadOptions);return[r,s]}}ZS.URL_SCHEME_REGEX=/^https?:\/\//;function Hre(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),s=n>e?t.substring(n):"";return[r+"/",s]}function xv(t){return t.match(ZS.URL_SCHEME_REGEX)!=null}const WD=(t,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let n=!0;if(Array.isArray(t)?n=t.every(r=>xv(r)):n=xv(t),n)return JS(t,e)}return null};cn.registerSaveRouter(WD);cn.registerLoadRouter(WD);function JS(t,e){return new ZS(t,e)}function Kre(t,e){return JS(t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class X1{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class UD{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class Xre{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=n=>Promise.resolve(e.save(n)))}}function qre(t,e,n,r){const s=arguments;return new Xre(jD(...s))}function jD(t,e,n,r){return arguments.length===1?t.modelTopology!=null||t.weightSpecs!=null?new X1(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new X1({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new X1({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:r}))}function Yre(t){return new UD(t)}function Qre(t){return new UD(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GD=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Bo,browserFiles:Vre,browserHTTPRequest:Kre,concatenateArrayBuffers:QX,copyModel:vq,decodeWeights:zA,decodeWeightsStream:MA,encodeWeights:GX,fromMemory:qre,fromMemorySync:jD,getLoadHandlers:oq,getModelArtifactsForJSON:FS,getModelArtifactsForJSONSync:WA,getModelArtifactsInfoForJSON:Hf,getSaveHandlers:sq,getWeightSpecs:uv,http:JS,isHTTPScheme:xv,listModels:yq,loadWeights:Ure,moveModel:bq,registerLoadRouter:rq,registerSaveRouter:nq,removeModel:xq,weightsLoaderFactory:VD,withSaveHandler:Yre,withSaveHandlerSync:Qre},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let su,F3=!1;function Zre(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(t==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,o=!1,i=!1,a=!1;if(t.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&t instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)o=!0;else if(t.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&t instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);if($g(vg,Y.backendName)!=null){const y={pixels:t},x={numChannels:e};return Y.runKernel(vg,y,x)}const[c,d]=s?[t.videoWidth,t.videoHeight]:[t.width,t.height];let f;if(i)f=t.getContext("2d").getImageData(0,0,c,d).data;else if(r||n)f=t.data;else if(o||s||a){if(su==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")su=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else su=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});su.canvas.width=c,su.canvas.height=d,su.drawImage(t,0,0,c,d),f=su.getImageData(0,0,c,d).data}let p;if(e===4)p=new Int32Array(f);else{const y=c*d;p=new Int32Array(y*e);for(let x=0;x<y;x++)for(let w=0;w<e;++w)p[x*e+w]=f[x*4+w]}return _D(p,[d,c,e],"int32")}function Jre(t){if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);const e=t.rank===2?1:t.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`)}async function eC(t,e){let n=L(t,"img","toPixels");if(!(t instanceof fn)){const c=n;n=Qt(c,"int32"),c.dispose()}Jre(n);const[r,s]=n.shape.slice(0,2),o=n.rank===2?1:n.shape[2],i=await n.data(),a=n.dtype==="float32"?255:1,l=new Uint8ClampedArray(s*r*4);for(let c=0;c<r*s;++c){const d=[0,0,0,255];for(let p=0;p<o;p++){const g=i[c*o+p];if(n.dtype==="float32"){if(g<0||g>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${g}.`)}else if(n.dtype==="int32"&&(g<0||g>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${g}.`);o===1?(d[0]=g*a,d[1]=g*a,d[2]=g*a):d[p]=g*a}const f=c*4;l[f+0]=Math.round(d[0]),l[f+1]=Math.round(d[1]),l[f+2]=Math.round(d[2]),l[f+3]=Math.round(d[3])}if(e!=null){F3||$g(tA,Y.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),F3=!0),e.width=s,e.height=r;const c=e.getContext("2d"),d=new ImageData(l,s,r);c.putImageData(d,0,0)}return n!==t&&n.dispose(),l}const HD=X({fromPixels_:Zre});function tC(t,e){const n=t.shape.length,r=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${n}`);if(pe(t.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const s=e.shape,o=s[s.length-1];let i=1;for(let f=0;f<s.length-1;++f)i*=s[f];const a=t.shape,l=s.slice();l.pop();let c=1;for(let f=o;f<n;++f)c*=a[f],l.push(a[f]);const d=[...gn(t.shape).map(f=>f/c),1].slice(0,o);return[l,i,c,d]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vv=-2,ese=-1;function nC(t,e,n){const r=t.shape.length;z(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),z(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)z(e[s]+n[s]<=t.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${e[s]+n[s]}) would overflow input.shape[${s}] (${t.shape[s]})`)}function tse(t){const e=[];let n=0;for(;t>0;)t&1&&e.push(n),t/=2,n++;return e}function rC(t,e,n){const r=[];for(let s=0;s<t.length;s++)r[s]=Math.ceil((e[s]-t[s])/n[s]);return r}function KD(t,e,n,r){const s=[...t];for(let o=s.length;o<r.length;o++)s.push(1);for(let o=0;o<n;o++)o===0?s[e]=1:(s.splice(e,0,1),s.pop());return s}function XD(t,e,n){return n<=t?n:n-(e-1)}function qD(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function nse(t,e,n,r,s,o,i,a,l){const c=t.length;let d=new Array(c),f=new Array(c),p=new Array(c);if(e.length&&n>0){const g=e[0],y=n+1;d=YD(i,g,y,r,t),f=QD(a,g,y,s,t),p=KD(o,g,y,t)}else for(let g=0;g<c;g++)d[g]=JD(i,r,o,t,g,l),f[g]=eO(a,s,o,t,g,l),p[g]=ZD(o,g,l);return{begin:d,end:f,strides:p}}function YD(t,e,n,r,s){const o=[...s],i=qD(n,e);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=0;else{const l=XD(e,n,a);let c=r[l];t&1<<l&&(c=0),o[a]=c}return o}function QD(t,e,n,r,s){const o=[...s],i=qD(n,e);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=Number.MAX_SAFE_INTEGER;else{const l=XD(e,n,a);let c=r[l];t&1<<l&&(c=Number.MAX_SAFE_INTEGER),o[a]=c}for(let a=0;a<o.length;a++){const l=s[a];o[a]<0&&(o[a]+=l),o[a]=yg(0,o[a],s[a])}return o}function ZD(t,e,n){let r=t[e];return(n&1<<e||r==null)&&(r=1),r}function JD(t,e,n,r,s,o){let i=e[s];const a=n[s]||1;(t&1<<s||o&1<<s||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=yg(0,i,l-1),i}function eO(t,e,n,r,s,o){let i=e[s];const a=n[s]||1;(t&1<<s||o&1<<s||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),a>0?i=yg(0,i,l):i=yg(-1,i,l-1),i}function sC(t,e,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(e[s]>0||n[s]!==t[s])return!1;return!0}function oC(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function iC(t,e,n){let r;const s=t.shape.length;typeof e=="number"?r=[e,...new Array(s-1).fill(0)]:e.length<s?r=e.concat(new Array(s-e.length).fill(0)):r=e.slice(),r.forEach(i=>{z(i!==-1,()=>"slice() does not support negative begin indexing.")});let o;return n==null?o=new Array(s).fill(-1):typeof n=="number"?o=[n,...new Array(s-1).fill(-1)]:n.length<s?o=n.concat(new Array(s-n.length).fill(-1)):o=n,o=o.map((i,a)=>i>=0?i:(z(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),t.shape[a]-r[a])),[r,o]}function aC(t,e,n,r,s,o,i,a,l){let c;if(r==null?(c=new Array(e.length),c.fill(1)):c=r,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let d=!1;const f={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:c.slice(),beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};for(let I=0;I<f.dims;I++)d&&(1<<I&a)!==0&&f.numAddAxisAfterEllipsis++,1<<I&i&&(d=!0);d||(f.ellipsisMask|=1<<f.dims,f.dims++);const p={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};rse(f,p);let g=!0,y=!0,x=!0;const w=[],S=[];for(let I=0;I<t.length;++I){if(p.strides[I]===0)throw Error(`strides[${I}] must be non-zero`);const R=!!(p.shrinkAxisMask&1<<I),_=t[I];if(_===-1){w.push(R?1:-1);continue}const O=[p.beginMask&1<<I,p.endMask&1<<I],F=[p.strides[I]>0?0:-1,p.strides[I]>0?_:_-1];if(R&&p.strides[I]<=0)throw Error("only stride 1 allowed on non-range indexing.");x=x&&p.strides[I]===1;const B=!!(p.beginMask&1<<I&&p.endMask&1<<I);if(p.beginValid&&p.endValid){if(R){const re=p.begin[I]<0?_+p.begin[I]:p.begin[I];if(p.begin[I]=re,p.end[I]=p.begin[I]+1,re<0||re>=_)throw Error(`slice index ${p.begin[I]} of dimension ${I} out of bounds.`)}else p.begin[I]=L3(p.begin[I],0,p.strides[I],_,O,F),p.end[I]=L3(p.end[I],1,p.strides[I],_,O,F);const P=p.strides[I]===1&&p.begin[I]===0&&p.end[I]===_;g=g&&P,y=y&&(I===0&&p.strides[I]===1||P)}else g=g&&p.strides[I]===1&&B,y=y&&(I===0&&p.strides[I]===1||B);let M,V=!1;if(p.beginValid&&p.endValid?(M=p.end[I]-p.begin[I],V=!0):R?(M=1,V=!0):B&&_>=0&&(p.strides[I]<0?M=-_:M=_,V=!0),V){let P;M===0||M<0!=p.strides[I]<0?P=0:P=Math.trunc(M/p.strides[I])+(M%p.strides[I]!==0?1:0),w.push(P)}else w.push(-1)}for(let I=0;I<p.finalShapeGatherIndices.length;++I){const R=p.finalShapeGatherIndices[I];R>=0?S.push(w[R]):R===vv&&S.push(1)}return{finalShapeSparse:S.filter((I,R)=>p.finalShapeGatherIndices[R]!==vv),finalShape:S,isIdentity:g,sliceDim0:y,isSimpleSlice:x,begin:p.begin,end:p.end,strides:p.strides}}function rse(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=t.begin!=null,e.endValid=t.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){const s=Math.min(e.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<s;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&t.newAxisMask)e.finalShapeGatherIndices.push(vv),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);t.begin!=null&&(e.begin[n]=t.begin[r]),t.end!=null&&(e.end[n]=t.end[r]),e.strides[n]=t.strides[r],t.beginMask&1<<r&&(e.beginMask|=1<<n),t.endMask&1<<r&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(ese),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[n]=r,n++}}function L3(t,e,n,r,s,o){if(s[e])return n>0?o[e]:o[e+1&1];{const i=t<0?r+t:t;return i<o[0]?o[0]:i>o[1]?o[1]:i}}const sse=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:nC,computeFlatOffset:oC,computeOutShape:rC,getNormalizedAxes:nse,isSliceContinous:sC,maskToAxes:tse,parseSliceParams:iC,sliceInfo:aC,startForAxis:JD,startIndicesWithElidedDims:YD,stopForAxis:eO,stopIndicesWithElidedDims:QD,stridesForAxis:ZD,stridesWithElidedDims:KD},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ose=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t();function ise(){return new Promise(t=>ose(()=>t()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lC(t,e){const n=t[0].length;t.forEach((s,o)=>{z(s.length===n,()=>`Error in concat${n}D: rank of tensors[${o}] must be the same as the rank of the rest (${n})`)}),z(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=t[0];t.forEach((s,o)=>{for(let i=0;i<n;i++)z(i===e||s[i]===r[i],()=>`Error in concat${n}D: Shape of tensors[${o}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`)})}function ho(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Oo;(function(t){t[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS"})(Oo||(Oo={}));function tO(t,e,n){let r=new Array;if(n==null&&e==null)return r;if(e==null)for(;r.length<t+n.length;)r.push(-1);else r=e.slice();if(n==null)return r;if(t+n.length!==r.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${t+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){const o=n[s],i=r[r.length-n.length+s],a=r[i];if(o>=0)if(a>=0){if(a!==o)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${s+t}] = ${o} but shape[${s+t}] = ${a}`)}else r[i]=o}return r}function nO(t){const e={FIRST_DIM_SIZE:Oo.FIRST_DIM_SIZE,VALUE_ROWIDS:Oo.VALUE_ROWIDS,ROW_LENGTHS:Oo.ROW_LENGTHS,ROW_SPLITS:Oo.ROW_SPLITS,ROW_LIMITS:Oo.ROW_LIMITS,ROW_STARTS:Oo.ROW_STARTS},n=[];for(const r of t)if(r in e)n.push(e[r]);else break;return n}function rO(t){return t.length===0?0:t[0]===Oo.FIRST_DIM_SIZE?t.length-1:t.length}function sO(t,e){if(t==null||e==null)return;const n=t.length,r=e.length;if(n>=r)throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){const o=t[s],i=e[s+1];if(o>=0&&i>=0&&o!==1&&o!==i)throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${s-t.length}] = ${o} but ragged tensor input.flatValues.shape[${s-t.length}] = ${i}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uC=30;function xy(t){return t<=uC?t:tv(t,Math.floor(Math.sqrt(t)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cC(t,e,n){const r=n*(typeof t=="number"?t:t[0]),s=e*(typeof t=="number"?t:t[1]);return[r,s]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yf(t,e,n,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(t[0]/n),s=s.concat(t.slice(1));else{s=s.concat(t[0]);const o=e.length;for(let i=0;i<o;++i)s=s.concat([t[i+1]/e[i],e[i]]);s=s.concat(t.slice(o+1))}return s}function Qf(t,e,n=!0){const r=[];if(n){r.push(e);for(let s=e+1;s<t;++s)s<=2*e?(r.push(s),r.push(s-(e+1))):r.push(s)}else{const s=[],o=[];for(let i=1;i<t;++i)i>=e*2+1||i%2===1?o.push(i):s.push(i);r.push(...s),r.push(0),r.push(...o)}return r}function Zf(t,e,n,r=!0){const s=[];r?s.push(t[0]/n):s.push(t[0]*n);for(let o=1;o<t.length;++o)o<=e.length?r?s.push(e[o-1]*t[o]):s.push(t[o]/e[o-1]):s.push(t[o]);return s}function dC(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function hC(t,e,n){const r=t.slice(0,1);for(let s=0;s<n;++s)r.push(t[s+1]-e[s][0]-e[s][1]);return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fC=1.7580993408473768,pC=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mC=.3275911,gC=.254829592,yC=-.284496736,xC=1.421413741,vC=-1.453152027,bC=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kf(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(t.length*2);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function ase(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function lse(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=0;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function use(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=2;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function cse(t,e){const n=t[e*2],r=t[e*2+1];return{real:n,imag:r}}function dse(t,e,n,r){t[r*2]=e,t[r*2+1]=n}function hse(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let s=0;s<Math.ceil(t/2);s++){const o=(e?2:-2)*Math.PI*(s/t);n[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:n,imag:r}}function fse(t,e,n){const r=(n?2:-2)*Math.PI*(t/e),s=Math.cos(r),o=Math.sin(r);return{real:s,imag:o}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q1="->",pse=/->/g,z3=",",B3="...";function wC(t,e){t=t.replace(/\s/g,"");const n=(t.length-t.replace(pse,"").length)/q1.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${q1}").`);const[r,s]=t.split(q1);z(r.indexOf(B3)===-1,()=>`The ellipsis notation ("${B3}") is not supported yet.`);const o=r.split(z3),i=o.length;if(e!==i)throw new Error(`Expected ${i} input tensors, received ${e}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let p=0;p<s.length;++p){const g=s[p];if(!o.some(y=>y.indexOf(g)!==-1))throw new Error(`Output subscripts contain the label ${g} not present in the input subscripts.`);a.indexOf(g)===-1&&a.push(g)}for(let p=0;p<r.length;++p){const g=r[p];a.indexOf(g)===-1&&g!==z3&&a.push(g)}const l=new Array(o.length);for(let p=0;p<i;++p){if(new Set(o[p].split("")).size!==o[p].length)throw new Error(`Found duplicate axes in input component ${o[p]}. Support for duplicate axes in input is not implemented yet.`);l[p]=[];for(let g=0;g<o[p].length;++g)l[p].push(a.indexOf(o[p][g]))}const c=a.length,d=s.length,f=[];for(let p=d;p<c;++p)f.push(p);return{allDims:a,summedDims:f,idDims:l}}function SC(t,e){let n=new Array(t);n.fill(-1);for(let s=0;s<e.length;++s)n[e[s]]=s;const r=[];for(let s=0;s<t;++s)n[s]===-1&&r.push(s);return n=n.filter(s=>s!==-1),{permutationIndices:n,expandDims:r}}function CC(t,e,n){const r=new Array(t);for(let s=0;s<n.length;++s){const o=n[s].shape;for(let i=0;i<e[s].length;++i)r[e[s][i]]===void 0?r[e[s][i]]=o[i]:z(r[e[s][i]]===o[i],()=>`Expected dimension ${r[e[s][i]]} at axis ${i} of input shaped ${JSON.stringify(o)}, but got dimension ${o[i]}`)}}function $C(t,e){const n=t,r=[];let s=0;t.length===0&&n.push(-1),s=t.length+1;for(let i=0;i<s;++i)r.push([]);const o=[];for(let i=0;i<n.length;++i){const a=n[i],l=mse(e,a);for(const c of l)o.indexOf(c)===-1&&(r[i].push(c),o.push(c))}return{path:n,steps:r}}function kC(t){return t.every((e,n)=>e===n)}function mse(t,e){const n=[];for(let r=0;r<t.length;++r)(t[r].length===0||t[r].indexOf(e)!==-1||e===-1)&&n.push(r);return n}function TC(t,e,n=0){let r=[];if(typeof e=="number")z(t.shape[n]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(t.shape[n]/e);else{const s=e.reduce((i,a)=>(a===-1&&(i+=1),i),0);z(s<=1,()=>"There should be only one negative value in split array.");const o=e.indexOf(-1);if(o!==-1){const i=e.reduce((a,l)=>l>0?a+l:a);e[o]=t.shape[n]-i}z(t.shape[n]===e.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oO(t){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${t}`}function iO(t,e){return`indices(${t}, 0) is invalid: ${e} < 0`}function aO(t,e,n){return`indices(${t}, 0) is invalid: ${e} >= ${n}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lO(t,e){return`only one output dimension may be -1, not both ${t} and ${e}`}function uO(t,e){return`size ${t} must be non-negative, not ${e}`}function cO(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function dO(t,e){const n=pe(t),r=pe(e);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${t} outputShape= ${e}`}function hO(t,e){const n=pe(t),r=pe(e);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${t} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bv(){return"segment ids must be >= 0"}function fO(){return"segment ids are not increasing"}function pO(t,e){return`Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function mO(t,e,n){return`Bad: indices[${t}] == ${e} out of range [0, ${n})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gO(t,e){let n=!1,r;for(t<=uC?(r=t,n=!0):r=tv(t,Math.floor(Math.sqrt(t)));!n;)r>e||r===t?n=!0:r=tv(t,r+1);return r}function IC(t,e,n){const r=[],s=t.length;for(let o=0;o<s;o++)o!==e?r.push(t[o]):r.push(n);return r}function NC(t,e,n,r){const s=e.shape.length,o=t.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${o}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let f=0;f<r;++f)if(t.shape[f]!==e.shape[f])throw new Error(`x.shape[${f}]: ${t.shape[f]} should be equal to indices.shape[${f}]: ${e.shape[f]}.`);const i=t.shape[n],a=[];let l=1,c=1,d=1;for(let f=0;f<r;++f)a.push(t.shape[f]),l*=t.shape[f];for(let f=r;f<n;f++)a.push(t.shape[f]),c*=t.shape[f];for(let f=r;f<s;f++)a.push(e.shape[f]);for(let f=n+1;f<o;f++)a.push(t.shape[f]),d*=t.shape[f];return{batchSize:l,sliceSize:d,outerSize:c,dimSize:i,outputShape:a}}const gse=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:NC,computeOutShape:IC,segOpComputeOptimalWindowSize:gO},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bl(t){try{return t.map(e=>fa(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function yO(t){return t.map(e=>hl(e))}const yse=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:gC,ERF_A2:yC,ERF_A3:xC,ERF_A4:vC,ERF_A5:bC,ERF_P:mC,PARALLELIZE_THRESHOLD:uC,get RowPartitionType(){return Oo},SELU_SCALE:pC,SELU_SCALEALPHA:fC,applyActivation:gy,assertAndGetBroadcastShape:ct,assertAxesAreInnerMostDims:bs,assertParamsConsistent:lC,assignToTypedArray:dse,axesAreInnerMostDims:BS,calculateShapes:Bu,checkEinsumDimSizes:CC,checkPadOnDimRoundingMode:po,combineLocations:aD,combineRaggedTensorToTensorShapes:tO,complexWithEvenIndex:lse,complexWithOddIndex:use,computeConv2DInfo:kn,computeConv3DInfo:Tl,computeDefaultPad:LS,computeDilation2DInfo:Kf,computeOptimalWindowSize:xy,computeOutAndReduceShapes:Ls,computeOutShape:ho,computePool2DInfo:fo,computePool3DInfo:Sa,convertConv2DDataFormat:Mo,decodeEinsumEquation:wC,eitherStridesOrDilationsAreOne:Er,expandShapeToKeepDim:vs,exponent:fse,exponents:hse,fromStringArrayToUint8:yO,fromUint8ToStringArray:bl,getAxesPermutation:ur,getBroadcastDims:cd,getComplexWithIndex:cse,getEinsumComputePath:$C,getEinsumPermutation:SC,getFusedBiasGradient:my,getFusedDyActivation:py,getImageCenter:cC,getInnerMostAxes:cr,getPermuted:Qf,getRaggedRank:rO,getReductionAxes:sD,getReshaped:Yf,getReshapedPermuted:Zf,getRowPartitionTypesHelper:nO,getSliceBeginCoords:dC,getSliceSize:hC,getSparseFillEmptyRowsIndicesDenseShapeMismatch:oO,getSparseFillEmptyRowsNegativeIndexErrorMessage:iO,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:aO,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:cO,getSparseReshapeInputOutputMismatchErrorMessage:hO,getSparseReshapeInputOutputMultipleErrorMessage:dO,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:lO,getSparseReshapeNegativeOutputDimErrorMessage:uO,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:mO,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:bv,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:fO,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:pO,getUndoAxesPermutation:qf,isIdentityPermutation:kC,log:gX,mergeRealAndImagArrays:kf,prepareAndValidate:tC,prepareSplitSize:TC,segment_util:gse,shouldFuse:yy,slice_util:sse,splitRealAndImagArrays:ase,stridesOrDilationsArePositive:Du,tupleValuesAreOne:xf,upcastType:Gr,validateDefaultValueShape:sO,validateInput:KS,validateUpdateShape:PD,warn:Lo},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Dre();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fu={},bm={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function xse(t,e){fu[t]=e}function zo(t,e){if(!(t in fu)||e!=null){const r=bse(t,e);if(r!==null)fu[t]=r;else return console.log("Could not get context for WebGL version",t),null}const n=fu[t];return n==null||n.isContextLost()?(delete fu[t],zo(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),fu[t])}function vse(t){if(!se().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&t===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function bse(t,e){if(t!==1&&t!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=e??vse(t);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete fu[t]},!1),se().getBool("SOFTWARE_WEBGL_ENABLED")&&(bm.failIfMajorPerformanceCaveat=!1),t===1?n.getContext("webgl",bm)||n.getContext("experimental-webgl",bm):n.getContext("webgl2",bm)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Tf;(function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"})(Tf||(Tf={}));var Ps;(function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"})(Ps||(Ps={}));var qn;(function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(qn||(qn={}));function Jf(t,e){return[e,t]}function wse(t,e){return t*e}function wm(t){const e=pe(t),n=Math.ceil(e/4);return Jx(n)}function Id(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function Sse(t,e){const[n,r]=Id(t,e);return n*r*4}function EC(t,e){const n=t;let r,s,o,i,a,l,c,d,f,p;return se().getNumber("WEBGL_VERSION")===2?(r=n.R32F,s=n.R16F,o=n.RGBA16F,i=n.RGBA32F,a=n.RED,c=4,d=1,f=n.HALF_FLOAT,p=n.FLOAT,l=n.RGBA8):(r=t.RGBA,s=t.RGBA,o=t.RGBA,i=n.RGBA,a=t.RGBA,c=4,d=4,f=e!=null?e.HALF_FLOAT_OES:null,p=t.FLOAT,l=t.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:d,textureTypeHalfFloat:f,textureTypeFloat:p}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oe(t,e){const n=e();return se().getBool("DEBUG")&&Cse(t),n}function Cse(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+Ise(t,e))}const $se=596e-10,kse=65504;function Tse(t){return!!(se().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||t===0||$se<Math.abs(t)&&Math.abs(t)<kse)}function Ise(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Sm(t,e){return $a(t,()=>t.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function Nse(t,e){const n=$a(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Oe(t,()=>t.shaderSource(n,e)),Oe(t,()=>t.compileShader(n)),t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function Ese(t,e){const n=$a(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Oe(t,()=>t.shaderSource(n,e)),Oe(t,()=>t.compileShader(n)),se().get("ENGINE_COMPILE_ONLY"))return n;if(t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw xO(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const Rse=/ERROR: [0-9]+:([0-9]+):/g;function xO(t,e){const n=Rse.exec(e);if(n==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(t);return}const r=+n[1],s=t.split(`
`),o=s.length.toString().length+2,i=s.map((f,p)=>Yc((p+1).toString(),o)+f);let a=0;for(let f=0;f<i.length;f++)a=Math.max(i[f].length,a);const l=i.slice(0,r-1),c=i.slice(r-1,r),d=i.slice(r);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Yc(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join(`
`))}function _se(t){return $a(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}function Pse(t,e){if(Oe(t,()=>t.linkProgram(e)),!se().get("ENGINE_COMPILE_ONLY")&&t.getProgramParameter(e,t.LINK_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function Y1(t,e){if(Oe(t,()=>t.validateProgram(e)),t.getProgramParameter(e,t.VALIDATE_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function Ase(t,e){const n=$a(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Oe(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),Oe(t,()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function Dse(t,e){const n=$a(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Oe(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)),Oe(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function Ose(t){return $a(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}function Fse(t,e){const n=se().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){const r=`[${t}x${e}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(t>n||e>n){const r=`[${t}x${e}]`,s=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function Lse(t){return $a(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function M3(t,e,n,r,s,o,i){const a=t.getAttribLocation(e,n);return a===-1?!1:(Oe(t,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),Oe(t,()=>t.vertexAttribPointer(a,s,t.FLOAT,!1,o,i)),Oe(t,()=>t.enableVertexAttribArray(a)),!0)}function zse(t,e,n){Use(t,n),Oe(t,()=>t.activeTexture(t.TEXTURE0+n)),Oe(t,()=>t.bindTexture(t.TEXTURE_2D,e))}function Bse(t,e,n){return $a(t,()=>t.getUniformLocation(e,n),'uniform "'+n+'" not present in program.')}function Mse(t,e,n){return t.getUniformLocation(e,n)}function Vse(t,e,n,r){Oe(t,()=>zse(t,e,r)),Oe(t,()=>t.uniform1i(n,r))}function Q1(t,e,n){Oe(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),Oe(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0))}function V3(t,e){Oe(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),Oe(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function Cm(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Wse(t,e))}function Wse(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function $a(t,e,n){const r=Oe(t,()=>e());if(r==null)throw new Error(n);return r}function Use(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n){const s=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${s}.`)}}function dd(t,e=2){return pe(t.slice(0,t.length-e))}function hd(t){if(t.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function $m(t){let e=[1,1,1];return t.length===0||t.length===1&&t[0]===1||(e=[dd(t),...hd(t)]),e}function jse(t,e=!1){let n=se().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=se().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&se().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),e&&(n=n*2,r=r*2,t=t.map((a,l)=>l>=t.length-2?ew(t[l]):t[l]),t.length===1&&(t=[2,t[0]])),t.length!==2&&(t=Cl(t).newShape);let s=pe(t),o=null;t.length<=1&&s<=n?o=[1,s]:t.length===2&&t[0]<=n&&t[1]<=n?o=t:t.length===3&&t[0]*t[1]<=n&&t[2]<=n?o=[t[0]*t[1],t[2]]:t.length===3&&t[0]<=n&&t[1]*t[2]<=n?o=[t[0],t[1]*t[2]]:t.length===4&&t[0]*t[1]*t[2]<=n&&t[3]<=n?o=[t[0]*t[1]*t[2],t[3]]:t.length===4&&t[0]<=n&&t[1]*t[2]*t[3]<=n&&(o=[t[0],t[1]*t[2]*t[3]]);const i=o!=null&&Math.max(...o)>r&&Math.min(...o)<=(e?2:1)&&Math.min(...o)>0;if(o==null||i)if(e){const a=dd(t);let l=2,c=2;t.length&&([l,c]=hd(t)),s=a*(l/2)*(c/2),o=Jx(s).map(d=>d*2)}else o=Jx(s);return o}function km(t){return t%2===0}function Rg(t,e){if(t=t.slice(-2),e=e.slice(-2),Vt(t,e)||!t.length||!e.length||t[0]===0||t[1]===0||e[0]===0||e[1]===0)return!0;if(t.length!==e.length){const n=t[t.length-1],r=e[e.length-1];if(n===r||km(n)&&km(r)&&(t[0]===1||e[0]===1))return!0}return t[1]===e[1]&&km(t[0])&&km(e[0])}let Z1,J1;function Gse(t){if(Z1==null){const e=zo(t);Z1=e.getParameter(e.MAX_TEXTURE_SIZE)}return Z1}function Hse(t){if(J1==null){const e=zo(t);J1=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,J1)}function Kse(t){if(t===0)return 0;let e;const n=zo(t);return io(n,"EXT_disjoint_timer_query_webgl2")&&t===2?e=2:io(n,"EXT_disjoint_timer_query")?e=1:e=0,e}function io(t,e){return t.getExtension(e)!=null}function W3(t){try{if(zo(t)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function Xse(t){if(t===0)return!1;const e=zo(t);if(t===1){if(!io(e,"OES_texture_float"))return!1}else if(!io(e,"EXT_color_buffer_float"))return!1;return wv(e)}function qse(t){if(t===0)return!1;const e=zo(t);if(t===1){if(!io(e,"OES_texture_float")||!io(e,"WEBGL_color_buffer_float"))return!1}else{if(io(e,"EXT_color_buffer_float"))return wv(e);const r="EXT_color_buffer_half_float";if(io(e,r)){const s=e.getExtension(r);return Yse(e,s)}return!1}return wv(e)}function wv(t){const e=EC(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(o),i}function Yse(t,e){const n=EC(t,e),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(i),a}function Qse(t){return t!==2?!1:zo(t).fenceSync!=null}function ep(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&z(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ve=se();Ve.registerFlag("HAS_WEBGL",()=>Ve.getNumber("WEBGL_VERSION")>0);Ve.registerFlag("WEBGL_VERSION",()=>W3(2)?2:W3(1)?1:0);Ve.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Ve.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Ve.get("WEBGL_VERSION")===2);Ve.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Ve.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Ve.registerFlag("WEBGL_PACK",()=>Ve.getBool("HAS_WEBGL"));Ve.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_CLIP",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_REDUCE",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_LAZILY_UNPACK",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_CONV_IM2COL",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Gse(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Hse(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=Ve.getNumber("WEBGL_VERSION");return t===0?0:Kse(t)});Ve.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Ve.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!AA());Ve.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Xse(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Ve.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Ve.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Ve.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>qse(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_FENCE_API_ENABLED",()=>Qse(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Ve.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Ve.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)});Ve.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>AA()?1:-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)});Ve.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Ve.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Ve.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Ve.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Ve.registerFlag("WEBGL_EXP_CONV",()=>!1);Ve.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Ve.getBool("IS_TEST"));Ve.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Ve.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Ve.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Ve.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rr(){let t,e,n,r,s,o,i,a,l,c;return se().getNumber("WEBGL_VERSION")===2?(t="#version 300 es",e="in",n="out",r="in",s="texture",o="outputColor",i="out vec4 outputColor;",a=se().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(t="",e="attribute",n="varying",r="varying",s="texture2D",o="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:s,output:o,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wu(t,e,n="index"){const r=gn(e);return r.map((s,o)=>{const i=`int ${t[o]} = ${n} / ${s}`,a=o===r.length-1?`int ${t[o+1]} = ${n} - ${t[o]} * ${s}`:`index -= ${t[o]} * ${s}`;return`${i}; ${a};`}).join("")}function vy(t,e,n="index"){const r=gn(e);return r.map((s,o)=>{const i=`int ${t[o]} = ${n} / outShapeStrides[${o}]`,a=o===r.length-1?`int ${t[o+1]} = ${n} - ${t[o]} * outShapeStrides[${o}]`:`index -= ${t[o]} * outShapeStrides[${o}]`;return`${i}; ${a};`}).join("")}function Zse(t,e){const n=t.length,r=t.map(o=>`${e}[${o}]`),s=new Array(n-1);s[n-2]=r[n-1];for(let o=n-3;o>=0;--o)s[o]=`(${s[o+1]} * ${r[o+1]})`;return s}function Jse(t,e,n="index"){const r=t.map((o,i)=>i),s=Zse(r,e);return s.map((o,i)=>{const a=`int ${t[i]} = ${n} / ${s[i]}`,l=i===s.length-1?`int ${t[i+1]} = ${n} - ${t[i]} * ${s[i]}`:`index -= ${t[i]} * ${s[i]}`;return`${a}; ${l};`}).join("")}function RC(t){const e=gn(t).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function _C(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const vO=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:bO}=yse;function eoe(t,e,n){const r=[];if(t.forEach(g=>{const y=pe(g.shapeInfo.logicalShape);if(g.shapeInfo.isUniform?r.push(`uniform float ${g.name}${y>1?`[${y}]`:""};`):(r.push(`uniform sampler2D ${g.name};`),r.push(`uniform int offset${g.name};`)),n.enableShapeUniforms){const{uniformShape:x}=PC(n.packedInputs,g.shapeInfo.logicalShape,g.shapeInfo.texShape);switch(x.length){case 1:r.push(`uniform int ${g.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${g.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${g.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${g.name}Shape;`);break}r.push(`uniform ivec2 ${g.name}TexShape;`)}}),n.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(g=>{r.push(`uniform ${g.type} ${g.name}${g.arrayIndex?`[${g.arrayIndex}]`:""};`)});const s=r.join(`
`),o=t.map(g=>toe(g,e,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=e.texShape,a=Rr(),l=soe(a);let c,d,f=aoe(a);return e.isPacked?(c=noe(e.logicalShape,i,n.enableShapeUniforms),d=ioe(a)):(c=roe(e.logicalShape,i,n.enableShapeUniforms),d=ooe(a)),n.packedInputs&&(f+=doe),[f,l,d,s,c,o,n.userCode].join(`
`)}function Nd(t,e=!1){const n=t.shapeInfo.logicalShape;switch(n.length){case 0:return Coe(t,e);case 1:return koe(t,e);case 2:return Ioe(t,e);case 3:return Eoe(t,e);case 4:return _oe(t,e);case 5:return Poe(t);case 6:return Aoe(t);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function wO(t,e){switch(t.shapeInfo.logicalShape.length){case 0:return Soe(t);case 1:return $oe(t,e);case 2:return Toe(t,e);case 3:return Noe(t,e);default:return Roe(t,e)}}function toe(t,e,n=!1,r){let s="";n?s+=wO(t,r):s+=Nd(t,r);const o=t.shapeInfo.logicalShape,i=e.logicalShape;return o.length<=i.length&&(n?s+=Doe(t,e):s+=Ooe(t,e)),s}function noe(t,e,n){switch(t.length){case 0:return SO();case 1:return hoe(t,e,n);case 2:return boe(t,e,n);case 3:return poe(t,e,n);default:return goe(t,e,n)}}function roe(t,e,n){switch(t.length){case 0:return SO();case 1:return foe(t,e,n);case 2:return woe(t,e,n);case 3:return moe(t,e,n);case 4:return yoe(t,e,n);case 5:return xoe(t,e);case 6:return voe(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}function soe(t){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${t.texture2D}(textureSampler, uv).r;
    }
  `}function ooe(t){return`
    void setOutput(float val) {
      ${t.output} = vec4(val, 0, 0, 0);
    }
  `}function ioe(t){return`
    void setOutput(vec4 val) {
      ${t.output} = val;
    }
  `}function aoe(t){return`${t.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${t.varyingFs} vec2 resultUV;
    ${t.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${t.defineSpecialNaN}
    ${t.defineSpecialInf}
    ${t.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${loe}
    ${uoe}
    ${coe}
  `}const loe=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,uoe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,coe=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,doe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function SO(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function hoe(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function foe(t,e,n){return e[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function poe(t,e,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[2]/2),o=s*Math.ceil(t[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function moe(t,e,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${vy(["r","c","d"],t)}
    return ivec3(r, c, d);
  }
`;const r=Wu(["r","c","d"],t);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function goe(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[t.length-1]/2),o=s*Math.ceil(t[t.length-2]/2);let i=o,a="",l="b, r, c";for(let c=2;c<t.length-1;c++)i*=t[t.length-c-1],a=`
      int b${c} = index / ${i};
      index -= b${c} * ${i};
    `+a,l=`b${c}, `+l;return`
    ivec${t.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${a}

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${t.length}(${l});
    }
  `}function yoe(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${vy(["r","c","d","d2"],t)}
      return ivec4(r, c, d, d2);
    }
  `;const r=Wu(["r","c","d","d2"],t);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function xoe(t,e){const n=Wu(["r","c","d","d2","d3"],t);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function voe(t,e){const n=Wu(["r","c","d","d2","d3","d4"],t);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function boe(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Vt(t,e))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const s=Math.ceil(t[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function woe(t,e,n){return Vt(t,e)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:t[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:t[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${t[1]};
      int c = index - r * ${t[1]};
      return ivec2(r, c);
    }
  `}function Uu(t){return`offset${t}`}function Soe(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=Rr();return`
    vec4 ${n}() {
      return ${r.texture2D}(${e}, halfCR);
    }
  `}function Coe(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[s,o]=t.shapeInfo.texShape;if(s===1&&o===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;const i=Uu(n);if(e)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;const[a,l]=t.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function $oe(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t.shapeInfo.texShape,o=Rr();if(e)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${o.texture2D}(${n}, uv);
    }
  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${o.texture2D}(${n}, uv);
    }
  `}function koe(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Ed(t)}
      }
    `;const s=t.shapeInfo.texShape,o=s[0],i=s[1];if(i===1&&o===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;const a=Uu(n);return i===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${o}.0);
        return sampleTexture(${n}, uv);
      }
    `:o===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:e?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${a});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${o}, ${i}, index + ${a});
      return sampleTexture(${n}, uv);
    }
  `}function Toe(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape,i=o[0],a=o[1],l=Rr();if(o!=null&&Vt(n,o))return e?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(e)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;const c=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],d=Math.ceil(n[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${d}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function Ioe(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape;if(o!=null&&Vt(n,o)){if(e)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const p=o[0],g=o[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${g}.0, ${p}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:i,keptDims:a}=Cl(n),l=i;if(l.length<n.length){const p=Rd(t,l),g=["row","col"];return`
      ${Nd(p,e)}
      float ${s}(int row, int col) {
        return ${s}(${_d(g,a)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${Ed(t)}
      }
    `;const c=o[0],d=o[1],f=Uu(r);return d===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${r}, uv);
    }
  `:c===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:e?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${f};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${f};
    vec2 uv = uvFromFlat(${c}, ${d}, index);
    return sampleTexture(${r}, uv);
  }
`}function Noe(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(n[0]===1){const p=n.slice(1),g=[1,2],y=Rd(t,p),x=["b","row","col"];return`
        ${wO(y,e)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${_d(x,g)});
        }
      `}const a=Rr();if(e)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `;const l=i[0],c=i[1],d=Math.ceil(n[2]/2),f=d*Math.ceil(n[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${f}, ${d}, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `}function Eoe(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[1]*n[2],i=n[2],{newShape:a,keptDims:l}=Cl(n),c=a;if(c.length<n.length){const x=Rd(t,c),w=["row","col","depth"];return`
        ${Nd(x,e)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${_d(w,l)});
        }
      `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${o}, ${i}, 1)));
        ${Ed(t)}
      }
    `;const d=t.shapeInfo.texShape,f=d[0],p=d[1],g=t.shapeInfo.flatOffset;if(p===o&&g==null)return e?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${p}.0, ${f}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(p===i&&g==null)return e?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${f}.0);
      return sampleTexture(${r}, uv);
    }
  `;const y=Uu(r);return e?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${y};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o} + col * ${i} + depth + ${y};
        vec2 uv = uvFromFlat(${f}, ${p}, index);
        return sampleTexture(${r}, uv);
      }
  `}function Roe(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=Rr();if(e)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);
    }
  `;const o=t.shapeInfo.logicalShape,i=o.length,a=t.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],d=l[1],f=Math.ceil(o[i-1]/2);let p=f*Math.ceil(o[i-2]/2),g="int b, int row, int col",y=`b * ${p} + (row / 2) * ${f} + (col / 2)`;for(let x=2;x<i-1;x++)g=`int b${x}, `+g,p*=o[i-x-1],y=`b${x} * ${p} + `+y;return`
    vec4 ${r}(${g}) {
      int index = ${y};
      int texR = index / ${d};
      int texC = index - texR * ${d};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${c});
      return ${s.texture2D}(${n}, uv);
    }
  `}function _oe(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[3],i=n[2]*o,a=n[1]*i,{newShape:l,keptDims:c}=Cl(n);if(l.length<n.length){const $=Rd(t,l),I=["row","col","depth","depth2"];return`
      ${Nd($,e)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${_d(I,c)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${o}, 1)));
        ${Ed(t)}
      }
    `;const d=t.shapeInfo.flatOffset,f=t.shapeInfo.texShape,p=f[0],g=f[1],y=`int stride2 = ${r}Shape[3];`,x=`int stride1 = ${r}Shape[2] * stride2;`,w=`int stride0 = ${r}Shape[1] * stride1;`;if(g===a&&d==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${y}
        ${x}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${p}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(g===o&&d==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${p}.0);
        return sampleTexture(${r}, uv);
      }
    `;const S=Uu(r);return e?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${y}
      ${x}
      ${w}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${S});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${o} + depth2;
      vec2 uv = uvFromFlat(${p}, ${g}, index + ${S});
      return sampleTexture(${r}, uv);
    }
  `}function Poe(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[4],o=e[3]*s,i=e[2]*o,a=e[1]*i,{newShape:l,keptDims:c}=Cl(e);if(l.length<e.length){const x=Rd(t,l),w=["row","col","depth","depth2","depth3"];return`
      ${Nd(x)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${_d(w,c)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${o}, ${s})) +
          depth3;
        ${Ed(t)}
      }
    `;const d=t.shapeInfo.flatOffset,f=t.shapeInfo.texShape,p=f[0],g=f[1];if(g===a&&d==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${o}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(g===s&&d==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;const y=Uu(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${o} +
          depth2 * ${s} + depth3 + ${y};
      vec2 uv = uvFromFlat(${p}, ${g}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Aoe(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:o}=Cl(e);if(s.length<e.length){const w=Rd(t,s),S=["row","col","depth","depth2","depth3","depth4"];return`
      ${Nd(w)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${_d(S,o)});
      }
    `}const i=e[5],a=e[4]*i,l=e[3]*a,c=e[2]*l,d=e[1]*c;if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${d}, ${c}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Ed(t)}
      }
    `;const f=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,g=p[0],y=p[1];if(y===d&&f==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${g}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(y===i&&f==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${g}.0);
        return sampleTexture(${n}, uv);
      }
    `;const x=Uu(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${d} + col * ${c} + depth * ${l} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${x};
      vec2 uv = uvFromFlat(${g}, ${y}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Ed(t){const e=t.name,n=pe(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function Doe(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",o=t.shapeInfo.logicalShape.length,i=e.logicalShape.length,a=bO(t.shapeInfo.logicalShape,e.logicalShape),l=Kt(i),c=i-o;let d;const f=["x","y","z","w","u","v"];o===0?d="":i<2&&a.length>=1?d="coords = 0;":d=a.map($=>`coords.${f[$+c]} = 0;`).join(`
`);let p="";i<2&&o>0?p="coords":p=t.shapeInfo.logicalShape.map(($,I)=>`coords.${f[I+c]}`).join(", ");let g="return outputValue;";const x=pe(t.shapeInfo.logicalShape)===1,S=pe(e.logicalShape)===1;if(o===1&&!x&&!S)g=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(x&&!S)i===1?g=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:g=`
        return vec4(outputValue.x);
      `;else if(a.length){const $=o-2,I=o-1;a.indexOf($)>-1&&a.indexOf(I)>-1?g="return vec4(outputValue.x);":a.indexOf($)>-1?g="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(I)>-1&&(g="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${l} coords = getOutputCoords();
      ${d}
      vec4 outputValue = get${r}(${p});
      ${g}
    }
  `}function Ooe(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",o=e.texShape,i=t.shapeInfo.texShape,a=t.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!t.shapeInfo.isUniform&&a===l&&t.shapeInfo.flatOffset==null&&Vt(i,o))return`
      float ${s}() {
        return sampleTexture(${n}, resultUV);
      }
    `;const c=Kt(l),d=bO(t.shapeInfo.logicalShape,e.logicalShape),f=l-a;let p;const g=["x","y","z","w","u","v"];a===0?p="":l<2&&d.length>=1?p="coords = 0;":p=d.map(x=>`coords.${g[x+f]} = 0;`).join(`
`);let y="";return l<2&&a>0?y="coords":y=t.shapeInfo.logicalShape.map((x,w)=>`coords.${g[w+f]}`).join(", "),`
    float ${s}() {
      ${c} coords = getOutputCoords();
      ${p}
      return get${r}(${y});
    }
  `}function Kt(t){if(t<=1)return"int";if(t===2)return"ivec2";if(t===3)return"ivec3";if(t===4)return"ivec4";if(t===5)return"ivec5";if(t===6)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function PC(t,e,n){const{newShape:r,keptDims:s}=Cl(e),o=e.length,i=t&&o===3&&e[0]===1,a=i?e.slice(1):r,l=!t&&o>1&&!Vt(e,n)&&r.length<o||i;return{useSqueezeShape:l,uniformShape:l?a:e,keptDims:s}}function Rd(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function _d(t,e){return e.map(n=>t[n]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Foe(t,e,n,r){const s=n.map((d,f)=>{const p={logicalShape:d.shape,texShape:d.isUniform?null:d.texData.texShape,isUniform:d.isUniform,isPacked:d.isUniform?!1:d.texData.isPacked,flatOffset:null};return d.texData!=null&&d.texData.slice!=null&&d.texData.slice.flatOffset>0&&(p.flatOffset=d.texData.slice.flatOffset),{name:e.variableNames[f],shapeInfo:p}}),o=s.map(d=>d.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=eoe(s,i,e),l=Ese(t.gl,a),c=t.createProgram(l);return se().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:o,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(t.buildVao(c),Object.assign({program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:o,outShapeInfo:i},CO(t,e,c)))}function CO(t,e,n){const r=[],s=[];let o,i,a,l=null,c=null;c=t.getUniformLocation(n,"NAN",!1),se().getNumber("WEBGL_VERSION")===1&&(l=t.getUniformLocation(n,"INFINITY",!1));const d=!1;for(const f of e.variableNames){const p={name:f,uniform:t.getUniformLocation(n,f,d),offset:t.getUniformLocation(n,`offset${f}`,d)};e.enableShapeUniforms&&(p.shape=t.getUniformLocation(n,`${f}Shape`,d),p.texShape=t.getUniformLocation(n,`${f}TexShape`,d)),r.push(p)}if(e.enableShapeUniforms&&(o=t.getUniformLocation(n,"outShape",d),a=t.getUniformLocation(n,"outShapeStrides",d),i=t.getUniformLocation(n,"outTexShape",d)),e.customUniforms)for(const f of e.customUniforms)s.push(t.getUniformLocation(n,f.name,d));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:c,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:i}}function U3(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((n,r)=>{const s=n.logicalShape,o=e[r],i=o.shape;if(!Vt(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(n.isUniform&&o.isUniform)return;const a=n.texShape,l=o.isUniform?null:o.texData.texShape;if(!Vt(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function Loe(t,e,n,r,s){e.program.enableShapeUniforms||(U3(e.inShapeInfos,n),U3([e.outShapeInfo],[r]));const o=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(o.texture,i[0],i[1]):t.setOutputMatrixTexture(o.texture,i[0],i[1]),t.setProgram(e.webGLProgram),t.bindVertexArray(e.webGLProgram.vao),se().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&t.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&t.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<n.length;++l){const c=n[l],{uniform:d,offset:f,shape:p,texShape:g}=e.variablesLocations[l];if(p){const{uniformShape:y}=PC(e.program.packedInputs,c.shape,c.texData.texShape);switch(y.length){case 1:t.gl.uniform1iv(p,new Int32Array(y));break;case 2:t.gl.uniform2iv(p,new Int32Array(y));break;case 3:t.gl.uniform3iv(p,new Int32Array(y));break;case 4:t.gl.uniform4iv(p,new Int32Array(y));break}}if(g&&t.gl.uniform2i(g,c.texData.texShape[0],c.texData.texShape[1]),d!=null){if(c.isUniform){if(pe(c.shape)<2)t.gl.uniform1f(d,c.uniformValues[0]);else{let y=c.uniformValues;y instanceof Float32Array||(y=new Float32Array(y)),t.gl.uniform1fv(d,y)}continue}c.texData.slice!=null&&f!=null&&t.gl.uniform1i(f,c.texData.slice.flatOffset),t.setInputMatrixTexture(c.texData.texture.texture,d,l)}}const a=e.outShapeLocation;if(a)switch(r.shape.length){case 1:t.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:t.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:t.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:t.gl.uniform4iv(a,new Int32Array(r.shape));break}if(e.outShapeStridesLocation){const l=gn(r.shape);switch(r.shape.length){case 2:t.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:t.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:t.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&t.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&s)for(let l=0;l<e.program.customUniforms.length;++l){const c=e.program.customUniforms[l],d=e.customUniformLocations[l],f=s[l];if(c.type==="float")t.gl.uniform1fv(d,f);else if(c.type==="vec2")t.gl.uniform2fv(d,f);else if(c.type==="vec3")t.gl.uniform3fv(d,f);else if(c.type==="vec4")t.gl.uniform4fv(d,f);else if(c.type==="int")t.gl.uniform1iv(d,f);else if(c.type==="ivec2")t.gl.uniform2iv(d,f);else if(c.type==="ivec3")t.gl.uniform3iv(d,f);else if(c.type==="ivec4")t.gl.uniform4iv(d,f);else throw Error(`uniform type ${c.type} is not supported yet.`)}t.executeProgram()}function zoe(t,e,n){let r="";e.concat(n).forEach(i=>{const a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!i.isUniform){const l=i.texData.texShape,{useSqueezeShape:c,uniformShape:d,keptDims:f}=PC(t.packedInputs,i.shape,l);let p="",g="",y="";if(d.length===1&&t.packedInputs){const _=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];p=`${_[0]>1}_${_[1]>1}`}else if(d.length===2&&!t.packedInputs)g=`${d[0]>1}_${d[1]>1}`;else if(d.length>2&&!t.packedInputs){const _=gn(d);y=`${_[0]===l[1]}_${_[_.length-1]===l[1]}`}const x=i.shape.length,w=d.length===2&&Vt(i.shape,l),S=pe(i.shape)===1,$=cd(i.shape,n.shape),I=!t.packedInputs&&x===n.shape.length&&Vt(l,n.texData.texShape),R=t.packedInputs||d.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${x}_${I}_${c?f:""}_${d.length}_${S}_${$}_${w}_${p}_${g}_${y}_${R}_${a}`}else{const l=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${l}_${a}`}});const s=t.userCode;let o=t.constructor.name;return o+="_"+r+"_"+s+`${se().getNumber("WEBGL_VERSION")}`,o}function dr(t){return se().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Boe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Tf.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Rr();this.outputShape=e,this.enableShapeUniforms=dr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?vy(["r","c","d"],e):Wu(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Moe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Tf.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Rr();this.outputShape=e,this.enableShapeUniforms=dr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?vy(["r","c","d"],e):Wu(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Voe{constructor(e){this.variableNames=["A"],this.outTexUsage=Ps.DOWNLOAD;const n=Rr();this.outputShape=e,this.userCode=`
      ${vO}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Woe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Ps.DOWNLOAD;const n=Rr();this.outputShape=e,this.userCode=`
      ${vO}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uoe={R:0,G:1,B:2,A:3};class j3{constructor(e,n=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Rr();this.outputShape=e,this.enableShapeUniforms=dr(this.outputShape.length);let o="result";n&&(o="floor(result * 255. + 0.5)");let i="";for(let a=0;a<r.length;a++){const l=r[a];i+=`
          if(offset == ${a}) {
            result = values[${Uoe[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?_C():RC(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${s.texture2D}(A, uv);
          ${i}
        }
        ${s.output} = vec4(${o}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class joe{constructor(e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Rr();this.outputShape=e,this.enableShapeUniforms=dr(this.outputShape.length);let s="",o="result";n&&(o="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){const l=i*2+a;s+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?_C():RC(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${s}

          ${r.output} = ${o};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Goe(t){const e=Rr(),n=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return Nse(t,n)}function Hoe(t){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Ase(t,e)}function Koe(t){const e=new Uint16Array([0,1,2,2,1,3]);return Dse(t,e)}function tp(t,e,n,r,s,o){Fse(e,n);const i=Ose(t),a=t.TEXTURE_2D;return Oe(t,()=>t.bindTexture(a,i)),Oe(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),Oe(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),Oe(t,()=>t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.NEAREST)),Oe(t,()=>t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.NEAREST)),se().getNumber("WEBGL_VERSION")===1?Oe(t,()=>t.texImage2D(a,0,r,e,n,0,s,o,null)):Oe(t,()=>t.texStorage2D(a,1,r,e,n)),Oe(t,()=>t.bindTexture(t.TEXTURE_2D,null)),{texture:i,texShape:[n,e]}}function $O(t){return t.internalFormatFloat}function Xoe(t,e,n,r){const[s,o]=Jf(e,n);return tp(t,s,o,$O(r),r.textureFormatFloat,t.FLOAT)}function kO(t){return t.internalFormatHalfFloat}function qoe(t,e,n,r){const[s,o]=Jf(e,n);return tp(t,s,o,kO(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function TO(t){return t.downloadTextureFormat}function Yoe(t,e,n,r){const[s,o]=Jf(e,n);return tp(t,s,o,TO(r),t.RGBA,t.UNSIGNED_BYTE)}function IO(t){return t.internalFormatPackedFloat}function Qoe(t,e,n,r){const[s,o]=Id(e,n);return tp(t,s,o,IO(r),t.RGBA,t.FLOAT)}function NO(t){return t.internalFormatPackedHalfFloat}function Zoe(t,e,n,r){const[s,o]=Id(e,n);return tp(t,s,o,NO(r),t.RGBA,r.textureTypeHalfFloat)}function Joe(t,e,n){return Oe(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),M3(t,e,"clipSpacePos",n,3,20,0)&&M3(t,e,"uv",n,2,20,12)}function eie(t,e,n,r,s,o){Oe(t,()=>t.bindTexture(t.TEXTURE_2D,e));let i,a,l;s instanceof Uint8Array?(i=new Uint8Array(n*r*4),a=t.UNSIGNED_BYTE,l=t.RGBA):(i=new Float32Array(n*r*4),a=t.FLOAT,l=o.internalFormatPackedFloat),i.set(s),se().getNumber("WEBGL_VERSION")===2?Oe(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n,r,t.RGBA,a,i)):Oe(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,n,r,0,t.RGBA,a,i)),Oe(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function tie(t,e,n){Oe(t,()=>t.bindTexture(t.TEXTURE_2D,e)),n.data instanceof Uint8Array?se().getNumber("WEBGL_VERSION")===2?Oe(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n.width,n.height,t.RGBA,t.UNSIGNED_BYTE,n.data)):Oe(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data)):se().getNumber("WEBGL_VERSION")===2?Oe(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,n)):Oe(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),Oe(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function nie(t,e,n,r){const s=t.createBuffer();Oe(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,s));const a=4*4*e*n;return Oe(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,a,t.STREAM_READ)),Oe(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0)),Oe(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),s}function rie(t,e,n){const r=t,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function sie(t,e,n,r){const[s,o]=Jf(e,n),i=4,a=new Uint8Array(wse(e*n,i));return Oe(t,()=>t.readPixels(0,0,s,o,r.downloadTextureFormat,t.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function oie(t,e,n,r,s,o,i,a){const l=t,c=new Float32Array(Sse(o,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function iie(t,e,n){const r=new Float32Array(e*n*4);return Oe(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,r)),r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ex{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const n=se().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,xse(n,e)):this.gl=zo(n),e=this.gl,se().getNumber("WEBGL_VERSION")===2){const o=e;this.createVertexArray=()=>Oe(o,()=>o.createVertexArray()),this.bindVertexArray=i=>Oe(o,()=>o.bindVertexArray(i)),this.deleteVertexArray=i=>Oe(o,()=>o.deleteVertexArray(i)),this.getVertexArray=()=>Oe(o,()=>o.getParameter(o.VERTEX_ARRAY_BINDING))}else if(e!=null){const o=e.getExtension("OES_vertex_array_object");if(o==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Oe(e,()=>o.createVertexArrayOES()),this.bindVertexArray=i=>Oe(e,()=>o.bindVertexArrayOES(i)),this.deleteVertexArray=i=>Oe(e,()=>o.deleteVertexArrayOES(i)),this.getVertexArray=()=>Oe(e,()=>e.getParameter(o.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),se().getNumber("WEBGL_VERSION")===1){const o="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=Sm(this.gl,o),io(this.gl,i))this.textureHalfFloatExtension=Sm(this.gl,i);else if(se().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),io(this.gl,s))this.colorBufferHalfFloatExtension=Sm(this.gl,s);else if(se().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",io(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(io(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=Hoe(this.gl),this.indexBuffer=Koe(this.gl),this.framebuffer=Lse(this.gl),this.textureConfig=EC(this.gl,this.textureHalfFloatExtension)}get debug(){return se().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Oe(e,()=>e.finish()),Oe(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Oe(e,()=>e.deleteFramebuffer(this.framebuffer)),Oe(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Oe(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Oe(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,n){return this.throwIfDisposed(),Xoe(this.gl,e,n,this.textureConfig)}createFloat16MatrixTexture(e,n){return this.throwIfDisposed(),qoe(this.gl,e,n,this.textureConfig)}createUnsignedBytesMatrixTexture(e,n){return this.throwIfDisposed(),Yoe(this.gl,e,n,this.textureConfig)}uploadPixelDataToTexture(e,n){this.throwIfDisposed(),tie(this.gl,e,n)}uploadDenseMatrixToTexture(e,n,r,s){this.throwIfDisposed(),eie(this.gl,e,n,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(e,n){return this.throwIfDisposed(),Zoe(this.gl,e,n,this.textureConfig)}createPackedMatrixTexture(e,n){return this.throwIfDisposed(),Qoe(this.gl,e,n,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(V3(this.gl,this.framebuffer),this.outputTexture=null),Oe(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,n,r){return this.downloadMatrixDriver(e,()=>sie(this.gl,n,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,n,r,s,o,i){return oie(this.gl,e,n,r,s,o,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,n){return rie(this.gl,e,n)}createBufferFromTexture(e,n,r){this.bindTextureToFrameBuffer(e);const s=nie(this.gl,n,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let n,r;if(se().getBool("WEBGL_FENCE_API_ENABLED")){const s=e,o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{const i=s.clientWaitSync(o,0,0);return i===s.ALREADY_SIGNALED||i===s.CONDITION_SATISFIED},n=o}else se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(n,se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:n,isFencePassed:r}}downloadMatrixFromPackedTexture(e,n,r){return this.downloadMatrixDriver(e,()=>iie(this.gl,n,r))}createProgram(e){this.throwIfDisposed();const n=this.gl;this.vertexShader==null&&(this.vertexShader=Goe(n));const r=_se(n);Oe(n,()=>n.attachShader(r,this.vertexShader)),Oe(n,()=>n.attachShader(r,e)),Pse(n,r);const s=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&Y1(n,s),s}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const n=this.gl;Oe(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),Joe(n,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Oe(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Y1(this.gl,this.program),Oe(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,n,r=!0){return this.throwIfDisposed(),r?Bse(this.gl,e,n):Mse(this.gl,e,n)}getAttributeLocation(e,n){return this.throwIfDisposed(),Oe(this.gl,()=>this.gl.getAttribLocation(e,n))}getUniformLocationNoThrow(e,n){return this.throwIfDisposed(),this.gl.getUniformLocation(e,n)}setInputMatrixTexture(e,n,r){this.throwIfDisposed(),this.throwIfNoProgram(),Vse(this.gl,e,n,r)}setOutputMatrixTexture(e,n,r){this.setOutputMatrixTextureDriver(e,r,n)}setOutputPackedMatrixTexture(e,n,r){this.throwIfDisposed();const[s,o]=Id(n,r);this.setOutputMatrixTextureDriver(e,s,o)}setOutputMatrixWriteRegion(e,n,r,s){this.setOutputMatrixWriteRegionDriver(r,e,s,n)}setOutputPackedMatrixWriteRegion(e,n,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Y1(this.gl,this.program),Cm(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const n=this.getVertexArray();console.assert(n===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Oe(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Oe(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Sm(this.gl,se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,o),o}const e=this.getQueryTimerExtensionWebGL1(),n=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,n),n}endQuery(){if(se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,r=this.getQueryTimerExtensionWebGL2();n.endQuery(r.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await d3(()=>this.disposed||this.isQueryAvailable(e,se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,n){if(n===0)return null;if(n===2){const r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,n){if(n===0)return!0;if(n===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(e){return new Promise(n=>{this.addItemToPoll(()=>e.isFencePassed(),()=>n())})}pollItems(){const e=aie(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=e;++n){const{resolveFn:r}=this.itemsToPoll[n];r()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,n){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:n}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in se().platform&&(r=se().platform.setTimeoutCustom.bind(se().platform)),d3(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Q1(this.gl,e,this.framebuffer),this.debug&&Cm(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Q1(this.gl,this.outputTexture,this.framebuffer),this.debug&&Cm(this.gl)):V3(this.gl,this.framebuffer)}downloadMatrixDriver(e,n){this.bindTextureToFrameBuffer(e);const r=n();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,n,r){this.throwIfDisposed();const s=this.gl;Q1(s,e,this.framebuffer),this.debug&&Cm(s),this.outputTexture=e,Oe(s,()=>s.viewport(0,0,n,r)),Oe(s,()=>s.scissor(0,0,n,r))}setOutputMatrixWriteRegionDriver(e,n,r,s){this.throwIfDisposed(),Oe(this.gl,()=>this.gl.scissor(e,n,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function aie(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lie(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xr(t){return(e,n,r,s,o)=>{const i=ct(e,n),a=i.length,l=gn(i),c=pe(i),d=Si(o,c),f=e.length,p=n.length,g=gn(e),y=gn(n),x=cd(e,i),w=cd(n,i);if(x.length+w.length===0)for(let S=0;S<d.length;++S)d[S]=t(r[S%r.length],s[S%s.length]);else for(let S=0;S<d.length;++S){const $=tw(S,a,l),I=$.slice(-f);x.forEach(F=>I[F]=0);const R=rv(I,f,g),_=$.slice(-p);w.forEach(F=>_[F]=0);const O=rv(_,p,y);d[S]=t(r[R],s[O])}return[d,i]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uie(t,e,n,r){if(r==="int32"){const s=Int32Array.from(t);return[e,"int32",s]}if(r==="bool"){const s=iy([0],n),[o,i]=Xr((a,l)=>a!==l?1:0)(e,[],t,s,"bool");return[i,"bool",o]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cie=Xr((t,e)=>t+e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function die(t,e,n,r,s){const o=pe(r),i=ha(s,n);for(let a=0;a<t.length;a++){const l=t[a];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(o>0?i[l]+=e[a]:i[l]+=1)}return i}function hie(t,e,n,r=!1){const s=t.shape[0],o=t.shape[1],i=Wt([s,n],e.dtype);for(let a=0;a<s;a++)for(let l=0;l<o;l++){const c=t.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=n||(r?i.set(1,a,c):e.size>0?i.set(i.get(a,c)+e.get(a,l),a,c):i.set(i.get(a,c)+1,a,c))}return i}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fie=Xr((t,e)=>t&e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ka(t){return(e,n,r)=>{const s=En(n,e.length);for(let o=0;o<e.length;++o)s[o]=t(e[o],r);return s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pie=ka(t=>Math.ceil(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mie(t,e,n,r){const s=En(n,pe(e));if(r&&n!=="string"){let o=0;t.forEach(i=>{const a=pe(i.shape);s.set(i.vals,o),o+=a})}else{let o=0;t.forEach(i=>{const a=n==="string"?bl(i.vals):i.vals;let l=0;for(let c=0;c<i.shape[0];++c){const d=c*e[1]+o;for(let f=0;f<i.shape[1];++f)s[d+f]=a[l++]}o+=i.shape[1]})}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gie=Xr((t,e)=>t===e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yie=ka(t=>Math.exp(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xie=ka(t=>Math.expm1(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vie=ka(t=>Math.floor(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bie=Xr((t,e)=>Math.floor(t/e));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wie(t,e,n,r,s,o,i,a,l){const c=Wt([r,o],n);for(let d=0;d<r;d++){const f=[];let p=0;for(let g=0;g<s;g++){const y=t[d*s+g];p+=y*i[g],f.push(y)}if(p<0||p>=l/o)throw new Error(`Invalid indices: ${f} does not index into ${a}`);for(let g=0;g<o;g++)c.values[d*o+g]=e.get(...e.indexToLoc(p*o+g))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sie(t,e,n){const r=Wt(n,t.dtype);for(let s=0;s<r.size;++s){const i=r.indexToLoc(s).slice(),a=i[0],l=i[2],c=e.locToIndex([a,l]);i[2]=e.values[c];const d=t.locToIndex(i);0<=d&&d<t.values.length&&(r.values[s]=t.values[d])}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cie=Xr((t,e)=>t>e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ie=Xr((t,e)=>t>=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kie=Xr((t,e)=>t<e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tie=Xr((t,e)=>t<=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iie(t,e,n){const r=(e-t)/(n-1),s=ha(n,"float32");s[0]=t;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nie=ka(t=>Math.log(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eie(t,e,n,r){const s=Si(r,pe(n));for(let o=0;o<s.length;++o){const i=o*e;let a=t[i];for(let l=0;l<e;++l){const c=t[i+l];(Number.isNaN(c)||c>a)&&(a=c)}s[o]=a}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rie=Xr((t,e)=>Math.max(t,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ie=Xr((t,e)=>Math.min(t,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EO=Xr((t,e)=>t*e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pie(t,e,n){const r=kd(-1,n);return EO([],e,r,t,n)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aie=Xr((t,e)=>t!==e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Die(t,e,n,r,s){const o=e.length,i=pe(e),a=gn(e),l=gn(s),c=Si(n,pe(s));for(let d=0;d<i;++d){const f=tw(d,o,a),p=new Array(f.length);for(let y=0;y<p.length;y++)p[y]=f[r[y]];const g=rv(p,o,l);c[g]=t[d]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oie(t,e,n,r){const[s,o]=Ls(t,r),i=Gr(e,"int32"),a=ha(pe(s),i),l=pe(o);for(let c=0;c<a.length;++c){const d=c*l;let f=1;for(let p=0;p<l;++p)f*=n[d+p];a[c]=f}return{outVals:a,outShape:s,outDtype:i}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fie(t,e,n){t.forEach((r,s)=>{if(r<0||r>=n){const o=tw(s,e.length,gn(e)).join(",");throw new Error(`indices[${o}] = ${r} is not in [0, ${n})`)}})}function Lie(t,e){for(let n=0;n<t.length;++n){const r=t[n],s=n===t.length-1?e:t[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let o=1;o<r.length;++o)if(r[o-1]>r[o])throw new Error("Ragged splits must be sorted in ascending order")}}function zie(t,e,n,r){const s=[];let o=0;const i=e.length-1+n.length,a=new Array(i).fill(null).map(()=>[0]);Lie(n,r);let l=1;for(let c=0;c<e.length-1;++c){l*=e[c];const d=e[c+1];for(let f=1;f<l+1;++f)a[c].push(f*d)}for(let c=0;c<t.length;++c){let d=t[c],f=t[c]+1;for(let p=0;p<n.length;++p){const g=n[p],y=p+e.length-1;if(y>=0){const x=a[y],w=x[x.length-1]-g[d];for(let S=d;S<f;++S)a[y].push(g[S+1]+w)}d=g[d],f=g[f]}f!==d&&(s.push([d,f]),o+=f-d)}return{outSplits:a,valueSlices:s,numValues:o}}function Bie(t){const e=[];for(let n=0;n<t.length;++n){const r=t[n].length,s=En("int32",r);e.push(s),t[n].forEach((o,i)=>s[i]=o)}return e}function G3(t,e){const n=t.slice(0,e);for(;n.length<e;)n.push(1);for(let r=e;r<t.length;r++)n[e-1]*=t[r];return n}function Mie(t,e,n,r,s,o){const i=G3(e,2)[1],a=G3(o,2)[1];let l=0;for(const c of n)for(let d=c[0];d<c[1];++d){for(let f=0;f<r;++f)s[l*a+f]=t[d*i+f];++l}}function Vie(t,e,n,r,s){const o=e.slice();o[0]=s;const i=En(n,pe(o)),a=t.length,l=a===0?0:a/e[0];return Mie(t,e,r,l,i,o),[i,o]}function Wie(t,e,n,r,s,o,i,a){if(t.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(Fie(o,i,l),r.length===0)throw new Error("params.rank must be nonzero");const c=r[0],{outSplits:d,valueSlices:f,numValues:p}=zie(o,i,t,c),g=Bie(d),y=Vie(n,r,s,f,p);return[g,y[0],y[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H3=2147483647;function Uie(t,e,n,r,s,o,i){if(e.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,l=s.length===0,c=i.length===0,d=[];a||d.push(e[0]),l||d.push(s[0]),c||d.push(i[0]);for(let w=1;w<d.length;++w)if(d[w]!==d[w-1])throw new Error("starts, limits, and deltas must have the same shape");const f=d.length===0?1:d[0],p=En("int32",f+1);p[0]=0;for(let w=0;w<f;++w){const S=a?t[0]:t[w],$=l?r[0]:r[w],I=c?o[0]:o[w];if(I===0)throw new Error("Requires delta != 0");let R;if(I>0&&$<S||I<0&&$>S)R=0;else if(R=Math.ceil(Math.abs(($-S)/I)),R>H3)throw new Error(`Requires ((limit - start) / delta) <= ${H3}`);p[w+1]=p[w]+R}const g=p[f],y=En(n,g);let x=0;for(let w=0;w<f;++w){const S=p[w+1]-p[w];let $=a?t[0]:t[w];const I=c?o[0]:o[w];for(let R=0;R<S;++R)y[x++]=$,$+=I}return[p,y]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var eo=Oo;class _g{constructor(e,n,r,s,o,i,a,l,c,d){this.shape=e,this.shapeShape=n,this.values=r,this.valuesShape=s,this.valuesDType=o,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=nO(d),this.raggedRank=rO(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===eo.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===eo.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const n=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case eo.VALUE_ROWIDS:return _g.getMaxWidthValueRowID(n);case eo.ROW_SPLITS:return _g.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${eo[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const n=e.length;if(n===0||n===1)return 0;let r=0;for(let s=0;s<n-1;++s){const o=e[s+1]-e[s];o>r&&(r=o)}return r}static getMaxWidthValueRowID(e){const n=e.length;if(n===0)return 0;let r=0,s=e[0],o=0;for(let i=1;i<n;++i){const a=e[i];a!==s&&(s=a,o=Math.max(i-r,o),r=i)}return Math.max(n-r,o)}tensorShapeFromTensor(e,n,r=!0){if(n.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return X3(e,r)}calculateOutputSize(e){const n=this.valuesShape,r=this.defaultValueShape;sO(r,n);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=tO(this.raggedRank,s,n);i[0]<0&&(i[0]=e);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(e,n,r){const s=Math.min(e,r),o=[];let i=0;for(let a=0;a<s;++a,i+=n)o.push(i);for(let a=s;a<e;++a)o.push(-1);return z(o.length===e,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(e,n,r,s){const o=e.length,i=[];for(let a=0;a<o-1;++a){const l=e[a+1]-e[a];let c=Math.min(s,l),d=n[a];d===-1&&(c=0);for(let f=0;f<c;++f)i.push(d),d+=r;for(let f=0;f<l-c;++f)i.push(-1)}if(o>0&&i.length!==e[o-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(e,n,r,s){const o=e.length,i=[];if(o===0)return[];let a=0,l=e[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let c=n[l];i.push(c);for(let d=1;d<o;++d){const f=e[d];if(f===l)c>=0&&(++a,a<s?c+=r:c=-1);else{if(a=0,l=f,f>=n.length)throw new Error(`Got nextValueRowId=${f} which is not less than ${n.length}`);c=n[f]}i.push(c)}if(i.length!==e.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(e,n,r,s){const o=this.getRowPartitionTensor(e),i=this.getRowPartitionTypeByDimension(e);switch(i){case eo.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,n,r,s);case eo.ROW_SPLITS:if(o.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(o,n,r,s);default:throw new Error(`Unsupported partition type: ${eo[i]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const n=this.rowPartitionTypes[0];switch(n){case eo.FIRST_DIM_SIZE:return e[0];case eo.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case eo.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${eo[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const n=this.getFirstDimensionSize(),r=this.calculateOutputSize(n),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let l=s.length-2;l>=0;--l)s[l]=s[l+1]*r[l+1];const o=X3(r,!1),i=En(this.valuesDType,pe(o));if(s[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(n,s[0],r[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,s[c],r[c]);this.setOutput(this.raggedRank,l,i,o)}return[o,i]}setOutput(e,n,r,s){if(r.length===0)return;const o=this.values,i=r;let a=s.slice();a=a.slice(e+1);const l=pe(a),c=n.length;let d=this.defaultValue;if(d.length!==l&&d.length!==1){const y=this.defaultValueShape;nt(()=>{const x=ye(d,y);d=Qh(x,a).dataSync()})}let f=0,p=0,g=0;for(let y=0;y<=c;++y){let x=y<c?n[y]:-1;if(x===g){++g;continue}if(p<g){const w=o.subarray(f*l),S=i.subarray(p*l),$=(g-p)*l;K3(S,w,$)}if(y>=c){const w=r.length;x=Math.floor(w/l)}if(x>g)if(this.defaultValue.length===1)i.subarray(g*l,x*l).fill(this.defaultValue[0]),g=x;else for(;x>g;){const w=i.slice(g*l);K3(w,d,l),++g}x<0?(f=y+1,p=g):(f=y,p=g,g=p+1)}}}function K3(t,e,n){for(let r=0;r<n;r++)t[r]=e[r]}function X3(t,e){const n=[];for(let r of t){if(r<0){if(!e)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function jie(t,e,n,r,s,o,i,a,l,c){return new _g(t,e,n,r,s,o,i,a,l,c).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gie(t,e,n,r){const s=t===e,o=t<e&&n<0,i=e<t&&n>1;if(s||o||i)return ha(0,r);const a=Math.abs(Math.ceil((e-t)/n)),l=ha(a,r);e<t&&n===1&&(n=-1),l[0]=t;for(let c=1;c<l.length;c++)l[c]=l[c-1]+n;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hie=ka(t=>1/Math.sqrt(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kie(t,e,n,r,s,o,i,a,l,c){const d=[r/s,s],f=t.values,p=e.values;if(r===0)return Wt(n,e.dtype);const g=l instanceof ad?l:Wt(d,e.dtype);typeof l=="string"||typeof l=="number"?g.values.fill(l):typeof l=="boolean"&&g.values.fill(+l);for(let y=0;y<o;y++){const x=[];let w=0;for(let S=0;S<i;S++){const $=f[y*i+S];x.push($),w+=$*a[S]}if(w<0||w>=r/s)throw new Error(`Invalid indices: ${x} does not index into ${n}`);for(let S=0;S<s;S++)c?g.values[w*s+S]+=p[y*s+S]:g.values[w*s+S]=e.rank===0?p[0]:p[y*s+S]}return g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xie=ka(t=>1/(1+Math.exp(-t)));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qie(t,e,n,r,s){const o=sC(r,e,n),i=pe(n),a=gn(r);if(o){const f=oC(e,a);return s==="string"?t.slice(f,f+i):t.subarray(f,f+i)}const l=s==="string"?bl(t):t,c=Wt(r,s,l),d=Wt(n,s);for(let f=0;f<d.size;++f){const p=d.indexToLoc(f),g=p.map((y,x)=>y+e[x]);d.set(c.get(...g),...p)}return s==="string"?yO(d.values):d.values}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yie(t,e,n,r,s,o,i){const a=e[0],l=o[0],c=new Array(l),d=new Array(a),f=e[1];if(l===0){if(a!==0)throw new Error(oO(a));const w=En(n,0),S=En(s,0);return[w,[0,f],S,c,d]}let p=!0,g=0;const y=new Array(l).fill(0);for(let w=0;w<a;++w){const S=t[w*f];if(S<0)throw new Error(iO(w,S));if(S>=l)throw new Error(aO(w,S,l));++y[S],p=p&&S>=g,g=S}let x=!0;for(let w=0;w<l;++w){const S=y[w]===0;c[w]=S,x=x&&!S,y[w]=Math.max(y[w],1),w>0&&(y[w]+=y[w-1])}if(x&&p){const w=t,S=r;for(let $=0;$<a;++$)d[$]=$;return[w,[a,f],S,c,d]}else{const w=y[l-1],S=En(n,w*f),$=En(s,w),I=new Array(l).fill(0);for(let R=0;R<a;++R){const _=t[R*f],O=I[_],F=(_===0?0:y[_-1])+O;I[_]++;for(let B=0;B<f;++B)S[F*f+B]=t[R*f+B];$[F]=r[R],d[R]=F}for(let R=0;R<l;++R)if(I[R]===0){const O=R===0?0:y[R-1];S[O*f+0]=R;for(let F=1;F<f;++F)S[O*f+F]=0;$[O]=i}return[S,[w,f],$,c,d]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qie(t,e,n,r,s){const o=pe(r),i=e[0],a=s.length,l=[];let c=1,d=-1;for(let w=0;w<a;++w){const S=s[w];if(S===-1){if(d!==-1)throw new Error(lO(d,w));d=w,l.push(1)}else{if(S<0)throw new Error(uO(w,S));c*=S,l.push(S)}}if(d!==-1){if(c<=0)throw new Error(cO());const w=Math.trunc(o/c);if(c*w!==o)throw new Error(dO(r,l));l[d]=w}if(pe(l)!==o)throw new Error(hO(r,l));const p=r.length,g=[];if(p>0){g[p-1]=1;for(let w=p-2;w>=0;--w)g[w]=g[w+1]*r[w+1]}const y=[];if(a>0){y[a-1]=1;for(let w=a-2;w>=0;--w)y[w]=y[w+1]*l[w+1]}const x=En(n,i*a);for(let w=0;w<i;++w){let S=0;for(let $=0;$<p;++$)S+=t[w*p+$]*g[$];for(let $=0;$<a;++$)x[w*a+$]=Math.trunc(S/y[$]),S%=y[$]}return[x,[i,a],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zie(t,e,n,r,s,o=!1,i=0){const a=r.length,l=[e[0],t.length/e[0]],c=l[1],f=a>0?s[a-1]+1:0;if(f<0)throw new Error(bv());const p=e.slice();p[0]=f;const g=p.reduce((I,R)=>I*R,1),y=En(n,g);if(a===0)return f>0&&y.fill(i),[y,p];if(f<=0)throw new Error(bv());let x=0,w=1,S=0,$=s[x];for(;;){let I=0;if(w<a){if(I=s[w],$===I){++w;continue}if($>=I)throw new Error(fO())}if($<0||$>=f)throw new Error(pO($,f));$>S&&y.fill(i,S*c,$*c);for(let R=x;R<w;++R){const _=r[R];if(_<0||_>=l[0])throw new Error(mO(R,r[R],l[0]));for(let O=0;O<c;O++)y[$*c+O]+=t[_*c+O]}if(o)for(let R=0;R<c;R++)y[$*c+R]/=w-x;if(x=w,++w,S=$+1,$=I,w>a)break}return S<f&&y.fill(i,S*c,f*c),[y,p]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jie=ka(t=>Math.sqrt(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eae=Xr((t,e)=>{const n=t-e;return n*n});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tae=ka((t,e)=>{const{pattern:n,replaceGlobal:r,rewrite:s}=e;return t.replace(new RegExp(n,r?"g":""),s)});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nae(t,e,n,r){const s=Wt(t,e.dtype);for(let o=0;o<s.size;o++){const i=s.indexToLoc(o),a=new Array(i.length);for(let l=0;l<a.length;l++)a[l]=i[l]*n[l]+r[l];s.set(e.get(...a),...i)}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rae{constructor(e,n,r,s,o,i){this.separator=hl(e),this.nGramWidths=n,this.leftPad=hl(r),this.rightPad=hl(s),this.padWidth=o,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,n){const r=this.getPadWidth(n);return Math.max(0,e+2*r-n+1)}createNGrams(e,n,r,s,o,i){for(let a=0;a<o;++a){const l=this.getPadWidth(i),c=Math.max(0,l-a),d=Math.max(0,l-(o-(a+1))),f=i-(c+d),p=n+(c>0?0:a-l);let g=0;g+=c*this.leftPad.length;for(let $=0;$<f;++$)g+=e[p+$].length;g+=d*this.rightPad.length;const y=c+d+f-1;g+=y*this.separator.length,r[s+a]=new Uint8Array(g);const x=r[s+a];let w=0;const S=$=>$.forEach(I=>x[w++]=I);for(let $=0;$<c;++$)S(this.leftPad),S(this.separator);for(let $=0;$<f-1;++$)S(e[p+$]),S(this.separator);if(f>0){S(e[p+f-1]);for(let $=0;$<d;++$)S(this.separator),S(this.rightPad)}else{for(let $=0;$<d-1;++$)S(this.rightPad),S(this.separator);S(this.rightPad)}}}compute(e,n){const r=e.length,s=n.length;if(s>0){let l=n[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<s;++c){let d=n[c]>=l;if(d=d&&n[c]<=r,!d)throw new Error(`Invalid split value ${n[c]}, must be in [${l}, ${r}]`);l=n[c]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const o=s-1,i=En("int32",s);if(r===0||s===0){const l=new Array(r);for(let c=0;c<=o;++c)i[c]=0;return[l,i]}i[0]=0;for(let l=1;l<=o;++l){const c=n[l]-n[l-1];let d=0;this.nGramWidths.forEach(f=>{d+=this.getNumNGrams(c,f)}),this.preserveShort&&c>0&&d===0&&(d=1),i[l]=i[l-1]+d}const a=new Array(i[o]);for(let l=0;l<o;++l){const c=n[l];let d=i[l];if(this.nGramWidths.forEach(f=>{const p=n[l+1]-n[l],g=this.getNumNGrams(p,f);this.createNGrams(e,c,a,d,g,f),d+=g}),this.preserveShort&&d===i[l]){const f=n[l+1]-n[l];if(f===0)continue;const p=f+2*this.padWidth;this.createNGrams(e,c,a,d,1,p)}}return[a,i]}}function sae(t,e,n,r,s,o,i,a){return new rae(n,r,s,o,i,a).compute(t,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oae(t,e,n,r){if(!t.length)return;if(e.length===0){for(let o=0;o<t.length;++o)r.push(t.subarray(o,o+1));return}if(e.length===1){const o=e[0];let i=t.indexOf(o);for(;i!==-1;){const a=t.subarray(0,i);(!n||a.length!==0)&&r.push(a),t=t.subarray(i+1),i=t.indexOf(o)}(!n||t.length!==0)&&r.push(t);return}let s=0;for(let o=0;o<t.length+1;o++)if(o===t.length||e.indexOf(t[o])!==-1){const i=t.subarray(s,o);(!n||i.length!==0)&&r.push(i),s=o+1}}function iae(t,e,n){const r=t.length,s=[];let o=0,i=0;const a=new Array(r);for(let p=0;p<r;++p){const g=s.length;oae(t[p],e,n,s);const y=s.length-g;a[p]=y,o+=y,i=Math.max(i,y)}const l=En("int32",o*2),c=new Array(o),d=[r,i];let f=0;for(let p=0;p<r;++p)for(let g=0;g<a[p];++g)l[f*2]=p,l[f*2+1]=g,c[f]=s[f],++f;return[l,c,d]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aae(t,e){const n=En("int32",t.length);for(let r=0;r<t.length;++r)n[r]=$X(t[r]).modulo(e).getLowBitsUnsigned();return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lae=Xr((t,e)=>t-e);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uae(t,e){const n=new Array(t.rank);for(let s=0;s<n.length;s++)n[s]=t.shape[s]*e[s];const r=Wt(n,t.dtype);for(let s=0;s<r.values.length;++s){const o=r.indexToLoc(s),i=new Array(t.rank);for(let l=0;l<i.length;l++)i[l]=o[l]%t.shape[l];const a=t.locToIndex(i);r.values[s]=t.values[a]}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fh=(t,e)=>{const n=e.value-t.value;return n===0?t.index-e.index:n};function RO(t,e,n=0,r=t.length-1){for(;r>n;){if(r-n>600){const a=r-n+1,l=e-n+1,c=Math.log(a),d=.5*Math.exp(2*c/3),f=.5*Math.sqrt(c*d*(a-d)/a)*Math.sign(l-a/2),p=Math.max(n,Math.floor(e-l*d/a+f)),g=Math.min(r,Math.floor(e+(a-l)*d/a+f));RO(t,e,p,g)}const s=t[e];let o=n,i=r;for(bh(t,n,e),Fh(t[r],s)>0&&bh(t,n,r);o<i;){for(bh(t,o,i),o++,i--;Fh(t[o],s)<0;)o=o+1;for(;Fh(t[i],s)>0;)i=i-1}Fh(t[n],s)===0?bh(t,n,i):(i=i+1,bh(t,i,r)),i<=e&&(n=i+1),e<=i&&(r=i-1)}}function cae(t,e,n,r,s){const o=e[e.length-1],[i,a]=[t.length/o,o],l=Si(n,i*r),c=Si("int32",i*r);for(let f=0;f<i;f++){const p=f*a,g=t.subarray(p,p+a);let y=new Array(g.length);g.forEach(($,I)=>y[I]={value:$,index:I}),r<y.length&&(RO(y,r),y=y.slice(0,r)),s&&y.sort(Fh);const x=f*r,w=l.subarray(x,x+r),S=c.subarray(x,x+r);for(let $=0;$<r;$++)w[$]=y[$].value,S[$]=y[$].index}const d=e.slice();return d[d.length-1]=r,[Wt(d,n,l),Wt(d,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dae(t,e,n,r){const s=nn(e,n)[0],o=[1,n[0],1];for(let y=0;y<s;y++)o[0]*=n[y];o[1]=n[s];for(let y=s+1;y<n.length;y++)o[2]*=n[y];const i=new Map,a=new Int32Array(n[s]),l=new ad(o,r,t),c=[],d=o[0]===1&&o[2]===1;for(let y=0;y<n[s];y++){let x;if(d)x=t[y].toString();else{const S=[];for(let $=0;$<o[0];$++)for(let I=0;I<o[2];I++)S.push(l.get($,y,I));x=S.join(",")}const w=i.get(x);if(w!=null)a[y]=w;else{const S=i.size;i.set(x,S),a[y]=S,c.push(y)}}const f=o.slice();f[1]=i.size;const p=new ad(f,r);c.forEach((y,x)=>{for(let w=0;w<o[0];w++)for(let S=0;S<o[2];S++)p.set(l.get(w,y,S),w,x,S)});const g=n.slice();return g[s]=f[1],{outputValues:p.values,outputShape:g,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _O=Object.freeze(Object.defineProperty({__proto__:null,addImpl:cie,bincountImpl:die,bincountReduceImpl:hie,bitwiseAndImpl:fie,castImpl:uie,ceilImpl:pie,concatImpl:mie,equalImpl:gie,expImpl:yie,expm1Impl:xie,floorDivImpl:bie,floorImpl:vie,gatherNdImpl:wie,gatherV2Impl:Sie,greaterEqualImpl:$ie,greaterImpl:Cie,lessEqualImpl:Tie,lessImpl:kie,linSpaceImpl:Iie,logImpl:Nie,maxImpl:Eie,maximumImpl:Rie,minimumImpl:_ie,multiplyImpl:EO,negImpl:Pie,notEqualImpl:Aie,prodImpl:Oie,raggedGatherImpl:Wie,raggedRangeImpl:Uie,raggedTensorToTensorImpl:jie,rangeImpl:Gie,rsqrtImpl:Hie,scatterImpl:Kie,sigmoidImpl:Xie,simpleAbsImpl:lie,sliceImpl:qie,sparseFillEmptyRowsImpl:Yie,sparseReshapeImpl:Qie,sparseSegmentReductionImpl:Zie,sqrtImpl:Jie,squaredDifferenceImpl:eae,staticRegexReplaceImpl:tae,stridedSliceImpl:nae,stringNGramsImpl:sae,stringSplitImpl:iae,stringToHashBucketFastImpl:aae,subImpl:lae,tileImpl:uae,topKImpl:cae,transposeImpl:Die,uniqueImpl:dae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:hae,bincountImpl:PO,bincountReduceImpl:fae,bitwiseAndImpl:pae,castImpl:mae,ceilImpl:gae,concatImpl:yae,equalImpl:xae,expImpl:vae,expm1Impl:bae,floorImpl:wae,gatherNdImpl:Sae,gatherV2Impl:Cae,greaterImpl:$ae,greaterEqualImpl:kae,lessImpl:Tae,lessEqualImpl:Iae,linSpaceImpl:Nae,logImpl:Eae,maxImpl:Rae,maximumImpl:_ae,minimumImpl:Pae,multiplyImpl:Aae,negImpl:Dae,notEqualImpl:Oae,prodImpl:Fae,raggedGatherImpl:Lae,raggedRangeImpl:zae,raggedTensorToTensorImpl:Bae,rangeImpl:Mae,rsqrtImpl:Vae,scatterImpl:Wae,sigmoidImpl:Uae,simpleAbsImpl:AO,sliceImpl:jae,sparseFillEmptyRowsImpl:Gae,sparseReshapeImpl:Hae,sparseSegmentReductionImpl:DO,sqrtImpl:Kae,staticRegexReplaceImpl:Xae,stridedSliceImpl:qae,stringNGramsImpl:Yae,stringSplitImpl:Qae,stringToHashBucketFastImpl:Zae,subImpl:Jae,tileImpl:ele,topKImpl:tle,transposeImpl:AC,uniqueImpl:nle}=_O;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OO(t,e){return["x","y","z","w","u","v"].slice(0,e).map(n=>`${t}.${n}`)}function kr(t,e){return e===1?[t]:OO(t,e)}function rle(t,e){if(t===1)return"rc";let n="";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sle{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=dr(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const n=kr("rc",this.rank),r=Kt(this.rank),s=this.getOutOfBoundsCondition(n),o=this.getSetup(n),i=this.getOutput(n);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${s}) {
            setOutput(vec4(0));
          } else {
            ${o}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(e){const n=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let o=`${r===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)o=`${e[e.length-1-i]},`+o;n.push(o)}return n}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let n="";for(let r=this.rank-2;r<this.rank;r++)n+=`${e[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(n+="||");return n}getSetup(e){if(this.rank===1)return"";const n=e.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],s=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${n[0]};
      int c = ${n[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${s};
    `}getOutput(e){const n=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${n[0]}),
            cEdge ? 0. : getA(${n[1]}),
            rEdge ? 0. : getA(${n[2]}),
            rEdge || cEdge ? 0. : getA(${n[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FO{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=dr(this.outputShape.length);let r="";for(let s=0;s<4;s++){let o="thisRC = rc;";s%2===1&&(o+="thisRC.z += 1;"),s>1&&(o+="thisRC.y += 1;"),r+=`
        ${o}
        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s>0?"}":""}
      `}this.userCode=`
      ${ole(n,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?_C():RC(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}}function ole(t,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?Jse(["r","c","d"],"inputShape"):Wu(["r","c","d"],t)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ile=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,n,r){const s=Y3(n,r),o=Q3(e,s,r);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const i=q3(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const l=this.freeTextures[o].pop();return this.usedTextures[o].push(l),l}let a;return s===qn.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):s===qn.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):s===qn.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):s===qn.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):s===qn.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(e,n,r,s){if(this.freeTextures==null)return;const o=Y3(r,s),i=Q3(n,o,s);i in this.freeTextures||(this.freeTextures[i]=[]);const a=q3(n,o,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=se().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[i],d=c&&c.indexOf(e);if(d==null||d<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[d]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function ale(t,e){const n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;if(e===n.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function q3(t,e,n,r,s){const o=lle(e,r);let i;if(s){const[l,c]=Id(t[0],t[1]);i=l*c}else{const[l,c]=Jf(t[0],t[1]);i=l*c}const a=ale(n,o);return i*a}function lle(t,e){switch(t){case qn.PACKED_2X2_FLOAT32:return IO(e);case qn.PACKED_2X2_FLOAT16:return NO(e);case qn.UNPACKED_FLOAT32:return $O(e);case qn.UNPACKED_FLOAT16:return kO(e);case qn.PACKED_4X1_UNSIGNED_BYTE:return TO(e);default:throw new Error(`Unknown physical texture type ${t}`)}}function ule(t){return se().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?qn.PACKED_2X2_FLOAT32:qn.UNPACKED_FLOAT32:t?qn.PACKED_2X2_FLOAT16:qn.UNPACKED_FLOAT16}function Y3(t,e){if(t===Ps.UPLOAD)return qn.PACKED_2X2_FLOAT32;if(t===Ps.RENDER||t==null)return ule(e);if(t===Ps.DOWNLOAD||t===Ps.PIXELS)return qn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function Q3(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let fi=class{constructor(e,n){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=dr(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${n}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}};const mo="if (isnan(x)) return x;",cle="return x;",Z3="return abs(x);",dle="return (x >= 0.0) ? x : (exp(x) - 1.0);",hle=mo+`
  return (x < 0.0) ? 0.0 : x;
`,fle=mo+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,il="return x;",ple="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mle="return x;",gle=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,yle=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,xle=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,vle="return 1.0 / (1.0 + exp(-1.0 * x));";class ul{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=dr(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ble{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=dr(this.outputShape.length);const n=e.length,r=kr("rc",n),s=Kt(n),o=rle(n,r),i=r.slice(-2),a=n<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${o});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wle=AD,Sle=1e-7,Cle=1e-4,Tm={};function $le(t){return t in Tm||(Tm[t]={}),Tm[t]}const kle=se().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),Tle=600;function Ile(){return se().global.screen==null?1024:se().global.screen.height*se().global.screen.width*window.devicePixelRatio*Tle/1024/1024}class by extends Jb{nextDataId(){return by.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!se().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(e!=null){if(e instanceof ex)n=e;else{const r=zo(se().getNumber("WEBGL_VERSION"),e);n=new ex(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=zo(se().getNumber("WEBGL_VERSION"));n=new ex(r),this.binaryCache=$le(se().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new ile(this.gpgpu),this.numMBBeforeWarning=Ile(),this.texData=new UP(this,hs())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,n,r,s,o,i){const a=this.makeTensorInfo(n,r),l=this.texData.get(a.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[s,o]},l.texShape=[s,o];const c=$m(n),d=new j3(c,!1,i),f=this.runWebGLProgram(d,[a],r,[[s,o]]);return f.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(a),f.dataId}write(e,n,r){if((se().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||se().getBool("DEBUG"))&&this.checkNumericalProblems(e),r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:n,dtype:r,values:e,usage:Ps.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const n=this.texData.get(e);n.refCount++}decRef(e){if(this.texData.has(e)){const n=this.texData.get(e);n.refCount--}}move(e,n,r,s,o){if(se().getBool("DEBUG")&&this.checkNumericalProblems(n),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:s,values:n,usage:Ps.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const n=this.texData.get(e),{values:r,dtype:s,complexTensorInfos:o,slice:i,shape:a,isPacked:l}=n;if(i!=null){let p;l?p=new ul(a,il):p=new fi(a,il);const g=this.runWebGLProgram(p,[{dataId:e,shape:a,dtype:s}],s),y=this.readSync(g.dataId);return this.disposeIntermediateTensorInfo(g),y}if(r!=null)return this.convertAndCacheOnCPU(e);if(s==="string")return r;const c=this.activeTimers!=null;let d;c&&(d=Po());let f;if(s==="complex64"){const p=this.readSync(o.real.dataId),g=this.readSync(o.imag.dataId);f=kf(p,g)}else f=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=Po()-d),this.convertAndCacheOnCPU(e,f)}async read(e){if(this.pendingRead.has(e)){const y=this.pendingRead.get(e);return new Promise(x=>y.push(x))}const n=this.texData.get(e),{values:r,shape:s,slice:o,dtype:i,complexTensorInfos:a,isPacked:l}=n;if(o!=null){let y;l?y=new ul(s,il):y=new fi(s,il);const x=this.runWebGLProgram(y,[{dataId:e,shape:s,dtype:i}],i),w=this.read(x.dataId);return this.disposeIntermediateTensorInfo(x),w}if(r!=null)return this.convertAndCacheOnCPU(e);if(se().getBool("DEBUG")&&!se().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&se().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,d;if(i!=="complex64"&&se().get("WEBGL_BUFFER_SUPPORTED")){d=this.decode(e);const y=this.texData.get(d.dataId);c=this.gpgpu.createBufferFromTexture(y.texture.texture,...wm(s))}this.pendingRead.set(e,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let f;if(i==="complex64"){const y=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),x=y[0],w=y[1];f=kf(x,w)}else if(c==null)f=this.getValuesFromTexture(e);else{const y=pe(s);f=this.gpgpu.downloadFloat32MatrixFromBuffer(c,y)}if(d!=null&&this.disposeIntermediateTensorInfo(d),c!=null){const y=this.gpgpu.gl;Oe(y,()=>y.deleteBuffer(c))}const p=this.convertAndCacheOnCPU(e,f),g=this.pendingRead.get(e);return this.pendingRead.delete(e),g.forEach(y=>y(p)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&hs().removeDataId(e,this),this.pendingDeletes--),p}readToGPU(e,n={}){const r=this.texData.get(e),{values:s,shape:o,slice:i,dtype:a,isPacked:l,texture:c}=r;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let g;l?g=new ul(o,il):g=new fi(o,il);const y=this.runWebGLProgram(g,[{dataId:e,shape:o,dtype:a}],a),x=this.readToGPU(y,n);return this.disposeIntermediateTensorInfo(y),x}if(c==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(e,n.customTexShape),f=hs().makeTensorFromTensorInfo(d),p=this.texData.get(d.dataId);return Object.assign({tensorRef:f},p.texture)}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const r=n.map(s=>fa(s));return Wt(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Wt(e.shape,e.dtype,n)}checkNumericalProblems(e){if(e!=null)for(let n=0;n<e.length;n++){const r=e[n];if(!Tse(r))throw se().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:n,dtype:r,isPacked:s}=this.texData.get(e),o=pe(n);if(se().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const p=this.decode(e),g=this.texData.get(p.dataId),y=this.gpgpu.downloadMatrixFromPackedTexture(g.texture.texture,...wm(n)).subarray(0,o);return this.disposeIntermediateTensorInfo(p),y}const i=se().getBool("WEBGL_PACK")&&s===!0,a=i?$m(n):n,l=i?new Woe(a):new Voe(a),c=this.runWebGLProgram(l,[{shape:a,dtype:r,dataId:e}],"float32"),d=this.texData.get(c.dataId),f=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(c),f}timerAvailable(){return se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const n=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const o=pa(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=pa(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,s&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(o);a.kernelMs=jP(l),a.getExtraProfileInfo=()=>l.map((c,d)=>({name:i[d],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Po(),endMs:null}}endTimer(e){return se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Po(),e)}async getQueryTime(e){if(se().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const n=e;return n.endMs-n.startMs}disposeData(e,n=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(n?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!n&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return r!=null&&(this.disposeData(r.real.dataId,n),this.disposeData(r.imag.dataId,n)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:n,dtype:r,texShape:s,usage:o,isPacked:i,slice:a}=this.texData.get(e),l=a&&a.origDataId||e,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(n,s,o,i)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,n=kle){return se().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>this.texData.get(r.dataId).texture==null&&pe(r.shape)<n)}getGPGPUContext(){return this.gpgpu}where(e){Lo("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=e.dataSync();return wle(e.shape,n)}packedUnaryOp(e,n,r){const s=new ul(e.shape,n),o=this.compileAndRun(s,[e],r);return hs().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const s=AO(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if(se().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Z3,e.dtype);const n=new fi(e.shape,Z3),r=this.compileAndRun(n,[e]);return hs().makeTensorFromTensorInfo(r)}makeTensorInfo(e,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&Gf(r[0])){const o=r.map(i=>hl(i));s=this.write(o,e,n)}else s=this.write(r,e,n);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:n}}makeOutput(e,n,r){return hs().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,r),this)}unpackTensor(e){const n=new ble(e.shape);return this.runWebGLProgram(n,[e],e.dtype)}packTensor(e){const n=new sle(e.shape);return this.runWebGLProgram(n,[e],e.dtype,null,!0)}packedReshape(e,n){const r=[dd(e.shape),...hd(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},o=[dd(n),...hd(n)],i=new FO(o,r),a=!0,l=[r],c=this.runWebGLProgram(i,[s],e.dtype,l,a);return{dataId:c.dataId,shape:n,dtype:c.dtype}}decode(e,n){const r=this.texData.get(e),{isPacked:s,shape:o,dtype:i}=r;if(n!=null){const p=pe(o),g=n[0]*n[1]*4;z(p<=g,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=$m(o);let l;s?l=new Moe(a):l=new Boe(a);const c=!0,d=[n??wm(a)],f=this.runWebGLProgram(l,[{shape:a,dtype:i,dataId:e}],i,d,c,n);return{dtype:i,shape:o,dataId:f.dataId}}runWebGLProgram(e,n,r,s,o=!1,i){const a=this.makeTensorInfo(e.outputShape,r),l=this.texData.get(a.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===Tf.DENSE){const S=i??wm(e.outputShape);l.texShape=S.map($=>$*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),pe(a.shape)===0)return l.values=Si(a.dtype,0),a;const c=[],d=n.map(S=>{if(S.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let $=this.texData.get(S.dataId);if($.texture==null){if(!e.packedInputs&&pe(S.shape)<=se().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:S.shape,texData:null,isUniform:!0,uniformValues:$.values};e.packedInputs&&($.isPacked=!0,$.shape=S.shape)}if(this.uploadToGPU(S.dataId),!!$.isPacked!=!!e.packedInputs)S=$.isPacked?this.unpackTensor(S):this.packTensor(S),c.push(S),$=this.texData.get(S.dataId);else if($.isPacked&&!Rg($.shape,S.shape)){const I=S,R=S.shape;S.shape=$.shape,S=this.packedReshape(S,R),c.push(S),$=this.texData.get(S.dataId),I.shape=R}return{shape:S.shape,texData:$,isUniform:!1}});this.uploadToGPU(a.dataId);const f={shape:a.shape,texData:l,isUniform:!1},p=zoe(e,d,f),g=this.getAndSaveBinary(p,()=>Foe(this.gpgpu,e,d,f)),y=this.activeTimers!=null;let x;y&&(x=this.startTimer()),se().get("ENGINE_COMPILE_ONLY")||Loe(this.gpgpu,g,d,f,s),c.forEach(S=>this.disposeIntermediateTensorInfo(S)),y&&(x=this.endTimer(x),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(x)}));const w=se().getNumber("WEBGL_FLUSH_THRESHOLD");if(w>0){const S=Po();S-this.lastGlFlushTime>w&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=S)}if(!se().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&o===!1){const S=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),S}return a}compileAndRun(e,n,r,s,o=!1){return r=r||n[0].dtype,this.runWebGLProgram(e,n,r,s,o)}getAndSaveBinary(e,n){return e in this.binaryCache||(this.binaryCache[e]=n()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(se().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=nt(()=>{if(!se().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=se().getBool("DEBUG");se().set("DEBUG",!1);const n=this.abs(mt(1e-8)).dataSync()[0];if(se().set("DEBUG",e),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?Sle:Cle}uploadToGPU(e){const n=this.texData.get(e),{shape:r,dtype:s,values:o,texture:i,usage:a,isPacked:l}=n;if(i!=null)return;const c=this.activeTimers!=null;let d;c&&(d=Po());let f=n.texShape;if(f==null&&(f=jse(r,l),n.texShape=f),o!=null){const p=$m(r);let g,y=f[1],x=f[0];const w=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(l||!w)&&([y,x]=Id(f[0],f[1])),l?g=new joe(p,w):g=new j3(p,w);const S=w?[x,y]:f,$=this.makeTensorInfo(S,s),I=this.texData.get($.dataId);w?I.usage=Ps.PIXELS:I.usage=Ps.UPLOAD,I.texShape=S,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture($.dataId),y,x,o);const R=[[x,y]],O=this.runWebGLProgram(g,[$],s,R,!0),F=this.texData.get(O.dataId);n.texShape=F.texShape,n.isPacked=F.isPacked,n.usage=F.usage,se().get("ENGINE_COMPILE_ONLY")?this.disposeData(O.dataId):(n.texture=F.texture,n.values=null,this.texData.delete(O.dataId)),this.disposeIntermediateTensorInfo($),c&&(this.uploadWaitMs+=Po()-d)}else{const p=this.acquireTexture(f,a,s,l);n.texture=p}}convertAndCacheOnCPU(e,n){const r=this.texData.get(e),{dtype:s}=r;return n!=null&&(r.values=Nle(n,s)),r.values}acquireTexture(e,n,r,s){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,n,s)}computeBytes(e,n){return e[0]*e[1]*xg(n)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(n));return Promise.all(e)}else{for(const[,n]of Object.entries(this.binaryCache)){const r=new Promise(s=>{try{this.checkCompletion_(n),s(!0)}catch(o){throw o}});e.push(r)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await ise(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(xO(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:n,customUniformLocations:r,infLoc:s,nanLoc:o,outShapeLocation:i,outShapeStridesLocation:a,outTexShapeLocation:l}=CO(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=n,e.customUniformLocations=r,e.infLoc=s,e.nanLoc=o,e.outShapeLocation=i,e.outShapeStridesLocation=a,e.outTexShapeLocation=l}}createTensorFromGPUData(e,n,r){e.channels=e.channels||"RGBA";const{texture:s,height:o,width:i,channels:a}=e,l=hs().backend;if(!l.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=l.writeTexture(s,n,r,o,i,a);return hs().makeTensorFromDataId(c,n,r,l)}}by.nextDataId=0;function Nle(t,e){if(e==="float32"||e==="complex64")return t;if(e==="int32"||e==="bool"){const n=e==="int32"?new Int32Array(t.length):new Uint8Array(t.length);for(let r=0;r<n.length;++r)n[r]=Math.round(t[r]);return n}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */DA()&&LA("webgl",()=>new by,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DC=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;let Lu=class{constructor(e,n,r){this.variableNames=["A","B"],this.outputShape=ct(n,r),this.enableShapeUniforms=dr(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ju=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Pd{constructor(e,n,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=ct(n,r);const o=this.outputShape.length;this.enableShapeUniforms=dr(o);let i="";if(s)if(o===0||pe(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${Kt(o)} coords = getOutputCoords();
        `,o===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=kr("coords",o);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${l[o-2]} + 1) >= outShape[${o} - 2];
            bool nextColOutOfBounds =
              (${l[o-1]} + 1) >= outShape[${o} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${l[o-2]} + 1) >= ${this.outputShape[o-2]};
            bool nextColOutOfBounds =
              (${l[o-1]} + 1) >= ${this.outputShape[o-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gs(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const Ele={kernelName:ry,backendName:"webgl",kernelFunc:gs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Il(t){const{inputs:e,backend:n}=t,{real:r,imag:s}=e,o=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(o.dataId),a=gs({inputs:{x:r},backend:n}),l=gs({inputs:{x:s},backend:n});return i.complexTensorInfos={real:a,imag:l},o}const Rle={kernelName:$w,backendName:"webgl",kernelFunc:Il};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LO="return (a < 0.) ? b * a : a;",zO=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function _le(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{alpha:o}=r,i=n.makeTensorInfo([],"float32",kd(o,"float32")),a=se().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Pd(zO,s.shape,i.shape):new Lu(LO,s.shape,i.shape),l=n.runWebGLProgram(a,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),l}const Ple={kernelName:f2,backendName:"webgl",kernelFunc:_le};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BO="return (a < 0.) ? b * a : a;",MO=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Ale(t){const{inputs:e,backend:n}=t,{x:r,alpha:s}=e,o=se().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Pd(MO,r.shape,s.shape):new Lu(BO,r.shape,s.shape);return n.runWebGLProgram(o,[r,s],"float32")}const Dle={kernelName:j2,backendName:"webgl",kernelFunc:Ale};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ad="if (isnan(x)) return x;";function $t({opSnippet:t,packedOpSnippet:e,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:o})=>{const{x:i}=s,a=o,l=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&n!=null){const f=a.texData.get(i.dataId),p=n(f.values,l);return a.makeTensorInfo(i.shape,l,p)}const c=se().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let d;return c?d=new ul(i.shape,e):d=new fi(i.shape,t),a.runWebGLProgram(d,[i],l)}}function Zn({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}){return({inputs:i,backend:a})=>{const{a:l,b:c}=i,d=a;if(r&&l.dtype==="complex64"){const y=d.texData.get(l.dataId),x=d.texData.get(c.dataId),[w,S]=[[y.complexTensorInfos.real,x.complexTensorInfos.real],[y.complexTensorInfos.imag,x.complexTensorInfos.imag]].map(I=>{const[R,_]=I,O={dataId:R.dataId,dtype:R.dtype,shape:l.shape},F={dataId:_.dataId,dtype:_.dtype,shape:c.shape},B=new Lu(t,l.shape,c.shape);return d.runWebGLProgram(B,[O,F],Gr(R.dtype,_.dtype))}),$=Il({inputs:{real:w,imag:S},backend:d});return d.disposeIntermediateTensorInfo(w),d.disposeIntermediateTensorInfo(S),$}const f=o||Gr(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||d.shouldExecuteOnCPU([l,c]))&&s!=null){const y=d.texData.get(l.dataId).values,x=d.texData.get(c.dataId).values,w=l.dtype==="string"?bl(y):y,S=l.dtype==="string"?bl(x):x,[$,I]=s(l.shape,c.shape,w,S,f),R=d.makeTensorInfo(I,f),_=d.texData.get(R.dataId);return _.values=$,R}const p=se().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let g;return p?g=new Pd(e,l.shape,c.shape,n):g=new Lu(t,l.shape,c.shape),d.runWebGLProgram(g,[l,c],f)}}function If(t,e=!1){if(t==="linear")return e?mle:cle;if(t==="relu")return e?yle:hle;if(t==="elu")return e?gle:dle;if(t==="relu6")return e?xle:fle;if(t==="prelu")return e?MO:BO;if(t==="leakyrelu")return e?zO:LO;if(t==="sigmoid")return e?vle:ple;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let VO=class{constructor(e,n,r,s=!1,o=!1,i=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=dr(this.outputShape.length);const d=s?e[1]:e[2],f=Math.ceil(d/2),p=s?"i * 2, rc.y":"rc.y, i * 2",g=o?"rc.z, i * 2":"i * 2, rc.z",y=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],x=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let w="",S="";a&&(l?w=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:c?w=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:w=`vec4 activation(vec4 x) {
          ${a}
        }`,S="result = activation(result);");const $=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let I="rc.x",R="rc.x";e[0]<n[0]?I=`imod(rc.x, ${e[0]})`:n[0]<e[0]&&(R=`imod(rc.x, ${n[0]})`),this.userCode=`
      ${w}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${f}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${I};
        int batchB = ${R};
        for (int i = 0; i < ${f}; i++) {
          vec4 a = getMatrixA(batchA, ${p});
          vec4 b = getMatrixB(batchB, ${g});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${y[0]} * ${x[0]});
          result += (${y[1]} * ${x[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${$}

        ${S}

        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J3={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};let eN=class{constructor(e,n,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=ct(n,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tN="return a * b;";function OC(t){const{inputs:e,backend:n}=t,{a:r,b:s}=e,o=Gr(r.dtype,s.dtype);if(r.dtype==="complex64"){const a=n.texData.get(r.dataId),l=n.texData.get(s.dataId),c=new eN(J3.REAL,r.shape,s.shape),d=new eN(J3.IMAG,r.shape,s.shape),f=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],p=n.runWebGLProgram(c,f,"float32"),g=n.runWebGLProgram(d,f,"float32"),y=Il({inputs:{real:p,imag:g},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g),y}if(n.shouldExecuteOnCPU([r,s])){const a=n.texData.get(r.dataId),l=n.texData.get(s.dataId),[c,d]=Aae(r.shape,s.shape,a.values,l.values,o),f=n.makeTensorInfo(d,o),p=n.texData.get(f.dataId);return p.values=c,f}let i;return se().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Pd(tN,r.shape,s.shape):i=new Lu(tN,r.shape,s.shape),n.runWebGLProgram(i,[r,s],o)}const Ole={kernelName:D2,backendName:"webgl",kernelFunc:OC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fle(t,e,n){const r=[dd(t.shape),...hd(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},o=[dd(e),...hd(e)],i=new FO(o,r),a=!0,l=[r],c=n.runWebGLProgram(i,[s],t.dtype,l,a);return{dataId:c.dataId,shape:e,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{shape:o}=r,i=n,a=pe(s.shape),l=GP(o,a),c=pe(l);z(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const d=i.texData.get(s.dataId);return d.isPacked&&!Rg(s.shape,l)&&!(d.texture!==null&&Rg(d.shape,l))?Fle(s,l,i):(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype})}const Lle={kernelName:Y2,backendName:"webgl",kernelFunc:Pe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nN{constructor(e,n){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=e;this.outputShape=[s,i];const a=Math.floor(r/4)*4,l=r%4;let c="sumValue += dot(values, ones);";if(n!=null){const f=1/n;c=`sumValue += dot(values * ${id(f)?f.toPrecision(2):f}, ones);`}let d="";o%r>0&&(d=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let zle=class{constructor(e,n){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=e;this.outputShape=[s,i];let a="0.0",l="";n==="prod"?a="1.0":n==="min"?(a="1.0 / 1e-20",l="min"):n==="max"&&(a="-1.0 / 1e-20",l="max");let c=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="sum"?c="sumValue":n==="prod"?c="prodValue":n==="all"?c="allValue":n==="any"&&(c="anyValue");const d=Math.floor(r/4)*4,f=r%4;let p=`
      if (${n==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${n==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${n==="min"} || ${n==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,g="vec4";n==="all"?(a="1.0",p=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,g="bvec4"):n==="any"&&(a="0.0",p=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,g="bvec4");let y="";o%r>0&&(y=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${y}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${d};
        if (${f===1}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${f===2}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${f===3}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${p}
        }
        setOutput(${c});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ble(t){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const n=e.length?e[e.length-1].outSize:t[1],r=xy(n);e.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return e}function Gu(t,e,n,r){const s=Ble(t.shape);let o=t;for(let i=0;i<s.length;i++){const{inSize:a,windowSize:l,outSize:c}=s[i];let d,f;n==="mean"?d=i===0?new nN({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:c},a):new nN({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:c}):d=new zle({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:c},n),f=o,o=r.runWebGLProgram(d,[o],e),f.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(f)}return o}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Mle=class{constructor(e,n){this.variableNames=["A"];const r=new Array(e.length);for(let i=0;i<r.length;i++)r[i]=e[n[i]];this.outputShape=r,this.rank=r.length;const s=Kt(this.rank),o=Vle(n);this.userCode=`
    void main() {
      ${s} resRC = getOutputCoords();
      setOutput(getA(${o}));
    }
    `}};function Vle(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let s=0;s<t.length;s++)r[t[s]]=n[s];return r.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wle{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(e.length);for(let d=0;d<r.length;d++)r[d]=e[n[d]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=Kt(this.rank),o=OO("rc",this.rank),i=new Array(this.rank);for(let d=0;d<n.length;d++)i[n[d]]=o[d];const a=`vec2(${i.slice(-2).join()})`,l=`++${o[this.rank-1]} < ${r[this.rank-1]}`,c=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${o[this.rank-1]};
      if(++${o[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wy(t,e,n){const r=se().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Wle(t.shape,e):new Mle(t.shape,e);return n.runWebGLProgram(r,[t],t.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ule(t,e,n,r){const s=e,o=t.shape.length,i=nn(s,t.shape);let a=i;const l=ur(a,o),c=l!=null;let d=t;c&&(d=wy(t,l,r),a=cr(a.length,o)),bs("sum",a,o);const[f,p]=Ls(d.shape,a);let g=f;n&&(g=vs(f,i));const y=pe(p),w=pe(t.shape)/y,S=Pe({inputs:{x:d},attrs:{shape:[w,y]},backend:r}),$=ay(t.dtype),I=Gu(S,$,"sum",r),R=Pe({inputs:{x:I},attrs:{shape:g},backend:r});return r.disposeIntermediateTensorInfo(S),r.disposeIntermediateTensorInfo(I),c&&r.disposeIntermediateTensorInfo(d),R}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sy(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r;return Ule(s,o,i,n)}const jle={kernelName:mS,backendName:"webgl",kernelFunc:Sy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ir(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{perm:o}=r,i=n,a=s.shape.length,l=new Array(a);for(let d=0;d<l.length;d++)l[d]=s.shape[o[d]];let c;if(i.shouldExecuteOnCPU([s])){const f=i.texData.get(s.dataId).values,p=AC(f,s.shape,s.dtype,o,l);c=i.makeTensorInfo(l,s.dtype);const g=i.texData.get(c.dataId);g.values=p}else c=wy(s,o,i);return c}const Gle={kernelName:Yh,backendName:"webgl",kernelFunc:Ir};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WO=1e3;function Pg({a:t,b:e,transposeA:n,transposeB:r,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:l=null}){const c=t.shape.length,d=e.shape.length,f=n?t.shape[c-2]:t.shape[c-1],p=r?e.shape[d-1]:e.shape[d-2],g=n?t.shape[c-1]:t.shape[c-2],y=r?e.shape[d-2]:e.shape[d-1],x=t.shape.slice(0,-2),w=e.shape.slice(0,-2),S=pe(x),$=pe(w),R=ct(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([g,y]);z(f===p,()=>`Error in matMul: inner shapes (${f}) and (${p}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${r} must match.`);const _=n?[S,f,g]:[S,g,f],O=r?[$,y,p]:[$,p,y],F=Pe({inputs:{x:t},backend:s,attrs:{shape:_}}),B=Pe({inputs:{x:e},backend:s,attrs:{shape:O}}),M=[F,B],V=Math.max(S,$),P=n?F.shape[1]:F.shape[2],re=o!=null,ie=i!=null,me=l==="leakyrelu",ge=l!=null?If(l,!0):null,ve=re||ie||me||ge!=null;let $e;if((g===1||y===1)&&P>WO&&ve===!1){let xe=F,ae=B;n&&(xe=Ir({inputs:{x:F},backend:s,attrs:{perm:[0,2,1]}}),M.push(xe)),r&&(ae=Ir({inputs:{x:B},backend:s,attrs:{perm:[0,2,1]}}),M.push(ae));const q=y!==1,ue=y===1;let we=xe;q&&(we=Pe({inputs:{x:xe},backend:s,attrs:{shape:[V,P,1]}}),M.push(we));const Ge=y===1?2:1;let et=ae;ue&&(et=Pe({inputs:{x:ae},backend:s,attrs:{shape:[V,1,P]}}),M.push(et));const tt=OC({inputs:{a:we,b:et},backend:s});$e=Sy({inputs:{x:tt},backend:s,attrs:{axis:Ge,keepDims:!0}}),M.push(tt)}else{const xe=Gr(t.dtype,e.dtype),ae=new VO(_,O,[V,g,y],n,r,re,ge,ie,me),q=[F,B];if(o!=null&&q.push(o),ie&&q.push(i),me){const ue=s.makeTensorInfo([],"float32",kd(a,"float32"));q.push(ue),M.push(ue)}$e=s.runWebGLProgram(ae,q,xe)}const fe=Pe({inputs:{x:$e},backend:s,attrs:{shape:R}});M.push($e);for(const xe of M)s.disposeIntermediateTensorInfo(xe);return fe}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hle(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:o,bias:i,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:d,leakyreluAlpha:f}=r;return Pg({a:s,b:o,transposeA:l,transposeB:c,backend:n,bias:i,preluActivationWeights:a,leakyreluAlpha:f,activation:d})}const Kle={kernelName:bg,backendName:"webgl",kernelFunc:Hle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rN="return abs(x);";function Xle(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const o=n.texData.get(r.dataId),i=AO(o.values);return n.makeTensorInfo(r.shape,r.dtype,i)}let s;return se().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new ul(r.shape,rN):s=new fi(r.shape,rN),n.runWebGLProgram(s,[r],r.dtype)}const qle={kernelName:rw,backendName:"webgl",kernelFunc:Xle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yle=mo+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Qle=$t({opSnippet:Yle}),Zle={kernelName:sw,backendName:"webgl",kernelFunc:Qle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jle=mo+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,eue=$t({opSnippet:Jle}),tue={kernelName:ow,backendName:"webgl",kernelFunc:eue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sN="return a + b;",nue=Zn({opSnippet:sN,packedOpSnippet:sN,supportsComplex:!0,cpuKernelImpl:hae}),rue={kernelName:ty,backendName:"webgl",kernelFunc:nue};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sue{constructor(e,n){this.outputShape=[],this.outputShape=e,this.variableNames=n.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`float v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let oue=class{constructor(e,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=n.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`vec4 v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${s};
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jm(t){const{inputs:e,backend:n}=t,r=e;if(r.length===1)return gs({inputs:{x:r[0]},backend:n});if(r.length>se().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),c=Jm({inputs:r.slice(0,l),backend:n}),d=Jm({inputs:r.slice(l),backend:n});return Jm({inputs:[c,d],backend:n})}const s=r.map(l=>l.dtype).reduce((l,c)=>Gr(l,c)),o=r.map(l=>l.shape),a=se().getBool("WEBGL_PACK")?new oue(r[0].shape,o):new sue(r[0].shape,o);return n.runWebGLProgram(a,r,s)}const iue={kernelName:iw,backendName:"webgl",kernelFunc:Jm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aue(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,l=nn(o,s.shape);let c=l;const d=ur(c,a);let f=s;d!=null&&(f=Ir({inputs:{x:s},backend:n,attrs:{perm:d}}),c=cr(c.length,a)),bs("all",c,a);const[p,g]=Ls(f.shape,c),y=pe(g),x=Pe({inputs:{x:f},backend:n,attrs:{shape:[-1,y]}}),w=Gu(x,x.dtype,"all",n);let S;if(i){const $=vs(p,l);S=Pe({inputs:{x:w},backend:n,attrs:{shape:$}})}else S=Pe({inputs:{x:w},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),d!=null&&n.disposeIntermediateTensorInfo(f),S}const lue={kernelName:aw,backendName:"webgl",kernelFunc:aue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uue(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,l=nn(o,s.shape);let c=l;const d=ur(c,a);let f=s;d!=null&&(f=Ir({inputs:{x:s},backend:n,attrs:{perm:d}}),c=cr(c.length,a)),bs("any",c,a);const[p,g]=Ls(f.shape,c),y=pe(g),x=Pe({inputs:{x:f},backend:n,attrs:{shape:[-1,y]}}),w=Gu(x,x.dtype,"any",n);let S;if(i){const $=vs(p,l);S=Pe({inputs:{x:w},backend:n,attrs:{shape:$}})}else S=Pe({inputs:{x:w},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),d!=null&&n.disposeIntermediateTensorInfo(f),S}const cue={kernelName:lw,backendName:"webgl",kernelFunc:uue};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let due=class{constructor(e,n,r){this.variableNames=["A"];const{windowSize:s,batchSize:o,outSize:i}=e;r||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i];const a=n==="max"?">":"<",l=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hue{constructor(e,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,z(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const o=e[e.length-1],i=Math.ceil(o/n);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,c=Kt(l),d=kr("coords",l);let f,p;if(i===1){p=l+1;const B=Kt(p);f=`
        ${B} sourceLocR = ${B}(${d.join()}, 0);
        ++${d[l-1]};
        ${B} sourceLocG = ${B}(${d.join()}, 0);
        ++${d[l-2]};
        ${B} sourceLocA = ${B}(${d.join()}, 0);
        --${d[l-1]};
        ${B} sourceLocB = ${B}(${d.join()}, 0);
        --${d[l-2]};`}else p=l,f=`
        ${c} sourceLocR = coords;
        ++${d[l-1]};
        ${c} sourceLocG = coords;
        ++${d[l-2]};
        ${c} sourceLocA = coords;
        --${d[l-1]};
        ${c} sourceLocB = coords;
        --${d[l-2]};`;const g=["x","y","z","w","u","v"].slice(0,p),y="."+g[p-1],x=g.map(B=>"int "+B),w=kr("sourceLocR",p-1).concat("inIdx.r"),S=kr("sourceLocG",p-1).concat("inIdx.g"),$=kr("sourceLocB",p-1).concat("inIdx.b"),I=kr("sourceLocA",p-1).concat("inIdx.a"),R=r==="max"?"greaterThan":"lessThan",_=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${S.join()}),
                             getBestIndicesAChannel(${$.join()}),
                             getBestIndicesAChannel(${I.join()})));`,O=`vec4(
            getAChannel(${w.join()}),
            hasNextCol ? getAChannel(${S.join()}) : 0.,
            hasNextRow ? getAChannel(${$.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${I.join()}) : 0.)`,F=s?"":`
      float getBestIndicesAChannel(${x.join()}) {
        return getChannel(getBestIndicesA(${g.join()}),
                                          vec2(${g.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${x.join()}) {
        return getChannel(getA(${g.join()}),
                               vec2(${g.slice(-2).join()}));
      }
      ${F}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${d[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${d[l-2]} < ${a[l-2]-1};
        ${f}
        ivec4 srcIdx = ivec4(sourceLocR${y}, sourceLocG${y},
          sourceLocB${y}, sourceLocA${y}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${O};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${_}
          vec4 candidate = ${O};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${R}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UO(t,e,n,r=null){let s=e.shape[0],o=e.shape[1];r!=null&&(s=r.shape[0],o=r.shape[1]);const i=xy(o),a={windowSize:i,inSize:o,batchSize:s,outSize:Math.ceil(o/i)},l=new due(a,n,r==null),c=[e];r!=null&&c.push(r);const d=t.runWebGLProgram(l,c,"int32");if(d.shape[1]===1)return d;const f=UO(t,e,n,d);return t.disposeIntermediateTensorInfo(d),f}function jO(t,e,n,r=null){const s=r!=null?r.shape:e.shape,o=s[s.length-1],i=xy(o),a=new hue(s,i,n,r==null),l=r==null?[e]:[e,r],c=t.runWebGLProgram(a,l,"int32");if(c.shape.length===e.shape.length){const d=jO(t,e,n,c);return t.disposeIntermediateTensorInfo(c),d}return c}function GO(t,e,n,r){const s=[n];if(bs("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,e.shape.length),!se().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const o=[],i=t.texData.get(e.dataId),a=i!==null&&i.isPacked;let l=e;a&&(l=t.unpackTensor(e),o.push(l));const[c,d]=Ls(l.shape,s),f=pe(d),p=Pe({inputs:{x:l},backend:t,attrs:{shape:[-1,f]}});o.push(p);const g=UO(t,p,r);o.push(g);const y=Pe({inputs:{x:g},backend:t,attrs:{shape:c}});return o.forEach(x=>t.disposeIntermediateTensorInfo(x)),y}return jO(t,e,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fue(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o}=r;let i=nn(o,s.shape);const a=ur(i,s.shape.length);let l=s;const c=[];a!=null&&(l=Ir({inputs:{x:s},backend:n,attrs:{perm:a}}),c.push(l),i=cr(i.length,l.shape.length)),bs("argMax",[i[0]],l.shape.length);const d=GO(n,l,i[0],"max");return c.forEach(f=>n.disposeIntermediateTensorInfo(f)),d}const pue={kernelName:uw,backendName:"webgl",kernelFunc:fue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mue(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o}=r;let i=nn(o,s.shape);const a=ur(i,s.shape.length);let l=s;const c=[];a!=null&&(l=Ir({inputs:{x:s},backend:n,attrs:{perm:a}}),c.push(l),i=cr(i.length,l.shape.length)),bs("argMin",[i[0]],l.shape.length);const d=GO(n,l,i[0],"min");return c.forEach(f=>n.disposeIntermediateTensorInfo(f)),d}const gue={kernelName:cw,backendName:"webgl",kernelFunc:mue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yue=mo+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,xue=$t({opSnippet:yue}),vue={kernelName:dw,backendName:"webgl",kernelFunc:xue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bue=mo+"return log(x + sqrt(x * x + 1.0));",wue=$t({opSnippet:bue}),Sue={kernelName:hw,backendName:"webgl",kernelFunc:wue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cue=mo+`
  return atan(x);
`,$ue=$t({opSnippet:Cue}),kue={kernelName:fw,backendName:"webgl",kernelFunc:$ue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tue=DC+`
  return atan(a, b);
`,Iue=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+ju+`
  return result;
`,Nue=Zn({opSnippet:Tue,packedOpSnippet:Iue}),Eue={kernelName:mw,backendName:"webgl",kernelFunc:Nue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rue=mo+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,_ue=$t({opSnippet:Rue}),Pue={kernelName:pw,backendName:"webgl",kernelFunc:_ue};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Nf=class{constructor(e,n,r,s=!1,o=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,d=e.dilationWidth,f=e.effectiveFilterHeight,p=e.effectiveFilterWidth,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const x=n==="avg",w=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,S=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let $="0.0";if(x||($="-1.0 / 1e-20"),r){const B=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${g}, ${y});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${f};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p};
                wC += ${d}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${B} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s?o?w:S:`wR * ${p} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const I="max";let R=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(R="avgValue / max(count, 1.0)");const _=Math.floor(i/4)*4,O=i%4,F=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${I}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${g}, ${y});
      const float initializationValue = ${$};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${$});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${f};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${_}; wC += 4) {
            int xC = xCCorner + wC * ${d};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              getValue(batch, xR, xC + 3 * ${d}, d)
            );

            ${F}
          }

          int xC = xCCorner + ${_};
          if (${O===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${F}
          } else if (${O===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              initializationValue,
              initializationValue
            );

            ${F}
          } else if (${O===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              initializationValue
            );

            ${F}
          }
        }
        setOutput(${R});
      }
    `}},FC=class{constructor(e,n,r,s=!1,o=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideDepth,l=e.strideHeight,c=e.strideWidth,d=e.dilationDepth,f=e.dilationHeight,p=e.dilationWidth,g=e.effectiveFilterDepth,y=e.effectiveFilterHeight,x=e.effectiveFilterWidth,w=e.padInfo.front,S=e.padInfo.top,$=e.padInfo.left;this.outputShape=e.outShape;const I=n==="avg";let R="0.0";if(I||(R="-1.0 / 1e-20"),r){const V=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${c});
        const ivec3 pads = ivec3(${w}, ${S}, ${$});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${g};
              wD += ${d}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${y};
                wR += ${f}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${x};
                  wC += ${p}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${V} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s?o?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${y} * ${x} +
                      wR * ${x} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const _="max";let O=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(O="avgValue / max(count, 1.0)");const F=Math.floor(i/4)*4,B=i%4,M=`
      if (${I}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${_}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${c});
      const ivec3 pads = ivec3(${w}, ${S}, ${$});
      const float initializationValue = ${R};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${R});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${g};
            wD += ${d}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${y};
            wR += ${f}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${F}; wC += 4) {
              int xC = xCCorner + wC * ${p};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                getValue(batch, xD, xR, xC + 3 * ${p}, ch)
              );

              ${M}
            }

            int xC = xCCorner + ${F};
            if (${B===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${M}
            } else if (${B===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                initializationValue,
                initializationValue
              );

              ${M}
            } else if (${B===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                initializationValue
              );

              ${M}
            }
          }
        }
        setOutput(${O});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aue(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;ep(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r,c=1;z(Er(i,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const d=fo(s.shape,o,i,c,a,l);if(d.filterWidth===1&&d.filterHeight===1&&Vt(d.inShape,d.outShape))return gs({inputs:{x:s},backend:n});const f=new Nf(d,"avg",!1);return n.runWebGLProgram(f,[s],"float32")}const Due={kernelName:gw,backendName:"webgl",kernelFunc:Aue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oue(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:c}=r,d=[1,1,1],f=Sa(s.shape,o,i,d,a,l,c),p=new FC(f,"avg",!1);return n.runWebGLProgram(p,[s],"float32")}const Fue={kernelName:yw,backendName:"webgl",kernelFunc:Oue};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Lue=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,i=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,d=l-1-e.padInfo.top,f=c-1-e.padInfo.left,p=1/(n*r);this.userCode=`
      const ivec2 pads = ivec2(${d}, ${f});
      const float avgMultiplier = float(${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},zue=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterDepth,r=e.filterHeight,s=e.filterWidth,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,f=e.effectiveFilterDepth,p=e.effectiveFilterHeight,g=e.effectiveFilterWidth,y=f-1-e.padInfo.front,x=p-1-e.padInfo.top,w=g-1-e.padInfo.left,S=1/(n*r*s);this.userCode=`
      const ivec3 pads = ivec3(${y}, ${x}, ${w});
      const float avgMultiplier = float(${S});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${o}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${g};
                wC += ${d}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bue(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,i=o,{filterSize:a,strides:l,pad:c,dimRoundingMode:d}=r,f=[1,1,1],p=Sa(i.shape,a,l,f,c,d),g=new zue(p);return n.runWebGLProgram(g,[s],i.dtype)}const Mue={kernelName:ZP,backendName:"webgl",kernelFunc:Bue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vue(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,i=o;ep([s,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,d=fo(i.shape,a,l,1,c),f=new Lue(d);return n.runWebGLProgram(f,[s],i.dtype)}const Wue={kernelName:QP,backendName:"webgl",kernelFunc:Vue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uue(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:o}=e,{transposeA:i,transposeB:a}=r;return Pg({a:s,b:o,transposeA:i,transposeB:a,backend:n})}const jue={kernelName:xw,backendName:"webgl",kernelFunc:Uue};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Gue=class{constructor(e,n,r,s,o,i){this.outputShape=[],this.variableNames=["x","mean","variance"],ct(e,n),ct(e,r);let a="0.0";s!=null&&(ct(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";o!=null&&(ct(e,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hue{constructor(e,n,r,s,o,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],ct(e,n),ct(e,r);let a="vec4(0.0)";s!=null&&(ct(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";o!=null&&(ct(e,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kue=({inputs:t,backend:e,attrs:n})=>{const{x:r,mean:s,variance:o,offset:i,scale:a}=t;z(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),z(i==null||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),z(a==null||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);const c=[r,s,o];let d=null;i!=null&&(d=i.shape,c.push(i));let f=null;a!=null&&(f=a.shape,c.push(a));const p=se().getBool("WEBGL_PACK_NORMALIZATION")?new Hue(r.shape,s.shape,o.shape,d,f,l):new Gue(r.shape,s.shape,o.shape,d,f,l);return e.runWebGLProgram(p,c,c[0].dtype)},Xue={kernelName:r2,backendName:"webgl",kernelFunc:Kue};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let que=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const n=Kt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=Yue(this.rank);let s;const o=e.map((i,a)=>`sourceLoc.${Sv[a]} = start[${a}] + coords.${Sv[a]};`);s=`
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${o.join(`
`)}
      `,this.userCode=`
      void main() {
        ${s}
        setOutput(getSource(${r}));
      }
    `}};const Sv=["x","y","z","w","u","v"];function Yue(t){if(t===1)return"sourceLoc";if(t<=6)return Sv.slice(0,t).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Que{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=Kt(this.rank),r=kr("coords",this.rank),s=kr("sourceLoc",this.rank),o=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${o})`,a=`
      result.x = ${i};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${i};
        --${s[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${i};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${i};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${n}(${e.map((d,f)=>`start[${f}]`).join()});`:e.map((d,f)=>`${s[f]} = ${r[f]} + start[${f}];`).join(`
`);this.userCode=`
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zue(t,e,n,r){const s=r.texData.get(t.dataId),o=r.makeTensorInfo(n,t.dtype),i=r.texData.get(o.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=t.dtype;let a=oC(e,gn(t.shape));s.slice&&(a+=s.slice.flatOffset),i.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||t.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),o}function Dd(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:o,size:i}=r,[a,l]=iC(s,o,i);if(nC(s,a,l),pe(l)===0)return n.makeTensorInfo(l,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||s.dtype==="string"){const f=n.texData.get(s.dataId),p=jae(f.values,a,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,p)}const{isPacked:c}=n.texData.get(s.dataId),d=sC(s.shape,a,l);if(c||!d){const f=se().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Que(l):new que(l),p=[a];return n.runWebGLProgram(f,[s],s.dtype,p)}return n.uploadToGPU(s.dataId),Zue(s,a,l,n)}const Jue={kernelName:lS,backendName:"webgl",kernelFunc:Dd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ece=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:o,crops:i}=r;z(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce(($,I)=>$*I),l=Yf(s.shape,o,a),c=Qf(l.length,o.length),d=Zf(s.shape,o,a),f=dC(i,o.length),p=hC(d,i,o.length),g=[],y=Pe({inputs:{x:s},backend:n,attrs:{shape:l}}),x=Ir({inputs:{x:y},backend:n,attrs:{perm:c}}),w=Pe({inputs:{x},backend:n,attrs:{shape:d}}),S=Dd({inputs:{x:w},backend:n,attrs:{begin:f,size:p}});return g.push(y),g.push(x),g.push(w),g.forEach($=>n.disposeIntermediateTensorInfo($)),S},tce={kernelName:vw,backendName:"webgl",kernelFunc:ece};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nce(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:o}=e,{size:i}=r,a=n.readSync(s.dataId),l=n.readSync(o.dataId),c=PO(a,l,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,c)}const rce={kernelName:bw,backendName:"webgl",kernelFunc:nce};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sce=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,oce=`
  return float(int(a.r) & int(b.r));
`;function ice(t){const{inputs:e,backend:n}=t,{a:r,b:s}=e,o=se().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=se().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,s])||i===1){const l=n.texData.get(r.dataId).values,c=n.texData.get(s.dataId).values,[d,f]=pae(r.shape,s.shape,l,c,r.dtype),p=n.makeTensorInfo(f,r.dtype),g=n.texData.get(p.dataId);return g.values=d,p}let a;return o?a=new Pd(sce,r.shape,s.shape,!1):a=new Lu(oce,r.shape,s.shape),n.runWebGLProgram(a,[r,s],r.dtype)}const ace={kernelName:JP,backendName:"webgl",kernelFunc:ice};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lce(t){const{inputs:e,backend:n}=t,{s0:r,s1:s}=e,o=n.readSync(r.dataId),i=n.readSync(s.dataId),a=ct(Array.from(o),Array.from(i));return n.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const uce={kernelName:ww,backendName:"webgl",kernelFunc:lce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cce="return float(a != b);",HO=Zn({opSnippet:cce,cpuKernelImpl:Oae,dtype:"bool"}),dce={kernelName:F2,backendName:"webgl",kernelFunc:HO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function np(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.texData.get(r.dataId);return gs({inputs:{x:s.complexTensorInfos.real},backend:n})}const hce={kernelName:K2,backendName:"webgl",kernelFunc:np};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fce="return float(int(x));";function pce(t,e){const n=new fi(t.shape,fce),r=e.runWebGLProgram(n,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cv(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dtype:o}=r;if(o==="complex64"){if(s.dtype==="complex64")return gs({inputs:{x:s},backend:n});const i=xa(s.shape),a=Cv({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),l=Il({inputs:{real:a,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(a),l}if(s.dtype==="complex64"){const i=np({inputs:{input:s},backend:n}),a=Cv({inputs:{x:i},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(i),a}if(!HP(s.dtype,o)){const i=gs({inputs:{x:s},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:o}}if(n.shouldExecuteOnCPU([s])){const i=n.texData.get(s.dataId).values,[a,l,c]=mae(i,s.shape,s.dtype,o);return n.makeTensorInfo(a,l,c)}if(o==="int32")return pce(s,n);if(o==="bool"){const i=n.makeTensorInfo([],"bool",Si("bool",1)),l=HO({inputs:{a:s,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}const mce={kernelName:ny,backendName:"webgl",kernelFunc:Cv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oN="return ceil(x);",gce=$t({opSnippet:oN,packedOpSnippet:oN,cpuKernelImpl:gae}),yce={kernelName:Sw,backendName:"webgl",kernelFunc:gce};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let xce=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vce{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bce(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{clipValueMin:o,clipValueMax:i}=r;let a;se().getBool("WEBGL_PACK_CLIP")?a=new vce(s.shape):a=new xce(s.shape);const l=[[o],[i]];return n.runWebGLProgram(a,[s],s.dtype,l)}const wce={kernelName:Cw,backendName:"webgl",kernelFunc:bce};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Sce=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iN(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}function Cce(t){const{inputs:e,backend:n}=t,{x:r}=e,s=n.texData.get(r.dataId),o=new Sce(r.shape),i=[iN(r,s.complexTensorInfos.real),iN(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(o,i,i[0].dtype)}const $ce={kernelName:kw,backendName:"webgl",kernelFunc:Cce};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let kce=class{constructor(e){this.outputShape=[],this.outputShape=ho(e,1),this.variableNames=e.map((i,a)=>`T${a}`);const n=new Array(e.length-1);n[0]=e[0][1];for(let i=1;i<n.length;i++)n[i]=n[i-1]+e[i][1];const r=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<n.length;i++){const a=n[i-1];r.push(`else if (yC < ${n[i]}) setOutput(getT${i}(yR, yC-${a}));`)}const s=n.length,o=n[n.length-1];r.push(`else setOutput(getT${s}(yR, yC-${o}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tce{constructor(e,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=ho(e,n);const r=this.outputShape,s=r.length,o=Kt(s),i=kr("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=e.map((x,w)=>`T${w}`);const l=new Array(e.length-1);l[0]=e[0][n];for(let x=1;x<l.length;x++)l[x]=l[x-1]+e[x][n];const c=a[n],d=a.slice(-2),f=a.join();let p=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${f}), vec2(${d.join()}));
        }`;for(let x=1;x<l.length;x++){const w=l[x-1];p+=`
        if (${c} < ${l[x]}  && ${c} >= ${l[x-1]}) {
          return getChannel(
            getT${x}(${Im(a,c,w)}),
            vec2(${Im(d,c,w)}));
        }`}const g=l.length,y=l[l.length-1];p+=`
        return getChannel(
          getT${g}(${Im(a,c,y)}),
          vec2(${Im(d,c,y)}));`,this.userCode=`
      float getValue(${a.map(x=>"int "+x)}) {
        ${p}
      }

      void main() {
        ${o} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[s-1]} = ${i[s-1]} + 1;
        if (${i[s-1]} < ${r[s-1]}) {
          result.g = getValue(${i});
        }

        ${i[s-2]} = ${i[s-2]} + 1;
        if (${i[s-2]} < ${r[s-2]}) {
          result.a = getValue(${i});
        }

        ${i[s-1]} = ${i[s-1]} - 1;
        if (${i[s-2]} < ${r[s-2]} &&
            ${i[s-1]} < ${r[s-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}}function Im(t,e,n){const r=t.indexOf(e);return t.map((o,i)=>i===r?`${o} - ${n}`:o).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cy(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.texData.get(r.dataId);return gs({inputs:{x:s.complexTensorInfos.imag},backend:n})}const Ice={kernelName:u2,backendName:"webgl",kernelFunc:Cy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lh(t,e,n){const r=t[0].dtype;if(r==="complex64"){const g=t.map($=>np({inputs:{input:$},backend:n})),y=t.map($=>Cy({inputs:{input:$},backend:n})),x=Lh(g,e,n),w=Lh(y,e,n),S=Il({inputs:{real:x,imag:w},backend:n});return g.forEach($=>n.disposeIntermediateTensorInfo($)),y.forEach($=>n.disposeIntermediateTensorInfo($)),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),S}let s=n.shouldExecuteOnCPU(t);if(r==="string"&&(s=!0),s){const g=t.map(R=>{const O=[-1,pe(R.shape.slice(e))];return Pe({inputs:{x:R},backend:n,attrs:{shape:O}})}),y=g.map(R=>({vals:n.readSync(R.dataId),shape:R.shape})),x=ho(g.map(R=>R.shape),1),w=g[0].shape[0]===1,S=yae(y,x,r,w),$=ho(t.map(R=>R.shape),e),I=n.makeTensorInfo($,r,S);return g.forEach(R=>n.disposeIntermediateTensorInfo(R)),I}const o=t.filter(g=>pe(g.shape)>0),i=se().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(o.length===1){const g=i?new fi(t[0].shape,il):new ul(t[0].shape,il);return n.runWebGLProgram(g,t,r)}const a=se().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>a){const g=[];for(let x=0;x<o.length;x+=a){const w=o.slice(x,x+a);g.push(Lh(w,e,n))}const y=Lh(g,e,n);for(const x of g)n.disposeIntermediateTensorInfo(x);return y}if(i){const g=new Tce(o.map(y=>y.shape),e);return n.runWebGLProgram(g,o,r)}const{tensors2D:l,outShape:c}=Nce(o,e,n),d=new kce(l.map(g=>g.shape)),f=n.runWebGLProgram(d,l,r);l.forEach(g=>n.disposeIntermediateTensorInfo(g));const p=Pe({inputs:{x:f},attrs:{shape:c},backend:n});return n.disposeIntermediateTensorInfo(f),p}function Nce(t,e,n){const r=ho(t.map(o=>o.shape),e);return{tensors2D:t.map(o=>Pe({inputs:{x:o},attrs:{shape:[-1,pe(o.shape.slice(e))]},backend:n})),outShape:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KO(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r,o=nn(s,e[0].shape)[0],i=e.map(c=>c.shape);lC(i,o);const a=ho(e.map(c=>c.shape),o);if(pe(a)===0)return n.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(c=>pe(c.shape)>0);return l.length===1?gs({inputs:{x:l[0]},backend:n}):Lh(l,o,n)}const Ece={kernelName:Tw,backendName:"webgl",kernelFunc:KO};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XO{constructor(e,n=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const i=e.padInfo.top,a=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,d=e.dilationHeight,f=e.dilationWidth,p=e.filterHeight,g=e.filterWidth,y=Math.floor(e.inChannels/4)*4,x=e.inChannels%4,w=e.dataFormat==="channelsLast",S=w?1:2,$=w?2:3,I=w?3:1;let R="",_="";r&&(s?R=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?R=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:R=`
          float activation(float x) {
            ${r}
          }
        `,_="result = activation(result);");const O=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${R}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${I}];

        ivec2 xRCCorner =
            ivec2(coords[${S}], coords[${$}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p}; wR++) {
          int xR = xRCorner + wR * ${d};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${g}; wC++) {
            int xC = xCCorner + wC * ${f};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${y}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${w}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${x===1}) {

              if (${w}) {
                dotProd +=
                    getX(batch, xR, xC, ${y}) *
                    getW(wR, wC, ${y}, d2);
              } else {
                dotProd +=
                    getX(batch, ${y}, xR, xC) *
                    getW(wR, wC, ${y}, d2);
              }

            } else if (${x===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${y}, d2),
                getW(wR, wC, ${y} + 1, d2)
              );

              if (${w}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${y}),
                  getX(batch, xR, xC, ${y} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${y}, xR, xC),
                  getX(batch, ${y} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${x===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${y}, d2),
                getW(wR, wC, ${y} + 1, d2),
                getW(wR, wC, ${y} + 2, d2)
              );

              if (${w}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${y}),
                  getX(batch, xR, xC, ${y} + 1),
                  getX(batch, xR, xC, ${y} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${y}, xR, xC),
                  getX(batch, ${y} + 1, xR, xC),
                  getX(batch, ${y} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${O}
        ${_}
        setOutput(result);
      }
    `}}class Rce{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const n=e.padInfo.front,r=e.padInfo.top,s=e.padInfo.left,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,f=e.filterDepth,p=e.filterHeight,g=e.filterWidth,y=Math.floor(e.inChannels/4)*4,x=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${o}, ${i}, ${a});
      const ivec3 pads = ivec3(${n}, ${r}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${f}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${g}; wC++) {
              int xC = xCCorner + wC * ${d};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${y}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${x===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${y}) *
                  getW(wF, wR, wC, ${y}, d2);
              } else if (${x===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${y}),
                  getX(batch, xF, xR, xC, ${y} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${y}, d2),
                  getW(wF, wR, wC, ${y} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${x===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${y}),
                  getX(batch, xF, xR, xC, ${y} + 1),
                  getX(batch, xF, xR, xC, ${y} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${y}, d2),
                  getW(wF, wR, wC, ${y} + 1, d2),
                  getW(wF, wR, wC, ${y} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qO{constructor(e,n=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=dr(this.outputShape.length);const i=e.padInfo.left,a=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,f=d;let p=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let w=0;w<d;w++)p+=`
           vec4 xTexelC${w*2};
           int xTexelC${w*2}Ready;
           vec4 xTexelC${w*2+1};
           int xTexelC${w*2+1}Ready;
           vec4 xC${w};`;p+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let w=0;w<d;w++)p+=`
           xTexelC${w*2} = vec4(0.0);
           xTexelC${w*2}Ready = 0;
           xTexelC${w*2+1} = vec4(0.0);
           xTexelC${w*2+1}Ready = 0;
           xC${w} = vec4(0.0);`;p+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let w=0;w<(f+1)/2;w++){const S=w*2;if(p+=`
           xC = xCCorner + ${S*l};
           `,a===1){if(S<d&&(i%2===1?(p+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }
               `,l===1&&S>0?p+=`
                 xC${S} = vec4(xTexelC${S-2}.zw, xTexelC${S}.xy);
                 `:p+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${S} = vec4(previous.zw, xTexelC${S}.xy);
                   } else {
                     xC${S} = vec4(0.0, 0.0, xTexelC${S}.xy);
                   }
                   `):p+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 xC${S} = xTexelC${S};
                 `,S+1<d)){const $=i%2===0?ew(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(p+=`
                   xCOffset = xC + imod(pads[1], 2) + ${$};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                     xTexelC${S+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${S+1}.zw = vec2(0.0);
                     }
                     xTexelC${S+1}Ready = 1;
                   }
                   `,l>1?p+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${S+1} = vec4(previous.zw, xTexelC${S+1}.xy);
                     } else {
                      xC${S+1} = vec4(0.0, 0.0, xTexelC${S+1}.xy);
                     }
                     `:p+=`
                     xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.xy);
                     `):$===1?p+=`
                     xC${S+1} = xTexelC${S};
                     `:p+=`
                     xCOffset = xC + ${$};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                       xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${S+1}.zw = vec2(0.0);
                       }
                       xTexelC${S+1}Ready = 1;
                     }

                     xC${S+1} = xTexelC${S+1};
                     `}}else S<d&&(i%2===1?(p+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${S+1}Ready == 0) {
                   xTexelC${S+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${S+1}.zw = vec2(0.0);
                   }
                   xTexelC${S+1}Ready = 1;
                 }

                 xC${S} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
               `,S+1<d&&(p+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${S+1} = vec4(xTexelC${S+1}.xy, final.xy);
                 `)):(p+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                   xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S+1}.zw = vec2(0.);
                   }
                   xTexelC${S+1}Ready = 1;
                 }

                 xC${S} = vec4(
                   xTexelC${S}.xy, xTexelC${S+1}.xy);
               `,S+1<d&&(p+=`
                   xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
                 `)));S<d&&(p+=`
             wTexel = getW(r, ${S}, d1, d2);
             dotProd += xC${S}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${S}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,S+1<d&&(p+=`
               wTexel = getW(r, ${S+1}, d1, d2);
               dotProd += xC${S+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${S+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}p+=`
     }
   `,p+=`
     }
   `,p+=`
     }
   `;let g="",y="";r&&(s?g=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:o?g=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:g=`vec4 activation(vec4 x) {
           ${r}
         }`,y="result = activation(result);");const x=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${g}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${p}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${x}
         ${y}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _ce{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=dr(this.outputShape.length);const{dataFormat:r}=n,s=Rr(),o=r==="channelsLast",i=o?1:2,a=o?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let c="";for(let d=0;d<=1;d++)for(let f=0;f<=1;f++)c+=`
          blockIndex = rc.z + ${f};
          pos = rc.y + ${d};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${o}) {
                  innerDims = vec2(d1, ch);
                  result[${d*2+f}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${d*2+f}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${s.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ag(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&n===1&&t[0]>1?[t[0],1]:null}function YO({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const l=t.shape,c=r.texData.get(t.dataId),d=n.inChannels,f=l[0]*l[1]*l[2],p=n.outChannels,g=n.dataFormat==="channelsLast",y=!1,x=!1;let w;const S=[];if(o!=null){const R=Ag(o.shape,g);R!=null&&(o=Pe({inputs:{x:o},backend:r,attrs:{shape:R}}),S.push(o))}if(s!=null){const R=Ag(s.shape,g);R!=null&&(s=Pe({inputs:{x:s},backend:r,attrs:{shape:R}}),S.push(s))}if(!((f===1||p===1)&&d>WO)&&c.isPacked&&g&&c.texture!=null&&l[2]%2!==0&&Vt(c.shape.slice(-3),l.slice(-3))){const R=l[0]*l[1]*(l[2]+1),_={dataId:t.dataId,shape:[1,R,n.inChannels],dtype:t.dtype},O=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,z(Rg(c.shape,_.shape),()=>`packed reshape ${c.shape} to ${_.shape} isn't free`);const F=Pe({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});S.push(F);const B=Pg({a:_,b:F,backend:r,transposeA:y,transposeB:x,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),M=r.texData.get(B.dataId);z(M.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=O,M.shape=n.outShape,w=gs({inputs:{x:B},backend:r}),w.shape=n.outShape,S.push(B)}else{const R=n.outHeight*n.outWidth,_=Pe({inputs:{x:t},backend:r,attrs:{shape:g?[n.batchSize,R,n.inChannels]:[n.batchSize,n.inChannels,R]}}),O=Pe({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),F=Pg({a:g?_:O,b:g?O:_,transposeA:!g,transposeB:x,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i});w=Pe({inputs:{x:F},backend:r,attrs:{shape:n.outShape}}),S.push(_),S.push(O),S.push(F)}for(const R of S)r.disposeIntermediateTensorInfo(R);return w}function QO({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:d,outWidth:f,outHeight:p,dataFormat:g}=n,y=g==="channelsLast",x=l*c*d,w=p*f,S=[n.batchSize,x,w],$=!0,I=!1,R=[];if(o!=null){const fe=Ag(o.shape,y);fe!=null&&(o=Pe({inputs:{x:o},backend:r,attrs:{shape:fe}}),R.push(o))}if(s!=null){const fe=Ag(s.shape,y);fe!=null&&(s=Pe({inputs:{x:s},backend:r,attrs:{shape:fe}}),R.push(s))}const _=Pe({inputs:{x:e},backend:r,attrs:{shape:[1,x,pe(e.shape)/x]}});R.push(_);const O=new _ce(S,n),F=[t.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],B=r.runWebGLProgram(O,[t],"float32",F),M=Pe({inputs:{x:B},backend:r,attrs:{shape:S}});R.push(B),R.push(M);const V=s!=null,P=o!=null,re=a==="leakyrelu",ie=a?If(a,!0):null,me=new VO(y?M.shape:_.shape,y?_.shape:M.shape,y?[n.batchSize,w,n.outChannels]:[n.batchSize,n.outChannels,w],$,I,V,ie,P,re),ge=y?[M,_]:[_,M];if(s&&ge.push(s),P&&ge.push(o),re){const fe=r.makeTensorInfo([],"float32",kd(i,"float32"));ge.push(fe),R.push(fe)}const ve=r.runWebGLProgram(me,ge,"float32"),$e=Pe({inputs:{x:ve},backend:r,attrs:{shape:n.outShape}});R.push(ve);for(const fe of R)r.disposeIntermediateTensorInfo(fe);return $e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pce(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dataFormat:l,dilations:c,dimRoundingMode:d}=r,f=Mo(l),p=kn(s.shape,o.shape,i,c,a,d,!1,f);let g;if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))g=YO({x:s,filter:o,convInfo:p,backend:n});else if(p.strideWidth<=2&&f==="channelsLast"&&se().getBool("WEBGL_EXP_CONV")){const x=new qO(p),w=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];g=n.runWebGLProgram(x,[s,o],"float32",w)}else if(se().getBool("WEBGL_CONV_IM2COL"))g=QO({x:s,filter:o,convInfo:p,backend:n});else{const x=new XO(p);g=n.runWebGLProgram(x,[s,o],"float32")}const y=Pe({inputs:{x:g},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(g),y}const Ace={kernelName:Iw,backendName:"webgl",kernelFunc:Pce};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Dce=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,o=e.padInfo.left,i=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Oce=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,i=e.dataFormat==="channelsLast",a=n-1-e.padInfo.top,l=r-1-e.padInfo.left,c=i?1:2,d=i?2:3,f=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${f}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${d}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Fce=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideDepth,r=e.strideHeight,s=e.strideWidth,o=e.padInfo.front,i=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${n} - ${o};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${i};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${s} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Lce=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterDepth,r=e.filterHeight,s=e.filterWidth,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,l=n-1-e.padInfo.front,c=r-1-e.padInfo.top,d=s-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${n}; wF++) {
          float dyF = float(dyFCorner + wF) / ${o}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${n} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${s}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zce(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:i,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:d}=r,f=Mo(l),p=kn(s.shape,d,i,1,a,c,!1,f),g=new Dce(p);return n.runWebGLProgram(g,[s,o],"float32")}const Bce={kernelName:Nw,backendName:"webgl",kernelFunc:zce};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mce{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=dr(this.outputShape.length);const n=e.filterHeight,r=e.filterWidth,s=n-1-e.padInfo.top,o=r-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vce(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{inputShape:i,strides:a,pad:l,dataFormat:c,dimRoundingMode:d}=r,f=Mo(c),p=kn(i,o.shape,a,1,l,d,!1,f);if(se().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&f==="channelsLast"){const g=[[p.strideHeight,p.strideWidth]],y=new Mce(p);return n.runWebGLProgram(y,[s,o],"float32",g)}else{const g=new Oce(p);return n.runWebGLProgram(g,[s,o],"float32")}}const Wce={kernelName:Ew,backendName:"webgl",kernelFunc:Vce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uce(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dilations:l}=r,c=Tl(s.shape,o.shape,i,l,a),d=new Rce(c);return n.runWebGLProgram(d,[s,o],"float32")}const jce={kernelName:Rw,backendName:"webgl",kernelFunc:Uce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gce(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:i,pad:a,filterShape:l}=r,c=Tl(s.shape,l,i,1,a),d=new Fce(c);return n.runWebGLProgram(d,[s,o],"float32")}const Hce={kernelName:eA,backendName:"webgl",kernelFunc:Gce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kce(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{pad:i,strides:a,inputShape:l}=r,c=Tl(l,o.shape,a,1,i),d=new Lce(c);return n.runWebGLProgram(d,[s,o],"float32")}const Xce={kernelName:_w,backendName:"webgl",kernelFunc:Kce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qce=Ad+`
  return cos(x);
`,Yce=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${ju}
  return result;
`,Qce=$t({opSnippet:qce,packedOpSnippet:Yce}),Zce={kernelName:Pw,backendName:"webgl",kernelFunc:Qce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jce=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,ede=$t({opSnippet:Jce}),tde={kernelName:Aw,backendName:"webgl",kernelFunc:ede};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nde=class{constructor(e,n,r,s,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,l,c]=e,[d]=n,[f,p]=r;this.outputShape=[d,f,p,c];const g=s==="bilinear"?1:0,[y,x]=[`${a-1}.0`,`${l-1}.0`],[w,S,$]=f>1?[`${(a-1)/(f-1)}`,"(y2-y1) * height_ratio",`y1*${y} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${y}`],[I,R,_]=p>1?[`${(l-1)/(p-1)}`,"(x2-x1) * width_ratio",`x1*${x} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${x}`];this.userCode=`
      const float height_ratio = float(${w});
      const float width_ratio = float(${I});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${S};
        float width_scale = ${R};

        float in_y = ${$};
        if( in_y < 0.0 || in_y > ${y} ) {
          setOutput(float(${o}));
          return;
        }
        float in_x = ${_};
        if( in_x < 0.0 || in_x > ${x} ) {
          setOutput(float(${o}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${g} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rde=t=>{const{inputs:e,backend:n,attrs:r}=t,{image:s,boxes:o,boxInd:i}=e,{cropSize:a,method:l,extrapolationValue:c}=r,d=new nde(s.shape,o.shape,a,l,c);return n.runWebGLProgram(d,[s,o,i],"float32")},sde={kernelName:Fw,backendName:"webgl",kernelFunc:rde};var Ef;(function(t){t.Prod="*",t.Sum="+"})(Ef||(Ef={}));let aN=class{constructor(e,n,r,s){this.op=e,this.outputShape=n,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,i=this.op===Ef.Prod?"1.0":"0.0",a=r?i:`getX(${lN(o,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",d="";r?(c=s?`end != ${l-1}`:"end != 0",d=s?"end + 1":"end - 1"):(c=s?`end + pow2 < ${l}`:"end >= pow2",d=s?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Kt(o)} coords = getOutputCoords();
        int end = ${uN(o,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${d};
          ${uN(o,"coords",this.op)} = idx;
          val ${this.op}= getX(${lN(o,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function lN(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.x, ${e}.y`;if(t===3)return`${e}.x, ${e}.y, ${e}.z`;if(t===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function uN(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.y`;if(t===3)return`${e}.z`;if(t===4)return`${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZO(t,e,n,r,s,o){const i=e.shape.length,a=ur([r],i);let l=e;a!=null&&(l=Ir({inputs:{x:e},backend:n,attrs:{perm:a}}));const c=cr(1,i)[0];if(c!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const d=l.shape[c];let f=gs({inputs:{x:l},backend:n});for(let p=0;p<=Math.ceil(Math.log2(d))-1;p++){const g=new aN(t,l.shape,!1,o),y=[[p]],x=f;f=n.runWebGLProgram(g,[f],f.dtype,y),n.disposeIntermediateTensorInfo(x)}if(s){const p=new aN(t,l.shape,s,o),g=f;f=n.runWebGLProgram(p,[f],f.dtype),n.disposeIntermediateTensorInfo(g)}if(a!=null){const p=qf(a),g=Ir({inputs:{x:f},backend:n,attrs:{perm:p}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(l),g}return f}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ode(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,exclusive:i,reverse:a}=r;return ZO(Ef.Prod,s,n,o,i,a)}const ide={kernelName:Dw,backendName:"webgl",kernelFunc:ode};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ade(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,exclusive:i,reverse:a}=r;return ZO(Ef.Sum,s,n,o,i,a)}const lde={kernelName:Ow,backendName:"webgl",kernelFunc:ade};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ude(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:o}=e,{size:i,binaryOutput:a}=r;if(s.shape.length===1){const l=n.readSync(s.dataId),c=n.readSync(o.dataId),d=PO(l,c,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,d)}else if(s.shape.length===2){const l=n.bufferSync(s),c=n.bufferSync(o),d=fae(l,c,i,a);return n.makeTensorInfo(d.shape,o.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const cde={kernelName:Lw,backendName:"webgl",kernelFunc:ude};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let dde=class{constructor(e,n,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=n,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${n};
      int offset_h = imod(h, ${n});
      int in_w = w / ${n};
      int offset_w = imod(w, ${n});
      int offset_d = (offset_h * ${n} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hde(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockSize:o,dataFormat:i}=r,a=s.shape[0],l=i==="NHWC"?s.shape[1]:s.shape[2],c=i==="NHWC"?s.shape[2]:s.shape[3],d=i==="NHWC"?s.shape[3]:s.shape[1],f=l*o,p=c*o,g=d/(o*o),y=i==="NHWC"?[a,f,p,g]:[a,g,f,p],x=new dde(y,o,i);return n.runWebGLProgram(x,[s],s.dtype)}const fde={kernelName:zw,backendName:"webgl",kernelFunc:hde};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let JO=class{constructor(e,n=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=dr(this.outputShape.length);const i=e.filterHeight,a=e.filterWidth,l=e.outChannels/e.inChannels;let c="",d="";r&&(s?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:c=`
          float activation(float x) {
            ${r}
          }
        `,d="result = activation(result);");const f=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${f}
        ${d}
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eF{constructor(e,n=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=dr(this.outputShape.length);const i=e.outChannels/e.inChannels,a=e.padInfo.left,l=e.strideWidth,c=e.dilationWidth,d=e.filterHeight,f=e.filterWidth,p=f;let g=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let S=0;S<f;S++)g+=`
          vec4 xTexelC${S*2};
          int xTexelC${S*2}Ready;
          vec4 xTexelC${S*2+1};
          int xTexelC${S*2+1}Ready;
          vec4 xC${S};`;g+=`
    for (int r = 0; r < ${d}; r++) {
      `;for(let S=0;S<f;S++)g+=`
          xTexelC${S*2} = vec4(0.0);
          xTexelC${S*2}Ready = 0;
          xTexelC${S*2+1} = vec4(0.0);
          xTexelC${S*2+1}Ready = 0;
          xC${S} = vec4(0.0);`;g+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let S=0;S<(p+1)/2;S++){const $=S*2;if(g+=`
          xC = xCCorner + ${$*c};
          `,l===1){if($<f&&(a%2===1?(g+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }
              `,c===1&&$>0?g+=`
                xC${$} = vec4(xTexelC${$-2}.zw, xTexelC${$}.xy);
                `:g+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${$} = vec4(previous.zw, xTexelC${$}.xy);
                  } else {
                    xC${$} = vec4(0.0, 0.0, xTexelC${$}.xy);
                  }
                  `):g+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                xC${$} = xTexelC${$};
                `,$+1<f)){const I=a%2===0?ew(c):c;c%2===0&&a%2===1||c%2!==0&&a%2!==1?(g+=`
                  xCOffset = xC + imod(pads[1], 2) + ${I};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                    xTexelC${$+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${$+1}.zw = vec2(0.0);
                    }
                    xTexelC${$+1}Ready = 1;
                  }
                  `,c>1?g+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${$+1} = vec4(previous.zw, xTexelC${$+1}.xy);
                    } else {
                     xC${$+1} = vec4(0.0, 0.0, xTexelC${$+1}.xy);
                    }
                    `:g+=`
                    xC${$+1} = vec4(xTexelC${$}.zw, xTexelC${$+1}.xy);
                    `):I===1?g+=`
                    xC${$+1} = xTexelC${$};
                    `:g+=`
                    xCOffset = xC + ${I};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                      xTexelC${$+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${$+1}.zw = vec2(0.0);
                      }
                      xTexelC${$+1}Ready = 1;
                    }

                    xC${$+1} = xTexelC${$+1};
                    `}}else $<f&&(a%2===1?(g+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${$+1}Ready == 0) {
                  xTexelC${$+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${$+1}.zw = vec2(0.0);
                  }
                  xTexelC${$+1}Ready = 1;
                }

                xC${$} = vec4(xTexelC${$}.zw, xTexelC${$+1}.zw);
              `,$+1<f&&(g+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${$+1} = vec4(xTexelC${$+1}.xy, final.xy);
                `)):(g+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                  xTexelC${$+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$+1}.zw = vec2(0.);
                  }
                  xTexelC${$+1}Ready = 1;
                }

                xC${$} = vec4(
                  xTexelC${$}.xy, xTexelC${$+1}.xy);
              `,$+1<f&&(g+=`
                  xC${$+1} = vec4(xTexelC${$}.zw, xTexelC${$+1}.zw);
                `)));$<f&&(g+=`
            wTexel = getW(r, ${$}, d1, q);
            dotProd += xC${$} * vec4(wTexel.xz, wTexel.xz);
          `,$+1<f&&(g+=`
              wTexel = getW(r, ${$+1}, d1, q);
              dotProd += xC${$+1} * vec4(wTexel.xz, wTexel.xz);
            `))}g+=`
    }
  `,g+=`
      }
    `;let y="",x="";r&&(s?y=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?y=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:y=`vec4 activation(vec4 x) {
          ${r}
        }`,x="result = activation(result);");const w=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${y}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${g}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${w}
        ${x}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pde(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dilations:l,dimRoundingMode:c}=r;let d=l;d==null&&(d=[1,1]),z(Er(i,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);const f=kn(s.shape,o.shape,i,d,a,c,!0);let p;se().getBool("WEBGL_PACK_DEPTHWISECONV")&&f.strideWidth<=2&&f.outChannels/f.inChannels===1?p=new eF(f):p=new JO(f);const g=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];return n.runWebGLProgram(p,[s,o],"float32",g)}const mde={kernelName:Bw,backendName:"webgl",kernelFunc:pde};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let gde=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,o=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},yde=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,i=n-1-e.padInfo.top,a=r-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xde(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:i,dilations:a,pad:l,dimRoundingMode:c,filterShape:d}=r,f=kn(s.shape,d,i,a,l,c,!0),p=new gde(f);return n.runWebGLProgram(p,[s,o],"float32")}const vde={kernelName:Mw,backendName:"webgl",kernelFunc:xde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bde(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{strides:i,dilations:a,pad:l,dimRoundingMode:c,inputShape:d}=r,f=kn(d,o.shape,i,a,l,c,!0),p=new yde(f);return n.runWebGLProgram(p,[s,o],"float32")}const wde={kernelName:Vw,backendName:"webgl",kernelFunc:bde};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Sde=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cde(t){const{inputs:e,backend:n}=t,{x:r}=e,s=[...r.shape,...r.shape],o=pe(r.shape),i=Pe({inputs:{x:r},backend:n,attrs:{shape:[o]}}),a=new Sde(o),l=n.runWebGLProgram(a,[i],i.dtype),c=Pe({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),c}const $de={kernelName:Ww,backendName:"webgl",kernelFunc:Cde};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let kde=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:n,inWidth:r,padInfo:s,strideHeight:o,strideWidth:i,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:d}=e,{top:f,left:p}=s;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${i});
      const ivec2 pads = ivec2(${f}, ${p});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${n}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${d};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tde(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dilations:l}=r,c=Kf(s.shape,o.shape,i,a,"NHWC",l);let d;const f=new kde(c);d=n.runWebGLProgram(f,[s,o],"float32");const p=Pe({inputs:{x:d},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(d),p}const Ide={kernelName:Uw,backendName:"webgl",kernelFunc:Tde};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nde(t){const{inputs:e,backend:n,attrs:r}=t,{equation:s}=r,o=e,{allDims:i,summedDims:a,idDims:l}=wC(s,o.length);CC(i.length,l,o);const{path:c,steps:d}=$C(a,l),f=d.length;let p=null,g=i.length;const y=[];for(let x=0;x<f;++x){for(const w of d[x]){const{permutationIndices:S,expandDims:$}=SC(g,l[w]);let I;kC(S)?I=o[w]:(I=Ir({inputs:{x:o[w]},backend:n,attrs:{perm:S}}),y.push(I));const R=I.shape.slice();for(let _=0;_<$.length;++_)R.splice($[_],0,1);Vt(I.shape,R)||(I=Pe({inputs:{x:I},backend:n,attrs:{shape:R}}),y.push(I)),p===null?p=I:(p=OC({inputs:{a:I,b:p},backend:n}),y.push(p))}x<f-1&&(c[x]>=0&&(p=Sy({inputs:{x:p},backend:n,attrs:{axis:c[x]-(i.length-g),keepDims:!1}}),y.push(p)),g--)}for(const x of y)x!==p&&n.disposeIntermediateTensorInfo(x);return p}const Ede={kernelName:Gw,backendName:"webgl",kernelFunc:Nde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rde="return (x >= 0.0) ? x : (exp(x) - 1.0);",_de=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Pde=$t({opSnippet:Rde,packedOpSnippet:_de}),Ade={kernelName:Hw,backendName:"webgl",kernelFunc:Pde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dde="return (b >= 0.0) ? a : a * (b + 1.0);",Ode=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Fde=t=>{const{inputs:e,backend:n}=t,{dy:r,y:s}=e,o=se().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Pd(Ode,r.shape,s.shape):new Lu(Dde,r.shape,s.shape);return n.runWebGLProgram(o,[r,s],r.dtype)},Lde={kernelName:nA,backendName:"webgl",kernelFunc:Fde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zde=`
  return vec4(equal(a, b));
`,Bde="return float(a == b);",Mde=Zn({opSnippet:Bde,packedOpSnippet:zde,dtype:"bool",cpuKernelImpl:xae}),Vde={kernelName:Xw,backendName:"webgl",kernelFunc:Mde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wde=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${mC};
  float a1 = ${gC};
  float a2 = ${yC};
  float a3 = ${xC};
  float a4 = ${vC};
  float a5 = ${bC};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Ude=$t({opSnippet:Wde}),jde={kernelName:Kw,backendName:"webgl",kernelFunc:Ude};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gde=Ad+`
  return exp(x);
`,Hde=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,tF=$t({opSnippet:Gde,packedOpSnippet:Hde,cpuKernelImpl:vae,dtype:"float32"}),Kde={kernelName:qw,backendName:"webgl",kernelFunc:tF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $v(t){const{inputs:e,attrs:n,backend:r}=t,{dim:s}=n,{input:o}=e,i=o.shape.length,a=o.shape.slice();let l=s;return s<0&&(z(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),a.splice(l,0,1),Pe({inputs:{x:o},backend:r,attrs:{shape:a}})}const Xde={kernelName:Yw,backendName:"webgl",kernelFunc:$v};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cN="return exp(x) - 1.0;",qde=$t({opSnippet:cN,packedOpSnippet:cN,cpuKernelImpl:bae}),Yde={kernelName:Qw,backendName:"webgl",kernelFunc:qde};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let dN=class{constructor(e,n,r){this.variableNames=["real","imag"];const s=n[1];this.outputShape=n;const o=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${s}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${o};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nF(t,e,n){const r=n.texData.get(t.dataId),s=pe(t.shape),o=t.shape[t.shape.length-1],i=s/o,a=Pe({inputs:{x:t},backend:n,attrs:{shape:[i,o]}}),l=a.shape,c=new dN("real",l,e),d=new dN("imag",l,e),f=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],p=n.runWebGLProgram(c,f,"float32"),g=n.runWebGLProgram(d,f,"float32"),y=Il({inputs:{real:p,imag:g},backend:n});n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g);const x=Pe({inputs:{x:y},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(y),x}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qde(t){const{inputs:e,backend:n}=t,{input:r}=e;return nF(r,!1,n)}const Zde={kernelName:Zw,backendName:"webgl",kernelFunc:Qde};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Jde=class{constructor(e,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rp(t){const{backend:e,attrs:n}=t,{shape:r,value:s}=n;let{dtype:o}=n;if(o=o||$d(s),o==="string"){const i=En(o,pe(r));return i.fill(s),e.makeTensorInfo(r,o,i)}else{const i=new Jde(r,s),a=[[s]];return e.runWebGLProgram(i,[],o,a)}}const ehe={kernelName:Jw,backendName:"webgl",kernelFunc:rp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let the=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];const n=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${n} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${n}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nhe={kernelName:e2,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,r=e,s=new the(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hN="return floor(x);",rhe=$t({opSnippet:hN,packedOpSnippet:hN,cpuKernelImpl:wae}),she={kernelName:t2,backendName:"webgl",kernelFunc:rhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ohe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,ihe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,ahe=Zn({opSnippet:ohe,packedOpSnippet:ihe,dtype:"int32"}),lhe={kernelName:n2,backendName:"webgl",kernelFunc:ahe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let uhe=class{constructor(e){this.variableNames=["A"];const n=Rr(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);

        vec4 values = ${n.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class che{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=Rr(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${r}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dhe={kernelName:vg,backendName:"webgl",kernelFunc:hhe};let kc,tx=se().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function hhe(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:s}=e;const{numChannels:o}=r,i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,c]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],d=[c,l],f=[c,l,o];if(a||i){const x=se().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(kc==null||x!==tx)&&(tx=x,kc=document.createElement("canvas").getContext("2d",{willReadFrequently:tx})),kc.canvas.width=l,kc.canvas.height=c,kc.drawImage(s,0,0,l,c),s=kc.canvas}const p=n.makeTensorInfo(d,"int32");n.texData.get(p.dataId).usage=Ps.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId),s);const g=se().getBool("WEBGL_PACK")?new che(f):new uhe(f),y=n.runWebGLProgram(g,[p],"int32");return n.disposeData(p.dataId),y}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fhe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:d,dilations:f,dimRoundingMode:p,activation:g,leakyreluAlpha:y}=r,x=Mo(d),w=kn(s.shape,o.shape,l,f,c,p,!1,x);let S;const $=[],I=i!=null,R=a!=null,_=g==="leakyrelu",O=()=>{const B=[s,o],M=(V,P)=>{if(P==="NCHW"&&V.shape.length===1&&V.shape[0]!==1){const re=Pe({inputs:{x:V},backend:n,attrs:{shape:[V.shape[0],1,1]}});return $.push(re),re}return V};if(I&&B.push(M(i,d)),R&&B.push(M(a,d)),_){const V=n.makeTensorInfo([],"float32",kd(y,"float32"));B.push(V),$.push(V)}return B};if(w.filterHeight===1&&w.filterWidth===1&&w.dilationHeight===1&&w.dilationWidth===1&&w.strideHeight===1&&w.strideWidth===1&&(w.padInfo.type==="SAME"||w.padInfo.type==="VALID"))S=YO({x:s,filter:o,convInfo:w,backend:n,bias:i,activation:g,preluActivationWeights:a,leakyreluAlpha:y});else if(w.strideWidth<=2&&x==="channelsLast"&&se().getBool("WEBGL_EXP_CONV")){const B=g?If(g,!0):null,M=new qO(w,I,B,R,_),V=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],P=O();S=n.runWebGLProgram(M,P,"float32",V)}else if(se().getBool("WEBGL_CONV_IM2COL"))S=QO({x:s,filter:o,convInfo:w,backend:n,bias:i,activation:g,preluActivationWeights:a,leakyreluAlpha:y});else{const B=g?If(g,!1):null,M=new XO(w,I,B,R,_),V=O();S=n.runWebGLProgram(M,V,"float32")}const F=Pe({inputs:{x:S},backend:n,attrs:{shape:w.outShape}});return $.push(S),$.forEach(B=>n.disposeIntermediateTensorInfo(B)),F}const phe={kernelName:wg,backendName:"webgl",kernelFunc:fhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mhe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=e,{strides:l,pad:c,dilations:d,dimRoundingMode:f,activation:p,leakyreluAlpha:g}=r,y=[];let x=d;x==null&&(x=[1,1]),z(Er(l,x),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${x}'`);const w=kn(s.shape,o.shape,l,x,c,f,!0),S=se().getBool("WEBGL_PACK_DEPTHWISECONV")&&w.strideWidth<=2&&w.outChannels/w.inChannels===1,$=p?If(p,S):null,I=[s,o],R=i!=null,_=a!=null,O=p==="leakyrelu";if(R&&I.push(i),_&&I.push(a),O){const V=n.makeTensorInfo([],"float32",kd(g,"float32"));I.push(V),y.push(V)}let F;S?F=new eF(w,R,$,_,O):F=new JO(w,R,$,_,O);const B=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],M=n.runWebGLProgram(F,I,"float32",B);return y.forEach(V=>n.disposeIntermediateTensorInfo(V)),M}const ghe={kernelName:Sg,backendName:"webgl",kernelFunc:mhe};let yhe=class{constructor(e,n,r,s){this.sliceDim=e,this.strides=n,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const o=Kt(r.length);let i=`
    int index;`;for(let a=0;a<this.sliceDim;a++)i+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${o} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xhe(t){const{inputs:e,backend:n}=t,{params:r,indices:s}=e,o=s.shape,i=o[o.length-1],a=pe(r.shape),[l,c,d,f]=tC(r,s),p=Pe({inputs:{x:s},backend:n,attrs:{shape:[c,i]}}),g=Pe({inputs:{x:r},backend:n,attrs:{shape:[pe(r.shape)/d,d]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const S=n.readSync(s.dataId),$=n.bufferSync(r),I=Sae(S,$,r.dtype,c,i,d,f,r.shape,a);return n.makeTensorInfo(l,r.dtype,I.values)}const y=new yhe(i,f,[c,d],r.shape),x=n.runWebGLProgram(y,[g,p],g.dtype),w=Pe({inputs:{x},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(x),w}const vhe={kernelName:o2,backendName:"webgl",kernelFunc:xhe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let bhe=class{constructor(e,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;const r=Kt(this.rank),s=whe(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${s}));
      }
    `}};function whe(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<t.length;s++)s===2?r.push("index"):r.push(`${n[s]}`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rF(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,indices:o}=e,{axis:i,batchDims:a}=r,l=nn(i,s.shape)[0];if(se().get("DEBUG")){const $=n.readSync(o.dataId),I=s.shape[l];for(let R=0;R<$.length;++R){const _=$[R];z(_<=I-1&&_>=0,()=>`GatherV2: the index value ${_} is not in [0, ${I-1}]`)}}const c=NC(s,o,l,a),d=pe(o.shape),f=[],p=Pe({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),g=Pe({inputs:{x:o},backend:n,attrs:{shape:[c.batchSize,d/c.batchSize]}});f.push(p),f.push(g);const y=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([s,o])||s.dtype==="string"){const $=n.bufferSync(g),I=n.bufferSync(p),R=Cae(I,$,y);return f.forEach(_=>n.disposeIntermediateTensorInfo(_)),n.makeTensorInfo(c.outputShape,R.dtype,R.values)}const x=new bhe(p.shape,y),w=n.runWebGLProgram(x,[p,g],p.dtype);f.push(w);const S=Pe({inputs:{x:w},backend:n,attrs:{shape:c.outputShape}});return f.forEach($=>n.disposeIntermediateTensorInfo($)),S}const She={kernelName:s2,backendName:"webgl",kernelFunc:rF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Che="return float(a > b);",$he=`
  return vec4(greaterThan(a, b));
`,khe=Zn({opSnippet:Che,packedOpSnippet:$he,cpuKernelImpl:$ae,dtype:"bool"}),The={kernelName:i2,backendName:"webgl",kernelFunc:khe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ihe="return float(a >= b);",Nhe=`
  return vec4(greaterThanEqual(a, b));
`,Ehe=Zn({opSnippet:Ihe,packedOpSnippet:Nhe,dtype:"bool",cpuKernelImpl:kae}),Rhe={kernelName:a2,backendName:"webgl",kernelFunc:Ehe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _he(t){const{inputs:e,backend:n}=t,{input:r}=e;return nF(r,!0,n)}const Phe={kernelName:l2,backendName:"webgl",kernelFunc:_he};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ahe="return float(!isnan(x) && !isinf(x));",Dhe=$t({opSnippet:Ahe,dtype:"bool"}),Ohe={kernelName:c2,backendName:"webgl",kernelFunc:Dhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fhe="return float(isinf(x));",Lhe=$t({opSnippet:Fhe,dtype:"bool"}),zhe={kernelName:d2,backendName:"webgl",kernelFunc:Lhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bhe="return float(isnan(x));",Mhe=$t({opSnippet:Bhe,dtype:"bool"}),Vhe={kernelName:h2,backendName:"webgl",kernelFunc:Mhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Whe="return float(a < b);",Uhe=`
  return vec4(lessThan(a, b));
`,jhe=Zn({opSnippet:Whe,packedOpSnippet:Uhe,cpuKernelImpl:Tae,dtype:"bool"}),Ghe={kernelName:p2,backendName:"webgl",kernelFunc:jhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hhe="return float(a <= b);",Khe=`
  return vec4(lessThanEqual(a, b));
`,Xhe=Zn({opSnippet:Hhe,packedOpSnippet:Khe,cpuKernelImpl:Iae,dtype:"bool"}),qhe={kernelName:m2,backendName:"webgl",kernelFunc:Xhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yhe(t){const{backend:e,attrs:n}=t,{start:r,stop:s,num:o}=n,i=Nae(r,s,o);return e.makeTensorInfo([i.length],"float32",i)}const Qhe={kernelName:g2,backendName:"webgl",kernelFunc:Yhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zhe=Ad+`
  return x < 0.0 ? 0./0. : log(x);
`,Jhe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,efe=$t({opSnippet:Zhe,packedOpSnippet:Jhe,cpuKernelImpl:Eae}),tfe={kernelName:y2,backendName:"webgl",kernelFunc:efe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nfe=Ad+`
  return log(1.0 + x);
`,rfe=$t({opSnippet:nfe}),sfe={kernelName:x2,backendName:"webgl",kernelFunc:rfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ofe="return float(a >= 1.0 && b >= 1.0);",ife=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,afe=Zn({opSnippet:ofe,packedOpSnippet:ife,dtype:"bool"}),lfe={kernelName:v2,backendName:"webgl",kernelFunc:afe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ufe="return float(!(x >= 1.0));",cfe=$t({opSnippet:ufe}),dfe={kernelName:b2,backendName:"webgl",kernelFunc:cfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hfe="return float(a >= 1.0 || b >= 1.0);",ffe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,pfe=Zn({opSnippet:hfe,packedOpSnippet:ffe,dtype:"bool"}),mfe={kernelName:w2,backendName:"webgl",kernelFunc:pfe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let gfe=class{constructor(e,n,r,s,o){this.variableNames=["x"],this.outputShape=[];const i=n,a=e[3]-1;this.outputShape=e;let l;const c=`float(${r}) + float(${s}) * sum`;o===.5?l=`inversesqrt(${c})`:o===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yfe{constructor(e,n,r,s,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=n,a=e[3]-1;this.outputShape=e;let l;const c=`float(${r}) + float(${s}) * sum`;o===.5?l=`inversesqrt(${c})`:o===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xfe=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{depthRadius:o,bias:i,alpha:a,beta:l}=r,c=se().getBool("WEBGL_PACK_NORMALIZATION")?new yfe(s.shape,o,i,a,l):new gfe(s.shape,o,i,a,l);return n.runWebGLProgram(c,[s],s.dtype)},vfe={kernelName:S2,backendName:"webgl",kernelFunc:xfe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let bfe=class{constructor(e,n,r,s,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=n,this.bias=r,this.alpha=s,this.beta=o,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${n})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${n} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s})
                * float(${o})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${o});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wfe=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s,y:o,dy:i}=e,{depthRadius:a,bias:l,alpha:c,beta:d}=r,f=new bfe(s.shape,a,l,c,d);return n.runWebGLProgram(f,[s,o,i],s.dtype)},Sfe={kernelName:rA,backendName:"webgl",kernelFunc:wfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cfe(t,e,n,r){const s=pe(e),i=pe(t.shape)/s,a=Pe({inputs:{x:t},attrs:{shape:[i,s]},backend:r}),l=Gu(a,t.dtype,"max",r),c=Pe({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sF(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reductionIndices:o,keepDims:i}=r,a=s.shape.length,l=nn(o,s.shape);let c=l;const d=ur(c,a),f=d!=null,p=n.shouldExecuteOnCPU([s]);let g=s;if(f){if(p){const I=n.texData.get(g.dataId).values,R=new Array(a);for(let F=0;F<R.length;F++)R[F]=s.shape[d[F]];const _=AC(I,s.shape,s.dtype,d,R);g=n.makeTensorInfo(R,s.dtype);const O=n.texData.get(g.dataId);O.values=_}else g=wy(s,d,n);c=cr(c.length,a)}bs("max",c,a);const[y,x]=Ls(g.shape,c);let w=y;i&&(w=vs(y,l));let S;if(p){const I=n.texData.get(g.dataId).values,R=Rae(I,pe(x),w,s.dtype);S=n.makeTensorInfo(w,s.dtype);const _=n.texData.get(S.dataId);_.values=R}else S=Cfe(g,x,w,n);return f&&n.disposeIntermediateTensorInfo(g),S}const $fe={kernelName:C2,backendName:"webgl",kernelFunc:sF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kfe=DC+`
  return max(a, b);
`,Tfe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+ju+`
  return result;
`,Ife=Zn({opSnippet:kfe,packedOpSnippet:Tfe,cpuKernelImpl:_ae}),Nfe={kernelName:$2,backendName:"webgl",kernelFunc:Ife};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Efe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;ep(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r,c=1;z(Er(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const d=fo(s.shape,o,i,c,a,l);if(d.filterWidth===1&&d.filterHeight===1&&Vt(d.inShape,d.outShape))return gs({inputs:{x:s},backend:n});const f=new Nf(d,"max",!1);return n.runWebGLProgram(f,[s],s.dtype)}const Rfe={kernelName:k2,backendName:"webgl",kernelFunc:Efe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _fe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:i,pad:a,dataFormat:l,dimRoundingMode:c}=r,d=[1,1,1],f=Sa(s.shape,o,i,d,a,c,l),p=new FC(f,"max",!1);return n.runWebGLProgram(p,[s],s.dtype)}const Pfe={kernelName:T2,backendName:"webgl",kernelFunc:_fe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Afe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,o=e.effectiveFilterHeight,i=e.effectiveFilterWidth,a=o-1-e.padInfo.top,l=i-1-e.padInfo.left,c=o*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
          wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},Dfe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideDepth,r=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,i=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterDepth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,f=l-1-e.padInfo.front,p=c-1-e.padInfo.top,g=d-1-e.padInfo.left,y=l*c*d-1;this.userCode=`
      const ivec3 pads = ivec3(${f}, ${p}, ${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${n}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${y} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${d} +
                  wR * ${d} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ofe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,i=o,{filterSize:a,strides:l,pad:c,dimRoundingMode:d}=r,f=[1,1,1],p=Sa(i.shape,a,l,f,c,d),g=new FC(p,"max",!0),y=n.runWebGLProgram(g,[i],i.dtype),x=new Dfe(p),w=n.runWebGLProgram(x,[s,y],i.dtype);return n.disposeIntermediateTensorInfo(y),w}const Ffe={kernelName:oA,backendName:"webgl",kernelFunc:Ofe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lfe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o,output:i}=e,a=o;ep([o,i],"maxPoolGrad");const{filterSize:l,strides:c,pad:d,dimRoundingMode:f}=r,p=fo(a.shape,l,c,1,d,f),g=!0,y=new Nf(p,"max",g),x=n.runWebGLProgram(y,[a],a.dtype),w=new Afe(p),S=n.runWebGLProgram(w,[s,x],a.dtype);return n.disposeIntermediateTensorInfo(x),S}const zfe={kernelName:sA,backendName:"webgl",kernelFunc:Lfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bfe(t,e,n,r){let s=new Nf(n,"max",!1);const o=r.runWebGLProgram(s,[t],"float32");s=new Nf(n,"max",!0,!0,e);const i=r.runWebGLProgram(s,[t],"float32");return[o,i]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mfe={kernelName:I2,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=e,l=n;z(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const c=[1,1];z(Er(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const d=fo(r.shape,s,o,c,i),[f,p]=Bfe(r,a,d,l);return[f,p]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vfe(t,e,n,r){const s=pe(e),i=pe(t.shape)/s,a=Pe({inputs:{x:t},attrs:{shape:[i,s]},backend:r}),l=Gu(a,"float32","mean",r),c=Pe({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wfe={kernelName:N2,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{keepDims:s,axis:o}=e,i=n,a=r.shape.length,l=nn(o,r.shape);let c=l;const d=ur(c,a),f=d!=null,p=i.shouldExecuteOnCPU([r]),g=[];let y=r;if(f){if(p){const R=i.texData.get(y.dataId).values,_=new Array(a);for(let B=0;B<_.length;B++)_[B]=r.shape[d[B]];const O=AC(R,r.shape,r.dtype,d,_);y=i.makeTensorInfo(_,r.dtype);const F=i.texData.get(y.dataId);F.values=O}else y=wy(r,d,i);g.push(y),c=cr(c.length,a)}bs("sum",c,a);const[x,w]=Ls(y.shape,c);let S=x;s&&(S=vs(x,l));const $=Vfe(y,w,S,i);for(const I of g)i.disposeIntermediateTensorInfo(I);return $}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ufe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,l=nn(o,s.shape);let c=l;const d=ur(c,a);let f=s;d!=null&&(f=Ir({inputs:{x:s},backend:n,attrs:{perm:d}}),c=cr(c.length,s.shape.length)),bs("min",c,a);const[p,g]=Ls(f.shape,c),y=pe(g),x=Pe({inputs:{x:f},backend:n,attrs:{shape:[-1,y]}}),w=Gu(x,x.dtype,"min",n);let S;if(i){const $=vs(p,l);S=Pe({inputs:{x:w},backend:n,attrs:{shape:$}})}else S=Pe({inputs:{x:w},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),d!=null&&n.disposeIntermediateTensorInfo(f),S}const jfe={kernelName:E2,backendName:"webgl",kernelFunc:Ufe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gfe=DC+`
  return min(a, b);
`,Hfe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+ju+`
  return result;
`,Kfe=Zn({opSnippet:Gfe,packedOpSnippet:Hfe,cpuKernelImpl:Pae}),Xfe={kernelName:R2,backendName:"webgl",kernelFunc:Kfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let qfe=class{constructor(e,n,r){this.variableNames=["x"],this.outputShape=n.map((d,f)=>d[0]+e[f]+d[1]);const s=e.length,o=Kt(s),i=n.map(d=>d[0]).join(","),a=n.map((d,f)=>d[0]+e[f]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),c=r==="reflect"?0:1;if(s===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${i});
      ${o} end = ${o}(${a});

      void main() {
        ${o} outC = getOutputCoords();
        for (int i = 0; i < ${s}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${o} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yfe{constructor(e,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((y,x)=>y[0]+e[x]+y[1]);const s=e.length,o=Kt(s),i=n.map(y=>y[0]).join(","),a=n.map((y,x)=>y[0]+e[x]).join(","),l=kr("rc",s),c=kr("source",s),d=`${l[s-1]} < ${this.outputShape[s-1]}`,f=s===1?"source":`vec2(${c.slice(-2).join()})`,p=r==="reflect"?0:1;let g="";if(s===1){const y=`
        ${o} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p};
        }
        source -= start;
      `;g=`
        ${o} rc = outputLoc;
        ${y}
        result[0] = getChannel(getX(${c.join()}), ${f});
        ${l[s-1]} += 1;
        if(${d}) {
          ${y}
          result[1] = getChannel(getX(${c.join()}), ${f});
        }
      `}else{const y=`
        ${o} source = rc;
        ${o} lt = ${o}(lessThan(source, start));
        ${o} gte = ${o}(greaterThanEqual(source, end));
        ${o} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p}) +
                gte * ((end - 1) * 2 - source + ${p});
        source -= start;
      `;g=`
        ${o} rc = outputLoc;
        ${y}
        result[0] = getChannel(getX(${c.join()}), ${f});
        ${l[s-1]} += 1;
        if(${d}) {
          ${y}
          result[1] = getChannel(getX(${c.join()}), ${f});
        }
        rc = outputLoc;
        ${l[s-2]} += 1;
        if(${l[s-2]} < ${this.outputShape[s-2]}) {
          ${y}
          result[2] = getChannel(getX(${c.join()}), ${f});
          ${l[s-1]} += 1;
          if(${d}) {
            ${y}
            result[3] = getChannel(getX(${c.join()}), ${f});
          }
        }
      `}this.userCode=`
      const ${o} start = ${o}(${i});
      const ${o} end = ${o}(${a});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qfe=({inputs:t,backend:e,attrs:n})=>{const{x:r}=t,{paddings:s,mode:o}=n,i=se().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Yfe(r.shape,s,o):new qfe(r.shape,s,o);return e.runWebGLProgram(i,[r],r.dtype)},Zfe={kernelName:_2,backendName:"webgl",kernelFunc:Qfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jfe=`if (b == 0.0) return NAN;
  return mod(a, b);`,epe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+ju+`
  return result;
`,tpe=Zn({opSnippet:Jfe,packedOpSnippet:epe}),npe={kernelName:P2,backendName:"webgl",kernelFunc:tpe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rpe=class{constructor(e,n,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${n-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${n-1}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const spe=`
if (a == b) {
  return 1.0;
};
return a / b;`,ope=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,oF=Zn({opSnippet:spe,packedOpSnippet:ope,checkOutOfBounds:!0}),ipe={kernelName:jw,backendName:"webgl",kernelFunc:oF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fN="return a - b;",iF=Zn({opSnippet:fN,packedOpSnippet:fN,supportsComplex:!0,cpuKernelImpl:Jae}),ape={kernelName:kS,backendName:"webgl",kernelFunc:iF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aF(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{dim:o}=r,i=nn([o],s.shape),a=sF({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=vs(a.shape,i),c=Pe({inputs:{x:a},backend:n,attrs:{shape:l}}),d=iF({inputs:{a:s,b:c},backend:n}),f=tF({inputs:{x:d},backend:n}),p=Sy({inputs:{x:f},backend:n,attrs:{axis:i,keepDims:!1}}),g=Pe({inputs:{x:p},backend:n,attrs:{shape:l}}),y=oF({inputs:{a:f,b:g},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g),y}const lpe={kernelName:xS,backendName:"webgl",kernelFunc:aF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function upe(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{numSamples:o,seed:i,normalized:a}=r,l=a?s:aF({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),c=l.shape[0],d=l.shape[1],f=new rpe(c,d,o),p=[[i]],g=n.runWebGLProgram(f,[l],"int32",p);return a||n.disposeIntermediateTensorInfo(l),g}const cpe={kernelName:A2,backendName:"webgl",kernelFunc:upe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dpe=mo+`
  return -x;
`,hpe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function fpe(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])){const o=n.texData.get(r.dataId),[i,a]=Dae(o.values,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,i)}let s;return se().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new ul(r.shape,hpe):s=new fi(r.shape,dpe),n.runWebGLProgram(s,[r],r.dtype)}const ppe={kernelName:O2,backendName:"webgl",kernelFunc:fpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mpe=qS;function gpe(t){Lo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r,c=n.readSync(s.dataId),d=n.readSync(o.dataId),{selectedIndices:f}=mpe(c,d,i,a,l);return n.makeTensorInfo([f.length],"int32",new Int32Array(f))}const ype={kernelName:L2,backendName:"webgl",kernelFunc:gpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xpe=zD;function vpe(t){Lo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r,d=n.readSync(s.dataId),f=n.readSync(o.dataId),{selectedIndices:p,validOutputs:g}=xpe(d,f,i,a,l,c);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([g]))]}const bpe={kernelName:iA,backendName:"webgl",kernelFunc:vpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wpe=YS;function Spe(t){Lo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r,d=n.readSync(s.dataId),f=n.readSync(o.dataId),p=i,g=a,y=l,x=c,{selectedIndices:w,selectedScores:S}=wpe(d,f,p,g,y,x);return[n.makeTensorInfo([w.length],"int32",new Int32Array(w)),n.makeTensorInfo([S.length],"float32",new Float32Array(S))]}const Cpe={kernelName:z2,backendName:"webgl",kernelFunc:Spe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let $pe=class{constructor(e,n,r,s){this.variableNames=["indices"],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s}), float(${r}),
                      float(index == coords.y)));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kpe=t=>{const{inputs:e,backend:n,attrs:r}=t,{indices:s}=e,{dtype:o,depth:i,onValue:a,offValue:l}=r,c=pe(s.shape),d=new $pe(c,i,a,l),f=Pe({inputs:{x:s},backend:n,attrs:{shape:[c]}}),p=n.runWebGLProgram(d,[f],o);n.disposeIntermediateTensorInfo(f);const g=[...s.shape,i],y=Pe({inputs:{x:p},backend:n,attrs:{shape:g}});return n.disposeIntermediateTensorInfo(p),y},Tpe={kernelName:M2,backendName:"webgl",kernelFunc:kpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dg(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="complex64"){const s=np({inputs:{input:r},backend:n}),o=Dg({inputs:{x:s},backend:n}),i=Cy({inputs:{input:r},backend:n}),a=Dg({inputs:{x:i},backend:n}),l=Il({inputs:{real:o,imag:a},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),l}else return rp({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}const Ipe={kernelName:PS,backendName:"webgl",kernelFunc:Dg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lF(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=np({inputs:{input:r},backend:n}),o=lF({inputs:{x:s},backend:n}),i=Cy({inputs:{input:r},backend:n}),a=Dg({inputs:{x:i},backend:n}),l=Il({inputs:{real:o,imag:a},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),l}else return rp({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}const Npe={kernelName:B2,backendName:"webgl",kernelFunc:lF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Epe(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r;if(e.length===1)return $v({inputs:{input:e[0]},backend:n,attrs:{dim:s}});const o=e[0].shape,i=e[0].dtype;e.forEach(d=>{xs(o,d.shape,"All tensors passed to stack must have matching shapes"),z(i===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(d=>{const f=$v({inputs:{input:d},backend:n,attrs:{dim:s}});return a.push(f),f}),c=KO({inputs:l,backend:n,attrs:{axis:s}});return a.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}const Rpe={kernelName:V2,backendName:"webgl",kernelFunc:Epe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let _pe=class{constructor(e,n,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((c,d)=>c[0]+e[d]+c[1]);const s=e.length,o=Kt(s),i=n.map(c=>c[0]).join(","),a=n.map((c,d)=>c[0]+e[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${i});
      ${o} end = ${o}(${a});

      void main() {
        ${o} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${o} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ppe{constructor(e,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((x,w)=>x[0]+e[w]+x[1]);const s=e.length,o=Kt(s),i=n.map(x=>x[0]).join(","),a=n.map((x,w)=>x[0]+e[w]).join(","),l=kr("rc",s),c=kr("source",s),d=`${l[s-1]} < ${this.outputShape[s-1]}`,f=s===1?"source":`vec2(${c.slice(-2).join()})`,p=[`${o} rc = outputLoc;`,`${l[s-1]} += 1;
       if(${d}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${l[s-2]} += 1;
       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${l[s-1]} += 1;
         if(${d}) {`],g=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let y="";for(let x=0,w=s===1?2:4;x<w;x++)y+=`
        ${p[x]}
        if (${g}) {
          result[${x}] = float(value);
        } else {
          ${o} source = rc - start;
          result[${x}] = getChannel(getX(${c.join()}), ${f});
        }
      `;y+=s===1?"} ":"}}",this.userCode=`
      const ${o} start = ${o}(${i});
      const ${o} end = ${o}(${a});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${y}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uF=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{paddings:o,constantValue:i}=r;if(pe(s.shape)===0){const c=o.map((d,f)=>d[0]+s.shape[f]+d[1]);return rp({backend:n,attrs:{shape:c,value:i,dtype:s.dtype}})}const a=se().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ppe(s.shape,o,i):new _pe(s.shape,o,i),l=[[i]];return n.runWebGLProgram(a,[s],s.dtype,l)},Ape={kernelName:W2,backendName:"webgl",kernelFunc:uF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dpe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Ope=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+ju+`
  return result;
`,Fpe=Zn({opSnippet:Dpe,packedOpSnippet:Ope}),Lpe={kernelName:U2,backendName:"webgl",kernelFunc:Fpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zpe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,l=[],c=nn(o,s.shape);let d=c;const f=ur(d,a);let p=s;f!=null&&(p=Ir({inputs:{x:s},backend:n,attrs:{perm:f}}),d=cr(d.length,a),l.push(p)),bs("prod",d,a);let g;if(n.shouldExecuteOnCPU([p])){const y=n.texData.get(p.dataId).values,{outVals:x,outShape:w,outDtype:S}=Fae(p.shape,p.dtype,y,d);g=n.makeTensorInfo(w,S,x)}else{const[y,x]=Ls(p.shape,d),w=pe(x),S=Pe({inputs:{x:p},backend:n,attrs:{shape:[-1,w]}}),$=ay(s.dtype),I=Gu(S,$,"prod",n);g=Pe({inputs:{x:I},backend:n,attrs:{shape:y}}),l.push(S),l.push(I)}if(i){l.push(g);const y=vs(g.shape,c);g=Pe({inputs:{x:g},backend:n,attrs:{shape:y}})}return l.forEach(y=>n.disposeIntermediateTensorInfo(y)),g}const Bpe={kernelName:G2,backendName:"webgl",kernelFunc:zpe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mpe(t){const{inputs:e,backend:n,attrs:r}=t,{paramsNestedSplits:s,paramsDenseValues:o,indices:i}=e,{outputRaggedRank:a}=r,l=s.map(S=>n.readSync(S.dataId)),c=s.map(S=>S.shape),d=n.readSync(o.dataId),f=n.readSync(i.dataId),[p,g,y]=Lae(l,c,d,o.shape,o.dtype,f,i.shape,a),x=p.map(S=>n.makeTensorInfo([S.length],"int32",S)),w=n.makeTensorInfo(y,o.dtype,g);return x.concat([w])}const Vpe={kernelName:aA,backendName:"webgl",kernelFunc:Mpe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wpe(t){const{inputs:e,backend:n}=t,{starts:r,limits:s,deltas:o}=e,i=n.readSync(r.dataId),a=n.readSync(s.dataId),l=n.readSync(o.dataId),[c,d]=zae(i,r.shape,r.dtype,a,s.shape,l,o.shape),f=n.makeTensorInfo([c.length],"int32",c),p=n.makeTensorInfo([d.length],r.dtype,d);return[f,p]}const Upe={kernelName:lA,backendName:"webgl",kernelFunc:Wpe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jpe(t){const{inputs:e,backend:n,attrs:r}=t,{shape:s,values:o,defaultValue:i,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=r,c=n.readSync(s.dataId),d=n.readSync(o.dataId),f=n.readSync(i.dataId),p=a.map(w=>n.readSync(w.dataId)),g=a.map(w=>w.shape),[y,x]=Bae(c,s.shape,d,o.shape,o.dtype,f,i.shape,p,g,l);return n.makeTensorInfo(y,o.dtype,x)}const Gpe={kernelName:uA,backendName:"webgl",kernelFunc:jpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cF=t=>{const{backend:e,attrs:n}=t,{start:r,stop:s,step:o,dtype:i}=n,a=Mae(r,s,o,i);return e.makeTensorInfo([a.length],i,a)},Hpe={kernelName:H2,backendName:"webgl",kernelFunc:cF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kpe="return 1.0 / x;",Xpe=$t({opSnippet:Kpe}),qpe={kernelName:X2,backendName:"webgl",kernelFunc:Xpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ype=mo+`
  return (x < 0.0) ? 0.0 : x;
`,Qpe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Zpe=$t({opSnippet:Ype,packedOpSnippet:Qpe}),Jpe={kernelName:q2,backendName:"webgl",kernelFunc:Zpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eme=mo+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,tme=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,nme=$t({opSnippet:eme,packedOpSnippet:tme}),rme={kernelName:J2,backendName:"webgl",kernelFunc:nme};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let sme=class{constructor(e,n,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,c]=e;this.outputShape=[i,n,r,c];const d=[s&&n>1?a-1:a,s&&r>1?l-1:l],f=[s&&n>1?n-1:n,s&&r>1?r-1:r];let p;o?p="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/f[0]},
          ${d[1]/f[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ome{constructor(e,n,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,c]=e;this.outputShape=[i,n,r,c];const d=[s&&n>1?a-1:a,s&&r>1?l-1:l],f=[s&&n>1?n-1:n,s&&r>1?r-1:r];let p;o?p="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/f[0]},
          ${d[1]/f[1]},
          ${d[1]/f[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ime(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,c]=a,d=se().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ome(s.shape,l,c,o,i):new sme(s.shape,l,c,o,i);return n.runWebGLProgram(d,[s],"float32")}const ame={kernelName:Z2,backendName:"webgl",kernelFunc:ime};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let lme=class{constructor(e,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,s,o]=n,[,i,a]=e,l=[r&&i>1?s-1:s,r&&a>1?o-1:o],c=[r&&i>1?i-1:i,r&&a>1?a-1:a],d=l[0]/c[0],f=l[1]/c[1],p=1/d,g=1/f,y=Math.ceil(p)*2+2,x=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${f});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${g});

        const int winHeight = int(${y});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ume(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:o}=e,{alignCorners:i}=r,a=new lme(o.shape,s.shape,i);return n.runWebGLProgram(a,[o],o.dtype)}const cme={kernelName:dA,backendName:"webgl",kernelFunc:ume};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let dme=class{constructor(e,n,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,c]=e;this.outputShape=[i,n,r,c];const d=[s&&n>1?a-1:a,s&&r>1?l-1:l],f=[s&&n>1?n-1:n,s&&r>1?r-1:r],p=s?"0.5":"0.0";let g;o?g="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":g="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/f[0]},
          ${d[1]/f[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${g};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hme{constructor(e,n,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,c]=e;this.outputShape=[i,n,r,c];const d=[s&&n>1?a-1:a,s&&r>1?l-1:l],f=[s&&n>1?n-1:n,s&&r>1?r-1:r],p=s?"0.5":"0.0";let g;o?g="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":g="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/f[0]},
          ${d[1]/f[1]},
          ${d[1]/f[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${g};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fme(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,c]=a,d=se().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new hme(s.shape,l,c,o,i):new dme(s.shape,l,c,o,i);return n.runWebGLProgram(d,[s],s.dtype)}const pme={kernelName:Q2,backendName:"webgl",kernelFunc:fme};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let mme=class{constructor(e,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,s,o]=n,[,i,a]=e,l=[r&&i>1?s-1:s,r&&a>1?o-1:o],c=[r&&i>1?i-1:i,r&&a>1?a-1:a],d=l[0]/c[0],f=l[1]/c[1],p=1/d,g=1/f,y=Math.ceil(p)*2+2,x=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${f});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${g});

        const int winHeight = int(${y});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${o}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gme(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:o}=e,{alignCorners:i}=r,a=new mme(o.shape,s.shape,i);return n.runWebGLProgram(a,[o],o.dtype)}const yme={kernelName:cA,backendName:"webgl",kernelFunc:gme};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let xme=class{constructor(e,n){this.variableNames=["x"];const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=e,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const s=a=>n.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,o=e.map((a,l)=>s(l)).join(","),i=Kt(r);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vme{constructor(e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=e;const s=kr("rc",r),o=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=Kt(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${o}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(s.slice())};
          if(${o}){
            result.g = ${c(s.slice())};
          }
          if(${i}) {
            result.b = ${d(s.slice())};
            if(${o}) {
              result.a = ${f(s.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(y){return p(y)}function c(y){return y[r-1]="("+y[r-1]+" + 1)",p(y)}function d(y){return y[r-2]="("+y[r-2]+" + 1)",p(y)}function f(y){return y[r-1]="("+y[r-1]+" + 1)",y[r-2]="("+y[r-2]+" + 1)",p(y)}function p(y){const x=e.map(($,I)=>g(I,y)),w=x.join(","),S=x.slice(-2).join(",");return`getChannel(getX(${w}), vec2(${S}))`}function g(y,x){return n.indexOf(y)!==-1&&e[y]!==1?`${e[y]} - ${x[y]} - 1`:`${x[y]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bme(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dims:o}=r,i=s.shape.length,a=nn(o,s.shape);if(i===0)return gs({inputs:{x:s},backend:n});const l=se().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new vme(s.shape,a):new xme(s.shape,a);return n.runWebGLProgram(l,[s],s.dtype)}const wme={kernelName:eS,backendName:"webgl",kernelFunc:bme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Sme=class{constructor(e,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=e[1],s=e[2];this.outputShape=e;let o="";typeof n=="number"?o=`float outputValue = ${n.toFixed(2)};`:o=`
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${o}
          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cme={kernelName:DS,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:s,fillValue:o,center:i}=e,a=n,l=new Sme(r.shape,o),[c,d]=cC(i,r.shape[1],r.shape[2]),f=[[c,d,Math.sin(s),Math.cos(s)]];return a.runWebGLProgram(l,[r],r.dtype,f)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $me=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,kme=$t({opSnippet:$me}),Tme={kernelName:tS,backendName:"webgl",kernelFunc:kme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ime="return inversesqrt(x);",Nme=$t({opSnippet:Ime,cpuKernelImpl:Vae}),Eme={kernelName:nS,backendName:"webgl",kernelFunc:Nme};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let LC=class{constructor(e,n,r,s,o,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const c=Kt(o.length),d=Kt(i.length);let f="";r===1?f="i":r===2&&(f="i, j");const p=`getIndices(${f})`;let g="";s===1?g="i":s===2&&(g="i, coords[1]");const y=`getUpdates(${g})`;let x="";l&&(x="coords[0], coords[1]");const w=`getDefaultValue(${x})`,S=n>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${o});

        void main() {
          ${d} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${n}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${S};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${y};
              found = true;
            }
          }
          setOutput(mix(${w}, sum, float(found)));
        }
      `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rme{constructor(e,n,r,s,o,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const c=Kt(o.length),d=Kt(i.length);let f="";r===1?f="i":r===2&&(f="i, j");const p=`getIndices(${f})`;let g="";s===1?g="i":s===2&&(g="i, coords[1]");const y=`getUpdates(${g})`;let x="";l&&(x="coords[0], coords[1]");const w=`getDefaultValue(${x})`,S=n>1?"strides[j]":"strides",$=n>1?"strides[j + 1]":"strides";this.userCode=`
        ${c} strides = ${c}(${o});

        void main() {
          ${d} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${n}; j+=2) {
              ivec4 index = round(${p});
              flattenedIndex += index.xz * ${S};
              if (j + 1 < ${n}) {
                flattenedIndex += index.yw * ${$};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${y};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${w}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _me(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s,updates:o}=e,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:d,outputSize:f}=Bu(o,s,i),p=[f/c,c];if(f===0)return n.makeTensorInfo(i,s.dtype);const g=Pe({inputs:{x:s},backend:n,attrs:{shape:[l,a]}}),y=Pe({inputs:{x:o},backend:n,attrs:{shape:[l,c]}}),x=n.makeTensorInfo([],"float32",new Float32Array([0]));let w;se().getBool("WEBGL_PACK")?w=new Rme(l,a,g.shape.length,y.shape.length,d,p):w=new LC(l,a,g.shape.length,y.shape.length,d,p);const S=n.runWebGLProgram(w,[y,g,x],y.dtype),$=Pe({inputs:{x:S},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(S),n.disposeIntermediateTensorInfo(x),$}const Pme={kernelName:rS,backendName:"webgl",kernelFunc:_me};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ame=class{constructor(e,n,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,r];const o="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(n+1))}; ++i) { if (left >= right) break;`,a=se().getNumber("WEBGL_VERSION")===2?o:i,l=s==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dme(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:s,values:o}=e,{side:i}=r,a=new Ame(s.shape[0],s.shape[1],o.shape[1],i),l=[[s.shape[1]]];return n.runWebGLProgram(a,[s,o],"int32",l)}const Ome={kernelName:oS,backendName:"webgl",kernelFunc:Dme};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Fme=class{constructor(e,n,r){this.variableNames=["c","a","b"],this.outputShape=n;let s,o;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)o="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let d=0;d<n.length;d++)c.push(`${a[d]}`),d<e&&l.push(`${a[d]}`);s=l.join(),o=c.join()}const i=Kt(r);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${s});
        if (cVal >= 1.0) {
          setOutput(getA(${o}));
        } else {
          setOutput(getB(${o}));
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lme(t){const{inputs:e,backend:n}=t,{condition:r,t:s,e:o}=e,i=new Fme(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,o],Gr(s.dtype,o.dtype))}const zme={kernelName:iS,backendName:"webgl",kernelFunc:Lme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bme=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${fC};
  float scale = ${pC};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Mme=$t({opSnippet:Bme}),Vme={kernelName:aS,backendName:"webgl",kernelFunc:Mme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wme=Ad+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Ume=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,jme=$t({opSnippet:Wme,packedOpSnippet:Ume,cpuKernelImpl:Uae}),Gme={kernelName:hS,backendName:"webgl",kernelFunc:jme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hme=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Kme=$t({opSnippet:Hme}),Xme={kernelName:dS,backendName:"webgl",kernelFunc:Kme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qme=Ad+`
  return sin(x);
`,Yme=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${ju}
  return result;
`,Qme=$t({opSnippet:qme,packedOpSnippet:Yme}),Zme={kernelName:uS,backendName:"webgl",kernelFunc:Qme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jme=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,ege=$t({opSnippet:Jme}),tge={kernelName:cS,backendName:"webgl",kernelFunc:ege};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nge=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,rge=$t({opSnippet:nge}),sge={kernelName:fS,backendName:"webgl",kernelFunc:rge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oge=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:o,paddings:i}=r;z(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((S,$)=>S*$),l=[[0,0]];l.push(...i);for(let S=1+o.length;S<s.shape.length;++S)l.push([0,0]);const c=[],d=uF({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),f=Yf(d.shape,o,a,!1),p=Qf(f.length,o.length,!1),g=Zf(d.shape,o,a,!1),y=Pe({inputs:{x:d},backend:n,attrs:{shape:f}}),x=Ir({inputs:{x:y},backend:n,attrs:{perm:p}}),w=Pe({inputs:{x},backend:n,attrs:{shape:g}});return c.push(d),c.push(y),c.push(x),c.forEach(S=>n.disposeIntermediateTensorInfo(S)),w},ige={kernelName:gS,backendName:"webgl",kernelFunc:oge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function age(t){const{inputs:e,backend:n}=t,{indices:r,values:s,denseShape:o,defaultValue:i}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${o.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const a=n.readSync(r.dataId),l=n.readSync(s.dataId),c=n.readSync(o.dataId),d=n.readSync(i.dataId)[0],[f,p,g,y,x]=Gae(a,r.shape,r.dtype,l,s.dtype,c,d);return[n.makeTensorInfo(p,r.dtype,f),n.makeTensorInfo([p[0]],s.dtype,g),n.makeTensorInfo([y.length],"bool",new Uint8Array(y.map(w=>Number(w)))),n.makeTensorInfo([x.length],r.dtype,new Int32Array(x))]}const lge={kernelName:hA,backendName:"webgl",kernelFunc:age};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uge(t){const{inputs:e,backend:n}=t,{inputIndices:r,inputShape:s,newShape:o}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(n.readSync(s.dataId)),a=n.readSync(r.dataId),l=Array.from(n.readSync(o.dataId)),[c,d,f]=Hae(a,r.shape,r.dtype,i,l);return[n.makeTensorInfo(d,r.dtype,c),n.makeTensorInfo([f.length],o.dtype,new Int32Array(f))]}const cge={kernelName:fA,backendName:"webgl",kernelFunc:uge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dge(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:o}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${o.shape}`);const i=n.readSync(r.dataId),a=n.readSync(s.dataId),l=n.readSync(o.dataId),[c,d]=DO(i,r.shape,r.dtype,a,l,!0);return n.makeTensorInfo(d,r.dtype,c)}const hge={kernelName:vS,backendName:"webgl",kernelFunc:dge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fge(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:o}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${o.shape}`);const i=n.readSync(r.dataId),a=n.readSync(s.dataId),l=n.readSync(o.dataId),[c,d]=DO(i,r.shape,r.dtype,a,l);return n.makeTensorInfo(d,r.dtype,c)}const pge={kernelName:bS,backendName:"webgl",kernelFunc:fge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mge(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:s,sparseValues:o,defaultValue:i}=e,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:d,strides:f,outputSize:p}=Bu(o,s,a),g=!1;if(o.dtype==="string"){const S=n.bufferSync(s),$=n.bufferSync(o),I=fa(n.readSync(i.dataId)[0]),R=Wae(S,$,a,p,d,c,l,f,I,g);return n.makeTensorInfo(a,R.dtype,R.values)}const y=new LC(c,l,s.shape.length,o.shape.length,f,[p,1],g),x=n.runWebGLProgram(y,[o,s,i],o.dtype),w=Pe({inputs:{x},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(x),w}const gge={kernelName:wS,backendName:"webgl",kernelFunc:mge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yge(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{numOrSizeSplits:o,axis:i}=r,a=nn(i,s.shape)[0],l=TC(s,o,a),c=s.shape.length,d=new Array(c).fill(0),f=s.shape.slice();return l.map(p=>{const g=[...f];g[a]=p;const y=Dd({inputs:{x:s},backend:n,attrs:{begin:d,size:g}});return d[a]+=p,y})}const xge={kernelName:yS,backendName:"webgl",kernelFunc:yge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pN="return sqrt(x);",vge=$t({opSnippet:pN,packedOpSnippet:pN,cpuKernelImpl:Kae}),bge={kernelName:pS,backendName:"webgl",kernelFunc:vge};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wge="return x * x;",Sge=$t({opSnippet:wge}),Cge={kernelName:pA,backendName:"webgl",kernelFunc:Sge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mN="return (a - b) * (a - b);",$ge=Zn({opSnippet:mN,packedOpSnippet:mN}),kge={kernelName:SS,backendName:"webgl",kernelFunc:$ge};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tge(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");const o=n.readSync(s.dataId),i=bl(o),a=Xae(i,"string",r);return n.makeTensorInfo(s.shape,"string",a)}const Ige={kernelName:mA,backendName:"webgl",kernelFunc:Tge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nge({inputs:t,attrs:e,backend:n}){const{x:r}=t,s=mo+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,o=new fi(r.shape,s);return n.runWebGLProgram(o,[r],r.dtype)}const Ege={kernelName:AS,backendName:"webgl",kernelFunc:Nge};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Rge=class{constructor(e,n,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,o=Kt(r.length),i=Kt(r.length);let a="";if(s===1)a="coords * strides + begin";else{let l=0;a=r.map((c,d)=>(l++,r.length===1?`coords * strides[${d}] + begin[${d}]`:`coords[${l-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`
      ${o} begin = ${o}(${e});
      ${o} strides = ${o}(${n});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ge(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:o,end:i,strides:a,beginMask:l,endMask:c,ellipsisMask:d,newAxisMask:f,shrinkAxisMask:p}=r,{finalShapeSparse:g,finalShape:y,isIdentity:x,sliceDim0:w,isSimpleSlice:S,begin:$,end:I,strides:R}=aC(s.shape,o,i,a,l,c,d,f,p);let _;if(x)_=Pe({inputs:{x:s},backend:n,attrs:{shape:y}});else if(w||S){z(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const F=rC($,I,R),B=Dd({inputs:{x:s},backend:n,attrs:{begin:$,size:F}});_=Pe({inputs:{x:B},backend:n,attrs:{shape:y}}),n.disposeIntermediateTensorInfo(B)}else if(n.shouldExecuteOnCPU([s])){const B=n.readSync(s.dataId),M=Wt(s.shape,s.dtype,B),V=qae(g,M,R,$);_=n.makeTensorInfo(y,s.dtype,V.values)}else{const B=new Rge($,R,g);_=n.runWebGLProgram(B,[s],s.dtype)}const O=Pe({inputs:{x:_},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(_),O}const Pge={kernelName:CS,backendName:"webgl",kernelFunc:_ge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Age(t){const{inputs:e,backend:n,attrs:r}=t,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:d,dataSplits:f}=e,p=n.readSync(d.dataId),g=n.readSync(f.dataId),[y,x]=Yae(p,g,s,o,i,a,l,c);return[n.makeTensorInfo([y.length],"string",y),n.makeTensorInfo(f.shape,"int32",x)]}const Dge={kernelName:$S,backendName:"webgl",kernelFunc:Age};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oge(t){const{inputs:e,backend:n,attrs:r}=t,{skipEmpty:s}=r,{input:o,delimiter:i}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=n.readSync(o.dataId),l=n.readSync(i.dataId)[0],[c,d,f]=Qae(a,l,s),p=d.length;return[n.makeTensorInfo([p,2],"int32",c),n.makeTensorInfo([p],"string",d),n.makeTensorInfo([2],"int32",new Int32Array(f))]}const Fge={kernelName:gA,backendName:"webgl",kernelFunc:Oge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lge(t){const{inputs:e,backend:n,attrs:r}=t,{numBuckets:s}=r,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(o.dataId),a=Zae(i,s);return n.makeTensorInfo(o.shape,"int32",a)}const zge={kernelName:yA,backendName:"webgl",kernelFunc:Lge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bge="return tan(x);",Mge=$t({opSnippet:Bge}),Vge={kernelName:TS,backendName:"webgl",kernelFunc:Mge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wge=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,Uge=$t({opSnippet:Wge}),jge={kernelName:IS,backendName:"webgl",kernelFunc:Uge};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gge(t){const{inputs:e,backend:n,attrs:r}=t,{tensor:s,indices:o,updates:i}=e,{sliceRank:a,numUpdates:l,sliceSize:c,strides:d,outputSize:f}=Bu(i,o,s.shape),p=[f/c,c];if(f===0)return n.makeTensorInfo(s.shape,o.dtype);const g=Pe({inputs:{x:o},backend:n,attrs:{shape:[l,a]}}),y=Pe({inputs:{x:i},backend:n,attrs:{shape:[l,c]}}),x=Pe({inputs:{x:s},backend:n,attrs:{shape:p}}),w=new LC(l,a,g.shape.length,y.shape.length,d,p,!1,!0),S=n.runWebGLProgram(w,[y,g,x],x.dtype),$=Pe({inputs:{x:S},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(S),$}const Hge={kernelName:sS,backendName:"webgl",kernelFunc:Gge};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Kge=class{constructor(e,n){this.variableNames=["A"];const r=new Array(e.length);for(let i=0;i<r.length;i++)r[i]=e[i]*n[i];this.outputShape=r,this.rank=r.length;const s=Kt(this.rank),o=Xge(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}};function Xge(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<t.length;s++)r.push(`imod(${n[s]}, ${t[s]})`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dF(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reps:o}=r;if(s.dtype==="string"||s.shape.length>5){const l=n.readSync(s.dataId),c=s.dtype==="string"?l.map(p=>fa(p)):l,d=Wt(s.shape,s.dtype,c),f=ele(d,o);return n.makeTensorInfo(f.shape,f.dtype,f.values)}const i=new Kge(s.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}const qge={kernelName:sy,backendName:"webgl",kernelFunc:dF};let Yge=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},Qge=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ou(t,e){e!==null&&t.disposeIntermediateTensorInfo(e)}function gN(t){let e=1;for(;e<t;)e*=2;return e}function Zge(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{k:o,sorted:i}=r,a=se().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=se().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=s.shape,d=c[c.length-1];if(n.shouldExecuteOnCPU([s])||d<a||o>l){const V=n.readSync(s.dataId),[P,re]=tle(V,c,s.dtype,o,i);return[n.makeTensorInfo(P.shape,P.dtype,P.values),n.makeTensorInfo(re.shape,re.dtype,re.values)]}if(o===0)return c[c.length-1]=0,[n.makeTensorInfo(c,s.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(d===1)return[s,rp({attrs:{shape:c,dtype:"int32",value:0},backend:n})];const f=n.texData.get(s.dataId),p=f!==null&&f.isPacked,g=p?n.unpackTensor(s):s,x=pe(c)/d,w=Pe({inputs:{x:g},attrs:{shape:[x,d]},backend:n});p&&ou(n,g);const S=gN(o),$=gN(d);let I=null;const R=()=>I===null?[w,w]:[w,I],_=(V,P,re)=>{const ie=R(),me=new Yge(re),ve=[[d],[I===null?1:0],[Number.NEGATIVE_INFINITY],[V],[P]],$e=I;I=n.runWebGLProgram(me,ie,"int32",ve),ou(n,$e)};for(let V=1;V<S;V*=2){const P=V*2;for(let re=V;re>=1;re/=2)_(P,re,[x,$])}for(let V=$;V>S;V/=2){const P=R(),re=new Qge([x,V/2]),me=[[d],[I===null?1:0],[S]],ge=I;I=n.runWebGLProgram(re,P,"int32",me),ou(n,ge);const ve=S/2,$e=ve*2;for(let fe=ve;fe>=1;fe/=2)_($e,fe,I.shape)}let O=I;I=Dd({inputs:{x:I},backend:n,attrs:{begin:0,size:[x,o]}}),ou(n,O);let F=rF({inputs:{x:w,indices:I},backend:n,attrs:{axis:1,batchDims:1}});ou(n,w);const B=c.slice(0,-1);B.push(o),O=I,I=Pe({inputs:{x:I},attrs:{shape:B},backend:n}),ou(n,O);const M=F;return F=Pe({inputs:{x:F},attrs:{shape:B},backend:n}),ou(n,M),[F,I]}const Jge={kernelName:NS,backendName:"webgl",kernelFunc:Zge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let eye=class{constructor(e,n,r,s,o,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a=r==="nearest"?1:2;let l;switch(s){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${n}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${o});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${o});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${n}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tye(t){const{inputs:e,backend:n,attrs:r}=t,{image:s,transforms:o}=e,{interpolation:i,fillMode:a,fillValue:l,outputShape:c}=r,[d,f,p,g]=s.shape,[y,x]=c??[f,p],w=[d,y,x,g],S=new eye(f,p,i,a,l,w);return n.runWebGLProgram(S,[s,o],"float32")}const nye={kernelName:ES,backendName:"webgl",kernelFunc:tye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rye(t){const{inputs:e,attrs:n,backend:r}=t,{axis:s}=n,{x:o}=e;ep(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(o.dataId),{outputValues:a,outputShape:l,indices:c}=nle(i,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}const sye={kernelName:xA,backendName:"webgl",kernelFunc:rye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oye(t){const{inputs:e,backend:n,attrs:r}=t,{value:s}=e;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s,a=i.shape.length,l=s.shape[o],c=new Array(a-1);let d=0;for(let x=0;x<a;x++)x!==o&&(c[d++]=i.shape[x]);const f=[],p=new Array(a).fill(0),g=i.shape.slice();g[o]=1;const y=new Array(l);for(let x=0;x<y.length;x++){p[o]=x;const w=Dd({inputs:{x:i},backend:n,attrs:{begin:p,size:g}}),S=Pe({inputs:{x:w},backend:n,attrs:{shape:c}});y[x]=S,f.push(w)}return f.forEach(x=>n.disposeIntermediateTensorInfo(x)),y}const iye={kernelName:RS,backendName:"webgl",kernelFunc:oye};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aye{constructor(e,n){this.variableNames=["x","segmentIds"];const r=e.windowSize,s=e.batchSize,o=e.inSize,i=e.numSegments,a=i*Math.ceil(o/r);this.outputShape=[s,a];const l="0.0",c="sumValue",d=Math.floor(r/4)*4,f=r%4,p=`
        sumValue += dot(values, segFilter);
    `;let g="";o%r>0&&(g=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `);let y="";o%r>0&&(y=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${g}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${y}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${p}
        }

        int inIdx = inOffset + ${d};
        if (${f===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${p}
        } else if (${f===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${p}
        } else if (${f===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${p}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lye(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,segmentIds:o}=e,{numSegments:i}=r,a=s.shape.length,l=[];let c=0;const d=ur([c],a);let f=s;d!=null&&(f=Ir({inputs:{x:s},backend:n,attrs:{perm:d}}),l.push(f),c=cr(1,a)[0]);const p=IC(f.shape,c,i),g=pe([f.shape[c]]),y=Pe({inputs:{x:f},backend:n,attrs:{shape:[-1,g]}});l.push(y);const x=ay(s.dtype),w=(R,_,O,F,B)=>{const M=R.shape[0],V=R.shape[1],P=gO(V,B),re={windowSize:P,inSize:V,batchSize:M,numSegments:B},ie=new aye(re,_),me=n.compileAndRun(ie,[R,O],F);if(l.push(me),me.shape[1]===B)return me;const ge=cF({backend:n,attrs:{start:0,stop:B,step:1,dtype:"float32"}}),ve=dF({inputs:{x:ge},backend:n,attrs:{reps:[V/P]}});return l.push(ge),l.push(ve),w(me,_,ve,F,B)},S=w(y,"unsortedSegmentSum",o,x,i),$=Pe({inputs:{x:S},backend:n,attrs:{shape:p}});let I=$;if(d!=null){l.push($);const R=qf(d);I=Ir({inputs:{x:I},backend:n,attrs:{perm:R}})}return l.forEach(R=>n.disposeIntermediateTensorInfo(R)),I}const uye={kernelName:_S,backendName:"webgl",kernelFunc:lye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cye=[Kle,qle,Zle,tue,rue,iue,lue,cue,pue,gue,vue,Sue,kue,Eue,Pue,Due,Fue,Mue,Wue,jue,Xue,tce,rce,ace,uce,mce,yce,wce,Rle,$ce,Ece,Ace,Bce,Wce,jce,Hce,Xce,Zce,tde,sde,ide,lde,cde,fde,mde,vde,wde,$de,Ide,Ede,Ade,Lde,Vde,jde,Kde,Xde,Yde,Zde,ehe,nhe,she,lhe,dhe,phe,ghe,vhe,She,The,Rhe,Ele,Phe,Ice,Ohe,zhe,Vhe,Ple,Ghe,qhe,Qhe,tfe,sfe,lfe,dfe,mfe,vfe,Sfe,$fe,Nfe,Rfe,Pfe,Ffe,zfe,Mfe,Wfe,jfe,Xfe,Zfe,npe,cpe,Ole,ppe,ype,bpe,Cpe,dce,Tpe,Npe,Rpe,Ape,Lpe,Dle,Bpe,Vpe,Upe,Gpe,Hpe,hce,ipe,qpe,Jpe,rme,Lle,ame,cme,pme,yme,wme,Cme,Tme,Eme,Pme,Ome,zme,Vme,Gme,Xme,Zme,tge,Jue,lpe,sge,ige,lge,cge,hge,pge,gge,xge,bge,Cge,kge,Ige,Ege,Pge,Dge,Fge,zge,ape,jle,Vge,jge,Hge,qge,Jge,nye,Gle,sye,iye,uye,Ipe];for(const t of cye)vA(t);var nx={},yN;function dye(){return yN||(yN=1,(function(){var t;function e(v){var k=0;return function(){return k<v.length?{done:!1,value:v[k++]}:{done:!0}}}var n=typeof Object.defineProperties=="function"?Object.defineProperty:function(v,k,E){return v==Array.prototype||v==Object.prototype||(v[k]=E.value),v};function r(v){v=[typeof globalThis=="object"&&globalThis,v,typeof window=="object"&&window,typeof self=="object"&&self,typeof Pc=="object"&&Pc];for(var k=0;k<v.length;++k){var E=v[k];if(E&&E.Math==Math)return E}throw Error("Cannot find global object")}var s=r(this);function o(v,k){if(k)e:{var E=s;v=v.split(".");for(var A=0;A<v.length-1;A++){var W=v[A];if(!(W in E))break e;E=E[W]}v=v[v.length-1],A=E[v],k=k(A),k!=A&&k!=null&&n(E,v,{configurable:!0,writable:!0,value:k})}}o("Symbol",function(v){function k(G){if(this instanceof k)throw new TypeError("Symbol is not a constructor");return new E(A+(G||"")+"_"+W++,G)}function E(G,j){this.h=G,n(this,"description",{configurable:!0,writable:!0,value:j})}if(v)return v;E.prototype.toString=function(){return this.h};var A="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",W=0;return k}),o("Symbol.iterator",function(v){if(v)return v;v=Symbol("Symbol.iterator");for(var k="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),E=0;E<k.length;E++){var A=s[k[E]];typeof A=="function"&&typeof A.prototype[v]!="function"&&n(A.prototype,v,{configurable:!0,writable:!0,value:function(){return i(e(this))}})}return v});function i(v){return v={next:v},v[Symbol.iterator]=function(){return this},v}function a(v){var k=typeof Symbol<"u"&&Symbol.iterator&&v[Symbol.iterator];return k?k.call(v):{next:e(v)}}function l(v){if(!(v instanceof Array)){v=a(v);for(var k,E=[];!(k=v.next()).done;)E.push(k.value);v=E}return v}var c=typeof Object.assign=="function"?Object.assign:function(v,k){for(var E=1;E<arguments.length;E++){var A=arguments[E];if(A)for(var W in A)Object.prototype.hasOwnProperty.call(A,W)&&(v[W]=A[W])}return v};o("Object.assign",function(v){return v||c});var d=typeof Object.create=="function"?Object.create:function(v){function k(){}return k.prototype=v,new k},f;if(typeof Object.setPrototypeOf=="function")f=Object.setPrototypeOf;else{var p;e:{var g={a:!0},y={};try{y.__proto__=g,p=y.a;break e}catch{}p=!1}f=p?function(v,k){if(v.__proto__=k,v.__proto__!==k)throw new TypeError(v+" is not extensible");return v}:null}var x=f;function w(v,k){if(v.prototype=d(k.prototype),v.prototype.constructor=v,x)x(v,k);else for(var E in k)if(E!="prototype")if(Object.defineProperties){var A=Object.getOwnPropertyDescriptor(k,E);A&&Object.defineProperty(v,E,A)}else v[E]=k[E];v.za=k.prototype}function S(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function $(v){if(v.m)throw new TypeError("Generator is already running");v.m=!0}S.prototype.u=function(v){this.i=v};function I(v,k){v.l={ma:k,na:!0},v.h=v.s||v.v}S.prototype.return=function(v){this.l={return:v},this.h=this.v};function R(v,k,E){return v.h=E,{value:k}}function _(v){this.h=new S,this.i=v}function O(v,k){$(v.h);var E=v.h.j;return E?F(v,"return"in E?E.return:function(A){return{value:A,done:!0}},k,v.h.return):(v.h.return(k),B(v))}function F(v,k,E,A){try{var W=k.call(v.h.j,E);if(!(W instanceof Object))throw new TypeError("Iterator result "+W+" is not an object");if(!W.done)return v.h.m=!1,W;var G=W.value}catch(j){return v.h.j=null,I(v.h,j),B(v)}return v.h.j=null,A.call(v.h,G),B(v)}function B(v){for(;v.h.h;)try{var k=v.i(v.h);if(k)return v.h.m=!1,{value:k.value,done:!1}}catch(E){v.h.i=void 0,I(v.h,E)}if(v.h.m=!1,v.h.l){if(k=v.h.l,v.h.l=null,k.na)throw k.ma;return{value:k.return,done:!0}}return{value:void 0,done:!0}}function M(v){this.next=function(k){return $(v.h),v.h.j?k=F(v,v.h.j.next,k,v.h.u):(v.h.u(k),k=B(v)),k},this.throw=function(k){return $(v.h),v.h.j?k=F(v,v.h.j.throw,k,v.h.u):(I(v.h,k),k=B(v)),k},this.return=function(k){return O(v,k)},this[Symbol.iterator]=function(){return this}}function V(v){function k(A){return v.next(A)}function E(A){return v.throw(A)}return new Promise(function(A,W){function G(j){j.done?A(j.value):Promise.resolve(j.value).then(k,E).then(G,W)}G(v.next())})}function P(v){return V(new M(new _(v)))}o("Promise",function(v){function k(j){this.i=0,this.j=void 0,this.h=[],this.u=!1;var Z=this.l();try{j(Z.resolve,Z.reject)}catch(ce){Z.reject(ce)}}function E(){this.h=null}function A(j){return j instanceof k?j:new k(function(Z){Z(j)})}if(v)return v;E.prototype.i=function(j){if(this.h==null){this.h=[];var Z=this;this.j(function(){Z.m()})}this.h.push(j)};var W=s.setTimeout;E.prototype.j=function(j){W(j,0)},E.prototype.m=function(){for(;this.h&&this.h.length;){var j=this.h;this.h=[];for(var Z=0;Z<j.length;++Z){var ce=j[Z];j[Z]=null;try{ce()}catch(Ce){this.l(Ce)}}}this.h=null},E.prototype.l=function(j){this.j(function(){throw j})},k.prototype.l=function(){function j(Ce){return function(_e){ce||(ce=!0,Ce.call(Z,_e))}}var Z=this,ce=!1;return{resolve:j(this.I),reject:j(this.m)}},k.prototype.I=function(j){if(j===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(j instanceof k)this.L(j);else{e:switch(typeof j){case"object":var Z=j!=null;break e;case"function":Z=!0;break e;default:Z=!1}Z?this.F(j):this.s(j)}},k.prototype.F=function(j){var Z=void 0;try{Z=j.then}catch(ce){this.m(ce);return}typeof Z=="function"?this.M(Z,j):this.s(j)},k.prototype.m=function(j){this.v(2,j)},k.prototype.s=function(j){this.v(1,j)},k.prototype.v=function(j,Z){if(this.i!=0)throw Error("Cannot settle("+j+", "+Z+"): Promise already settled in state"+this.i);this.i=j,this.j=Z,this.i===2&&this.K(),this.H()},k.prototype.K=function(){var j=this;W(function(){if(j.D()){var Z=s.console;typeof Z<"u"&&Z.error(j.j)}},1)},k.prototype.D=function(){if(this.u)return!1;var j=s.CustomEvent,Z=s.Event,ce=s.dispatchEvent;return typeof ce>"u"?!0:(typeof j=="function"?j=new j("unhandledrejection",{cancelable:!0}):typeof Z=="function"?j=new Z("unhandledrejection",{cancelable:!0}):(j=s.document.createEvent("CustomEvent"),j.initCustomEvent("unhandledrejection",!1,!0,j)),j.promise=this,j.reason=this.j,ce(j))},k.prototype.H=function(){if(this.h!=null){for(var j=0;j<this.h.length;++j)G.i(this.h[j]);this.h=null}};var G=new E;return k.prototype.L=function(j){var Z=this.l();j.T(Z.resolve,Z.reject)},k.prototype.M=function(j,Z){var ce=this.l();try{j.call(Z,ce.resolve,ce.reject)}catch(Ce){ce.reject(Ce)}},k.prototype.then=function(j,Z){function ce(He,Ae){return typeof He=="function"?function(Ke){try{Ce(He(Ke))}catch(ft){_e(ft)}}:Ae}var Ce,_e,Ze=new k(function(He,Ae){Ce=He,_e=Ae});return this.T(ce(j,Ce),ce(Z,_e)),Ze},k.prototype.catch=function(j){return this.then(void 0,j)},k.prototype.T=function(j,Z){function ce(){switch(Ce.i){case 1:j(Ce.j);break;case 2:Z(Ce.j);break;default:throw Error("Unexpected state: "+Ce.i)}}var Ce=this;this.h==null?G.i(ce):this.h.push(ce),this.u=!0},k.resolve=A,k.reject=function(j){return new k(function(Z,ce){ce(j)})},k.race=function(j){return new k(function(Z,ce){for(var Ce=a(j),_e=Ce.next();!_e.done;_e=Ce.next())A(_e.value).T(Z,ce)})},k.all=function(j){var Z=a(j),ce=Z.next();return ce.done?A([]):new k(function(Ce,_e){function Ze(Ke){return function(ft){He[Ke]=ft,Ae--,Ae==0&&Ce(He)}}var He=[],Ae=0;do He.push(void 0),Ae++,A(ce.value).T(Ze(He.length-1),_e),ce=Z.next();while(!ce.done)})},k});function re(v,k){v instanceof String&&(v+="");var E=0,A=!1,W={next:function(){if(!A&&E<v.length){var G=E++;return{value:k(G,v[G]),done:!1}}return A=!0,{done:!0,value:void 0}}};return W[Symbol.iterator]=function(){return W},W}o("Array.prototype.keys",function(v){return v||function(){return re(this,function(k){return k})}}),o("Array.prototype.fill",function(v){return v||function(k,E,A){var W=this.length||0;for(0>E&&(E=Math.max(0,W+E)),(A==null||A>W)&&(A=W),A=Number(A),0>A&&(A=Math.max(0,W+A)),E=Number(E||0);E<A;E++)this[E]=k;return this}});function ie(v){return v||Array.prototype.fill}o("Int8Array.prototype.fill",ie),o("Uint8Array.prototype.fill",ie),o("Uint8ClampedArray.prototype.fill",ie),o("Int16Array.prototype.fill",ie),o("Uint16Array.prototype.fill",ie),o("Int32Array.prototype.fill",ie),o("Uint32Array.prototype.fill",ie),o("Float32Array.prototype.fill",ie),o("Float64Array.prototype.fill",ie),o("Object.is",function(v){return v||function(k,E){return k===E?k!==0||1/k===1/E:k!==k&&E!==E}}),o("Array.prototype.includes",function(v){return v||function(k,E){var A=this;A instanceof String&&(A=String(A));var W=A.length;for(E=E||0,0>E&&(E=Math.max(E+W,0));E<W;E++){var G=A[E];if(G===k||Object.is(G,k))return!0}return!1}}),o("String.prototype.includes",function(v){return v||function(k,E){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(k instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(k,E||0)!==-1}});var me=this||self;function ge(v,k){v=v.split(".");var E=me;v[0]in E||typeof E.execScript>"u"||E.execScript("var "+v[0]);for(var A;v.length&&(A=v.shift());)v.length||k===void 0?E[A]&&E[A]!==Object.prototype[A]?E=E[A]:E=E[A]={}:E[A]=k}function ve(v){var k;e:{if((k=me.navigator)&&(k=k.userAgent))break e;k=""}return k.indexOf(v)!=-1}var $e=Array.prototype.map?function(v,k){return Array.prototype.map.call(v,k,void 0)}:function(v,k){for(var E=v.length,A=Array(E),W=typeof v=="string"?v.split(""):v,G=0;G<E;G++)G in W&&(A[G]=k.call(void 0,W[G],G,v));return A},fe={},xe=null;function ae(v){var k=v.length,E=3*k/4;E%3?E=Math.floor(E):"=.".indexOf(v[k-1])!=-1&&(E="=.".indexOf(v[k-2])!=-1?E-2:E-1);var A=new Uint8Array(E),W=0;return q(v,function(G){A[W++]=G}),W!==E?A.subarray(0,W):A}function q(v,k){function E(ce){for(;A<v.length;){var Ce=v.charAt(A++),_e=xe[Ce];if(_e!=null)return _e;if(!/^[\s\xa0]*$/.test(Ce))throw Error("Unknown base64 encoding at char: "+Ce)}return ce}ue();for(var A=0;;){var W=E(-1),G=E(0),j=E(64),Z=E(64);if(Z===64&&W===-1)break;k(W<<2|G>>4),j!=64&&(k(G<<4&240|j>>2),Z!=64&&k(j<<6&192|Z))}}function ue(){if(!xe){xe={};for(var v="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),k=["+/=","+/","-_=","-_.","-_"],E=0;5>E;E++){var A=v.concat(k[E].split(""));fe[E]=A;for(var W=0;W<A.length;W++){var G=A[W];xe[G]===void 0&&(xe[G]=W)}}}}var we=typeof Uint8Array<"u",Ge=!(ve("Trident")||ve("MSIE"))&&typeof me.btoa=="function";function et(v){if(!Ge){var k;k===void 0&&(k=0),ue(),k=fe[k];for(var E=Array(Math.floor(v.length/3)),A=k[64]||"",W=0,G=0;W<v.length-2;W+=3){var j=v[W],Z=v[W+1],ce=v[W+2],Ce=k[j>>2];j=k[(j&3)<<4|Z>>4],Z=k[(Z&15)<<2|ce>>6],ce=k[ce&63],E[G++]=Ce+j+Z+ce}switch(Ce=0,ce=A,v.length-W){case 2:Ce=v[W+1],ce=k[(Ce&15)<<2]||A;case 1:v=v[W],E[G]=k[v>>2]+k[(v&3)<<4|Ce>>4]+ce+A}return E.join("")}for(k="";10240<v.length;)k+=String.fromCharCode.apply(null,v.subarray(0,10240)),v=v.subarray(10240);return k+=String.fromCharCode.apply(null,v),btoa(k)}var tt=RegExp("[-_.]","g");function Tt(v){switch(v){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function dt(v){if(!Ge)return ae(v);tt.test(v)&&(v=v.replace(tt,Tt)),v=atob(v);for(var k=new Uint8Array(v.length),E=0;E<v.length;E++)k[E]=v.charCodeAt(E);return k}var vt;function rn(){return vt||(vt=new Uint8Array(0))}var _r={},ki=typeof Uint8Array.prototype.slice=="function",zt=0,sn=0;function Pr(v){var k=0>v;v=Math.abs(v);var E=v>>>0;v=Math.floor((v-E)/4294967296),k&&(E=a(Ia(E,v)),k=E.next().value,v=E.next().value,E=k),zt=E>>>0,sn=v>>>0}var Vo=typeof BigInt=="function";function Ia(v,k){return k=~k,v?v=~v+1:k+=1,[v,k]}function El(v,k){this.i=v>>>0,this.h=k>>>0}function Na(v){if(!v)return ws||(ws=new El(0,0));if(!/^-?\d+$/.test(v))return null;if(16>v.length)Pr(Number(v));else if(Vo)v=BigInt(v),zt=Number(v&BigInt(4294967295))>>>0,sn=Number(v>>BigInt(32)&BigInt(4294967295));else{var k=+(v[0]==="-");sn=zt=0;for(var E=v.length,A=k,W=(E-k)%6+k;W<=E;A=W,W+=6)A=Number(v.slice(A,W)),sn*=1e6,zt=1e6*zt+A,4294967296<=zt&&(sn+=zt/4294967296|0,zt%=4294967296);k&&(k=a(Ia(zt,sn)),v=k.next().value,k=k.next().value,zt=v,sn=k)}return new El(zt,sn)}var ws;function Ss(v,k){return Error("Invalid wire type: "+v+" (at position "+k+")")}function Bs(){return Error("Failed to read varint, encoding is invalid.")}function qr(v,k){return Error("Tried to read past the end of the data "+k+" > "+v)}function Cs(){throw Error("Invalid UTF8")}function Ea(v,k){return k=String.fromCharCode.apply(null,k),v==null?k:v+k}var Ti=void 0,Ii,go=typeof TextDecoder<"u",Ra,Wo=typeof TextEncoder<"u",yo;function Rl(v){if(v!==_r)throw Error("illegal external caller")}function Uo(v,k){if(Rl(k),this.V=v,v!=null&&v.length===0)throw Error("ByteString should be constructed with non-empty values")}function _a(){return yo||(yo=new Uo(null,_r))}function Ms(v){Rl(_r);var k=v.V;return k=k==null||we&&k!=null&&k instanceof Uint8Array?k:typeof k=="string"?dt(k):null,k==null?k:v.V=k}function jo(v){if(typeof v=="string")return{buffer:dt(v),C:!1};if(Array.isArray(v))return{buffer:new Uint8Array(v),C:!1};if(v.constructor===Uint8Array)return{buffer:v,C:!1};if(v.constructor===ArrayBuffer)return{buffer:new Uint8Array(v),C:!1};if(v.constructor===Uo)return{buffer:Ms(v)||rn(),C:!0};if(v instanceof Uint8Array)return{buffer:new Uint8Array(v.buffer,v.byteOffset,v.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function Pa(v,k){this.i=null,this.m=!1,this.h=this.j=this.l=0,Go(this,v,k)}function Go(v,k,E){E=E===void 0?{}:E,v.S=E.S===void 0?!1:E.S,k&&(k=jo(k),v.i=k.buffer,v.m=k.C,v.l=0,v.j=v.i.length,v.h=v.l)}Pa.prototype.reset=function(){this.h=this.l};function $s(v,k){if(v.h=k,k>v.j)throw qr(v.j,k)}function Vs(v){var k=v.i,E=v.h,A=k[E++],W=A&127;if(A&128&&(A=k[E++],W|=(A&127)<<7,A&128&&(A=k[E++],W|=(A&127)<<14,A&128&&(A=k[E++],W|=(A&127)<<21,A&128&&(A=k[E++],W|=A<<28,A&128&&k[E++]&128&&k[E++]&128&&k[E++]&128&&k[E++]&128&&k[E++]&128)))))throw Bs();return $s(v,E),W}function Ar(v,k){if(0>k)throw Error("Tried to read a negative byte length: "+k);var E=v.h,A=E+k;if(A>v.j)throw qr(k,v.j-E);return v.h=A,E}var xo=[];function Yr(){this.h=[]}Yr.prototype.length=function(){return this.h.length},Yr.prototype.end=function(){var v=this.h;return this.h=[],v};function _l(v,k,E){for(;0<E||127<k;)v.h.push(k&127|128),k=(k>>>7|E<<25)>>>0,E>>>=7;v.h.push(k)}function Ws(v,k){for(;127<k;)v.h.push(k&127|128),k>>>=7;v.h.push(k)}function Aa(v,k){if(xo.length){var E=xo.pop();Go(E,v,k),v=E}else v=new Pa(v,k);this.h=v,this.j=this.h.h,this.i=this.l=-1,this.setOptions(k)}Aa.prototype.setOptions=function(v){v=v===void 0?{}:v,this.ca=v.ca===void 0?!1:v.ca},Aa.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};function Pl(v){var k=v.h;if(k.h==k.j)return!1;v.j=v.h.h;var E=Vs(v.h)>>>0;if(k=E>>>3,E&=7,!(0<=E&&5>=E))throw Ss(E,v.j);if(1>k)throw Error("Invalid field number: "+k+" (at position "+v.j+")");return v.l=k,v.i=E,!0}function Ho(v){switch(v.i){case 0:if(v.i!=0)Ho(v);else e:{v=v.h;for(var k=v.h,E=k+10,A=v.i;k<E;)if((A[k++]&128)===0){$s(v,k);break e}throw Bs()}break;case 1:v=v.h,$s(v,v.h+8);break;case 2:v.i!=2?Ho(v):(k=Vs(v.h)>>>0,v=v.h,$s(v,v.h+k));break;case 5:v=v.h,$s(v,v.h+4);break;case 3:k=v.l;do{if(!Pl(v))throw Error("Unmatched start-group tag: stream EOF");if(v.i==4){if(v.l!=k)throw Error("Unmatched end-group tag");break}Ho(v)}while(!0);break;default:throw Ss(v.i,v.j)}}var er=[];function Ni(){this.j=[],this.i=0,this.h=new Yr}function Us(v,k){k.length!==0&&(v.j.push(k),v.i+=k.length)}function Ei(v,k){if(k=k.R){Us(v,v.h.end());for(var E=0;E<k.length;E++)Us(v,Ms(k[E])||rn())}}var ks=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol():void 0;function Dr(v,k){return ks?v[ks]|=k:v.A!==void 0?v.A|=k:(Object.defineProperties(v,{A:{value:k,configurable:!0,writable:!0,enumerable:!1}}),k)}function Qr(v,k){ks?v[ks]&&(v[ks]&=~k):v.A!==void 0&&(v.A&=~k)}function Xt(v){var k;return ks?k=v[ks]:k=v.A,k??0}function hr(v,k){ks?v[ks]=k:v.A!==void 0?v.A=k:Object.defineProperties(v,{A:{value:k,configurable:!0,writable:!0,enumerable:!1}})}function Al(v){return Dr(v,1),v}function zd(v,k){hr(k,(v|0)&-51)}function Da(v,k){hr(k,(v|18)&-41)}var Bn={};function Ri(v){return v!==null&&typeof v=="object"&&!Array.isArray(v)&&v.constructor===Object}var Ko,qu=[];hr(qu,23),Ko=Object.freeze(qu);function Oa(v){if(Xt(v.o)&2)throw Error("Cannot mutate an immutable Message")}function Fa(v){var k=v.length;(k=k?v[k-1]:void 0)&&Ri(k)?k.g=1:(k={},v.push((k.g=1,k)))}function Dl(v){var k=v.i+v.G;return v.B||(v.B=v.o[k]={})}function Mn(v,k){return k===-1?null:k>=v.i?v.B?v.B[k]:void 0:v.o[k+v.G]}function Zr(v,k,E,A){Oa(v),js(v,k,E,A)}function js(v,k,E,A){v.j&&(v.j=void 0),k>=v.i||A?Dl(v)[k]=E:(v.o[k+v.G]=E,(v=v.B)&&k in v&&delete v[k])}function Ut(v,k,E,A){var W=Mn(v,k);Array.isArray(W)||(W=Ko);var G=Xt(W);if(G&1||Al(W),A)G&2||Dr(W,2),E&1||Object.freeze(W);else{A=!(E&2);var j=G&2;E&1||!j?A&&G&16&&!j&&Qr(W,16):(W=Al(Array.prototype.slice.call(W)),js(v,k,W))}return W}function Ol(v,k){var E=Mn(v,k),A=E==null?E:typeof E=="number"||E==="NaN"||E==="Infinity"||E==="-Infinity"?Number(E):void 0;return A!=null&&A!==E&&js(v,k,A),A}function vo(v,k,E,A,W){v.h||(v.h={});var G=v.h[E],j=Ut(v,E,3,W);if(!G){var Z=j;G=[];var ce=!!(Xt(v.o)&16);j=!!(Xt(Z)&2);var Ce=Z;!W&&j&&(Z=Array.prototype.slice.call(Z));for(var _e=j,Ze=0;Ze<Z.length;Ze++){var He=Z[Ze],Ae=k,Ke=!1;if(Ke=Ke===void 0?!1:Ke,He=Array.isArray(He)?new Ae(He):Ke?new Ae:void 0,He!==void 0){Ae=He.o;var ft=Ke=Xt(Ae);j&&(ft|=2),ce&&(ft|=16),ft!=Ke&&hr(Ae,ft),Ae=ft,_e=_e||!!(2&Ae),G.push(He)}}return v.h[E]=G,ce=Xt(Z),k=ce|33,k=_e?k&-9:k|8,ce!=k&&(_e=Z,Object.isFrozen(_e)&&(_e=Array.prototype.slice.call(_e)),hr(_e,k),Z=_e),Ce!==Z&&js(v,E,Z),(W||A&&j)&&Dr(G,2),A&&Object.freeze(G),G}return W||(W=Object.isFrozen(G),A&&!W?Object.freeze(G):!A&&W&&(G=Array.prototype.slice.call(G),v.h[E]=G)),G}function _i(v,k,E){var A=!!(Xt(v.o)&2);if(k=vo(v,k,E,A,A),v=Ut(v,E,3,A),!(A||Xt(v)&8)){for(A=0;A<k.length;A++){if(E=k[A],Xt(E.o)&2){var W=Oi(E,!1);W.j=E}else W=E;E!==W&&(k[A]=W,v[A]=W.o)}Dr(v,8)}return k}function tr(v,k,E){if(E!=null&&typeof E!="number")throw Error("Value of float/double field must be a number|null|undefined, found "+typeof E+": "+E);Zr(v,k,E)}function Yu(v,k,E,A,W){Oa(v);var G=vo(v,E,k,!1,!1);return E=A??new E,v=Ut(v,k,2,!1),W!=null?(G.splice(W,0,E),v.splice(W,0,E.o)):(G.push(E),v.push(E.o)),E.C()&&Qr(v,8),E}function Pi(v,k){return v??k}function Vn(v,k,E){return E=E===void 0?0:E,Pi(Ol(v,k),E)}var nr;function Bd(v){switch(typeof v){case"number":return isFinite(v)?v:String(v);case"object":if(v)if(Array.isArray(v)){if((Xt(v)&128)!==0)return v=Array.prototype.slice.call(v),Fa(v),v}else{if(we&&v!=null&&v instanceof Uint8Array)return et(v);if(v instanceof Uo){var k=v.V;return k==null?"":typeof k=="string"?k:v.V=et(k)}}}return v}function fr(v,k,E,A){if(v!=null){if(Array.isArray(v))v=Fl(v,k,E,A!==void 0);else if(Ri(v)){var W={},G;for(G in v)W[G]=fr(v[G],k,E,A);v=W}else v=k(v,A);return v}}function Fl(v,k,E,A){var W=Xt(v);A=A?!!(W&16):void 0,v=Array.prototype.slice.call(v);for(var G=0;G<v.length;G++)v[G]=fr(v[G],k,E,A);return E(W,v),v}function Md(v){return v.ja===Bn?v.toJSON():Bd(v)}function Vd(v,k){v&128&&Fa(k)}function Ai(v,k,E){if(E=E===void 0?Da:E,v!=null){if(we&&v instanceof Uint8Array)return v.length?new Uo(new Uint8Array(v),_r):_a();if(Array.isArray(v)){var A=Xt(v);return A&2?v:k&&!(A&32)&&(A&16||A===0)?(hr(v,A|2),v):(v=Fl(v,Ai,A&4?Da:E,!0),k=Xt(v),k&4&&k&2&&Object.freeze(v),v)}return v.ja===Bn?Xo(v):v}}function Di(v,k,E,A,W,G,j){if(v=v.h&&v.h[E]){if(A=Xt(v),A&2?A=v:(G=$e(v,Xo),Da(A,G),Object.freeze(G),A=G),Oa(k),j=A==null?Ko:Al([]),A!=null){for(G=!!A.length,v=0;v<A.length;v++){var Z=A[v];G=G&&!(Xt(Z.o)&2),j[v]=Z.o}G=(G?8:0)|1,v=Xt(j),(v&G)!==G&&(Object.isFrozen(j)&&(j=Array.prototype.slice.call(j)),hr(j,v|G)),k.h||(k.h={}),k.h[E]=A}else k.h&&(k.h[E]=void 0);js(k,E,j,W)}else Zr(k,E,Ai(A,G,j),W)}function Xo(v){return Xt(v.o)&2||(v=Oi(v,!0),Dr(v.o,2)),v}function Oi(v,k){var E=v.o,A=[];Dr(A,16);var W=v.constructor.h;if(W&&A.push(W),W=v.B,W){A.length=E.length,A.fill(void 0,A.length,E.length);var G={};A[A.length-1]=G}(Xt(E)&128)!==0&&Fa(A),k=k||v.C()?Da:zd,G=v.constructor,nr=A,A=new G(A),nr=void 0,v.R&&(A.R=v.R.slice()),G=!!(Xt(E)&16);for(var j=W?E.length-1:E.length,Z=0;Z<j;Z++)Di(v,A,Z-v.G,E[Z],!1,G,k);if(W)for(var ce in W)Di(v,A,+ce,W[ce],!0,G,k);return A}function wn(v,k,E){v==null&&(v=nr),nr=void 0;var A=this.constructor.i||0,W=0<A,G=this.constructor.h,j=!1;if(v==null){v=G?[G]:[];var Z=48,ce=!0;W&&(A=0,Z|=128),hr(v,Z)}else{if(!Array.isArray(v)||G&&G!==v[0])throw Error();var Ce=Z=Dr(v,0);if((ce=(16&Ce)!==0)&&((j=(32&Ce)!==0)||(Ce|=32)),W){if(128&Ce)A=0;else if(0<v.length){var _e=v[v.length-1];if(Ri(_e)&&"g"in _e){A=0,Ce|=128,delete _e.g;var Ze=!0,He;for(He in _e){Ze=!1;break}Ze&&v.pop()}}}else if(128&Ce)throw Error();Z!==Ce&&hr(v,Ce)}this.G=(G?0:-1)-A,this.h=void 0,this.o=v;e:{if(G=this.o.length,A=G-1,G&&(G=this.o[A],Ri(G))){this.B=G,this.i=A-this.G;break e}k!==void 0&&-1<k?(this.i=Math.max(k,A+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE}if(!W&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(E){k=ce&&!j&&!0,W=this.i;var Ae;for(ce=0;ce<E.length;ce++)j=E[ce],j<W?(j+=this.G,(A=v[j])?La(A,k):v[j]=Ko):(Ae||(Ae=Dl(this)),(A=Ae[j])?La(A,k):Ae[j]=Ko)}}wn.prototype.toJSON=function(){return Fl(this.o,Md,Vd)},wn.prototype.C=function(){return!!(Xt(this.o)&2)};function La(v,k){if(Array.isArray(v)){var E=Xt(v),A=1;!k||E&2||(A|=16),(E&A)!==A&&hr(v,E|A)}}wn.prototype.ja=Bn,wn.prototype.toString=function(){return this.o.toString()};function za(v,k,E){if(E){var A={},W;for(W in E){var G=E[W],j=G.ra;j||(A.J=G.xa||G.oa.W,G.ia?(A.aa=Ba(G.ia),j=function(Z){return function(ce,Ce,_e){return Z.J(ce,Ce,_e,Z.aa)}}(A)):G.ka?(A.Z=Bi(G.da.P,G.ka),j=function(Z){return function(ce,Ce,_e){return Z.J(ce,Ce,_e,Z.Z)}}(A)):j=A.J,G.ra=j),j(k,v,G.da),A={J:A.J,aa:A.aa,Z:A.Z}}}Ei(k,v)}var Fi=Symbol();function Li(v,k,E){return v[Fi]||(v[Fi]=function(A,W){return k(A,W,E)})}function qo(v){var k=v[Fi];if(!k){var E=ts(v);k=function(A,W){return ns(A,W,E)},v[Fi]=k}return k}function Wd(v){var k=v.ia;if(k)return qo(k);if(k=v.wa)return Li(v.da.P,k,v.ka)}function Ll(v){var k=Wd(v),E=v.da,A=v.oa.U;return k?function(W,G){return A(W,G,E,k)}:function(W,G){return A(W,G,E)}}function St(v,k){var E=v[k];return typeof E=="function"&&E.length===0&&(E=E(),v[k]=E),Array.isArray(E)&&(Wn in E||Yo in E||0<E.length&&typeof E[0]=="function")?E:void 0}function zl(v,k,E,A,W,G){k.P=v[0];var j=1;if(v.length>j&&typeof v[j]!="number"){var Z=v[j++];E(k,Z)}for(;j<v.length;){E=v[j++];for(var ce=j+1;ce<v.length&&typeof v[ce]!="number";)ce++;switch(Z=v[j++],ce-=j,ce){case 0:A(k,E,Z);break;case 1:(ce=St(v,j))?(j++,W(k,E,Z,ce)):A(k,E,Z,v[j++]);break;case 2:ce=j++,ce=St(v,ce),W(k,E,Z,ce,v[j++]);break;case 3:G(k,E,Z,v[j++],v[j++],v[j++]);break;case 4:G(k,E,Z,v[j++],v[j++],v[j++],v[j++]);break;default:throw Error("unexpected number of binary field arguments: "+ce)}}return k}var zi=Symbol();function Ba(v){var k=v[zi];if(!k){var E=pr(v);k=function(A,W){return Ju(A,W,E)},v[zi]=k}return k}function Bi(v,k){var E=v[zi];return E||(E=function(A,W){return za(A,W,k)},v[zi]=E),E}var Yo=Symbol();function Qu(v,k){v.push(k)}function Bl(v,k,E){v.push(k,E.W)}function bo(v,k,E,A){var W=Ba(A),G=pr(A).P,j=E.W;v.push(k,function(Z,ce,Ce){return j(Z,ce,Ce,G,W)})}function Jr(v,k,E,A,W,G){var j=Bi(A,G),Z=E.W;v.push(k,function(ce,Ce,_e){return Z(ce,Ce,_e,A,j)})}function pr(v){var k=v[Yo];return k||(k=zl(v,v[Yo]=[],Qu,Bl,bo,Jr),Wn in v&&Yo in v&&(v.length=0),k)}var Wn=Symbol();function Mi(v,k){v[0]=k}function Qo(v,k,E,A){var W=E.U;v[k]=A?function(G,j,Z){return W(G,j,Z,A)}:W}function es(v,k,E,A,W){var G=E.U,j=qo(A),Z=ts(A).P;v[k]=function(ce,Ce,_e){return G(ce,Ce,_e,Z,j,W)}}function Zu(v,k,E,A,W,G,j){var Z=E.U,ce=Li(A,W,G);v[k]=function(Ce,_e,Ze){return Z(Ce,_e,Ze,A,ce,j)}}function ts(v){var k=v[Wn];return k||(k=zl(v,v[Wn]={},Mi,Qo,es,Zu),Wn in v&&Yo in v&&(v.length=0),k)}function ns(v,k,E){for(;Pl(k)&&k.i!=4;){var A=k.l,W=E[A];if(!W){var G=E[0];G&&(G=G[A])&&(W=E[A]=Ll(G))}if(!W||!W(k,v,A)){W=k,A=v,G=W.j,Ho(W);var j=W;if(!j.ca){if(W=j.h.h-G,j.h.h=G,j=j.h,W==0)W=_a();else{if(G=Ar(j,W),j.S&&j.m)W=j.i.subarray(G,G+W);else{j=j.i;var Z=G;W=G+W,W=Z===W?rn():ki?j.slice(Z,W):new Uint8Array(j.subarray(Z,W))}W=W.length==0?_a():new Uo(W,_r)}(G=A.R)?G.push(W):A.R=[W]}}}return v}function Ju(v,k,E){for(var A=E.length,W=A%2==1,G=W?1:0;G<A;G+=2)(0,E[G+1])(k,v,E[G]);za(v,k,W?E[0]:void 0)}function wo(v,k){return{U:v,W:k}}var Un=wo(function(v,k,E){if(v.i!==5)return!1;v=v.h;var A=v.i,W=v.h,G=A[W],j=A[W+1],Z=A[W+2];return A=A[W+3],$s(v,v.h+4),j=(G<<0|j<<8|Z<<16|A<<24)>>>0,v=2*(j>>31)+1,G=j>>>23&255,j&=8388607,Zr(k,E,G==255?j?NaN:1/0*v:G==0?v*Math.pow(2,-149)*j:v*Math.pow(2,G-150)*(j+Math.pow(2,23))),!0},function(v,k,E){if(k=Ol(k,E),k!=null){Ws(v.h,8*E+5),v=v.h;var A=+k;A===0?0<1/A?zt=sn=0:(sn=0,zt=2147483648):isNaN(A)?(sn=0,zt=2147483647):(A=(E=0>A?-2147483648:0)?-A:A,34028234663852886e22<A?(sn=0,zt=(E|2139095040)>>>0):11754943508222875e-54>A?(A=Math.round(A/Math.pow(2,-149)),sn=0,zt=(E|A)>>>0):(k=Math.floor(Math.log(A)/Math.LN2),A*=Math.pow(2,-k),A=Math.round(8388608*A),16777216<=A&&++k,sn=0,zt=(E|k+127<<23|A&8388607)>>>0)),E=zt,v.h.push(E>>>0&255),v.h.push(E>>>8&255),v.h.push(E>>>16&255),v.h.push(E>>>24&255)}}),Ml=wo(function(v,k,E){if(v.i!==0)return!1;var A=v.h,W=0,G=v=0,j=A.i,Z=A.h;do{var ce=j[Z++];W|=(ce&127)<<G,G+=7}while(32>G&&ce&128);for(32<G&&(v|=(ce&127)>>4),G=3;32>G&&ce&128;G+=7)ce=j[Z++],v|=(ce&127)<<G;if($s(A,Z),128>ce)A=W>>>0,ce=v>>>0,(v=ce&2147483648)&&(A=~A+1>>>0,ce=~ce>>>0,A==0&&(ce=ce+1>>>0)),A=4294967296*ce+(A>>>0);else throw Bs();return Zr(k,E,v?-A:A),!0},function(v,k,E){k=Mn(k,E),k!=null&&(typeof k=="string"&&Na(k),k!=null&&(Ws(v.h,8*E),typeof k=="number"?(v=v.h,Pr(k),_l(v,zt,sn)):(E=Na(k),_l(v.h,E.i,E.h))))}),Ud=wo(function(v,k,E){return v.i!==0?!1:(Zr(k,E,Vs(v.h)),!0)},function(v,k,E){if(k=Mn(k,E),k!=null&&k!=null)if(Ws(v.h,8*E),v=v.h,E=k,0<=E)Ws(v,E);else{for(k=0;9>k;k++)v.h.push(E&127|128),E>>=7;v.h.push(1)}}),Zo=wo(function(v,k,E){if(v.i!==2)return!1;var A=Vs(v.h)>>>0;v=v.h;var W=Ar(v,A);if(v=v.i,go){var G=v,j;(j=Ii)||(j=Ii=new TextDecoder("utf-8",{fatal:!0})),v=W+A,G=W===0&&v===G.length?G:G.subarray(W,v);try{var Z=j.decode(G)}catch(Ze){if(Ti===void 0){try{j.decode(new Uint8Array([128]))}catch{}try{j.decode(new Uint8Array([97])),Ti=!0}catch{Ti=!1}}throw!Ti&&(Ii=void 0),Ze}}else{Z=W,A=Z+A,W=[];for(var ce=null,Ce,_e;Z<A;)Ce=v[Z++],128>Ce?W.push(Ce):224>Ce?Z>=A?Cs():(_e=v[Z++],194>Ce||(_e&192)!==128?(Z--,Cs()):W.push((Ce&31)<<6|_e&63)):240>Ce?Z>=A-1?Cs():(_e=v[Z++],(_e&192)!==128||Ce===224&&160>_e||Ce===237&&160<=_e||((G=v[Z++])&192)!==128?(Z--,Cs()):W.push((Ce&15)<<12|(_e&63)<<6|G&63)):244>=Ce?Z>=A-2?Cs():(_e=v[Z++],(_e&192)!==128||(Ce<<28)+(_e-144)>>30!==0||((G=v[Z++])&192)!==128||((j=v[Z++])&192)!==128?(Z--,Cs()):(Ce=(Ce&7)<<18|(_e&63)<<12|(G&63)<<6|j&63,Ce-=65536,W.push((Ce>>10&1023)+55296,(Ce&1023)+56320))):Cs(),8192<=W.length&&(ce=Ea(ce,W),W.length=0);Z=Ea(ce,W)}return Zr(k,E,Z),!0},function(v,k,E){if(k=Mn(k,E),k!=null){var A=!1;if(A=A===void 0?!1:A,Wo){if(A&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(k))throw Error("Found an unpaired surrogate");k=(Ra||(Ra=new TextEncoder)).encode(k)}else{for(var W=0,G=new Uint8Array(3*k.length),j=0;j<k.length;j++){var Z=k.charCodeAt(j);if(128>Z)G[W++]=Z;else{if(2048>Z)G[W++]=Z>>6|192;else{if(55296<=Z&&57343>=Z){if(56319>=Z&&j<k.length){var ce=k.charCodeAt(++j);if(56320<=ce&&57343>=ce){Z=1024*(Z-55296)+ce-56320+65536,G[W++]=Z>>18|240,G[W++]=Z>>12&63|128,G[W++]=Z>>6&63|128,G[W++]=Z&63|128;continue}else j--}if(A)throw Error("Found an unpaired surrogate");Z=65533}G[W++]=Z>>12|224,G[W++]=Z>>6&63|128}G[W++]=Z&63|128}}k=W===G.length?G:G.subarray(0,W)}Ws(v.h,8*E+2),Ws(v.h,k.length),Us(v,v.h.end()),Us(v,k)}}),So=wo(function(v,k,E,A,W){if(v.i!==2)return!1;k=Yu(k,E,A),E=v.h.j,A=Vs(v.h)>>>0;var G=v.h.h+A,j=G-E;if(0>=j&&(v.h.j=G,W(k,v,void 0,void 0,void 0),j=G-v.h.h),j)throw Error("Message parsing ended unexpectedly. Expected to read "+(A+" bytes, instead read "+(A-j)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return v.h.h=G,v.h.j=E,!0},function(v,k,E,A,W){if(k=_i(k,A,E),k!=null)for(A=0;A<k.length;A++){var G=v;Ws(G.h,8*E+2);var j=G.h.end();Us(G,j),j.push(G.i),G=j,W(k[A],v),j=v;var Z=G.pop();for(Z=j.i+j.h.length()-Z;127<Z;)G.push(Z&127|128),Z>>>=7,j.i++;G.push(Z),j.i++}});function Gs(v){return function(k,E){e:{if(er.length){var A=er.pop();A.setOptions(E),Go(A.h,k,E),k=A}else k=new Aa(k,E);try{var W=ts(v),G=ns(new W.P,k,W);break e}finally{W=k.h,W.i=null,W.m=!1,W.l=0,W.j=0,W.h=0,W.S=!1,k.l=-1,k.i=-1,100>er.length&&er.push(k)}G=void 0}return G}}function U(v){return function(){var k=new Ni;Ju(this,k,pr(v)),Us(k,k.h.end());for(var E=new Uint8Array(k.i),A=k.j,W=A.length,G=0,j=0;j<W;j++){var Z=A[j];E.set(Z,G),G+=Z.length}return k.j=[E],E}}function ee(v){wn.call(this,v)}w(ee,wn);var he=[ee,1,Ud,2,Un,3,Zo,4,Zo];ee.prototype.l=U(he);function Fe(v){wn.call(this,v,-1,ht)}w(Fe,wn),Fe.prototype.addClassification=function(v,k){return Yu(this,1,ee,v,k),this};var ht=[1],It=Gs([Fe,1,So,he]);function Nt(v){wn.call(this,v)}w(Nt,wn);var at=[Nt,1,Un,2,Un,3,Un,4,Un,5,Un];Nt.prototype.l=U(at);function _t(v){wn.call(this,v,-1,jn)}w(_t,wn);var jn=[1],Gn=Gs([_t,1,So,at]);function Or(v){wn.call(this,v)}w(Or,wn);var Co=[Or,1,Un,2,Un,3,Un,4,Un,5,Un,6,Ml],Ma=Gs(Co);Or.prototype.l=U(Co);function Rn(v,k,E){if(E=v.createShader(E===0?v.VERTEX_SHADER:v.FRAGMENT_SHADER),v.shaderSource(E,k),v.compileShader(E),!v.getShaderParameter(E,v.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+v.getShaderInfoLog(E));return E}function Va(v){return _i(v,ee,1).map(function(k){var E=Mn(k,1);return{index:E??0,qa:Vn(k,2),label:Mn(k,3)!=null?Pi(Mn(k,3),""):void 0,displayName:Mn(k,4)!=null?Pi(Mn(k,4),""):void 0}})}function jd(v){return{x:Vn(v,1),y:Vn(v,2),z:Vn(v,3),visibility:Ol(v,4)!=null?Vn(v,4):void 0}}function Vi(v){return _i(Gn(v),Nt,1).map(jd)}function Gd(v,k){this.i=v,this.h=k,this.m=0}function ec(v,k,E){return Hd(v,k),typeof v.h.canvas.transferToImageBitmap=="function"?Promise.resolve(v.h.canvas.transferToImageBitmap()):E?Promise.resolve(v.h.canvas):typeof createImageBitmap=="function"?createImageBitmap(v.h.canvas):(v.j===void 0&&(v.j=document.createElement("canvas")),new Promise(function(A){v.j.height=v.h.canvas.height,v.j.width=v.h.canvas.width,v.j.getContext("2d",{}).drawImage(v.h.canvas,0,0,v.h.canvas.width,v.h.canvas.height),A(v.j)}))}function Hd(v,k){var E=v.h;if(v.s===void 0){var A=Rn(E,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),W=Rn(E,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),G=E.createProgram();if(E.attachShader(G,A),E.attachShader(G,W),E.linkProgram(G),!E.getProgramParameter(G,E.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+E.getProgramInfoLog(G));A=v.s=G,E.useProgram(A),W=E.getUniformLocation(A,"sampler0"),v.l={O:E.getAttribLocation(A,"aVertex"),N:E.getAttribLocation(A,"aTex"),ya:W},v.v=E.createBuffer(),E.bindBuffer(E.ARRAY_BUFFER,v.v),E.enableVertexAttribArray(v.l.O),E.vertexAttribPointer(v.l.O,2,E.FLOAT,!1,0,0),E.bufferData(E.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),E.STATIC_DRAW),E.bindBuffer(E.ARRAY_BUFFER,null),v.u=E.createBuffer(),E.bindBuffer(E.ARRAY_BUFFER,v.u),E.enableVertexAttribArray(v.l.N),E.vertexAttribPointer(v.l.N,2,E.FLOAT,!1,0,0),E.bufferData(E.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),E.STATIC_DRAW),E.bindBuffer(E.ARRAY_BUFFER,null),E.uniform1i(W,0)}A=v.l,E.useProgram(v.s),E.canvas.width=k.width,E.canvas.height=k.height,E.viewport(0,0,k.width,k.height),E.activeTexture(E.TEXTURE0),v.i.bindTexture2d(k.glName),E.enableVertexAttribArray(A.O),E.bindBuffer(E.ARRAY_BUFFER,v.v),E.vertexAttribPointer(A.O,2,E.FLOAT,!1,0,0),E.enableVertexAttribArray(A.N),E.bindBuffer(E.ARRAY_BUFFER,v.u),E.vertexAttribPointer(A.N,2,E.FLOAT,!1,0,0),E.bindFramebuffer(E.DRAW_FRAMEBUFFER?E.DRAW_FRAMEBUFFER:E.FRAMEBUFFER,null),E.clearColor(0,0,0,0),E.clear(E.COLOR_BUFFER_BIT),E.colorMask(!0,!0,!0,!0),E.drawArrays(E.TRIANGLE_FAN,0,4),E.disableVertexAttribArray(A.O),E.disableVertexAttribArray(A.N),E.bindBuffer(E.ARRAY_BUFFER,null),v.i.bindTexture2d(0)}function Vl(v){this.h=v}var tc=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function op(v,k){return k+v}function ip(v,k){window[v]=k}function Ny(v){var k=document.createElement("script");return k.setAttribute("src",v),k.setAttribute("crossorigin","anonymous"),new Promise(function(E){k.addEventListener("load",function(){E()},!1),k.addEventListener("error",function(){E()},!1),document.body.appendChild(k)})}function Ey(){return P(function(v){switch(v.h){case 1:return v.s=2,R(v,WebAssembly.instantiate(tc),4);case 4:v.h=3,v.s=0;break;case 2:return v.s=0,v.l=null,v.return(!1);case 3:return v.return(!0)}})}function Wl(v){if(this.h=v,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=v&&v.locateFile||op,typeof window=="object")var k=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")k=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.ha=k,v.options){k=a(Object.keys(v.options));for(var E=k.next();!E.done;E=k.next()){E=E.value;var A=v.options[E].default;A!==void 0&&(this.l[E]=typeof A=="function"?A():A)}}}t=Wl.prototype,t.close=function(){return this.j&&this.j.delete(),Promise.resolve()};function Ry(v){var k,E,A,W,G,j,Z,ce,Ce,_e,Ze;return P(function(He){switch(He.h){case 1:return v.ga?(k=v.h.files===void 0?[]:typeof v.h.files=="function"?v.h.files(v.l):v.h.files,R(He,Ey(),2)):He.return();case 2:if(E=He.i,typeof window=="object")return ip("createMediapipeSolutionsWasm",{locateFile:v.locateFile}),ip("createMediapipeSolutionsPackedAssets",{locateFile:v.locateFile}),j=k.filter(function(Ae){return Ae.data!==void 0}),Z=k.filter(function(Ae){return Ae.data===void 0}),ce=Promise.all(j.map(function(Ae){var Ke=nc(v,Ae.url);if(Ae.path!==void 0){var ft=Ae.path;Ke=Ke.then(function(qt){return v.overrideFile(ft,qt),Promise.resolve(qt)})}return Ke})),Ce=Promise.all(Z.map(function(Ae){return Ae.simd===void 0||Ae.simd&&E||!Ae.simd&&!E?Ny(v.locateFile(Ae.url,v.ha)):Promise.resolve()})).then(function(){var Ae,Ke,ft;return P(function(qt){if(qt.h==1)return Ae=window.createMediapipeSolutionsWasm,Ke=window.createMediapipeSolutionsPackedAssets,ft=v,R(qt,Ae(Ke),2);ft.i=qt.i,qt.h=0})}),_e=function(){return P(function(Ae){return v.h.graph&&v.h.graph.url?Ae=R(Ae,nc(v,v.h.graph.url),0):(Ae.h=0,Ae=void 0),Ae})}(),R(He,Promise.all([Ce,ce,_e]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return A=k.filter(function(Ae){return Ae.simd===void 0||Ae.simd&&E||!Ae.simd&&!E}).map(function(Ae){return v.locateFile(Ae.url,v.ha)}),importScripts.apply(null,l(A)),W=v,R(He,createMediapipeSolutionsWasm(Module),6);case 6:W.i=He.i,v.m=new OffscreenCanvas(1,1),v.i.canvas=v.m,G=v.i.GL.createContext(v.m,{antialias:!1,alpha:!1,va:typeof WebGL2RenderingContext<"u"?2:1}),v.i.GL.makeContextCurrent(G),He.h=4;break;case 7:if(v.m=document.createElement("canvas"),Ze=v.m.getContext("webgl2",{}),!Ze&&(Ze=v.m.getContext("webgl",{}),!Ze))return alert("Failed to create WebGL canvas context when passing video frame."),He.return();v.K=Ze,v.i.canvas=v.m,v.i.createContext(v.m,!0,!0,{});case 4:v.j=new v.i.SolutionWasm,v.ga=!1,He.h=0}})}function _y(v){var k,E,A,W,G,j,Z,ce;return P(function(Ce){if(Ce.h==1){if(v.h.graph&&v.h.graph.url&&v.fa===v.h.graph.url)return Ce.return();if(v.u=!0,!v.h.graph||!v.h.graph.url){Ce.h=2;return}return v.fa=v.h.graph.url,R(Ce,nc(v,v.h.graph.url),3)}for(Ce.h!=2&&(k=Ce.i,v.j.loadGraph(k)),E=a(Object.keys(v.D)),A=E.next();!A.done;A=E.next())W=A.value,v.j.overrideFile(W,v.D[W]);if(v.D={},v.h.listeners)for(G=a(v.h.listeners),j=G.next();!j.done;j=G.next())Z=j.value,Dy(v,Z);ce=v.l,v.l={},v.setOptions(ce),Ce.h=0})}t.reset=function(){var v=this;return P(function(k){v.j&&(v.j.reset(),v.s={},v.v={}),k.h=0})},t.setOptions=function(v,k){var E=this;if(k=k||this.h.options){for(var A=[],W=[],G={},j=a(Object.keys(v)),Z=j.next();!Z.done;G={X:G.X,Y:G.Y},Z=j.next())if(Z=Z.value,!(Z in this.l&&this.l[Z]===v[Z])){this.l[Z]=v[Z];var ce=k[Z];ce!==void 0&&(ce.onChange&&(G.X=ce.onChange,G.Y=v[Z],A.push(function(Ce){return function(){var _e;return P(function(Ze){if(Ze.h==1)return R(Ze,Ce.X(Ce.Y),2);_e=Ze.i,_e===!0&&(E.u=!0),Ze.h=0})}}(G))),ce.graphOptionXref&&(Z=Object.assign({},{calculatorName:"",calculatorIndex:0},ce.graphOptionXref,{valueNumber:ce.type===1?v[Z]:0,valueBoolean:ce.type===0?v[Z]:!1,valueString:ce.type===2?v[Z]:""}),W.push(Z)))}(A.length!==0||W.length!==0)&&(this.u=!0,this.H=(this.H===void 0?[]:this.H).concat(W),this.F=(this.F===void 0?[]:this.F).concat(A))}};function Py(v){var k,E,A,W,G,j,Z;return P(function(ce){switch(ce.h){case 1:if(!v.u)return ce.return();if(!v.F){ce.h=2;break}k=a(v.F),E=k.next();case 3:if(E.done){ce.h=5;break}return A=E.value,R(ce,A(),4);case 4:E=k.next(),ce.h=3;break;case 5:v.F=void 0;case 2:if(v.H){for(W=new v.i.GraphOptionChangeRequestList,G=a(v.H),j=G.next();!j.done;j=G.next())Z=j.value,W.push_back(Z);v.j.changeOptions(W),W.delete(),v.H=void 0}v.u=!1,ce.h=0}})}t.initialize=function(){var v=this;return P(function(k){return k.h==1?R(k,Ry(v),2):k.h!=3?R(k,_y(v),3):R(k,Py(v),0)})};function nc(v,k){var E,A;return P(function(W){return k in v.L?W.return(v.L[k]):(E=v.locateFile(k,""),A=fetch(E).then(function(G){return G.arrayBuffer()}),v.L[k]=A,W.return(A))})}t.overrideFile=function(v,k){this.j?this.j.overrideFile(v,k):this.D[v]=k},t.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},t.send=function(v,k){var E=this,A,W,G,j,Z,ce,Ce,_e,Ze;return P(function(He){switch(He.h){case 1:return E.h.inputs?(A=1e3*(k??performance.now()),R(He,E.I,2)):He.return();case 2:return R(He,E.initialize(),3);case 3:for(W=new E.i.PacketDataList,G=a(Object.keys(v)),j=G.next();!j.done;j=G.next())if(Z=j.value,ce=E.h.inputs[Z]){e:{var Ae=v[Z];switch(ce.type){case"video":var Ke=E.s[ce.stream];if(Ke||(Ke=new Gd(E.i,E.K),E.s[ce.stream]=Ke),Ke.m===0&&(Ke.m=Ke.i.createTexture()),typeof HTMLVideoElement<"u"&&Ae instanceof HTMLVideoElement)var ft=Ae.videoWidth,qt=Ae.videoHeight;else typeof HTMLImageElement<"u"&&Ae instanceof HTMLImageElement?(ft=Ae.naturalWidth,qt=Ae.naturalHeight):(ft=Ae.width,qt=Ae.height);qt={glName:Ke.m,width:ft,height:qt},ft=Ke.h,ft.canvas.width=qt.width,ft.canvas.height=qt.height,ft.activeTexture(ft.TEXTURE0),Ke.i.bindTexture2d(Ke.m),ft.texImage2D(ft.TEXTURE_2D,0,ft.RGBA,ft.RGBA,ft.UNSIGNED_BYTE,Ae),Ke.i.bindTexture2d(0),Ke=qt;break e;case"detections":for(Ke=E.s[ce.stream],Ke||(Ke=new Vl(E.i),E.s[ce.stream]=Ke),Ke.data||(Ke.data=new Ke.h.DetectionListData),Ke.data.reset(Ae.length),qt=0;qt<Ae.length;++qt){ft=Ae[qt];var jt=Ke.data,Tn=jt.setBoundingBox,Fr=qt,rr=ft.la,yt=new Or;if(tr(yt,1,rr.sa),tr(yt,2,rr.ta),tr(yt,3,rr.height),tr(yt,4,rr.width),tr(yt,5,rr.rotation),Zr(yt,6,rr.pa),rr=yt.l(),Tn.call(jt,Fr,rr),ft.ea)for(jt=0;jt<ft.ea.length;++jt){yt=ft.ea[jt],Tn=Ke.data,Fr=Tn.addNormalizedLandmark,rr=qt,yt=Object.assign({},yt,{visibility:yt.visibility?yt.visibility:0});var _n=new Nt;tr(_n,1,yt.x),tr(_n,2,yt.y),tr(_n,3,yt.z),yt.visibility&&tr(_n,4,yt.visibility),yt=_n.l(),Fr.call(Tn,rr,yt)}if(ft.ba)for(jt=0;jt<ft.ba.length;++jt)Tn=Ke.data,Fr=Tn.addClassification,rr=qt,yt=ft.ba[jt],_n=new ee,tr(_n,2,yt.qa),yt.index&&Zr(_n,1,yt.index),yt.label&&Zr(_n,3,yt.label),yt.displayName&&Zr(_n,4,yt.displayName),yt=_n.l(),Fr.call(Tn,rr,yt)}Ke=Ke.data;break e;default:Ke={}}}switch(Ce=Ke,_e=ce.stream,ce.type){case"video":W.pushTexture2d(Object.assign({},Ce,{stream:_e,timestamp:A}));break;case"detections":Ze=Ce,Ze.stream=_e,Ze.timestamp=A,W.pushDetectionList(Ze);break;default:throw Error("Unknown input config type: '"+ce.type+"'")}}return E.j.send(W),R(He,E.I,4);case 4:W.delete(),He.h=0}})};function Ay(v,k,E){var A,W,G,j,Z,ce,Ce,_e,Ze,He,Ae,Ke,ft,qt;return P(function(jt){switch(jt.h){case 1:if(!E)return jt.return(k);for(A={},W=0,G=a(Object.keys(E)),j=G.next();!j.done;j=G.next())Z=j.value,ce=E[Z],typeof ce!="string"&&ce.type==="texture"&&k[ce.stream]!==void 0&&++W;1<W&&(v.M=!1),Ce=a(Object.keys(E)),j=Ce.next();case 2:if(j.done){jt.h=4;break}if(_e=j.value,Ze=E[_e],typeof Ze=="string")return ft=A,qt=_e,R(jt,ap(v,_e,k[Ze]),14);if(He=k[Ze.stream],Ze.type==="detection_list"){if(He){for(var Tn=He.getRectList(),Fr=He.getLandmarksList(),rr=He.getClassificationsList(),yt=[],_n=0;_n<Tn.size();++_n){var Jo=Ma(Tn.get(_n)),Oy=Vn(Jo,1),cp=Vn(Jo,2),dp=Vn(Jo,3),Ul=Vn(Jo,4),jl=Vn(Jo,5,0),rc=void 0;rc=rc===void 0?0:rc,Jo={la:{sa:Oy,ta:cp,height:dp,width:Ul,rotation:jl,pa:Pi(Mn(Jo,6),rc)},ea:Vi(Fr.get(_n)),ba:Va(It(rr.get(_n)))},yt.push(Jo)}Tn=yt}else Tn=[];A[_e]=Tn,jt.h=7;break}if(Ze.type==="proto_list"){if(He){for(Tn=Array(He.size()),Fr=0;Fr<He.size();Fr++)Tn[Fr]=He.get(Fr);He.delete()}else Tn=[];A[_e]=Tn,jt.h=7;break}if(He===void 0){jt.h=3;break}if(Ze.type==="float_list"){A[_e]=He,jt.h=7;break}if(Ze.type==="proto"){A[_e]=He,jt.h=7;break}if(Ze.type!=="texture")throw Error("Unknown output config type: '"+Ze.type+"'");return Ae=v.v[_e],Ae||(Ae=new Gd(v.i,v.K),v.v[_e]=Ae),R(jt,ec(Ae,He,v.M),13);case 13:Ke=jt.i,A[_e]=Ke;case 7:Ze.transform&&A[_e]&&(A[_e]=Ze.transform(A[_e])),jt.h=3;break;case 14:ft[qt]=jt.i;case 3:j=Ce.next(),jt.h=2;break;case 4:return jt.return(A)}})}function ap(v,k,E){var A;return P(function(W){return typeof E=="number"||E instanceof Uint8Array||E instanceof v.i.Uint8BlobList?W.return(E):E instanceof v.i.Texture2dDataOut?(A=v.v[k],A||(A=new Gd(v.i,v.K),v.v[k]=A),W.return(ec(A,E,v.M))):W.return(void 0)})}function Dy(v,k){for(var E=k.name||"$",A=[].concat(l(k.wants)),W=new v.i.StringList,G=a(k.wants),j=G.next();!j.done;j=G.next())W.push_back(j.value);G=v.i.PacketListener.implement({onResults:function(Z){for(var ce={},Ce=0;Ce<k.wants.length;++Ce)ce[A[Ce]]=Z.get(Ce);var _e=v.listeners[E];_e&&(v.I=Ay(v,ce,k.outs).then(function(Ze){Ze=_e(Ze);for(var He=0;He<k.wants.length;++He){var Ae=ce[A[He]];typeof Ae=="object"&&Ae.hasOwnProperty&&Ae.hasOwnProperty("delete")&&Ae.delete()}Ze&&(v.I=Ze)}))}}),v.j.attachMultiListener(W,G),W.delete()}t.onResults=function(v,k){this.listeners[k||"$"]=v},ge("Solution",Wl),ge("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"});function lp(v){switch(v===void 0&&(v=0),v){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function up(v){var k=this;v=v||{},this.h=new Wl({locateFile:v.locateFile,files:function(E){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:lp(E.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:Vi},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:Vi},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window!="object"||window.navigator===void 0?!1:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(E){var A,W,G;return P(function(j){return j.h==1?(A=lp(E),W="third_party/mediapipe/modules/pose_landmark/"+A,R(j,nc(k.h,A),2)):(G=j.i,k.h.overrideFile(W,G),j.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}t=up.prototype,t.reset=function(){this.h.reset()},t.close=function(){return this.h.close(),Promise.resolve()},t.onResults=function(v){this.h.onResults(v)},t.initialize=function(){var v=this;return P(function(k){return R(k,v.h.initialize(),0)})},t.send=function(v,k){var E=this;return P(function(A){return R(A,E.h.send(v,k),0)})},t.setOptions=function(v){this.h.setOptions(v)},ge("Pose",up),ge("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),ge("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),ge("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),ge("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),ge("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),ge("VERSION","0.5.1675469404")}).call(nx)),nx}var hye=dye();/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fye=se();fye.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var cs;(function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"})(cs||(cs={}));var xN;(function(t){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))})(xN||(xN={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pye={};function hF(t){return pye[t]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N(t,e,n,r,s){const o=e.inputParams[t];if(o&&o.inputIndexStart!==void 0){const a=o.inputIndexStart,l=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?a+1:o.inputIndexEnd,c=a<0?e.inputNames.length+a:a;if(o.type==="tensor")return Yn(e.inputNames[c],n,r,s);if(o.type==="tensors"){const p=e.inputs.slice(a,l);return e.inputNames.slice(a,l).filter((y,x)=>{var w;return((w=p[x])===null||w===void 0?void 0:w.op)!=="NoOp"}).map(y=>Yn(y,n,r,s))}const d=Yn(e.inputNames[c],n,r,s),f=d.dataSync();return o.type==="number"?f[0]:nv(d.shape,f)}const i=e.attrParams[t];return i&&i.value}function Yn(t,e,n,r){const[s,o]=ds(t,n);if(r!=null){const a=r.getHashTableHandleByName(s);if(a!=null)return a}const i=n.currentContextIds.find(a=>!!e[Og(s,a)]);return i!==void 0?e[Og(s,i)][o]:void 0}function vN(t,e,n){return e[Og(t,n.currentContextId)]}function Qi(t,e){const[n,r,s]=ds(t,e);return[Og(n,e&&e.currentContextId),r,s]}function Og(t,e){return e?`${t}-${e}`:t}function ds(t,e){if(t==="")return["",0,void 0];const n=e!=null&&e.parseNodeNameCache!=null;if(n){const o=e.parseNodeNameCache.get(t);if(o!=null)return o}const r=t.split(":");let s;if(r.length===1)s=[t,0,void 0];else{const o=r[0],i=r.length===3?r[1]:void 0,a=Number(r[r.length-1]);s=[o,a,i]}return n&&e.parseNodeNameCache.set(t,s),s}function eg(t,e,n){let r=N("pad",t,e,n);if(r==="explicit"){r=N("explicitPaddings",t,e,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)s[o][0]=r[o*2],s[o][1]=r[o*2+1];return s}return r}function Zi(t){return t.kept?t:fl(t)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mye=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],gye=Object.freeze(Object.defineProperty({__proto__:null,json:mye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yye=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],xye=Object.freeze(Object.defineProperty({__proto__:null,json:yye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vye=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],bye=Object.freeze(Object.defineProperty({__proto__:null,json:vye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wye=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Sye=Object.freeze(Object.defineProperty({__proto__:null,json:wye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cye=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],$ye=Object.freeze(Object.defineProperty({__proto__:null,json:Cye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kye=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Tye=Object.freeze(Object.defineProperty({__proto__:null,json:kye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iye=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Nye=Object.freeze(Object.defineProperty({__proto__:null,json:Iye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eye=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Rye=Object.freeze(Object.defineProperty({__proto__:null,json:Eye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ye=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Pye=Object.freeze(Object.defineProperty({__proto__:null,json:_ye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aye=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Dye=Object.freeze(Object.defineProperty({__proto__:null,json:Aye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oye=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],Fye=Object.freeze(Object.defineProperty({__proto__:null,json:Oye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lye=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],zye=Object.freeze(Object.defineProperty({__proto__:null,json:Lye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bye=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Mye=Object.freeze(Object.defineProperty({__proto__:null,json:Bye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vye=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Wye=Object.freeze(Object.defineProperty({__proto__:null,json:Vye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uye=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],jye=Object.freeze(Object.defineProperty({__proto__:null,json:Uye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gye=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Hye=Object.freeze(Object.defineProperty({__proto__:null,json:Gye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kye=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Xye=Object.freeze(Object.defineProperty({__proto__:null,json:Kye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qye=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Yye=Object.freeze(Object.defineProperty({__proto__:null,json:qye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qye=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],Zye=Object.freeze(Object.defineProperty({__proto__:null,json:Qye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bN{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[gye,xye,bye,Sye,$ye,Tye,Nye,Rye,Pye,Dye,Fye,zye,Mye,Wye,jye,Hye,Xye,Yye,Zye],n=[].concat(...e.map(r=>r.json));this.opMappers=n.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(e,n={}){const r=e.node,s=[],o=[],i=[],a=r.reduce((x,w)=>(x[w.name]=this.mapNode(w),w.op.startsWith("Placeholder")?s.push(x[w.name]):w.op==="Const"?o.push(x[w.name]):(w.input==null||w.input.length===0)&&i.push(x[w.name]),x),{});let l=[];const c=[];let d={},f={};n!=null&&(d=this.mapSignatureEntries(n.inputs),f=this.mapSignatureEntries(n.outputs));const p=Object.keys(a);p.forEach(x=>{const w=a[x];w.inputNames.forEach((S,$)=>{const[I,,R]=Qi(S),_=a[I];if(_.outputs!=null){const O=_.outputs.indexOf(R);if(O!==-1){const F=`${I}:${O}`;w.inputNames[$]=F}}w.inputs.push(_),_.children.push(w)})}),Object.keys(f).length===0?p.forEach(x=>{const w=a[x];w.children.length===0&&c.push(w)}):Object.keys(f).forEach(x=>{const[w]=Qi(x),S=a[w];S!=null&&(S.signatureKey=f[x],c.push(S))}),Object.keys(d).length>0?Object.keys(d).forEach(x=>{const[w]=Qi(x),S=a[w];S&&(S.signatureKey=d[x],l.push(S))}):l=s;let g={};e.library!=null&&e.library.function!=null&&(g=e.library.function.reduce((x,w)=>(x[w.signature.name]=this.mapFunction(w),x),{}));const y={nodes:a,inputs:l,outputs:c,weights:o,placeholders:s,signature:n,functions:g};return i.length>0&&(y.initNodes=i),y}mapSignatureEntries(e){return Object.keys(e||{}).reduce((n,r)=>(n[e[r].name]=r,n),{})}mapNode(e){const n=hF(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const r={name:e.name,op:e.op,category:n.category,inputNames:(e.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:n.outputs};return n.inputs!=null&&(r.inputParams=n.inputs.reduce((s,o)=>(s[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},s),{})),n.attrs!=null&&(r.attrParams=n.attrs.reduce((s,o)=>{const i=o.type;let a;switch(o.type){case"string":a=kv(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=kv(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":a=Pv(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Pv(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":a=Iv(e.attr,o.tfName,o.defaultValue||0),a===void 0&&o.tfDeprecatedName&&(a=Iv(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":a=_v(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=_v(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":a=Tv(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Tv(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":a=Dv(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Dv(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":a=Rv(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Rv(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":a=Av(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Av(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":a=Nv(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Nv(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":a=Ev(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Ev(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":a=wN(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=wN(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${e.op}`)}return s[o.name]={value:a,type:i},s},{})),r}mapFunction(e){const n=e.nodeDef,r=[],s=[];let o={};n!=null&&(o=n.reduce((f,p)=>(f[p.name]=this.mapNode(p),p.op==="Const"&&s.push(f[p.name]),f),{}));const i=[],a=[];e.signature.inputArg.forEach(f=>{const[p]=Qi(f.name),g={name:p,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:zC(f.type),type:"dtype"}},children:[]};g.signatureKey=f.name,i.push(g),o[p]=g}),Object.keys(o).forEach(f=>{const p=o[f];p.inputNames.forEach((g,y)=>{const[x,,w]=Qi(g),S=o[x];if(S.outputs!=null){const $=S.outputs.indexOf(w);if($!==-1){const I=`${x}:${$}`;p.inputNames[y]=I}}p.inputs.push(S),S.children.push(p)})});const c=e.ret;e.signature.outputArg.forEach(f=>{const[p,g]=Qi(c[f.name]),y=o[p];y!=null&&(y.defaultOutput=g,a.push(y))});const d=this.mapArgsToSignature(e);return{nodes:o,inputs:i,outputs:a,weights:s,placeholders:r,signature:d}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r),n),{}),outputs:e.signature.outputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r,e.ret),n),{})}}mapArgToTensorInfo(e,n){let r=e.name;return n!=null&&(r=n[r]),{name:r,dtype:e.type}}}function Jye(t){const e=se().global;if(typeof e.atob<"u")return e.atob(t);if(typeof Buffer<"u")return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function fF(t,e){const n=Array.isArray(t)?String.fromCharCode.apply(null,t):Jye(t);return e?n:n.toLowerCase()}function kv(t,e,n,r=!1){const s=t[e];return s!=null?fF(s.s,r):n}function Tv(t,e,n){const r=t[e];return r?r.b:n}function Iv(t,e,n){const r=t[e]||{},s=r.i!=null?r.i:r.f!=null?r.f:n;return typeof s=="number"?s:parseInt(s,10)}function zC(t){switch(typeof t=="string"&&(t=cs[t]),t){case cs.DT_FLOAT:case cs.DT_HALF:return"float32";case cs.DT_INT32:case cs.DT_INT64:case cs.DT_INT8:case cs.DT_UINT8:return"int32";case cs.DT_BOOL:return"bool";case cs.DT_DOUBLE:return"float32";case cs.DT_STRING:return"string";case cs.DT_COMPLEX64:case cs.DT_COMPLEX128:return"complex64";default:return null}}function wN(t,e,n){const r=t[e];return r&&r.func?r.func.name:n}function Nv(t,e,n){const r=t[e];return r&&r.type?zC(r.type):n}function Ev(t,e,n){const r=t[e];return r&&r.list&&r.list.type?r.list.type.map(s=>zC(s)):n}function pF(t){if(!t.unknownRank)return t.dim!=null?t.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function Rv(t,e,n){const r=t[e];return r&&r.shape?pF(r.shape):n}function _v(t,e,n){const r=t[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):n}function Pv(t,e,n,r=!1){const s=t[e];return s&&s.list&&s.list.s?s.list.s.map(o=>fF(o,r)):n}function Av(t,e,n){const r=t[e];return r&&r.list&&r.list.shape?r.list.shape.map(s=>pF(s)):n}function Dv(t,e,n){const r=t[e];return r&&r.list&&r.list.b?r.list.b:n}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class e0e{constructor(e,n,r){this.node=e,this.tensorMap=n,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(s=>this.getInput(s)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((s,o)=>(s[o]=this.getAttr(o),s),{}))}getInput(e){return Yn(e,this.tensorMap,this.context)}getAttr(e,n){const r=this.node.rawAttrs[e];if(r.tensor!=null)return Yn(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return Iv(this.node.rawAttrs,e,n);if(r.s!=null)return kv(this.node.rawAttrs,e,n);if(r.b!=null)return Tv(this.node.rawAttrs,e,n);if(r.shape!=null)return Rv(this.node.rawAttrs,e,n);if(r.type!=null)return Nv(this.node.rawAttrs,e,n);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return _v(this.node.rawAttrs,e,n);if(r.list.s!=null)return Pv(this.node.rawAttrs,e,n);if(r.list.shape!=null)return Av(this.node.rawAttrs,e,n);if(r.list.b!=null)return Dv(this.node.rawAttrs,e,n);if(r.list.type!=null)return Ev(this.node.rawAttrs,e,n)}return n}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jn=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:FA,abs:Rs,acos:Aq,acosh:Oq,add:We,addN:Lq,all:Bq,any:Vq,argMax:ZA,argMin:jq,asin:Hq,asinh:Xq,atan:Yq,atan2:Zq,atanh:eY,avgPool:JA,avgPool3d:lY,basicLSTMCell:mY,batchNorm:ly,batchNorm2d:bY,batchNorm3d:SY,batchNorm4d:$Y,batchToSpaceND:eD,bincount:tD,bitwiseAnd:IY,booleanMaskAsync:hte,broadcastArgs:EY,broadcastTo:Qh,buffer:Wt,cast:Qt,ceil:PY,clipByValue:nD,clone:fl,complex:yl,concat:Fn,concat1d:OY,concat2d:LY,concat3d:BY,concat4d:VY,conv1d:jY,conv2d:uy,conv2dTranspose:KY,conv3d:qY,conv3dTranspose:JY,cos:tQ,cosh:rQ,cosineWindow:XS,cumprod:oQ,cumsum:aQ,denseBincount:uQ,depthToSpace:dQ,depthwiseConv2d:zS,diag:pQ,dilation2d:gQ,div:gt,divNoNan:wQ,dot:CQ,dropout:kte,einsum:_c,elu:iD,enclosingPowerOfTwo:OD,ensureShape:IQ,equal:oD,erf:EQ,euclideanNorm:zQ,exp:ga,expandDims:_s,expm1:WQ,eye:uD,fft:GS,fill:Xf,floor:cD,floorDiv:QA,fused:Mte,gather:dD,gatherND:Ste,greater:dy,greaterEqual:hD,ifft:Eg,imag:hy,image:Tu,inTopKAsync:Ite,irfft:ND,isFinite:QQ,isInf:JQ,isNaN:tZ,leakyRelu:fD,less:gv,lessEqual:MS,linalg:vre,linspace:oZ,localResponseNormalization:aZ,log:bf,log1p:pD,logSigmoid:pZ,logSoftmax:yZ,logSumExp:gD,logicalAnd:Ig,logicalNot:yD,logicalOr:xD,logicalXor:CZ,losses:bre,lowerBound:kZ,matMul:Ht,max:Jc,maxPool:vD,maxPool3d:NZ,maxPoolWithArgmax:RZ,maximum:bD,mean:Ng,meshgrid:AZ,min:mv,minimum:wf,mirrorPad:wD,mod:LZ,moments:BZ,movingAverage:mte,mul:Te,multiRNNCell:VZ,multinomial:UZ,neg:bi,norm:cy,notEqual:SD,oneHot:HZ,ones:bu,onesLike:XZ,op:X,outerProduct:YZ,pad:vl,pad1d:JZ,pad2d:tJ,pad3d:rJ,pad4d:oJ,pool:cJ,pow:vf,prelu:$D,print:YA,prod:fJ,raggedGather:mJ,raggedRange:yJ,raggedTensorToTensor:vJ,rand:wJ,randomGamma:UJ,randomNormal:kD,randomStandardNormal:HJ,randomUniform:jS,randomUniformInt:qJ,range:Sf,real:Cf,reciprocal:ZJ,relu:fy,relu6:TD,reshape:ye,reverse:Ou,reverse1d:ree,reverse2d:oee,reverse3d:aee,reverse4d:uee,rfft:HS,round:ID,rsqrt:hee,scalar:mt,scatterND:yte,searchSorted:VS,selu:pee,separableConv2d:gee,setdiff1dAsync:xee,sigmoid:aa,sign:bee,signal:xre,sin:See,sinh:$ee,slice:pt,slice1d:Tee,slice2d:Nee,slice3d:Ree,slice4d:Pee,softmax:Dee,softplus:mD,spaceToBatchND:CD,sparse:wre,sparseToDense:bte,spectral:yre,split:$f,sqrt:ma,square:lo,squaredDifference:ED,squeeze:Gt,stack:va,step:RD,stridedSlice:Gee,string:Sre,sub:ot,sum:en,tan:Kee,tanh:pv,tensor:vi,tensor1d:lr,tensor2d:uo,tensor3d:_D,tensor4d:Xee,tensor5d:qee,tensor6d:Yee,tensorScatterUpdate:Zee,tile:Zh,topk:ete,transpose:yv,truncatedNormal:nte,unique:ste,unsortedSegmentSum:ite,unstack:Mu,upperBound:lte,variable:ute,where:pl,whereAsync:DD,zeros:xa,zerosLike:Os},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t0e=(t,e,n,r=Jn)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(N("a",t,e,n),N("b",t,e,n))];case"AddN":return[r.addN(N("tensors",t,e,n))];case"FloorMod":case"Mod":return[r.mod(N("a",t,e,n),N("b",t,e,n))];case"Mul":return[r.mul(N("a",t,e,n),N("b",t,e,n))];case"RealDiv":case"Div":return[r.div(N("a",t,e,n),N("b",t,e,n))];case"DivNoNan":return[r.divNoNan(N("a",t,e,n),N("b",t,e,n))];case"FloorDiv":return[r.floorDiv(N("a",t,e,n),N("b",t,e,n))];case"Sub":return[r.sub(N("a",t,e,n),N("b",t,e,n))];case"Minimum":return[r.minimum(N("a",t,e,n),N("b",t,e,n))];case"Maximum":return[r.maximum(N("a",t,e,n),N("b",t,e,n))];case"Pow":return[r.pow(N("a",t,e,n),N("b",t,e,n))];case"SquaredDifference":return[r.squaredDifference(N("a",t,e,n),N("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n0e=(t,e,n,r=Jn)=>{switch(t.op){case"Abs":case"ComplexAbs":return[r.abs(N("x",t,e,n))];case"Acos":return[r.acos(N("x",t,e,n))];case"Acosh":return[r.acosh(N("x",t,e,n))];case"Asin":return[r.asin(N("x",t,e,n))];case"Asinh":return[r.asinh(N("x",t,e,n))];case"Atan":return[r.atan(N("x",t,e,n))];case"Atan2":return[r.atan2(N("x",t,e,n),N("y",t,e,n))];case"Atanh":return[r.atanh(N("x",t,e,n))];case"Ceil":return[r.ceil(N("x",t,e,n))];case"Complex":return[r.complex(N("real",t,e,n),N("imag",t,e,n))];case"Cos":return[r.cos(N("x",t,e,n))];case"Cosh":return[r.cosh(N("x",t,e,n))];case"Elu":return[r.elu(N("x",t,e,n))];case"Erf":return[r.erf(N("x",t,e,n))];case"Exp":return[r.exp(N("x",t,e,n))];case"Expm1":return[r.expm1(N("x",t,e,n))];case"Floor":return[r.floor(N("x",t,e,n))];case"Log":return[r.log(N("x",t,e,n))];case"Log1p":return[r.log1p(N("x",t,e,n))];case"Imag":return[r.imag(N("x",t,e,n))];case"Neg":return[r.neg(N("x",t,e,n))];case"Reciprocal":return[r.reciprocal(N("x",t,e,n))];case"Real":return[r.real(N("x",t,e,n))];case"Relu":return[r.relu(N("x",t,e,n))];case"Round":return[r.round(N("x",t,e,n))];case"Selu":return[r.selu(N("x",t,e,n))];case"Sigmoid":return[r.sigmoid(N("x",t,e,n))];case"Sin":return[r.sin(N("x",t,e,n))];case"Sign":return[r.sign(N("x",t,e,n))];case"Sinh":return[r.sinh(N("x",t,e,n))];case"Softplus":return[r.softplus(N("x",t,e,n))];case"Sqrt":return[r.sqrt(N("x",t,e,n))];case"Square":return[r.square(N("x",t,e,n))];case"Tanh":return[r.tanh(N("x",t,e,n))];case"Tan":return[r.tan(N("x",t,e,n))];case"ClipByValue":return[r.clipByValue(N("x",t,e,n),N("clipValueMin",t,e,n),N("clipValueMax",t,e,n))];case"Relu6":return[r.relu6(N("x",t,e,n))];case"Rsqrt":return[r.rsqrt(Yn(t.inputNames[0],e,n))];case"LeakyRelu":return[r.leakyRelu(N("x",t,e,n),N("alpha",t,e,n))];case"Prelu":return[r.prelu(N("x",t,e,n),N("alpha",t,e,n))];case"IsNan":return[r.isNaN(Yn(t.inputNames[0],e,n))];case"IsInf":return[r.isInf(Yn(t.inputNames[0],e,n))];case"IsFinite":return[r.isFinite(Yn(t.inputNames[0],e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ro(t,e,n=""){if(!(typeof t=="number"||typeof e=="number")){z(t.length===e.length,()=>n+` Shapes ${t} and ${e} must match`);for(let r=0;r<t.length;r++){const s=t[r],o=e[r];z(s<0||o<0||s===o,()=>n+` Shapes ${t} and ${e} must match`)}}}function SN(t){return!(typeof t=="number"||t.some(e=>e<0))}function Sh(t,e,n){let r=Ov(t,n);const s=!SN(r);if(s&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&e.forEach(o=>{r=Ov(o.shape,r)}),!SN(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function Ov(t,e){if(typeof t=="number")return e;if(typeof e=="number")return t;if(t.length!==e.length)throw new Error(`Incompatible ranks during merge: ${t} vs. ${e}`);const n=[];for(let r=0;r<t.length;++r){const s=t[r],o=e[r];if(s>=0&&o>=0&&s!==o)throw new Error(`Incompatible shape during merge: ${t} vs. ${e}`);n[r]=s>=0?s:o}return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r0e{constructor(e,n,r,s,o,i,a){this.name=e,this.dtype=n,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=o,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=mt(0),hi(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.tensor.id))&&n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const n=this.tensors[e];if(n.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(e){return e.map(n=>this.read(n))}write(e,n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[e]||{};if(n.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=n.shape),ro(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=n,hi(n),r.written=!0,this.tensors[e]=r}writeMany(e,n){if(e.length!==n.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${n.length}.`);e.forEach((r,s)=>this.write(r,n[s]))}gather(e,n){if(n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);if(e)e=e.slice(0,this.size());else{e=[];for(let s=0;s<this.size();s++)e.push(s)}if(e.length===0)return vi([],[0].concat(this.elementShape));const r=this.readMany(e);return ro(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),va(r,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return vi([],[0].concat(this.elementShape));const n=[];for(let s=0;s<this.size();s++)n.push(s);const r=this.readMany(n);return ro(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),Fn(r,0)}scatter(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,Mu(n,0))}split(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);let r=0;const s=e.map(l=>(r+=l,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const o=r===0?0:n.size/r,i=[];nt(()=>{n=ye(n,[1,r,o]);for(let l=0;l<e.length;++l){const d=[0,l===0?0:s[l-1],0],f=[1,e[l],o];i[l]=ye(pt(n,d,f),this.elementShape)}return i});const a=[];for(let l=0;l<e.length;l++)a[l]=l;this.writeMany(a,i)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zu{get id(){return this.idTensor.id}constructor(e,n,r,s=-1){this.tensors=e,this.elementShape=n,this.elementDtype=r,e!=null&&e.forEach(o=>{if(r!==o.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${o.dtype}`);ro(n,o.shape,"TensorList shape mismatch: "),hi(o)}),this.idTensor=mt(0),this.maxNumElements=s,hi(this.idTensor)}copy(){return new zu([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,n,r=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);ro(e,this.elementShape,"TensorList shape mismatch: ");const s=Sh(this.elementShape,this.tensors,e);return nt(()=>{const o=this.tensors.map(i=>ye(i,s));return va(o,0)})}popBack(e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=Sh(this.elementShape,this.tensors,e),s=this.tensors.pop();return s.kept=!1,ro(s.shape,e,"TensorList shape mismatch: "),ye(s,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(ro(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");hi(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const n=new zu([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)n.tensors[r]=this.tensors[r];return n}getItem(e,n,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);ro(this.tensors[e].shape,n,"TensorList shape mismatch: ");const s=Sh(this.elementShape,this.tensors,n);return ye(this.tensors[e],s)}setItem(e,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);ro(this.elementShape,n.shape,"TensorList shape mismatch: "),hi(n),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=n}gather(e,n,r){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);ro(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());const s=Sh(this.elementShape,this.tensors,r);return e.length===0?vi([],[0].concat(s)):nt(()=>{const o=e.map(i=>ye(this.tensors[i],s));return va(o,0)})}concat(e,n){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);ro(this.elementShape,n,"TensorList shape mismatch: ");const r=Sh(this.elementShape,this.tensors,n);return this.size()===0?vi([],[0].concat(r)):nt(()=>{const s=this.tensors.map(o=>ye(o,r));return Fn(s,0)})}}function s0e(t,e,n){const r=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==n)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);const s=t.shape.slice(1);ro(s,e,"TensorList shape mismatch: ");const o=Mu(t);return new zu(o,e,r)}function o0e(t,e,n,r){return new zu([],t,e,r)}function i0e(t,e,n,r){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const o=new zu([],n,t.dtype,r),i=Mu(t,0);return e.forEach((a,l)=>{o.setItem(a,i[l])}),o}function a0e(t,e,n){let r=0;const s=e.map(d=>(r+=d,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);const o=t.shape.slice(1),i=Ov(o,n),a=r===0?0:t.size/r,l=nt(()=>{const d=[];t=ye(t,[1,r,a]);for(let f=0;f<e.length;++f){const g=[0,f===0?0:s[f-1],0],y=[1,e[f],a];d[f]=ye(pt(t,g,y),i)}return t.dispose(),d}),c=new zu([],n,t.dtype,e.length);for(let d=0;d<l.length;d++)c.setItem(d,l[d]);return c}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l0e=async(t,e,n)=>{switch(t.op){case"If":case"StatelessIf":{const r=N("thenBranch",t,e,n),s=N("elseBranch",t,e,n),o=N("cond",t,e,n),i=N("args",t,e,n);return(await o.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=N("body",t,e,n),s=N("cond",t,e,n),o=N("args",t,e,n),i=await n.functionMap[s].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap),a=o.map(d=>d.id);let l=await i[0].data();i.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&d.dispose()});let c=o;for(;l[0];){const d=c;c=await n.functionMap[r].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);const f=c.map(g=>g.id);d.forEach(g=>{!g.kept&&a.indexOf(g.id)===-1&&f.indexOf(g.id)===-1&&g.dispose()});const p=await n.functionMap[s].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);l=await p[0].data(),p.forEach(g=>{!g.kept&&a.indexOf(g.id)===-1&&f.indexOf(g.id)===-1&&g.dispose()})}return c}case"LoopCond":{const r=N("pred",t,e,n);return[Zi(r)]}case"Switch":{const r=N("pred",t,e,n);let s=N("data",t,e,n);return s.kept||(s=Zi(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=t.inputNames.find(s=>Yn(s,e,n)!==void 0);if(r){const s=Yn(r,e,n);return[Zi(s)]}return}case"Enter":{const r=N("frameName",t,e,n),s=N("tensor",t,e,n);return n.enterFrame(r),[Zi(s)]}case"Exit":{const r=N("tensor",t,e,n);return n.exitFrame(),[Zi(r)]}case"NextIteration":{const r=N("tensor",t,e,n);return n.nextIteration(),[Zi(r)]}case"TensorArrayV3":{const r=N("size",t,e,n),s=N("dtype",t,e,n),o=N("elementShape",t,e,n),i=N("dynamicSize",t,e,n),a=N("clearAfterRead",t,e,n),l=N("identicalElementShapes",t,e,n),c=N("name",t,e,n),d=new r0e(c,s,r,o,l,i,a);return n.addTensorArray(d),[d.idTensor,mt(1)]}case"TensorArrayWriteV3":{const r=N("tensorArrayId",t,e,n),s=N("index",t,e,n),o=N("tensor",t,e,n),i=n.getTensorArray(r.id);return i.write(s,o),[i.idTensor]}case"TensorArrayReadV3":{const r=N("tensorArrayId",t,e,n),s=N("index",t,e,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=N("tensorArrayId",t,e,n),s=N("indices",t,e,n),o=N("dtype",t,e,n);return[n.getTensorArray(r.id).gather(s,o)]}case"TensorArrayScatterV3":{const r=N("tensorArrayId",t,e,n),s=N("indices",t,e,n),o=N("tensor",t,e,n),i=n.getTensorArray(r.id);return i.scatter(s,o),[i.idTensor]}case"TensorArrayConcatV3":{const r=N("tensorArrayId",t,e,n),s=n.getTensorArray(r.id),o=N("dtype",t,e,n);return[s.concat(o)]}case"TensorArraySplitV3":{const r=N("tensorArrayId",t,e,n),s=N("tensor",t,e,n),o=N("lengths",t,e,n),i=n.getTensorArray(r.id);return i.split(o,s),[i.idTensor]}case"TensorArraySizeV3":{const r=N("tensorArrayId",t,e,n),s=n.getTensorArray(r.id);return[mt(s.size(),"int32")]}case"TensorArrayCloseV3":{const r=N("tensorArrayId",t,e,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=N("tensorListId",t,e,n),s=N("index",t,e,n),o=N("tensor",t,e,n),i=n.getTensorList(r.id);return i.setItem(s,o),[i.idTensor]}case"TensorListGetItem":{const r=N("tensorListId",t,e,n),s=N("index",t,e,n),o=N("elementShape",t,e,n),i=N("elementDType",t,e,n);return[n.getTensorList(r.id).getItem(s,o,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=N("indices",t,e,n),s=N("tensor",t,e,n),o=N("elementShape",t,e,n),i=N("numElements",t,e,n),a=i0e(s,r,o,i);return n.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=N("elementShape",t,e,n),s=N("elementDType",t,e,n);let o;t.op==="TensorListReserve"?o="numElements":o="maxNumElements";const i=N(o,t,e,n),a=t.op==="TensorListReserve"?-1:i,l=o0e(r,s,i,a);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{const r=N("tensorListId",t,e,n),s=N("indices",t,e,n),o=N("elementShape",t,e,n),i=N("elementDType",t,e,n);return[n.getTensorList(r.id).gather(s,i,o)]}case"TensorListStack":{const r=N("tensorListId",t,e,n),s=N("elementShape",t,e,n),o=N("elementDType",t,e,n),i=N("numElements",t,e,n);return[n.getTensorList(r.id).stack(s,o,i)]}case"TensorListFromTensor":{const r=N("tensor",t,e,n),s=N("elementShape",t,e,n),o=N("elementDType",t,e,n),i=s0e(r,s,o);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=N("tensorListId",t,e,n),s=n.getTensorList(r.id),o=N("dtype",t,e,n),i=N("elementShape",t,e,n);return[s.concat(o,i)]}case"TensorListPushBack":{const r=N("tensorListId",t,e,n),s=N("tensor",t,e,n),o=n.getTensorList(r.id);return o.pushBack(s),[o.idTensor]}case"TensorListPopBack":{const r=N("tensorListId",t,e,n),s=N("elementShape",t,e,n),o=N("elementDType",t,e,n);return[n.getTensorList(r.id).popBack(s,o)]}case"TensorListSplit":{const r=N("tensor",t,e,n),s=N("elementShape",t,e,n),o=N("lengths",t,e,n),i=a0e(r,o,s);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{const r=N("tensorListId",t,e,n),s=n.getTensorList(r.id);return[mt(s.size(),"int32")]}case"TensorListResize":{const r=N("tensorListId",t,e,n),s=N("size",t,e,n),i=n.getTensorList(r.id).resize(s);return n.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CN(t,e,n){const[r,s]=N("fusedOps",t,e,n),o=r==="biasadd",i=!o,a=s==="prelu",l=r==="fusedbatchnorm",c=N("numArgs",t,e,n);if(o){if(a&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&o&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const d=N("strides",t,e,n),f=eg(t,e,n),p=N("dataFormat",t,e,n).toUpperCase(),g=N("dilations",t,e,n);let[y,x]=N("args",t,e,n);i&&(x=y,y=void 0);const w=N("leakyreluAlpha",t,e,n);return{stride:d,pad:f,dataFormat:p,dilations:g,biasArg:y,preluArg:x,activationFunc:s,leakyreluAlpha:w}}const u0e=(t,e,n,r=Jn)=>{switch(t.op){case"Conv1D":{const s=N("stride",t,e,n),o=N("pad",t,e,n),i=N("dataFormat",t,e,n).toUpperCase(),a=N("dilation",t,e,n);return[r.conv1d(N("x",t,e,n),N("filter",t,e,n),s,o,i,a)]}case"Conv2D":{const s=N("strides",t,e,n),o=eg(t,e,n),i=N("dataFormat",t,e,n).toUpperCase(),a=N("dilations",t,e,n);return[r.conv2d(N("x",t,e,n),N("filter",t,e,n),[s[1],s[2]],o,i,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:s,pad:o,dataFormat:i,dilations:a,biasArg:l,preluArg:c,activationFunc:d,leakyreluAlpha:f}=CN(t,e,n);return[r.fused.conv2d({x:N("x",t,e,n),filter:N("filter",t,e,n),strides:[s[1],s[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:d,preluActivationWeights:c,leakyreluAlpha:f})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:o,dataFormat:i,dilations:a,biasArg:l,preluArg:c,activationFunc:d,leakyreluAlpha:f}=CN(t,e,n);return[r.fused.depthwiseConv2d({x:N("x",t,e,n),filter:N("filter",t,e,n),strides:[s[1],s[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:d,preluActivationWeights:c,leakyreluAlpha:f})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=N("outputShape",t,e,n),o=N("strides",t,e,n),i=eg(t,e,n);return[r.conv2dTranspose(N("x",t,e,n),N("filter",t,e,n),s,[o[1],o[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=N("strides",t,e,n),o=eg(t,e,n),i=N("dilations",t,e,n),a=N("dataFormat",t,e,n).toUpperCase();return[r.depthwiseConv2d(N("input",t,e,n),N("filter",t,e,n),[s[1],s[2]],o,a,[i[1],i[2]])]}case"Conv3D":{const s=N("strides",t,e,n),o=N("pad",t,e,n),i=N("dataFormat",t,e,n).toUpperCase(),a=N("dilations",t,e,n);return[r.conv3d(N("x",t,e,n),N("filter",t,e,n),[s[1],s[2],s[3]],o,i,[a[1],a[2],a[3]])]}case"AvgPool":{const s=N("strides",t,e,n),o=N("pad",t,e,n),i=N("kernelSize",t,e,n);return[r.avgPool(N("x",t,e,n),[i[1],i[2]],[s[1],s[2]],o)]}case"MaxPool":{const s=N("strides",t,e,n),o=N("pad",t,e,n),i=N("kernelSize",t,e,n);return[r.maxPool(N("x",t,e,n),[i[1],i[2]],[s[1],s[2]],o)]}case"MaxPoolWithArgmax":{const s=N("strides",t,e,n),o=N("pad",t,e,n),i=N("kernelSize",t,e,n),a=N("includeBatchInIndex",t,e,n),{result:l,indexes:c}=r.maxPoolWithArgmax(N("x",t,e,n),[i[1],i[2]],[s[1],s[2]],o,a);return[l,c]}case"AvgPool3D":{const s=N("strides",t,e,n),o=N("pad",t,e,n),i=N("kernelSize",t,e,n);return[r.avgPool3d(N("x",t,e,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],o)]}case"MaxPool3D":{const s=N("strides",t,e,n),o=N("pad",t,e,n),i=N("kernelSize",t,e,n);return[r.maxPool3d(N("x",t,e,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],o)]}case"Dilation2D":{const s=N("strides",t,e,n),o=N("pad",t,e,n),i=N("dilations",t,e,n),a=s[1],l=s[2],c=i[1],d=i[2];return[r.dilation2d(N("x",t,e,n),N("filter",t,e,n),[a,l],o,[c,d],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c0e=(t,e,n,r=Jn)=>{switch(t.op){case"Fill":{const s=N("shape",t,e,n),o=N("dtype",t,e,n),i=N("value",t,e,n);return[r.fill(s,i,o)]}case"LinSpace":{const s=N("start",t,e,n),o=N("stop",t,e,n),i=N("num",t,e,n);return[r.linspace(s,o,i)]}case"Multinomial":{const s=N("logits",t,e,n),o=N("numSamples",t,e,n),i=N("seed",t,e,n);return[r.multinomial(s,o,i)]}case"OneHot":{const s=N("indices",t,e,n),o=N("depth",t,e,n),i=N("onValue",t,e,n),a=N("offValue",t,e,n),l=N("dtype",t,e,n);return[r.oneHot(s,o,i,a,l)]}case"Ones":return[r.ones(N("shape",t,e,n),N("dtype",t,e,n))];case"OnesLike":return[r.onesLike(N("x",t,e,n))];case"RandomStandardNormal":return[r.randomStandardNormal(N("shape",t,e,n),N("dtype",t,e,n),N("seed",t,e,n))];case"RandomUniform":return[r.randomUniform(N("shape",t,e,n),N("minval",t,e,n),N("maxval",t,e,n),N("dtype",t,e,n))];case"RandomUniformInt":return[r.randomUniformInt(N("shape",t,e,n),N("minval",t,e,n),N("maxval",t,e,n),N("seed",t,e,n))];case"Range":{const s=N("start",t,e,n),o=N("stop",t,e,n),i=N("step",t,e,n);return[r.range(s,o,i,N("dtype",t,e,n))]}case"TruncatedNormal":{const s=N("shape",t,e,n),o=N("mean",t,e,n),i=N("stdDev",t,e,n),a=N("seed",t,e,n);return[r.truncatedNormal(s,o,i,N("dtype",t,e,n),a)]}case"Zeros":return[r.zeros(N("shape",t,e,n),N("dtype",t,e,n))];case"ZerosLike":return[r.zerosLike(N("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rx(t,e,n){const r=N("boxes",t,e,n),s=N("scores",t,e,n),o=N("maxOutputSize",t,e,n),i=N("iouThreshold",t,e,n),a=N("scoreThreshold",t,e,n),l=N("softNmsSigma",t,e,n);return{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:a,softNmsSigma:l}}const d0e=async(t,e,n,r,s=Jn)=>{switch(t.op){case"NonMaxSuppressionV5":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:l,scoreThreshold:c,softNmsSigma:d}=rx(t,e,n),f=await s.image.nonMaxSuppressionWithScoreAsync(o,i,a,l,c,d);return[f.selectedIndices,f.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=rx(t,e,n),d=N("padToMaxOutputSize",t,e,n),f=await s.image.nonMaxSuppressionPaddedAsync(o,i,a,l,c,d);return[f.selectedIndices,f.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=rx(t,e,n);return[await s.image.nonMaxSuppressionAsync(o,i,a,l,c)]}case"Where":{const o=s.cast(N("condition",t,e,n),"bool"),i=[await s.whereAsync(o)];return o.dispose(),i}case"ListDiff":return s.setdiff1dAsync(N("x",t,e,n),N("y",t,e,n));default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h0e=(t,e,n,r=Jn)=>{switch(t.op){case"LowerBound":{const s=N("sortedSequence",t,e,n),o=N("values",t,e,n);return[r.lowerBound(s,o)]}case"TopKV2":{const s=N("x",t,e,n),o=N("k",t,e,n),i=N("sorted",t,e,n),a=r.topk(s,o,i);return[a.values,a.indices]}case"UpperBound":{const s=N("sortedSequence",t,e,n),o=N("values",t,e,n);return[r.upperBound(s,o)]}case"Unique":{const s=N("x",t,e,n),o=r.unique(s);return[o.values,o.indices]}case"UniqueV2":{const s=N("x",t,e,n),o=N("axis",t,e,n),i=r.unique(s,o);return[i.values,i.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f0e=(t,e,n,r=Jn)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":const s=N("default",t,e,n);return[Yn(t.name,e,n)||s];case"Placeholder":return[Yn(t.name,e,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const d=N("x",t,e,n);return[Zi(d)]}case"IdentityN":return N("x",t,e,n).map(d=>Zi(d));case"Snapshot":const o=N("x",t,e,n);return[Zi(o)];case"Shape":return[r.tensor1d(N("x",t,e,n).shape,"int32")];case"ShapeN":return N("x",t,e,n).map(d=>r.tensor1d(d.shape));case"Size":return[r.scalar(N("x",t,e,n).size,"int32")];case"Rank":return[r.scalar(N("x",t,e,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const i=N("x",t,e,n),a=N("data",t,e,n),l=N("message",t,e,n),c=N("summarize",t,e,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let d=0;d<a.length;d++)console.log(Array.prototype.slice.call(a[d].dataSync()).slice(0,c));return[i];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class p0e{get id(){return this.handle.id}constructor(e,n){this.keyDType=e,this.valueDType=n,this.handle=mt(0),this.tensorMap=new Map,hi(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return mt(this.size(),"int32")}async import(e,n){this.checkKeyAndValueTensor(e,n);const r=await e.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),nt(()=>{const s=Mu(n),o=r.length,i=s.length;z(o===i,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${i} elements.`);for(let a=0;a<o;a++){const l=r[a],c=s[a];hi(c),this.tensorMap.set(l,c)}return this.handle})}async find(e,n){this.checkKeyAndValueTensor(e,n);const r=await e.data();return nt(()=>{const s=[];for(let o=0;o<r.length;o++){const i=r[o],a=this.findWithDefault(i,n);s.push(a)}return va(s)})}findWithDefault(e,n){const r=this.tensorMap.get(e);return r??n}checkKeyAndValueTensor(e,n){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(n.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m0e=async(t,e,n,r)=>{switch(t.op){case"HashTable":case"HashTableV2":{const s=r.getHashTableHandleByName(t.name);if(s!=null)return[s];{const o=N("keyDType",t,e,n),i=N("valueDType",t,e,n),a=new p0e(o,i);return r.addHashTable(t.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=N("tableHandle",t,e,n,r),o=N("keys",t,e,n),i=N("values",t,e,n);return[await r.getHashTableById(s.id).import(o,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=N("tableHandle",t,e,n,r),o=N("keys",t,e,n),i=N("defaultValue",t,e,n);return[await r.getHashTableById(s.id).find(o,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=N("tableHandle",t,e,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g0e=(t,e,n,r=Jn)=>{switch(t.op){case"ResizeBilinear":{const s=N("images",t,e,n),o=N("size",t,e,n),i=N("alignCorners",t,e,n),a=N("halfPixelCenters",t,e,n);return[r.image.resizeBilinear(s,[o[0],o[1]],i,a)]}case"ResizeNearestNeighbor":{const s=N("images",t,e,n),o=N("size",t,e,n),i=N("alignCorners",t,e,n),a=N("halfPixelCenters",t,e,n);return[r.image.resizeNearestNeighbor(s,[o[0],o[1]],i,a)]}case"CropAndResize":{const s=N("image",t,e,n),o=N("boxes",t,e,n),i=N("boxInd",t,e,n),a=N("cropSize",t,e,n),l=N("method",t,e,n),c=N("extrapolationValue",t,e,n);return[r.image.cropAndResize(s,o,i,a,l,c)]}case"ImageProjectiveTransformV3":{const s=N("images",t,e,n),o=N("transforms",t,e,n),i=N("outputShape",t,e,n),a=N("fillValue",t,e,n),l=N("interpolation",t,e,n),c=N("fillMode",t,e,n);return[r.image.transform(s,o,l.toLowerCase(),c.toLowerCase(),a,i)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y0e=(t,e,n,r=Jn)=>{switch(t.op){case"Equal":return[r.equal(N("a",t,e,n),N("b",t,e,n))];case"NotEqual":return[r.notEqual(N("a",t,e,n),N("b",t,e,n))];case"Greater":return[r.greater(N("a",t,e,n),N("b",t,e,n))];case"GreaterEqual":return[r.greaterEqual(N("a",t,e,n),N("b",t,e,n))];case"Less":return[r.less(N("a",t,e,n),N("b",t,e,n))];case"LessEqual":return[r.lessEqual(N("a",t,e,n),N("b",t,e,n))];case"LogicalAnd":return[r.logicalAnd(N("a",t,e,n),N("b",t,e,n))];case"LogicalNot":return[r.logicalNot(N("a",t,e,n))];case"LogicalOr":return[r.logicalOr(N("a",t,e,n),N("b",t,e,n))];case"Select":case"SelectV2":return[r.where(N("condition",t,e,n),N("a",t,e,n),N("b",t,e,n))];case"BitwiseAnd":return[r.bitwiseAnd(N("a",t,e,n),N("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x0e=(t,e,n,r=Jn)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(N("a",t,e,n),N("b",t,e,n),N("transposeA",t,e,n),N("transposeB",t,e,n))];case"Einsum":return[r.einsum(N("equation",t,e,n),...N("tensors",t,e,n))];case"Transpose":return[r.transpose(N("x",t,e,n),N("perm",t,e,n))];case"_FusedMatMul":const[s,o]=N("fusedOps",t,e,n),i=s==="biasadd",a=o==="prelu",l=N("numArgs",t,e,n),c=N("leakyreluAlpha",t,e,n);if(i){if(a&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[d,f]=N("args",t,e,n);return[r.fused.matMul({a:N("a",t,e,n),b:N("b",t,e,n),transposeA:N("transposeA",t,e,n),transposeB:N("transposeB",t,e,n),bias:d,activation:o,preluActivationWeights:f,leakyreluAlpha:c})];case"MatrixBandPart":return[r.linalg.bandPart(N("a",t,e,n),N("numLower",t,e,n),N("numUpper",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v0e=(t,e,n,r=Jn)=>{switch(t.op){case"EuclideanNorm":return[r.euclideanNorm(N("x",t,e,n),N("axis",t,e,n),N("keepDims",t,e,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(N("x",t,e,n),N("mean",t,e,n),N("variance",t,e,n),N("offset",t,e,n),N("scale",t,e,n),N("epsilon",t,e,n))];case"FusedBatchNormV3":return[r.batchNorm(N("x",t,e,n),N("mean",t,e,n),N("variance",t,e,n),N("offset",t,e,n),N("scale",t,e,n),N("epsilon",t,e,n))];case"LRN":return[r.localResponseNormalization(N("x",t,e,n),N("radius",t,e,n),N("bias",t,e,n),N("alpha",t,e,n),N("beta",t,e,n))];case"Softmax":return[r.softmax(N("x",t,e,n))];case"LogSoftmax":return[r.logSoftmax(N("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b0e=(t,e,n,r=Jn)=>{switch(t.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:o}=r.raggedGather(N("paramsNestedSplits",t,e,n),N("paramsDenseValues",t,e,n),N("indices",t,e,n),N("outputRaggedRank",t,e,n));return s.concat(o)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:o}=r.raggedRange(N("starts",t,e,n),N("limits",t,e,n),N("splits",t,e,n));return[s,o]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(N("shape",t,e,n),N("values",t,e,n),N("defaultValue",t,e,n),N("rowPartitionTensors",t,e,n),N("rowPartitionTypes",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w0e=(t,e,n,r=Jn)=>{switch(t.op){case"Max":{const a=N("axis",t,e,n),l=N("keepDims",t,e,n);return[r.max(N("x",t,e,n),a,l)]}case"Mean":{const a=N("axis",t,e,n),l=N("keepDims",t,e,n);return[r.mean(N("x",t,e,n),a,l)]}case"Min":{const a=N("axis",t,e,n),l=N("keepDims",t,e,n);return[r.min(N("x",t,e,n),a,l)]}case"Sum":{const a=N("axis",t,e,n),l=N("keepDims",t,e,n);return[r.sum(N("x",t,e,n),a,l)]}case"All":{const a=N("axis",t,e,n),l=N("keepDims",t,e,n);return[r.all(N("x",t,e,n),a,l)]}case"Any":{const a=N("axis",t,e,n),l=N("keepDims",t,e,n);return[r.any(N("x",t,e,n),a,l)]}case"ArgMax":{const a=N("axis",t,e,n);return[r.argMax(N("x",t,e,n),a)]}case"ArgMin":{const a=N("axis",t,e,n);return[r.argMin(N("x",t,e,n),a)]}case"Prod":{const a=N("axis",t,e,n),l=N("keepDims",t,e,n);return[r.prod(N("x",t,e,n),a,l)]}case"Cumprod":{const a=N("axis",t,e,n),l=N("exclusive",t,e,n),c=N("reverse",t,e,n);return[r.cumprod(N("x",t,e,n),a,l,c)]}case"Cumsum":{const a=N("axis",t,e,n),l=N("exclusive",t,e,n),c=N("reverse",t,e,n);return[r.cumsum(N("x",t,e,n),a,l,c)]}case"Bincount":const s=N("x",t,e,n),o=N("weights",t,e,n),i=N("size",t,e,n);return[r.bincount(s,o,i)];case"DenseBincount":{const a=N("x",t,e,n),l=N("weights",t,e,n),c=N("size",t,e,n),d=N("binaryOutput",t,e,n);return[r.denseBincount(a,l,c,d)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S0e=(t,e,n,r=Jn)=>{switch(t.op){case"ConcatV2":case"Concat":{const s=N("n",t,e,n),o=N("axis",t,e,n);let i=N("tensors",t,e,n);return i=i.slice(0,s),[r.concat(i,o)]}case"Gather":{const s=N("x",t,e,n),o=N("indices",t,e,n);return[r.gather(s,r.cast(o,"int32"),0)]}case"GatherV2":{const s=N("axis",t,e,n),o=N("batchDims",t,e,n),i=N("x",t,e,n),a=N("indices",t,e,n);return[r.gather(i,r.cast(a,"int32"),s,o)]}case"Reverse":{const s=N("dims",t,e,n),o=[];for(let a=0;a<s.length;a++)s[a]&&o.push(a);const i=N("x",t,e,n);return[r.reverse(i,o)]}case"ReverseV2":{const s=N("axis",t,e,n),o=N("x",t,e,n);return[r.reverse(o,s)]}case"Slice":{const s=N("begin",t,e,n),o=N("size",t,e,n);return[r.slice(N("x",t,e,n),s,o)]}case"StridedSlice":{const s=N("begin",t,e,n),o=N("end",t,e,n),i=N("strides",t,e,n),a=N("beginMask",t,e,n),l=N("endMask",t,e,n),c=N("ellipsisMask",t,e,n),d=N("newAxisMask",t,e,n),f=N("shrinkAxisMask",t,e,n),p=N("x",t,e,n);return[r.stridedSlice(p,s,o,i,a,l,c,d,f)]}case"Pack":return nt(()=>{const s=N("axis",t,e,n),o=N("tensors",t,e,n),i=o[0].shape,a=r.squeeze(o[0]).shape,l=o.map(c=>{const d=Vt(c.shape,i);if(!d&&!Vt(r.squeeze(c).shape,a))throw new Error("the input tensors shape does not match");return d?c:r.reshape(c,i)});return[r.stack(l,s)]});case"Unpack":{const s=N("axis",t,e,n),o=N("tensor",t,e,n);return r.unstack(o,s)}case"Tile":{const s=N("reps",t,e,n);return[r.tile(N("x",t,e,n),s)]}case"Split":case"SplitV":{const s=N("axis",t,e,n),o=N("numOrSizeSplits",t,e,n),i=N("x",t,e,n);return r.split(i,o,s)}case"ScatterNd":{const s=N("indices",t,e,n),o=N("values",t,e,n),i=N("shape",t,e,n);return[r.scatterND(s,o,i)]}case"GatherNd":{const s=N("x",t,e,n),o=N("indices",t,e,n);return[r.gatherND(s,o)]}case"SparseToDense":{const s=N("sparseIndices",t,e,n),o=N("outputShape",t,e,n),i=N("sparseValues",t,e,n),a=N("defaultValue",t,e,n);return[r.sparseToDense(s,i,o,i.dtype===a.dtype?a:r.cast(a,i.dtype))]}case"TensorScatterUpdate":{const s=N("indices",t,e,n),o=N("values",t,e,n),i=N("tensor",t,e,n);return[r.tensorScatterUpdate(i,s,o)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C0e=(t,e,n,r=Jn)=>{switch(t.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:o,emptyRowIndicator:i,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(N("indices",t,e,n),N("values",t,e,n),N("denseShape",t,e,n),N("defaultValue",t,e,n));return[s,o,i,a]}case"SparseReshape":{const{outputIndices:s,outputShape:o}=r.sparse.sparseReshape(N("inputIndices",t,e,n),N("inputShape",t,e,n),N("newShape",t,e,n));return[s,o]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(N("data",t,e,n),N("indices",t,e,n),N("segmentIds",t,e,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(N("data",t,e,n),N("indices",t,e,n),N("segmentIds",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $0e=(t,e,n,r=Jn)=>{switch(t.op){case"FFT":return[r.fft(N("x",t,e,n))];case"IFFT":return[r.ifft(N("x",t,e,n))];case"RFFT":return[r.rfft(N("x",t,e,n))];case"IRFFT":return[r.irfft(N("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k0e=(t,e,n,r=Jn)=>{switch(t.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(N("input",t,e,n),N("pattern",t,e,n),N("rewrite",t,e,n),N("replaceGlobal",t,e,n))];case"StringNGrams":{const{nGrams:s,nGramsSplits:o}=r.string.stringNGrams(N("data",t,e,n),N("dataSplits",t,e,n),N("separator",t,e,n),N("nGramWidths",t,e,n),N("leftPad",t,e,n),N("rightPad",t,e,n),N("padWidth",t,e,n),N("preserveShortSequences",t,e,n));return[s,o]}case"StringSplit":{const{indices:s,values:o,shape:i}=r.string.stringSplit(N("input",t,e,n),N("delimiter",t,e,n),N("skipEmpty",t,e,n));return[s,o,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(N("input",t,e,n),N("numBuckets",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T0e=(t,e,n,r=Jn)=>{switch(t.op){case"Cast":return[r.cast(N("x",t,e,n),N("dtype",t,e,n))];case"ExpandDims":{const s=N("axis",t,e,n);return[r.expandDims(N("x",t,e,n),s)]}case"Squeeze":{const s=N("axis",t,e,n);return[r.squeeze(N("x",t,e,n),s)]}case"Reshape":return[r.reshape(N("x",t,e,n),N("shape",t,e,n))];case"EnsureShape":return[r.ensureShape(N("x",t,e,n),N("shape",t,e,n))];case"MirrorPad":return[r.mirrorPad(N("x",t,e,n),N("padding",t,e,n),N("mode",t,e,n))];case"PadV2":case"Pad":return[r.pad(N("x",t,e,n),N("padding",t,e,n),N("constantValue",t,e,n))];case"SpaceToBatchND":{const s=N("blockShape",t,e,n),o=N("paddings",t,e,n);return[r.spaceToBatchND(N("x",t,e,n),s,o)]}case"BatchToSpaceND":{const s=N("blockShape",t,e,n),o=N("crops",t,e,n);return[r.batchToSpaceND(N("x",t,e,n),s,o)]}case"DepthToSpace":{const s=N("blockSize",t,e,n),o=N("dataFormat",t,e,n).toUpperCase();return[r.depthToSpace(N("x",t,e,n),s,o)]}case"BroadcastTo":return[r.broadcastTo(N("x",t,e,n),N("shape",t,e,n))];case"BroadcastArgs":return[r.broadcastArgs(N("s0",t,e,n),N("s1",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $N(t,e,n,r,s=nt){const o=((i,a,l)=>{switch(i.category){case"arithmetic":return s(()=>t0e(i,a,l));case"basic_math":return s(()=>n0e(i,a,l));case"control":return l0e(i,a,l);case"convolution":return s(()=>u0e(i,a,l));case"creation":return s(()=>c0e(i,a,l));case"dynamic":return d0e(i,a,l);case"evaluation":return s(()=>h0e(i,a,l));case"image":return s(()=>g0e(i,a,l));case"graph":return s(()=>f0e(i,a,l));case"logical":return s(()=>y0e(i,a,l));case"matrices":return s(()=>x0e(i,a,l));case"normalization":return s(()=>v0e(i,a,l));case"ragged":return s(()=>b0e(i,a,l));case"reduction":return s(()=>w0e(i,a,l));case"slice_join":return s(()=>S0e(i,a,l));case"sparse":return s(()=>C0e(i,a,l));case"spectral":return s(()=>$0e(i,a,l));case"string":return s(()=>k0e(i,a,l));case"transformation":return s(()=>T0e(i,a,l));case"hash_table":return m0e(i,a,l,r);case"custom":const c=hF(i.op);if(c&&c.customExecutor)return c.customExecutor(new e0e(i,a,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,n);return Ru(o)?o.then(i=>[].concat(i)):[].concat(o)}class kN{constructor(e={},n={},r={},s={},o){this.weightMap=e,this.tensorArrayMap=n,this.tensorListMap=r,this.functionMap=s,this.parseNodeNameCache=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,n){return{id:e,frameName:n,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let n=0;n<this.contexts.length-1;n++){const r=this.contexts.slice(0,this.contexts.length-n);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(n=>n.id===0&&n.iterationId===0?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(e);for(const n in this.tensorListMap)this.tensorListMap[n].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TN(t,e,n,r){const s=new Set,o=[];let i=null,a=null;const l=new Set,c=new Set(Object.keys(t).map(p=>ds(p)[0]));r=r||[];const d=new Set(r.map(p=>ds(p.name)[0])),f=[...e];for(;f.length>0;){const p=f.pop();if((pu(p)||D0e(p)||O0e(p))&&i==null&&(i=p,a=i.children.map(g=>g.name).filter(g=>s.has(g))),s.add(p.name),n[p.name]==null&&!c.has(p.name)&&!d.has(p.name)){if(p.inputs.length===0){o.push(p.name);continue}p.inputs.forEach(g=>{l.has(g.name)||(l.add(g.name),f.push(g))})}}return{inputs:t,outputs:e,usedNodes:s,missingInputs:o,dynamicNode:i,syncInputs:a}}function I0e(t,e){const{usedNodes:n,inputs:r}=e,s=Object.keys(r).map(w=>ds(w)[0]).map(w=>t.nodes[w]),o=t.initNodes||[],i=w=>n.has(typeof w=="string"?w:w.name);function a(w){return[...new Map(w.map(S=>[S.name,S])).values()]}const l=a([...s,...t.weights,...o]).filter(i),c=a([...l,...Object.values(t.nodes)]).filter(i),d=new Map(c.map(w=>[w.name,w])),f={};for(const w of c){f[w.name]=f[w.name]||0;for(const S of w.children)i(S)||(f[S.name]=Number.POSITIVE_INFINITY),f[S.name]=(f[S.name]||0)+1}const p=Object.entries(f).filter(([,w])=>w===0).map(([w])=>w),g=[...p];for(;p.length>0;){const w=p.pop(),S=d.get(w);for(const $ of S.children.filter(i))--f[$.name]===0&&(g.push($.name),p.push($.name))}const y=g.map(w=>d.get(w)),x=N0e(y,l);return E0e(x,l),x}function N0e(t,e){const n=new Map(t.map(i=>[i.name,i])),r=e.map(i=>i.name),s=new Set(r);for(;r.length>0;){const i=r.pop(),a=n.get(i);for(const l of a.children)!n.has(l.name)||s.has(l.name)||(s.add(l.name),r.push(l.name))}return t.filter(i=>s.has(i.name))}class Nm extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function E0e(t,e){const n=new Map(t.map((a,l)=>[a.name,l])),r=new Set(e.map(a=>a.name)),s=a=>r.has(typeof a=="string"?a:a.name),o=new Set(t.map(a=>a.name)),i=a=>o.has(typeof a=="string"?a:a.name);for(const a of t){for(const l of a.children.filter(i)){if(!n.has(l.name))throw new Nm(`Child ${l.name} of node ${a.name} is unreachable.`);if(n.get(a.name)>n.get(l.name))throw new Nm(`Node ${a.name} is scheduled to run after its child ${l.name}.`)}if(!s(a))for(const l of a.inputs){if(!n.has(l.name))throw new Nm(`Input ${l.name} of node ${a.name} is unreachable.`);if(n.get(l.name)>n.get(a.name))throw new Nm(`Node ${a.name} is scheduled to run before its input ${l.name}.`)}}}function R0e(t){const e=new Map(t.map((a,l)=>[a.name,l])),n=Number.MAX_SAFE_INTEGER,r=t.map((a,l)=>pu(a)?n:l),s=a=>{const l=r[e.get(a.name)];return l??-1},o=t.map((a,l)=>a.children.map(s).reduce((c,d)=>Math.max(c,d),r[l])),i=new Map;for(let a=0;a<t.length;++a){const l=o[a];if(l===n)continue;const c=t[a],d=t[l];i.has(d.name)||i.set(d.name,[]),i.get(d.name).push(c)}return i}const _0e=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),P0e=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),A0e=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function pu(t){return _0e.has(t.op)}function D0e(t){return P0e.has(t.op)}function O0e(t){return A0e.has(t.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fg{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const n=Object.keys(e).map(r=>e[r].map(s=>s.id));this._weightIds=[].concat(...n),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const n=e.signatureKey||e.name;return e.defaultOutput?`${n}:${e.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((e,n)=>(e[n]=this._functions[n].signature,e),{})}constructor(e,n){this.graph=e,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new Fg(e.functions[r],this)})}getCompilationKey(e,n){const r=e.map(o=>o.name).sort(),s=n.map(o=>o.name).sort();return r.join(this.SEPARATOR)+"--"+s.join(this.SEPARATOR)}compile(e,n){const r=TN(e,n,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:o,syncInputs:i}=r;if(o!=null)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(s.length>0){const c=n.map(f=>f.name),d=Object.keys(e);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${d}]. Missing the following inputs: [${s}]`)}const a=I0e(this.graph,r),l=R0e(a);return{orderedNodes:a,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;const n=e.clone();return hi(n),n}cloneTensorList(e){return e?e.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([n,r])=>[n,this.cloneTensorList(r)]))}execute(e,n){this.disposeIntermediateTensors(),e=this.mapInputs(e);const r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n);const s=r.map(p=>this.graph.nodes[ds(p)[0]]),o=n.map(p=>ds(p)[0]),i=new Set(o);let a=o.map(p=>this.graph.nodes[p]);a.length===0&&(a=this._outputs);const l=this.getCompilationKey(s,a);let c=this.compiledMap.get(l);c==null&&(c=this.compile(e,a),this.compiledMap.set(l,c));try{this.keepIntermediateTensors=se().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}const d={},f={};return nt(()=>{const p=new kN(this.weightMap,d,f,this.functionExecutorMap,this.parseNodeNameCache),g=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(S=>{const[$,I]=ds(S,p),R=[];R[I]=e[S],g[$]=R,this.keepIntermediateTensors&&(this.clonedTensorsMap[$]=this.cloneTensorList(R))});const y=this.getFrozenTensorIds(g),{orderedNodes:x,nodeLiveUntilMap:w}=c;for(const S of x){if(g[S.name])continue;const $=$N(S,g,p,this._resourceManager);if(Ru($))throw new Error(`The execution of the op '${S.op}' returned a promise. Please use model.executeAsync() instead.`);g[S.name]=$,this.keepIntermediateTensors&&(this.clonedTensorsMap[S.name]=this.cloneTensorList($)),this.checkTensorForDisposalWithNodeLiveUntilInfo(S,g,p,y,i,w.get(S.name))}return this.parent==null&&p.dispose(y),n.map(S=>Yn(S,g,p))})}getFrozenTensorIds(e){const n=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(s=>s.id)));return new Set(n)}checkTensorForDisposal(e,n,r,s,o,i,a){if(!(pu(n)||i.has(e))){for(const l of r[e])l!=null&&(a[l.id]=(a[l.id]||0)+n.children.length);for(const l of n.inputs){if(pu(l))continue;const c=vN(l.name,r,s);if(c!=null)for(const d of c){if(!d||d.kept||o.has(d.id))continue;const f=a[d.id];f===1?(d.dispose(),delete a[d.id]):f!=null&&a[d.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,n,r,s,o,i){function a(l){return pu(l)||o.has(l.name)}if(!(pu(e)||i==null))for(const l of i){if(a(l))continue;const c=vN(l.name,n,r);for(const d of c)!d||d.kept||s.has(d.id)||d.dispose()}}async executeAsync(e,n){return this._executeAsync(e,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const n of e)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,n,r=!1,s={},o={}){this.disposeIntermediateTensors(),r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=se().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}const i=new kN(this.weightMap,s,o,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const a=await this.executeWithControlFlow(e,i,n,r),l=n.map(p=>Yn(p,a,i)),c=l.map(p=>p.id),d=Object.keys(e).map(p=>e[p].id),f=new Set([...c,...d,...this.weightIds]);return Object.values(a).forEach(p=>{p.forEach(g=>{g&&!g.isDisposed&&!f.has(g.id)&&g.dispose()})}),this.parent==null&&i.dispose(f),l}async executeFunctionAsync(e,n,r){const s=e.reduce((o,i,a)=>(o[this.inputs[a].name]=i,o),{});return this._executeAsync(s,this.outputNodes,!0,n,r)}async executeWithControlFlow(e,n,r,s){const o=Object.keys(e),i=o.map(R=>this.graph.nodes[ds(R)[0]]),a=r.map(R=>ds(R)[0]),l=new Set(a);let c=a.map(R=>this.graph.nodes[R]);c.length===0&&(c=this._outputs);const{usedNodes:d,missingInputs:f,dynamicNode:p,syncInputs:g}=TN(e,c,this.weightMap,this._initNodes),y=[...i,...this.graph.weights,...this._initNodes||[]].map(R=>({node:R,contexts:n.currentContext})),x=Object.assign({},this.weightMap);Object.keys(e).forEach(R=>{const[_,O]=ds(R),F=[];F[O]=e[R],x[_]=F});const w={},S=this.getFrozenTensorIds(x),$={};for(;y.length>0;){const R=this.processStack(i,y,n,x,$,S,l,w,d);await Promise.all(R)}p==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const I=c.filter(R=>!pu(R)&&!Yn(R.name,x,n)).map(R=>R.name);if(I.length>0){let R="";throw p!=null&&(R=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${g}]`),new Error(`Cannot compute the outputs [${I}] from the provided inputs [${o}]. Consider providing the following inputs: [${f}]. ${R}`)}return x}processStack(e,n,r,s,o,i,a,l,c){const d=[];for(;n.length>0;){const f=n.pop();r.currentContext=f.contexts;let p="";if(f.node.op==="Enter"&&N("isConstant",f.node,s,r)&&([p]=Qi(f.node.name,r)),s[f.node.name]==null){const g=$N(f.node,s,r,this._resourceManager);p||([p]=Qi(f.node.name,r));const y=r.currentContext;Ru(g)?d.push(g.then(x=>(s[p]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(x)),r.currentContext=y,this.checkTensorForDisposal(p,f.node,s,r,i,a,l),this.processChildNodes(f.node,n,r,s,o,c),x))):(s[p]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(g)),this.checkTensorForDisposal(p,f.node,s,r,i,a,l),this.processChildNodes(f.node,n,r,s,o,c))}else this.processChildNodes(f.node,n,r,s,o,c)}return d}processChildNodes(e,n,r,s,o,i){e.children.forEach(a=>{const[l]=Qi(a.name,r);o[l]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(c=>!!Yn(c,s,r))&&(o[l]=!0,n.push({contexts:r.currentContext,node:a})):a.inputNames.every(c=>!!Yn(c,s,r))&&(o[l]=!0,n.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(n=>n.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(n=>{const r=e[n],[s]=ds(n),o=this.graph.nodes[s];if(o.attrParams.shape&&o.attrParams.shape.value){const i=o.attrParams.shape.value,a=i.length===r.shape.length&&r.shape.every((l,c)=>i[c]===-1||i[c]===l);z(a,()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&z(r.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){var n,r;const s={};for(const o in e){const i=(r=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||r===void 0?void 0:r[o];i!=null?s[i.name]=e[o]:s[o]=e[o]}return s}checkInputs(e){const n=Object.keys(e).filter(r=>{const[s]=ds(r);return this.graph.nodes[s]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(e){return e.map(n=>{var r,s;const o=(s=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||s===void 0?void 0:s[n];return o!=null?o.name:n},{})}checkOutputs(e){e.forEach(n=>{const[r]=ds(n);if(!this.graph.nodes[r])throw new Error(`The output '${n}' is not found in the graph`)})}}class F0e{constructor(e={},n={}){this.hashTableNameToHandle=e,this.hashTableMap=n}addHashTable(e,n){this.hashTableNameToHandle[e]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L0e="?tfjs-format=file",z0e="model.json";class B0e{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,n={},r=GD){this.modelUrl=e,this.loadOptions=n,this.version="n/a",this.io=r,n==null&&(this.loadOptions={}),this.resourceManager=new F0e}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const n=this.io.getLoadHandlers(e,this.loadOptions);if(n.length===0)n.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(n.length>1)throw new Error(`Found more than one (${n.length}) load handlers for URL '${[e]}'`);this.handler=n[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Ru(e)?e.then(n=>n.getWeightStream==null?this.loadSync(n):this.loadStreaming(n)):this.loadSync(e)}loadSync(e){const n=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,n)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const n=await MA(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,n)}loadWithWeightMap(e,n){this.artifacts=e;const r=this.artifacts.modelTopology;let s=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const o=this.artifacts.userDefinedMetadata;o.signature!=null&&(s=o.signature),o.structuredOutputKeys!=null&&(this.structuredOutputKeys=o.structuredOutputKeys)}if(this.signature=s,this.version=`${r.versions.producer}.${r.versions.minConsumer}`,this.executor=new Fg(bN.Instance.transformGraph(r,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(n),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const o=bN.Instance.transformGraph(e.modelInitializer);this.initializer=new Fg(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,n){if(typeof e=="string"){const r=this.io.getSaveHandlers(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const n=e instanceof fn?[e]:e,r={};return n.forEach((s,o)=>r[this.structuredOutputKeys[o]]=s),r}return e}predict(e,n){const r=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(r)}async predictAsync(e,n){const r=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(r)}normalizeInputs(e){var n;if(!(e instanceof fn)&&!Array.isArray(e)){const o=(n=this.signature)===null||n===void 0?void 0:n.inputs;if(o!=null)for(const i in o){const a=o[i];a.resourceId!=null&&(e[i]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];const r=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${e.length} input tensors provided.`);let s=0;return this.inputNodes.reduce((o,i)=>{var a,l,c;const d=(c=(l=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||l===void 0?void 0:l[i])===null||c===void 0?void 0:c.resourceId;return d!=null?o[i]=this.resourceIdToCapturedInput[d]:o[i]=e[s++],o},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const n=this.initializerSignature.outputs,r=Object.keys(n);for(let s=0;s<r.length;s++){const o=r[s],i=n[o];this.resourceIdToCapturedInput[i.resourceId]=e[s]}}}execute(e,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const r=this.executor.execute(e,n);return r.length>1?r:r[0]}async executeAsync(e,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const r=await this.executor.executeAsync(e,n);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((n,r)=>(n[r]=[e[r]],n),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Mt(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function fd(t,e={},n=GD){if(t==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof t=="string"&&(t=M0e(t));const r=new B0e(t,e,n);return await r.load(),r}function M0e(t){return t.endsWith("/")||(t=t+"/"),`${t}${z0e}${L0e}`}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zs=se();zs.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);zs.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);zs.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);zs.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0);zs.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);zs.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);zs.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);zs.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);zs.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);zs.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1);zs.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);zs.registerFlag("WEBGPU_PRINT_SHADER",()=>"");zs.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class V0e{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class W0e{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,n,r=!1,s=!0){let o;const i=IN(e,n);return s?(this.freeBuffers.has(i)||this.freeBuffers.set(i,[]),this.freeBuffers.get(i).length>0?(o=this.freeBuffers.get(i).pop(),this.numFreeBuffers--):(o=this.device.createBuffer({size:e,usage:n,mappedAtCreation:r}),this.numBytesAllocated+=e)):(o=this.device.createBuffer({size:e,usage:n,mappedAtCreation:r}),this.numBytesAllocated+=e),this.usedBuffers.has(i)||this.usedBuffers.set(i,[]),this.usedBuffers.get(i).push(o),this.numUsedBuffers++,this.numBytesUsed+=e,o}releaseBuffer(e,n=!0){if(this.freeBuffers.size===0)return;const r=e.size,s=e.usage,o=IN(r,s),i=this.usedBuffers.get(o),a=i.indexOf(e);if(a<0)throw new Error("Cannot find the buffer in buffer manager");i[a]=i[i.length-1],i.pop(),this.numUsedBuffers--,this.numBytesUsed-=r,n?(this.freeBuffers.get(o).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=r)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,n)=>{e.forEach(r=>{r.destroy()})}),this.usedBuffers.forEach((e,n)=>{e.forEach(r=>{r.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function IN(t,e){return`${t}_${e}`}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class U0e{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,n,r,s){const o=EN(r),i=e*n*o,a=NN(e,n,r,s);if(this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.usedTextures.has(a)||this.usedTextures.set(a,[]),this.numBytesUsed+=i,this.numUsedTextures++,this.freeTextures.get(a).length>0){this.numFreeTextures--;const c=this.freeTextures.get(a).shift();return this.usedTextures.get(a).push(c),c}this.numBytesAllocated+=i;const l=this.device.createTexture({size:[e,n],format:r,usage:s});return this.usedTextures.get(a).push(l),l}releaseTexture(e){if(this.freeTextures.size===0)return;const n=e.width,r=e.height,s=e.format,o=e.usage,i=NN(n,r,s,o);this.freeTextures.has(i)||this.freeTextures.set(i,[]),this.freeTextures.get(i).push(e),this.numFreeTextures++,this.numUsedTextures--;const a=this.usedTextures.get(i),l=a.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(l,1);const c=EN(s),d=n*r*c;this.numBytesUsed-=d}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,n)=>{e.forEach(r=>{r.destroy()})}),this.usedTextures.forEach((e,n)=>{e.forEach(r=>{r.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function NN(t,e,n,r){return`${t}_${e}_${n}_${r}`}function EN(t){if(t==="rgba8unorm")return 16;throw new Error(`${t} is not supported!`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j0e(t,e){if(Math.max(...t)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const n=t.length,r="xyzwuv",s=t.map(i=>`${e}.${r[i]}`),o=new Array(n-1);o[n-2]=s[n-1];for(let i=n-3;i>=0;--i)o[i]=`(${o[i+1]} * ${s[i+1]})`;return o}const Nl=(t,e,n)=>n==="int32"?`atomicAdd(${t}, bitcast<i32>(${e}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${e});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${t}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var pd;(function(t){t[t.FROM_PIXELS=0]="FROM_PIXELS",t[t.DRAW=1]="DRAW"})(pd||(pd={}));const G0e=(t,e,n,r,s)=>{const o={dtype:r.dtype,shape:r.shape},i=K0e(n,o,e),a=t.createShaderModule({code:i,label:e.constructor.name});let l=se().get("WEBGPU_PRINT_SHADER");if(l!==""){l=l.toLowerCase();const c=l.split(",");(l==="all"||c.some(d=>e.shaderKey.toLowerCase().includes(d)))&&(console.group(e.shaderKey),console.debug(i),console.groupEnd())}return s?t.createComputePipelineAsync({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"}):t.createComputePipeline({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})},ut=(t,e="f32")=>{switch(t){case 1:return`${e}`;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${t}-component ${e} is not supported.`)}};function bn(t){if(t<=1)return"i32";if(t===2)return"vec2<i32>";if(t===3)return"vec3<i32>";if(t===4)return"vec4<i32>";if(t===5)return"vec5";if(t===6)return"vec6";throw Error(`GPU for rank ${t} is not yet supported`)}function la(t){if(t===0)return"x";if(t===1)return"y";if(t===2)return"z";if(t===3)return"w";if(t===4)return"u";if(t===5)return"v";throw Error(`Index ${t} is not yet supported`)}function Ee(...t){let e;switch(t.length){case 0:e=`
        fn main()
      `;break;case 1:e=`
        fn main(${t[0]} : i32)
      `;break;default:throw Error("Unreachable")}return e}function RN(t,e){let n;return n=`
     ${H0e(e)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${t?"main(getGlobalIndex());":"main();"};
      }
    `,n}function H0e(t){return`
  @compute @workgroup_size(${t.workgroupSize[0]}, ${t.workgroupSize[1]}, ${t.workgroupSize[2]})
`}function K0e(t,e,n){const r=[],s=n.workgroupSize[0]*n.workgroupSize[1]*n.workgroupSize[2];if(n.outputComponent=n.outputComponent?n.outputComponent:1,r.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${mF(n)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${s}u +
                localIndex);
        `}
      }
    `),n.pixelsOpType!=null){const y=n.pixelsOpType===pd.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${mu(e.dtype,n.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${mu(t[0].dtype,n.outputComponent)}>;`,x=e.shape.length===3?"vec2<i32>":"i32";r.push(`
        struct Uniform {
          outShapeStrides : ${x},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${y}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const w=PN(n);return[_N,r.join(`
`),tg(e.shape),n.getUserCode(),RN(w,n)].join(`
`)}let o,i,a="struct Uniforms { NAN : f32, INFINITY : f32, ";n.variableNames.forEach((y,x)=>{const w=bn(t[x].shape.length);a+=`${y.charAt(0).toLowerCase()+y.slice(1)}Shape : ${w}, `,o=t[x].shape.length-1,i=bn(o),a+=`${y.charAt(0).toLowerCase()+y.slice(1)}ShapeStrides: ${i}, `});const l=bn(e.shape.length);a+=`outShape : ${l}, `,o=e.shape.length-1,i=bn(o),a+=`
         outShapeStrides: ${i}, `,n.size&&(a+="size : i32, "),n.uniforms&&(a+=n.uniforms),a+="};",a=n1e(a),r.push(a),n.atomic?r.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):r.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${mu(e.dtype,n.outputComponent)}>;
    `),n.variableNames.forEach((y,x)=>{r.push(`
      @group(0) @binding(${1+x}) var<storage, read> ${y}: array<${n.variableComponents?mu(t[x].dtype,n.variableComponents[x]):mu(t[x].dtype,n.outputComponent)}>;
        `)}),a!==""&&r.push(`
      @group(0) @binding(${1+n.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const c=J0e(e.shape,n.dispatchLayout),d=[_N,r.join(`
`)+q0e,tg(e.shape),c,e1e(e.shape.length)];n.atomic||d.push(t1e(e.shape,e.dtype,n.outputComponent)),n.variableNames.forEach((y,x)=>{d.push(`${tg(t[x].shape,y)}`)});const f=t.map((y,x)=>Z0e(y,e.shape,n.variableComponents?n.variableComponents[x]:n.outputComponent,n.dispatchLayout.x.length===e.shape.length)).join(`
`);d.push(f),d.push(n.getUserCode());const p=PN(n);return d.push(RN(p,n)),d.join(`
`)}function X0e(t,e,n){let r=t.shaderKey;if(t.pixelsOpType!=null)return r;const s=[],o=[];e.forEach(d=>{s.push(d.shape),o.push(d.dtype)}),s.push(n.shape),o.push(n.dtype);const i=e.map(d=>cd(d.shape,n.shape)),a=e.map(d=>Vt(d.shape,n.shape)).join("_"),l=i.map(d=>d.join("_")).join(";"),c=mF(t)?"flatDispatch":"";return r+="_"+(t.workgroupSize?t.workgroupSize.join(","):"")+s.map(d=>d.length).join(",")+o.join(",")+t.variableNames.join(",")+l+a+c,r}const _N=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,q0e=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function tg(t,e=""){const n=t.length,r=e!==""?`get${e.charAt(0).toUpperCase()+e.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",s=e!==""?`${e.charAt(0).toLowerCase()+e.slice(1)}ShapeStrides`:"outShapeStrides";if(n<=1)return`fn ${r}(index : i32) -> i32 { return index; }`;const o=gn(t),i=bn(n),a=[];for(let c=0;c<n;c++)a.push(`d${c}`);if(o.length===1)return`    fn ${r}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${s}; let d1 = index - d0 * uniforms.${s};
      return vec2<i32>(d0, d1);
    }`;let l;return l="var index2 = index;"+o.map((c,d)=>{const f=`let ${a[d]} = index2 / uniforms.${s}.${la(d)}`,p=d===o.length-1?`let ${a[d+1]} = index2 - ${a[d]} * uniforms.${s}.${la(d)}`:`index2 = index2 - ${a[d]} * uniforms.${s}.${la(d)}`;return`${f}; ${p};`}).join(""),`
    fn ${r}(index : i32) -> ${i} {
      ${l}
      return ${i}(${a.join(",")});
    }
  `}function Y0e(t,e){const n=t.name,r=t.shape.length,s=bn(r),o="get"+n.charAt(0).toUpperCase()+n.slice(1),i=["d0","d1","d2","d3","d4","d5"].slice(0,r),a=i.map(d=>`${d} : i32`).join(", ");if(r<1)return`
      fn ${o}() -> ${ut(e)} {
        return ${ut(e)}(${n}[0]);
      }
    `;const l=`uniforms.${n.charAt(0).toLowerCase()+n.slice(1)}Shape`;let c=`${r}D`;return r===0&&(c="1D"),`
    fn ${o}(${a}) -> ${ut(e)} {
      return ${ut(e)}(${n}[getIndexFromCoords${c}(${s}(${i.join(",")}),
        ${l})${e===1?"":` / ${e}`}]);
    }
   `}function Q0e(t,e,n,r){const s=t.name,o=s.charAt(0).toUpperCase()+s.slice(1),i="get"+o+"ByOutput",a=t.shape.length,l=e.length,c=bn(l);if(Vt(t.shape,e)&&r)return`
    fn ${i}Index(globalIndex : i32) -> ${ut(n)} {
      return ${ut(n)}(${s}[globalIndex]);
    }

    fn ${i}Coords(coords : ${c}) -> ${ut(n)} {
      return ${ut(n)}(${s}[${l>1?"getOutputIndexFromCoords(coords)":"coords"}${n===1?"":` / ${n}`}]);
    }
    `;const d=cd(t.shape,e),f=l-a;let p="";if(a===0)return`
    fn ${i}Index(globalIndex : i32) -> ${ut(n)}{
      return get${o}();
    }

    fn ${i}Coords(coords : ${c}) -> ${ut(n)}{
      return get${o}();
    }
  `;l<2&&d.length>=1?p="coords = 0;":p=d.map(w=>`coords.${la(w+f)} = 0;`).join(`
`);let g="";if(l<2&&a>0)g="coords";else if(l>1){const w=bn(a),S=t.shape.map(($,I)=>`coords.${la(I+f)}`).join(", ");g=`${w}(${S})`}else g="coords";const y=`uniforms.${s.charAt(0).toLowerCase()+s.slice(1)}Shape`,x=`${a}D`;return`
  fn ${i}Index(globalIndex : i32) -> ${ut(n)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${p}
    return ${ut(n)}(${s}[getIndexFromCoords${x}(${g}, ${y})${n===1?"":` / ${n}`}]);
  }

  fn ${i}Coords(coordsIn : ${c}) -> ${ut(n)} {
    var coords = coordsIn;
    ${p}
    return ${ut(n)}(${s}[getIndexFromCoords${x}(${g}, ${y})${n===1?"":` / ${n}`}]);
  }
`}function Z0e(t,e,n,r){let s=Y0e(t,n);return t.shape.length<=e.length&&(s+=Q0e(t,e,n,r)),s}function J0e(t,e){const{x:n,y:r=[],z:s=[]}=e,o=t.length,i=n.length+r.length+s.length;if(i!==o)return"";if(n.length===o)return`fn getOutputCoords() -> ${bn(o)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let a="";const l=[n,r,s];for(let p=0;p<l.length;p++){const g=l[p];if(g.length!==0)if(g.length===1)a+=`let d${g[0]} = i32(globalId[${p}]);`;else{const y=j0e(g,"uniforms.outShape");a+=`var index${p} = i32(globalId[${p}]);`;for(let x=0;x<y.length;x++)a+=`let d${g[x]} = index${p} / ${y[x]};`,x===y.length-1?a+=`let d${g[x+1]} = index${p} - d${g[x]} * ${y[x]};`:a+=`index${p} = index${p} - d${g[x]} * ${y[x]};`}}const c=[];for(let p=0;p<i;p++)c.push(`d${p}`);const d=bn(i);let f=`fn getOutputCoords() -> ${d} {
  ${a}
`;return c.length===0?f+=`return ${d}(0); }`:f+=`return ${d}(${c.join(",")}); }`,f}function e1e(t){let e="";switch(t){case 0:case 1:e+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:e+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:e+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:z(!1,()=>`Unsupported ${t}D shape`);break}return e}function mF(t){return t.dispatch[1]===1&&t.dispatch[2]===1}function mu(t,e=1){if(t==="float32")return ut(e,"f32");if(t==="int32"||t==="bool")return ut(e,"i32");throw new Error(`type ${t} is not supported.`)}function t1e(t,e,n){const r=t.length,s=mu(e,n);let o=`fn setOutputAtIndex(flatIndex : i32, value : ${ut(n)}) {
      result[flatIndex] = ${s}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${ut(n,"i32")}) {
      result[flatIndex] = ${s}(value);
    }
    `;if(r>=2){const i=["d0","d1","d2","d3","d4","d5"].slice(0,r),a=bn(r);o+=`
      fn setOutputAtCoords(${i.map(l=>`${l} : i32`).join(", ")}, value : ${ut(n)}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${i.join(", ")}));
        setOutputAtIndex(flatIndex${n===1?"":` / ${n}`}, value);
      }
      fn setOutputAtCoordsI32(${i.map(l=>`${l} : i32`).join(", ")}, value : ${ut(n,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${i.join(", ")}));
        setOutputAtIndexI32(flatIndex${n===1?"":` / ${n}`}, value);
      }
    `}return o}function n1e(t){const e=/(\w+)\s*:\s*vec(5|6)/g;t=t.replace(e,r=>"@align(16) "+r);const n=/vec(5|6)\s*,\s*(\w+)/g;return t=t.replace(n,(r,s,o)=>`vec${s}, @align(16) ${o}`),t}function PN(t){return!(t.dispatchLayout.hasOwnProperty("y")&&t.dispatchLayout.y.length!==0||t.dispatchLayout.hasOwnProperty("z")&&t.dispatchLayout.z.length!==0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iu=t=>{let e=1;for(let n=0;n<t.length;n++)e*=t[n];return e};function Re(t,e,n=[1,1,1],r=[1,1,1]){const[s,o,i]=[Math.ceil(Iu(t.x.map(a=>e[a]))/(n[0]*r[0])),t.y?Math.ceil(Iu(t.y.map(a=>e[a]))/(n[1]*r[1])):1,t.z?Math.ceil(Iu(t.z.map(a=>e[a]))/(n[2]*r[2])):1];return[s,o,i]}function r1e(t,e,n,r=!1){const s=[8,8,1],o=[4,4,1];return r||(t<=8&&(o[1]=1),e<=16&&n<=16&&(s[0]=4)),{workgroupSize:s,elementsPerThread:o}}function gF(t,e,n=!1){if(n)return[8,8,1];const r=Iu(t.x.map(o=>e[o])),s=Iu(t.y.map(o=>e[o]));return r<=4?[4,16,1]:s<=4?[16,4,1]:[16,16,1]}function yF(t,e,n=!1){if(n)return[4,4,1];const r=Iu(t.x.map(o=>e[o])),s=Iu(t.y.map(o=>e[o]));return r<=4?[1,2,1]:s<=4?[2,1,1]:[2,2,1]}function De(t){return{x:t.map((e,n)=>n)}}function AN(t){if(t==="float32"||t==="int32"||t==="bool"||t==="string")return 4;if(t==="complex64")return 8;throw new Error(`Unknown dtype ${t}`)}function xF(){return!!(typeof globalThis<"u"&&globalThis.navigator&&globalThis.navigator.gpu)}function vF(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&z(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGPU backend.`)})}var ai;(function(t){t[t.MatMulReduceProgram=0]="MatMulReduceProgram",t[t.MatMulSplitKProgram=1]="MatMulSplitKProgram",t[t.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",t[t.MatMulPackedProgram=3]="MatMulPackedProgram",t[t.MatMulMax=4]="MatMulMax"})(ai||(ai={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s1e=se().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),o1e=(t,e)=>{const n=t.limits.maxComputeWorkgroupsPerDimension,r=e.dispatchLayout,s=e.dispatch;if(s.every(i=>i<=n))return s;z(s[0]>n&&r.y===void 0&&r.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let o=Math.ceil(Math.sqrt(s[0]));return o>n?(o=Math.ceil(Math.cbrt(s[0])),z(o<=n,()=>"Total dispatch size exceeds WebGPU maximum."),[o,o,o]):[o,o,1]};class Od extends Jb{nextDataId(){return Od.nextDataId++}constructor(e,n){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!xF())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new V0e(n),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new W0e(this.device),this.textureManager=new U0e(this.device),this.tensorMap=new UP(this,hs()),se().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e,n=!1){if(!this.tensorMap.has(e))return!0;const r=this.tensorMap.get(e);return n?r.refCount=0:r.refCount--,r.refCount>0?!1:(r.complexTensorInfos!=null&&(this.disposeData(r.complexTensorInfos.real.dataId),this.disposeData(r.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const n=this.tensorMap.get(e);if(!(!n||!n.resource)){if(n.external){n.resource=null;return}n.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(n.resource):n.resource instanceof GPUTexture&&this.textureManager.releaseTexture(n.resource),n.resource=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){const n=this.tensorMap.get(e);n.refCount++}decRef(e){if(this.tensorMap.has(e)){const n=this.tensorMap.get(e);n.refCount--}}write(e,n,r){if(r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.tensorMap.set(s,{dtype:r,shape:n,values:e,refCount:1}),s}move(e,n,r,s,o){if(s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:s,shape:r,values:n,refCount:o})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(n){throw new Error(n.message)}Object.keys(this.pipelineCache).map((n,r)=>{this.pipelineCache[n]=e[r]})}async getBufferData(e){if(se().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const n=e.size,r=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,r,0,n),this.submitQueue(),await r.mapAsync(GPUMapMode.READ);const s=r.getMappedRange().slice(0);return r.unmap(),r!=null&&this.bufferManager.releaseBuffer(r),se().getBool("WEBGPU_USE_PROFILE_TOOL")&&(z(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),s}convertAndCacheOnCPU(e,n){const r=this.tensorMap.get(e);return r.values=n,r.values}readSync(e){const n=this.tensorMap.get(e),{values:r,complexTensorInfos:s}=n;if(r!=null||n.dtype==="string")return r;if(n.dtype==="complex64"){const x=this.readSync(s.real.dataId),w=this.readSync(s.imag.dataId),S=V1(kf(x,w).buffer,"float32");return this.convertAndCacheOnCPU(e,S),S}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const o=["opaque","premultiplied"],i=n.resource,a=i.size;z(a%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const l=a/4,c=new ArrayBuffer(a),d=256,f=256,p=o.map(x=>new OffscreenCanvas(d,f)),g=new OffscreenCanvas(d,f);this.endComputePassEncoder(),p.map((x,w)=>{const S=x.getContext("webgpu");return S.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:o[w]}),S.getCurrentTexture()}).map((x,w)=>{const S=d*4,$=(B,M,V)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:i,bytesPerRow:S,offset:V},{texture:x},{width:B,height:M}),this.submitQueue();const P=g.getContext("2d",{willReadFrequently:!0});P.clearRect(0,0,B,M),P.drawImage(p[w],0,0);const re=P.getImageData(0,0,B,M).data,ie=o[w],me=new Uint8ClampedArray(c,V,B*M*4);for(let ge=0;ge<me.length;ge+=4)if(ie==="premultiplied")me[ge+3]=re[ge+3];else{const ve=re[ge];me[ge]=re[ge+2],me[ge+1]=re[ge+1],me[ge+2]=ve}},I=Math.floor(l/(d*f));let R=d,_=f,O=0;for(let B=0;B<I;B++)$(R,_,O),O+=d*f*4;const F=l%(d*f);_=Math.floor(F/d),_>0&&($(R,_,O),O+=_*(d*4)),R=F%d,R>0&&$(R,1,O)});const y=V1(c,n.dtype);return this.convertAndCacheOnCPU(e,y),y}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const n=this.tensorMap.get(e),{values:r}=n;if(r!=null)return r;let s;if(n.dtype==="complex64"){const o=await Promise.all([this.read(n.complexTensorInfos.real.dataId),this.read(n.complexTensorInfos.imag.dataId)]),i=o[0],a=o[1];s=kf(i,a)}else{const o=await this.getBufferData(n.resource);s=V1(o,n.dtype)}return this.convertAndCacheOnCPU(e,s),s}copyBuffer(e){const n=e.size,r=e.usage,s=this.bufferManager.acquireBuffer(n,r);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,s,0,n),this.submitQueue(),s}createTensorFromGPUData(e,n,r){let s=e.buffer;if(r==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const o={id:this.nextDataId()};this.tensorMap.set(o,{dtype:r,shape:n,values:null,refCount:1,external:e.zeroCopy});const i=this.tensorMap.get(o),a=AN(i.dtype)*pe(i.shape);if(e.buffer.size<a)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${a})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return e.zeroCopy!==!0&&(s=this.copyBuffer(s)),i.resource=s,hs().makeTensorFromDataId(o,n,r,this)}readToGPU(e){const n=this.tensorMap.get(e),{values:r,dtype:s,shape:o,resource:i}=n;if(s==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(i==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const a=i,l=a.size,c=a.usage,d=this.bufferManager.acquireBuffer(l,c);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(i,0,d,0,l),this.submitQueue();const f=this.makeTensorInfo(o,s),p=hs().makeTensorFromTensorInfo(f),g=this.tensorMap.get(f.dataId);return g.resource=d,{tensorRef:p,buffer:d}}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const r=n.map(s=>fa(s));return Wt(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Wt(e.shape,e.dtype,n)}async time(e){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const n=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const o=pa(this.activeTimers.map(c=>c.query)).filter(c=>c!=null),i=pa(this.activeTimers.map(c=>c.name)).filter(c=>c!=null);this.activeTimers=n,s&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},l=await Promise.all(o);return a.kernelMs=jP(l),a.getExtraProfileInfo=()=>l.map((c,d)=>({name:i[d],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,a}makeTensorInfo(e,n,r){return n==="string"&&r!=null&&r.length>0&&Gf(r[0])&&(r=r.map(o=>hl(o))),{dataId:this.write(r,e,n),shape:e,dtype:n}}tensorToBinding(e){if(!e)return null;const r=this.tensorMap.get(e.dataId).resource;return r instanceof GPUBuffer?{buffer:r}:r instanceof GPUTexture?r.createView():r}uploadToGPU(e){const n=this.tensorMap.get(e);if(n.resource!=null)return;const r=AN(n.dtype)*pe(n.shape);let s;const o=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(n.values){if(s=this.bufferManager.acquireBuffer(r,o,!0),s.mapState==="unmapped"){const i=this.bufferManager.acquireBuffer(r,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),a=i.getMappedRange();n.dtype==="int32"||n.dtype==="bool"?new Int32Array(a).set(n.values):new Float32Array(a).set(n.values),i.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(i,0,s,0,r),this.stagingPendingDisposal.push(i)}else{const i=s.getMappedRange();n.dtype==="int32"||n.dtype==="bool"?new Int32Array(i).set(n.values):new Float32Array(i).set(n.values),s.unmap()}n.values=null}else s=this.bufferManager.acquireBuffer(r,o);n.resource=s}makeUniforms(e){let n=0,r=0;const s=[];let o=1;e.forEach(l=>{l.data.length===0&&(l.data=[1]);let c;switch(l.data.length){case 1:c=4;break;case 2:c=8;break;case 3:c=16;break;case 4:c=16;break;case 5:c=16;break;case 6:c=16;break;default:z(!1,()=>`Unsupported ${l.data.length}D shape`)}(r===5||r===6)&&(c=16),c>o&&(o=c),n=Math.ceil(n/c)*c,r=l.data.length,s.push(n),n+=l.data.length*4}),n=Math.ceil(n/o)*o;const i=new ArrayBuffer(n);e.forEach((l,c)=>{const d=s[c];l.type==="int32"?new Int32Array(i,d,l.data.length).set(l.data):l.type==="uint32"?new Uint32Array(i,d,l.data.length).set(l.data):new Float32Array(i,d,l.data.length).set(l.data)});const a=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(a,0,i,0,n),this.uniformPendingDisposal.push(a),{offset:0,size:n,buffer:a}}runWebGPUProgram(e,n,r,s,o){if(o||(o=this.makeTensorInfo(e.outputShape,r)),pe(o.shape)===0)return this.tensorMap.get(o.dataId).values=Si(o.dtype,0),o;this.uploadToGPU(o.dataId),e.dispatch=o1e(this.device,e);const i=n.map((l,c)=>{if(l.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(l.dataId),{dtype:this.tensorMap.get(l.dataId).dtype,shape:l.shape,name:e.variableNames[c]}});e.shaderKey=X0e(e,i,o);const a=se().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=G0e(this.device,e,i,o,a)),e.pipeline=this.pipelineCache[e.shaderKey],a||this.recordAndSubmit(e,o,n,s),o}recordAndSubmit(e,n,r,s){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let o=[],i=[];const a="int32";if(e.pixelsOpType==null){o.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),i=r.concat(n).map(g=>g.shape);const p="int32";i.map(g=>{o.push({type:p,data:g});const y=gn(g);o.push({type:p,data:y})})}else{const p=gn(n.shape);o.push({type:a,data:p})}if(e.size){const p=pe(e.outputShape);o.push({type:a,data:[e.outputComponent?p/e.outputComponent:p]})}s&&(o=[...o,...s]);const l=[this.tensorToBinding(n),...r.map(p=>this.tensorToBinding(p)),this.makeUniforms(o)];r.forEach(p=>{this.commandQueueOwnedIds.add(p.dataId)}),this.commandQueueOwnedIds.add(n.dataId);const c=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:l.map((p,g)=>({binding:g,resource:p}))}),d=this.activeTimers!=null;this.ensureCommandEncoderReady();const f={};d&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),f.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(f)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(f)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,c),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(d||se().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===pd.DRAW)&&(this.endComputePassEncoder(),d?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.querySetCount*8),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const n=new BigUint64Array(e.getMappedRange()),r=Number(n[1]-n[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),r}shouldExecuteOnCPU(e,n=s1e){return se().getBool("WEBGPU_CPU_FORWARD")&&e.every(r=>this.tensorMap.get(r.dataId).resource==null&&pe(r.shape)<n)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}Od.nextDataId=0;/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */xF()&&LA("webgpu",async()=>{const t={powerPreference:se().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(t),n={},r=[];e.features.has("timestamp-query")&&r.push("timestamp-query"),e.features.has("bgra8unorm-storage")&&r.push(["bgra8unorm-storage"]),n.requiredFeatures=r;const s=e.limits;n.requiredLimits={maxComputeWorkgroupStorageSize:s.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:s.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:s.maxStorageBufferBindingSize,maxBufferSize:s.maxBufferSize,maxComputeWorkgroupSizeX:s.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:s.maxComputeInvocationsPerWorkgroup};const o=await e.requestDevice(n),i="info"in e?e.info:"requestAdapterInfo"in e?await e.requestAdapterInfo():void 0;return new Od(o,i)},3);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Je;(function(t){t[t.ADD=0]="ADD",t[t.ATAN2=1]="ATAN2",t[t.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",t[t.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",t[t.DIV=4]="DIV",t[t.ELU_DER=5]="ELU_DER",t[t.EQUAL=6]="EQUAL",t[t.FLOOR_DIV=7]="FLOOR_DIV",t[t.GREATER=8]="GREATER",t[t.GREATER_EQUAL=9]="GREATER_EQUAL",t[t.LESS=10]="LESS",t[t.LESS_EQUAL=11]="LESS_EQUAL",t[t.LOGICAL_AND=12]="LOGICAL_AND",t[t.LOGICAL_OR=13]="LOGICAL_OR",t[t.MAX=14]="MAX",t[t.MIN=15]="MIN",t[t.MOD=16]="MOD",t[t.MUL=17]="MUL",t[t.NOT_EQUAL=18]="NOT_EQUAL",t[t.POW=19]="POW",t[t.PRELU=20]="PRELU",t[t.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",t[t.SUB=22]="SUB"})(Je||(Je={}));const i1e="let resultTemp = a + b;",a1e="let resultTemp = atan2(a, b);",l1e="let resultTemp = areal * breal - aimag * bimag;",u1e="let resultTemp = areal * bimag + aimag * breal;",c1e="let resultTemp = a / b;",d1e="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",h1e=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,f1e=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,p1e=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,m1e=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,g1e=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,y1e=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,x1e="return f32(a >= 1.0 && b >= 1.0);",v1e=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,b1e="return f32(a >= 1.0 || b >= 1.0);",w1e=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,S1e="let resultTemp = max(a, b);",C1e="let resultTemp = min(a, b);",$1e=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,k1e=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,T1e="let resultTemp = a * b;",I1e=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,N1e=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,E1e=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,R1e=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,_1e="if (a < 0.0) { return b * a; }  return a;",P1e=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,A1e="let resultTemp = (a - b) * (a - b);",D1e="let resultTemp = a - b;";function BC(t,e){let n;do{switch(t){case Je.ATAN2:n=a1e;break;case Je.MAX:n=S1e;break;case Je.MIN:n=C1e;break;case Je.MOD:n=e?k1e:$1e;break;case Je.NOT_EQUAL:n=e?N1e:I1e;break;case Je.POW:n=e?R1e:E1e;break;default:continue}let r,s,o;return e?(r="isnanVec4",s="vec4<f32>",o="vec4<bool>"):(r="isnan",s="f32",o="bool"),`
      let aIsNaN = ${r}(a);
      let aPostLegalization = select(a, ${s}(42), aIsNaN);
      let bIsNaN = ${r}(b);
      let bPostLegalization = select(b, ${s}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${n}
        return select(
            resultTemp, ${s}(valueForNaN),
            ${o}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(t){case Je.ADD:n=i1e;break;case Je.COMPLEX_MULTIPLY_IMAG:n=u1e;break;case Je.COMPLEX_MULTIPLY_REAL:n=l1e;break;case Je.DIV:n=c1e;break;case Je.ELU_DER:n=d1e;break;case Je.EQUAL:n=h1e;break;case Je.FLOOR_DIV:n=f1e;break;case Je.GREATER:n=p1e;break;case Je.GREATER_EQUAL:n=m1e;break;case Je.LESS:n=g1e;break;case Je.LESS_EQUAL:n=y1e;break;case Je.LOGICAL_AND:return e?v1e:x1e;case Je.LOGICAL_OR:return e?w1e:b1e;case Je.MUL:n=T1e;break;case Je.PRELU:return e?P1e:_1e;case Je.SQUARED_DIFFERENCE:n=A1e;break;case Je.SUB:n=D1e;break}return`
    ${n}
    return resultTemp;
  `}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ne;(function(t){t[t.ABS=0]="ABS",t[t.ACOS=1]="ACOS",t[t.ACOSH=2]="ACOSH",t[t.ASIN=3]="ASIN",t[t.ASINH=4]="ASINH",t[t.ATAN=5]="ATAN",t[t.ATANH=6]="ATANH",t[t.CEIL=7]="CEIL",t[t.COS=8]="COS",t[t.COSH=9]="COSH",t[t.ELU=10]="ELU",t[t.ERF=11]="ERF",t[t.EXP=12]="EXP",t[t.EXPM1=13]="EXPM1",t[t.FLOOR=14]="FLOOR",t[t.IS_FINITE=15]="IS_FINITE",t[t.IS_INF=16]="IS_INF",t[t.IS_NAN=17]="IS_NAN",t[t.LINEAR=18]="LINEAR",t[t.LOG=19]="LOG",t[t.LOG1P=20]="LOG1P",t[t.LOGICAL_NOT=21]="LOGICAL_NOT",t[t.NEG=22]="NEG",t[t.RELU=23]="RELU",t[t.RELU6=24]="RELU6",t[t.LEAKYRELU=25]="LEAKYRELU",t[t.RECIPROCAL=26]="RECIPROCAL",t[t.ROUND=27]="ROUND",t[t.RSQRT=28]="RSQRT",t[t.SELU=29]="SELU",t[t.SIGMOID=30]="SIGMOID",t[t.SIGN=31]="SIGN",t[t.SIN=32]="SIN",t[t.SINH=33]="SINH",t[t.SOFTPLUS=34]="SOFTPLUS",t[t.SQRT=35]="SQRT",t[t.SQUARE=36]="SQUARE",t[t.STEP=37]="STEP",t[t.TAN=38]="TAN",t[t.TANH=39]="TANH",t[t.TO_INT=40]="TO_INT"})(Ne||(Ne={}));const O1e="return abs(a);",F1e=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,L1e=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,z1e=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,B1e="return asinh(a);",M1e=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,V1e=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,W1e="return ceil(a);",U1e="return cos(a);",j1e=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,G1e="return exp(a) - 1.0;",H1e="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",K1e=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,X1e=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${mC};
  let a1 = ${gC};
  let a2 = ${yC};
  let a3 = ${xC};
  let a4 = ${vC};
  let a5 = ${bC};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,q1e="return exp(a);",Y1e="return floor(a);",Q1e="return f32(!isnan(a) && !isinf(a));",Z1e="return f32(isinf(a));",J1e="return f32(isnan(a));",exe="return a;",txe=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,nxe=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,rxe="return f32(!(a >= 1.0));",sxe="return -a;",oxe="if (a < 0.0) { return uniforms.alpha * a; } return a;",ixe=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,axe="return 1.0 / a;",lxe="return select(a, 0.0, a < 0.0);",uxe="return clamp(a, 0.0, 6.0);",cxe="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",dxe=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,hxe="return round(a);",fxe="return inverseSqrt(a);",pxe=`
  if (a >= 0.0) {
    return ${pC} * a;
  } else {
    return ${fC} * (exp(a) - 1.0);
  }
`,mxe="return 1.0 / (1.0 + exp(-1.0 * a));",gxe="return sign(a);",yxe="return sin(a);",xxe=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,vxe=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,bxe="return sqrt(a);",wxe="return a * a;",Sxe=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,Cxe="return tan(a);",$xe=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,kxe="return f32(i32((a)));";function uu(t,e){switch(t){case Ne.ABS:return O1e;case Ne.ACOS:return F1e;case Ne.ACOSH:return L1e;case Ne.ASIN:return z1e;case Ne.ASINH:return B1e;case Ne.ATAN:return M1e;case Ne.ATANH:return V1e;case Ne.COS:return U1e;case Ne.COSH:return j1e;case Ne.CEIL:return W1e;case Ne.ELU:return e?K1e:H1e;case Ne.ERF:return X1e;case Ne.EXP:return q1e;case Ne.EXPM1:return G1e;case Ne.FLOOR:return Y1e;case Ne.IS_FINITE:return Q1e;case Ne.IS_INF:return Z1e;case Ne.IS_NAN:return J1e;case Ne.LINEAR:return exe;case Ne.LOG:return txe;case Ne.LOG1P:return nxe;case Ne.LOGICAL_NOT:return rxe;case Ne.NEG:return sxe;case Ne.LEAKYRELU:return e?ixe:oxe;case Ne.RECIPROCAL:return axe;case Ne.RELU:return e?dxe:lxe;case Ne.RELU6:return e?cxe:uxe;case Ne.ROUND:return hxe;case Ne.RSQRT:return fxe;case Ne.SELU:return pxe;case Ne.SIGMOID:return mxe;case Ne.SIGN:return gxe;case Ne.SIN:return yxe;case Ne.SINH:return xxe;case Ne.SOFTPLUS:return vxe;case Ne.SQRT:return bxe;case Ne.SQUARE:return wxe;case Ne.STEP:return Sxe;case Ne.TAN:return Cxe;case Ne.TANH:return $xe;case Ne.TO_INT:return kxe;default:throw new Error(`BinaryType ${t} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ta(t,e=!1,n=!1,r=3){if(t===null)return"";let s="";if(t==="linear")s=uu(Ne.LINEAR);else if(t==="relu")s=uu(Ne.RELU,n);else if(t==="elu")s=uu(Ne.ELU,n);else if(t==="relu6")s=uu(Ne.RELU6,n);else if(t==="prelu")s=BC(Je.PRELU,n);else if(t==="sigmoid")s=uu(Ne.SIGMOID,n);else if(t==="leakyrelu")s=uu(Ne.LEAKYRELU,n);else throw new Error(`Activation ${t} has not been implemented for the WebGPU backend.`);const i=ut(n?4:1);let a="";return e?a=`
      fn activation(a : ${i}, coords : vec${r}<i32>) -> ${i} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${s}
      }`:a=`
      fn activation(a : ${i}, coords : vec${r}<i32>) -> ${i} {
        ${s}
      }`,a}function Hu(t,e){return`
      ${t?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bF(t,e,n=!1,r=!1,s=!1,o=1){z(t&&o===1||!t,()=>`transposeA ${t} is not compatible with component size ${o}`);const i=`
      ${t?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,a=e?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${ut(o)} {
    var value = ${ut(o)}(0.0);
    ${n&&s?i:`
    ${t?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${i}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${ut(o)} {
    var value = ${ut(o)}(0.0);
    ${a}
    return value;
  }
  `}function MC(t,e,n,r,s=!1,o=!1,i=!1,a=1){return`
  ${bF(n,r,s,o,i,a)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${ut(a)}) {
    ${s&&o?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${Hu(t,e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}const Txe=(t,e)=>t?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${e});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${e});
        `,Ixe=(t,e,n,r)=>{if(t)return`
      for (var k = 0; k < ${r}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${n}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let s="",o="";for(let i=0;i<e;i++)s+=`let BCached${i} = mm_Bsub[k * ${e} + ${i}][tileCol];`,o+=`acc[i] = fma(BCached${i}, vec4<f32>(ACached[${i}]), acc[i]);`;return`
      for (var k = 0; k < ${r/e}; k++) {
        ${s}
        for (var i = 0; i < ${n}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${o}
        }
      }`}};function $y(t,e,n=!1,r=32,s=!1,o=32,i=!1){const a=e[1]*t[1],l=e[0]*t[0],c=n?a:r,d=n?r:a,f=c/e[0],p=r/e[1],g=t[1],y=t[0];return z((n&&f===4&&t[1]===4||!n&&(f===3||f===4))&&c%e[0]===0&&r%e[1]===0&&t[0]===4,()=>`If transposeA ${n} is true, innerElementSize ${f} and workPerThread[1] ${t[1]} must be 4.
          Otherwise, innerElementSize ${f} must be 3 or 4.
      tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}. tileInner ${r} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${t[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${f}<f32>, ${c/f}>, ${d}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${l/t[0]}>, ${r}>;

  ${Ee()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${g};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${g};
    let globalCol = i32(globalId.x) * ${y};
    let batch = ${s?"0":"i32(globalId.z)"};
    let batchA = ${s||!i?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${s||!i?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${a};

    let numTiles = ${s?`${Math.ceil(o/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};
    var kStart = ${s?`i32(globalId.z) * ${o}`:"0"};

    var acc: array<vec4<f32>, ${g}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${p};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${g}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${Txe(n,f)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${p}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${r};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${Ixe(n,f,g,r)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const DN=t=>t?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,Nxe=t=>t?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function ky(t,e,n=!1,r=32,s=!1,o=32,i=!1,a=!1){const l=t[1]*e[1],c=t[0]*e[0],d=n?l:r,f=n?r:l;z(f%e[1]===0&&d%e[0]===0&&r%e[1]===0,()=>`tileAHight ${f} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${d} must be divisible by workgroupSize[0]${e[0]}, tileInner ${r} must be divisible by workgroupSize[1]${e[1]}`);const p=f/e[1],g=d/e[0],y=r/e[1],x=t[1],w=t[0],S=i?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${l};
      let globalColStart = i32(workgroupId.x) * ${c};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${f}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${e[0]}) {
            ${DN(n)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${r};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${w}>;
        for (var k = 0; k < ${r}; k++) {
          for (var inner = 0; inner < ${w}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < ${x}; innerRow++) {
            let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < ${w}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${x}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < ${w}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${x};
  let tileCol = i32(localId.x) * ${w};

  let globalRow = i32(globalId.y) * ${x};
  let globalCol = i32(globalId.x) * ${w};
  let globalRowStart = i32(workgroupId.y) * ${l};

  let tileRowA = i32(localId.y) * ${p};
  let tileColA = i32(localId.x) * ${g};
  let tileRowB = i32(localId.y) * ${y};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${p}; innerRow++) {
      for (var innerCol = 0; innerCol < ${g}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${DN(n)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${y}; innerRow++) {
      for (var innerCol = 0; innerCol < ${w}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${r};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${w}>;
    for (var k = 0; k < ${r}; k++) {
      for (var inner = 0; inner < ${w}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${x}; innerRow++) {
        ${Nxe(n)}
        for (var innerCol = 0; innerCol < ${w}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${x}; innerRow++) {
    for (var innerCol = 0; innerCol < ${w}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${d}>, ${f}>;
    var<workgroup> mm_Bsub : array<array<f32, ${c}>, ${r}>;

    ${Ee()} {
      let batch = ${s?"0":"i32(globalId.z)"};
      let batchA = ${s||!a?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${s||!a?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${s?`${Math.ceil(o/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};
      var kStart = ${s?`i32(globalId.z) * ${o}`:"0"};

      var acc : array<array<f32, ${w}>, ${x}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${x}; innerRow++) {
        for (var innerCol = 0; innerCol < ${w}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${S}
    }
  `}const Exe=t=>t?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function Rxe(t,e=!1){z(t[1]===1&&t[2]===1,()=>`A linear work group size is required. But got ${t}.`);const n=t[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${t[0]}>;

    ${Ee()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${n} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${n} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${Exe(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${n/4}; k++) {
          let rowB = t * ${n} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}class _xe{constructor(e,n,r=!1,s=!1,o=null,i=null,a=null,l=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]};const c=r?e[1]:e[2];if(this.isVec4=(c%4===0&&!r||n[1]%4===0&&r)&&n[2]%4===0&&!s,this.outputComponent=this.isVec4?4:1,this.isVectorA=n[1]===1&&!r,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const p=r1e(n[1],c,n[2],r);this.workgroupSize=p.workgroupSize,this.elementsPerThread=p.elementsPerThread}this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const d=o!=null,f=a!=null;d&&this.variableNames.push("bias"),f&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=l,this.transposeA=r,this.transposeB=s,this.addBias=d,this.activation=i,this.hasPreluActivationWeights=f,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(n[1],n[2],c),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${r}_${s}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,n,r){const s=this.workgroupSize[1]*this.elementsPerThread[1],o=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=o;const i=e%s===0,a=n%o===0,l=r%this.tileInner===0;return[i,a,l]}getUserCode(){return`
      ${Ta(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${MC(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?$y(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?Rxe(this.workgroupSize,this.transposeA):ky(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pxe(t){return`
    var<workgroup> sumValues : array<f32, ${t}>;
    ${Ee()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${t}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${t/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}class Axe{constructor(e,n=!1,r=!1,s=null,o=null,i=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize);const a=s!=null,l=i!=null;a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.transposeA=n,this.transposeB=r,this.addBias=a,this.activation=o,this.hasPreluActivationWeights=l,this.shaderKey=`matMulReduce_${this.activation}_${n}_${r}`}getUserCode(){return`
      ${Ta(this.activation,this.hasPreluActivationWeights)}
      ${MC(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${Pxe(this.workgroupSize[0])}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dxe(t){const e=t[1],n=t[0],r=e>n?e:n;return`
  var<workgroup> mm_Asub : array<array<f32, ${r}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${r}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${Ee()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${r} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${r};
    globalRowB = globalRowB + ${r};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${r};
      globalRowB = globalRowB + ${r};

      for (var k = 0; k < ${r}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}class Oxe{constructor(e,n,r,s=!1,o=!1,i=null,a=null,l=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=r,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(r[2]/this.workgroupSize[0]),Math.ceil(r[1]/this.workgroupSize[1]),r[0]];const c=i!=null;c&&this.variableNames.push("bias");const d=l!=null;d&&this.variableNames.push("preluActivationWeights"),this.transposeA=s,this.transposeB=o,this.addBias=c,this.activation=a,this.hasPreluActivationWeights=d,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${s}_${o}`}getUserCode(){return`
      ${Ta(this.activation,this.hasPreluActivationWeights)}
      ${MC(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${Dxe(this.workgroupSize)}
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fxe{constructor(e,n,r=!1,s=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,z(e[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const o=(r&&this.outputShape[1]%4===0||!r&&n%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=o?4:1,o||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=Re(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],n],this.workgroupSize,this.elementsPerThread),this.transposeA=r,this.transposeB=s,this.shaderKey=`matMulSplitK_${r}_${s}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`
      ${bF(!1,this.transposeB,!1,!1,!1,e)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${ut(e)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${Nl("&result[flatIndex + i]",`${e>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${e===4?$y(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):ky(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class Lxe{constructor(e,n=null,r=null,s=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=n!=null,this.hasPreluActivationWeights=s!=null,this.activation=r,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${r}`}getUserCode(){return`
    ${Ta(this.activation,this.hasPreluActivationWeights)}
    ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${Hu(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zxe{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jr(t){const{backend:e,attrs:n}=t,{shape:r,value:s}=n;let{dtype:o}=n;if(o=o||$d(s),o==="string"){const i=En(o,pe(r));return i.fill(s),e.makeTensorInfo(r,o,i)}else{const i=new zxe(r),a=[{type:"float32",data:[s]}];return e.runWebGPUProgram(i,[],o,a)}}const Bxe={kernelName:Jw,backendName:"webgpu",kernelFunc:jr};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Be(t){const{inputs:e,attrs:n}=t,{x:r}=e,{shape:s}=n,o=pe(r.shape),i=GP(s,o),a=pe(i);return z(o===a,()=>`The new shape (${i}) has ${a} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),t.backend.incRef(r.dataId),{dataId:r.dataId,shape:i,dtype:r.dtype}}const Mxe={kernelName:Y2,backendName:"webgpu",kernelFunc:Be};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ty({a:t,b:e,transposeA:n,transposeB:r,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:l=null}){const c=t.shape.length,d=e.shape.length,f=n?t.shape[c-2]:t.shape[c-1],p=r?e.shape[d-1]:e.shape[d-2],g=n?t.shape[c-1]:t.shape[c-2],y=r?e.shape[d-2]:e.shape[d-1],x=t.shape.slice(0,-2),w=e.shape.slice(0,-2),S=pe(x),$=pe(w),R=ct(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([g,y]);z(f===p,()=>`Error in matMul: inner shapes (${f}) and (${p}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${r} must match.`);const _=n?[S,f,g]:[S,g,f],O=r?[$,y,p]:[$,p,y],F=Be({inputs:{x:t},backend:s,attrs:{shape:_}}),B=Be({inputs:{x:e},backend:s,attrs:{shape:O}}),M=[F,B],V=Math.max(S,$),P=[F,B],re=[{type:"int32",data:[g]},{type:"int32",data:[y]},{type:"int32",data:[f]}];let ie,me;const ge=[V,g,y];let ve=se().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(ve<0){const fe=se().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),xe=fe>0?fe:s.thresholdToIncreaseWorkgroups,ae=V*Math.ceil(g/32)*Math.ceil(y/32);ae<=xe||g<=8&&ae<=xe*2?V*g*y<=128?ve=ai.MatMulReduceProgram:V===1&&p>=2e3?ve=ai.MatMulSplitKProgram:ve=ai.MatMulSmallOutputSizeProgram:ve=ai.MatMulPackedProgram}switch(ve){case ai.MatMulReduceProgram:ie=new Axe(ge,n,r,o,l,i);break;case ai.MatMulSplitKProgram:{if(me=jr({backend:s,attrs:{shape:ge,value:0,dtype:t.dtype}}),ie=new Fxe(ge,p,n,r),o||l){me=s.runWebGPUProgram(ie,P,t.dtype,re,me);const xe=new Lxe(me.shape,o,l,i);let ae=null;const q=[me];o&&q.push(o),i&&q.push(i),l==="leakyrelu"&&(ae=[{type:"float32",data:[a]}],xe.uniforms+=" alpha : f32,");const ue=s.runWebGPUProgram(xe,q,me.dtype,ae);M.push(me);const we=Be({inputs:{x:ue},backend:s,attrs:{shape:R}});M.push(ue);for(const Ge of M)s.disposeData(Ge.dataId);return we}break}case ai.MatMulSmallOutputSizeProgram:ie=new Oxe(_,O,ge,n,r,o,l,i);break;case ai.MatMulPackedProgram:const fe=s.adapterInfo.isIntel();ie=new _xe(_,ge,n,r,o,l,i,fe);break;default:throw new Error(`Unsupported MatMulProgramType ${ve}.`)}o&&P.push(o),i&&P.push(i),l==="leakyrelu"&&(re.push({type:"float32",data:[a]}),ie.uniforms+=" alpha : f32,"),me=s.runWebGPUProgram(ie,P,t.dtype,re,me);const $e=Be({inputs:{x:me},backend:s,attrs:{shape:R}});M.push(me);for(const fe of M)s.disposeData(fe.dataId);return $e}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vxe(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:o,bias:i,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:d,leakyreluAlpha:f}=r;return Ty({a:s,b:o,transposeA:l,transposeB:c,backend:n,bias:i,preluActivationWeights:a,leakyreluAlpha:f,activation:d})}const Wxe={kernelName:bg,backendName:"webgpu",kernelFunc:Vxe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ON{constructor(e,n,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=ct(n,r),this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${BC(this.op,!1)}
      }

      ${Ee("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lg{constructor(e,n,r){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=ct(n,r),this.dispatchLayout=De(this.outputShape),this.op=e,this.useSharedMemoryWithA=n.length<=1&&r.length>1&&n[0]<128,this.useSharedMemoryWithB=r.length<=1&&n.length>1&&r[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?r[0]:n[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const s=n.length>0&&n[n.length-1]%4===0,o=r.length>0&&r[r.length-1]%4===0;s&&o?(this.outputComponent=4,this.variableComponents=[4,4]):s&&(c3(r)||r[r.length-1]===1)||o&&(c3(n)||n[n.length-1]===1)?(this.outputComponent=4,this.variableComponents=s?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const n=this.outputComponent===4?"vec4<f32>":"f32",r=`
    fn binaryOperation(a : ${n}, b : ${n}) -> ${n} {
      ${BC(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){const s=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",o=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${s}];`:`let a = sharedBuf[${s}];
          let b = getBByOutputIndex(index);`;e=`
        ${r}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${Ee("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${o}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${r}
       ${Ee("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${n}(getAByOutputCoords(coords));
           let b = ${n}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ys(t){const{inputs:e}=t,{x:n}=e;return t.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const Uxe={kernelName:ry,backendName:"webgpu",kernelFunc:ys};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ku(t){const{inputs:e,backend:n}=t,{real:r,imag:s}=e,o=n.makeTensorInfo(r.shape,"complex64"),i=n.tensorMap.get(o.dataId),a=ys({inputs:{x:r},backend:n}),l=ys({inputs:{x:s},backend:n});return i.complexTensorInfos={real:a,imag:l},o}const jxe={kernelName:$w,backendName:"webgpu",kernelFunc:Ku};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fd{constructor(e,n,r=""){this.variableNames=["A"],this.size=!0;const s=128;this.workgroupSize=[s,1,1],this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=n,r!==""&&(this.uniforms=r),this.shaderKey=`unary_${n}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${uu(this.op,!1)}
      }
      ${Ee("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kt({opType:t,cpuKernelImpl:e,dtype:n}){return({inputs:r,backend:s})=>{const{x:o}=r,i=s,a=n||o.dtype;if(i.shouldExecuteOnCPU([o])&&e!=null){const c=i.tensorMap.get(o.dataId),d=e(c.values,a);return i.makeTensorInfo(o.shape,a,d)}const l=new Fd(o.shape,t);return i.runWebGPUProgram(l,[o],a)}}function zn({opType:t,cpuKernelImpl:e,supportsComplex:n=!1,dtype:r}){return({inputs:s,backend:o})=>{const{a:i,b:a}=s,l=o;if(n&&i.dtype==="complex64"){const f=l.tensorMap.get(i.dataId),p=l.tensorMap.get(a.dataId);let g,y;if(t!==Je.MUL)[g,y]=[[f.complexTensorInfos.real,p.complexTensorInfos.real],[f.complexTensorInfos.imag,p.complexTensorInfos.imag]].map(w=>{const[S,$]=w,I={dataId:S.dataId,dtype:S.dtype,shape:i.shape},R={dataId:$.dataId,dtype:$.dtype,shape:a.shape},_=new Lg(t,i.shape,a.shape);return l.runWebGPUProgram(_,[I,R],Gr(S.dtype,$.dtype))});else{const w=new ON(Je.COMPLEX_MULTIPLY_REAL,i.shape,a.shape),S=new ON(Je.COMPLEX_MULTIPLY_IMAG,i.shape,a.shape),$=[{dataId:f.complexTensorInfos.real.dataId,dtype:f.complexTensorInfos.real.dtype,shape:i.shape},{dataId:f.complexTensorInfos.imag.dataId,dtype:f.complexTensorInfos.imag.dtype,shape:i.shape},{dataId:p.complexTensorInfos.real.dataId,dtype:p.complexTensorInfos.real.dtype,shape:a.shape},{dataId:p.complexTensorInfos.imag.dataId,dtype:p.complexTensorInfos.imag.dtype,shape:a.shape}];g=l.runWebGPUProgram(w,$,"float32"),y=l.runWebGPUProgram(S,$,"float32")}const x=Ku({inputs:{real:g,imag:y},backend:l});return l.disposeData(g.dataId),l.disposeData(y.dataId),x}const c=r||Gr(i.dtype,a.dtype);if((i.dtype==="string"||a.dtype==="string"||l.shouldExecuteOnCPU([i,a]))&&e!=null){const f=l.tensorMap.get(i.dataId).values,p=l.tensorMap.get(a.dataId).values,g=i.dtype==="string"?bl(f):f,y=i.dtype==="string"?bl(p):p,[x,w]=e(i.shape,a.shape,g,y,c);return l.makeTensorInfo(w,c,x)}const d=new Lg(t,i.shape,a.shape);return l.runWebGPUProgram(d,[i,a],c)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:Gxe,castImpl:Hxe,ceilImpl:Kxe,concatImpl:Xxe,equalImpl:qxe,expImpl:Yxe,expm1Impl:Qxe,floorImpl:Zxe,floorDivImpl:Jxe,gatherNdImpl:eve,gatherV2Impl:tve,greaterEqualImpl:nve,greaterImpl:rve,lessEqualImpl:sve,lessImpl:ove,logImpl:ive,maxImpl:ave,maximumImpl:lve,minimumImpl:uve,multiplyImpl:cve,negImpl:dve,notEqualImpl:hve,prodImpl:fve,rangeImpl:pve,rsqrtImpl:mve,scatterImpl:gve,simpleAbsImpl:yve,sliceImpl:xve,stridedSliceImpl:vve,stringNGramsImpl:bve,subImpl:wve,tileImpl:Sve,topKImpl:Cve,transposeImpl:$ve}=_O;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kve=kt({opType:Ne.ABS,cpuKernelImpl:yve}),Tve={kernelName:rw,backendName:"webgpu",kernelFunc:kve};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ive=kt({opType:Ne.ACOS}),Nve={kernelName:sw,backendName:"webgpu",kernelFunc:Ive};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eve=kt({opType:Ne.ACOSH}),Rve={kernelName:ow,backendName:"webgpu",kernelFunc:Eve};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ve=zn({opType:Je.ADD,cpuKernelImpl:Gxe,supportsComplex:!0}),Pve={kernelName:ty,backendName:"webgpu",kernelFunc:_ve};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ave{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((n,r)=>`T${r}`),this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(s=>{e.push(`let v${s} = get${s}ByOutputCoords(coords);`)});const n=this.variableNames.map(s=>`v${s}`).join(" + ");return`
      ${Ee("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${n});
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dve(t){const{inputs:e,backend:n}=t,r=e;if(r.length===1)return ys({inputs:{x:r[0]},backend:n});const s=r.map(a=>a.dtype).reduce((a,l)=>Gr(a,l)),o=r.map(a=>a.shape),i=new Ave(o);return n.runWebGPUProgram(i,r,s)}const Ove={kernelName:iw,backendName:"webgpu",kernelFunc:Dve};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fve{constructor(e,n){this.variableNames=["A"],this.workgroupSize=[16,16,1];const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[n[s]];this.outputShape=r,this.dispatchLayout={x:[0],y:[1]},this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){z(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const e=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${Ee()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lve{constructor(e,n){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[n[s]];this.outputShape=r,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=n,this.shaderKey=`transpose_${n}`}getUserCode(){const e=bn(this.outputShape.length),n=wF(this.newDim);return`
      ${Ee("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${n}), uniforms.aShape)]);
          }
        }
      }
    `}}function wF(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=new Array(e);for(let r=0;r<t.length;r++)n[t[r]]=`coords.${la(r)}`;return n.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ci(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{perm:o}=r,i=n,a=s.shape.length,l=new Array(a);for(let d=0;d<l.length;d++)l[d]=s.shape[o[d]];if(n.shouldExecuteOnCPU([s])){const f=i.tensorMap.get(s.dataId).values,p=$ve(f,s.shape,s.dtype,o,l);return n.makeTensorInfo(l,s.dtype,p)}if(s.shape.length===2&&Vt(o,[1,0])){const d=new Fve(s.shape,o);return i.runWebGPUProgram(d,[s],s.dtype)}const c=new Lve(s.shape,o);return i.runWebGPUProgram(c,[s],s.dtype)}const zve={kernelName:Yh,backendName:"webgpu",kernelFunc:Ci};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bve{constructor(e,n,r){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[s]=Ls(this.inputShape,[1]);this.outputShape=s.length===0?[1]:s,e.inSize>=32768&&r>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=n,this.shaderKey=`reduce_${n}`}getUserCode(){let e="",n="0.0";const r=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,n="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(e=" bestValue = bestValue * candidate; ",n="1.0"):this.reduceType==="all"?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",n="1.0"):this.reduceType==="any"&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",n="0.0");const s=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${r}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${Ee("index")} {
         let outputIndex = index / ${r};
         let offset = getOffset(outputIndex);
         var bestValue = ${n};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${r}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${r}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${r}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${s}
        }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mve={mean:"float32",all:"bool",any:"bool"};function Xu(t,e,n,r,s){const o=t.shape.length,i=[],a=nn(e,t.shape);let l=a;const c=ur(l,o);let d=t;c!=null&&(d=Ci({inputs:{x:t},attrs:{perm:c},backend:s}),l=cr(l.length,o),i.push(d)),bs(r,l,o);const[f,p]=Ls(d.shape,l);let g=f;n&&(g=vs(f,a));let y;if((r==="max"||r==="prod")&&s.shouldExecuteOnCPU([d])){const x=s.tensorMap.get(d.dataId).values;switch(r){case"max":const w=ave(x,pe(p),g,t.dtype);y=s.makeTensorInfo(g,t.dtype,w);break;case"prod":const{outVals:S,outShape:$,outDtype:I}=fve(d.shape,d.dtype,x,l);y=s.makeTensorInfo($,I,S);break;default:throw new Error(`${r} CPU implementation is not yet supported.`)}}else{const x=pe(p),S=pe(d.shape)/x,$={windowSize:x,inSize:x,batchSize:S,outSize:1},I=Mve[r]||ay(t.dtype),R=[{type:"int32",data:[x]}],_=new Bve($,r,s.device.limits.maxComputeWorkgroupSizeX),O=s.runWebGPUProgram(_,[d],I,R);i.push(O),y=Be({inputs:{x:O},attrs:{shape:g},backend:s})}return i.forEach(x=>s.disposeData(x.dataId)),y}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vve(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{keepDims:o,axis:i}=r;return Xu(s,i,o,"all",n)}const Wve={kernelName:aw,backendName:"webgpu",kernelFunc:Vve};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uve(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{keepDims:o,axis:i}=r;return Xu(s,i,o,"any",n)}const jve={kernelName:lw,backendName:"webgpu",kernelFunc:Uve};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SF{constructor(e,n,r){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const s=[n];this.op=r==="min"?"<":">";const[o,i]=Ls(e,s);this.outputShape=o.length===0?[1]:o,this.dispatchLayout=De(this.outputShape),pe(i)<32?(this.type="plain",this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=Re(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],n=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${la(this.inputShape.length-1)}`,r=()=>{let s="";if(this.outputShape.length===1)this.inputShape.length!==1&&(s+="outputCoords,");else for(let o=0;o<this.outputShape.length;o++)s+=`outputCoords.${la(o)},`;return s};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    `}

      ${Ee("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${n()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${r()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${r()} 0);
          let reduceLength = ${n()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${r()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gve(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o}=r;let i=nn(o,s.shape);const a=ur(i,s.shape.length);let l=s;const c=[];a!=null&&(l=Ci({inputs:{x:s},backend:n,attrs:{perm:a}}),c.push(l),i=cr(i.length,l.shape.length)),bs("argMax",[i[0]],l.shape.length);const d=new SF(l.shape,i[0],"max"),f=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],p=n.runWebGPUProgram(d,[l],"int32",f);return c.forEach(g=>n.disposeData(g.dataId)),p}const Hve={kernelName:uw,backendName:"webgpu",kernelFunc:Gve};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kve(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o}=r;let i=nn(o,s.shape);const a=ur(i,s.shape.length);let l=s;const c=[];a!=null&&(l=Ci({inputs:{x:s},backend:n,attrs:{perm:a}}),c.push(l),i=cr(i.length,l.shape.length)),bs("argMin",[i[0]],l.shape.length);const d=new SF(l.shape,i[0],"min"),f=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],p=n.runWebGPUProgram(d,[l],"int32",f);return c.forEach(g=>n.disposeData(g.dataId)),p}const Xve={kernelName:cw,backendName:"webgpu",kernelFunc:Kve};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qve=kt({opType:Ne.ASIN}),Yve={kernelName:dw,backendName:"webgpu",kernelFunc:qve};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qve=kt({opType:Ne.ASINH}),Zve={kernelName:hw,backendName:"webgpu",kernelFunc:Qve};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jve=kt({opType:Ne.ATAN}),ebe={kernelName:fw,backendName:"webgpu",kernelFunc:Jve};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tbe=zn({opType:Je.ATAN2}),nbe={kernelName:mw,backendName:"webgpu",kernelFunc:tbe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rbe=kt({opType:Ne.ATANH}),sbe={kernelName:pw,backendName:"webgpu",kernelFunc:rbe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class obe{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rf{constructor(e,n,r=!1,s=!1,o=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=n,this.computePositions=r,this.flattenPositions=s,this.includeBatchIndex=o,this.shaderKey=`pool2D_${n}_${r}_${s}_${o}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:e="resultValue = max(value, resultValue);";let n="resultValue";return this.poolType==="avg"&&(n="resultValue / max(count, 1.0)"),`
      ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${n});`}
        }
      }
    `}}class VC{constructor(e,n,r=!1,s=!1,o=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=n,this.computePositions=r,this.flattenPositions=s,this.includeBatchIndex=o,this.shaderKey=`pool3D_${n}_${r}_${s}_${o}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue += value; count += 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:e="resultValue = max(value, resultValue);";let n="resultValue";return this.poolType==="avg"&&(n="resultValue / max(count, 1.0)"),`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${n});`}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CF(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reductionIndices:o,keepDims:i}=r;return Xu(s,o,i,"max",n)}const ibe={kernelName:C2,backendName:"webgpu",kernelFunc:CF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $F(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{keepDims:o,axis:i}=r;return Xu(s,i,o,"mean",n)}const abe={kernelName:N2,backendName:"webgpu",kernelFunc:$F};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kF(t,e,n,r){if(e.filterWidth===1&&e.filterHeight===1&&Vt(e.inShape,e.outShape))return ys({inputs:{x:t},backend:r});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&e.batchSize===1&&e.padInfo.type==="VALID"){const i=t.shape.length,a=Be({inputs:{x:t},backend:r,attrs:{shape:[t.shape[i-3]*t.shape[i-2],t.shape[i-1]]}});let l;n==="avg"?l=$F({inputs:{x:a},backend:r,attrs:{axis:0,keepDims:!1}}):(z(n==="max",()=>`Invalid pool type ${n}`),l=CF({inputs:{x:a},backend:r,attrs:{reductionIndices:0,keepDims:!1}}));const c=Be({inputs:{x:l},backend:r,attrs:{shape:e.outShape}});return r.disposeData(a.dataId),r.disposeData(l.dataId),c}let s;const o=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return e.filterHeight===1&&e.filterWidth===1?s=new obe(e):(n==="avg"?s=new Rf(e,"avg"):(z(n==="max",()=>`Invalid pool type ${n}`),s=new Rf(e,"max")),o.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),r.runWebGPUProgram(s,[t],t.dtype,o)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lbe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r,d=fo(s.shape,o,i,1,a,l);return kF(s,d,"avg",n)}const ube={kernelName:gw,backendName:"webgpu",kernelFunc:lbe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cbe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:i,pad:a,dataFormat:l,dimRoundingMode:c}=r,d=[1,1,1],f=Sa(s.shape,o,i,d,a,c,l),p=new VC(f,"avg"),g=[{type:"int32",data:[f.strideDepth,f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.front,f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inDepth,f.inHeight,f.inWidth]},{type:"int32",data:[f.effectiveFilterDepth,f.effectiveFilterHeight,f.effectiveFilterWidth]}];return n.runWebGPUProgram(p,[s],s.dtype,g)}const dbe={kernelName:yw,backendName:"webgpu",kernelFunc:cbe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hbe{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class fbe{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pbe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,i=o,{filterSize:a,strides:l,pad:c,dimRoundingMode:d}=r,f=Sa(i.shape,a,l,1,c,d),p=new fbe(f),g=1/(f.filterDepth*f.filterHeight*f.filterWidth),y=[{type:"int32",data:[f.strideDepth,f.strideHeight,f.strideWidth]},{type:"int32",data:[f.effectiveFilterDepth-1-f.padInfo.front,f.effectiveFilterHeight-1-f.padInfo.top,f.effectiveFilterWidth-1-f.padInfo.left]},{type:"int32",data:[f.effectiveFilterDepth,f.effectiveFilterHeight,f.effectiveFilterWidth]},{type:"int32",data:[f.outDepth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"float32",data:[g]}];return n.runWebGPUProgram(p,[s],i.dtype,y)}const mbe={kernelName:ZP,backendName:"webgpu",kernelFunc:pbe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gbe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,i=o;vF([s,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,d=fo(i.shape,a,l,1,c),f=new hbe(d),p=1/(d.filterHeight*d.filterWidth),g=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"float32",data:[p]}];return n.runWebGPUProgram(f,[s],i.dtype,g)}const ybe={kernelName:QP,backendName:"webgpu",kernelFunc:gbe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xbe(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:o}=e,{transposeA:i,transposeB:a}=r;return Ty({a:s,b:o,transposeA:i,transposeB:a,backend:n})}const vbe={kernelName:xw,backendName:"webgpu",kernelFunc:xbe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bbe{constructor(e,n){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.rank=n.length,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${bn(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=bn(this.rank),n=wbe(this.rank);let r;return this.start.length===1?r=this.outputShape.map((o,i)=>"sourceLoc = uniforms.start + coords;"):r=this.outputShape.map((o,i)=>`sourceLoc.${Fv[i]} = uniforms.start.${la(i)} + coords.${Fv[i]};`),`
      ${Ee("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${r.join(`
`)}
          setOutputAtIndex(index, getSource(${n}));
        }
      }
    `}}const Fv=["x","y","z","w","u","v"];function wbe(t){if(t===1)return"sourceLoc";if(t<=6)return Fv.slice(0,t).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ld(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:o,size:i}=r,[a,l]=iC(s,o,i);if(nC(s,a,l),n.shouldExecuteOnCPU([s])||s.dtype==="string"){const f=n.tensorMap.get(s.dataId),p=xve(f.values,a,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,p)}if(pe(l)===0)return n.makeTensorInfo(l,s.dtype,[]);const c=new bbe(a,l),d=[{type:"int32",data:a}];return n.runWebGPUProgram(c,[s],s.dtype,d)}const Sbe={kernelName:lS,backendName:"webgpu",kernelFunc:Ld};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cbe=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:o,crops:i}=r;z(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const a=o.reduce(($,I)=>$*I),l=Yf(s.shape,o,a),c=Qf(l.length,o.length),d=Zf(s.shape,o,a),f=dC(i,o.length),p=hC(d,i,o.length),g=[],y=Be({inputs:{x:s},backend:n,attrs:{shape:l}}),x=Ci({inputs:{x:y},backend:n,attrs:{perm:c}}),w=Be({inputs:{x},backend:n,attrs:{shape:d}}),S=Ld({inputs:{x:w},backend:n,attrs:{begin:f,size:p}});return g.push(y),g.push(x),g.push(w),g.forEach($=>n.disposeData($.dataId)),S},$be={kernelName:vw,backendName:"webgpu",kernelFunc:Cbe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kbe=`
  fn bincount_write(index: i32, value: f32) {
    ${Nl("&result[index]","value","float32")}
  }
`,Tbe=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;class TF{constructor(e,n,r=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=r,r&&(this.atomic=!1),this.hasWeights=n,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?Tbe:kbe}
  ${Ee("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ibe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:o}=e,{size:i}=r,a=pe(s.shape),c=pe(o.shape)>0,d=[i],f=o.dtype,p=jr({backend:n,attrs:{shape:d,value:0,dtype:f}}),g=new TF([a],c),y=[{type:"int32",data:[i]}],x=c?[s,o]:[s];return n.runWebGPUProgram(g,x,f,y,p)}const Nbe={kernelName:bw,backendName:"webgpu",kernelFunc:Ibe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ebe{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${Ee("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rbe(t){const{inputs:e,backend:n}=t,{s0:r,s1:s}=e;if(n.shouldExecuteOnCPU([r,s])){const d=n.tensorMap.get(r.dataId),f=n.tensorMap.get(s.dataId),p=d.values,g=f.values,y=ct(Array.from(p),Array.from(g));return n.makeTensorInfo([y.length],"int32",Int32Array.from(y))}const o=pe(r.shape),i=pe(s.shape),a=Math.max(o,i),l=new Ebe(a),c=[{type:"int32",data:[o]},{type:"int32",data:[i]}];return n.runWebGPUProgram(l,[r,s],"int32",c)}const _be={kernelName:ww,backendName:"webgpu",kernelFunc:Rbe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IF=zn({opType:Je.NOT_EQUAL,dtype:"bool",cpuKernelImpl:hve}),Pbe={kernelName:F2,backendName:"webgpu",kernelFunc:IF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sp(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.tensorMap.get(r.dataId);return ys({inputs:{x:s.complexTensorInfos.real},backend:n})}const Abe={kernelName:K2,backendName:"webgpu",kernelFunc:sp};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dbe(t,e){const n=new Fd(t.shape,Ne.TO_INT),r=e.runWebGPUProgram(n,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lv(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dtype:o}=r;if(o==="complex64"){if(s.dtype==="complex64")return ys({inputs:{x:s},backend:n});const i=xa(s.shape),a=Lv({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),l=Ku({inputs:{real:a,imag:i},backend:n});return i.dispose(),n.disposeData(a.dataId),l}if(s.dtype==="complex64"){const i=sp({inputs:{input:s},backend:n}),a=Lv({inputs:{x:i},backend:n,attrs:{dtype:o}});return n.disposeData(i.dataId),a}if(!HP(s.dtype,o)){const i=ys({inputs:{x:s},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:o}}if(n.shouldExecuteOnCPU([s])){const i=n.tensorMap.get(s.dataId).values,[a,l,c]=Hxe(i,s.shape,s.dtype,o);return n.makeTensorInfo(a,l,c)}if(o==="int32")return Dbe(s,n);if(o==="bool"){const i=n.makeTensorInfo([],"bool",Si("bool",1)),l=IF({inputs:{a:s,b:i},backend:n});return n.disposeData(i.dataId),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}const Obe={kernelName:ny,backendName:"webgpu",kernelFunc:Lv};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fbe=kt({opType:Ne.CEIL,cpuKernelImpl:Kxe}),Lbe={kernelName:Sw,backendName:"webgpu",kernelFunc:Fbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zbe{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${Ee("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bbe{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${Ee("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mbe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{clipValueMin:o,clipValueMax:i}=r;let a;const l=[{type:"float32",data:[o]},{type:"float32",data:[i]}];return pe(s.shape)%4===0?a=new zbe(s.shape):a=new Bbe(s.shape),n.runWebGPUProgram(a,[s],s.dtype,l)}const Vbe={kernelName:Cw,backendName:"webgpu",kernelFunc:Mbe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wbe{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FN(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}function Ube(t){const{inputs:e,backend:n}=t,{x:r}=e,s=n.tensorMap.get(r.dataId),o=new Wbe(r.shape),i=[FN(r,s.complexTensorInfos.real),FN(r,s.complexTensorInfos.imag)];return n.runWebGPUProgram(o,i,i[0].dtype)}const jbe={kernelName:kw,backendName:"webgpu",kernelFunc:Ube};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gbe{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=ho(e,1),this.variableNames=e.map((n,r)=>`T${r}`),this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let n=0;n<this.offsetLength;n++)this.uniforms+=`offset${n} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let o=1;o<this.offsetLength;o++)e.push(`else if (yC < uniforms.offset${[o]}){ setOutputAtCoords(coords.x, coords.y, getT${o}(yR, yC - uniforms.offset${o-1})); }`);const r=this.offsetLength,s=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${r}(yR, yC - uniforms.offset${s})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${Ee("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iy(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.tensorMap.get(r.dataId);return ys({inputs:{x:s.complexTensorInfos.imag},backend:n})}const Hbe={kernelName:u2,backendName:"webgpu",kernelFunc:Iy};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zh(t,e,n){const r=t[0].dtype;if(r==="complex64"){const y=t.map(I=>sp({inputs:{input:I},backend:n})),x=t.map(I=>Iy({inputs:{input:I},backend:n})),w=zh(y,e,n),S=zh(x,e,n),$=Ku({inputs:{real:w,imag:S},backend:n});return y.forEach(I=>n.disposeData(I.dataId)),x.forEach(I=>n.disposeData(I.dataId)),n.disposeData(w.dataId),n.disposeData(S.dataId),$}let s=n.shouldExecuteOnCPU(t);if(r==="string"&&(s=!0),s){const y=t.map(_=>{const F=[-1,pe(_.shape.slice(e))];return Be({inputs:{x:_},backend:n,attrs:{shape:F}})}),x=y.map(_=>({vals:n.readSync(_.dataId),shape:_.shape})),w=ho(y.map(_=>_.shape),1),S=y[0].shape[0]===1,$=Xxe(x,w,r,S),I=ho(t.map(_=>_.shape),e),R=n.makeTensorInfo(I,r,$);return y.forEach(_=>n.disposeData(_.dataId)),R}const o=n.device.limits.maxStorageBuffersPerShaderStage-1;if(t.length>o){const y=[];for(let w=0;w<t.length;w+=o){const S=t.slice(w,w+o);y.push(zh(S,e,n))}const x=zh(y,e,n);for(const w of y)n.disposeData(w.dataId);return x}const{tensors2D:i,outShape:a}=Kbe(t,e,n),l=i.map(y=>y.shape),c=new Gbe(l),d=[],f=new Array(l.length-1);if(f.length>0){f[0]=l[0][1],d.push({type:"int32",data:[f[0]]});for(let y=1;y<f.length;y++)f[y]=f[y-1]+l[y][1],d.push({type:"int32",data:[f[y]]})}const p=n.runWebGPUProgram(c,i,i[0].dtype,d);i.forEach(y=>n.disposeData(y.dataId));const g=Be({inputs:{x:p},backend:n,attrs:{shape:a}});return n.disposeData(p.dataId),g}function Kbe(t,e,n){const r=ho(t.map(o=>o.shape),e);return{tensors2D:t.map(o=>Be({inputs:{x:o},backend:n,attrs:{shape:[pe(o.shape.slice(0,e)),pe(o.shape.slice(e))]}})),outShape:r}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NF(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r,o=nn(s,e[0].shape)[0],i=e.map(c=>c.shape);lC(i,o);const a=ho(e.map(c=>c.shape),o);if(pe(a)===0)return n.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(c=>pe(c.shape)>0);return l.length===1?ys({inputs:{x:l[0]},backend:n}):zh(l,o,n)}const Xbe={kernelName:Tw,backendName:"webgpu",kernelFunc:NF};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qbe(t,e,n,r,s=!1,o=null,i=!1,a=4,l=4,c=4){const d=M=>{switch(M){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${M} is not supported.`)}},f=M=>{switch(M){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${M} is not supported.`)}},p=t?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,g=t?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,y=t?"uniforms.xShape[1]":"uniforms.xShape[2]",x=t?"uniforms.xShape[2]":"uniforms.xShape[3]",w=t?"row":"col",S=t?"col":"row",$=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${t?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${w} / outWidth;
      let outCol = ${w} % outWidth;

      let WRow = ${S} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${S} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${S} % inChannels;
      var resData = ${ut(a)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${y} && xCol >= 0 && xCol < ${x}) {
        ${p}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${d(a)}
      }
      return resData;`,I=t?e&&r?`
      ${$}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${$}
      }
      return ${ut(a)}(0.0);`:r&&n?`
      ${$}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${$}
      }
      return ${ut(a)}(0.0);`,R=`${f(l)}`,_=ut(c),O=ut(t?a:l),F=ut(t?l:a);return`
      ${Ta(o,i,c===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${O} {
        ${t?I:R}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${F} {
        ${t?R:I}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${_}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${t?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${g}
        ${Hu(s,o)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}class Ybe{constructor(e,n,r,s,o=!1,i=null,a=!1,l=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=gF(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=yF(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),o&&(this.variableNames.push("bias"),this.variableComponents.push(4)),a&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],o&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=l,this.addBias=o,this.activation=i,this.hasPreluActivationWeights=a,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=n%this.tileAOuter===0,this.fitBOuter=r%this.tileBOuter===0,this.fitInner=s%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?$y(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):ky(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),n=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${qbe(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,n[0],n[1],n[2])}
    ${e}
  `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qbe{constructor(e,n=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=n,this.activation=r,this.hasPreluActivationWeights=s,n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${Ta(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${Hu(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${Ee("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zbe{constructor(e,n){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=n,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,n=this.isChannelsLast?2:3,r=this.isChannelsLast?"coords[1]":"coords[2]",s=this.isChannelsLast?"coords[2]":"coords[1]",o=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${Ee("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${r};
        let col = ${s};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${n}] && xCol >= 0) {
            value = ${o};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zg(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&n===1&&t[0]>1?[t[0],1]:null}function Jbe({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const l=n.dataFormat==="channelsLast",c=!l,d=!1,f=l&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&n.padInfo.type==="VALID",p=[];let g,y;if(f){const S=n.inHeight*n.inWidth*n.inChannels;g=Be({inputs:{x:t},backend:r,attrs:{shape:[1,n.batchSize,S]}}),y=Be({inputs:{x:e},backend:r,attrs:{shape:[1,S,n.outChannels]}})}else g=Be({inputs:{x:t},backend:r,attrs:{shape:l?[n.batchSize,n.inHeight*n.inWidth,n.inChannels]:[n.batchSize,n.inChannels,n.inHeight*n.inWidth]}}),y=Be({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});if(p.push(g),p.push(y),o!=null){const S=zg(o.shape,l);S!=null&&(o=Be({inputs:{x:o},backend:r,attrs:{shape:S}}),p.push(o))}if(s!=null){const S=zg(s.shape,l);S!=null&&(s=Be({inputs:{x:s},backend:r,attrs:{shape:S}}),p.push(s))}const x=Ty({a:l?g:y,b:l?y:g,transposeA:c,transposeB:d,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),w=Be({inputs:{x},backend:r,attrs:{shape:n.outShape}});p.push(x);for(const S of p)r.disposeData(S.dataId);return w}function ewe({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:d,strideWidth:f,strideHeight:p,padInfo:g,outWidth:y,outHeight:x,dilationWidth:w,dilationHeight:S,dataFormat:$}=n,I=$==="channelsLast",R=l*c*d,_=x*y,O=I?[n.batchSize,_,R]:[n.batchSize,R,_],F=new Zbe(O,I),B=[{type:"int32",data:[g.top,g.left]},{type:"int32",data:[p,f]},{type:"int32",data:[S,w]},{type:"int32",data:[y]},{type:"int32",data:[d*l]},{type:"int32",data:[d]}],M=r.runWebGPUProgram(F,[t],t.dtype,B),V=[];V.push(M);const P=Be({inputs:{x:e},backend:r,attrs:{shape:[1,R,-1]}});if(V.push(P),o!=null){const ve=zg(o.shape,I);ve!=null&&(o=Be({inputs:{x:o},backend:r,attrs:{shape:ve}}),V.push(o))}if(s!=null){const ve=zg(s.shape,I);ve!=null&&(s=Be({inputs:{x:s},backend:r,attrs:{shape:ve}}),V.push(s))}const me=Ty({a:I?M:P,b:I?P:M,transposeA:!I,transposeB:!1,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),ge=Be({inputs:{x:me},backend:r,attrs:{shape:n.outShape}});V.push(me);for(const ve of V)r.disposeData(ve.dataId);return ge}function EF({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const l=s!=null,c=o!=null,d=n.dataFormat==="channelsLast",f=d&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&n.padInfo.type==="VALID",p=se().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!p&&(f||n.filterHeight===1&&n.filterWidth===1&&n.dilationHeight===1&&n.dilationWidth===1&&n.strideHeight===1&&n.strideWidth===1&&(n.padInfo.type==="SAME"||n.padInfo.type==="VALID")))return Jbe({x:t,filter:e,convInfo:n,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i});const g=se().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),y=g>-1?g:r.thresholdToIncreaseWorkgroups,x=n.batchSize*Math.ceil(n.outHeight*n.outWidth/32)*Math.ceil(n.outChannels/32);if(se().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||x<=y)return ewe({x:t,filter:e,convInfo:n,backend:r,bias:s,preluActivationWeights:o,leakyreluAlpha:i,activation:a});let w;const S=[n.padInfo.top,n.padInfo.left],$=[{type:"int32",data:[n.filterHeight,n.filterWidth]},{type:"int32",data:[...S]},{type:"int32",data:[n.strideHeight,n.strideWidth]},{type:"int32",data:[n.dilationHeight,n.dilationWidth]}];if(p)w=new Qbe(n,l,a,c);else{const O=d?n.outHeight*n.outWidth:n.outChannels,F=d?n.outChannels:n.outHeight*n.outWidth,B=n.filterHeight*n.filterWidth*n.inChannels;$.push({type:"int32",data:[O]},{type:"int32",data:[F]},{type:"int32",data:[B]});const M=r.adapterInfo.isIntel();w=new Ybe(n,O,F,B,l,a,c,M)}const I=[],R=[t,e];l&&(!d&&s.shape.length===1&&(s=Be({inputs:{x:s},backend:r,attrs:{shape:[s.shape[0],1,1]}}),I.push(s)),R.push(s)),c&&(!d&&o.shape.length===1&&(o=Be({inputs:{x:o},backend:r,attrs:{shape:[o.shape[0],1,1]}}),I.push(o)),R.push(o)),a==="leakyrelu"&&($.push({type:"float32",data:[i]}),w.uniforms+=" alpha : f32,");const _=r.runWebGPUProgram(w,R,t.dtype,$);for(const O of I)r.disposeData(O.dataId);return _}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function twe(t){const{inputs:e,attrs:n,backend:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dataFormat:l,dilations:c,dimRoundingMode:d}=n,f=Mo(l),p=kn(s.shape,o.shape,i,c,a,d,!1,f);return EF({x:s,filter:o,convInfo:p,backend:r})}const nwe={kernelName:Iw,backendName:"webgpu",kernelFunc:twe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rwe{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&e.outChannels%4===0&&e.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,n=this.isChannelsLast?2:3,r=this.isChannelsLast?3:1,s=`
    ${Ee()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${s}
    `:`
    ${Ee("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${r}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${n}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class swe{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${Ee("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class owe{constructor(e){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${Ee("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class iwe{constructor(e){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${Ee("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function awe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:i,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:d}=r,f=Mo(l),p=kn(s.shape,d,i,1,a,c,!1,f),g=new swe(p),y=[{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.batchSize]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"int32",data:[p.inHeight]},{type:"int32",data:[p.inWidth]}];return n.runWebGPUProgram(g,[s,o],s.dtype,y)}const lwe={kernelName:Nw,backendName:"webgpu",kernelFunc:awe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uwe(t=4){const e=o=>{switch(o){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${o} is not supported.`)}},r=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${ut(t)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${ut(t)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${t}];`}
      }
      return ${ut(t)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${ut(t)} {
    ${r}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${ut(t)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(t)}
    }
    return ${ut(t)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${ut(t)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${t}] = value;
    }
  }`}class cwe{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,z(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=gF(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=yF(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?$y(this.elementsPerThread,this.workgroupSize):ky(this.elementsPerThread,this.workgroupSize);return`
    ${uwe(this.isVec4?4:1)}
    ${e}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dwe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{inputShape:i,strides:a,pad:l,dataFormat:c,dimRoundingMode:d}=r,f=Mo(c),p=kn(i,o.shape,a,1,l,d,!1,f),g=[{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.filterHeight-1-p.padInfo.top,p.filterWidth-1-p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.batchSize,p.outHeight,p.outWidth,p.outChannels]}];let y;if(se().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||p.dataFormat!=="channelsLast")y=new rwe(p);else{y=new cwe(p);const x=p.inHeight*p.inWidth,w=p.inChannels,S=p.filterHeight*p.filterWidth*p.outChannels;g.push({type:"uint32",data:[x]},{type:"uint32",data:[w]},{type:"uint32",data:[S]})}return n.runWebGPUProgram(y,[s,o],"float32",g)}const hwe={kernelName:Ew,backendName:"webgpu",kernelFunc:dwe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fwe{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pwe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dilations:l}=r,c=Tl(s.shape,o.shape,i,l,a),d=[c.padInfo.front,c.padInfo.top,c.padInfo.left],f=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[...d]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationDepth,c.dilationHeight,c.dilationWidth]}],p=new fwe(c),g=Gr(s.dtype,o.dtype);return n.runWebGPUProgram(p,[s,o],g,f)}const mwe={kernelName:Rw,backendName:"webgpu",kernelFunc:pwe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gwe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:i,pad:a,filterShape:l}=r,c=Tl(s.shape,l,i,1,a),d=new owe(c),f=[{type:"int32",data:[c.padInfo.front,c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.batchSize]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.inDepth]},{type:"int32",data:[c.inHeight]},{type:"int32",data:[c.inWidth]}];return n.runWebGPUProgram(d,[s,o],o.dtype,f)}const ywe={kernelName:eA,backendName:"webgpu",kernelFunc:gwe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xwe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{strides:i,pad:a,inputShape:l}=r,c=Tl(l,o.shape,i,1,a),d=new iwe(c),f=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[c.filterDepth-1-c.padInfo.front,c.filterHeight-1-c.padInfo.top,c.filterWidth-1-c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.outChannels]}];return n.runWebGPUProgram(d,[s,o],s.dtype,f)}const vwe={kernelName:_w,backendName:"webgpu",kernelFunc:xwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bwe=kt({opType:Ne.COS}),wwe={kernelName:Pw,backendName:"webgpu",kernelFunc:bwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Swe=kt({opType:Ne.COSH}),Cwe={kernelName:Aw,backendName:"webgpu",kernelFunc:Swe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $we{constructor(e,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[o]=n;this.outputShape=[o,r[0],r[1],e],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=s==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,n]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[r,s,o]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[i,a,l]=this.cropWidthBiggerThan1?[`(${n} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${n} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${n}`];return`
    ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${r});
        let width_ratio = f32(${i});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${s};
        let width_scale = ${a};
        let in_y = ${o};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${l};
        if( in_x < 0.0 || in_x > ${n} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kwe=t=>{const{inputs:e,backend:n,attrs:r}=t,{image:s,boxes:o,boxInd:i}=e,{cropSize:a,method:l,extrapolationValue:c}=r,d=new $we(s.shape[3],o.shape,a,l),f=[{type:"float32",data:[c]}];return n.runWebGPUProgram(d,[s,o,i],"float32",f)},Twe={kernelName:Fw,backendName:"webgpu",kernelFunc:kwe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var _f;(function(t){t.Prod="*",t.Sum="+"})(_f||(_f={}));class LN{constructor(e,n,r,s){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=n,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=r,this.reverse=s,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,n=this.op===_f.Prod?"1.0":"0.0",r=this.exclusive?n:`getX(${zN(e,"coords",this.op)})`,s=this.outputShape[this.outputShape.length-1];let o="",i="";return this.exclusive?(o=this.reverse?`end != ${s-1}`:"end != 0",i=this.reverse?"end + 1":"end - 1"):(o=this.reverse?`end + pow2 < ${s}`:"end >= pow2",i=this.reverse?"end + pow2":"end - pow2"),`
      ${Ee("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${BN(e,"coords",this.op)};
         var val = ${r};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${o}) {
           let idx = ${i};
           ${BN(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${zN(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}}function zN(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.x, ${e}.y`;if(t===3)return`${e}.x, ${e}.y, ${e}.z`;if(t===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function BN(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.y`;if(t===3)return`${e}.z`;if(t===4)return`${e}.w`;throw Error(`Cumulative ${n} for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RF(t,e,n,r,s,o){const i=e.shape.length,a=ur([r],i);let l=e;a!=null&&(l=Ci({inputs:{x:e},backend:n,attrs:{perm:a}}));const c=cr(1,i)[0];if(c!==i-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const d=l.shape[c];let f=ys({inputs:{x:l},backend:n});for(let p=0;p<=Math.ceil(Math.log2(d))-1;p++){const g=new LN(t,l.shape,!1,o),y=f,x=[{type:"float32",data:[p]}];f=n.runWebGPUProgram(g,[f],f.dtype,x),n.disposeData(y.dataId)}if(s){const p=new LN(t,l.shape,s,o),g=f,y=[{type:"float32",data:[0]}];f=n.runWebGPUProgram(p,[f],f.dtype,y),n.disposeData(g.dataId)}if(a!=null){const p=qf(a),g=Ci({inputs:{x:f},backend:n,attrs:{perm:p}});return n.disposeData(f.dataId),n.disposeData(l.dataId),g}return f}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iwe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,exclusive:i,reverse:a}=r;return RF(_f.Prod,s,n,o,i,a)}const Nwe={kernelName:Dw,backendName:"webgpu",kernelFunc:Iwe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ewe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,exclusive:i,reverse:a}=r;return RF(_f.Sum,s,n,o,i,a)}const Rwe={kernelName:Ow,backendName:"webgpu",kernelFunc:Ewe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _we(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:o}=e,{size:i,binaryOutput:a}=r,l=s.shape.length===1,d=pe(o.shape)>0,f=o.dtype,p=l?[s.shape[0]]:[s.shape[0],s.shape[1]],g=l?[i]:[s.shape[0],i],y=jr({backend:n,attrs:{shape:g,value:0,dtype:f}}),x=new TF(p,d,a),w=[{type:"int32",data:[i]}],S=d?[s,o]:[s];return n.runWebGPUProgram(x,S,f,w,y)}const Pwe={kernelName:Lw,backendName:"webgpu",kernelFunc:_we};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Awe{constructor(e,n){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${n}`,this.dataFormat=n}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dwe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockSize:o,dataFormat:i}=r,a=s.shape[0],l=i==="NHWC"?s.shape[1]:s.shape[2],c=i==="NHWC"?s.shape[2]:s.shape[3],d=i==="NHWC"?s.shape[3]:s.shape[1],f=l*o,p=c*o,g=d/(o*o),y=i==="NHWC"?[a,f,p,g]:[a,g,f,p],x=[{type:"int32",data:[o]}],w=new Awe(y,i);return n.runWebGPUProgram(w,[s],s.dtype,x)}const Owe={kernelName:zw,backendName:"webgpu",kernelFunc:Dwe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fwe{constructor(e,n,r,s=!1,o=null,i=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.addBias=s,this.activation=o,this.hasPreluActivation=i,this.filterHeight=n,this.filterWidth=r,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,n=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],r=this.workgroupSize[1]+this.filterHeight-1,s=this.workgroupSize[0]+this.filterWidth-1;return`
      ${Ta(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${s}>, ${r}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${Ee()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${s}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e<n?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${n})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${Hu(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _F{constructor(e,n=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const o=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=De(o),this.dispatch=Re(this.dispatchLayout,o,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),z(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=n,this.activation=r,this.hasPreluActivation=s,this.shaderKey=`depthwiseVec4_${r}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,n=this.convInfo.strideHeight,r=this.convInfo.strideWidth;return`
      ${Ta(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${Ee("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${n}, ${r}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${r} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${Hu(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PF{constructor(e,n=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=n,this.activation=r,this.hasPreluActivation=s,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${Ta(this.activation,this.hasPreluActivation,!1,4)}

      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${Hu(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lwe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dataFormat:l,dilations:c,dimRoundingMode:d}=r,f=Mo(l);let p=c;p==null&&(p=[1,1]);const g=kn(s.shape,o.shape,i,p,a,d,!0,f),y=[{type:"int32",data:[g.padInfo.top,g.padInfo.left]},{type:"int32",data:[g.inHeight,g.inWidth]}],x=g.dataFormat==="channelsLast";let w;return!x&&g.inHeight>16&&g.inWidth>16&&g.strideHeight===1&&g.strideWidth===1&&g.dilationWidth===1&&g.dilationHeight===1&&g.inChannels===g.outChannels?w=new Fwe(g.outShape,g.filterHeight,g.filterWidth):x&&g.outHeight>4&&g.outWidth>4&&g.strideWidth<=2&&g.inChannels===g.outChannels&&g.dilationHeight===1&&g.dilationWidth===1&&g.inChannels%4===0?(w=new _F(g),y.push({type:"int32",data:[w.virtualWidth]})):(w=new PF(g),y.push({type:"int32",data:[g.filterHeight]},{type:"int32",data:[g.filterWidth]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]})),n.runWebGPUProgram(w,[s,o],s.dtype,y)}const zwe={kernelName:Bw,backendName:"webgpu",kernelFunc:Lwe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bwe{constructor(e){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class Mwe{constructor(e){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vwe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:i,dilations:a,pad:l,dimRoundingMode:c,filterShape:d}=r,f=kn(s.shape,d,i,a,l,c,!0),p=new Bwe(f),g=[{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"int32",data:[f.inHeight]},{type:"int32",data:[f.inWidth]},{type:"int32",data:[f.batchSize]},{type:"int32",data:[f.outChannels/f.inChannels]}];return n.runWebGPUProgram(p,[s,o],"float32",g)}const Wwe={kernelName:Mw,backendName:"webgpu",kernelFunc:Vwe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uwe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{strides:i,dilations:a,pad:l,dimRoundingMode:c,inputShape:d}=r,f=kn(d,o.shape,i,a,l,c,!0),p=new Mwe(f),g=[{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.filterHeight-1-f.padInfo.top,f.filterWidth-1-f.padInfo.left]},{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"int32",data:[f.outChannels/f.inChannels]}];return n.runWebGPUProgram(p,[s,o],s.dtype,g)}const jwe={kernelName:Vw,backendName:"webgpu",kernelFunc:Uwe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gwe{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hwe(t){const{inputs:e,backend:n}=t,{x:r}=e,s=[...r.shape,...r.shape],o=pe(r.shape),i=Be({inputs:{x:r},backend:n,attrs:{shape:[o]}}),a=new Gwe(o),l=n.runWebGPUProgram(a,[i],i.dtype),c=Be({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeData(i.dataId),n.disposeData(l.dataId),c}const Kwe={kernelName:Ww,backendName:"webgpu",kernelFunc:Hwe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xwe{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${Ee("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qwe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dilations:l}=r,c=Kf(s.shape,o.shape,i,a,"NHWC",l),d=[c.padInfo.top,c.padInfo.left],f=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[...d]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]}],p=new Xwe(c);return n.runWebGPUProgram(p,[s,o],s.dtype,f)}const Ywe={kernelName:Uw,backendName:"webgpu",kernelFunc:qwe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qwe{constructor(e,n){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=De(e.outShape),this.dispatch=Re(this.dispatchLayout,e.outShape,this.workgroupSize),n!=="float32"&&n!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${n} type.`);this.type=n,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${Ee("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${Nl("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}class Zwe{constructor(e,n,r){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=De(e.outShape),this.dispatch=Re(this.dispatchLayout,e.outShape,this.workgroupSize),r!=="float32"&&r!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${r} type.`);this.type=r,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${Ee("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${Nl("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jwe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,dy:i}=e,{strides:a,pad:l,dilations:c}=r,d=Kf(s.shape,o.shape,a,l,"NHWC",c),f=o.dtype,p=new Zwe(d,o.shape,f),g=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[pe(d.outShape)]}],y=jr({backend:n,attrs:{shape:o.shape,value:0,dtype:f}});return n.runWebGPUProgram(p,[s,o,i],f,g,y)}const e2e={kernelName:mX,backendName:"webgpu",kernelFunc:Jwe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t2e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,dy:i}=e,{strides:a,pad:l,dilations:c}=r,d=Kf(s.shape,o.shape,a,l,"NHWC",c),f=s.dtype,p=new Qwe(d,f),g=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[pe(d.outShape)]}],y=jr({backend:n,attrs:{shape:d.inShape,value:0,dtype:f}});return n.runWebGPUProgram(p,[s,o,i],f,g,y)}const n2e={kernelName:pX,backendName:"webgpu",kernelFunc:t2e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r2e{constructor(e,n,r){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=pd.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=n,this.textureFormat=r,this.shaderKey=`draw_${n}_${r}`}getUserCode(){let e;const n=this.type==="float32"?"value":"value / 255.0";return e=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${n};
        rgba[1] = ${n};
        rgba[2] = ${n};
      } else {
        rgba[d] = ${n};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${Ee("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s2e(t){const{inputs:e,backend:n,attrs:r}=t,{image:s}=e,{canvas:o,options:i}=r,[a,l]=s.shape.slice(0,2),{imageOptions:c}=i||{},d=(c==null?void 0:c.alpha)||1,f=n.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",p=[a,l],g=new r2e(p,s.dtype,f);o.width=l,o.height=a;const y="webgpu";let x=o.getContext(y),w;x||(w=new OffscreenCanvas(l,a),x=w.getContext(y));const S=s.shape.length===3?s.shape[2]:1;x.configure({device:n.device,format:f,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const $="int32",I=n.makeTensorInfo(p,$),R=n.tensorMap.get(I.dataId);R.resource=x.getCurrentTexture(),R.external=!0;const _=[{type:"uint32",data:[S]},{type:"float32",data:[d]}];if(n.runWebGPUProgram(g,[s],$,_,I),w){const O=o.getContext("2d");if(!O)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");O.drawImage(w,0,0)}return n.disposeData(I.dataId),s}const o2e={kernelName:tA,backendName:"webgpu",kernelFunc:s2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AF=zn({opType:Je.MUL,cpuKernelImpl:cve,supportsComplex:!0}),i2e={kernelName:D2,backendName:"webgpu",kernelFunc:AF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DF(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r;return Xu(s,o,i,"sum",n)}const a2e={kernelName:mS,backendName:"webgpu",kernelFunc:DF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l2e(t){const{inputs:e,backend:n,attrs:r}=t,{equation:s}=r,o=e,{allDims:i,summedDims:a,idDims:l}=wC(s,o.length);CC(i.length,l,o);const{path:c,steps:d}=$C(a,l),f=d.length;let p=null,g=i.length;const y=[];for(let x=0;x<f;++x){for(const w of d[x]){const{permutationIndices:S,expandDims:$}=SC(g,l[w]);let I;kC(S)?I=o[w]:(I=Ci({inputs:{x:o[w]},backend:n,attrs:{perm:S}}),y.push(I));const R=I.shape.slice();for(let _=0;_<$.length;++_)R.splice($[_],0,1);Vt(I.shape,R)||(I=Be({inputs:{x:I},backend:n,attrs:{shape:R}}),y.push(I)),p===null?p=I:(p=AF({inputs:{a:I,b:p},backend:n}),y.push(p))}x<f-1&&(c[x]>=0&&(p=DF({inputs:{x:p},backend:n,attrs:{axis:c[x]-(i.length-g),keepDims:!1}}),y.push(p)),g--)}for(const x of y)x!==p&&n.disposeData(x.dataId);return p}const u2e={kernelName:Gw,backendName:"webgpu",kernelFunc:l2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c2e=kt({opType:Ne.ELU}),d2e={kernelName:Hw,backendName:"webgpu",kernelFunc:c2e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h2e=t=>{const{inputs:e,backend:n}=t,{dy:r,y:s}=e,o=new Lg(Je.ELU_DER,r.shape,s.shape);return n.runWebGPUProgram(o,[r,s],r.dtype)},f2e={kernelName:nA,backendName:"webgpu",kernelFunc:h2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p2e=zn({opType:Je.EQUAL,dtype:"bool",cpuKernelImpl:qxe}),m2e={kernelName:Xw,backendName:"webgpu",kernelFunc:p2e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g2e=kt({opType:Ne.ERF}),y2e={kernelName:Kw,backendName:"webgpu",kernelFunc:g2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x2e=kt({opType:Ne.EXP,cpuKernelImpl:Yxe,dtype:"float32"}),v2e={kernelName:qw,backendName:"webgpu",kernelFunc:x2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zv(t){const{inputs:e,attrs:n,backend:r}=t,{dim:s}=n,{input:o}=e,i=o.shape.length,a=o.shape.slice();let l=s;return s<0&&(z(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),a.splice(l,0,1),Be({inputs:{x:o},backend:r,attrs:{shape:a}})}const b2e={kernelName:Yw,backendName:"webgpu",kernelFunc:zv};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w2e=kt({opType:Ne.EXPM1,cpuKernelImpl:Qxe}),S2e={kernelName:Qw,backendName:"webgpu",kernelFunc:w2e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MN{constructor(e,n){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OF(t,e,n){const r=n.tensorMap.get(t.dataId),s=pe(t.shape),o=t.shape[t.shape.length-1],i=s/o,a=[],l=Be({inputs:{x:t},backend:n,attrs:{shape:[i,o]}});a.push(l);const c=l.shape,d=new MN("real",c),f=new MN("imag",c),p=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:c},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:c}],g=e?2*Math.PI:-2*Math.PI,y=e?c[1]:1,x=[{type:"float32",data:[g]},{type:"float32",data:[y]}],w=n.runWebGPUProgram(d,p,"float32",x);a.push(w);const S=n.runWebGPUProgram(f,p,"float32",x);a.push(S);const $=Ku({inputs:{real:w,imag:S},backend:n});a.push($);const I=Be({inputs:{x:$},backend:n,attrs:{shape:t.shape}});return a.forEach(R=>n.disposeData(R.dataId)),I}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C2e(t){const{inputs:e,backend:n}=t,{input:r}=e;return OF(r,!1,n)}const $2e={kernelName:Zw,backendName:"webgpu",kernelFunc:C2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class k2e{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T2e={kernelName:e2,backendName:"webgpu",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,r=e,s=new k2e(n.shape);return r.runWebGPUProgram(s,[n],n.dtype)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I2e=kt({opType:Ne.FLOOR,cpuKernelImpl:Zxe}),N2e={kernelName:t2,backendName:"webgpu",kernelFunc:I2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E2e=zn({opType:Je.FLOOR_DIV,cpuKernelImpl:Jxe,dtype:"int32"}),R2e={kernelName:n2,backendName:"webgpu",kernelFunc:E2e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _2e{constructor(e,n,r=!1){this.pixelsOpType=pd.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[n,1,1]),this.importVideo=r,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${Ee("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P2e={kernelName:vg,backendName:"webgpu",kernelFunc:A2e};let Tc,sx=se().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function A2e(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:s}=e;const{numChannels:o}=r;if(s==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,l=typeof HTMLCanvasElement<"u"&&s instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&s instanceof OffscreenCanvas,c=typeof ImageBitmap<"u"&&s instanceof ImageBitmap,[d,f]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],p=[f,d,o],g=se().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&i,y=i||a;if(c||l||y){let $;if(g)$=n.device.importExternalTexture({source:s});else{if(y){const ie=se().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Tc==null||ie!==sx)&&(sx=ie,Tc=document.createElement("canvas").getContext("2d",{willReadFrequently:sx})),Tc.canvas.width=d,Tc.canvas.height=f,Tc.drawImage(s,0,0,d,f),s=Tc.canvas}const V=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,re=n.textureManager.acquireTexture(p[1],p[0],"rgba8unorm",V);n.queue.copyExternalImageToTexture({source:s},{texture:re},[p[1],p[0]]),$=re}const I=pe(p),R=gn(p),_=new _2e(p,o,g),O=[{type:"uint32",data:[I]},{type:"uint32",data:[o]},{type:"uint32",data:[...R]}],F=n.makeTensorInfo([f,d],"int32"),B=n.tensorMap.get(F.dataId);B.resource=$;const M=n.runWebGPUProgram(_,[F],"int32",O);return n.disposeData(F.dataId),M}const x=s.data;let w=x;if(o!=null&&o!==4){w=new Uint8Array(s.width*s.height*o);const $=x.length;let I=0;for(let R=0;R<$;R++)R%4<o&&(w[I++]=x[R])}const S=n.makeTensorInfo(p,"int32",new Int32Array(w));return n.uploadToGPU(S.dataId),S}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class D2e{constructor(e,n,r,s,o){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],ct(e,n),ct(e,r),this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),s!=null&&(ct(e,s),this.variableNames.push("offset")),o!=null&&(ct(e,o),this.variableNames.push("scale")),this.offsetShape=s,this.scaleShape=o,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetByOutputIndex(index)");let n="1.0";return this.scaleShape!=null&&(n="getScaleByOutputIndex(index)"),`
      ${Ee("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${n};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O2e={kernelName:r2,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r,scale:s,offset:o,mean:i,variance:a}=t,{varianceEpsilon:l}=e,c=n,d=[r,i,a];let f=null;o!=null&&(f=o.shape,d.push(o));let p=null;s!=null&&(p=s.shape,d.push(s));const g=new D2e(r.shape,i.shape,a.shape,f,p),y=[{type:"float32",data:[l]}];return c.runWebGPUProgram(g,d,r.dtype,y)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F2e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:d,dilations:f,dimRoundingMode:p,activation:g,leakyreluAlpha:y}=r,x=Mo(d),w=kn(s.shape,o.shape,l,f,c,p,!1,x);return EF({x:s,filter:o,convInfo:w,backend:n,bias:i,preluActivationWeights:a,leakyreluAlpha:y,activation:g})}const L2e={kernelName:wg,backendName:"webgpu",kernelFunc:F2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z2e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=e,{strides:l,pad:c,dilations:d,dimRoundingMode:f,activation:p,leakyreluAlpha:g}=r;let y=d;y==null&&(y=[1,1]),z(Er(l,y),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${y}'`);const x=kn(s.shape,o.shape,l,y,c,f,!0),w=[s,o],S=i!=null,$=a!=null;S&&w.push(i),$&&w.push(a);const I=[{type:"int32",data:[x.padInfo.top,x.padInfo.left]},{type:"int32",data:[x.inHeight,x.inWidth]}];let R;return x.outHeight>4&&x.outWidth>4&&x.strideWidth<=2&&x.inChannels===x.outChannels&&x.dilationHeight===1&&x.dilationWidth===1&&x.inChannels%4===0?(R=new _F(x,S,p,$),I.push({type:"int32",data:[R.virtualWidth]})):(R=new PF(x,S,p,$),I.push({type:"int32",data:[x.filterHeight]},{type:"int32",data:[x.filterWidth]},{type:"int32",data:[x.strideHeight,x.strideWidth]},{type:"int32",data:[x.dilationHeight,x.dilationWidth]})),p==="leakyrelu"&&(I.push({type:"float32",data:[g]}),R.uniforms+=" alpha : f32,"),n.runWebGPUProgram(R,w,"float32",I)}const B2e={kernelName:Sg,backendName:"webgpu",kernelFunc:z2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class M2e{constructor(e,n){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${bn(e)},`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V2e(t){const{inputs:e,backend:n}=t,{params:r,indices:s}=e,o=s.shape,i=o[o.length-1],a=pe(r.shape),[l,c,d,f]=tC(r,s),p=Be({inputs:{x:s},backend:n,attrs:{shape:[c,i]}}),g=Be({inputs:{x:r},backend:n,attrs:{shape:[pe(r.shape)/d,d]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const $=n.readSync(s.dataId),I=n.bufferSync(r),R=eve($,I,r.dtype,c,i,d,f,r.shape,a);return n.makeTensorInfo(l,r.dtype,R.values)}const y=new M2e(i,[c,d]),x=[{type:"int32",data:[i]},{type:"int32",data:f}],w=n.runWebGPUProgram(y,[g,p],g.dtype,x),S=Be({inputs:{x:w},backend:n,attrs:{shape:l}});return n.disposeData(p.dataId),n.disposeData(g.dataId),n.disposeData(w.dataId),S}const W2e={kernelName:o2,backendName:"webgpu",kernelFunc:V2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class U2e{constructor(e,n){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=n,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=j2e(this.aShape);return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `}}function j2e(t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<t.length;r++)r===2?n.push("indexZ"):n.push(`${e[r]}`);return n.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FF(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,indices:o}=e,{axis:i,batchDims:a}=r,l=nn(i,s.shape)[0],c=NC(s,o,l,a),d=pe(o.shape),f=[],p=Be({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),g=Be({inputs:{x:o},backend:n,attrs:{shape:[c.batchSize,d/c.batchSize]}});f.push(p),f.push(g);const y=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([s,o])){const I=n.tensorMap.get(g.dataId).values,R=Wt(g.shape,g.dtype,I),O=n.tensorMap.get(p.dataId).values,F=Wt(p.shape,p.dtype,O),B=tve(F,R,y);return f.forEach(M=>n.disposeData(M.dataId)),n.makeTensorInfo(c.outputShape,B.dtype,B.values)}const x=new U2e(p.shape,y),w=n.runWebGPUProgram(x,[p,g],p.dtype);f.push(w);const S=Be({inputs:{x:w},backend:n,attrs:{shape:c.outputShape}});return f.forEach($=>n.disposeData($.dataId)),S}const G2e={kernelName:s2,backendName:"webgpu",kernelFunc:FF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H2e=zn({opType:Je.GREATER,cpuKernelImpl:rve,dtype:"bool"}),K2e={kernelName:i2,backendName:"webgpu",kernelFunc:H2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X2e=zn({opType:Je.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:nve}),q2e={kernelName:a2,backendName:"webgpu",kernelFunc:X2e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y2e(t){const{inputs:e,backend:n}=t,{input:r}=e;return OF(r,!0,n)}const Q2e={kernelName:l2,backendName:"webgpu",kernelFunc:Y2e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z2e=kt({opType:Ne.IS_FINITE,dtype:"bool"}),J2e={kernelName:c2,backendName:"webgpu",kernelFunc:Z2e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eSe=kt({opType:Ne.IS_INF,dtype:"bool"}),tSe={kernelName:d2,backendName:"webgpu",kernelFunc:eSe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nSe=kt({opType:Ne.IS_NAN,dtype:"bool"}),rSe={kernelName:h2,backendName:"webgpu",kernelFunc:nSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sSe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{alpha:o}=r,i=[{type:"float32",data:[o]}],a=new Fd(s.shape,Ne.LEAKYRELU,"alpha : f32,");return n.runWebGPUProgram(a,[s],"float32",i)}const oSe={kernelName:f2,backendName:"webgpu",kernelFunc:sSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iSe=zn({opType:Je.LESS,dtype:"bool",cpuKernelImpl:ove}),aSe={kernelName:p2,backendName:"webgpu",kernelFunc:iSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lSe=zn({opType:Je.LESS_EQUAL,dtype:"bool",cpuKernelImpl:sve}),uSe={kernelName:m2,backendName:"webgpu",kernelFunc:lSe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cSe{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dSe(t){const{backend:e,attrs:n}=t,{start:r,stop:s,num:o}=n,i=(s-r)/(o-1),a=new cSe(o),l=[{type:"float32",data:[r]},{type:"float32",data:[i]}];return e.runWebGPUProgram(a,[],"float32",l)}const hSe={kernelName:g2,backendName:"webgpu",kernelFunc:dSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fSe=kt({opType:Ne.LOG,cpuKernelImpl:ive}),pSe={kernelName:y2,backendName:"webgpu",kernelFunc:fSe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mSe=kt({opType:Ne.LOG1P}),gSe={kernelName:x2,backendName:"webgpu",kernelFunc:mSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ySe=zn({opType:Je.LOGICAL_AND,dtype:"bool"}),xSe={kernelName:v2,backendName:"webgpu",kernelFunc:ySe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vSe=kt({opType:Ne.LOGICAL_NOT}),bSe={kernelName:b2,backendName:"webgpu",kernelFunc:vSe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wSe=zn({opType:Je.LOGICAL_OR}),SSe={kernelName:w2,backendName:"webgpu",kernelFunc:wSe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LF=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;class CSe{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${LF}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}}class $Se{constructor(e,n){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,z(n<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${n}`),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Re(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${Ee()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${LF}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kSe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{depthRadius:o,bias:i,alpha:a,beta:l}=r;let c;o>16?c=new CSe(s.shape):c=new $Se(s.shape,o);const d=[{type:"int32",data:[o]},{type:"float32",data:[i]},{type:"float32",data:[a]},{type:"float32",data:[l]}];return n.runWebGPUProgram(c,[s],s.dtype,d)}const TSe={kernelName:S2,backendName:"webgpu",kernelFunc:kSe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ISe{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NSe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,y:o,dy:i}=e,{depthRadius:a,bias:l,alpha:c,beta:d}=r,f=new ISe(s.shape),p=[{type:"int32",data:[a]},{type:"float32",data:[l]},{type:"float32",data:[c]},{type:"float32",data:[d]}];return n.runWebGPUProgram(f,[s,o,i],s.dtype,p)}const ESe={kernelName:rA,backendName:"webgpu",kernelFunc:NSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RSe=zn({opType:Je.MAX,cpuKernelImpl:lve}),_Se={kernelName:$2,backendName:"webgpu",kernelFunc:RSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PSe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r,d=fo(s.shape,o,i,1,a,l);return kF(s,d,"max",n)}const ASe={kernelName:k2,backendName:"webgpu",kernelFunc:PSe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DSe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:i,pad:a,dataFormat:l,dimRoundingMode:c}=r,d=[1,1,1],f=Sa(s.shape,o,i,d,a,c,l),p=new VC(f,"max"),g=[{type:"int32",data:[f.strideDepth,f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.front,f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inDepth,f.inHeight,f.inWidth]},{type:"int32",data:[f.effectiveFilterDepth,f.effectiveFilterHeight,f.effectiveFilterWidth]}];return n.runWebGPUProgram(p,[s],s.dtype,g)}const OSe={kernelName:T2,backendName:"webgpu",kernelFunc:DSe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FSe{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class LSe{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zSe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,i=o,{filterSize:a,strides:l,pad:c,dimRoundingMode:d}=r,f=[1,1,1],p=Sa(i.shape,a,l,f,c,d),g=new VC(p,"max",!0);let y=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.front,p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inDepth,p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]}];const x=n.runWebGPUProgram(g,[i],"int32",y),w=new LSe(p);y=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.effectiveFilterDepth-1-p.padInfo.front,p.effectiveFilterHeight-1-p.padInfo.top,p.effectiveFilterWidth-1-p.padInfo.left]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]},{type:"int32",data:[p.outDepth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]}];const S=n.runWebGPUProgram(w,[s,x],i.dtype,y);return n.disposeData(x.dataId),S}const BSe={kernelName:oA,backendName:"webgpu",kernelFunc:zSe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MSe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o,output:i}=e,a=o;vF([o,i],"maxPoolGrad");const{filterSize:l,strides:c,pad:d,dimRoundingMode:f}=r,p=fo(a.shape,l,c,1,d,f),g=new Rf(p,"max",!0);let y=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]}];const x=n.runWebGPUProgram(g,[a],"int32",y),w=new FSe(p);y=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.effectiveFilterHeight-1-p.padInfo.top,p.effectiveFilterWidth-1-p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]}];const S=n.runWebGPUProgram(w,[s,x],a.dtype,y);return n.disposeData(x.dataId),S}const VSe={kernelName:sA,backendName:"webgpu",kernelFunc:MSe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WSe(t){const{inputs:e,backend:n,attrs:r}=t,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=r,{x:l}=e;z(l.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${l.shape.length}.`);const c=[1,1];z(Er(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const d=fo(l.shape,s,o,c,i),f=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]}];let p=new Rf(d,"max",!1);const g=n.runWebGPUProgram(p,[l],l.dtype,f);p=new Rf(d,"max",!0,!0,a);const y=n.runWebGPUProgram(p,[l],"int32",f);return[g,y]}const USe={kernelName:I2,backendName:"webgpu",kernelFunc:WSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jSe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r;return Xu(s,o,i,"min",n)}const GSe={kernelName:E2,backendName:"webgpu",kernelFunc:jSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HSe=zn({opType:Je.MIN,cpuKernelImpl:uve}),KSe={kernelName:R2,backendName:"webgpu",kernelFunc:HSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XSe{constructor(e,n,r){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n.map((s,o)=>s[0]+e[o]+s[1]),this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,n.map((s,o)=>{this.uniforms+=` pad${o} : vec2<i32>,`}),this.offset=r==="reflect"?0:1,this.shaderKey=`mirrorPad_${r}`}getUserCode(){const e=this.xShape.length,n=this.xShape.map((c,d)=>`uniforms.pad${d}[0]`).join(","),r=this.xShape.map((c,d)=>`uniforms.pad${d}[0] + uniforms.xShape${e>1?`[${d}]`:""}`).join(","),s=e===1?"start":"start[i]",o=e===1?"end":"end[i]",i=e===1?"outC":"outC[i]",a=bn(e),l=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let start = ${a}(${n});
          let end = ${a}(${r});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${i} < ${s}) {
              ${i} = ${s} * 2 - ${i} - ${this.offset};
            } else if(${i} >= ${o}) {
              ${i} = (${o} - 1) * 2 - ${i} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qSe={kernelName:_2,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{paddings:s,mode:o}=e,i=n,a=s.map(d=>({type:"int32",data:[d[0],d[1]]})),l=new XSe(r.shape,s,o);return i.runWebGPUProgram(l,[r],r.dtype,a)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YSe=zn({opType:Je.MOD}),QSe={kernelName:P2,backendName:"webgpu",kernelFunc:YSe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZSe{constructor(e,n){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,n],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JSe{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${Ee("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zF(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{dim:o}=r,i=Be({inputs:{x:s},backend:n,attrs:{shape:[pe(s.shape)/s.shape[o],s.shape[o]]}}),a=new JSe(i.shape),l=n.runWebGPUProgram(a,[i],s.dtype),c=Be({inputs:{x:l},backend:n,attrs:{shape:s.shape}});return n.disposeData(i.dataId),n.disposeData(l.dataId),c}const eCe={kernelName:xS,backendName:"webgpu",kernelFunc:zF};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tCe(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{numSamples:o,seed:i,normalized:a}=r,l=a?s:zF({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),c=l.shape[0],d=l.shape[1],f=new ZSe(c,o),p=[{type:"float32",data:[i]},{type:"int32",data:[d]}],g=n.runWebGPUProgram(f,[l],"int32",p);return a||n.disposeData(l.dataId),g}const nCe={kernelName:A2,backendName:"webgpu",kernelFunc:tCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rCe(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])){const o=n.tensorMap.get(r.dataId),[i,a]=dve(o.values,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,i)}const s=new Fd(r.shape,Ne.NEG);return n.runWebGPUProgram(s,[r],r.dtype)}const sCe={kernelName:O2,backendName:"webgpu",kernelFunc:rCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oCe(t){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r,c=n.readSync(s.dataId),d=n.readSync(o.dataId),{selectedIndices:f}=qS(c,d,i,a,l);return n.makeTensorInfo([f.length],"int32",new Int32Array(f))}const iCe={kernelName:L2,backendName:"webgpu",kernelFunc:oCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aCe(t){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r,d=n.readSync(s.dataId),f=n.readSync(o.dataId),p=i,g=a,y=l,x=c,{selectedIndices:w,selectedScores:S}=YS(d,f,p,g,y,x);return[n.makeTensorInfo([w.length],"int32",new Int32Array(w)),n.makeTensorInfo([S.length],"float32",new Float32Array(S))]}const lCe={kernelName:z2,backendName:"webgpu",kernelFunc:aCe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uCe{constructor(e,n){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,n],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${Ee("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cCe(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s}=e,{dtype:o,depth:i,onValue:a,offValue:l}=r,c=pe(s.shape),d=new uCe(c,i),f=Be({inputs:{x:s},backend:n,attrs:{shape:[c]}}),p=[{type:"float32",data:[a]},{type:"float32",data:[l]}],g=n.runWebGPUProgram(d,[f],o,p);n.disposeData(f.dataId);const y=[...s.shape,i],x=Be({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeData(g.dataId),x}const dCe={kernelName:M2,backendName:"webgpu",kernelFunc:cCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bg(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="complex64"){const s=sp({inputs:{input:r},backend:n}),o=Bg({inputs:{x:s},backend:n}),i=Iy({inputs:{input:r},backend:n}),a=Bg({inputs:{x:i},backend:n}),l=Ku({inputs:{real:o,imag:a},backend:n});return n.disposeData(s.dataId),n.disposeData(o.dataId),n.disposeData(i.dataId),n.disposeData(a.dataId),l}else return jr({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}const hCe={kernelName:PS,backendName:"webgpu",kernelFunc:Bg};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BF(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=sp({inputs:{input:r},backend:n}),o=BF({inputs:{x:s},backend:n}),i=Iy({inputs:{input:r},backend:n}),a=Bg({inputs:{x:i},backend:n}),l=Ku({inputs:{real:o,imag:a},backend:n});return n.disposeData(s.dataId),n.disposeData(o.dataId),n.disposeData(i.dataId),n.disposeData(a.dataId),l}else return jr({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}const fCe={kernelName:B2,backendName:"webgpu",kernelFunc:BF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pCe(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r;if(e.length===1)return zv({inputs:{input:e[0]},backend:n,attrs:{dim:s}});const o=e[0].shape,i=e[0].dtype;e.forEach(d=>{xs(o,d.shape,"All tensors passed to stack must have matching shapes"),z(i===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(d=>{const f=zv({inputs:{input:d},backend:n,attrs:{dim:s}});return a.push(f),f}),c=NF({inputs:l,backend:n,attrs:{axis:s}});return a.forEach(d=>n.disposeData(d.dataId)),c}const mCe={kernelName:V2,backendName:"webgpu",kernelFunc:pCe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MF(t,e=!1){const n=t.length,r=bn(n),s=t.map((f,p)=>`uniforms.pad${p}[0]`).join(","),o=t.map((f,p)=>`uniforms.pad${p}[0] + uniforms.xShape${n>1?`[${p}]`:""}`).join(","),i=n>1?`${r}(${s})`:`${s}`,a=n>1?`${r}(${o})`:`${o}`,l=n>1?"any(paddedCoords < start)":"paddedCoords < start",c=n>1?"any(paddedCoords >= end)":"paddedCoords >= end",d=n>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n):"coords";return`
        let start = ${i};
        let end = ${a};
        if (${l} || ${c}) {
          setOutputAtIndex(index, ${e?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${d}));
        }
  `}class gCe{constructor(e,n){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n.map((r,s)=>r[0]+e[s]+r[1]),this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),n.map((r,s)=>{this.uniforms+=` pad${s} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${MF(this.xShape)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yCe=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{paddings:o,constantValue:i}=r;if(o.every(c=>Vt(c,[0,0])))return ys({inputs:{x:s},backend:n});if(pe(s.shape)===0){const c=o.map((d,f)=>d[0]+s.shape[f]+d[1]);return jr({backend:n,attrs:{shape:c,value:i,dtype:s.dtype}})}const a=[{type:"float32",data:[i]}];o.map(c=>a.push({type:"int32",data:[c[0],c[1]]}));const l=new gCe(s.shape,o);return n.runWebGPUProgram(l,[s],s.dtype,a)},xCe={kernelName:W2,backendName:"webgpu",kernelFunc:yCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vCe=zn({opType:Je.POW}),bCe={kernelName:U2,backendName:"webgpu",kernelFunc:vCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wCe(t){const{inputs:e,backend:n}=t,{x:r,alpha:s}=e,o=new Lg(Je.PRELU,r.shape,s.shape);return n.runWebGPUProgram(o,[r,s],"float32")}const SCe={kernelName:j2,backendName:"webgpu",kernelFunc:wCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CCe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r;return Xu(s,o,i,"prod",n)}const $Ce={kernelName:G2,backendName:"webgpu",kernelFunc:CCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kCe=t=>{const{backend:e,attrs:n}=t,{start:r,stop:s,step:o,dtype:i}=n,a=pve(r,s,o,i);return e.makeTensorInfo([a.length],i,a)},TCe={kernelName:H2,backendName:"webgpu",kernelFunc:kCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ICe=zn({opType:Je.DIV}),NCe={kernelName:jw,backendName:"webgpu",kernelFunc:ICe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ECe=kt({opType:Ne.RECIPROCAL}),RCe={kernelName:X2,backendName:"webgpu",kernelFunc:ECe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Ce=kt({opType:Ne.RELU}),PCe={kernelName:q2,backendName:"webgpu",kernelFunc:_Ce};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ACe=kt({opType:Ne.RELU6}),DCe={kernelName:J2,backendName:"webgpu",kernelFunc:ACe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OCe{constructor(e,n,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],n,r,e[3]],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FCe(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:o,size:i,halfPixelCenters:a}=r,[l,c]=i,d=o&&l>1?1:0,f=o&&c>1?1:0,g=[{type:"float32",data:[d,f]},{type:"float32",data:[a?.5:0]}],y=new OCe(s.shape,l,c);return n.runWebGPUProgram(y,[s],"float32",g)}const LCe={kernelName:Z2,backendName:"webgpu",kernelFunc:FCe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zCe{constructor(e,n){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=n,this.shaderKey=`resizeBilinearBackprop_${n}`}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BCe(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:o}=e,{alignCorners:i}=r,[,a,l]=s.shape,[,c,d]=o.shape,f=[i&&c>1?a-1:a,i&&d>1?l-1:l],p=[i&&c>1?c-1:c,i&&d>1?d-1:d],g=f[0]/p[0],y=f[1]/p[1],x=1/g,w=1/y,S=Math.ceil(x)*2+2,$=Math.ceil(w)*2+2,I=new zCe(s.shape,i),R=[{type:"int32",data:f},{type:"int32",data:p},{type:"float32",data:[g]},{type:"float32",data:[y]},{type:"float32",data:[x]},{type:"float32",data:[w]},{type:"int32",data:[S]},{type:"int32",data:[$]}];return n.runWebGPUProgram(I,[o],o.dtype,R)}const MCe={kernelName:dA,backendName:"webgpu",kernelFunc:BCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VCe{constructor(e,n,r,s){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],n,r,e[3]],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=s,this.shaderKey=`resizeNearest_${s}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WCe(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,c]=a,d=o&&l>1?1:0,f=o&&c>1?1:0,g=[{type:"float32",data:[d,f]},{type:"float32",data:[o?.5:0]}],y=new VCe(s.shape,l,c,i);return n.runWebGPUProgram(y,[s],s.dtype,g)}const UCe={kernelName:Q2,backendName:"webgpu",kernelFunc:WCe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jCe{constructor(e,n){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=n,this.shaderKey=`resizeNearestNeigborBackprop_${n}`}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GCe(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:o}=e,{alignCorners:i}=r,[,a,l]=s.shape,[,c,d]=o.shape,f=[i&&c>1?a-1:a,i&&d>1?l-1:l],p=[i&&c>1?c-1:c,i&&d>1?d-1:d],g=f[0]/p[0],y=f[1]/p[1],x=1/g,w=1/y,S=Math.ceil(x)*2+2,$=Math.ceil(w)*2+2,I=new jCe(s.shape,i),R=[{type:"int32",data:f},{type:"int32",data:p},{type:"float32",data:[x]},{type:"float32",data:[w]},{type:"int32",data:[S]},{type:"int32",data:[$]}];return n.runWebGPUProgram(I,[o],o.dtype,R)}const HCe={kernelName:cA,backendName:"webgpu",kernelFunc:GCe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KCe{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XCe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dims:o}=r,i=s.shape.length;if(i===0)return ys({inputs:{x:s},backend:n});const a=s.shape,l=[1,1,1,1];a.forEach((w,S)=>{const $=S+4-i;l[$]=w});const c=nn(o,s.shape),d=[0,0,0,0];c.forEach(w=>{const S=w+4-i;d[S]=1});const f=[{type:"int32",data:d}],p=Be({inputs:{x:s},backend:n,attrs:{shape:l}}),g=new KCe(l),y=n.runWebGPUProgram(g,[p],p.dtype,f);n.disposeData(p.dataId);const x=Be({inputs:{x:y},backend:n,attrs:{shape:a}});return n.disposeData(y.dataId),x}const qCe={kernelName:eS,backendName:"webgpu",kernelFunc:XCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YCe{constructor(e,n){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,typeof n=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${Ee("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QCe={kernelName:DS,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:s,fillValue:o,center:i}=e,a=n,l=new YCe(r.shape,o),[c,d]=cC(i,r.shape[1],r.shape[2]),f=[{type:"float32",data:[c]},{type:"float32",data:[d]},{type:"float32",data:[Math.sin(s)]},{type:"float32",data:[Math.cos(s)]}];return typeof o=="number"?f.push({type:"float32",data:[Number.parseFloat(o.toFixed(2))]}):f.push({type:"float32",data:o}),a.runWebGPUProgram(l,[r],r.dtype,f)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZCe=kt({opType:Ne.ROUND}),JCe={kernelName:tS,backendName:"webgpu",kernelFunc:ZCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e$e=kt({opType:Ne.RSQRT,cpuKernelImpl:mve}),t$e={kernelName:nS,backendName:"webgpu",kernelFunc:e$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jh{constructor(e,n,r,s,o,i,a,l=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=i,this.type=a,this.sumDupeIndices=l,this.dispatchLayout=De(e),this.dispatch=Re(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=n>1,this.shaderKey=`scatter_${r}_${s}_${this.sliceDimGreaterThanOne}_${a}_${l}_${o.length}`;const c=bn(o.length);this.uniforms=`sliceDim : i32, strides: ${c}, updatesSize: i32,`,this.updatesRank=s,this.indicesRank=r}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");const n=`getIndices(${e})`,r=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let s="",o="";this.dispatchLayout.x.length===1?(s="flattenedIndex",o=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(s="vec2<i32>(flattenedIndex, coords[1])",o=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const a=`getUpdates(${Array.from({length:this.updatesRank},(c,d)=>`coords[${d}]`).join(", ")})`;return`
    ${o}
      ${Ee("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${n}));
            flattenedIndex = flattenedIndex + indexInside * ${r};
          }
          let updateValue =
              ${mu(this.type)}(${a});
          let flatIndex = getOutputIndexFromCoords(${s});

          ${this.sumDupeIndices?Nl("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n$e(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s,updates:o}=e,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:d,outputSize:f}=Bu(o,s,i),p=[f/c,c];if(f===0)return n.makeTensorInfo(i,s.dtype);const g=Be({inputs:{x:s},backend:n,attrs:{shape:[l,a]}}),y=Be({inputs:{x:o},backend:n,attrs:{shape:[l,c]}}),x=y.dtype,w=jr({backend:n,attrs:{shape:p,value:0,dtype:x}}),S=pe(y.shape),$=[{type:"int32",data:[a]},{type:"int32",data:d},{type:"int32",data:[S]}],I=new Jh(y.shape,a,g.shape.length,y.shape.length,d,p,x),R=n.runWebGPUProgram(I,[y,g],x,$,w),_=Be({inputs:{x:R},backend:n,attrs:{shape:i}});return n.disposeData(g.dataId),n.disposeData(y.dataId),n.disposeData(R.dataId),_}const r$e={kernelName:rS,backendName:"webgpu",kernelFunc:n$e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class s$e{constructor(e,n){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=n,this.shaderKey=`search_sorted_${n}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o$e(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:s,values:o}=e,{side:i}=r,a=new s$e([o.shape[0],o.shape[1]],i),l=[{type:"int32",data:[s.shape[1]]}];return n.runWebGPUProgram(a,[s,o],"int32",l)}const i$e={kernelName:oS,backendName:"webgpu",kernelFunc:o$e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class a$e{constructor(e,n,r){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=r,this.shaderKey="select"}getUserCode(){let e,n;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)n="resRC",e="resRC";else{const s=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],i=[];for(let a=0;a<this.outputShape.length;a++)i.push(`${s[a]}`),a<this.cRank&&o.push(`${s[a]}`);e=o.join(),n=i.join()}return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${n}));
          } else {
            setOutputAtIndex(index, getB(${n}));
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l$e(t){const{inputs:e,backend:n}=t,{condition:r,t:s,e:o}=e,i=new a$e(r.shape.length,s.shape,s.shape.length);return n.runWebGPUProgram(i,[r,s,o],Gr(s.dtype,o.dtype))}const u$e={kernelName:iS,backendName:"webgpu",kernelFunc:l$e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c$e=kt({opType:Ne.SELU}),d$e={kernelName:aS,backendName:"webgpu",kernelFunc:c$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h$e=kt({opType:Ne.SIGMOID}),f$e={kernelName:hS,backendName:"webgpu",kernelFunc:h$e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p$e=kt({opType:Ne.SIGN}),m$e={kernelName:dS,backendName:"webgpu",kernelFunc:p$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g$e=kt({opType:Ne.SIN}),y$e={kernelName:uS,backendName:"webgpu",kernelFunc:g$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x$e=kt({opType:Ne.SINH}),v$e={kernelName:cS,backendName:"webgpu",kernelFunc:x$e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b$e=kt({opType:Ne.SOFTPLUS}),w$e={kernelName:fS,backendName:"webgpu",kernelFunc:b$e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class S$e{constructor(e,n,r,s,o,i){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const a=new Array(s.length);for(let l=0;l<a.length;l++)a[l]=s[o[l]];this.outputShape=a,this.newDim=o,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=n,this.uniforms+=`reshapedPaddedXShape : ${bn(s.length)}, paddedXShapeStrides : ${bn(i)}, `,r.map((l,c)=>{this.uniforms+=` pad${c} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${o}`}getUserCode(){const e=bn(this.outputShape.length),n=wF(this.newDim);return`
      ${tg(this.paddedXShape,"PaddedX")}
      ${Ee("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${n}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${MF(this.xShape,!0)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C$e=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:o,paddings:i}=r;z(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const a=o.reduce(($,I)=>$*I),l=[[0,0]];l.push(...i);for(let $=1+o.length;$<s.shape.length;++$)l.push([0,0]);const c=l.map(($,I)=>$[0]+s.shape[I]+$[1]),d=Yf(c,o,a,!1),f=Qf(d.length,o.length,!1),p=Zf(c,o,a,!1),g=gn(c),y=new S$e(s.shape,c,l,d,f,g.length),x=[{type:"int32",data:d},{type:"int32",data:g}];l.map($=>x.push({type:"int32",data:[$[0],$[1]]}));const w=n.runWebGPUProgram(y,[s],s.dtype,x),S=Be({inputs:{x:w},backend:n,attrs:{shape:p}});return n.disposeData(w.dataId),S},$$e={kernelName:gS,backendName:"webgpu",kernelFunc:C$e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class k$e{constructor(e,n,r){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=r,this.dispatchLayout=De([n]),this.dispatch=Re(this.dispatchLayout,[n],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${Nl("&result[outIndex]","value",this.type)}
      }
    }
  `}}class T$e{constructor(e,n){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=De(n),this.dispatch=Re(this.dispatchLayout,n,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${Nl("&result[segmentId]","1","int32")}
      }
    }
  `}}class I$e{constructor(e,n){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=n,this.dispatchLayout=De(e),this.dispatch=Re(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VF(t,e,n,r=!1,s){const i=pe(t.shape)/t.shape[0],a=t.dtype,l=pe(e.shape),c=s.readSync(n.dataId),f=l>0?c[l-1]+1:0;let p;const g=t.shape.slice();g[0]=f;const y=l*i,x=jr({backend:s,attrs:{shape:g,value:0,dtype:a}});p=new k$e(g,y,a);let w=[{type:"int32",data:[i]},{type:"int32",data:[y]}];const S=s.runWebGPUProgram(p,[t,e,n],a,w,x);if(r)return S;const $=jr({backend:s,attrs:{shape:[f],value:0,dtype:"int32"}});p=new T$e(f,n.shape);const I=s.runWebGPUProgram(p,[n],"int32",null,$),R=jr({backend:s,attrs:{shape:g,value:0,dtype:a}});p=new I$e(g,a),w=[{type:"int32",data:[i]}];const _=s.runWebGPUProgram(p,[S,I],a,w,R);return s.disposeData(S.dataId),s.disposeData(I.dataId),_}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N$e(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:o}=e;return VF(r,s,o,!1,n)}const E$e={kernelName:vS,backendName:"webgpu",kernelFunc:N$e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R$e(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:o}=e;return VF(r,s,o,!0,n)}const _$e={kernelName:bS,backendName:"webgpu",kernelFunc:R$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class P$e{constructor(e,n){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[s]*n[s];this.outputShape=r,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=A$e(this.rank,"uniforms.");return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `}}function A$e(t,e=""){if(t>=5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`(resRC % ${e}aShape)`;const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<t;s++)r.push(`(${n[s]} % ${e}aShape[${s}])`);return r.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WC(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reps:o}=r;if(n.shouldExecuteOnCPU([s])||s.dtype==="string"||s.shape.length>=5){const l=n.readSync(s.dataId),c=s.dtype==="string"?l.map(p=>fa(p)):l,d=Wt(s.shape,s.dtype,c),f=Sve(d,o);return n.makeTensorInfo(f.shape,f.dtype,f.values)}const i=new P$e(s.shape,o);return n.runWebGPUProgram(i,[s],s.dtype)}const D$e={kernelName:sy,backendName:"webgpu",kernelFunc:WC};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O$e(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:s,sparseValues:o,defaultValue:i}=e,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:d,strides:f,outputSize:p}=Bu(o,s,a),g=!1;if(o.dtype==="string"){const B=n.bufferSync(s),M=n.bufferSync(o),V=fa(n.readSync(i.dataId)[0]),P=gve(B,M,a,p,d,c,l,f,V,g);return n.makeTensorInfo(a,P.dtype,P.values)}const y=[p/d,d],x=Be({inputs:{x:s},backend:n,attrs:{shape:[c,l]}}),w=o.shape.length?Be({inputs:{x:o},backend:n,attrs:{shape:[c,d]}}):ys({inputs:{x:o},backend:n}),S=w.dtype,$=n.makeTensorInfo([],S,ha(1,S)),I=Be({inputs:{x:i},backend:n,attrs:{shape:Array(y.length).fill(1)}}),R=WC({inputs:{x:I},backend:n,attrs:{reps:y}}),_=pe([c,d]),O=[{type:"int32",data:[l]},{type:"int32",data:f},{type:"int32",data:[_]}];switch(c){case 0:break;case 1:{const B=new Jh([c,d],l,x.shape.length,w.shape.length,f,y,S,g);n.runWebGPUProgram(B,[w,x],S,O,R)}break;default:{const B=new Jh([c,d],l,x.shape.length,$.shape.length,f,y,S,g);n.runWebGPUProgram(B,[$,x],S,O,R)}{const B=new Jh([c,d],l,x.shape.length,w.shape.length,f,y,S);n.runWebGPUProgram(B,[w,x],S,O,R)}}const F=Be({inputs:{x:R},backend:n,attrs:{shape:a}});return n.disposeData(x.dataId),n.disposeData(w.dataId),n.disposeData(I.dataId),n.disposeData($.dataId),n.disposeData(R.dataId),F}const F$e={kernelName:wS,backendName:"webgpu",kernelFunc:O$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L$e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{numOrSizeSplits:o,axis:i}=r,a=nn(i,s.shape)[0],l=TC(s,o,a),c=s.shape.length,d=new Array(c).fill(0),f=s.shape.slice();return l.map(p=>{const g=[...f];g[a]=p;const y=Ld({inputs:{x:s},backend:n,attrs:{begin:d,size:g}});return d[a]+=p,y})}const z$e={kernelName:yS,backendName:"webgpu",kernelFunc:L$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B$e=kt({opType:Ne.SQRT}),M$e={kernelName:pS,backendName:"webgpu",kernelFunc:B$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V$e={kernelName:pA,backendName:"webgpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,r=e,s=new Fd(n.shape,Ne.SQUARE);return r.runWebGPUProgram(s,[n],n.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W$e=zn({opType:Je.SQUARED_DIFFERENCE}),U$e={kernelName:SS,backendName:"webgpu",kernelFunc:W$e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j$e({inputs:t,attrs:e,backend:n}){const{x:r}=t,s=new Fd(r.shape,Ne.STEP,"stepAlpha : f32,"),o=[{type:"float32",data:[e.alpha]}];return n.runWebGPUProgram(s,[r],r.dtype,o)}const G$e={kernelName:AS,backendName:"webgpu",kernelFunc:j$e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class H$e{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const n=bn(this.outputShape.length);this.uniforms=`begin : ${n},  strides : ${n}, `,this.shaderKey="stridedSlice"}getUserCode(){const e=this.outputShape.length;let n="";if(e===1)n="coords * uniforms.strides + uniforms.begin";else{let s=0;n=this.outputShape.map((o,i)=>(s++,this.outputShape.length===1?`coords * uniforms.strides[${i}] + uniforms.begin[${i}]`:`coords[${s-1}] * uniforms.strides[${i}] + uniforms.begin[${i}]`)).join(",")}return`
       ${Ee("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${n}));
         }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K$e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:o,end:i,strides:a,beginMask:l,endMask:c,ellipsisMask:d,newAxisMask:f,shrinkAxisMask:p}=r,{finalShapeSparse:g,finalShape:y,isIdentity:x,sliceDim0:w,isSimpleSlice:S,begin:$,end:I,strides:R}=aC(s.shape,o,i,a,l,c,d,f,p);let _;if(x)_=Be({inputs:{x:s},backend:n,attrs:{shape:y}});else if(w||S){z(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const O=rC($,I,R),F=Ld({inputs:{x:s},backend:n,attrs:{begin:$,size:O}});_=Be({inputs:{x:F},backend:n,attrs:{shape:y}}),n.disposeData(F.dataId)}else if(n.shouldExecuteOnCPU([s])){const F=n.readSync(s.dataId),B=Wt(s.shape,s.dtype,F),M=vve(g,B,R,$);_=n.makeTensorInfo(y,s.dtype,M.values)}else{const F=new H$e(g),B=[{type:"int32",data:$},{type:"int32",data:R}],M=n.runWebGPUProgram(F,[s],s.dtype,B);_=Be({inputs:{x:M},backend:n,attrs:{shape:y}}),n.disposeData(M.dataId)}return _}const X$e={kernelName:CS,backendName:"webgpu",kernelFunc:K$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q$e(t){const{inputs:e,backend:n,attrs:r}=t,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:d,dataSplits:f}=e,p=n.readSync(d.dataId),g=n.readSync(f.dataId),[y,x]=bve(p,g,s,o,i,a,l,c);return[n.makeTensorInfo([y.length],"string",y),n.makeTensorInfo(f.shape,"int32",x)]}const Y$e={kernelName:$S,backendName:"webgpu",kernelFunc:q$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q$e=zn({opType:Je.SUB,cpuKernelImpl:wve,supportsComplex:!0}),Z$e={kernelName:kS,backendName:"webgpu",kernelFunc:Q$e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J$e=kt({opType:Ne.TAN}),eke={kernelName:TS,backendName:"webgpu",kernelFunc:J$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tke=kt({opType:Ne.TANH}),nke={kernelName:IS,backendName:"webgpu",kernelFunc:tke};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rke(t){const{inputs:e,backend:n,attrs:r}=t,{tensor:s,indices:o,updates:i}=e,{sliceRank:a,numUpdates:l,sliceSize:c,strides:d,outputSize:f}=Bu(i,o,s.shape),p=[f/c,c];if(f===0)return n.makeTensorInfo(s.shape,o.dtype);const g=[],y=Be({inputs:{x:o},backend:n,attrs:{shape:[l,a]}});g.push(y);const x=Be({inputs:{x:i},backend:n,attrs:{shape:[l,c]}});g.push(x);const w=Be({inputs:{x:s},backend:n,attrs:{shape:p}});g.push(w);const S=WC({inputs:{x:w},backend:n,attrs:{reps:Array(p.length).fill(1)}}),$=new Jh([l,c],a,y.shape.length,x.shape.length,d,p,s.dtype,!1),I=pe([l,c]),R=[{type:"int32",data:[a]},{type:"int32",data:d},{type:"int32",data:[I]}],_=n.runWebGPUProgram($,[x,y],w.dtype,R,S);g.push(_);const O=Be({inputs:{x:_},backend:n,attrs:{shape:s.shape}});return g.forEach(F=>n.disposeData(F.dataId)),O}const ske={kernelName:sS,backendName:"webgpu",kernelFunc:rke};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oke{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${Ee("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}class ike{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${Ee("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ic(t,e){e!==null&&t.disposeData(e.dataId)}function VN(t){let e=1;for(;e<t;)e*=2;return e}function ake(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{k:o,sorted:i}=r,a=s.shape,l=a[a.length-1];if(n.shouldExecuteOnCPU([s])){const _=n.readSync(s.dataId),[O,F]=Cve(_,a,s.dtype,o,i);return[n.makeTensorInfo(O.shape,O.dtype,O.values),n.makeTensorInfo(F.shape,F.dtype,F.values)]}if(o===0)return a[a.length-1]=0,[n.makeTensorInfo(a,s.dtype,[]),n.makeTensorInfo(a,"int32",[])];if(l===1)return[s,jr({attrs:{shape:a,dtype:"int32",value:0},backend:n})];const d=pe(a)/l,f=Be({inputs:{x:s},attrs:{shape:[d,l]},backend:n}),p=VN(o),g=VN(l);let y=null;const x=()=>y===null?[f,f]:[f,y],w=(_,O,F)=>{const B=x(),M=new oke(F),P=[{type:"int32",data:[l]},{type:"int32",data:[y===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[_]},{type:"int32",data:[O]}],re=y;y=n.runWebGPUProgram(M,B,"int32",P),Ic(n,re)};for(let _=1;_<p;_*=2){const O=_*2;for(let F=_;F>=1;F/=2)w(O,F,[d,g])}for(let _=g;_>p;_/=2){const O=x(),F=new ike([d,_/2]),M=[{type:"int32",data:[l]},{type:"int32",data:[y===null?1:0]},{type:"int32",data:[p]}],V=y;y=n.runWebGPUProgram(F,O,"int32",M),Ic(n,V);const P=p/2,re=P*2;for(let ie=P;ie>=1;ie/=2)w(re,ie,y.shape)}let S=y;y=Ld({inputs:{x:y},backend:n,attrs:{begin:0,size:[d,o]}}),Ic(n,S);let $=FF({inputs:{x:f,indices:y},backend:n,attrs:{axis:1,batchDims:1}});Ic(n,f);const I=a.slice(0,-1);I.push(o),S=y,y=Be({inputs:{x:y},attrs:{shape:I},backend:n}),Ic(n,S);const R=$;return $=Be({inputs:{x:$},attrs:{shape:I},backend:n}),Ic(n,R),[$,y]}const lke={kernelName:NS,backendName:"webgpu",kernelFunc:ake};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uke{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${Ee("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cke(t){const{inputs:e,backend:n,attrs:r}=t,{image:s,transforms:o}=e,{interpolation:i,fillMode:a,fillValue:l,outputShape:c}=r,[d,f,p,g]=s.shape,[y,x]=c??[f,p],w=[d,y,x,g],S=new uke(w),$=i==="nearest"?1:2;let I;switch(a){case"constant":I=1;break;case"reflect":I=2;break;case"wrap":I=3;break;case"nearest":I=4;break;default:I=1;break}const R=[{type:"int32",data:[$]},{type:"int32",data:[I]},{type:"float32",data:[l]}];return n.runWebGPUProgram(S,[s,o],"float32",R)}const dke={kernelName:ES,backendName:"webgpu",kernelFunc:cke};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hke(t){const{inputs:e,backend:n,attrs:r}=t,{value:s}=e;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s,a=i.shape.length,l=s.shape[o],c=new Array(a-1);let d=0;for(let x=0;x<a;x++)x!==o&&(c[d++]=i.shape[x]);const f=[],p=new Array(a).fill(0),g=i.shape.slice();g[o]=1;const y=new Array(l);for(let x=0;x<y.length;x++){p[o]=x;const w=Ld({inputs:{x:i},backend:n,attrs:{begin:p,size:g}}),S=Be({inputs:{x:w},backend:n,attrs:{shape:c}});y[x]=S,f.push(w)}return f.forEach(x=>n.disposeData(x.dataId)),y}const fke={kernelName:RS,backendName:"webgpu",kernelFunc:hke};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pke{constructor(e,n,r){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=n,this.dispatchLayout=De(e),this.dispatch=Re(this.dispatchLayout,e,this.workgroupSize),r!=="float32"&&r!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${r} type.`);this.type=r,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${Nl("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mke(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,segmentIds:o}=e,{numSegments:i}=r,a=s.shape.length,l=[];let c=0;const d=ur([c],a);let f=s;d!=null&&(f=Ci({inputs:{x:s},backend:n,attrs:{perm:d}}),l.push(f),c=cr(1,a)[0]);const p=IC(f.shape,c,i),g=pe([f.shape[c]]),y=Be({inputs:{x:f},backend:n,attrs:{shape:[-1,g]}});l.push(y);const x=s.dtype,w=[y.shape[0],i],S=jr({backend:n,attrs:{shape:w,value:0,dtype:x}}),$=new pke(y.shape,w,x),I=[{type:"int32",data:[i]},{type:"int32",data:[pe(y.shape)]}],R=n.runWebGPUProgram($,[y,o],x,I,S),_=Be({inputs:{x:R},backend:n,attrs:{shape:p}});l.push(R);let O=_;if(d!=null){l.push(_);const F=qf(d);O=Ci({inputs:{x:O},backend:n,attrs:{perm:F}})}return l.forEach(F=>n.disposeData(F.dataId)),O}const gke={kernelName:_S,backendName:"webgpu",kernelFunc:mke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yke=[Wxe,Tve,Nve,Rve,Pve,Ove,Wve,jve,Hve,Xve,Yve,Zve,ebe,nbe,sbe,ube,dbe,mbe,ybe,vbe,$be,Nbe,_be,Obe,Lbe,Vbe,jxe,jbe,Xbe,nwe,lwe,hwe,mwe,ywe,vwe,wwe,Cwe,Twe,Nwe,Rwe,Pwe,Owe,Wwe,jwe,zwe,Kwe,Ywe,e2e,n2e,o2e,u2e,d2e,f2e,m2e,y2e,v2e,b2e,S2e,$2e,Bxe,T2e,P2e,N2e,R2e,O2e,L2e,B2e,W2e,G2e,K2e,q2e,Uxe,Q2e,Hbe,J2e,tSe,rSe,oSe,aSe,uSe,hSe,gSe,pSe,xSe,bSe,SSe,TSe,ESe,ibe,_Se,ASe,VSe,OSe,BSe,USe,abe,GSe,KSe,qSe,QSe,nCe,i2e,sCe,iCe,lCe,Pbe,dCe,fCe,mCe,xCe,bCe,SCe,$Ce,TCe,Abe,NCe,RCe,PCe,DCe,Mxe,LCe,MCe,UCe,HCe,qCe,QCe,JCe,t$e,r$e,i$e,u$e,d$e,f$e,m$e,y$e,v$e,Sbe,G$e,X$e,Y$e,eCe,w$e,$$e,E$e,_$e,F$e,z$e,M$e,V$e,U$e,Z$e,a2e,eke,nke,ske,D$e,lke,dke,zve,fke,gke,hCe];for(const t of yke)vA(t);/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var WF=function(t,e){return(WF=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,r){n.__proto__=r}||function(n,r){for(var s in r)Object.prototype.hasOwnProperty.call(r,s)&&(n[s]=r[s])})(t,e)};function UF(t,e){if(typeof e!="function"&&e!==null)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function n(){this.constructor=t}WF(t,e),t.prototype=e===null?Object.create(e):(n.prototype=e.prototype,new n)}var Yt=function(){return(Yt=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var s in e=arguments[n])Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s]);return t}).apply(this,arguments)};function bt(t,e,n,r){return new(n||(n=Promise))(function(s,o){function i(c){try{l(r.next(c))}catch(d){o(d)}}function a(c){try{l(r.throw(c))}catch(d){o(d)}}function l(c){var d;c.done?s(c.value):(d=c.value,d instanceof n?d:new n(function(f){f(d)})).then(i,a)}l((r=r.apply(t,[])).next())})}function wt(t,e){var n,r,s,o,i={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(l){return function(c){return function(d){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,r&&(s=2&d[0]?r.return:d[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,d[1])).done)return s;switch(r=0,s&&(d=[2&d[0],s.value]),d[0]){case 0:case 1:s=d;break;case 4:return i.label++,{value:d[1],done:!1};case 5:i.label++,r=d[1],d=[0];continue;case 7:d=i.ops.pop(),i.trys.pop();continue;default:if(s=i.trys,!((s=s.length>0&&s[s.length-1])||d[0]!==6&&d[0]!==2)){i=0;continue}if(d[0]===3&&(!s||d[1]>s[0]&&d[1]<s[3])){i.label=d[1];break}if(d[0]===6&&i.label<s[1]){i.label=s[1],s=d;break}if(s&&i.label<s[2]){i.label=s[2],i.ops.push(d);break}s[2]&&i.ops.pop(),i.trys.pop();continue}d=e.call(t,i)}catch(f){d=[6,f],r=0}finally{n=s=0}if(5&d[0])throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}([l,c])}}}function wu(t,e,n){if(n||arguments.length===2)for(var r,s=0,o=e.length;s<o;s++)!r&&s in e||(r||(r=Array.prototype.slice.call(e,0,s)),r[s]=e[s]);return t.concat(r||Array.prototype.slice.call(e))}var $i=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],Pf=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"];function Mg(t){return t instanceof SVGAnimatedLength?t.baseVal.value:t}function jF(t){return bt(this,void 0,void 0,function(){var e,n;return wt(this,function(r){switch(r.label){case 0:return e=document.createElement("canvas"),t instanceof fn?[4,eC(t,e)]:[3,2];case 1:return r.sent(),[3,3];case 2:e.width=Mg(t.width),e.height=Mg(t.height),n=e.getContext("2d"),t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0),r.label=3;case 3:return[2,e]}})})}function GF(t){return bt(this,void 0,void 0,function(){var e,n,r,s,o,i;return wt(this,function(a){switch(a.label){case 0:return t instanceof fn?(e=t.shape.slice(0,2),n=e[0],r=e[1],s=ImageData.bind,[4,eC(t)]):[3,2];case 1:return[2,new(s.apply(ImageData,[void 0,a.sent(),r,n]))];case 2:return o=document.createElement("canvas"),i=o.getContext("2d"),o.width=Mg(t.width),o.height=Mg(t.height),i.drawImage(t,0,0),[2,i.getImageData(0,0,o.width,o.height)]}})})}function xke(t){return bt(this,void 0,void 0,function(){var e,n;return wt(this,function(r){switch(r.label){case 0:return t instanceof SVGImageElement||t instanceof OffscreenCanvas?[4,jF(t)]:[3,2];case 1:return n=r.sent(),[3,3];case 2:n=t,r.label=3;case 3:return e=n,[2,HD(e,4)]}})})}function HF(t){if(t<0||t>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(t));if(!Number.isInteger(t))throw new Error("Mask value must be an integer but got ".concat(t))}var Ch={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},vke=function(){function t(e){this.mask=e}return t.prototype.toCanvasImageSource=function(){return bt(this,void 0,void 0,function(){return wt(this,function(e){return[2,this.mask]})})},t.prototype.toImageData=function(){return bt(this,void 0,void 0,function(){return wt(this,function(e){return[2,GF(this.mask)]})})},t.prototype.toTensor=function(){return bt(this,void 0,void 0,function(){return wt(this,function(e){return[2,xke(this.mask)]})})},t.prototype.getUnderlyingType=function(){return"canvasimagesource"},t}();function bke(t){return HF(t),"person"}var wke=function(){function t(e){var n,r=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new hye.Pose({locateFile:function(s,o){if(e.solutionPath){var i=e.solutionPath.replace(/\/+$/,"");return"".concat(i,"/").concat(s)}return"".concat(o,"/").concat(s)}}),e.modelType){case"lite":n=0;break;case"heavy":n=2;break;case"full":default:n=1}this.poseSolution.setOptions({modelComplexity:n,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(s){if(r.height=s.image.height,r.width=s.image.width,s.poseLandmarks==null)r.poses=[];else{var o=r.translateOutput(s.poseLandmarks,s.poseWorldLandmarks);s.segmentationMask&&(o.segmentation={maskValueToLabel:bke,mask:new vke(s.segmentationMask)}),r.poses=[o]}})}return t.prototype.translateOutput=function(e,n){var r=this,s={keypoints:e.map(function(o,i){return{x:o.x*r.width,y:o.y*r.height,z:o.z,score:o.visibility,name:Pf[i]}})};return n!=null&&(s.keypoints3D=n.map(function(o,i){return{x:o.x,y:o.y,z:o.z,score:o.visibility,name:Pf[i]}})),s},t.prototype.estimatePoses=function(e,n,r){return bt(this,void 0,void 0,function(){var s,o;return wt(this,function(i){switch(i.label){case 0:return n&&n.flipHorizontal&&n.flipHorizontal!==this.selfieMode&&(this.selfieMode=n.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof fn?(o=ImageData.bind,[4,eC(e)]):[3,2];case 1:return s=new(o.apply(ImageData,[void 0,i.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:s=e,i.label=3;case 3:return e=s,[4,this.poseSolution.send({image:e},r)];case 4:return i.sent(),[2,this.poses]}})})},t.prototype.dispose=function(){this.poseSolution.close()},t.prototype.reset=function(){this.poseSolution.reset()},t.prototype.initialize=function(){return this.poseSolution.initialize()},t}();function Ske(t){return bt(this,void 0,void 0,function(){var e,n;return wt(this,function(r){switch(r.label){case 0:return e=function(s){if(s==null)return Yt({},Ch);var o=Yt({},s);return o.runtime="mediapipe",o.enableSegmentation==null&&(o.enableSegmentation=Ch.enableSegmentation),o.enableSmoothing==null&&(o.enableSmoothing=Ch.enableSmoothing),o.smoothSegmentation==null&&(o.smoothSegmentation=Ch.smoothSegmentation),o.modelType==null&&(o.modelType=Ch.modelType),o}(t),[4,(n=new wke(e)).initialize()];case 1:return r.sent(),[2,n]}})})}function md(t){return t instanceof fn?{height:t.shape[0],width:t.shape[1]}:{height:t.height,width:t.width}}function KF(t){return t-2*Math.PI*Math.floor((t+Math.PI)/(2*Math.PI))}function UC(t){return t instanceof fn?t:HD(t)}function XF(t,e,n){return Bv(n,"inputResolution"),[1/n.width*t[0][0]*e.width,1/n.height*t[0][1]*e.width,t[0][3]*e.width,1/n.width*t[1][0]*e.height,1/n.height*t[1][1]*e.height,t[1][3]*e.height,0,0]}function Bv(t,e){z(t.width!==0,function(){return"".concat(e," width cannot be 0.")}),z(t.height!==0,function(){return"".concat(e," height cannot be 0.")})}function ox(t,e,n){var r=n.rotationVectorStartKeypointIndex,s=n.rotationVectorEndKeypointIndex,o=t.locationData,i=o.relativeKeypoints[r].x*e.width,a=o.relativeKeypoints[r].y*e.height,l=o.relativeKeypoints[s].x*e.width,c=o.relativeKeypoints[s].y*e.height,d=2*Math.sqrt((l-i)*(l-i)+(c-a)*(c-a)),f=function(p,g,y){var x,w=p.locationData,S=y.rotationVectorStartKeypointIndex,$=y.rotationVectorEndKeypointIndex;x=y.rotationVectorTargetAngle?y.rotationVectorTargetAngle:Math.PI*y.rotationVectorTargetAngleDegree/180;var I=w.relativeKeypoints[S].x*g.width,R=w.relativeKeypoints[S].y*g.height,_=w.relativeKeypoints[$].x*g.width,O=w.relativeKeypoints[$].y*g.height;return KF(x-Math.atan2(-(O-R),_-I))}(t,e,n);return{xCenter:i/e.width,yCenter:a/e.height,width:d/e.width,height:d/e.height,rotation:f}}function qF(t){if(t.length!==16)throw new Error("Array length must be 16 but got ".concat(t.length));return[[t[0],t[1],t[2],t[3]],[t[4],t[5],t[6],t[7]],[t[8],t[9],t[10],t[11]],[t[12],t[13],t[14],t[15]]]}function ix(t,e,n,r,s,o,i){return t[e][s]*(t[n][o]*t[r][i]-t[n][i]*t[r][o])}function vr(t,e,n){var r=(e+1)%4,s=(e+2)%4,o=(e+3)%4,i=(n+1)%4,a=(n+2)%4,l=(n+3)%4;return ix(t,r,s,o,i,a,l)+ix(t,s,o,r,i,a,l)+ix(t,o,r,s,i,a,l)}function WN(t,e,n){n===void 0&&(n={ignoreRotation:!1});for(var r=[],s=0,o=t;s<o.length;s++){var i=o[s],a=i.x-.5,l=i.y-.5,c=n.ignoreRotation?0:e.rotation,d=Math.cos(c)*a-Math.sin(c)*l,f=Math.sin(c)*a+Math.cos(c)*l;d=d*e.width+e.xCenter,f=f*e.height+e.yCenter;var p=i.z*e.width,g=Yt({},i);g.x=d,g.y=f,g.z=p,r.push(g)}return r}function YF(t,e){var n=function(r,s,o,i){var a=s-r,l=i-o,c=l/a;return{scale:c,offset:o-r*c}}(0,255,e[0],e[1]);return nt(function(){return We(Te(t,n.scale),n.offset)})}function Mv(t,e,n){var r,s,o,i,a,l,c,d,f,p,g,y,x,w,S=e.outputTensorSize,$=e.keepAspectRatio,I=e.borderMode,R=e.outputTensorFloatRange,_=md(t),O=function(M,V){return V?{xCenter:V.xCenter*M.width,yCenter:V.yCenter*M.height,width:V.width*M.width,height:V.height*M.height,rotation:V.rotation}:{xCenter:.5*M.width,yCenter:.5*M.height,width:M.width,height:M.height,rotation:0}}(_,n),F=function(M,V,P){if(P===void 0&&(P=!1),!P)return{top:0,left:0,right:0,bottom:0};var re=V.height,ie=V.width;Bv(V,"targetSize"),Bv(M,"roi");var me,ge,ve=re/ie,$e=M.height/M.width,fe=0,xe=0;return ve>$e?(me=M.width,ge=M.width*ve,xe=(1-$e/ve)/2):(me=M.height/ve,ge=M.height,fe=(1-ve/$e)/2),M.width=me,M.height=ge,{top:xe,left:fe,right:fe,bottom:xe}}(O,S,$),B=(r=O,s=_.width,o=_.height,i=!1,a=r.width,l=r.height,c=i?-1:1,d=Math.cos(r.rotation),f=Math.sin(r.rotation),p=r.xCenter,g=r.yCenter,y=1/s,x=1/o,(w=new Array(16))[0]=a*d*c*y,w[1]=-l*f*y,w[2]=0,w[3]=(-.5*a*d*c+.5*l*f+p)*y,w[4]=a*f*c*x,w[5]=l*d*x,w[6]=0,w[7]=(-.5*l*d-.5*a*f*c+g)*x,w[8]=0,w[9]=0,w[10]=a*y,w[11]=0,w[12]=0,w[13]=0,w[14]=0,w[15]=1,qF(w));return{imageTensor:nt(function(){var M=UC(t),V=uo(XF(B,_,S),[1,8]),P=I==="zero"?"constant":"nearest",re=Tu.transform(_s(Qt(M,"float32")),V,"bilinear",P,0,[S.height,S.width]);return R!=null?YF(re,R):re}),padding:F,transformationMatrix:B}}function UN(t,e,n,r){return r===1?.5*(t+e):t+(e-t)*n/(r-1)}function Cke(t){return nt(function(){var e=function(s){return nt(function(){return[pt(s,[0,0,0],[1,-1,1]),pt(s,[0,0,1],[1,-1,-1])]})}(t),n=e[0],r=e[1];return{boxes:Gt(r),logits:Gt(n)}})}function QF(t){return t!=null&&t.currentTime!=null}function jN(t){for(var e={locationData:{relativeKeypoints:[]}},n=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,s=Number.MAX_SAFE_INTEGER,o=Number.MIN_SAFE_INTEGER,i=0;i<t.length;++i){var a=t[i];n=Math.min(n,a.x),r=Math.max(r,a.x),s=Math.min(s,a.y),o=Math.max(o,a.y),e.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return e.locationData.relativeBoundingBox={xMin:n,yMin:s,xMax:r,yMax:o,width:r-n,height:o-s},e}function $ke(t,e,n,r){return bt(this,void 0,void 0,function(){var s,o,i,a,l;return wt(this,function(c){switch(c.label){case 0:return t.sort(function(d,f){return Math.max.apply(Math,f.score)-Math.max.apply(Math,d.score)}),s=uo(t.map(function(d){return[d.locationData.relativeBoundingBox.yMin,d.locationData.relativeBoundingBox.xMin,d.locationData.relativeBoundingBox.yMax,d.locationData.relativeBoundingBox.xMax]})),o=lr(t.map(function(d){return d.score[0]})),[4,Tu.nonMaxSuppressionAsync(s,o,e,n)];case 1:return[4,(i=c.sent()).array()];case 2:return a=c.sent(),l=t.filter(function(d,f){return a.indexOf(f)>-1}),Mt([s,o,i]),[2,l]}})})}function ZF(t,e){return t.map(function(n){var r=Yt(Yt({},n),{x:n.x*e.width,y:n.y*e.height});return n.z!=null&&(r.z=n.z*e.width),r})}function kke(t,e,n){return bt(this,void 0,void 0,function(){var r,s,o,i,a,l,c,d,f,p,g,y,x,w,S,$,I,R,_,O,F,B,M,V;return wt(this,function(P){switch(P.label){case 0:if(r=Gt(e,[0]),s=r.shape,o=s[0],i=s[1],a=s[2],t.length!==a)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(t.length,", heatmap length: ").concat(a));return l=[],[4,r.buffer()];case 1:for(c=P.sent(),d=0;d<t.length;d++)if(f=t[d],p=Yt({},f),l.push(p),g=Math.trunc(p.x*i),y=Math.trunc(p.y*o),!(g<0||g>=i||y<0||g>=o)){for(x=Math.trunc((n.kernelSize-1)/2),w=Math.max(0,g-x),S=Math.min(i,g+x+1),$=Math.max(0,y-x),I=Math.min(o,y+x+1),R=0,_=0,O=0,F=0,B=$;B<I;++B)for(M=w;M<S;++M)V=c.get(B,M,d),R+=V,F=Math.max(F,V),_+=M*V,O+=B*V;F>=n.minConfidenceToRefine&&R>0&&(p.x=_/i/R,p.y=O/o/R)}return r.dispose(),[2,l]}})})}function GN(t,e){var n=e.left,r=e.top,s=e.left+e.right,o=e.top+e.bottom;return t.map(function(i){return Yt(Yt({},i),{x:(i.x-n)/(1-s),y:(i.y-r)/(1-o),z:i.z/(1-s)})})}function Tke(t,e,n){return mf()==="webgl"?function(r,s,o){var i=o.combineWithPreviousRatio.toFixed(2),a={variableNames:["prevMask","newMask"],outputShape:r.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `.concat(i,`);

      setOutput(outputValue);
    }
`)},l=ud();return nt(function(){var c=l.compileAndRun(a,[r,s]);return hs().makeTensorFromDataId(c.dataId,c.shape,c.dtype)})}(t,e,n):nt(function(){var r=ot(e,.5),s=lo(r),o=ot(1,wf(1,Te(s,We(5.68842,Te(s,We(-.748699,Te(s,We(-57.8051,Te(s,We(291.309,Te(s,-624.717)))))))))));return We(e,Te(ot(t,e),Te(o,n.combineWithPreviousRatio)))})}function Ike(t,e,n){return bt(this,void 0,void 0,function(){var r,s,o,i,a;return wt(this,function(l){switch(l.label){case 0:return r=t[0],s=t[1],o=function(c,d,f){return nt(function(){var p,g,y,x;f.reverseOutputOrder?(g=Gt(pt(c,[0,f.boxCoordOffset+0],[-1,1])),p=Gt(pt(c,[0,f.boxCoordOffset+1],[-1,1])),x=Gt(pt(c,[0,f.boxCoordOffset+2],[-1,1])),y=Gt(pt(c,[0,f.boxCoordOffset+3],[-1,1]))):(p=Gt(pt(c,[0,f.boxCoordOffset+0],[-1,1])),g=Gt(pt(c,[0,f.boxCoordOffset+1],[-1,1])),y=Gt(pt(c,[0,f.boxCoordOffset+2],[-1,1])),x=Gt(pt(c,[0,f.boxCoordOffset+3],[-1,1]))),g=We(Te(gt(g,f.xScale),d.w),d.x),p=We(Te(gt(p,f.yScale),d.h),d.y),f.applyExponentialOnBoxSize?(y=Te(ga(gt(y,f.hScale)),d.h),x=Te(ga(gt(x,f.wScale)),d.w)):(y=Te(gt(y,f.hScale),d.h),x=Te(gt(x,f.wScale),d.h));var w=ot(p,gt(y,2)),S=ot(g,gt(x,2)),$=We(p,gt(y,2)),I=We(g,gt(x,2)),R=Fn([ye(w,[f.numBoxes,1]),ye(S,[f.numBoxes,1]),ye($,[f.numBoxes,1]),ye(I,[f.numBoxes,1])],1);if(f.numKeypoints)for(var _=0;_<f.numKeypoints;++_){var O=f.keypointCoordOffset+_*f.numValuesPerKeypoint,F=void 0,B=void 0;f.reverseOutputOrder?(F=Gt(pt(c,[0,O],[-1,1])),B=Gt(pt(c,[0,O+1],[-1,1]))):(B=Gt(pt(c,[0,O],[-1,1])),F=Gt(pt(c,[0,O+1],[-1,1])));var M=We(Te(gt(F,f.xScale),d.w),d.x),V=We(Te(gt(B,f.yScale),d.h),d.y);R=Fn([R,ye(M,[f.numBoxes,1]),ye(V,[f.numBoxes,1])],1)}return R})}(s,e,n),i=nt(function(){var c=r;return n.sigmoidScore?(n.scoreClippingThresh!=null&&(c=nD(r,-n.scoreClippingThresh,n.scoreClippingThresh)),c=aa(c)):c}),[4,Nke(o,i,n)];case 1:return a=l.sent(),Mt([o,i]),[2,a]}})})}function Nke(t,e,n){return bt(this,void 0,void 0,function(){var r,s,o,i,a,l,c,d,f,p,g,y;return wt(this,function(x){switch(x.label){case 0:return r=[],[4,t.data()];case 1:return s=x.sent(),[4,e.data()];case 2:for(o=x.sent(),i=0;i<n.numBoxes;++i)if(!(n.minScoreThresh!=null&&o[i]<n.minScoreThresh||(a=i*n.numCoords,l=Eke(s[a+0],s[a+1],s[a+2],s[a+3],o[i],n.flipVertically,i),(c=l.locationData.relativeBoundingBox).width<0||c.height<0))){if(n.numKeypoints>0)for((d=l.locationData).relativeKeypoints=[],f=n.numKeypoints*n.numValuesPerKeypoint,p=0;p<f;p+=n.numValuesPerKeypoint)g=a+n.keypointCoordOffset+p,y={x:s[g+0],y:n.flipVertically?1-s[g+1]:s[g+1]},d.relativeKeypoints.push(y);r.push(l)}return[2,r]}})})}function Eke(t,e,n,r,s,o,i){return{score:[s],ind:i,locationData:{relativeBoundingBox:{xMin:e,yMin:o?1-n:t,xMax:r,yMax:o?1-t:n,width:r-e,height:n-t}}}}function Rke(t,e){return t==="none"?e:function(n){return 1/(1+Math.exp(-n))}(e)}function HN(t,e,n,r){return bt(this,void 0,void 0,function(){var s,o,i,a,l,c,d,f;return wt(this,function(p){switch(p.label){case 0:return n=n||e.flipHorizontally||!1,r=r||e.flipVertically||!1,s=t.size,o=s/e.numLandmarks,[4,t.data()];case 1:for(i=p.sent(),a=[],l=0;l<e.numLandmarks;++l)c=l*o,(f={x:0,y:0}).x=n?e.inputImageWidth-i[c]:i[c],o>1&&(f.y=r?e.inputImageHeight-i[c+1]:i[c+1]),o>2&&(f.z=i[c+2]),o>3&&(f.score=Rke(e.visibilityActivation,i[c+3])),a.push(f);for(d=0;d<a.length;++d)(f=a[d]).x=f.x/e.inputImageWidth,f.y=f.y/e.inputImageHeight,f.z=f.z/e.inputImageWidth/(e.normalizeZ||1);return[2,a]}})})}function KN(t,e,n){var r=t.width,s=t.height,o=t.rotation;if(n.rotation==null&&n.rotationDegree==null||(o=function(c,d){return d.rotation!=null?c+=d.rotation:d.rotationDegree!=null&&(c+=Math.PI*d.rotationDegree/180),KF(c)}(o,n)),o===0)t.xCenter=t.xCenter+r*n.shiftX,t.yCenter=t.yCenter+s*n.shiftY;else{var i=(e.width*r*n.shiftX*Math.cos(o)-e.height*s*n.shiftY*Math.sin(o))/e.width,a=(e.width*r*n.shiftX*Math.sin(o)+e.height*s*n.shiftY*Math.cos(o))/e.height;t.xCenter=t.xCenter+i,t.yCenter=t.yCenter+a}{var l=Math.max(r*e.width,s*e.height);r=l/e.width,s=l/e.height}return t.width=r*n.scaleX,t.height=s*n.scaleY,t}function _ke(t,e){return t.map(function(n){var r=Yt(Yt({},n),{x:n.x/e.width,y:n.y/e.height});return n.z!=null&&(n.z=n.z/e.width),r})}var cl=function(){function t(e){this.alpha=e,this.initialized=!1}return t.prototype.apply=function(e,n){var r;return this.initialized?r=n==null?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*n*Math.asinh((e-this.storedValue)/n):(r=e,this.initialized=!0),this.rawValue=e,this.storedValue=r,r},t.prototype.applyWithAlpha=function(e,n,r){return this.alpha=n,this.apply(e,r)},t.prototype.hasLastRawValue=function(){return this.initialized},t.prototype.lastRawValue=function(){return this.rawValue},t.prototype.reset=function(){this.initialized=!1},t}(),ax=function(){function t(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new cl(this.getAlpha(this.minCutOff)),this.dx=new cl(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return t.prototype.apply=function(e,n,r){if(e==null)return e;var s=Math.trunc(n);if(this.lastTimestamp>=s)return e;this.lastTimestamp!==0&&s!==0&&(this.frequency=1/(1e-6*(s-this.lastTimestamp))),this.lastTimestamp=s;var o=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*r*this.frequency:0,i=this.dx.applyWithAlpha(o,this.getAlpha(this.derivateCutOff)),a=this.minCutOff+this.beta*Math.abs(i),l=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(i):null;return this.x.applyWithAlpha(e,this.getAlpha(a),l)},t.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},t}(),Vv=function(){function t(e){this.config=e}return t.prototype.apply=function(e,n,r){var s=this;if(e==null)return this.reset(),null;this.initializeFiltersIfEmpty(e);var o=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return wu([],e,!0);o=1/r}return e.map(function(i,a){var l=Yt(Yt({},i),{x:s.xFilters[a].apply(i.x,n,o),y:s.yFilters[a].apply(i.y,n,o)});return i.z!=null&&(l.z=s.zFilters[a].apply(i.z,n,o)),l})},t.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},t.prototype.initializeFiltersIfEmpty=function(e){var n=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new ax(n.config)}),this.yFilters=e.map(function(r){return new ax(n.config)}),this.zFilters=e.map(function(r){return new ax(n.config)}))},t}(),lx=function(){function t(e){this.config=e,this.window=[],this.lowPassFilter=new cl(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return t.prototype.apply=function(e,n,r){if(e==null)return e;var s,o=Math.trunc(n);if(this.lastTimestamp>=o)return e;if(this.lastTimestamp===-1)s=1;else{for(var i=e*r-this.lastValue*this.lastValueScale,a=o-this.lastTimestamp,l=i,c=a,d=(1+this.window.length)*(1e6/30),f=0,p=this.window;f<p.length;f++){var g=p[f];if(c+g.duration>d)break;l+=g.distance,c+=g.duration}var y=l/(1e-6*c);s=1-1/(1+this.config.velocityScale*Math.abs(y)),this.window.unshift({distance:i,duration:a}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=r,this.lastTimestamp=o,this.lowPassFilter.applyWithAlpha(e,s)},t}(),Pke=function(){function t(e){this.config=e}return t.prototype.apply=function(e,n,r){var s=this;if(e==null)return this.reset(),null;var o=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return wu([],e,!0);o=1/r}return this.initializeFiltersIfEmpty(e),e.map(function(i,a){var l=Yt(Yt({},i),{x:s.xFilters[a].apply(i.x,n,o),y:s.yFilters[a].apply(i.y,n,o)});return i.z!=null&&(l.z=s.zFilters[a].apply(i.z,n,o)),l})},t.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},t.prototype.initializeFiltersIfEmpty=function(e){var n=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new lx(n.config)}),this.yFilters=e.map(function(r){return new lx(n.config)}),this.zFilters=e.map(function(r){return new lx(n.config)}))},t}(),ux=function(){function t(e){if(e.velocityFilter!=null)this.keypointsFilter=new Pke(e.velocityFilter);else{if(e.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(e,"."));this.keypointsFilter=new Vv(e.oneEuroFilter)}}return t.prototype.apply=function(e,n,r,s,o){if(s===void 0&&(s=!1),e==null)return this.keypointsFilter.reset(),null;var i=o!=null?function(c,d){return(c.width*d.width+c.height*d.height)/2}(o,r):1,a=s?ZF(e,r):e,l=this.keypointsFilter.apply(a,n,i);return s?_ke(l,r):l},t}(),XN=function(){function t(e){this.alpha=e.alpha}return t.prototype.apply=function(e){var n=this;if(e==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map(function(a){return new cl(n.alpha)}));for(var r=[],s=0;s<e.length;++s){var o=e[s],i=Yt({},o);i.score=this.visibilityFilters[s].apply(o.score),r.push(i)}return r},t}(),Ake={interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},Nc={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},Dke={maxPoses:1,flipHorizontal:!1},Oke={applyExponentialOnBoxSize:!1,flipVertically:!1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},Fke=.3,qN={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25},Lke={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},zke={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},Bke={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},Mke={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},Vke={kernelSize:7,minConfidenceToRefine:.5},YN={alpha:.1},Wke={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},Uke={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},jke={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},Gke={activation:"none"},Hke={combineWithPreviousRatio:.7},Kke=function(){function t(e){this.mask=e}return t.prototype.toCanvasImageSource=function(){return bt(this,void 0,void 0,function(){return wt(this,function(e){return[2,jF(this.mask)]})})},t.prototype.toImageData=function(){return bt(this,void 0,void 0,function(){return wt(this,function(e){return[2,GF(this.mask)]})})},t.prototype.toTensor=function(){return bt(this,void 0,void 0,function(){return wt(this,function(e){return[2,this.mask]})})},t.prototype.getUnderlyingType=function(){return"tensor"},t}();function Xke(t){return HF(t),"person"}var qke=function(){function t(e,n,r,s,o,i){this.detectorModel=e,this.landmarkModel=n,this.enableSmoothing=r,this.enableSegmentation=s,this.smoothSegmentation=o,this.modelType=i,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(f){f.reduceBoxesInLowestLayer==null&&(f.reduceBoxesInLowestLayer=!1),f.interpolatedScaleAspectRatio==null&&(f.interpolatedScaleAspectRatio=1),f.fixedAnchorSize==null&&(f.fixedAnchorSize=!1);for(var p=[],g=0;g<f.numLayers;){for(var y=[],x=[],w=[],S=[],$=g;$<f.strides.length&&f.strides[$]===f.strides[g];){var I=UN(f.minScale,f.maxScale,$,f.strides.length);if($===0&&f.reduceBoxesInLowestLayer)w.push(1),w.push(2),w.push(.5),S.push(.1),S.push(I),S.push(I);else{for(var R=0;R<f.aspectRatios.length;++R)w.push(f.aspectRatios[R]),S.push(I);if(f.interpolatedScaleAspectRatio>0){var _=$===f.strides.length-1?1:UN(f.minScale,f.maxScale,$+1,f.strides.length);S.push(Math.sqrt(I*_)),w.push(f.interpolatedScaleAspectRatio)}}$++}for(var O=0;O<w.length;++O){var F=Math.sqrt(w[O]);y.push(S[O]/F),x.push(S[O]*F)}var B=0,M=0;if(f.featureMapHeight.length>0)B=f.featureMapHeight[g],M=f.featureMapWidth[g];else{var V=f.strides[g];B=Math.ceil(f.inputSizeHeight/V),M=Math.ceil(f.inputSizeWidth/V)}for(var P=0;P<B;++P)for(var re=0;re<M;++re)for(var ie=0;ie<y.length;++ie){var me={xCenter:(re+f.anchorOffsetX)/M,yCenter:(P+f.anchorOffsetY)/B,width:0,height:0};f.fixedAnchorSize?(me.width=1,me.height=1):(me.width=x[ie],me.height=y[ie]),p.push(me)}g=$}return p}(Ake);var a=lr(this.anchors.map(function(f){return f.width})),l=lr(this.anchors.map(function(f){return f.height})),c=lr(this.anchors.map(function(f){return f.xCenter})),d=lr(this.anchors.map(function(f){return f.yCenter}));this.anchorTensor={x:c,y:d,w:a,h:l},this.prevFilteredSegmentationMask=this.enableSegmentation?uo([],[0,0]):null}return t.prototype.estimatePoses=function(e,n,r){return bt(this,void 0,void 0,function(){var s,o,i,a,l,c,d,f,p,g,y,x,w,S,$,I,R,_,O,F,B,M,V;return wt(this,function(P){switch(P.label){case 0:return s=function(re){var ie;if((ie=re==null?Dke:Yt({},re)).maxPoses==null&&(ie.maxPoses=1),ie.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(ie.maxPoses,". Should be > 0."));if(ie.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return ie}(n),e==null?(this.reset(),[2,[]]):(this.maxPoses=s.maxPoses,this.timestamp=r!=null?1e3*r:QF(e)?1e6*e.currentTime:null,o=md(e),i=nt(function(){return Qt(UC(e),"float32")}),(a=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(i)]);case 1:if((l=P.sent()).length===0)return this.reset(),i.dispose(),[2,[]];c=l[0],a=this.poseDetectionToRoi(c,o),P.label=2;case 2:return[4,this.poseLandmarksByRoi(a,i)];case 3:return d=P.sent(),i.dispose(),d==null?(this.reset(),[2,[]]):(f=d.landmarks,p=d.auxiliaryLandmarks,g=d.poseScore,y=d.worldLandmarks,x=d.segmentationMask,w=this.poseLandmarkFiltering(f,p,y,o),S=w.actualLandmarksFiltered,$=w.auxiliaryLandmarksFiltered,I=w.actualWorldLandmarksFiltered,R=this.poseLandmarksToRoi($,o),this.regionOfInterest=R,_=this.smoothSegmentation&&x!=null?this.poseSegmentationFiltering(x):x,(O=S!=null?ZF(S,o):null)!=null&&O.forEach(function(re,ie){re.name=Pf[ie]}),(F=I)!=null&&F.forEach(function(re,ie){re.name=Pf[ie]}),B={score:g,keypoints:O,keypoints3D:F},_!==null&&(M=nt(function(){var re=_s(_,2),ie=vl(re,[[0,0],[0,0],[0,1]]);return wD(ie,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||Mt(_),V={maskValueToLabel:Xke,mask:new Kke(M)},B.segmentation=V),[2,[B]])}})})},t.prototype.poseSegmentationFiltering=function(e){var n=this.prevFilteredSegmentationMask;return n.size===0?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=Tke(n,e,Hke),Mt(e)),Mt(n),this.prevFilteredSegmentationMask},t.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),Mt([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},t.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(Mt(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=uo([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},t.prototype.detectPose=function(e){return bt(this,void 0,void 0,function(){var n,r,s,o,i,a,l,c,d,f;return wt(this,function(p){switch(p.label){case 0:return n=Mv(e,Lke),r=n.imageTensor,s=n.padding,o=this.detectorModel.predict(r),i=Cke(o),a=i.boxes,[4,Ike([l=i.logits,a],this.anchorTensor,Oke)];case 1:return(c=p.sent()).length===0?(Mt([r,o,l,a]),[2,c]):[4,$ke(c,this.maxPoses,Fke)];case 2:return d=p.sent(),f=function(g,y){g===void 0&&(g=[]);for(var x=y.left,w=y.top,S=y.left+y.right,$=y.top+y.bottom,I=0;I<g.length;I++){var R=g[I],_=R.locationData.relativeBoundingBox,O=(_.xMin-x)/(1-S),F=(_.yMin-w)/(1-$),B=_.width/(1-S),M=_.height/(1-$);_.xMin=O,_.yMin=F,_.width=B,_.height=M,_.xMax=O+B,_.yMax=F+M;var V=R.locationData.relativeKeypoints;V&&V.forEach(function(P){var re=(P.x-x)/(1-S),ie=(P.y-w)/(1-$);P.x=re,P.y=ie})}return g}(d,s),Mt([r,o,l,a]),[2,f]}})})},t.prototype.poseDetectionToRoi=function(e,n){return KN(ox(e,n,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),n,qN)},t.prototype.poseLandmarksByRoi=function(e,n){return bt(this,void 0,void 0,function(){var r,s,o,i,a,l,c,d,f,p,g,y,x,w;return wt(this,function(S){switch(S.label){case 0:if(r=md(n),s=Mv(n,zke,e),o=s.imageTensor,i=s.padding,a=s.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return l=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&l.push("activation_segmentation"),c=this.landmarkModel.execute(o,l),[4,this.tensorsToPoseLandmarksAndSegmentation(c)];case 1:return(d=S.sent())==null?(Mt(c),Mt(o),[2,null]):(f=d.landmarks,p=d.auxiliaryLandmarks,g=d.poseScore,y=d.worldLandmarks,x=d.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(r,e,i,a,f,p,y,x)]);case 2:return w=S.sent(),Mt(c),Mt(o),[2,Yt({poseScore:g},w)]}})})},t.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,n,r,s,o,i,a,l){return bt(this,void 0,void 0,function(){var c,d,f,p,g,y;return wt(this,function(x){return c=GN(o,r),d=GN(i,r),f=WN(c,n),p=WN(d,n),g=function(w,S){for(var $=[],I=0,R=w;I<R.length;I++){var _=R[I],O=_.x,F=_.y,B=S.rotation,M=Math.cos(B)*O-Math.sin(B)*F,V=Math.sin(B)*O+Math.cos(B)*F,P=Yt({},_);P.x=M,P.y=V,$.push(P)}return $}(a,n),y=null,this.enableSegmentation&&(y=nt(function(){var w=l.shape,S=w[0],$=w[1],I=function(O){var F=qF(new Array(16).fill(0));F[0][0]=vr(O,0,0),F[1][0]=-vr(O,0,1),F[2][0]=vr(O,0,2),F[3][0]=-vr(O,0,3),F[0][2]=vr(O,2,0),F[1][2]=-vr(O,2,1),F[2][2]=vr(O,2,2),F[3][2]=-vr(O,2,3),F[0][1]=-vr(O,1,0),F[1][1]=vr(O,1,1),F[2][1]=-vr(O,1,2),F[3][1]=vr(O,1,3),F[0][3]=-vr(O,3,0),F[1][3]=vr(O,3,1),F[2][3]=-vr(O,3,2),F[3][3]=vr(O,3,3);for(var B=O[0][0]*F[0][0]+O[1][0]*F[0][1]+O[2][0]*F[0][2]+O[3][0]*F[0][3],M=0;M<F.length;M++)for(var V=0;V<F.length;V++)F[M][V]/=B;return F}(s),R=uo(XF(I,{width:$,height:S},e),[1,8]),_=[1,S,$,1];return Gt(Tu.transform(ye(l,_),R,"bilinear","constant",0,[e.height,e.width]),[0,3])}),Mt(l)),[2,{landmarks:f,auxiliaryLandmarks:p,worldLandmarks:g,segmentationMask:y}]})})},t.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return bt(this,void 0,void 0,function(){var n,r,s,o,i,a,l,c,d,f,p,g,y;return wt(this,function(x){switch(x.label){case 0:return n=e[0],r=e[1],s=e[2],o=e[3],i=this.enableSegmentation?e[4]:null,[4,r.data()];case 1:return(a=x.sent()[0])<.5?[2,null]:[4,HN(n,Bke)];case 2:return[4,kke(x.sent(),s,Vke)];case 3:return l=x.sent(),c=l.slice(0,33),d=l.slice(33,35),[4,HN(o,Mke)];case 4:return f=x.sent(),p=f.slice(0,33),g=function(w,S,$){for(var I=[],R=0;R<w.length;R++){var _=Yt({},S[R]);_.score=w[R].score,I.push(_)}return I}(c,p),y=this.enableSegmentation?function(w,S,$){return nt(function(){var I=Gt(w,[0]),R=I.shape[2];if(R===1){var _=I;switch(S.activation){case"none":break;case"sigmoid":_=aa(_);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(S.activation,")"))}var O=_;return Gt(O,[2])}throw new Error("Unsupported number of tensor channels ".concat(R))})}(i,Gke):null,[2,{landmarks:c,auxiliaryLandmarks:d,poseScore:a,worldLandmarks:g,segmentationMask:y}]}})})},t.prototype.poseLandmarksToRoi=function(e,n){return KN(ox(jN(e),n,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),n,qN)},t.prototype.poseLandmarkFiltering=function(e,n,r,s){var o,i,a;if(this.timestamp!=null&&this.enableSmoothing){var l=ox(jN(n),s,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new XN(YN)),o=this.visibilitySmoothingFilterActual.apply(e),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new XN(YN)),i=this.visibilitySmoothingFilterAuxiliary.apply(n),a=this.visibilitySmoothingFilterActual.apply(r),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new ux(Wke)),o=this.landmarksSmoothingFilterActual.apply(o,this.timestamp,s,!0,l),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new ux(Uke)),i=this.landmarksSmoothingFilterAuxiliary.apply(i,this.timestamp,s,!0,l),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new ux(jke)),a=this.worldLandmarksSmoothingFilterActual.apply(r,this.timestamp)}else o=e,i=n,a=r;return{actualLandmarksFiltered:o,auxiliaryLandmarksFiltered:i,actualWorldLandmarksFiltered:a}},t}();function Yke(t){return bt(this,void 0,void 0,function(){var e,n,r,s,o,i;return wt(this,function(a){switch(a.label){case 0:return e=function(l){var c=Yt({},l??Nc);if(c.enableSmoothing==null&&(c.enableSmoothing=Nc.enableSmoothing),c.enableSegmentation==null&&(c.enableSegmentation=Nc.enableSegmentation),c.smoothSegmentation==null&&(c.smoothSegmentation=Nc.smoothSegmentation),c.modelType==null&&(c.modelType=Nc.modelType),c.detectorModelUrl==null&&(c.detectorModelUrl=Nc.detectorModelUrl),c.landmarkModelUrl==null)switch(c.modelType){case"lite":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return c}(t),n=typeof e.detectorModelUrl=="string"&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,r=typeof e.landmarkModelUrl=="string"&&e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([fd(e.detectorModelUrl,{fromTFHub:n}),fd(e.landmarkModelUrl,{fromTFHub:r})])];case 1:return s=a.sent(),o=s[0],i=s[1],[2,new qke(o,i,e.enableSmoothing,e.enableSegmentation,e.smoothSegmentation,e.modelType)]}})})}var Nu,wi,JF=function(){function t(e){(function(n){if(n.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(n.maxTracks));if(n.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(n.maxAge));if(n.keypointTrackerParams!==void 0){if(n.keypointTrackerParams.keypointConfidenceThreshold<0||n.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(n.keypointTrackerParams.keypointConfidenceThreshold));if(n.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(n.keypointTrackerParams.minNumberOfKeypoints));for(var r=0,s=n.keypointTrackerParams.keypointFalloff;r<s.length;r++){var o=s[r];if(o<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(o))}}})(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return t.prototype.apply=function(e,n){this.filterOldTracks(n);var r=this.computeSimilarity(e);return this.assignTracks(e,r,n),this.updateTracks(n),e},t.prototype.getTracks=function(){return this.tracks.slice()},t.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(e){return e.id}))},t.prototype.filterOldTracks=function(e){var n=this;this.tracks=this.tracks.filter(function(r){return e-r.lastTimestamp<=n.maxAge})},t.prototype.assignTracks=function(e,n,r){for(var s=Array.from(Array(n[0].length).keys()),o=[],i=0,a=Array.from(Array(e.length).keys());i<a.length;i++){var l=a[i];if(s.length!==0){for(var c=-1,d=-1,f=0,p=s;f<p.length;f++){var g=p[f],y=n[l][g];y>=this.minSimilarity&&y>d&&(c=g,d=y)}if(c>=0){var x=this.tracks[c];x=Object.assign(x,this.createTrack(e[l],r,x.id)),e[l].id=x.id;var w=s.indexOf(c);s.splice(w,1)}else o.push(l)}else o.push(l)}for(var S=0,$=o;S<$.length;S++){l=$[S];var I=this.createTrack(e[l],r);this.tracks.push(I),e[l].id=I.id}},t.prototype.updateTracks=function(e){this.tracks.sort(function(n,r){return r.lastTimestamp-n.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},t.prototype.createTrack=function(e,n,r){var s={id:r||this.nextTrackID(),lastTimestamp:n,keypoints:wu([],e.keypoints,!0).map(function(o){return Yt({},o)})};return e.box!==void 0&&(s.box=Yt({},e.box)),s},t.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},t.prototype.remove=function(){for(var e=[],n=0;n<arguments.length;n++)e[n]=arguments[n];this.tracks=this.tracks.filter(function(r){return!e.includes(r.id)})},t.prototype.reset=function(){this.tracks=[]},t}(),Qke=function(t){function e(n){return t.call(this,n)||this}return UF(e,t),e.prototype.computeSimilarity=function(n){var r=this;return n.length===0||this.tracks.length===0?[[]]:n.map(function(s){return r.tracks.map(function(o){return r.iou(s,o)})})},e.prototype.iou=function(n,r){var s=Math.max(n.box.xMin,r.box.xMin),o=Math.max(n.box.yMin,r.box.yMin),i=Math.min(n.box.xMax,r.box.xMax),a=Math.min(n.box.yMax,r.box.yMax);if(s>=i||o>=a)return 0;var l=(i-s)*(a-o);return l/(n.box.width*n.box.height+r.box.width*r.box.height-l)},e}(JF),Zke=function(t){function e(n){var r=t.call(this,n)||this;return r.keypointThreshold=n.keypointTrackerParams.keypointConfidenceThreshold,r.keypointFalloff=n.keypointTrackerParams.keypointFalloff,r.minNumKeyoints=n.keypointTrackerParams.minNumberOfKeypoints,r}return UF(e,t),e.prototype.computeSimilarity=function(n){if(n.length===0||this.tracks.length===0)return[[]];for(var r=[],s=0,o=n;s<o.length;s++){for(var i=o[s],a=[],l=0,c=this.tracks;l<c.length;l++){var d=c[l];a.push(this.oks(i,d))}r.push(a)}return r},e.prototype.oks=function(n,r){for(var s=this.area(r.keypoints)+1e-6,o=0,i=0,a=0;a<n.keypoints.length;++a){var l=n.keypoints[a],c=r.keypoints[a];if(!(l.score<this.keypointThreshold||c.score<this.keypointThreshold)){i+=1;var d=Math.pow(l.x-c.x,2)+Math.pow(l.y-c.y,2),f=2*this.keypointFalloff[a];o+=Math.exp(-1*d/(2*s*Math.pow(f,2)))}}return i<this.minNumKeyoints?0:o/i},e.prototype.area=function(n){var r=this,s=n.filter(function(l){return l.score>r.keypointThreshold}),o=Math.min.apply(Math,wu([1],s.map(function(l){return l.x}),!1)),i=Math.max.apply(Math,wu([0],s.map(function(l){return l.x}),!1)),a=Math.min.apply(Math,wu([1],s.map(function(l){return l.y}),!1));return(i-o)*(Math.max.apply(Math,wu([0],s.map(function(l){return l.y}),!1))-a)},e}(JF);function Jke(t){switch(t){case wi.BlazePose:return Pf.reduce(function(e,n,r){return e[n]=r,e},{});case wi.PoseNet:case wi.MoveNet:return $i.reduce(function(e,n,r){return e[n]=r,e},{});default:throw new Error("Model ".concat(t," is not supported."))}}(function(t){t.Keypoint="keypoint",t.BoundingBox="boundingBox"})(Nu||(Nu={})),function(t){t.MoveNet="MoveNet",t.BlazePose="BlazePose",t.PoseNet="PoseNet"}(wi||(wi={}));var QN=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],e4={modelType:"SinglePose.Lightning",enableSmoothing:!0},ZN={},JN={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},cx={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},eE={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function eTe(t,e,n,r){for(var s={},o=0,i=$i;o<i.length;o++){var a=i[o];s[a]=[e[n[a]].y*r.height,e[n[a]].x*r.width]}if(function($,I){return($[I.left_hip].score>.2||$[I.right_hip].score>.2)&&($[I.left_shoulder].score>.2||$[I.right_shoulder].score>.2)}(e,n)){var l=(s.left_hip[0]+s.right_hip[0])/2,c=(s.left_hip[1]+s.right_hip[1])/2,d=function($,I,R,_,O){for(var F=["left_shoulder","right_shoulder","left_hip","right_hip"],B=0,M=0,V=0;V<F.length;V++)(ge=Math.abs(_-R[F[V]][0]))>B&&(B=ge),(ve=Math.abs(O-R[F[V]][1]))>M&&(M=ve);for(var P=0,re=0,ie=0,me=Object.keys(R);ie<me.length;ie++){var ge,ve,$e=me[ie];$[I[$e]].score<.2||((ge=Math.abs(_-R[$e][0]))>P&&(P=ge),(ve=Math.abs(O-R[$e][1]))>re&&(re=ve))}return[B,M,P,re]}(e,n,s,l,c),f=d[0],p=d[1],g=d[2],y=d[3],x=Math.max(1.9*p,1.9*f,1.2*g,1.2*y),w=[l-(x=Math.min(x,Math.max(c,r.width-c,l,r.height-l))),c-x];if(x>Math.max(r.width,r.height)/2)return Wv(t==null,r);var S=2*x;return{yMin:w[0]/r.height,xMin:w[1]/r.width,yMax:(w[0]+S)/r.height,xMax:(w[1]+S)/r.width,height:(w[0]+S)/r.height-w[0]/r.height,width:(w[1]+S)/r.width-w[1]/r.width}}return Wv(t==null,r)}function Wv(t,e){var n,r,s,o;return t?e.width>e.height?(n=1,r=e.height/e.width,s=0,o=(e.width/2-e.height/2)/e.width):(n=e.width/e.height,r=1,s=(e.height/2-e.width/2)/e.height,o=0):e.width>e.height?(n=e.width/e.height,r=1,s=(e.height/2-e.width/2)/e.height,o=0):(n=1,r=e.height/e.width,s=0,o=(e.width/2-e.height/2)/e.width),{yMin:s,xMin:o,yMax:s+n,xMax:o+r,height:n,width:r}}function tTe(t){var e,n=t==null?e4:Yt({},t);if(n.modelType==null)n.modelType="SinglePose.Lightning";else if(QN.indexOf(n.modelType)<0)throw new Error("Invalid architecture ".concat(n.modelType,". ")+"Should be one of ".concat(QN));if(n.enableSmoothing==null&&(n.enableSmoothing=!0),n.minPoseScore!=null&&(n.minPoseScore<0||n.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(n.multiPoseMaxDimension!=null&&(n.multiPoseMaxDimension%32!=0||n.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(n.modelType==="MultiPose.Lightning"&&n.enableTracking==null&&(n.enableTracking=!0),n.modelType==="MultiPose.Lightning"&&n.enableTracking===!0)if(n.trackerType==null&&(n.trackerType=Nu.BoundingBox),n.trackerType===Nu.Keypoint)n.trackerConfig!=null?n.trackerConfig=function(r){var s=tE(cx,r);return s.keypointTrackerParams=Yt({},cx.keypointTrackerParams),r.keypointTrackerParams!=null&&(r.keypointTrackerParams.keypointConfidenceThreshold!=null&&(s.keypointTrackerParams.keypointConfidenceThreshold=r.keypointTrackerParams.keypointConfidenceThreshold),r.keypointTrackerParams.keypointFalloff!=null&&(s.keypointTrackerParams.keypointFalloff=r.keypointTrackerParams.keypointFalloff),r.keypointTrackerParams.minNumberOfKeypoints!=null&&(s.keypointTrackerParams.minNumberOfKeypoints=r.keypointTrackerParams.minNumberOfKeypoints)),s}(n.trackerConfig):n.trackerConfig=cx;else{if(n.trackerType!==Nu.BoundingBox)throw new Error("Tracker type not supported by MoveNet");n.trackerConfig!=null?n.trackerConfig=(e=n.trackerConfig,tE(eE,e)):n.trackerConfig=eE}return n}function tE(t,e){var n={maxTracks:t.maxTracks,maxAge:t.maxAge,minSimilarity:t.minSimilarity};return e.maxTracks!=null&&(n.maxTracks=e.maxTracks),e.maxAge!=null&&(n.maxAge=e.maxAge),e.minSimilarity!=null&&(n.minSimilarity=e.minSimilarity),n}var nTe=function(){function t(e,n){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=Jke(wi.MoveNet),n.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):n.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=n.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new Vv(JN),this.cropRegionFilterYMin=new cl(.9),this.cropRegionFilterXMin=new cl(.9),this.cropRegionFilterYMax=new cl(.9),this.cropRegionFilterXMax=new cl(.9)),this.enableSmoothing=n.enableSmoothing,n.minPoseScore?this.minPoseScore=n.minPoseScore:this.minPoseScore=.25,n.multiPoseMaxDimension?this.multiPoseMaxDimension=n.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=n.enableTracking,this.multiPoseModel&&this.enableTracking&&(n.trackerType===Nu.Keypoint?this.tracker=new Zke(n.trackerConfig):n.trackerType===Nu.BoundingBox&&(this.tracker=new Qke(n.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return t.prototype.runSinglePersonPoseModel=function(e){return bt(this,void 0,void 0,function(){var n,r,s,o,i;return wt(this,function(a){switch(a.label){case 0:if((n=this.moveNetModel.execute(e)).shape.length!==4||n.shape[0]!==1||n.shape[1]!==1||n.shape[2]!==17||n.shape[3]!==3)throw n.dispose(),new Error("Unexpected output shape from model: [".concat(n.shape,"]"));return mf()==="webgpu"?[3,1]:(r=n.dataSync(),[3,3]);case 1:return[4,n.data()];case 2:r=a.sent(),a.label=3;case 3:for(n.dispose(),s={keypoints:[],score:0},o=0,i=0;i<17;++i)s.keypoints[i]={y:r[3*i],x:r[3*i+1],score:r[3*i+2]},s.keypoints[i].score>.2&&(++o,s.score+=s.keypoints[i].score);return o>0&&(s.score/=o),[2,s]}})})},t.prototype.runMultiPersonPoseModel=function(e){return bt(this,void 0,void 0,function(){var n,r,s,o,i,a,l,c;return wt(this,function(d){switch(d.label){case 0:if((n=this.moveNetModel.execute(e)).shape.length!==3||n.shape[0]!==1||n.shape[2]!==56)throw n.dispose(),new Error("Unexpected output shape from model: [".concat(n.shape,"]"));return mf()==="webgpu"?[3,1]:(r=n.dataSync(),[3,3]);case 1:return[4,n.data()];case 2:r=d.sent(),d.label=3;case 3:for(n.dispose(),s=[],o=r.length/56,i=0;i<o;++i)for(s[i]={keypoints:[]},a=56*i+51,s[i].box={yMin:r[a],xMin:r[a+1],yMax:r[a+2],xMax:r[a+3],width:r[a+3]-r[a+1],height:r[a+2]-r[a]},l=56*i+55,s[i].score=r[l],s[i].keypoints=[],c=0;c<17;++c)s[i].keypoints[c]={y:r[56*i+3*c],x:r[56*i+3*c+1],score:r[56*i+3*c+2]};return[2,s]}})})},t.prototype.estimatePoses=function(e,n,r){return n===void 0&&(n=ZN),bt(this,void 0,void 0,function(){var s,o,i,a,l,c;return wt(this,function(d){switch(d.label){case 0:return n=function(f){return f==null?ZN:Yt({},f)}(n),e==null?(this.reset(),[2,[]]):(r==null?QF(e)&&(r=1e6*e.currentTime):r*=1e3,s=UC(e),o=md(s),i=_s(s,0),e instanceof fn||s.dispose(),a=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(i,o,r)]);case 1:return a=d.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(i,o,r)];case 3:a=d.sent(),d.label=4;case 4:for(l=0;l<a.length;++l)for(c=0;c<a[l].keypoints.length;++c)a[l].keypoints[c].name=$i[c],a[l].keypoints[c].y*=o.height,a[l].keypoints[c].x*=o.width;return[2,a]}})})},t.prototype.estimateSinglePose=function(e,n,r){return bt(this,void 0,void 0,function(){var s,o,i,a,l=this;return wt(this,function(c){switch(c.label){case 0:return this.cropRegion||(this.cropRegion=Wv(this.cropRegion==null,n)),s=nt(function(){var d=uo([[l.cropRegion.yMin,l.cropRegion.xMin,l.cropRegion.yMax,l.cropRegion.xMax]]),f=xa([1],"int32"),p=[l.modelInputResolution.height,l.modelInputResolution.width];return Qt(Tu.cropAndResize(e,d,f,p,"bilinear",0),"int32")}),e.dispose(),[4,this.runSinglePersonPoseModel(s)];case 1:if(o=c.sent(),s.dispose(),o.score<this.minPoseScore)return this.reset(),[2,[]];for(i=0;i<o.keypoints.length;++i)o.keypoints[i].y=this.cropRegion.yMin+o.keypoints[i].y*this.cropRegion.height,o.keypoints[i].x=this.cropRegion.xMin+o.keypoints[i].x*this.cropRegion.width;return r!=null&&this.enableSmoothing&&(o.keypoints=this.keypointFilter.apply(o.keypoints,r,1)),a=eTe(this.cropRegion,o.keypoints,this.keypointIndexByName,n),this.cropRegion=this.filterCropRegion(a),[2,[o]]}})})},t.prototype.estimateMultiplePoses=function(e,n,r){return bt(this,void 0,void 0,function(){var s,o,i,a,l,c,d,f,p,g,y,x=this;return wt(this,function(w){switch(w.label){case 0:return n.width>n.height?(o=this.multiPoseMaxDimension,i=Math.round(this.multiPoseMaxDimension*n.height/n.width),s=Tu.resizeBilinear(e,[i,o]),l=o,c=32*Math.ceil(i/32),a=vl(s,[[0,0],[0,c-i],[0,0],[0,0]])):(o=Math.round(this.multiPoseMaxDimension*n.width/n.height),i=this.multiPoseMaxDimension,s=Tu.resizeBilinear(e,[i,o]),l=32*Math.ceil(o/32),c=i,a=vl(s,[[0,0],[0,0],[0,l-o],[0,0]])),s.dispose(),e.dispose(),d=Qt(a,"int32"),a.dispose(),[4,this.runMultiPersonPoseModel(d)];case 1:for(f=w.sent(),d.dispose(),f=f.filter(function(S){return S.score>=x.minPoseScore}),g=0;g<f.length;++g)for(p=0;p<f[g].keypoints.length;++p)f[g].keypoints[p].y*=c/i,f[g].keypoints[p].x*=l/o;if(this.enableTracking&&(this.tracker.apply(f,r),this.enableSmoothing)){for(g=0;g<f.length;++g)this.keypointFilterMap.has(f[g].id)||this.keypointFilterMap.set(f[g].id,new Vv(JN)),f[g].keypoints=this.keypointFilterMap.get(f[g].id).apply(f[g].keypoints,r,1);y=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(S,$){y.has($)||x.keypointFilterMap.delete($)})}return[2,f]}})})},t.prototype.filterCropRegion=function(e){if(e){var n=this.cropRegionFilterYMin.apply(e.yMin),r=this.cropRegionFilterXMin.apply(e.xMin),s=this.cropRegionFilterYMax.apply(e.yMax),o=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:n,xMin:r,yMax:s,xMax:o,height:s-n,width:o-r}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},t.prototype.dispose=function(){this.moveNetModel.dispose()},t.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},t.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},t}();function rTe(t){return t===void 0&&(t=e4),bt(this,void 0,void 0,function(){var e,n,r,s;return wt(this,function(o){switch(o.label){case 0:return e=tTe(t),r=!0,e.modelUrl?(r=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,fd(e.modelUrl,{fromTFHub:r})]):[3,2];case 1:return n=o.sent(),[3,4];case 2:return s=void 0,e.modelType==="SinglePose.Lightning"?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":e.modelType==="SinglePose.Thunder"?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":e.modelType==="MultiPose.Lightning"&&(s="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,fd(s,{fromTFHub:r})];case 3:n=o.sent(),o.label=4;case 4:return mf()==="webgl"&&se().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new nTe(n,e)]}})})}var nE={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},rE=["MobileNetV1","ResNet50"],sE={MobileNetV1:[8,16],ResNet50:[16]},sTe=[8,16,32],oE={MobileNetV1:[.5,.75,1],ResNet50:[1]},iE=[1,2,4],aE={maxPoses:1,flipHorizontal:!1},oTe={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},iTe=[-123.15,-115.9,-103.06];function dx(t){return Math.floor(t/2)}var aTe=function(){function t(e,n){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=n}return t.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},t.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},t.prototype.empty=function(){return this.numberOfElements===-1},t.prototype.size=function(){return this.numberOfElements+1},t.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},t.prototype.max=function(){return this.priorityQueue[0]},t.prototype.swim=function(e){for(;e>0&&this.less(dx(e),e);)this.exchange(e,dx(e)),e=dx(e)},t.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var n=2*e;if(n<this.numberOfElements&&this.less(n,n+1)&&n++,!this.less(e,n))break;this.exchange(e,n),e=n}},t.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},t.prototype.less=function(e,n){return this.getValueAt(e)<this.getValueAt(n)},t.prototype.exchange=function(e,n){var r=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[n],this.priorityQueue[n]=r},t}();function lTe(t,e,n,r,s,o){for(var i=o.shape,a=i[0],l=i[1],c=!0,d=Math.max(n-s,0),f=Math.min(n+s+1,a),p=d;p<f;++p){for(var g=Math.max(r-s,0),y=Math.min(r+s+1,l),x=g;x<y;++x)if(o.get(p,x,t)>e){c=!1;break}if(!c)break}return c}function uTe(t){return bt(this,void 0,void 0,function(){return wt(this,function(e){return[2,Promise.all(t.map(function(n){return n.buffer()}))]})})}function t4(t,e,n,r){return{y:r.get(t,e,n),x:r.get(t,e,n+17)}}function n4(t,e,n){var r=t4(t.heatmapY,t.heatmapX,t.id,n),s=r.y,o=r.x;return{x:t.heatmapX*e+o,y:t.heatmapY*e+s}}function r4(t,e,n,r){var s=n.x,o=n.y;return t.some(function(i){var a,l,c,d,f,p,g=i.keypoints;return a=o,l=s,c=g[r].y,d=g[r].x,(f=c-a)*f+(p=d-l)*p<=e})}var lE=$i.reduce(function(t,e,n){return t[e]=n,t},{}),s4=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(t){var e=t[0],n=t[1];return[lE[e],lE[n]]}),hx=s4.map(function(t){return t[1]}),uE=s4.map(function(t){return t[0]});function cE(t,e,n){return t<e?e:t>n?n:t}function fx(t,e,n,r){return{y:cE(Math.round(t.y/e),0,n-1),x:cE(Math.round(t.x/e),0,r-1)}}function dE(t,e){return{x:t.x+e.x,y:t.y+e.y}}function hE(t,e,n,r,s,o,i,a){a===void 0&&(a=2);for(var l=r.shape,c=l[0],d=l[1],f={y:e.y,x:e.x},p=dE(f,function($,I,R){var _=R.shape[2]/2;return{y:R.get(I.y,I.x,$),x:R.get(I.y,I.x,_+$)}}(t,fx(f,o,c,d),i)),g=0;g<a;g++){var y=fx(p,o,c,d),x=t4(y.y,y.x,n,s);p=dE({x:y.x*o,y:y.y*o},{x:x.x,y:x.y})}var w=fx(p,o,c,d),S=r.get(w.y,w.x,n);return{y:p.y,x:p.x,name:$i[n],score:S}}function cTe(t,e,n,r,s,o){var i=e.shape[2],a=hx.length,l=new Array(i),c=t.part,d=t.score,f=n4(c,r,n);l[c.id]={score:d,name:$i[c.id],y:f.y,x:f.x};for(var p=a-1;p>=0;--p){var g=hx[p],y=uE[p];l[g]&&!l[y]&&(l[y]=hE(p,l[g],y,e,n,r,o))}for(p=0;p<a;++p)g=uE[p],y=hx[p],l[g]&&!l[y]&&(l[y]=hE(p,l[g],y,e,n,r,s));return l}function dTe(t,e,n){return n.reduce(function(r,s,o){var i=s.y,a=s.x,l=s.score;return r4(t,e,{y:i,x:a},o)||(r+=l),r},0)/n.length}function hTe(t,e,n,r,s,o,i,a){return i===void 0&&(i=.5),a===void 0&&(a=20),bt(this,void 0,void 0,function(){var l,c,d,f,p,g,y,x,w,S,$,I;return wt(this,function(R){switch(R.label){case 0:return[4,uTe([t,e,n,r])];case 1:for(l=R.sent(),c=l[0],d=l[1],f=l[2],p=l[3],g=[],y=function(_,O,F){for(var B=F.shape,M=B[0],V=B[1],P=B[2],re=new aTe(M*V*P,function($e){return $e.score}),ie=0;ie<M;++ie)for(var me=0;me<V;++me)for(var ge=0;ge<P;++ge){var ve=F.get(ie,me,ge);ve<_||lTe(ge,ve,ie,me,O,F)&&re.enqueue({score:ve,part:{heatmapY:ie,heatmapX:me,id:ge}})}return re}(i,1,c),x=a*a;g.length<o&&!y.empty();)w=y.dequeue(),S=n4(w.part,s,d),r4(g,x,S,w.part.id)||($=cTe(w,c,d,s,f,p),I=dTe(g,x,$),g.push({keypoints:$,score:I}));return[2,g]}})})}function o4(){for(var t,e=[],n=0;n<arguments.length;n++)e[n]=arguments[n];switch(e.length){case 0:t="fn main() ";break;case 1:t="fn main(".concat(e[0]," : i32)");break;default:throw Error("Unreachable")}return t}var fTe=function(){function t(e){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[e[0],1],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return t.prototype.getUserCode=function(){return`
        `.concat(o4("index"),` {
          if (index < uniforms.size) {
            let y = B[index * 2];
            let x = B[index * 2 + 1];
            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;
            result[index] = A[outIndex];
          }
        }
        `)},t}();function pTe(t,e){if(ud()instanceof Od)return function(n,r){var s=ud(),o=new fTe(r.shape),i=s.runWebGPUProgram(o,[n,r],"float32");return hs().makeTensorFromTensorInfo(i)}(t,e);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}var mTe=function(){function t(e){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,e.length!==2||e[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(e));this.workgroupSize=[32,1,1],this.outputShape=e;var n=[e[0],1];this.dispatchLayout=De(n),this.dispatch=Re(this.dispatchLayout,n,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return t.prototype.getUserCode=function(){return`
    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {
      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;
      let outIndexX = outIndexY + uniforms.bShape.z;
      let outY = i32(B[outIndexY]);
      let outX = i32(B[outIndexX]);
      return vec2<i32>(outY, outX);
    }

    `.concat(o4("index"),` {
      if (index < uniforms.size) {
        let indexY = index * `).concat(this.supportedLastDimension,`;
        let indexX = indexY + 1;
        let heatmapY = A[indexY];
        let heatmapX = A[indexX];
        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);
        result[indexY] = f32(out[0]);
        result[indexX] = f32(out[1]);
      }
    }
    `)},t}();function gTe(t,e){if(ud()instanceof Od)return function(n,r){var s=ud(),o=new mTe(n.shape),i=s.runWebGPUProgram(o,[n,r],"float32");return hs().makeTensorFromTensorInfo(i)}(t,e);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}function i4(t){var e=t.shape,n=e[0],r=e[1],s=e[2];return nt(function(){var o,i,a=ye(t,[n*r,s]),l=ZA(a,0),c=_s(gt(l,mt(r,"int32")),1),d=_s((o=l,i=r,nt(function(){var f=gt(o,mt(i,"int32"));return ot(o,Te(f,mt(i,"int32")))})),1);return Fn([c,d],1)})}function yTe(t,e,n){return nt(function(){var r=function(s,o){for(var i=[],a=0;a<$i.length;a++){var l=s.get(a,0).valueOf(),c=s.get(a,1).valueOf(),d=xTe(l,c,a,o),f=d.x,p=d.y;i.push(p),i.push(f)}return uo(i,[$i.length,2])}(t,n);return We(Qt(Te(t.toTensor(),mt(e,"int32")),"float32"),r)})}function xTe(t,e,n,r){return{y:r.get(t,e,n),x:r.get(t,e,n+$i.length)}}function vTe(t,e,n){return bt(this,void 0,void 0,function(){var r,s,o,i,a,l,c,d,f,p;return wt(this,function(g){switch(g.label){case 0:return r=0,s=i4(t),[4,Promise.all([t.buffer(),e.buffer(),s.buffer()])];case 1:return o=g.sent(),i=o[0],a=o[1],l=o[2],[4,(c=yTe(l,n,a)).buffer()];case 2:return d=g.sent(),f=Array.from(function(y,x){for(var w=x.shape[0],S=new Float32Array(w),$=0;$<w;$++){var I=x.get($,0),R=x.get($,1);S[$]=y.get(I,R,$)}return S}(i,l)),p=f.map(function(y,x){return r+=y,{y:d.get(x,0),x:d.get(x,1),score:y,name:$i[x]}}),s.dispose(),c.dispose(),[2,{keypoints:p,score:r/p.length}]}})})}function bTe(t,e,n){return bt(this,void 0,void 0,function(){var r,s,o;return wt(this,function(i){return r=i4(t),s=function(a,l,c){return nt(function(){var d=gTe(a,c);return We(Qt(Te(a,mt(l,"int32")),"float32"),d)})}(r,n,e),o=pTe(t,r),[2,[s,o]]})})}function fE(t,e){return(t-1)%e==0}var pE="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",mE="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function gE(t,e){return function(n,r){return(n-1)%r==0}(t,e)?t:Math.floor(t/e)*e+1}var yE=function(){function t(e,n){this.posenetModel=e;var r=this.posenetModel.inputs[0].shape;z(r[1]===-1&&r[2]===-1,function(){return"Input shape [".concat(r[1],", ").concat(r[2],"] ")+"must both be equal to or -1"});var s,o,i=(s=n.inputResolution,o=n.outputStride,{height:gE(s.height,o),width:gE(s.width,o)});(function(a){z(sTe.indexOf(a)>=0,function(){return"outputStride of ".concat(a," is invalid. ")+"It must be either 8 or 16."})})(n.outputStride),function(a,l){z(fE(a.height,l),function(){return"height of ".concat(a.height," is invalid for output stride ")+"".concat(l,".")}),z(fE(a.width,l),function(){return"width of ".concat(a.width," is invalid for output stride ")+"".concat(l,".")})}(i,n.outputStride),this.inputResolution=i,this.outputStride=n.outputStride,this.architecture=n.architecture}return t.prototype.estimatePoses=function(e,n){return n===void 0&&(n=aE),bt(this,void 0,void 0,function(){return wt(this,function(r){return[2,this.estimatePosesGPU(e,n,!1)]})})},t.prototype.estimatePosesGPU=function(e,n,r){return n===void 0&&(n=aE),r===void 0&&(r=!1),bt(this,void 0,void 0,function(){var s,o,i,a,l,c,d,f,p,g,y,x,w,S,$,I,R,_;return wt(this,function(O){switch(O.label){case 0:return s=function(F){var B=F;if(B.maxPoses==null&&(B.maxPoses=1),B.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(B.maxPoses,". Should be > 0."));if(B.maxPoses>1){if((B=Yt(Yt({},oTe),B)).scoreThreshold<0||B.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(B.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(B.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(B.nmsRadius,"."))}return B}(n),e==null?[2,r?[[],[]]:[]]:(this.maxPoses=s.maxPoses,o=Mv(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),i=o.imageTensor,a=o.padding,l=this.architecture==="ResNet50"?We(i,iTe):YF(i,[-1,1]),c=this.posenetModel.predict(l),this.architecture==="ResNet50"?(d=Gt(c[2],[0]),f=Gt(c[3],[0]),p=Gt(c[0],[0]),g=Gt(c[1],[0])):(d=Gt(c[0],[0]),f=Gt(c[1],[0]),p=Gt(c[2],[0]),g=Gt(c[3],[0])),y=aa(f),this.maxPoses!==1?[3,5]:r?[4,bTe(y,d,this.outputStride)]:[3,2]);case 1:return w=O.sent(),$=w[0],S=w[1],x=[$,S],[3,4];case 2:return[4,vTe(y,d,this.outputStride)];case 3:$=O.sent(),x=[$],O.label=4;case 4:return[3,7];case 5:if(r)throw new Error("GPU renderer only supports single pose!");return[4,hTe(y,d,p,g,this.outputStride,this.maxPoses,s.scoreThreshold,s.nmsRadius)];case 6:x=O.sent(),O.label=7;case 7:if(r){if(s.flipHorizontal===!0)throw new Error("flipHorizontal is not supported!");I=this.getCanvasInfo(md(e),this.inputResolution,a)}else _=md(e),R=function(F,B,M,V){var P=B.height,re=B.width,ie=P/(M.height*(1-V.top-V.bottom)),me=re/(M.width*(1-V.left-V.right)),ge=-V.top*M.height,ve=-V.left*M.width;if(me===1&&ie===1&&ge===0&&ve===0)return F;for(var $e=0,fe=F;$e<fe.length;$e++)for(var xe=0,ae=fe[$e].keypoints;xe<ae.length;xe++){var q=ae[xe];q.x=(q.x+ve)*me,q.y=(q.y+ge)*ie}return F}(x,_,this.inputResolution,a),s.flipHorizontal&&(R=function(F,B){for(var M=0,V=F;M<V.length;M++)for(var P=0,re=V[M].keypoints;P<re.length;P++){var ie=re[P];ie.x=B.width-1-ie.x}return F}(R,_));return i.dispose(),l.dispose(),Mt(c),d.dispose(),f.dispose(),p.dispose(),g.dispose(),y.dispose(),[2,r?[x,I]:R]}})})},t.prototype.getCanvasInfo=function(e,n,r){var s=e.height,o=e.width,i=s/(n.height*(1-r.top-r.bottom)),a=o/(n.width*(1-r.left-r.right)),l=-r.top*n.height;return[-r.left*n.width,l,a,i,e.width,e.height]},t.prototype.dispose=function(){this.posenetModel.dispose()},t.prototype.reset=function(){},t}();function wTe(t){return t===void 0&&(t=nE),bt(this,void 0,void 0,function(){var e,n,r,s,o;return wt(this,function(i){switch(i.label){case 0:return(e=function(d){var f=d||nE;if(f.architecture==null&&(f.architecture="MobileNetV1"),rE.indexOf(f.architecture)<0)throw new Error("Invalid architecture ".concat(f.architecture,". ")+"Should be one of ".concat(rE));if(f.inputResolution==null&&(f.inputResolution={height:257,width:257}),f.outputStride==null&&(f.outputStride=16),sE[f.architecture].indexOf(f.outputStride)<0)throw new Error("Invalid outputStride ".concat(f.outputStride,". ")+"Should be one of ".concat(sE[f.architecture]," ")+"for architecture ".concat(f.architecture,"."));if(f.multiplier==null&&(f.multiplier=1),oE[f.architecture].indexOf(f.multiplier)<0)throw new Error("Invalid multiplier ".concat(f.multiplier,". ")+"Should be one of ".concat(oE[f.architecture]," ")+"for architecture ".concat(f.architecture,"."));if(f.quantBytes==null&&(f.quantBytes=4),iE.indexOf(f.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(f.quantBytes,". ")+"Should be one of ".concat(iE," ")+"for architecture ".concat(f.architecture,"."));if(f.architecture==="MobileNetV1"&&f.outputStride===32&&f.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return f}(t)).architecture!=="ResNet50"?[3,2]:(a=e.outputStride,l=e.quantBytes,c="model-stride".concat(a,".json"),n=l===4?mE+"float/"+c:mE+"quant".concat(l,"/")+c,[4,fd(e.modelUrl||n)]);case 1:return r=i.sent(),[2,new yE(r,e)];case 2:return s=function(d,f,p){var g={1:"100",.75:"075",.5:"050"},y="model-stride".concat(d,".json");return p===4?pE+"float/".concat(g[f],"/")+y:pE+"quant".concat(p,"/").concat(g[f],"/")+y}(e.outputStride,e.multiplier,e.quantBytes),[4,fd(e.modelUrl||s)];case 3:return o=i.sent(),[2,new yE(o,e)]}var a,l,c})})}function STe(t,e){return bt(this,void 0,void 0,function(){var n,r;return wt(this,function(s){switch(t){case wi.PoseNet:return[2,wTe(e)];case wi.BlazePose:if(r=void 0,(n=e)!=null){if(n.runtime==="tfjs")return[2,Yke(e)];if(n.runtime==="mediapipe")return[2,Ske(e)];r=n.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(r));case wi.MoveNet:return[2,rTe(e)];default:throw new Error("".concat(t," is not a supported model name."))}})})}var CTe={modelType:{SINGLEPOSE_LIGHTNING:"SinglePose.Lightning"}};const xE={150:{Shoulder:[16.5,16.5722,16.5856,16.6229,16.3468,16.3576,16.5433,16.6389,16.6642],ApexHeight:[8,8.0395,7.9894,7.9358,8.0214,8.0596,7.991,8.031,8.0645],ApexDistance:[6.75,6.6887,6.79,6.7221,6.7331,6.7022,6.7542,6.7589,6.7895],FullLength:[18,17.8812,17.8484,18.1335,18.0431,17.9067,18.1486,17.8715,17.986],SleeveLength:[8,7.9606,7.9609,7.9215,8.0487,8.0642,8.0284,7.9453,7.9907],LowerArmGirth:[13,12.9598,13.0228,13.0361,12.9803,12.935,13.0898,12.9218,12.97],Waist:[29,28.9903,28.8476,29.0417,29.0434,29.2858,28.8812,29.2772,29.0918],Hip:[null,null,null,null,null,null,null,null,null],Thigh:[null,null,null,null,null,null,null,null,null],BodyFigure:[34.5,34.3444,34.5455,34.6282,34.6688,34.1888,34.5734,34.4977,34.7789],Knee:[17.5,17.4252,17.6046,17.5375,17.4483,17.5478,17.5423,17.5622,17.5773],Crotch:[10.25,10.2826,10.3194,10.2763,10.3327,10.28,10.2108,10.2379,10.2663],Bottomline:[18.5,18.586,18.3483,18.4242,18.5916,18.38,18.3639,18.5146,18.6745]},155:{Shoulder:[15,14.8806,15.0817,15.1051,15.0301,14.8863,15.1452,15.0848,14.9542],ApexHeight:[9.5,9.4864,9.4754,9.5011,9.4698,9.5664,9.5612,9.4251,9.5875],ApexDistance:[7,7.019,7.046,7.029,6.991,7.0327,7.0652,6.9678,7.0431],FullLength:[21,21.016,20.9931,20.9729,21.097,20.9027,21.1477,21.1389,20.8264],SleeveLength:[10,10.0763,9.9488,9.9929,10.0221,9.9758,9.9057,10.0702,9.9364],LowerArmGirth:[11,10.9367,11.0655,10.9649,11.0837,11.0443,10.9508,10.8922,11.0986],Waist:[31,30.7431,31.1364,30.9929,31.1601,31.1182,31.0905,30.9943,31.1816],Hip:[37.25,36.9468,37.0426,37.3929,37.1056,37.3108,37.2301,37.273,37.1945],Thigh:[17.5,17.5861,17.4408,17.571,17.4198,17.413,17.3672,17.3924,17.3668],BodyFigure:[23.125,23.1416,23.2463,22.9794,22.9938,23.1177,23.2289,23.3454,23.1364],Knee:[18.5,18.4197,18.3522,18.3868,18.3992,18.3814,18.3202,18.5126,18.4165],Crotch:[11,11.1043,11.0117,11.0434,10.9178,11.0811,10.998,11.082,11.0163],Bottomline:[19.5,19.4881,19.4768,19.3769,19.325,19.672,19.4913,19.6256,19.4613]},157:{Shoulder:[17,16.8552,17.044,16.8482,16.8807,17.0214,16.9333,17.1679,16.8703],ApexHeight:[10,10.0529,10.0213,10.0581,9.9451,10.0045,9.9901,9.9885,10.072],ApexDistance:[8.5,8.5833,8.4669,8.5206,8.5186,8.5408,8.5761,8.4503,8.4509],FullLength:[22,22.0706,21.8491,21.8565,21.813,21.7812,21.9782,22.0413,21.9082],SleeveLength:[10,9.9463,10.0414,10.0406,9.9908,10.0375,10.0848,10.0576,10.025],LowerArmGirth:[12.5,12.5403,12.6084,12.4813,12.5111,12.5369,12.6021,12.5817,12.3929],Waist:[31.5,31.2895,31.3788,31.6568,31.5436,31.3668,31.2633,31.6189,31.6258],Hip:[36.25,36.5709,36.2503,36.2455,35.9458,35.9164,36.2007,36.1212,36.069],Thigh:[21.5,21.3243,21.6986,21.6445,21.5323,21.6938,21.7148,21.5741,21.4009],BodyFigure:[36,35.669,36.1845,35.9788,36.1091,36.2996,35.7707,36.0614,36.097],Knee:[18.5,18.4969,18.3488,18.4437,18.4383,18.5629,18.6324,18.437,18.5717],Crotch:[11.5,11.4513,11.6024,11.5721,11.5115,11.4896,11.4573,11.4594,11.6081],Bottomline:[19.5,19.4626,19.5057,19.6904,19.5615,19.5166,19.4662,19.3782,19.4461]},158:{Shoulder:[17,17.0872,17.0426,17.0884,16.8992,17.0167,17.1454,16.979,17.0674],ApexHeight:[10.5,10.4205,10.5994,10.5229,10.4453,10.4283,10.5107,10.511,10.4146],ApexDistance:[8,8.0788,8.0661,7.9938,7.9388,8.0531,7.9997,8.0347,8.0014],FullLength:[21,20.9048,21.1406,21.2017,20.8924,21.0215,20.9511,21.1772,21.0035],SleeveLength:[8.25,8.3126,8.3101,8.2131,8.2979,8.236,8.3217,8.2513,8.3029],LowerArmGirth:[15.5,15.4327,15.4376,15.527,15.6547,15.4968,15.3911,15.512,15.452],Waist:[39.5,39.541,39.5343,39.4647,39.3592,39.254,39.656,39.5567,39.2895],Hip:[null,null,null,null,null,null,null,null,null],Thigh:[null,null,null,null,null,null,null,null,null],BodyFigure:[43,43.237,42.6075,43.2104,43.1765,43.2678,42.902,43.1408,43.2758],Knee:[20,20.1923,19.9981,19.8148,20.0009,20.0361,20.1479,20.1497,19.9761],Crotch:[12.5,12.5065,12.4892,12.5556,12.4775,12.5387,12.4136,12.4924,12.6173],Bottomline:[21,20.9322,21.0809,21.0629,21.1477,21.148,21.1509,20.9496,20.923]},159:{Shoulder:[14.5,14.5959,14.5139,14.6152,14.5707,14.4927,14.4302,14.4267,14.5399],ApexHeight:[7,7.0372,7.003,7.0177,6.9684,6.9408,6.97,6.968,6.9748],ApexDistance:[7,7.0056,6.9494,6.9624,7.0272,7.0289,6.939,6.9871,7.006],FullLength:[19,18.968,18.8886,18.9697,19.1538,19.032,19.0743,19.1356,19.1009],SleeveLength:[7,6.9833,6.9308,6.9792,7.0355,7.0495,7.0635,6.9887,7.0347],LowerArmGirth:[11.5,11.5106,11.5237,11.4357,11.4355,11.4852,11.3917,11.4623,11.5412],Waist:[30,29.9426,29.799,29.9804,29.7766,30.0734,29.7162,29.9364,30.0386],Hip:[40,39.6217,40.1142,39.7086,39.9694,39.6402,39.9033,39.7693,39.8615],Thigh:[22.125,22.2406,22.0715,22.2365,22.2719,22.0154,21.94,21.9123,22.1424],BodyFigure:[36,36.3599,35.892,36.1081,36.2025,36.1093,36.183,36.3237,35.7835],Knee:[18.5,18.3225,18.3714,18.3617,18.5627,18.5237,18.3956,18.5738,18.5988],Crotch:[11.5,11.4236,11.5247,11.557,11.4113,11.5734,11.6069,11.4099,11.3909],Bottomline:[19.5,19.4267,19.5692,19.6787,19.4597,19.5839,19.3346,19.5743,19.5496]},162:{Shoulder:[15.5,15.475,15.5259,15.5071,15.6348,15.4083,15.567,15.419,15.4677],ApexHeight:[10,10.0343,9.96,9.9632,10.0504,9.9145,9.9917,10.0997,10.0992],ApexDistance:[8.5,8.4275,8.4512,8.4601,8.5737,8.5647,8.5645,8.4778,8.4418],FullLength:[17,17.1135,17.0692,17.038,17.1657,17.0524,16.8327,17.1078,16.9318],SleeveLength:[8.5,8.5278,8.5746,8.4378,8.4346,8.4332,8.509,8.4613,8.5178],LowerArmGirth:[12.5,12.5544,12.4259,12.5336,12.441,12.4971,12.6013,12.5865,12.3981],Waist:[28.125,28.082,27.9994,27.8457,28.2775,28.2021,27.9911,28.2607,28.1541],Hip:[37.5,37.4458,37.1323,37.1814,37.7873,37.8029,37.5342,37.7509,37.5619],Thigh:[21.375,21.2246,21.2157,21.293,21.5456,21.5016,21.5292,21.5455,21.2511],BodyFigure:[35.125,34.949,34.846,35.3218,35.3949,35.0592,35.2098,34.8823,35.427],Knee:[19,19.1386,19.181,19.1181,19.1449,18.8194,19.0899,18.9362,19.1637],Crotch:[11.5,11.5695,11.5837,11.5715,11.4464,11.5661,11.4099,11.5856,11.5825],Bottomline:[20,19.889,20.1266,19.9841,19.9221,20.1181,19.891,19.8095,19.8773]},163:{Shoulder:[17.5,17.4399,17.6275,17.6634,17.4227,17.5495,17.4649,17.6684,17.5127],ApexHeight:[11.25,11.3488,11.1635,11.3558,11.1777,11.3541,11.1972,11.1619,11.2353],ApexDistance:[7.75,7.7854,7.7211,7.7665,7.7518,7.7322,7.7619,7.712,7.7824],FullLength:[22,21.7807,22.1873,22.0169,22.0965,22.1065,22.0751,21.9403,21.8108],SleeveLength:[9.125,9.155,9.094,9.091,9.1885,9.1651,9.0886,9.0902,9.1083],LowerArmGirth:[14.5,14.4717,14.4407,14.3919,14.4769,14.6277,14.5514,14.6168,14.5335],Waist:[36,35.8567,36.0345,35.6403,35.8466,35.9495,36.0576,36.1114,35.9748],Hip:[42.75,42.7005,42.5052,42.7271,43.093,43.0031,42.4676,42.395,42.7632],Thigh:[24.125,24.1891,24.0455,24.2786,24.2462,24.2084,23.9921,23.9798,23.8955],BodyFigure:[40,39.7959,39.9801,40.2798,39.6583,39.9316,40.1038,39.7555,40.1571],Knee:[19.5,19.4978,19.4002,19.5609,19.3072,19.5979,19.6053,19.3466,19.4708],Crotch:[12.5,12.419,12.6145,12.5045,12.3876,12.4373,12.5871,12.4891,12.5754],Bottomline:[20.5,20.5687,20.7,20.5391,20.6845,20.6605,20.5462,20.5899,20.502]},165:{Shoulder:[17,17.0474,16.8385,16.9235,16.9059,17.0804,17.0601,17.1333,16.8596],ApexHeight:[8.75,8.7363,8.6677,8.7008,8.7509,8.6671,8.6973,8.7762,8.7579],ApexDistance:[7.5,7.4581,7.5134,7.5464,7.426,7.5459,7.5297,7.476,7.4483],FullLength:[17.5,17.66,17.4428,17.3575,17.3589,17.6216,17.5363,17.6075,17.5804],SleeveLength:[5,5.0036,5.0473,4.9879,5.0052,5.0329,5.0119,5.0362,5.0077],LowerArmGirth:[14,14.0573,13.8728,13.9238,13.941,13.8823,13.9252,13.8883,13.9378],Waist:[26,26.0706,25.9297,25.9325,25.8489,25.8788,26.2271,26.077,26.0567],Hip:[33,32.783,33.1512,32.7778,32.9204,33.3231,33.0924,33.0376,33.1218],Thigh:[17,17.1166,17.0938,16.9079,16.8409,16.9373,16.921,16.9017,17.1506],BodyFigure:[32,32.2409,31.8814,32.0995,31.9332,32.2653,31.9737,31.8495,31.8378],Knee:[16.5,16.5203,16.4217,16.5279,16.6313,16.4668,16.4074,16.6642,16.5031],Crotch:[10,9.9182,9.9094,9.9219,10.0255,10.0584,9.9844,9.9127,9.9763],Bottomline:[17.5,17.6736,17.5102,17.6649,17.6263,17.329,17.5773,17.5636,17.5129]},175:{Shoulder:[17,16.9207,17.0479,16.8679,16.9778,16.9843,17.1543,17.1278,16.9196],ApexHeight:[9,9.0001,8.9422,9.0743,9.0667,8.9637,9.025,9.0196,8.9375],ApexDistance:[8,8.042,8.0063,8.0446,8.0049,7.9201,7.9719,7.9231,8.0687],FullLength:[20,20.1515,20.1327,19.923,19.8232,20.1512,20.1788,19.8343,19.9944],SleeveLength:[9,8.9225,9.0469,9.0479,8.9331,8.9956,9.009,8.9577,9.067],LowerArmGirth:[11,10.9831,10.9366,11.0086,11.0506,10.9343,10.9586,11.1089,11.033],Waist:[26.5,26.4672,26.5093,26.2991,26.3541,26.4142,26.5468,26.357,26.3517],Hip:[35,34.6997,35.0918,34.8103,35.2838,35.2517,34.6996,34.8166,35.1183],Thigh:[18.5,18.3943,18.364,18.6611,18.5263,18.4899,18.6053,18.6138,18.3855],BodyFigure:[31,30.7501,30.9573,30.9526,30.9796,31.142,31.1075,31.3002,30.751],Knee:[15,14.9708,14.9518,15.1085,14.9246,14.9071,14.9846,14.9766,14.9336],Crotch:[11,10.945,11.0931,10.9875,11.0795,11.0111,10.9011,11.1098,11.0739],Bottomline:[16,16.1501,16.1364,16.1116,15.8932,15.9954,15.9084,15.9683,15.8588]},176:{Shoulder:[null,null,null,null,null,null,null,null,null],ApexHeight:[null,null,null,null,null,null,null,null,null],ApexDistance:[null,null,null,null,null,null,null,null,null],FullLength:[null,null,null,null,null,null,null,null,null],SleeveLength:[null,null,null,null,null,null,null,null,null],LowerArmGirth:[null,null,null,null,null,null,null,null,null],Waist:[26.5,26.4359,26.7572,26.3756,26.6506,26.4762,26.4592,26.7424,26.7626],Hip:[35.5,35.5396,35.6551,35.2549,35.3557,35.8328,35.5562,35.53,35.6761],Thigh:[18,17.8406,18.0303,18.001,18.127,17.8767,18.1659,17.8488,17.8869],BodyFigure:[32.375,32.4365,32.4885,32.2035,32.1289,32.6277,32.2107,32.4362,32.4523],Knee:[null,null,null,null,null,null,null,null,null],Crotch:[null,null,null,null,null,null,null,null,null],Bottomline:[null,null,null,null,null,null,null,null,null]}},Es={NOSE:0,LEFT_SHOULDER:5,RIGHT_SHOULDER:6,LEFT_HIP:11,RIGHT_HIP:12,LEFT_KNEE:13,RIGHT_KNEE:14,LEFT_ANKLE:15,RIGHT_ANKLE:16},vE=[Es.NOSE,Es.LEFT_SHOULDER,Es.RIGHT_SHOULDER,Es.LEFT_HIP,Es.RIGHT_HIP,Es.LEFT_KNEE,Es.RIGHT_KNEE,Es.LEFT_ANKLE,Es.RIGHT_ANKLE],$Te=.3,bE=5,kTe=1500;function TTe({onNavigate:t}){const e=J.useRef(null),n=J.useRef(null),r=J.useRef(null),s=J.useRef(null),o=J.useRef(null),[i,a]=J.useState(!0),[l,c]=J.useState(null),[d,f]=J.useState(null),[p,g]=J.useState(!1),[y,x]=J.useState(!1),[w,S]=J.useState("Initializing camera..."),[$,I]=J.useState("INITIALIZING"),[R,_]=J.useState(!1),[O,F]=J.useState(null),B=BP(),[M,V]=J.useState(null),P=J.useCallback(()=>{s.current&&(clearInterval(s.current),s.current=null,console.log("Countdown interval cleared.")),o.current&&(clearTimeout(o.current),o.current=null,console.log("Pre-countdown timeout cleared.")),F(null)},[]),re=J.useCallback(async()=>{a(!0),c(null),S("Requesting camera access..."),I("INITIALIZING"),_(!1),P(),f(ae=>(ae&&(ae.getTracks().forEach(q=>q.stop()),console.log("Stopped previous stream inside requestCamera.")),null));try{console.log("Requesting getUserMedia...");const ae=await navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"},audio:!1});console.log("getUserMedia successful."),f(ae)}catch(ae){console.error("Error accessing camera:",ae);let q="Could not access camera. Please ensure permission is granted.";ae.name==="NotAllowedError"?q="Camera permission denied.":ae.name==="NotFoundError"||ae.name==="DevicesNotFoundError"?q="No suitable camera found.":ae.name==="NotReadableError"||ae.name==="TrackStartError"?q="Camera is already in use.":ae instanceof TypeError&&ae.message.includes("getUserMedia")?q="Camera requires secure connection (HTTPS).":q=`Unexpected camera error: ${ae.message}`,c(q),S("Error initializing camera."),a(!1),I("ERROR")}},[P]);J.useEffect(()=>(re(),()=>{console.log("Cleanup: Unmounting, stopping stream"),f(ae=>(ae&&ae.getTracks().forEach(q=>q.stop()),null)),cancelAnimationFrame(n.current),P(),r.current&&(r.current.dispose(),r.current=null)}),[re,P]);const ie=J.useCallback(ae=>{ae!==null?(console.log("Video element mounted."),e.current=ae,g(!0)):(console.log("Video element unmounted."),g(!1),e.current=null)},[]),me=J.useCallback(async()=>{if(!(r.current||l||$==="ERROR"||y)){x(!0),S("Loading pose detection model..."),console.log("Loading MoveNet model...");try{await UX("webgl"),await jX();const ae=wi.MoveNet,ue={modelType:CTe.modelType.SINGLEPOSE_LIGHTNING,modelUrl:"https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4"},we=await STe(ae,ue);r.current=we,console.log("MoveNet model loaded successfully."),x(!1),S("Model loaded. Position for FRONT pose."),I("DETECTING_FRONT")}catch(ae){console.error("Error loading pose model:",ae),ae instanceof TypeError&&ae.message.includes("fetch")?c("Failed to load pose model due to network/CORS issue."):c("Failed to load pose detection model."),S("Error loading model."),x(!1),I("ERROR")}}},[l,$,y]);J.useEffect(()=>{d&&p&&e.current&&!r.current&&!y&&(console.log("Attaching stream to video element."),e.current.srcObject=d,e.current.onloadedmetadata=()=>{console.log("Video metadata loaded."),a(!1),S("Camera ready. Prepare for FRONT pose."),I("FRONT_PROMPT"),me()},e.current.onerror=ae=>{console.error("Video element error:",ae),c("Video display error."),I("ERROR")})},[d,p,me,y]);const ge=J.useCallback(()=>{console.log("Processing results..."),cancelAnimationFrame(n.current),P();const ae=localStorage.getItem("userHeight");if(!ae){console.error("Height not found in storage!"),B({title:"Error",description:"Could not retrieve height.",status:"error",duration:3e3,isClosable:!0}),t("HEIGHT_INPUT");return}const q=ae;let ue={height:ae};if(xE[q]){const we=xE[q];for(const Ge in we){const et=we[Ge];if(et&&et.length>0){const tt=Math.floor(Math.random()*et.length);ue[Ge]=parseFloat(et[tt].toFixed(2))}else ue[Ge]="N/A"}}else console.warn(`No measurement data found for height: ${q}`),ue.Waist="N/A",ue.Hip="N/A",ue.Thigh="N/A",ue.BustChest="N/A";console.log("Generated results:",ue),B({title:"Success!",description:"Poses captured successfully!",status:"success",duration:2e3,isClosable:!0}),setTimeout(()=>t("RESULTS",ue),1500)},[t,B,P]),ve=J.useCallback(ae=>{o.current&&(clearTimeout(o.current),o.current=null),P(),F(bE),S(`Hold Pose: ${bE}`),s.current=setInterval(()=>{F(q=>{if(q===null)return P(),null;const ue=q-1;return ue>0?(S(`Hold Pose: ${ue}`),ue):(P(),console.log(`${$==="DETECTING_FRONT"?"FRONT":"SIDE"} POSE CONFIRMED`),ae==="SIDE_PROMPT"?S("Front pose captured! Prepare for SIDE pose."):(S("Side pose captured! Processing..."),ge()),I(ae),_(!1),null)})},1e3)},[P,ge,$]),$e=J.useCallback(ae=>{if(O!==null||o.current!==null)return;const q=Pr=>{_(!1),P(),S(Pr)};if(!ae||ae.length===0){S(Pr=>{const Vo="No person detected. Ensure you are fully visible.";return Pr!==Vo&&q(Vo),Vo});return}_(!1);const we=ae[0].keypoints;let Ge=0;for(const Pr of vE)we[Pr]&&we[Pr].score>$Te&&Ge++;if(Ge<vE.length){q("Full body not visible or low confidence. Adjust position.");return}const et=we[Es.LEFT_SHOULDER],tt=we[Es.RIGHT_SHOULDER],Tt=we[Es.LEFT_HIP],dt=we[Es.RIGHT_HIP];if(!et||!tt||!Tt||!dt){q("Cannot determine orientation. Adjust position.");return}const vt=Math.abs(et.x-tt.x),rn=Math.abs(Tt.x-dt.x);console.log(`ShoulderW: ${vt.toFixed(1)}, HipW: ${rn.toFixed(1)}`);const _r=vt>rn*.8&&vt>50,ki=vt<rn*.7||vt<50;let zt=!1,sn="";$==="DETECTING_FRONT"?(zt=_r,sn="Please face the camera directly."):$==="DETECTING_SIDE"&&(zt=ki,sn="Please turn 90 degrees (side view)."),zt?R||(console.log("Valid pose detected, starting pre-countdown delay..."),_(!0),S("Good Pose! Hold Still..."),o.current=setTimeout(()=>{console.log("Pre-countdown finished, starting main countdown."),o.current=null,ve($==="DETECTING_FRONT"?"SIDE_PROMPT":"DONE")},kTe)):q(sn||"Detecting pose...")},[$,O,R,ve,P]),fe=J.useCallback(async()=>{if(($==="DETECTING_FRONT"||$==="DETECTING_SIDE")&&O===null&&o.current===null&&r.current&&e.current&&e.current.readyState>=2)try{const ae=await r.current.estimatePoses(e.current,{maxPoses:1,flipHorizontal:!1});$e(ae)}catch(ae){console.error("Error during pose estimation:",ae)}n.current=requestAnimationFrame(fe)},[$,$e,O]);J.useEffect(()=>(r.current&&e.current&&!i&&!y&&$!=="ERROR"&&$!=="DONE"?(console.log(`Starting/Managing detection loop for stage: ${$}`),cancelAnimationFrame(n.current),n.current=requestAnimationFrame(fe)):cancelAnimationFrame(n.current),()=>{cancelAnimationFrame(n.current)}),[$,fe,i,y]),J.useEffect(()=>{let ae=null;return $==="SIDE_PROMPT"&&(console.log("In SIDE_PROMPT stage, waiting before detection..."),cancelAnimationFrame(n.current),ae=setTimeout(()=>{console.log("SIDE_PROMPT timeout finished, moving to DETECTING_SIDE."),I("DETECTING_SIDE")},1500)),()=>clearTimeout(ae)},[$]);const xe=J.useCallback(()=>{console.log("Retake requested"),cancelAnimationFrame(n.current),P(),_(!1),c(null),r.current&&(r.current.dispose(),r.current=null),x(!1),re()},[re,P]);return K.jsx(jf,{maxW:"container.xl",py:4,children:K.jsxs(ia,{spacing:4,w:"100%",children:[K.jsx(Sd,{size:"lg",children:"Pose Capture"}),(i||y)&&$!=="ERROR"&&K.jsxs(ia,{children:[K.jsx(Uf,{size:"xl",color:"blue.500"}),K.jsx(Sr,{children:w}),y&&K.jsx(PP,{size:"xs",isIndeterminate:!0,width:"80%",mt:2})]}),l&&K.jsxs(Kb,{status:"error",variant:"subtle",flexDirection:"column",alignItems:"center",justifyContent:"center",textAlign:"center",borderRadius:"md",children:[K.jsx(Xb,{boxSize:"40px",mr:0}),K.jsx(Sr,{mt:2,children:l})]}),!l&&K.jsxs(Ao,{position:"relative",width:"100%",mx:"auto",bg:"gray.200",borderRadius:"lg",overflow:"hidden",boxShadow:"lg",display:d?"block":"none",children:[K.jsx("video",{ref:ie,autoPlay:!0,playsInline:!0,muted:!0,style:{width:"100%",height:"auto",display:"block"}}),K.jsx(RP,{initialScale:.9,in:O!==null,children:K.jsx(pP,{position:"absolute",top:"50%",left:"50%",transform:"translate(-50%, -50%)",size:"100px",bg:"rgba(46, 204, 113, 0.8)",color:"white",fontSize:"4xl",fontWeight:"bold",zIndex:"20",children:O})}),!i&&d&&K.jsx(Sr,{position:"absolute",bottom:{base:"5px",md:"10px"},left:{base:"5px",md:"10px"},right:{base:"5px",md:"10px"},bg:R&&O===null&&o.current===null?"rgba(46, 204, 113, 0.8)":"rgba(0,0,0,0.7)",color:"white",p:{base:1,md:2},borderRadius:"md",fontSize:{base:"sm",md:"lg"},textAlign:"center",zIndex:"10",transition:"background-color 0.3s ease",children:w})]}),$!=="INITIALIZING"&&$!=="ERROR"&&!i&&!y&&K.jsx(bd,{onClick:xe,colorScheme:"orange",size:"lg",mt:4,children:"Retake Poses"})]})})}function ITe({onNavigate:t,results:e}){const[n,r]=J.useState(!0);J.useEffect(()=>{console.log("ResultsPage mounted, starting calculation simulation...");const l=setTimeout(()=>{console.log("Calculation simulation finished."),r(!1)},1500);return()=>clearTimeout(l)},[]);const s=()=>{console.log("Start Over clicked, navigating to HEIGHT_INPUT"),t("HEIGHT_INPUT")},o=l=>{const c=parseFloat(l);return l!=null&&l!=="N/A"&&!isNaN(c)?`${c.toFixed(1)} in`:"N/A"},i=["Waist","Hip","Thigh","Shoulder","ApexHeight","ApexDistance","FullLength","SleeveLength","LowerArmGirth","BodyFigure","Knee","Crotch","Bottomline"],a={Waist:VK,Hip:XK,Thigh:YK,BustChest:Qx,Shoulder:jK,ApexHeight:Zx,ApexDistance:Zx,FullLength:UK,SleeveLength:WP,LowerArmGirth:WK,BodyFigure:Qx,Knee:u3,Crotch:u3,Bottomline:MK};return K.jsxs(jf,{maxW:"container.lg",py:{base:8,md:12},children:[" ",K.jsxs(ia,{spacing:8,align:"stretch",children:[K.jsx(Sd,{as:"h1",size:"xl",textAlign:"center",color:"teal.600",children:n?"Calculating Measurements...":"Your Estimated Measurements"}),n?K.jsx(gP,{py:10,children:K.jsxs(ia,{spacing:4,children:[K.jsx(Uf,{thickness:"4px",speed:"0.65s",emptyColor:"gray.200",color:"teal.500",size:"xl"}),K.jsx(Sr,{fontSize:"lg",color:"gray.500",children:"Analyzing for best results confidence..."})]})}):K.jsx(_P,{in:!n,children:K.jsxs(ia,{spacing:8,align:"stretch",children:[K.jsxs(Sr,{textAlign:"center",fontSize:"lg",color:"gray.600",children:["Based on your height of ",(e==null?void 0:e.height)||"N/A"," cm and captured pose."]}),K.jsxs($P,{columns:{base:2,md:3},spacing:5,children:[" ",i.map(l=>K.jsxs(V7,{variant:"outline",size:"md",textAlign:"center",children:[" ",K.jsx(U7,{pb:0,children:K.jsx(wa,{as:a[l]||KK,w:8,h:8,color:"teal.500"})}),K.jsxs(W7,{pt:2,children:[" ",K.jsxs(FP,{children:[K.jsx(LP,{fontSize:"sm",color:"gray.500",mb:1,children:l}),K.jsxs(zP,{fontSize:"lg",children:[" ",o(e==null?void 0:e[l])]})]})]})]},l))]}),K.jsx(Sr,{textAlign:"center",fontSize:"sm",color:"gray.500",mt:4,children:"Note: These are estimations based on general data and simulated pose capture."}),K.jsx(bd,{colorScheme:"teal",size:"lg",onClick:s,alignSelf:"center",mt:6,leftIcon:K.jsx(LK,{}),children:"Start Over (Enter Height)"})]})})]})]})}function NTe(){const t=new Date().getFullYear();return K.jsxs("footer",{className:"app-footer",children:["DMMMSU (BSTFT) ",t]})}function ETe(){const[t,e]=J.useState("LANDING"),[n,r]=J.useState(null),s=(i,a=null)=>{console.log(`Navigating to ${i} with data:`,a),r(a),e(i)};let o;return t==="LANDING"?o=K.jsx(EK,{onNavigate:s}):t==="INSTRUCTIONS"?o=K.jsx(QK,{onNavigate:s}):t==="HEIGHT_INPUT"?o=K.jsx(JK,{onNavigate:s}):t==="CAMERA"?o=K.jsx(TTe,{onNavigate:s}):t==="RESULTS"?o=K.jsx(ITe,{onNavigate:s,results:n}):o=K.jsxs("div",{children:["Unknown View: ",t]}),K.jsxs("div",{className:"app-container",children:[K.jsx("main",{className:"main-content",children:o}),K.jsx(NTe,{})]})}const RTe=J7();mL.createRoot(document.getElementById("root")).render(K.jsx(sa.StrictMode,{children:K.jsx(O7,{theme:RTe,children:K.jsx(ETe,{})})}));
