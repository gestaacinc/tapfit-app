function L3(t,e){for(var n=0;n<e.length;n++){const r=e[n];if(typeof r!="string"&&!Array.isArray(r)){for(const s in r)if(s!=="default"&&!(s in t)){const o=Object.getOwnPropertyDescriptor(r,s);o&&Object.defineProperty(t,s,o.get?o:{enumerable:!0,get:()=>r[s]})}}}return Object.freeze(Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const i of o.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&r(i)}).observe(document,{childList:!0,subtree:!0});function n(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function r(s){if(s.ep)return;s.ep=!0;const o=n(s);fetch(s.href,o)}})();var Pc=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Df(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}function sL(t){if(Object.prototype.hasOwnProperty.call(t,"__esModule"))return t;var e=t.default;if(typeof e=="function"){var n=function r(){return this instanceof r?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};n.prototype=e.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(t).forEach(function(r){var s=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(n,r,s.get?s:{enumerable:!0,get:function(){return t[r]}})}),n}var n1={exports:{}},ph={},r1={exports:{}},xt={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var jk;function oL(){if(jk)return xt;jk=1;var t=Symbol.for("react.element"),e=Symbol.for("react.portal"),n=Symbol.for("react.fragment"),r=Symbol.for("react.strict_mode"),s=Symbol.for("react.profiler"),o=Symbol.for("react.provider"),i=Symbol.for("react.context"),a=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),c=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),f=Symbol.iterator;function p(Q){return Q===null||typeof Q!="object"?null:(Q=f&&Q[f]||Q["@@iterator"],typeof Q=="function"?Q:null)}var g={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},y=Object.assign,x={};function w(Q,he,be){this.props=Q,this.context=he,this.refs=x,this.updater=be||g}w.prototype.isReactComponent={},w.prototype.setState=function(Q,he){if(typeof Q!="object"&&typeof Q!="function"&&Q!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,Q,he,"setState")},w.prototype.forceUpdate=function(Q){this.updater.enqueueForceUpdate(this,Q,"forceUpdate")};function S(){}S.prototype=w.prototype;function $(Q,he,be){this.props=Q,this.context=he,this.refs=x,this.updater=be||g}var I=$.prototype=new S;I.constructor=$,y(I,w.prototype),I.isPureReactComponent=!0;var R=Array.isArray,_=Object.prototype.hasOwnProperty,F={current:null},O={key:!0,ref:!0,__self:!0,__source:!0};function M(Q,he,be){var We,nt={},Xe=null,kt=null;if(he!=null)for(We in he.ref!==void 0&&(kt=he.ref),he.key!==void 0&&(Xe=""+he.key),he)_.call(he,We)&&!O.hasOwnProperty(We)&&(nt[We]=he[We]);var mt=arguments.length-2;if(mt===1)nt.children=be;else if(1<mt){for(var Et=Array(mt),rn=0;rn<mt;rn++)Et[rn]=arguments[rn+2];nt.children=Et}if(Q&&Q.defaultProps)for(We in mt=Q.defaultProps,mt)nt[We]===void 0&&(nt[We]=mt[We]);return{$$typeof:t,type:Q,key:Xe,ref:kt,props:nt,_owner:F.current}}function B(Q,he){return{$$typeof:t,type:Q.type,key:he,ref:Q.ref,props:Q.props,_owner:Q._owner}}function V(Q){return typeof Q=="object"&&Q!==null&&Q.$$typeof===t}function A(Q){var he={"=":"=0",":":"=2"};return"$"+Q.replace(/[=:]/g,function(be){return he[be]})}var re=/\/+/g;function ae(Q,he){return typeof Q=="object"&&Q!==null&&Q.key!=null?A(""+Q.key):he.toString(36)}function pe(Q,he,be,We,nt){var Xe=typeof Q;(Xe==="undefined"||Xe==="boolean")&&(Q=null);var kt=!1;if(Q===null)kt=!0;else switch(Xe){case"string":case"number":kt=!0;break;case"object":switch(Q.$$typeof){case t:case e:kt=!0}}if(kt)return kt=Q,nt=nt(kt),Q=We===""?"."+ae(kt,0):We,R(nt)?(be="",Q!=null&&(be=Q.replace(re,"$&/")+"/"),pe(nt,he,be,"",function(rn){return rn})):nt!=null&&(V(nt)&&(nt=B(nt,be+(!nt.key||kt&&kt.key===nt.key?"":(""+nt.key).replace(re,"$&/")+"/")+Q)),he.push(nt)),1;if(kt=0,We=We===""?".":We+":",R(Q))for(var mt=0;mt<Q.length;mt++){Xe=Q[mt];var Et=We+ae(Xe,mt);kt+=pe(Xe,he,be,Et,nt)}else if(Et=p(Q),typeof Et=="function")for(Q=Et.call(Q),mt=0;!(Xe=Q.next()).done;)Xe=Xe.value,Et=We+ae(Xe,mt++),kt+=pe(Xe,he,be,Et,nt);else if(Xe==="object")throw he=String(Q),Error("Objects are not valid as a React child (found: "+(he==="[object Object]"?"object with keys {"+Object.keys(Q).join(", ")+"}":he)+"). If you meant to render a collection of children, use an array instead.");return kt}function ye(Q,he,be){if(Q==null)return Q;var We=[],nt=0;return pe(Q,We,"","",function(Xe){return he.call(be,Xe,nt++)}),We}function ve(Q){if(Q._status===-1){var he=Q._result;he=he(),he.then(function(be){(Q._status===0||Q._status===-1)&&(Q._status=1,Q._result=be)},function(be){(Q._status===0||Q._status===-1)&&(Q._status=2,Q._result=be)}),Q._status===-1&&(Q._status=0,Q._result=he)}if(Q._status===1)return Q._result.default;throw Q._result}var $e={current:null},se={transition:null},me={ReactCurrentDispatcher:$e,ReactCurrentBatchConfig:se,ReactCurrentOwner:F};function ge(){throw Error("act(...) is not supported in production builds of React.")}return xt.Children={map:ye,forEach:function(Q,he,be){ye(Q,function(){he.apply(this,arguments)},be)},count:function(Q){var he=0;return ye(Q,function(){he++}),he},toArray:function(Q){return ye(Q,function(he){return he})||[]},only:function(Q){if(!V(Q))throw Error("React.Children.only expected to receive a single React element child.");return Q}},xt.Component=w,xt.Fragment=n,xt.Profiler=s,xt.PureComponent=$,xt.StrictMode=r,xt.Suspense=l,xt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=me,xt.act=ge,xt.cloneElement=function(Q,he,be){if(Q==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+Q+".");var We=y({},Q.props),nt=Q.key,Xe=Q.ref,kt=Q._owner;if(he!=null){if(he.ref!==void 0&&(Xe=he.ref,kt=F.current),he.key!==void 0&&(nt=""+he.key),Q.type&&Q.type.defaultProps)var mt=Q.type.defaultProps;for(Et in he)_.call(he,Et)&&!O.hasOwnProperty(Et)&&(We[Et]=he[Et]===void 0&&mt!==void 0?mt[Et]:he[Et])}var Et=arguments.length-2;if(Et===1)We.children=be;else if(1<Et){mt=Array(Et);for(var rn=0;rn<Et;rn++)mt[rn]=arguments[rn+2];We.children=mt}return{$$typeof:t,type:Q.type,key:nt,ref:Xe,props:We,_owner:kt}},xt.createContext=function(Q){return Q={$$typeof:i,_currentValue:Q,_currentValue2:Q,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},Q.Provider={$$typeof:o,_context:Q},Q.Consumer=Q},xt.createElement=M,xt.createFactory=function(Q){var he=M.bind(null,Q);return he.type=Q,he},xt.createRef=function(){return{current:null}},xt.forwardRef=function(Q){return{$$typeof:a,render:Q}},xt.isValidElement=V,xt.lazy=function(Q){return{$$typeof:d,_payload:{_status:-1,_result:Q},_init:ve}},xt.memo=function(Q,he){return{$$typeof:c,type:Q,compare:he===void 0?null:he}},xt.startTransition=function(Q){var he=se.transition;se.transition={};try{Q()}finally{se.transition=he}},xt.unstable_act=ge,xt.useCallback=function(Q,he){return $e.current.useCallback(Q,he)},xt.useContext=function(Q){return $e.current.useContext(Q)},xt.useDebugValue=function(){},xt.useDeferredValue=function(Q){return $e.current.useDeferredValue(Q)},xt.useEffect=function(Q,he){return $e.current.useEffect(Q,he)},xt.useId=function(){return $e.current.useId()},xt.useImperativeHandle=function(Q,he,be){return $e.current.useImperativeHandle(Q,he,be)},xt.useInsertionEffect=function(Q,he){return $e.current.useInsertionEffect(Q,he)},xt.useLayoutEffect=function(Q,he){return $e.current.useLayoutEffect(Q,he)},xt.useMemo=function(Q,he){return $e.current.useMemo(Q,he)},xt.useReducer=function(Q,he,be){return $e.current.useReducer(Q,he,be)},xt.useRef=function(Q){return $e.current.useRef(Q)},xt.useState=function(Q){return $e.current.useState(Q)},xt.useSyncExternalStore=function(Q,he,be){return $e.current.useSyncExternalStore(Q,he,be)},xt.useTransition=function(){return $e.current.useTransition()},xt.version="18.3.1",xt}var Gk;function Wv(){return Gk||(Gk=1,r1.exports=oL()),r1.exports}/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Hk;function iL(){if(Hk)return ph;Hk=1;var t=Wv(),e=Symbol.for("react.element"),n=Symbol.for("react.fragment"),r=Object.prototype.hasOwnProperty,s=t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,o={key:!0,ref:!0,__self:!0,__source:!0};function i(a,l,c){var d,f={},p=null,g=null;c!==void 0&&(p=""+c),l.key!==void 0&&(p=""+l.key),l.ref!==void 0&&(g=l.ref);for(d in l)r.call(l,d)&&!o.hasOwnProperty(d)&&(f[d]=l[d]);if(a&&a.defaultProps)for(d in l=a.defaultProps,l)f[d]===void 0&&(f[d]=l[d]);return{$$typeof:e,type:a,key:p,ref:g,props:f,_owner:s.current}}return ph.Fragment=n,ph.jsx=i,ph.jsxs=i,ph}var Kk;function aL(){return Kk||(Kk=1,n1.exports=iL()),n1.exports}var K=aL(),ee=Wv();const ta=Df(ee),Xk=L3({__proto__:null,default:ta},[ee]);var om={},s1={exports:{}},is={},o1={exports:{}},i1={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var qk;function lL(){return qk||(qk=1,function(t){function e(se,me){var ge=se.length;se.push(me);e:for(;0<ge;){var Q=ge-1>>>1,he=se[Q];if(0<s(he,me))se[Q]=me,se[ge]=he,ge=Q;else break e}}function n(se){return se.length===0?null:se[0]}function r(se){if(se.length===0)return null;var me=se[0],ge=se.pop();if(ge!==me){se[0]=ge;e:for(var Q=0,he=se.length,be=he>>>1;Q<be;){var We=2*(Q+1)-1,nt=se[We],Xe=We+1,kt=se[Xe];if(0>s(nt,ge))Xe<he&&0>s(kt,nt)?(se[Q]=kt,se[Xe]=ge,Q=Xe):(se[Q]=nt,se[We]=ge,Q=We);else if(Xe<he&&0>s(kt,ge))se[Q]=kt,se[Xe]=ge,Q=Xe;else break e}}return me}function s(se,me){var ge=se.sortIndex-me.sortIndex;return ge!==0?ge:se.id-me.id}if(typeof performance=="object"&&typeof performance.now=="function"){var o=performance;t.unstable_now=function(){return o.now()}}else{var i=Date,a=i.now();t.unstable_now=function(){return i.now()-a}}var l=[],c=[],d=1,f=null,p=3,g=!1,y=!1,x=!1,w=typeof setTimeout=="function"?setTimeout:null,S=typeof clearTimeout=="function"?clearTimeout:null,$=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function I(se){for(var me=n(c);me!==null;){if(me.callback===null)r(c);else if(me.startTime<=se)r(c),me.sortIndex=me.expirationTime,e(l,me);else break;me=n(c)}}function R(se){if(x=!1,I(se),!y)if(n(l)!==null)y=!0,ve(_);else{var me=n(c);me!==null&&$e(R,me.startTime-se)}}function _(se,me){y=!1,x&&(x=!1,S(M),M=-1),g=!0;var ge=p;try{for(I(me),f=n(l);f!==null&&(!(f.expirationTime>me)||se&&!A());){var Q=f.callback;if(typeof Q=="function"){f.callback=null,p=f.priorityLevel;var he=Q(f.expirationTime<=me);me=t.unstable_now(),typeof he=="function"?f.callback=he:f===n(l)&&r(l),I(me)}else r(l);f=n(l)}if(f!==null)var be=!0;else{var We=n(c);We!==null&&$e(R,We.startTime-me),be=!1}return be}finally{f=null,p=ge,g=!1}}var F=!1,O=null,M=-1,B=5,V=-1;function A(){return!(t.unstable_now()-V<B)}function re(){if(O!==null){var se=t.unstable_now();V=se;var me=!0;try{me=O(!0,se)}finally{me?ae():(F=!1,O=null)}}else F=!1}var ae;if(typeof $=="function")ae=function(){$(re)};else if(typeof MessageChannel<"u"){var pe=new MessageChannel,ye=pe.port2;pe.port1.onmessage=re,ae=function(){ye.postMessage(null)}}else ae=function(){w(re,0)};function ve(se){O=se,F||(F=!0,ae())}function $e(se,me){M=w(function(){se(t.unstable_now())},me)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(se){se.callback=null},t.unstable_continueExecution=function(){y||g||(y=!0,ve(_))},t.unstable_forceFrameRate=function(se){0>se||125<se?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):B=0<se?Math.floor(1e3/se):5},t.unstable_getCurrentPriorityLevel=function(){return p},t.unstable_getFirstCallbackNode=function(){return n(l)},t.unstable_next=function(se){switch(p){case 1:case 2:case 3:var me=3;break;default:me=p}var ge=p;p=me;try{return se()}finally{p=ge}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(se,me){switch(se){case 1:case 2:case 3:case 4:case 5:break;default:se=3}var ge=p;p=se;try{return me()}finally{p=ge}},t.unstable_scheduleCallback=function(se,me,ge){var Q=t.unstable_now();switch(typeof ge=="object"&&ge!==null?(ge=ge.delay,ge=typeof ge=="number"&&0<ge?Q+ge:Q):ge=Q,se){case 1:var he=-1;break;case 2:he=250;break;case 5:he=1073741823;break;case 4:he=1e4;break;default:he=5e3}return he=ge+he,se={id:d++,callback:me,priorityLevel:se,startTime:ge,expirationTime:he,sortIndex:-1},ge>Q?(se.sortIndex=ge,e(c,se),n(l)===null&&se===n(c)&&(x?(S(M),M=-1):x=!0,$e(R,ge-Q))):(se.sortIndex=he,e(l,se),y||g||(y=!0,ve(_))),se},t.unstable_shouldYield=A,t.unstable_wrapCallback=function(se){var me=p;return function(){var ge=p;p=me;try{return se.apply(this,arguments)}finally{p=ge}}}}(i1)),i1}var Yk;function uL(){return Yk||(Yk=1,o1.exports=lL()),o1.exports}/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Qk;function cL(){if(Qk)return is;Qk=1;var t=Wv(),e=uL();function n(u){for(var h="https://reactjs.org/docs/error-decoder.html?invariant="+u,m=1;m<arguments.length;m++)h+="&args[]="+encodeURIComponent(arguments[m]);return"Minified React error #"+u+"; visit "+h+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var r=new Set,s={};function o(u,h){i(u,h),i(u+"Capture",h)}function i(u,h){for(s[u]=h,u=0;u<h.length;u++)r.add(h[u])}var a=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),l=Object.prototype.hasOwnProperty,c=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,d={},f={};function p(u){return l.call(f,u)?!0:l.call(d,u)?!1:c.test(u)?f[u]=!0:(d[u]=!0,!1)}function g(u,h,m,b){if(m!==null&&m.type===0)return!1;switch(typeof h){case"function":case"symbol":return!0;case"boolean":return b?!1:m!==null?!m.acceptsBooleans:(u=u.toLowerCase().slice(0,5),u!=="data-"&&u!=="aria-");default:return!1}}function y(u,h,m,b){if(h===null||typeof h>"u"||g(u,h,m,b))return!0;if(b)return!1;if(m!==null)switch(m.type){case 3:return!h;case 4:return h===!1;case 5:return isNaN(h);case 6:return isNaN(h)||1>h}return!1}function x(u,h,m,b,C,T,D){this.acceptsBooleans=h===2||h===3||h===4,this.attributeName=b,this.attributeNamespace=C,this.mustUseProperty=m,this.propertyName=u,this.type=h,this.sanitizeURL=T,this.removeEmptyString=D}var w={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(u){w[u]=new x(u,0,!1,u,null,!1,!1)}),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(u){var h=u[0];w[h]=new x(h,1,!1,u[1],null,!1,!1)}),["contentEditable","draggable","spellCheck","value"].forEach(function(u){w[u]=new x(u,2,!1,u.toLowerCase(),null,!1,!1)}),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(u){w[u]=new x(u,2,!1,u,null,!1,!1)}),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(u){w[u]=new x(u,3,!1,u.toLowerCase(),null,!1,!1)}),["checked","multiple","muted","selected"].forEach(function(u){w[u]=new x(u,3,!0,u,null,!1,!1)}),["capture","download"].forEach(function(u){w[u]=new x(u,4,!1,u,null,!1,!1)}),["cols","rows","size","span"].forEach(function(u){w[u]=new x(u,6,!1,u,null,!1,!1)}),["rowSpan","start"].forEach(function(u){w[u]=new x(u,5,!1,u.toLowerCase(),null,!1,!1)});var S=/[\-:]([a-z])/g;function $(u){return u[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(u){var h=u.replace(S,$);w[h]=new x(h,1,!1,u,null,!1,!1)}),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(u){var h=u.replace(S,$);w[h]=new x(h,1,!1,u,"http://www.w3.org/1999/xlink",!1,!1)}),["xml:base","xml:lang","xml:space"].forEach(function(u){var h=u.replace(S,$);w[h]=new x(h,1,!1,u,"http://www.w3.org/XML/1998/namespace",!1,!1)}),["tabIndex","crossOrigin"].forEach(function(u){w[u]=new x(u,1,!1,u.toLowerCase(),null,!1,!1)}),w.xlinkHref=new x("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach(function(u){w[u]=new x(u,1,!1,u.toLowerCase(),null,!0,!0)});function I(u,h,m,b){var C=w.hasOwnProperty(h)?w[h]:null;(C!==null?C.type!==0:b||!(2<h.length)||h[0]!=="o"&&h[0]!=="O"||h[1]!=="n"&&h[1]!=="N")&&(y(h,m,C,b)&&(m=null),b||C===null?p(h)&&(m===null?u.removeAttribute(h):u.setAttribute(h,""+m)):C.mustUseProperty?u[C.propertyName]=m===null?C.type===3?!1:"":m:(h=C.attributeName,b=C.attributeNamespace,m===null?u.removeAttribute(h):(C=C.type,m=C===3||C===4&&m===!0?"":""+m,b?u.setAttributeNS(b,h,m):u.setAttribute(h,m))))}var R=t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,_=Symbol.for("react.element"),F=Symbol.for("react.portal"),O=Symbol.for("react.fragment"),M=Symbol.for("react.strict_mode"),B=Symbol.for("react.profiler"),V=Symbol.for("react.provider"),A=Symbol.for("react.context"),re=Symbol.for("react.forward_ref"),ae=Symbol.for("react.suspense"),pe=Symbol.for("react.suspense_list"),ye=Symbol.for("react.memo"),ve=Symbol.for("react.lazy"),$e=Symbol.for("react.offscreen"),se=Symbol.iterator;function me(u){return u===null||typeof u!="object"?null:(u=se&&u[se]||u["@@iterator"],typeof u=="function"?u:null)}var ge=Object.assign,Q;function he(u){if(Q===void 0)try{throw Error()}catch(m){var h=m.stack.trim().match(/\n( *(at )?)/);Q=h&&h[1]||""}return`
`+Q+u}var be=!1;function We(u,h){if(!u||be)return"";be=!0;var m=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(h)if(h=function(){throw Error()},Object.defineProperty(h.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(h,[])}catch(ce){var b=ce}Reflect.construct(u,[],h)}else{try{h.call()}catch(ce){b=ce}u.call(h.prototype)}else{try{throw Error()}catch(ce){b=ce}u()}}catch(ce){if(ce&&b&&typeof ce.stack=="string"){for(var C=ce.stack.split(`
`),T=b.stack.split(`
`),D=C.length-1,H=T.length-1;1<=D&&0<=H&&C[D]!==T[H];)H--;for(;1<=D&&0<=H;D--,H--)if(C[D]!==T[H]){if(D!==1||H!==1)do if(D--,H--,0>H||C[D]!==T[H]){var Y=`
`+C[D].replace(" at new "," at ");return u.displayName&&Y.includes("<anonymous>")&&(Y=Y.replace("<anonymous>",u.displayName)),Y}while(1<=D&&0<=H);break}}}finally{be=!1,Error.prepareStackTrace=m}return(u=u?u.displayName||u.name:"")?he(u):""}function nt(u){switch(u.tag){case 5:return he(u.type);case 16:return he("Lazy");case 13:return he("Suspense");case 19:return he("SuspenseList");case 0:case 2:case 15:return u=We(u.type,!1),u;case 11:return u=We(u.type.render,!1),u;case 1:return u=We(u.type,!0),u;default:return""}}function Xe(u){if(u==null)return null;if(typeof u=="function")return u.displayName||u.name||null;if(typeof u=="string")return u;switch(u){case O:return"Fragment";case F:return"Portal";case B:return"Profiler";case M:return"StrictMode";case ae:return"Suspense";case pe:return"SuspenseList"}if(typeof u=="object")switch(u.$$typeof){case A:return(u.displayName||"Context")+".Consumer";case V:return(u._context.displayName||"Context")+".Provider";case re:var h=u.render;return u=u.displayName,u||(u=h.displayName||h.name||"",u=u!==""?"ForwardRef("+u+")":"ForwardRef"),u;case ye:return h=u.displayName||null,h!==null?h:Xe(u.type)||"Memo";case ve:h=u._payload,u=u._init;try{return Xe(u(h))}catch{}}return null}function kt(u){var h=u.type;switch(u.tag){case 24:return"Cache";case 9:return(h.displayName||"Context")+".Consumer";case 10:return(h._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return u=h.render,u=u.displayName||u.name||"",h.displayName||(u!==""?"ForwardRef("+u+")":"ForwardRef");case 7:return"Fragment";case 5:return h;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Xe(h);case 8:return h===M?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof h=="function")return h.displayName||h.name||null;if(typeof h=="string")return h}return null}function mt(u){switch(typeof u){case"boolean":case"number":case"string":case"undefined":return u;case"object":return u;default:return""}}function Et(u){var h=u.type;return(u=u.nodeName)&&u.toLowerCase()==="input"&&(h==="checkbox"||h==="radio")}function rn(u){var h=Et(u)?"checked":"value",m=Object.getOwnPropertyDescriptor(u.constructor.prototype,h),b=""+u[h];if(!u.hasOwnProperty(h)&&typeof m<"u"&&typeof m.get=="function"&&typeof m.set=="function"){var C=m.get,T=m.set;return Object.defineProperty(u,h,{configurable:!0,get:function(){return C.call(this)},set:function(D){b=""+D,T.call(this,D)}}),Object.defineProperty(u,h,{enumerable:m.enumerable}),{getValue:function(){return b},setValue:function(D){b=""+D},stopTracking:function(){u._valueTracker=null,delete u[h]}}}}function Jn(u){u._valueTracker||(u._valueTracker=rn(u))}function Ls(u){if(!u)return!1;var h=u._valueTracker;if(!h)return!0;var m=h.getValue(),b="";return u&&(b=Et(u)?u.checked?"true":"false":u.value),u=b,u!==m?(h.setValue(u),!0):!1}function Wt(u){if(u=u||(typeof document<"u"?document:void 0),typeof u>"u")return null;try{return u.activeElement||u.body}catch{return u.body}}function bn(u,h){var m=h.checked;return ge({},h,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:m??u._wrapperState.initialChecked})}function Il(u,h){var m=h.defaultValue==null?"":h.defaultValue,b=h.checked!=null?h.checked:h.defaultChecked;m=mt(h.value!=null?h.value:m),u._wrapperState={initialChecked:b,initialValue:m,controlled:h.type==="checkbox"||h.type==="radio"?h.checked!=null:h.value!=null}}function Xu(u,h){h=h.checked,h!=null&&I(u,"checked",h,!1)}function ka(u,h){Xu(u,h);var m=mt(h.value),b=h.type;if(m!=null)b==="number"?(m===0&&u.value===""||u.value!=m)&&(u.value=""+m):u.value!==""+m&&(u.value=""+m);else if(b==="submit"||b==="reset"){u.removeAttribute("value");return}h.hasOwnProperty("value")?Ta(u,h.type,m):h.hasOwnProperty("defaultValue")&&Ta(u,h.type,mt(h.defaultValue)),h.checked==null&&h.defaultChecked!=null&&(u.defaultChecked=!!h.defaultChecked)}function Nl(u,h,m){if(h.hasOwnProperty("value")||h.hasOwnProperty("defaultValue")){var b=h.type;if(!(b!=="submit"&&b!=="reset"||h.value!==void 0&&h.value!==null))return;h=""+u._wrapperState.initialValue,m||h===u.value||(u.value=h),u.defaultValue=h}m=u.name,m!==""&&(u.name=""),u.defaultChecked=!!u._wrapperState.initialChecked,m!==""&&(u.name=m)}function Ta(u,h,m){(h!=="number"||Wt(u.ownerDocument)!==u)&&(m==null?u.defaultValue=""+u._wrapperState.initialValue:u.defaultValue!==""+m&&(u.defaultValue=""+m))}var vs=Array.isArray;function bs(u,h,m,b){if(u=u.options,h){h={};for(var C=0;C<m.length;C++)h["$"+m[C]]=!0;for(m=0;m<u.length;m++)C=h.hasOwnProperty("$"+u[m].value),u[m].selected!==C&&(u[m].selected=C),C&&b&&(u[m].defaultSelected=!0)}else{for(m=""+mt(m),h=null,C=0;C<u.length;C++){if(u[C].value===m){u[C].selected=!0,b&&(u[C].defaultSelected=!0);return}h!==null||u[C].disabled||(h=u[C])}h!==null&&(h.selected=!0)}}function zs(u,h){if(h.dangerouslySetInnerHTML!=null)throw Error(n(91));return ge({},h,{value:void 0,defaultValue:void 0,children:""+u._wrapperState.initialValue})}function Kr(u,h){var m=h.value;if(m==null){if(m=h.children,h=h.defaultValue,m!=null){if(h!=null)throw Error(n(92));if(vs(m)){if(1<m.length)throw Error(n(93));m=m[0]}h=m}h==null&&(h=""),m=h}u._wrapperState={initialValue:mt(m)}}function ws(u,h){var m=mt(h.value),b=mt(h.defaultValue);m!=null&&(m=""+m,m!==u.value&&(u.value=m),h.defaultValue==null&&u.defaultValue!==m&&(u.defaultValue=m)),b!=null&&(u.defaultValue=""+b)}function Ia(u){var h=u.textContent;h===u._wrapperState.initialValue&&h!==""&&h!==null&&(u.value=h)}function Ci(u){switch(u){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function $i(u,h){return u==null||u==="http://www.w3.org/1999/xhtml"?Ci(h):u==="http://www.w3.org/2000/svg"&&h==="foreignObject"?"http://www.w3.org/1999/xhtml":u}var mo,Na=function(u){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(h,m,b,C){MSApp.execUnsafeLocalFunction(function(){return u(h,m,b,C)})}:u}(function(u,h){if(u.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in u)u.innerHTML=h;else{for(mo=mo||document.createElement("div"),mo.innerHTML="<svg>"+h.valueOf().toString()+"</svg>",h=mo.firstChild;u.firstChild;)u.removeChild(u.firstChild);for(;h.firstChild;)u.appendChild(h.firstChild)}});function Mo(u,h){if(h){var m=u.firstChild;if(m&&m===u.lastChild&&m.nodeType===3){m.nodeValue=h;return}}u.textContent=h}var go={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},El=["Webkit","ms","Moz","O"];Object.keys(go).forEach(function(u){El.forEach(function(h){h=h+u.charAt(0).toUpperCase()+u.substring(1),go[h]=go[u]})});function Vo(u,h,m){return h==null||typeof h=="boolean"||h===""?"":m||typeof h!="number"||h===0||go.hasOwnProperty(u)&&go[u]?(""+h).trim():h+"px"}function Ea(u,h){u=u.style;for(var m in h)if(h.hasOwnProperty(m)){var b=m.indexOf("--")===0,C=Vo(m,h[m],b);m==="float"&&(m="cssFloat"),b?u.setProperty(m,C):u[m]=C}}var Bs=ge({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function Wo(u,h){if(h){if(Bs[u]&&(h.children!=null||h.dangerouslySetInnerHTML!=null))throw Error(n(137,u));if(h.dangerouslySetInnerHTML!=null){if(h.children!=null)throw Error(n(60));if(typeof h.dangerouslySetInnerHTML!="object"||!("__html"in h.dangerouslySetInnerHTML))throw Error(n(61))}if(h.style!=null&&typeof h.style!="object")throw Error(n(62))}}function Ra(u,h){if(u.indexOf("-")===-1)return typeof h.is=="string";switch(u){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Uo=null;function Ss(u){return u=u.target||u.srcElement||window,u.correspondingUseElement&&(u=u.correspondingUseElement),u.nodeType===3?u.parentNode:u}var Ms=null,_r=null,yo=null;function Xr(u){if(u=Jd(u)){if(typeof Ms!="function")throw Error(n(280));var h=u.stateNode;h&&(h=bp(h),Ms(u.stateNode,u.type,h))}}function Rl(u){_r?yo?yo.push(u):yo=[u]:_r=u}function Vs(){if(_r){var u=_r,h=yo;if(yo=_r=null,Xr(u),h)for(u=0;u<h.length;u++)Xr(h[u])}}function _a(u,h){return u(h)}function _l(){}var jo=!1;function er(u,h,m){if(jo)return u(h,m);jo=!0;try{return _a(u,h,m)}finally{jo=!1,(_r!==null||yo!==null)&&(_l(),Vs())}}function ki(u,h){var m=u.stateNode;if(m===null)return null;var b=bp(m);if(b===null)return null;m=b[h];e:switch(h){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(b=!b.disabled)||(u=u.type,b=!(u==="button"||u==="input"||u==="select"||u==="textarea")),u=!b;break e;default:u=!1}if(u)return null;if(m&&typeof m!="function")throw Error(n(231,h,typeof m));return m}var Ws=!1;if(a)try{var Ti={};Object.defineProperty(Ti,"passive",{get:function(){Ws=!0}}),window.addEventListener("test",Ti,Ti),window.removeEventListener("test",Ti,Ti)}catch{Ws=!1}function Cs(u,h,m,b,C,T,D,H,Y){var ce=Array.prototype.slice.call(arguments,3);try{h.apply(m,ce)}catch(Se){this.onError(Se)}}var Pr=!1,qr=null,Xt=!1,hr=null,Pl={onError:function(u){Pr=!0,qr=u}};function zd(u,h,m,b,C,T,D,H,Y){Pr=!1,qr=null,Cs.apply(Pl,arguments)}function Pa(u,h,m,b,C,T,D,H,Y){if(zd.apply(this,arguments),Pr){if(Pr){var ce=qr;Pr=!1,qr=null}else throw Error(n(198));Xt||(Xt=!0,hr=ce)}}function Bn(u){var h=u,m=u;if(u.alternate)for(;h.return;)h=h.return;else{u=h;do h=u,(h.flags&4098)!==0&&(m=h.return),u=h.return;while(u)}return h.tag===3?m:null}function Ii(u){if(u.tag===13){var h=u.memoizedState;if(h===null&&(u=u.alternate,u!==null&&(h=u.memoizedState)),h!==null)return h.dehydrated}return null}function Go(u){if(Bn(u)!==u)throw Error(n(188))}function qu(u){var h=u.alternate;if(!h){if(h=Bn(u),h===null)throw Error(n(188));return h!==u?null:u}for(var m=u,b=h;;){var C=m.return;if(C===null)break;var T=C.alternate;if(T===null){if(b=C.return,b!==null){m=b;continue}break}if(C.child===T.child){for(T=C.child;T;){if(T===m)return Go(C),u;if(T===b)return Go(C),h;T=T.sibling}throw Error(n(188))}if(m.return!==b.return)m=C,b=T;else{for(var D=!1,H=C.child;H;){if(H===m){D=!0,m=C,b=T;break}if(H===b){D=!0,b=C,m=T;break}H=H.sibling}if(!D){for(H=T.child;H;){if(H===m){D=!0,m=T,b=C;break}if(H===b){D=!0,b=T,m=C;break}H=H.sibling}if(!D)throw Error(n(189))}}if(m.alternate!==b)throw Error(n(190))}if(m.tag!==3)throw Error(n(188));return m.stateNode.current===m?u:h}function Aa(u){return u=qu(u),u!==null?Da(u):null}function Da(u){if(u.tag===5||u.tag===6)return u;for(u=u.child;u!==null;){var h=Da(u);if(h!==null)return h;u=u.sibling}return null}var Al=e.unstable_scheduleCallback,Mn=e.unstable_cancelCallback,Yr=e.unstable_shouldYield,Us=e.unstable_requestPaint,Ut=e.unstable_now,Dl=e.unstable_getCurrentPriorityLevel,xo=e.unstable_ImmediatePriority,Ni=e.unstable_UserBlockingPriority,tr=e.unstable_NormalPriority,Yu=e.unstable_LowPriority,Ei=e.unstable_IdlePriority,Vn=null,nr=null;function Bd(u){if(nr&&typeof nr.onCommitFiberRoot=="function")try{nr.onCommitFiberRoot(Vn,u,void 0,(u.current.flags&128)===128)}catch{}}var fr=Math.clz32?Math.clz32:Vd,Fl=Math.log,Md=Math.LN2;function Vd(u){return u>>>=0,u===0?32:31-(Fl(u)/Md|0)|0}var Ri=64,_i=4194304;function Ho(u){switch(u&-u){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return u&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return u&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return u}}function Pi(u,h){var m=u.pendingLanes;if(m===0)return 0;var b=0,C=u.suspendedLanes,T=u.pingedLanes,D=m&268435455;if(D!==0){var H=D&~C;H!==0?b=Ho(H):(T&=D,T!==0&&(b=Ho(T)))}else D=m&~C,D!==0?b=Ho(D):T!==0&&(b=Ho(T));if(b===0)return 0;if(h!==0&&h!==b&&(h&C)===0&&(C=b&-b,T=h&-h,C>=T||C===16&&(T&4194240)!==0))return h;if((b&4)!==0&&(b|=m&16),h=u.entangledLanes,h!==0)for(u=u.entanglements,h&=b;0<h;)m=31-fr(h),C=1<<m,b|=u[m],h&=~C;return b}function wn(u,h){switch(u){case 1:case 2:case 4:return h+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return h+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Fa(u,h){for(var m=u.suspendedLanes,b=u.pingedLanes,C=u.expirationTimes,T=u.pendingLanes;0<T;){var D=31-fr(T),H=1<<D,Y=C[D];Y===-1?((H&m)===0||(H&b)!==0)&&(C[D]=wn(H,h)):Y<=h&&(u.expiredLanes|=H),T&=~H}}function Oa(u){return u=u.pendingLanes&-1073741825,u!==0?u:u&1073741824?1073741824:0}function Ai(){var u=Ri;return Ri<<=1,(Ri&4194240)===0&&(Ri=64),u}function Di(u){for(var h=[],m=0;31>m;m++)h.push(u);return h}function Ko(u,h,m){u.pendingLanes|=h,h!==536870912&&(u.suspendedLanes=0,u.pingedLanes=0),u=u.eventTimes,h=31-fr(h),u[h]=m}function Wd(u,h){var m=u.pendingLanes&~h;u.pendingLanes=h,u.suspendedLanes=0,u.pingedLanes=0,u.expiredLanes&=h,u.mutableReadLanes&=h,u.entangledLanes&=h,h=u.entanglements;var b=u.eventTimes;for(u=u.expirationTimes;0<m;){var C=31-fr(m),T=1<<C;h[C]=0,b[C]=-1,u[C]=-1,m&=~T}}function Ol(u,h){var m=u.entangledLanes|=h;for(u=u.entanglements;m;){var b=31-fr(m),C=1<<b;C&h|u[b]&h&&(u[b]|=h),m&=~C}}var wt=0;function Ll(u){return u&=-u,1<u?4<u?(u&268435455)!==0?16:536870912:4:1}var Fi,La,Oi,Xo,Qu,zl=!1,vo=[],Qr=null,pr=null,Wn=null,Li=new Map,qo=new Map,Zr=[],Zu="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Jr(u,h){switch(u){case"focusin":case"focusout":Qr=null;break;case"dragenter":case"dragleave":pr=null;break;case"mouseover":case"mouseout":Wn=null;break;case"pointerover":case"pointerout":Li.delete(h.pointerId);break;case"gotpointercapture":case"lostpointercapture":qo.delete(h.pointerId)}}function es(u,h,m,b,C,T){return u===null||u.nativeEvent!==T?(u={blockedOn:h,domEventName:m,eventSystemFlags:b,nativeEvent:T,targetContainers:[C]},h!==null&&(h=Jd(h),h!==null&&La(h)),u):(u.eventSystemFlags|=b,h=u.targetContainers,C!==null&&h.indexOf(C)===-1&&h.push(C),u)}function Ju(u,h,m,b,C){switch(h){case"focusin":return Qr=es(Qr,u,h,m,b,C),!0;case"dragenter":return pr=es(pr,u,h,m,b,C),!0;case"mouseover":return Wn=es(Wn,u,h,m,b,C),!0;case"pointerover":var T=C.pointerId;return Li.set(T,es(Li.get(T)||null,u,h,m,b,C)),!0;case"gotpointercapture":return T=C.pointerId,qo.set(T,es(qo.get(T)||null,u,h,m,b,C)),!0}return!1}function bo(u){var h=jl(u.target);if(h!==null){var m=Bn(h);if(m!==null){if(h=m.tag,h===13){if(h=Ii(m),h!==null){u.blockedOn=h,Qu(u.priority,function(){Oi(m)});return}}else if(h===3&&m.stateNode.current.memoizedState.isDehydrated){u.blockedOn=m.tag===3?m.stateNode.containerInfo:null;return}}}u.blockedOn=null}function Un(u){if(u.blockedOn!==null)return!1;for(var h=u.targetContainers;0<h.length;){var m=Tt(u.domEventName,u.eventSystemFlags,h[0],u.nativeEvent);if(m===null){m=u.nativeEvent;var b=new m.constructor(m.type,m);Uo=b,m.target.dispatchEvent(b),Uo=null}else return h=Jd(m),h!==null&&La(h),u.blockedOn=m,!1;h.shift()}return!0}function Bl(u,h,m){Un(u)&&m.delete(h)}function Ud(){zl=!1,Qr!==null&&Un(Qr)&&(Qr=null),pr!==null&&Un(pr)&&(pr=null),Wn!==null&&Un(Wn)&&(Wn=null),Li.forEach(Bl),qo.forEach(Bl)}function Yo(u,h){u.blockedOn===h&&(u.blockedOn=null,zl||(zl=!0,e.unstable_scheduleCallback(e.unstable_NormalPriority,Ud)))}function wo(u){function h(C){return Yo(C,u)}if(0<vo.length){Yo(vo[0],u);for(var m=1;m<vo.length;m++){var b=vo[m];b.blockedOn===u&&(b.blockedOn=null)}}for(Qr!==null&&Yo(Qr,u),pr!==null&&Yo(pr,u),Wn!==null&&Yo(Wn,u),Li.forEach(h),qo.forEach(h),m=0;m<Zr.length;m++)b=Zr[m],b.blockedOn===u&&(b.blockedOn=null);for(;0<Zr.length&&(m=Zr[0],m.blockedOn===null);)bo(m),m.blockedOn===null&&Zr.shift()}var js=R.ReactCurrentBatchConfig,U=!0;function J(u,h,m,b){var C=wt,T=js.transition;js.transition=null;try{wt=1,Oe(u,h,m,b)}finally{wt=C,js.transition=T}}function de(u,h,m,b){var C=wt,T=js.transition;js.transition=null;try{wt=4,Oe(u,h,m,b)}finally{wt=C,js.transition=T}}function Oe(u,h,m,b){if(U){var C=Tt(u,h,m,b);if(C===null)Hy(u,h,b,dt,m),Jr(u,b);else if(Ju(C,u,h,m,b))b.stopPropagation();else if(Jr(u,b),h&4&&-1<Zu.indexOf(u)){for(;C!==null;){var T=Jd(C);if(T!==null&&Fi(T),T=Tt(u,h,m,b),T===null&&Hy(u,h,b,dt,m),T===C)break;C=T}C!==null&&b.stopPropagation()}else Hy(u,h,b,null,m)}}var dt=null;function Tt(u,h,m,b){if(dt=null,u=Ss(b),u=jl(u),u!==null)if(h=Bn(u),h===null)u=null;else if(m=h.tag,m===13){if(u=Ii(h),u!==null)return u;u=null}else if(m===3){if(h.stateNode.current.memoizedState.isDehydrated)return h.tag===3?h.stateNode.containerInfo:null;u=null}else h!==u&&(u=null);return dt=u,null}function It(u){switch(u){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Dl()){case xo:return 1;case Ni:return 4;case tr:case Yu:return 16;case Ei:return 536870912;default:return 16}default:return 16}}var at=null,_t=null,jn=null;function Gn(){if(jn)return jn;var u,h=_t,m=h.length,b,C="value"in at?at.value:at.textContent,T=C.length;for(u=0;u<m&&h[u]===C[u];u++);var D=m-u;for(b=1;b<=D&&h[m-b]===C[T-b];b++);return jn=C.slice(u,1<b?1-b:void 0)}function Ar(u){var h=u.keyCode;return"charCode"in u?(u=u.charCode,u===0&&h===13&&(u=13)):u=h,u===10&&(u=13),32<=u||u===13?u:0}function So(){return!0}function za(){return!1}function Rn(u){function h(m,b,C,T,D){this._reactName=m,this._targetInst=C,this.type=b,this.nativeEvent=T,this.target=D,this.currentTarget=null;for(var H in u)u.hasOwnProperty(H)&&(m=u[H],this[H]=m?m(T):T[H]);return this.isDefaultPrevented=(T.defaultPrevented!=null?T.defaultPrevented:T.returnValue===!1)?So:za,this.isPropagationStopped=za,this}return ge(h.prototype,{preventDefault:function(){this.defaultPrevented=!0;var m=this.nativeEvent;m&&(m.preventDefault?m.preventDefault():typeof m.returnValue!="unknown"&&(m.returnValue=!1),this.isDefaultPrevented=So)},stopPropagation:function(){var m=this.nativeEvent;m&&(m.stopPropagation?m.stopPropagation():typeof m.cancelBubble!="unknown"&&(m.cancelBubble=!0),this.isPropagationStopped=So)},persist:function(){},isPersistent:So}),h}var Ba={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(u){return u.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},jd=Rn(Ba),zi=ge({},Ba,{view:0,detail:0}),Gd=Rn(zi),ec,Hd,Ml,tc=ge({},zi,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:k,button:0,buttons:0,relatedTarget:function(u){return u.relatedTarget===void 0?u.fromElement===u.srcElement?u.toElement:u.fromElement:u.relatedTarget},movementX:function(u){return"movementX"in u?u.movementX:(u!==Ml&&(Ml&&u.type==="mousemove"?(ec=u.screenX-Ml.screenX,Hd=u.screenY-Ml.screenY):Hd=ec=0,Ml=u),ec)},movementY:function(u){return"movementY"in u?u.movementY:Hd}}),ip=Rn(tc),ap=ge({},tc,{dataTransfer:0}),Ey=Rn(ap),Ry=ge({},zi,{relatedTarget:0}),Vl=Rn(Ry),_y=ge({},Ba,{animationName:0,elapsedTime:0,pseudoElement:0}),Py=Rn(_y),Ay=ge({},Ba,{clipboardData:function(u){return"clipboardData"in u?u.clipboardData:window.clipboardData}}),nc=Rn(Ay),Dy=ge({},Ba,{data:0}),lp=Rn(Dy),Fy={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},up={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},cp={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function v(u){var h=this.nativeEvent;return h.getModifierState?h.getModifierState(u):(u=cp[u])?!!h[u]:!1}function k(){return v}var E=ge({},zi,{key:function(u){if(u.key){var h=Fy[u.key]||u.key;if(h!=="Unidentified")return h}return u.type==="keypress"?(u=Ar(u),u===13?"Enter":String.fromCharCode(u)):u.type==="keydown"||u.type==="keyup"?up[u.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:k,charCode:function(u){return u.type==="keypress"?Ar(u):0},keyCode:function(u){return u.type==="keydown"||u.type==="keyup"?u.keyCode:0},which:function(u){return u.type==="keypress"?Ar(u):u.type==="keydown"||u.type==="keyup"?u.keyCode:0}}),P=Rn(E),W=ge({},tc,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),G=Rn(W),j=ge({},zi,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:k}),Z=Rn(j),ue=ge({},Ba,{propertyName:0,elapsedTime:0,pseudoElement:0}),Ce=Rn(ue),_e=ge({},tc,{deltaX:function(u){return"deltaX"in u?u.deltaX:"wheelDeltaX"in u?-u.wheelDeltaX:0},deltaY:function(u){return"deltaY"in u?u.deltaY:"wheelDeltaY"in u?-u.wheelDeltaY:"wheelDelta"in u?-u.wheelDelta:0},deltaZ:0,deltaMode:0}),Je=Rn(_e),He=[9,13,27,32],Ae=a&&"CompositionEvent"in window,Ke=null;a&&"documentMode"in document&&(Ke=document.documentMode);var ht=a&&"TextEvent"in window&&!Ke,qt=a&&(!Ae||Ke&&8<Ke&&11>=Ke),jt=" ",Tn=!1;function Dr(u,h){switch(u){case"keyup":return He.indexOf(h.keyCode)!==-1;case"keydown":return h.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function rr(u){return u=u.detail,typeof u=="object"&&"data"in u?u.data:null}var yt=!1;function _n(u,h){switch(u){case"compositionend":return rr(h);case"keypress":return h.which!==32?null:(Tn=!0,jt);case"textInput":return u=h.data,u===jt&&Tn?null:u;default:return null}}function Qo(u,h){if(yt)return u==="compositionend"||!Ae&&Dr(u,h)?(u=Gn(),jn=_t=at=null,yt=!1,u):null;switch(u){case"paste":return null;case"keypress":if(!(h.ctrlKey||h.altKey||h.metaKey)||h.ctrlKey&&h.altKey){if(h.char&&1<h.char.length)return h.char;if(h.which)return String.fromCharCode(h.which)}return null;case"compositionend":return qt&&h.locale!=="ko"?null:h.data;default:return null}}var Oy={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function dp(u){var h=u&&u.nodeName&&u.nodeName.toLowerCase();return h==="input"?!!Oy[u.type]:h==="textarea"}function hp(u,h,m,b){Rl(b),h=yp(h,"onChange"),0<h.length&&(m=new jd("onChange","change",null,m,b),u.push({event:m,listeners:h}))}var Wl=null,Ul=null;function rc(u){i$(u,0)}function fp(u){var h=lc(u);if(Ls(h))return u}function o4(u,h){if(u==="change")return h}var UC=!1;if(a){var Ly;if(a){var zy="oninput"in document;if(!zy){var jC=document.createElement("div");jC.setAttribute("oninput","return;"),zy=typeof jC.oninput=="function"}Ly=zy}else Ly=!1;UC=Ly&&(!document.documentMode||9<document.documentMode)}function GC(){Wl&&(Wl.detachEvent("onpropertychange",HC),Ul=Wl=null)}function HC(u){if(u.propertyName==="value"&&fp(Ul)){var h=[];hp(h,Ul,u,Ss(u)),er(rc,h)}}function i4(u,h,m){u==="focusin"?(GC(),Wl=h,Ul=m,Wl.attachEvent("onpropertychange",HC)):u==="focusout"&&GC()}function a4(u){if(u==="selectionchange"||u==="keyup"||u==="keydown")return fp(Ul)}function l4(u,h){if(u==="click")return fp(h)}function u4(u,h){if(u==="input"||u==="change")return fp(h)}function c4(u,h){return u===h&&(u!==0||1/u===1/h)||u!==u&&h!==h}var Co=typeof Object.is=="function"?Object.is:c4;function Kd(u,h){if(Co(u,h))return!0;if(typeof u!="object"||u===null||typeof h!="object"||h===null)return!1;var m=Object.keys(u),b=Object.keys(h);if(m.length!==b.length)return!1;for(b=0;b<m.length;b++){var C=m[b];if(!l.call(h,C)||!Co(u[C],h[C]))return!1}return!0}function KC(u){for(;u&&u.firstChild;)u=u.firstChild;return u}function XC(u,h){var m=KC(u);u=0;for(var b;m;){if(m.nodeType===3){if(b=u+m.textContent.length,u<=h&&b>=h)return{node:m,offset:h-u};u=b}e:{for(;m;){if(m.nextSibling){m=m.nextSibling;break e}m=m.parentNode}m=void 0}m=KC(m)}}function qC(u,h){return u&&h?u===h?!0:u&&u.nodeType===3?!1:h&&h.nodeType===3?qC(u,h.parentNode):"contains"in u?u.contains(h):u.compareDocumentPosition?!!(u.compareDocumentPosition(h)&16):!1:!1}function YC(){for(var u=window,h=Wt();h instanceof u.HTMLIFrameElement;){try{var m=typeof h.contentWindow.location.href=="string"}catch{m=!1}if(m)u=h.contentWindow;else break;h=Wt(u.document)}return h}function By(u){var h=u&&u.nodeName&&u.nodeName.toLowerCase();return h&&(h==="input"&&(u.type==="text"||u.type==="search"||u.type==="tel"||u.type==="url"||u.type==="password")||h==="textarea"||u.contentEditable==="true")}function d4(u){var h=YC(),m=u.focusedElem,b=u.selectionRange;if(h!==m&&m&&m.ownerDocument&&qC(m.ownerDocument.documentElement,m)){if(b!==null&&By(m)){if(h=b.start,u=b.end,u===void 0&&(u=h),"selectionStart"in m)m.selectionStart=h,m.selectionEnd=Math.min(u,m.value.length);else if(u=(h=m.ownerDocument||document)&&h.defaultView||window,u.getSelection){u=u.getSelection();var C=m.textContent.length,T=Math.min(b.start,C);b=b.end===void 0?T:Math.min(b.end,C),!u.extend&&T>b&&(C=b,b=T,T=C),C=XC(m,T);var D=XC(m,b);C&&D&&(u.rangeCount!==1||u.anchorNode!==C.node||u.anchorOffset!==C.offset||u.focusNode!==D.node||u.focusOffset!==D.offset)&&(h=h.createRange(),h.setStart(C.node,C.offset),u.removeAllRanges(),T>b?(u.addRange(h),u.extend(D.node,D.offset)):(h.setEnd(D.node,D.offset),u.addRange(h)))}}for(h=[],u=m;u=u.parentNode;)u.nodeType===1&&h.push({element:u,left:u.scrollLeft,top:u.scrollTop});for(typeof m.focus=="function"&&m.focus(),m=0;m<h.length;m++)u=h[m],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}}var h4=a&&"documentMode"in document&&11>=document.documentMode,sc=null,My=null,Xd=null,Vy=!1;function QC(u,h,m){var b=m.window===m?m.document:m.nodeType===9?m:m.ownerDocument;Vy||sc==null||sc!==Wt(b)||(b=sc,"selectionStart"in b&&By(b)?b={start:b.selectionStart,end:b.selectionEnd}:(b=(b.ownerDocument&&b.ownerDocument.defaultView||window).getSelection(),b={anchorNode:b.anchorNode,anchorOffset:b.anchorOffset,focusNode:b.focusNode,focusOffset:b.focusOffset}),Xd&&Kd(Xd,b)||(Xd=b,b=yp(My,"onSelect"),0<b.length&&(h=new jd("onSelect","select",null,h,m),u.push({event:h,listeners:b}),h.target=sc)))}function pp(u,h){var m={};return m[u.toLowerCase()]=h.toLowerCase(),m["Webkit"+u]="webkit"+h,m["Moz"+u]="moz"+h,m}var oc={animationend:pp("Animation","AnimationEnd"),animationiteration:pp("Animation","AnimationIteration"),animationstart:pp("Animation","AnimationStart"),transitionend:pp("Transition","TransitionEnd")},Wy={},ZC={};a&&(ZC=document.createElement("div").style,"AnimationEvent"in window||(delete oc.animationend.animation,delete oc.animationiteration.animation,delete oc.animationstart.animation),"TransitionEvent"in window||delete oc.transitionend.transition);function mp(u){if(Wy[u])return Wy[u];if(!oc[u])return u;var h=oc[u],m;for(m in h)if(h.hasOwnProperty(m)&&m in ZC)return Wy[u]=h[m];return u}var JC=mp("animationend"),e$=mp("animationiteration"),t$=mp("animationstart"),n$=mp("transitionend"),r$=new Map,s$="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Ma(u,h){r$.set(u,h),o(h,[u])}for(var Uy=0;Uy<s$.length;Uy++){var jy=s$[Uy],f4=jy.toLowerCase(),p4=jy[0].toUpperCase()+jy.slice(1);Ma(f4,"on"+p4)}Ma(JC,"onAnimationEnd"),Ma(e$,"onAnimationIteration"),Ma(t$,"onAnimationStart"),Ma("dblclick","onDoubleClick"),Ma("focusin","onFocus"),Ma("focusout","onBlur"),Ma(n$,"onTransitionEnd"),i("onMouseEnter",["mouseout","mouseover"]),i("onMouseLeave",["mouseout","mouseover"]),i("onPointerEnter",["pointerout","pointerover"]),i("onPointerLeave",["pointerout","pointerover"]),o("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),o("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),o("onBeforeInput",["compositionend","keypress","textInput","paste"]),o("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),o("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),o("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var qd="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),m4=new Set("cancel close invalid load scroll toggle".split(" ").concat(qd));function o$(u,h,m){var b=u.type||"unknown-event";u.currentTarget=m,Pa(b,h,void 0,u),u.currentTarget=null}function i$(u,h){h=(h&4)!==0;for(var m=0;m<u.length;m++){var b=u[m],C=b.event;b=b.listeners;e:{var T=void 0;if(h)for(var D=b.length-1;0<=D;D--){var H=b[D],Y=H.instance,ce=H.currentTarget;if(H=H.listener,Y!==T&&C.isPropagationStopped())break e;o$(C,H,ce),T=Y}else for(D=0;D<b.length;D++){if(H=b[D],Y=H.instance,ce=H.currentTarget,H=H.listener,Y!==T&&C.isPropagationStopped())break e;o$(C,H,ce),T=Y}}}if(Xt)throw u=hr,Xt=!1,hr=null,u}function sn(u,h){var m=h[Zy];m===void 0&&(m=h[Zy]=new Set);var b=u+"__bubble";m.has(b)||(a$(h,u,2,!1),m.add(b))}function Gy(u,h,m){var b=0;h&&(b|=4),a$(m,u,b,h)}var gp="_reactListening"+Math.random().toString(36).slice(2);function Yd(u){if(!u[gp]){u[gp]=!0,r.forEach(function(m){m!=="selectionchange"&&(m4.has(m)||Gy(m,!1,u),Gy(m,!0,u))});var h=u.nodeType===9?u:u.ownerDocument;h===null||h[gp]||(h[gp]=!0,Gy("selectionchange",!1,h))}}function a$(u,h,m,b){switch(It(h)){case 1:var C=J;break;case 4:C=de;break;default:C=Oe}m=C.bind(null,h,m,u),C=void 0,!Ws||h!=="touchstart"&&h!=="touchmove"&&h!=="wheel"||(C=!0),b?C!==void 0?u.addEventListener(h,m,{capture:!0,passive:C}):u.addEventListener(h,m,!0):C!==void 0?u.addEventListener(h,m,{passive:C}):u.addEventListener(h,m,!1)}function Hy(u,h,m,b,C){var T=b;if((h&1)===0&&(h&2)===0&&b!==null)e:for(;;){if(b===null)return;var D=b.tag;if(D===3||D===4){var H=b.stateNode.containerInfo;if(H===C||H.nodeType===8&&H.parentNode===C)break;if(D===4)for(D=b.return;D!==null;){var Y=D.tag;if((Y===3||Y===4)&&(Y=D.stateNode.containerInfo,Y===C||Y.nodeType===8&&Y.parentNode===C))return;D=D.return}for(;H!==null;){if(D=jl(H),D===null)return;if(Y=D.tag,Y===5||Y===6){b=T=D;continue e}H=H.parentNode}}b=b.return}er(function(){var ce=T,Se=Ss(m),ke=[];e:{var we=r$.get(u);if(we!==void 0){var Le=jd,Me=u;switch(u){case"keypress":if(Ar(m)===0)break e;case"keydown":case"keyup":Le=P;break;case"focusin":Me="focus",Le=Vl;break;case"focusout":Me="blur",Le=Vl;break;case"beforeblur":case"afterblur":Le=Vl;break;case"click":if(m.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":Le=ip;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":Le=Ey;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":Le=Z;break;case JC:case e$:case t$:Le=Py;break;case n$:Le=Ce;break;case"scroll":Le=Gd;break;case"wheel":Le=Je;break;case"copy":case"cut":case"paste":Le=nc;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":Le=G}var je=(h&4)!==0,Sn=!je&&u==="scroll",ie=je?we!==null?we+"Capture":null:we;je=[];for(var te=ce,le;te!==null;){le=te;var Ie=le.stateNode;if(le.tag===5&&Ie!==null&&(le=Ie,ie!==null&&(Ie=ki(te,ie),Ie!=null&&je.push(Qd(te,Ie,le)))),Sn)break;te=te.return}0<je.length&&(we=new Le(we,Me,null,m,Se),ke.push({event:we,listeners:je}))}}if((h&7)===0){e:{if(we=u==="mouseover"||u==="pointerover",Le=u==="mouseout"||u==="pointerout",we&&m!==Uo&&(Me=m.relatedTarget||m.fromElement)&&(jl(Me)||Me[Bi]))break e;if((Le||we)&&(we=Se.window===Se?Se:(we=Se.ownerDocument)?we.defaultView||we.parentWindow:window,Le?(Me=m.relatedTarget||m.toElement,Le=ce,Me=Me?jl(Me):null,Me!==null&&(Sn=Bn(Me),Me!==Sn||Me.tag!==5&&Me.tag!==6)&&(Me=null)):(Le=null,Me=ce),Le!==Me)){if(je=ip,Ie="onMouseLeave",ie="onMouseEnter",te="mouse",(u==="pointerout"||u==="pointerover")&&(je=G,Ie="onPointerLeave",ie="onPointerEnter",te="pointer"),Sn=Le==null?we:lc(Le),le=Me==null?we:lc(Me),we=new je(Ie,te+"leave",Le,m,Se),we.target=Sn,we.relatedTarget=le,Ie=null,jl(Se)===ce&&(je=new je(ie,te+"enter",Me,m,Se),je.target=le,je.relatedTarget=Sn,Ie=je),Sn=Ie,Le&&Me)t:{for(je=Le,ie=Me,te=0,le=je;le;le=ic(le))te++;for(le=0,Ie=ie;Ie;Ie=ic(Ie))le++;for(;0<te-le;)je=ic(je),te--;for(;0<le-te;)ie=ic(ie),le--;for(;te--;){if(je===ie||ie!==null&&je===ie.alternate)break t;je=ic(je),ie=ic(ie)}je=null}else je=null;Le!==null&&l$(ke,we,Le,je,!1),Me!==null&&Sn!==null&&l$(ke,Sn,Me,je,!0)}}e:{if(we=ce?lc(ce):window,Le=we.nodeName&&we.nodeName.toLowerCase(),Le==="select"||Le==="input"&&we.type==="file")var Ge=o4;else if(dp(we))if(UC)Ge=u4;else{Ge=a4;var qe=i4}else(Le=we.nodeName)&&Le.toLowerCase()==="input"&&(we.type==="checkbox"||we.type==="radio")&&(Ge=l4);if(Ge&&(Ge=Ge(u,ce))){hp(ke,Ge,m,Se);break e}qe&&qe(u,we,ce),u==="focusout"&&(qe=we._wrapperState)&&qe.controlled&&we.type==="number"&&Ta(we,"number",we.value)}switch(qe=ce?lc(ce):window,u){case"focusin":(dp(qe)||qe.contentEditable==="true")&&(sc=qe,My=ce,Xd=null);break;case"focusout":Xd=My=sc=null;break;case"mousedown":Vy=!0;break;case"contextmenu":case"mouseup":case"dragend":Vy=!1,QC(ke,m,Se);break;case"selectionchange":if(h4)break;case"keydown":case"keyup":QC(ke,m,Se)}var Ye;if(Ae)e:{switch(u){case"compositionstart":var st="onCompositionStart";break e;case"compositionend":st="onCompositionEnd";break e;case"compositionupdate":st="onCompositionUpdate";break e}st=void 0}else yt?Dr(u,m)&&(st="onCompositionEnd"):u==="keydown"&&m.keyCode===229&&(st="onCompositionStart");st&&(qt&&m.locale!=="ko"&&(yt||st!=="onCompositionStart"?st==="onCompositionEnd"&&yt&&(Ye=Gn()):(at=Se,_t="value"in at?at.value:at.textContent,yt=!0)),qe=yp(ce,st),0<qe.length&&(st=new lp(st,u,null,m,Se),ke.push({event:st,listeners:qe}),Ye?st.data=Ye:(Ye=rr(m),Ye!==null&&(st.data=Ye)))),(Ye=ht?_n(u,m):Qo(u,m))&&(ce=yp(ce,"onBeforeInput"),0<ce.length&&(Se=new lp("onBeforeInput","beforeinput",null,m,Se),ke.push({event:Se,listeners:ce}),Se.data=Ye))}i$(ke,h)})}function Qd(u,h,m){return{instance:u,listener:h,currentTarget:m}}function yp(u,h){for(var m=h+"Capture",b=[];u!==null;){var C=u,T=C.stateNode;C.tag===5&&T!==null&&(C=T,T=ki(u,m),T!=null&&b.unshift(Qd(u,T,C)),T=ki(u,h),T!=null&&b.push(Qd(u,T,C))),u=u.return}return b}function ic(u){if(u===null)return null;do u=u.return;while(u&&u.tag!==5);return u||null}function l$(u,h,m,b,C){for(var T=h._reactName,D=[];m!==null&&m!==b;){var H=m,Y=H.alternate,ce=H.stateNode;if(Y!==null&&Y===b)break;H.tag===5&&ce!==null&&(H=ce,C?(Y=ki(m,T),Y!=null&&D.unshift(Qd(m,Y,H))):C||(Y=ki(m,T),Y!=null&&D.push(Qd(m,Y,H)))),m=m.return}D.length!==0&&u.push({event:h,listeners:D})}var g4=/\r\n?/g,y4=/\u0000|\uFFFD/g;function u$(u){return(typeof u=="string"?u:""+u).replace(g4,`
`).replace(y4,"")}function xp(u,h,m){if(h=u$(h),u$(u)!==h&&m)throw Error(n(425))}function vp(){}var Ky=null,Xy=null;function qy(u,h){return u==="textarea"||u==="noscript"||typeof h.children=="string"||typeof h.children=="number"||typeof h.dangerouslySetInnerHTML=="object"&&h.dangerouslySetInnerHTML!==null&&h.dangerouslySetInnerHTML.__html!=null}var Yy=typeof setTimeout=="function"?setTimeout:void 0,x4=typeof clearTimeout=="function"?clearTimeout:void 0,c$=typeof Promise=="function"?Promise:void 0,v4=typeof queueMicrotask=="function"?queueMicrotask:typeof c$<"u"?function(u){return c$.resolve(null).then(u).catch(b4)}:Yy;function b4(u){setTimeout(function(){throw u})}function Qy(u,h){var m=h,b=0;do{var C=m.nextSibling;if(u.removeChild(m),C&&C.nodeType===8)if(m=C.data,m==="/$"){if(b===0){u.removeChild(C),wo(h);return}b--}else m!=="$"&&m!=="$?"&&m!=="$!"||b++;m=C}while(m);wo(h)}function Va(u){for(;u!=null;u=u.nextSibling){var h=u.nodeType;if(h===1||h===3)break;if(h===8){if(h=u.data,h==="$"||h==="$!"||h==="$?")break;if(h==="/$")return null}}return u}function d$(u){u=u.previousSibling;for(var h=0;u;){if(u.nodeType===8){var m=u.data;if(m==="$"||m==="$!"||m==="$?"){if(h===0)return u;h--}else m==="/$"&&h++}u=u.previousSibling}return null}var ac=Math.random().toString(36).slice(2),Zo="__reactFiber$"+ac,Zd="__reactProps$"+ac,Bi="__reactContainer$"+ac,Zy="__reactEvents$"+ac,w4="__reactListeners$"+ac,S4="__reactHandles$"+ac;function jl(u){var h=u[Zo];if(h)return h;for(var m=u.parentNode;m;){if(h=m[Bi]||m[Zo]){if(m=h.alternate,h.child!==null||m!==null&&m.child!==null)for(u=d$(u);u!==null;){if(m=u[Zo])return m;u=d$(u)}return h}u=m,m=u.parentNode}return null}function Jd(u){return u=u[Zo]||u[Bi],!u||u.tag!==5&&u.tag!==6&&u.tag!==13&&u.tag!==3?null:u}function lc(u){if(u.tag===5||u.tag===6)return u.stateNode;throw Error(n(33))}function bp(u){return u[Zd]||null}var Jy=[],uc=-1;function Wa(u){return{current:u}}function on(u){0>uc||(u.current=Jy[uc],Jy[uc]=null,uc--)}function Jt(u,h){uc++,Jy[uc]=u.current,u.current=h}var Ua={},mr=Wa(Ua),ts=Wa(!1),Gl=Ua;function cc(u,h){var m=u.type.contextTypes;if(!m)return Ua;var b=u.stateNode;if(b&&b.__reactInternalMemoizedUnmaskedChildContext===h)return b.__reactInternalMemoizedMaskedChildContext;var C={},T;for(T in m)C[T]=h[T];return b&&(u=u.stateNode,u.__reactInternalMemoizedUnmaskedChildContext=h,u.__reactInternalMemoizedMaskedChildContext=C),C}function ns(u){return u=u.childContextTypes,u!=null}function wp(){on(ts),on(mr)}function h$(u,h,m){if(mr.current!==Ua)throw Error(n(168));Jt(mr,h),Jt(ts,m)}function f$(u,h,m){var b=u.stateNode;if(h=h.childContextTypes,typeof b.getChildContext!="function")return m;b=b.getChildContext();for(var C in b)if(!(C in h))throw Error(n(108,kt(u)||"Unknown",C));return ge({},m,b)}function Sp(u){return u=(u=u.stateNode)&&u.__reactInternalMemoizedMergedChildContext||Ua,Gl=mr.current,Jt(mr,u),Jt(ts,ts.current),!0}function p$(u,h,m){var b=u.stateNode;if(!b)throw Error(n(169));m?(u=f$(u,h,Gl),b.__reactInternalMemoizedMergedChildContext=u,on(ts),on(mr),Jt(mr,u)):on(ts),Jt(ts,m)}var Mi=null,Cp=!1,e0=!1;function m$(u){Mi===null?Mi=[u]:Mi.push(u)}function C4(u){Cp=!0,m$(u)}function ja(){if(!e0&&Mi!==null){e0=!0;var u=0,h=wt;try{var m=Mi;for(wt=1;u<m.length;u++){var b=m[u];do b=b(!0);while(b!==null)}Mi=null,Cp=!1}catch(C){throw Mi!==null&&(Mi=Mi.slice(u+1)),Al(xo,ja),C}finally{wt=h,e0=!1}}return null}var dc=[],hc=0,$p=null,kp=0,Gs=[],Hs=0,Hl=null,Vi=1,Wi="";function Kl(u,h){dc[hc++]=kp,dc[hc++]=$p,$p=u,kp=h}function g$(u,h,m){Gs[Hs++]=Vi,Gs[Hs++]=Wi,Gs[Hs++]=Hl,Hl=u;var b=Vi;u=Wi;var C=32-fr(b)-1;b&=~(1<<C),m+=1;var T=32-fr(h)+C;if(30<T){var D=C-C%5;T=(b&(1<<D)-1).toString(32),b>>=D,C-=D,Vi=1<<32-fr(h)+C|m<<C|b,Wi=T+u}else Vi=1<<T|m<<C|b,Wi=u}function t0(u){u.return!==null&&(Kl(u,1),g$(u,1,0))}function n0(u){for(;u===$p;)$p=dc[--hc],dc[hc]=null,kp=dc[--hc],dc[hc]=null;for(;u===Hl;)Hl=Gs[--Hs],Gs[Hs]=null,Wi=Gs[--Hs],Gs[Hs]=null,Vi=Gs[--Hs],Gs[Hs]=null}var $s=null,ks=null,ln=!1,$o=null;function y$(u,h){var m=Ys(5,null,null,0);m.elementType="DELETED",m.stateNode=h,m.return=u,h=u.deletions,h===null?(u.deletions=[m],u.flags|=16):h.push(m)}function x$(u,h){switch(u.tag){case 5:var m=u.type;return h=h.nodeType!==1||m.toLowerCase()!==h.nodeName.toLowerCase()?null:h,h!==null?(u.stateNode=h,$s=u,ks=Va(h.firstChild),!0):!1;case 6:return h=u.pendingProps===""||h.nodeType!==3?null:h,h!==null?(u.stateNode=h,$s=u,ks=null,!0):!1;case 13:return h=h.nodeType!==8?null:h,h!==null?(m=Hl!==null?{id:Vi,overflow:Wi}:null,u.memoizedState={dehydrated:h,treeContext:m,retryLane:1073741824},m=Ys(18,null,null,0),m.stateNode=h,m.return=u,u.child=m,$s=u,ks=null,!0):!1;default:return!1}}function r0(u){return(u.mode&1)!==0&&(u.flags&128)===0}function s0(u){if(ln){var h=ks;if(h){var m=h;if(!x$(u,h)){if(r0(u))throw Error(n(418));h=Va(m.nextSibling);var b=$s;h&&x$(u,h)?y$(b,m):(u.flags=u.flags&-4097|2,ln=!1,$s=u)}}else{if(r0(u))throw Error(n(418));u.flags=u.flags&-4097|2,ln=!1,$s=u}}}function v$(u){for(u=u.return;u!==null&&u.tag!==5&&u.tag!==3&&u.tag!==13;)u=u.return;$s=u}function Tp(u){if(u!==$s)return!1;if(!ln)return v$(u),ln=!0,!1;var h;if((h=u.tag!==3)&&!(h=u.tag!==5)&&(h=u.type,h=h!=="head"&&h!=="body"&&!qy(u.type,u.memoizedProps)),h&&(h=ks)){if(r0(u))throw b$(),Error(n(418));for(;h;)y$(u,h),h=Va(h.nextSibling)}if(v$(u),u.tag===13){if(u=u.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(n(317));e:{for(u=u.nextSibling,h=0;u;){if(u.nodeType===8){var m=u.data;if(m==="/$"){if(h===0){ks=Va(u.nextSibling);break e}h--}else m!=="$"&&m!=="$!"&&m!=="$?"||h++}u=u.nextSibling}ks=null}}else ks=$s?Va(u.stateNode.nextSibling):null;return!0}function b$(){for(var u=ks;u;)u=Va(u.nextSibling)}function fc(){ks=$s=null,ln=!1}function o0(u){$o===null?$o=[u]:$o.push(u)}var $4=R.ReactCurrentBatchConfig;function eh(u,h,m){if(u=m.ref,u!==null&&typeof u!="function"&&typeof u!="object"){if(m._owner){if(m=m._owner,m){if(m.tag!==1)throw Error(n(309));var b=m.stateNode}if(!b)throw Error(n(147,u));var C=b,T=""+u;return h!==null&&h.ref!==null&&typeof h.ref=="function"&&h.ref._stringRef===T?h.ref:(h=function(D){var H=C.refs;D===null?delete H[T]:H[T]=D},h._stringRef=T,h)}if(typeof u!="string")throw Error(n(284));if(!m._owner)throw Error(n(290,u))}return u}function Ip(u,h){throw u=Object.prototype.toString.call(h),Error(n(31,u==="[object Object]"?"object with keys {"+Object.keys(h).join(", ")+"}":u))}function w$(u){var h=u._init;return h(u._payload)}function S$(u){function h(ie,te){if(u){var le=ie.deletions;le===null?(ie.deletions=[te],ie.flags|=16):le.push(te)}}function m(ie,te){if(!u)return null;for(;te!==null;)h(ie,te),te=te.sibling;return null}function b(ie,te){for(ie=new Map;te!==null;)te.key!==null?ie.set(te.key,te):ie.set(te.index,te),te=te.sibling;return ie}function C(ie,te){return ie=Za(ie,te),ie.index=0,ie.sibling=null,ie}function T(ie,te,le){return ie.index=le,u?(le=ie.alternate,le!==null?(le=le.index,le<te?(ie.flags|=2,te):le):(ie.flags|=2,te)):(ie.flags|=1048576,te)}function D(ie){return u&&ie.alternate===null&&(ie.flags|=2),ie}function H(ie,te,le,Ie){return te===null||te.tag!==6?(te=Y0(le,ie.mode,Ie),te.return=ie,te):(te=C(te,le),te.return=ie,te)}function Y(ie,te,le,Ie){var Ge=le.type;return Ge===O?Se(ie,te,le.props.children,Ie,le.key):te!==null&&(te.elementType===Ge||typeof Ge=="object"&&Ge!==null&&Ge.$$typeof===ve&&w$(Ge)===te.type)?(Ie=C(te,le.props),Ie.ref=eh(ie,te,le),Ie.return=ie,Ie):(Ie=Qp(le.type,le.key,le.props,null,ie.mode,Ie),Ie.ref=eh(ie,te,le),Ie.return=ie,Ie)}function ce(ie,te,le,Ie){return te===null||te.tag!==4||te.stateNode.containerInfo!==le.containerInfo||te.stateNode.implementation!==le.implementation?(te=Q0(le,ie.mode,Ie),te.return=ie,te):(te=C(te,le.children||[]),te.return=ie,te)}function Se(ie,te,le,Ie,Ge){return te===null||te.tag!==7?(te=tu(le,ie.mode,Ie,Ge),te.return=ie,te):(te=C(te,le),te.return=ie,te)}function ke(ie,te,le){if(typeof te=="string"&&te!==""||typeof te=="number")return te=Y0(""+te,ie.mode,le),te.return=ie,te;if(typeof te=="object"&&te!==null){switch(te.$$typeof){case _:return le=Qp(te.type,te.key,te.props,null,ie.mode,le),le.ref=eh(ie,null,te),le.return=ie,le;case F:return te=Q0(te,ie.mode,le),te.return=ie,te;case ve:var Ie=te._init;return ke(ie,Ie(te._payload),le)}if(vs(te)||me(te))return te=tu(te,ie.mode,le,null),te.return=ie,te;Ip(ie,te)}return null}function we(ie,te,le,Ie){var Ge=te!==null?te.key:null;if(typeof le=="string"&&le!==""||typeof le=="number")return Ge!==null?null:H(ie,te,""+le,Ie);if(typeof le=="object"&&le!==null){switch(le.$$typeof){case _:return le.key===Ge?Y(ie,te,le,Ie):null;case F:return le.key===Ge?ce(ie,te,le,Ie):null;case ve:return Ge=le._init,we(ie,te,Ge(le._payload),Ie)}if(vs(le)||me(le))return Ge!==null?null:Se(ie,te,le,Ie,null);Ip(ie,le)}return null}function Le(ie,te,le,Ie,Ge){if(typeof Ie=="string"&&Ie!==""||typeof Ie=="number")return ie=ie.get(le)||null,H(te,ie,""+Ie,Ge);if(typeof Ie=="object"&&Ie!==null){switch(Ie.$$typeof){case _:return ie=ie.get(Ie.key===null?le:Ie.key)||null,Y(te,ie,Ie,Ge);case F:return ie=ie.get(Ie.key===null?le:Ie.key)||null,ce(te,ie,Ie,Ge);case ve:var qe=Ie._init;return Le(ie,te,le,qe(Ie._payload),Ge)}if(vs(Ie)||me(Ie))return ie=ie.get(le)||null,Se(te,ie,Ie,Ge,null);Ip(te,Ie)}return null}function Me(ie,te,le,Ie){for(var Ge=null,qe=null,Ye=te,st=te=0,Xn=null;Ye!==null&&st<le.length;st++){Ye.index>st?(Xn=Ye,Ye=null):Xn=Ye.sibling;var Rt=we(ie,Ye,le[st],Ie);if(Rt===null){Ye===null&&(Ye=Xn);break}u&&Ye&&Rt.alternate===null&&h(ie,Ye),te=T(Rt,te,st),qe===null?Ge=Rt:qe.sibling=Rt,qe=Rt,Ye=Xn}if(st===le.length)return m(ie,Ye),ln&&Kl(ie,st),Ge;if(Ye===null){for(;st<le.length;st++)Ye=ke(ie,le[st],Ie),Ye!==null&&(te=T(Ye,te,st),qe===null?Ge=Ye:qe.sibling=Ye,qe=Ye);return ln&&Kl(ie,st),Ge}for(Ye=b(ie,Ye);st<le.length;st++)Xn=Le(Ye,ie,st,le[st],Ie),Xn!==null&&(u&&Xn.alternate!==null&&Ye.delete(Xn.key===null?st:Xn.key),te=T(Xn,te,st),qe===null?Ge=Xn:qe.sibling=Xn,qe=Xn);return u&&Ye.forEach(function(Ja){return h(ie,Ja)}),ln&&Kl(ie,st),Ge}function je(ie,te,le,Ie){var Ge=me(le);if(typeof Ge!="function")throw Error(n(150));if(le=Ge.call(le),le==null)throw Error(n(151));for(var qe=Ge=null,Ye=te,st=te=0,Xn=null,Rt=le.next();Ye!==null&&!Rt.done;st++,Rt=le.next()){Ye.index>st?(Xn=Ye,Ye=null):Xn=Ye.sibling;var Ja=we(ie,Ye,Rt.value,Ie);if(Ja===null){Ye===null&&(Ye=Xn);break}u&&Ye&&Ja.alternate===null&&h(ie,Ye),te=T(Ja,te,st),qe===null?Ge=Ja:qe.sibling=Ja,qe=Ja,Ye=Xn}if(Rt.done)return m(ie,Ye),ln&&Kl(ie,st),Ge;if(Ye===null){for(;!Rt.done;st++,Rt=le.next())Rt=ke(ie,Rt.value,Ie),Rt!==null&&(te=T(Rt,te,st),qe===null?Ge=Rt:qe.sibling=Rt,qe=Rt);return ln&&Kl(ie,st),Ge}for(Ye=b(ie,Ye);!Rt.done;st++,Rt=le.next())Rt=Le(Ye,ie,st,Rt.value,Ie),Rt!==null&&(u&&Rt.alternate!==null&&Ye.delete(Rt.key===null?st:Rt.key),te=T(Rt,te,st),qe===null?Ge=Rt:qe.sibling=Rt,qe=Rt);return u&&Ye.forEach(function(rL){return h(ie,rL)}),ln&&Kl(ie,st),Ge}function Sn(ie,te,le,Ie){if(typeof le=="object"&&le!==null&&le.type===O&&le.key===null&&(le=le.props.children),typeof le=="object"&&le!==null){switch(le.$$typeof){case _:e:{for(var Ge=le.key,qe=te;qe!==null;){if(qe.key===Ge){if(Ge=le.type,Ge===O){if(qe.tag===7){m(ie,qe.sibling),te=C(qe,le.props.children),te.return=ie,ie=te;break e}}else if(qe.elementType===Ge||typeof Ge=="object"&&Ge!==null&&Ge.$$typeof===ve&&w$(Ge)===qe.type){m(ie,qe.sibling),te=C(qe,le.props),te.ref=eh(ie,qe,le),te.return=ie,ie=te;break e}m(ie,qe);break}else h(ie,qe);qe=qe.sibling}le.type===O?(te=tu(le.props.children,ie.mode,Ie,le.key),te.return=ie,ie=te):(Ie=Qp(le.type,le.key,le.props,null,ie.mode,Ie),Ie.ref=eh(ie,te,le),Ie.return=ie,ie=Ie)}return D(ie);case F:e:{for(qe=le.key;te!==null;){if(te.key===qe)if(te.tag===4&&te.stateNode.containerInfo===le.containerInfo&&te.stateNode.implementation===le.implementation){m(ie,te.sibling),te=C(te,le.children||[]),te.return=ie,ie=te;break e}else{m(ie,te);break}else h(ie,te);te=te.sibling}te=Q0(le,ie.mode,Ie),te.return=ie,ie=te}return D(ie);case ve:return qe=le._init,Sn(ie,te,qe(le._payload),Ie)}if(vs(le))return Me(ie,te,le,Ie);if(me(le))return je(ie,te,le,Ie);Ip(ie,le)}return typeof le=="string"&&le!==""||typeof le=="number"?(le=""+le,te!==null&&te.tag===6?(m(ie,te.sibling),te=C(te,le),te.return=ie,ie=te):(m(ie,te),te=Y0(le,ie.mode,Ie),te.return=ie,ie=te),D(ie)):m(ie,te)}return Sn}var pc=S$(!0),C$=S$(!1),Np=Wa(null),Ep=null,mc=null,i0=null;function a0(){i0=mc=Ep=null}function l0(u){var h=Np.current;on(Np),u._currentValue=h}function u0(u,h,m){for(;u!==null;){var b=u.alternate;if((u.childLanes&h)!==h?(u.childLanes|=h,b!==null&&(b.childLanes|=h)):b!==null&&(b.childLanes&h)!==h&&(b.childLanes|=h),u===m)break;u=u.return}}function gc(u,h){Ep=u,i0=mc=null,u=u.dependencies,u!==null&&u.firstContext!==null&&((u.lanes&h)!==0&&(rs=!0),u.firstContext=null)}function Ks(u){var h=u._currentValue;if(i0!==u)if(u={context:u,memoizedValue:h,next:null},mc===null){if(Ep===null)throw Error(n(308));mc=u,Ep.dependencies={lanes:0,firstContext:u}}else mc=mc.next=u;return h}var Xl=null;function c0(u){Xl===null?Xl=[u]:Xl.push(u)}function $$(u,h,m,b){var C=h.interleaved;return C===null?(m.next=m,c0(h)):(m.next=C.next,C.next=m),h.interleaved=m,Ui(u,b)}function Ui(u,h){u.lanes|=h;var m=u.alternate;for(m!==null&&(m.lanes|=h),m=u,u=u.return;u!==null;)u.childLanes|=h,m=u.alternate,m!==null&&(m.childLanes|=h),m=u,u=u.return;return m.tag===3?m.stateNode:null}var Ga=!1;function d0(u){u.updateQueue={baseState:u.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function k$(u,h){u=u.updateQueue,h.updateQueue===u&&(h.updateQueue={baseState:u.baseState,firstBaseUpdate:u.firstBaseUpdate,lastBaseUpdate:u.lastBaseUpdate,shared:u.shared,effects:u.effects})}function ji(u,h){return{eventTime:u,lane:h,tag:0,payload:null,callback:null,next:null}}function Ha(u,h,m){var b=u.updateQueue;if(b===null)return null;if(b=b.shared,(Nt&2)!==0){var C=b.pending;return C===null?h.next=h:(h.next=C.next,C.next=h),b.pending=h,Ui(u,m)}return C=b.interleaved,C===null?(h.next=h,c0(b)):(h.next=C.next,C.next=h),b.interleaved=h,Ui(u,m)}function Rp(u,h,m){if(h=h.updateQueue,h!==null&&(h=h.shared,(m&4194240)!==0)){var b=h.lanes;b&=u.pendingLanes,m|=b,h.lanes=m,Ol(u,m)}}function T$(u,h){var m=u.updateQueue,b=u.alternate;if(b!==null&&(b=b.updateQueue,m===b)){var C=null,T=null;if(m=m.firstBaseUpdate,m!==null){do{var D={eventTime:m.eventTime,lane:m.lane,tag:m.tag,payload:m.payload,callback:m.callback,next:null};T===null?C=T=D:T=T.next=D,m=m.next}while(m!==null);T===null?C=T=h:T=T.next=h}else C=T=h;m={baseState:b.baseState,firstBaseUpdate:C,lastBaseUpdate:T,shared:b.shared,effects:b.effects},u.updateQueue=m;return}u=m.lastBaseUpdate,u===null?m.firstBaseUpdate=h:u.next=h,m.lastBaseUpdate=h}function _p(u,h,m,b){var C=u.updateQueue;Ga=!1;var T=C.firstBaseUpdate,D=C.lastBaseUpdate,H=C.shared.pending;if(H!==null){C.shared.pending=null;var Y=H,ce=Y.next;Y.next=null,D===null?T=ce:D.next=ce,D=Y;var Se=u.alternate;Se!==null&&(Se=Se.updateQueue,H=Se.lastBaseUpdate,H!==D&&(H===null?Se.firstBaseUpdate=ce:H.next=ce,Se.lastBaseUpdate=Y))}if(T!==null){var ke=C.baseState;D=0,Se=ce=Y=null,H=T;do{var we=H.lane,Le=H.eventTime;if((b&we)===we){Se!==null&&(Se=Se.next={eventTime:Le,lane:0,tag:H.tag,payload:H.payload,callback:H.callback,next:null});e:{var Me=u,je=H;switch(we=h,Le=m,je.tag){case 1:if(Me=je.payload,typeof Me=="function"){ke=Me.call(Le,ke,we);break e}ke=Me;break e;case 3:Me.flags=Me.flags&-65537|128;case 0:if(Me=je.payload,we=typeof Me=="function"?Me.call(Le,ke,we):Me,we==null)break e;ke=ge({},ke,we);break e;case 2:Ga=!0}}H.callback!==null&&H.lane!==0&&(u.flags|=64,we=C.effects,we===null?C.effects=[H]:we.push(H))}else Le={eventTime:Le,lane:we,tag:H.tag,payload:H.payload,callback:H.callback,next:null},Se===null?(ce=Se=Le,Y=ke):Se=Se.next=Le,D|=we;if(H=H.next,H===null){if(H=C.shared.pending,H===null)break;we=H,H=we.next,we.next=null,C.lastBaseUpdate=we,C.shared.pending=null}}while(!0);if(Se===null&&(Y=ke),C.baseState=Y,C.firstBaseUpdate=ce,C.lastBaseUpdate=Se,h=C.shared.interleaved,h!==null){C=h;do D|=C.lane,C=C.next;while(C!==h)}else T===null&&(C.shared.lanes=0);Ql|=D,u.lanes=D,u.memoizedState=ke}}function I$(u,h,m){if(u=h.effects,h.effects=null,u!==null)for(h=0;h<u.length;h++){var b=u[h],C=b.callback;if(C!==null){if(b.callback=null,b=m,typeof C!="function")throw Error(n(191,C));C.call(b)}}}var th={},Jo=Wa(th),nh=Wa(th),rh=Wa(th);function ql(u){if(u===th)throw Error(n(174));return u}function h0(u,h){switch(Jt(rh,h),Jt(nh,u),Jt(Jo,th),u=h.nodeType,u){case 9:case 11:h=(h=h.documentElement)?h.namespaceURI:$i(null,"");break;default:u=u===8?h.parentNode:h,h=u.namespaceURI||null,u=u.tagName,h=$i(h,u)}on(Jo),Jt(Jo,h)}function yc(){on(Jo),on(nh),on(rh)}function N$(u){ql(rh.current);var h=ql(Jo.current),m=$i(h,u.type);h!==m&&(Jt(nh,u),Jt(Jo,m))}function f0(u){nh.current===u&&(on(Jo),on(nh))}var cn=Wa(0);function Pp(u){for(var h=u;h!==null;){if(h.tag===13){var m=h.memoizedState;if(m!==null&&(m=m.dehydrated,m===null||m.data==="$?"||m.data==="$!"))return h}else if(h.tag===19&&h.memoizedProps.revealOrder!==void 0){if((h.flags&128)!==0)return h}else if(h.child!==null){h.child.return=h,h=h.child;continue}if(h===u)break;for(;h.sibling===null;){if(h.return===null||h.return===u)return null;h=h.return}h.sibling.return=h.return,h=h.sibling}return null}var p0=[];function m0(){for(var u=0;u<p0.length;u++)p0[u]._workInProgressVersionPrimary=null;p0.length=0}var Ap=R.ReactCurrentDispatcher,g0=R.ReactCurrentBatchConfig,Yl=0,dn=null,Pn=null,Hn=null,Dp=!1,sh=!1,oh=0,k4=0;function gr(){throw Error(n(321))}function y0(u,h){if(h===null)return!1;for(var m=0;m<h.length&&m<u.length;m++)if(!Co(u[m],h[m]))return!1;return!0}function x0(u,h,m,b,C,T){if(Yl=T,dn=h,h.memoizedState=null,h.updateQueue=null,h.lanes=0,Ap.current=u===null||u.memoizedState===null?E4:R4,u=m(b,C),sh){T=0;do{if(sh=!1,oh=0,25<=T)throw Error(n(301));T+=1,Hn=Pn=null,h.updateQueue=null,Ap.current=_4,u=m(b,C)}while(sh)}if(Ap.current=Lp,h=Pn!==null&&Pn.next!==null,Yl=0,Hn=Pn=dn=null,Dp=!1,h)throw Error(n(300));return u}function v0(){var u=oh!==0;return oh=0,u}function ei(){var u={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Hn===null?dn.memoizedState=Hn=u:Hn=Hn.next=u,Hn}function Xs(){if(Pn===null){var u=dn.alternate;u=u!==null?u.memoizedState:null}else u=Pn.next;var h=Hn===null?dn.memoizedState:Hn.next;if(h!==null)Hn=h,Pn=u;else{if(u===null)throw Error(n(310));Pn=u,u={memoizedState:Pn.memoizedState,baseState:Pn.baseState,baseQueue:Pn.baseQueue,queue:Pn.queue,next:null},Hn===null?dn.memoizedState=Hn=u:Hn=Hn.next=u}return Hn}function ih(u,h){return typeof h=="function"?h(u):h}function b0(u){var h=Xs(),m=h.queue;if(m===null)throw Error(n(311));m.lastRenderedReducer=u;var b=Pn,C=b.baseQueue,T=m.pending;if(T!==null){if(C!==null){var D=C.next;C.next=T.next,T.next=D}b.baseQueue=C=T,m.pending=null}if(C!==null){T=C.next,b=b.baseState;var H=D=null,Y=null,ce=T;do{var Se=ce.lane;if((Yl&Se)===Se)Y!==null&&(Y=Y.next={lane:0,action:ce.action,hasEagerState:ce.hasEagerState,eagerState:ce.eagerState,next:null}),b=ce.hasEagerState?ce.eagerState:u(b,ce.action);else{var ke={lane:Se,action:ce.action,hasEagerState:ce.hasEagerState,eagerState:ce.eagerState,next:null};Y===null?(H=Y=ke,D=b):Y=Y.next=ke,dn.lanes|=Se,Ql|=Se}ce=ce.next}while(ce!==null&&ce!==T);Y===null?D=b:Y.next=H,Co(b,h.memoizedState)||(rs=!0),h.memoizedState=b,h.baseState=D,h.baseQueue=Y,m.lastRenderedState=b}if(u=m.interleaved,u!==null){C=u;do T=C.lane,dn.lanes|=T,Ql|=T,C=C.next;while(C!==u)}else C===null&&(m.lanes=0);return[h.memoizedState,m.dispatch]}function w0(u){var h=Xs(),m=h.queue;if(m===null)throw Error(n(311));m.lastRenderedReducer=u;var b=m.dispatch,C=m.pending,T=h.memoizedState;if(C!==null){m.pending=null;var D=C=C.next;do T=u(T,D.action),D=D.next;while(D!==C);Co(T,h.memoizedState)||(rs=!0),h.memoizedState=T,h.baseQueue===null&&(h.baseState=T),m.lastRenderedState=T}return[T,b]}function E$(){}function R$(u,h){var m=dn,b=Xs(),C=h(),T=!Co(b.memoizedState,C);if(T&&(b.memoizedState=C,rs=!0),b=b.queue,S0(A$.bind(null,m,b,u),[u]),b.getSnapshot!==h||T||Hn!==null&&Hn.memoizedState.tag&1){if(m.flags|=2048,ah(9,P$.bind(null,m,b,C,h),void 0,null),Kn===null)throw Error(n(349));(Yl&30)!==0||_$(m,h,C)}return C}function _$(u,h,m){u.flags|=16384,u={getSnapshot:h,value:m},h=dn.updateQueue,h===null?(h={lastEffect:null,stores:null},dn.updateQueue=h,h.stores=[u]):(m=h.stores,m===null?h.stores=[u]:m.push(u))}function P$(u,h,m,b){h.value=m,h.getSnapshot=b,D$(h)&&F$(u)}function A$(u,h,m){return m(function(){D$(h)&&F$(u)})}function D$(u){var h=u.getSnapshot;u=u.value;try{var m=h();return!Co(u,m)}catch{return!0}}function F$(u){var h=Ui(u,1);h!==null&&No(h,u,1,-1)}function O$(u){var h=ei();return typeof u=="function"&&(u=u()),h.memoizedState=h.baseState=u,u={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:ih,lastRenderedState:u},h.queue=u,u=u.dispatch=N4.bind(null,dn,u),[h.memoizedState,u]}function ah(u,h,m,b){return u={tag:u,create:h,destroy:m,deps:b,next:null},h=dn.updateQueue,h===null?(h={lastEffect:null,stores:null},dn.updateQueue=h,h.lastEffect=u.next=u):(m=h.lastEffect,m===null?h.lastEffect=u.next=u:(b=m.next,m.next=u,u.next=b,h.lastEffect=u)),u}function L$(){return Xs().memoizedState}function Fp(u,h,m,b){var C=ei();dn.flags|=u,C.memoizedState=ah(1|h,m,void 0,b===void 0?null:b)}function Op(u,h,m,b){var C=Xs();b=b===void 0?null:b;var T=void 0;if(Pn!==null){var D=Pn.memoizedState;if(T=D.destroy,b!==null&&y0(b,D.deps)){C.memoizedState=ah(h,m,T,b);return}}dn.flags|=u,C.memoizedState=ah(1|h,m,T,b)}function z$(u,h){return Fp(8390656,8,u,h)}function S0(u,h){return Op(2048,8,u,h)}function B$(u,h){return Op(4,2,u,h)}function M$(u,h){return Op(4,4,u,h)}function V$(u,h){if(typeof h=="function")return u=u(),h(u),function(){h(null)};if(h!=null)return u=u(),h.current=u,function(){h.current=null}}function W$(u,h,m){return m=m!=null?m.concat([u]):null,Op(4,4,V$.bind(null,h,u),m)}function C0(){}function U$(u,h){var m=Xs();h=h===void 0?null:h;var b=m.memoizedState;return b!==null&&h!==null&&y0(h,b[1])?b[0]:(m.memoizedState=[u,h],u)}function j$(u,h){var m=Xs();h=h===void 0?null:h;var b=m.memoizedState;return b!==null&&h!==null&&y0(h,b[1])?b[0]:(u=u(),m.memoizedState=[u,h],u)}function G$(u,h,m){return(Yl&21)===0?(u.baseState&&(u.baseState=!1,rs=!0),u.memoizedState=m):(Co(m,h)||(m=Ai(),dn.lanes|=m,Ql|=m,u.baseState=!0),h)}function T4(u,h){var m=wt;wt=m!==0&&4>m?m:4,u(!0);var b=g0.transition;g0.transition={};try{u(!1),h()}finally{wt=m,g0.transition=b}}function H$(){return Xs().memoizedState}function I4(u,h,m){var b=Ya(u);if(m={lane:b,action:m,hasEagerState:!1,eagerState:null,next:null},K$(u))X$(h,m);else if(m=$$(u,h,m,b),m!==null){var C=Or();No(m,u,b,C),q$(m,h,b)}}function N4(u,h,m){var b=Ya(u),C={lane:b,action:m,hasEagerState:!1,eagerState:null,next:null};if(K$(u))X$(h,C);else{var T=u.alternate;if(u.lanes===0&&(T===null||T.lanes===0)&&(T=h.lastRenderedReducer,T!==null))try{var D=h.lastRenderedState,H=T(D,m);if(C.hasEagerState=!0,C.eagerState=H,Co(H,D)){var Y=h.interleaved;Y===null?(C.next=C,c0(h)):(C.next=Y.next,Y.next=C),h.interleaved=C;return}}catch{}finally{}m=$$(u,h,C,b),m!==null&&(C=Or(),No(m,u,b,C),q$(m,h,b))}}function K$(u){var h=u.alternate;return u===dn||h!==null&&h===dn}function X$(u,h){sh=Dp=!0;var m=u.pending;m===null?h.next=h:(h.next=m.next,m.next=h),u.pending=h}function q$(u,h,m){if((m&4194240)!==0){var b=h.lanes;b&=u.pendingLanes,m|=b,h.lanes=m,Ol(u,m)}}var Lp={readContext:Ks,useCallback:gr,useContext:gr,useEffect:gr,useImperativeHandle:gr,useInsertionEffect:gr,useLayoutEffect:gr,useMemo:gr,useReducer:gr,useRef:gr,useState:gr,useDebugValue:gr,useDeferredValue:gr,useTransition:gr,useMutableSource:gr,useSyncExternalStore:gr,useId:gr,unstable_isNewReconciler:!1},E4={readContext:Ks,useCallback:function(u,h){return ei().memoizedState=[u,h===void 0?null:h],u},useContext:Ks,useEffect:z$,useImperativeHandle:function(u,h,m){return m=m!=null?m.concat([u]):null,Fp(4194308,4,V$.bind(null,h,u),m)},useLayoutEffect:function(u,h){return Fp(4194308,4,u,h)},useInsertionEffect:function(u,h){return Fp(4,2,u,h)},useMemo:function(u,h){var m=ei();return h=h===void 0?null:h,u=u(),m.memoizedState=[u,h],u},useReducer:function(u,h,m){var b=ei();return h=m!==void 0?m(h):h,b.memoizedState=b.baseState=h,u={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:u,lastRenderedState:h},b.queue=u,u=u.dispatch=I4.bind(null,dn,u),[b.memoizedState,u]},useRef:function(u){var h=ei();return u={current:u},h.memoizedState=u},useState:O$,useDebugValue:C0,useDeferredValue:function(u){return ei().memoizedState=u},useTransition:function(){var u=O$(!1),h=u[0];return u=T4.bind(null,u[1]),ei().memoizedState=u,[h,u]},useMutableSource:function(){},useSyncExternalStore:function(u,h,m){var b=dn,C=ei();if(ln){if(m===void 0)throw Error(n(407));m=m()}else{if(m=h(),Kn===null)throw Error(n(349));(Yl&30)!==0||_$(b,h,m)}C.memoizedState=m;var T={value:m,getSnapshot:h};return C.queue=T,z$(A$.bind(null,b,T,u),[u]),b.flags|=2048,ah(9,P$.bind(null,b,T,m,h),void 0,null),m},useId:function(){var u=ei(),h=Kn.identifierPrefix;if(ln){var m=Wi,b=Vi;m=(b&~(1<<32-fr(b)-1)).toString(32)+m,h=":"+h+"R"+m,m=oh++,0<m&&(h+="H"+m.toString(32)),h+=":"}else m=k4++,h=":"+h+"r"+m.toString(32)+":";return u.memoizedState=h},unstable_isNewReconciler:!1},R4={readContext:Ks,useCallback:U$,useContext:Ks,useEffect:S0,useImperativeHandle:W$,useInsertionEffect:B$,useLayoutEffect:M$,useMemo:j$,useReducer:b0,useRef:L$,useState:function(){return b0(ih)},useDebugValue:C0,useDeferredValue:function(u){var h=Xs();return G$(h,Pn.memoizedState,u)},useTransition:function(){var u=b0(ih)[0],h=Xs().memoizedState;return[u,h]},useMutableSource:E$,useSyncExternalStore:R$,useId:H$,unstable_isNewReconciler:!1},_4={readContext:Ks,useCallback:U$,useContext:Ks,useEffect:S0,useImperativeHandle:W$,useInsertionEffect:B$,useLayoutEffect:M$,useMemo:j$,useReducer:w0,useRef:L$,useState:function(){return w0(ih)},useDebugValue:C0,useDeferredValue:function(u){var h=Xs();return Pn===null?h.memoizedState=u:G$(h,Pn.memoizedState,u)},useTransition:function(){var u=w0(ih)[0],h=Xs().memoizedState;return[u,h]},useMutableSource:E$,useSyncExternalStore:R$,useId:H$,unstable_isNewReconciler:!1};function ko(u,h){if(u&&u.defaultProps){h=ge({},h),u=u.defaultProps;for(var m in u)h[m]===void 0&&(h[m]=u[m]);return h}return h}function $0(u,h,m,b){h=u.memoizedState,m=m(b,h),m=m==null?h:ge({},h,m),u.memoizedState=m,u.lanes===0&&(u.updateQueue.baseState=m)}var zp={isMounted:function(u){return(u=u._reactInternals)?Bn(u)===u:!1},enqueueSetState:function(u,h,m){u=u._reactInternals;var b=Or(),C=Ya(u),T=ji(b,C);T.payload=h,m!=null&&(T.callback=m),h=Ha(u,T,C),h!==null&&(No(h,u,C,b),Rp(h,u,C))},enqueueReplaceState:function(u,h,m){u=u._reactInternals;var b=Or(),C=Ya(u),T=ji(b,C);T.tag=1,T.payload=h,m!=null&&(T.callback=m),h=Ha(u,T,C),h!==null&&(No(h,u,C,b),Rp(h,u,C))},enqueueForceUpdate:function(u,h){u=u._reactInternals;var m=Or(),b=Ya(u),C=ji(m,b);C.tag=2,h!=null&&(C.callback=h),h=Ha(u,C,b),h!==null&&(No(h,u,b,m),Rp(h,u,b))}};function Y$(u,h,m,b,C,T,D){return u=u.stateNode,typeof u.shouldComponentUpdate=="function"?u.shouldComponentUpdate(b,T,D):h.prototype&&h.prototype.isPureReactComponent?!Kd(m,b)||!Kd(C,T):!0}function Q$(u,h,m){var b=!1,C=Ua,T=h.contextType;return typeof T=="object"&&T!==null?T=Ks(T):(C=ns(h)?Gl:mr.current,b=h.contextTypes,T=(b=b!=null)?cc(u,C):Ua),h=new h(m,T),u.memoizedState=h.state!==null&&h.state!==void 0?h.state:null,h.updater=zp,u.stateNode=h,h._reactInternals=u,b&&(u=u.stateNode,u.__reactInternalMemoizedUnmaskedChildContext=C,u.__reactInternalMemoizedMaskedChildContext=T),h}function Z$(u,h,m,b){u=h.state,typeof h.componentWillReceiveProps=="function"&&h.componentWillReceiveProps(m,b),typeof h.UNSAFE_componentWillReceiveProps=="function"&&h.UNSAFE_componentWillReceiveProps(m,b),h.state!==u&&zp.enqueueReplaceState(h,h.state,null)}function k0(u,h,m,b){var C=u.stateNode;C.props=m,C.state=u.memoizedState,C.refs={},d0(u);var T=h.contextType;typeof T=="object"&&T!==null?C.context=Ks(T):(T=ns(h)?Gl:mr.current,C.context=cc(u,T)),C.state=u.memoizedState,T=h.getDerivedStateFromProps,typeof T=="function"&&($0(u,h,T,m),C.state=u.memoizedState),typeof h.getDerivedStateFromProps=="function"||typeof C.getSnapshotBeforeUpdate=="function"||typeof C.UNSAFE_componentWillMount!="function"&&typeof C.componentWillMount!="function"||(h=C.state,typeof C.componentWillMount=="function"&&C.componentWillMount(),typeof C.UNSAFE_componentWillMount=="function"&&C.UNSAFE_componentWillMount(),h!==C.state&&zp.enqueueReplaceState(C,C.state,null),_p(u,m,C,b),C.state=u.memoizedState),typeof C.componentDidMount=="function"&&(u.flags|=4194308)}function xc(u,h){try{var m="",b=h;do m+=nt(b),b=b.return;while(b);var C=m}catch(T){C=`
Error generating stack: `+T.message+`
`+T.stack}return{value:u,source:h,stack:C,digest:null}}function T0(u,h,m){return{value:u,source:null,stack:m??null,digest:h??null}}function I0(u,h){try{console.error(h.value)}catch(m){setTimeout(function(){throw m})}}var P4=typeof WeakMap=="function"?WeakMap:Map;function J$(u,h,m){m=ji(-1,m),m.tag=3,m.payload={element:null};var b=h.value;return m.callback=function(){Gp||(Gp=!0,W0=b),I0(u,h)},m}function ek(u,h,m){m=ji(-1,m),m.tag=3;var b=u.type.getDerivedStateFromError;if(typeof b=="function"){var C=h.value;m.payload=function(){return b(C)},m.callback=function(){I0(u,h)}}var T=u.stateNode;return T!==null&&typeof T.componentDidCatch=="function"&&(m.callback=function(){I0(u,h),typeof b!="function"&&(Xa===null?Xa=new Set([this]):Xa.add(this));var D=h.stack;this.componentDidCatch(h.value,{componentStack:D!==null?D:""})}),m}function tk(u,h,m){var b=u.pingCache;if(b===null){b=u.pingCache=new P4;var C=new Set;b.set(h,C)}else C=b.get(h),C===void 0&&(C=new Set,b.set(h,C));C.has(m)||(C.add(m),u=H4.bind(null,u,h,m),h.then(u,u))}function nk(u){do{var h;if((h=u.tag===13)&&(h=u.memoizedState,h=h!==null?h.dehydrated!==null:!0),h)return u;u=u.return}while(u!==null);return null}function rk(u,h,m,b,C){return(u.mode&1)===0?(u===h?u.flags|=65536:(u.flags|=128,m.flags|=131072,m.flags&=-52805,m.tag===1&&(m.alternate===null?m.tag=17:(h=ji(-1,1),h.tag=2,Ha(m,h,1))),m.lanes|=1),u):(u.flags|=65536,u.lanes=C,u)}var A4=R.ReactCurrentOwner,rs=!1;function Fr(u,h,m,b){h.child=u===null?C$(h,null,m,b):pc(h,u.child,m,b)}function sk(u,h,m,b,C){m=m.render;var T=h.ref;return gc(h,C),b=x0(u,h,m,b,T,C),m=v0(),u!==null&&!rs?(h.updateQueue=u.updateQueue,h.flags&=-2053,u.lanes&=~C,Gi(u,h,C)):(ln&&m&&t0(h),h.flags|=1,Fr(u,h,b,C),h.child)}function ok(u,h,m,b,C){if(u===null){var T=m.type;return typeof T=="function"&&!q0(T)&&T.defaultProps===void 0&&m.compare===null&&m.defaultProps===void 0?(h.tag=15,h.type=T,ik(u,h,T,b,C)):(u=Qp(m.type,null,b,h,h.mode,C),u.ref=h.ref,u.return=h,h.child=u)}if(T=u.child,(u.lanes&C)===0){var D=T.memoizedProps;if(m=m.compare,m=m!==null?m:Kd,m(D,b)&&u.ref===h.ref)return Gi(u,h,C)}return h.flags|=1,u=Za(T,b),u.ref=h.ref,u.return=h,h.child=u}function ik(u,h,m,b,C){if(u!==null){var T=u.memoizedProps;if(Kd(T,b)&&u.ref===h.ref)if(rs=!1,h.pendingProps=b=T,(u.lanes&C)!==0)(u.flags&131072)!==0&&(rs=!0);else return h.lanes=u.lanes,Gi(u,h,C)}return N0(u,h,m,b,C)}function ak(u,h,m){var b=h.pendingProps,C=b.children,T=u!==null?u.memoizedState:null;if(b.mode==="hidden")if((h.mode&1)===0)h.memoizedState={baseLanes:0,cachePool:null,transitions:null},Jt(bc,Ts),Ts|=m;else{if((m&1073741824)===0)return u=T!==null?T.baseLanes|m:m,h.lanes=h.childLanes=1073741824,h.memoizedState={baseLanes:u,cachePool:null,transitions:null},h.updateQueue=null,Jt(bc,Ts),Ts|=u,null;h.memoizedState={baseLanes:0,cachePool:null,transitions:null},b=T!==null?T.baseLanes:m,Jt(bc,Ts),Ts|=b}else T!==null?(b=T.baseLanes|m,h.memoizedState=null):b=m,Jt(bc,Ts),Ts|=b;return Fr(u,h,C,m),h.child}function lk(u,h){var m=h.ref;(u===null&&m!==null||u!==null&&u.ref!==m)&&(h.flags|=512,h.flags|=2097152)}function N0(u,h,m,b,C){var T=ns(m)?Gl:mr.current;return T=cc(h,T),gc(h,C),m=x0(u,h,m,b,T,C),b=v0(),u!==null&&!rs?(h.updateQueue=u.updateQueue,h.flags&=-2053,u.lanes&=~C,Gi(u,h,C)):(ln&&b&&t0(h),h.flags|=1,Fr(u,h,m,C),h.child)}function uk(u,h,m,b,C){if(ns(m)){var T=!0;Sp(h)}else T=!1;if(gc(h,C),h.stateNode===null)Mp(u,h),Q$(h,m,b),k0(h,m,b,C),b=!0;else if(u===null){var D=h.stateNode,H=h.memoizedProps;D.props=H;var Y=D.context,ce=m.contextType;typeof ce=="object"&&ce!==null?ce=Ks(ce):(ce=ns(m)?Gl:mr.current,ce=cc(h,ce));var Se=m.getDerivedStateFromProps,ke=typeof Se=="function"||typeof D.getSnapshotBeforeUpdate=="function";ke||typeof D.UNSAFE_componentWillReceiveProps!="function"&&typeof D.componentWillReceiveProps!="function"||(H!==b||Y!==ce)&&Z$(h,D,b,ce),Ga=!1;var we=h.memoizedState;D.state=we,_p(h,b,D,C),Y=h.memoizedState,H!==b||we!==Y||ts.current||Ga?(typeof Se=="function"&&($0(h,m,Se,b),Y=h.memoizedState),(H=Ga||Y$(h,m,H,b,we,Y,ce))?(ke||typeof D.UNSAFE_componentWillMount!="function"&&typeof D.componentWillMount!="function"||(typeof D.componentWillMount=="function"&&D.componentWillMount(),typeof D.UNSAFE_componentWillMount=="function"&&D.UNSAFE_componentWillMount()),typeof D.componentDidMount=="function"&&(h.flags|=4194308)):(typeof D.componentDidMount=="function"&&(h.flags|=4194308),h.memoizedProps=b,h.memoizedState=Y),D.props=b,D.state=Y,D.context=ce,b=H):(typeof D.componentDidMount=="function"&&(h.flags|=4194308),b=!1)}else{D=h.stateNode,k$(u,h),H=h.memoizedProps,ce=h.type===h.elementType?H:ko(h.type,H),D.props=ce,ke=h.pendingProps,we=D.context,Y=m.contextType,typeof Y=="object"&&Y!==null?Y=Ks(Y):(Y=ns(m)?Gl:mr.current,Y=cc(h,Y));var Le=m.getDerivedStateFromProps;(Se=typeof Le=="function"||typeof D.getSnapshotBeforeUpdate=="function")||typeof D.UNSAFE_componentWillReceiveProps!="function"&&typeof D.componentWillReceiveProps!="function"||(H!==ke||we!==Y)&&Z$(h,D,b,Y),Ga=!1,we=h.memoizedState,D.state=we,_p(h,b,D,C);var Me=h.memoizedState;H!==ke||we!==Me||ts.current||Ga?(typeof Le=="function"&&($0(h,m,Le,b),Me=h.memoizedState),(ce=Ga||Y$(h,m,ce,b,we,Me,Y)||!1)?(Se||typeof D.UNSAFE_componentWillUpdate!="function"&&typeof D.componentWillUpdate!="function"||(typeof D.componentWillUpdate=="function"&&D.componentWillUpdate(b,Me,Y),typeof D.UNSAFE_componentWillUpdate=="function"&&D.UNSAFE_componentWillUpdate(b,Me,Y)),typeof D.componentDidUpdate=="function"&&(h.flags|=4),typeof D.getSnapshotBeforeUpdate=="function"&&(h.flags|=1024)):(typeof D.componentDidUpdate!="function"||H===u.memoizedProps&&we===u.memoizedState||(h.flags|=4),typeof D.getSnapshotBeforeUpdate!="function"||H===u.memoizedProps&&we===u.memoizedState||(h.flags|=1024),h.memoizedProps=b,h.memoizedState=Me),D.props=b,D.state=Me,D.context=Y,b=ce):(typeof D.componentDidUpdate!="function"||H===u.memoizedProps&&we===u.memoizedState||(h.flags|=4),typeof D.getSnapshotBeforeUpdate!="function"||H===u.memoizedProps&&we===u.memoizedState||(h.flags|=1024),b=!1)}return E0(u,h,m,b,T,C)}function E0(u,h,m,b,C,T){lk(u,h);var D=(h.flags&128)!==0;if(!b&&!D)return C&&p$(h,m,!1),Gi(u,h,T);b=h.stateNode,A4.current=h;var H=D&&typeof m.getDerivedStateFromError!="function"?null:b.render();return h.flags|=1,u!==null&&D?(h.child=pc(h,u.child,null,T),h.child=pc(h,null,H,T)):Fr(u,h,H,T),h.memoizedState=b.state,C&&p$(h,m,!0),h.child}function ck(u){var h=u.stateNode;h.pendingContext?h$(u,h.pendingContext,h.pendingContext!==h.context):h.context&&h$(u,h.context,!1),h0(u,h.containerInfo)}function dk(u,h,m,b,C){return fc(),o0(C),h.flags|=256,Fr(u,h,m,b),h.child}var R0={dehydrated:null,treeContext:null,retryLane:0};function _0(u){return{baseLanes:u,cachePool:null,transitions:null}}function hk(u,h,m){var b=h.pendingProps,C=cn.current,T=!1,D=(h.flags&128)!==0,H;if((H=D)||(H=u!==null&&u.memoizedState===null?!1:(C&2)!==0),H?(T=!0,h.flags&=-129):(u===null||u.memoizedState!==null)&&(C|=1),Jt(cn,C&1),u===null)return s0(h),u=h.memoizedState,u!==null&&(u=u.dehydrated,u!==null)?((h.mode&1)===0?h.lanes=1:u.data==="$!"?h.lanes=8:h.lanes=1073741824,null):(D=b.children,u=b.fallback,T?(b=h.mode,T=h.child,D={mode:"hidden",children:D},(b&1)===0&&T!==null?(T.childLanes=0,T.pendingProps=D):T=Zp(D,b,0,null),u=tu(u,b,m,null),T.return=h,u.return=h,T.sibling=u,h.child=T,h.child.memoizedState=_0(m),h.memoizedState=R0,u):P0(h,D));if(C=u.memoizedState,C!==null&&(H=C.dehydrated,H!==null))return D4(u,h,D,b,H,C,m);if(T){T=b.fallback,D=h.mode,C=u.child,H=C.sibling;var Y={mode:"hidden",children:b.children};return(D&1)===0&&h.child!==C?(b=h.child,b.childLanes=0,b.pendingProps=Y,h.deletions=null):(b=Za(C,Y),b.subtreeFlags=C.subtreeFlags&14680064),H!==null?T=Za(H,T):(T=tu(T,D,m,null),T.flags|=2),T.return=h,b.return=h,b.sibling=T,h.child=b,b=T,T=h.child,D=u.child.memoizedState,D=D===null?_0(m):{baseLanes:D.baseLanes|m,cachePool:null,transitions:D.transitions},T.memoizedState=D,T.childLanes=u.childLanes&~m,h.memoizedState=R0,b}return T=u.child,u=T.sibling,b=Za(T,{mode:"visible",children:b.children}),(h.mode&1)===0&&(b.lanes=m),b.return=h,b.sibling=null,u!==null&&(m=h.deletions,m===null?(h.deletions=[u],h.flags|=16):m.push(u)),h.child=b,h.memoizedState=null,b}function P0(u,h){return h=Zp({mode:"visible",children:h},u.mode,0,null),h.return=u,u.child=h}function Bp(u,h,m,b){return b!==null&&o0(b),pc(h,u.child,null,m),u=P0(h,h.pendingProps.children),u.flags|=2,h.memoizedState=null,u}function D4(u,h,m,b,C,T,D){if(m)return h.flags&256?(h.flags&=-257,b=T0(Error(n(422))),Bp(u,h,D,b)):h.memoizedState!==null?(h.child=u.child,h.flags|=128,null):(T=b.fallback,C=h.mode,b=Zp({mode:"visible",children:b.children},C,0,null),T=tu(T,C,D,null),T.flags|=2,b.return=h,T.return=h,b.sibling=T,h.child=b,(h.mode&1)!==0&&pc(h,u.child,null,D),h.child.memoizedState=_0(D),h.memoizedState=R0,T);if((h.mode&1)===0)return Bp(u,h,D,null);if(C.data==="$!"){if(b=C.nextSibling&&C.nextSibling.dataset,b)var H=b.dgst;return b=H,T=Error(n(419)),b=T0(T,b,void 0),Bp(u,h,D,b)}if(H=(D&u.childLanes)!==0,rs||H){if(b=Kn,b!==null){switch(D&-D){case 4:C=2;break;case 16:C=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:C=32;break;case 536870912:C=268435456;break;default:C=0}C=(C&(b.suspendedLanes|D))!==0?0:C,C!==0&&C!==T.retryLane&&(T.retryLane=C,Ui(u,C),No(b,u,C,-1))}return X0(),b=T0(Error(n(421))),Bp(u,h,D,b)}return C.data==="$?"?(h.flags|=128,h.child=u.child,h=K4.bind(null,u),C._reactRetry=h,null):(u=T.treeContext,ks=Va(C.nextSibling),$s=h,ln=!0,$o=null,u!==null&&(Gs[Hs++]=Vi,Gs[Hs++]=Wi,Gs[Hs++]=Hl,Vi=u.id,Wi=u.overflow,Hl=h),h=P0(h,b.children),h.flags|=4096,h)}function fk(u,h,m){u.lanes|=h;var b=u.alternate;b!==null&&(b.lanes|=h),u0(u.return,h,m)}function A0(u,h,m,b,C){var T=u.memoizedState;T===null?u.memoizedState={isBackwards:h,rendering:null,renderingStartTime:0,last:b,tail:m,tailMode:C}:(T.isBackwards=h,T.rendering=null,T.renderingStartTime=0,T.last=b,T.tail=m,T.tailMode=C)}function pk(u,h,m){var b=h.pendingProps,C=b.revealOrder,T=b.tail;if(Fr(u,h,b.children,m),b=cn.current,(b&2)!==0)b=b&1|2,h.flags|=128;else{if(u!==null&&(u.flags&128)!==0)e:for(u=h.child;u!==null;){if(u.tag===13)u.memoizedState!==null&&fk(u,m,h);else if(u.tag===19)fk(u,m,h);else if(u.child!==null){u.child.return=u,u=u.child;continue}if(u===h)break e;for(;u.sibling===null;){if(u.return===null||u.return===h)break e;u=u.return}u.sibling.return=u.return,u=u.sibling}b&=1}if(Jt(cn,b),(h.mode&1)===0)h.memoizedState=null;else switch(C){case"forwards":for(m=h.child,C=null;m!==null;)u=m.alternate,u!==null&&Pp(u)===null&&(C=m),m=m.sibling;m=C,m===null?(C=h.child,h.child=null):(C=m.sibling,m.sibling=null),A0(h,!1,C,m,T);break;case"backwards":for(m=null,C=h.child,h.child=null;C!==null;){if(u=C.alternate,u!==null&&Pp(u)===null){h.child=C;break}u=C.sibling,C.sibling=m,m=C,C=u}A0(h,!0,m,null,T);break;case"together":A0(h,!1,null,null,void 0);break;default:h.memoizedState=null}return h.child}function Mp(u,h){(h.mode&1)===0&&u!==null&&(u.alternate=null,h.alternate=null,h.flags|=2)}function Gi(u,h,m){if(u!==null&&(h.dependencies=u.dependencies),Ql|=h.lanes,(m&h.childLanes)===0)return null;if(u!==null&&h.child!==u.child)throw Error(n(153));if(h.child!==null){for(u=h.child,m=Za(u,u.pendingProps),h.child=m,m.return=h;u.sibling!==null;)u=u.sibling,m=m.sibling=Za(u,u.pendingProps),m.return=h;m.sibling=null}return h.child}function F4(u,h,m){switch(h.tag){case 3:ck(h),fc();break;case 5:N$(h);break;case 1:ns(h.type)&&Sp(h);break;case 4:h0(h,h.stateNode.containerInfo);break;case 10:var b=h.type._context,C=h.memoizedProps.value;Jt(Np,b._currentValue),b._currentValue=C;break;case 13:if(b=h.memoizedState,b!==null)return b.dehydrated!==null?(Jt(cn,cn.current&1),h.flags|=128,null):(m&h.child.childLanes)!==0?hk(u,h,m):(Jt(cn,cn.current&1),u=Gi(u,h,m),u!==null?u.sibling:null);Jt(cn,cn.current&1);break;case 19:if(b=(m&h.childLanes)!==0,(u.flags&128)!==0){if(b)return pk(u,h,m);h.flags|=128}if(C=h.memoizedState,C!==null&&(C.rendering=null,C.tail=null,C.lastEffect=null),Jt(cn,cn.current),b)break;return null;case 22:case 23:return h.lanes=0,ak(u,h,m)}return Gi(u,h,m)}var mk,D0,gk,yk;mk=function(u,h){for(var m=h.child;m!==null;){if(m.tag===5||m.tag===6)u.appendChild(m.stateNode);else if(m.tag!==4&&m.child!==null){m.child.return=m,m=m.child;continue}if(m===h)break;for(;m.sibling===null;){if(m.return===null||m.return===h)return;m=m.return}m.sibling.return=m.return,m=m.sibling}},D0=function(){},gk=function(u,h,m,b){var C=u.memoizedProps;if(C!==b){u=h.stateNode,ql(Jo.current);var T=null;switch(m){case"input":C=bn(u,C),b=bn(u,b),T=[];break;case"select":C=ge({},C,{value:void 0}),b=ge({},b,{value:void 0}),T=[];break;case"textarea":C=zs(u,C),b=zs(u,b),T=[];break;default:typeof C.onClick!="function"&&typeof b.onClick=="function"&&(u.onclick=vp)}Wo(m,b);var D;m=null;for(ce in C)if(!b.hasOwnProperty(ce)&&C.hasOwnProperty(ce)&&C[ce]!=null)if(ce==="style"){var H=C[ce];for(D in H)H.hasOwnProperty(D)&&(m||(m={}),m[D]="")}else ce!=="dangerouslySetInnerHTML"&&ce!=="children"&&ce!=="suppressContentEditableWarning"&&ce!=="suppressHydrationWarning"&&ce!=="autoFocus"&&(s.hasOwnProperty(ce)?T||(T=[]):(T=T||[]).push(ce,null));for(ce in b){var Y=b[ce];if(H=C!=null?C[ce]:void 0,b.hasOwnProperty(ce)&&Y!==H&&(Y!=null||H!=null))if(ce==="style")if(H){for(D in H)!H.hasOwnProperty(D)||Y&&Y.hasOwnProperty(D)||(m||(m={}),m[D]="");for(D in Y)Y.hasOwnProperty(D)&&H[D]!==Y[D]&&(m||(m={}),m[D]=Y[D])}else m||(T||(T=[]),T.push(ce,m)),m=Y;else ce==="dangerouslySetInnerHTML"?(Y=Y?Y.__html:void 0,H=H?H.__html:void 0,Y!=null&&H!==Y&&(T=T||[]).push(ce,Y)):ce==="children"?typeof Y!="string"&&typeof Y!="number"||(T=T||[]).push(ce,""+Y):ce!=="suppressContentEditableWarning"&&ce!=="suppressHydrationWarning"&&(s.hasOwnProperty(ce)?(Y!=null&&ce==="onScroll"&&sn("scroll",u),T||H===Y||(T=[])):(T=T||[]).push(ce,Y))}m&&(T=T||[]).push("style",m);var ce=T;(h.updateQueue=ce)&&(h.flags|=4)}},yk=function(u,h,m,b){m!==b&&(h.flags|=4)};function lh(u,h){if(!ln)switch(u.tailMode){case"hidden":h=u.tail;for(var m=null;h!==null;)h.alternate!==null&&(m=h),h=h.sibling;m===null?u.tail=null:m.sibling=null;break;case"collapsed":m=u.tail;for(var b=null;m!==null;)m.alternate!==null&&(b=m),m=m.sibling;b===null?h||u.tail===null?u.tail=null:u.tail.sibling=null:b.sibling=null}}function yr(u){var h=u.alternate!==null&&u.alternate.child===u.child,m=0,b=0;if(h)for(var C=u.child;C!==null;)m|=C.lanes|C.childLanes,b|=C.subtreeFlags&14680064,b|=C.flags&14680064,C.return=u,C=C.sibling;else for(C=u.child;C!==null;)m|=C.lanes|C.childLanes,b|=C.subtreeFlags,b|=C.flags,C.return=u,C=C.sibling;return u.subtreeFlags|=b,u.childLanes=m,h}function O4(u,h,m){var b=h.pendingProps;switch(n0(h),h.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return yr(h),null;case 1:return ns(h.type)&&wp(),yr(h),null;case 3:return b=h.stateNode,yc(),on(ts),on(mr),m0(),b.pendingContext&&(b.context=b.pendingContext,b.pendingContext=null),(u===null||u.child===null)&&(Tp(h)?h.flags|=4:u===null||u.memoizedState.isDehydrated&&(h.flags&256)===0||(h.flags|=1024,$o!==null&&(G0($o),$o=null))),D0(u,h),yr(h),null;case 5:f0(h);var C=ql(rh.current);if(m=h.type,u!==null&&h.stateNode!=null)gk(u,h,m,b,C),u.ref!==h.ref&&(h.flags|=512,h.flags|=2097152);else{if(!b){if(h.stateNode===null)throw Error(n(166));return yr(h),null}if(u=ql(Jo.current),Tp(h)){b=h.stateNode,m=h.type;var T=h.memoizedProps;switch(b[Zo]=h,b[Zd]=T,u=(h.mode&1)!==0,m){case"dialog":sn("cancel",b),sn("close",b);break;case"iframe":case"object":case"embed":sn("load",b);break;case"video":case"audio":for(C=0;C<qd.length;C++)sn(qd[C],b);break;case"source":sn("error",b);break;case"img":case"image":case"link":sn("error",b),sn("load",b);break;case"details":sn("toggle",b);break;case"input":Il(b,T),sn("invalid",b);break;case"select":b._wrapperState={wasMultiple:!!T.multiple},sn("invalid",b);break;case"textarea":Kr(b,T),sn("invalid",b)}Wo(m,T),C=null;for(var D in T)if(T.hasOwnProperty(D)){var H=T[D];D==="children"?typeof H=="string"?b.textContent!==H&&(T.suppressHydrationWarning!==!0&&xp(b.textContent,H,u),C=["children",H]):typeof H=="number"&&b.textContent!==""+H&&(T.suppressHydrationWarning!==!0&&xp(b.textContent,H,u),C=["children",""+H]):s.hasOwnProperty(D)&&H!=null&&D==="onScroll"&&sn("scroll",b)}switch(m){case"input":Jn(b),Nl(b,T,!0);break;case"textarea":Jn(b),Ia(b);break;case"select":case"option":break;default:typeof T.onClick=="function"&&(b.onclick=vp)}b=C,h.updateQueue=b,b!==null&&(h.flags|=4)}else{D=C.nodeType===9?C:C.ownerDocument,u==="http://www.w3.org/1999/xhtml"&&(u=Ci(m)),u==="http://www.w3.org/1999/xhtml"?m==="script"?(u=D.createElement("div"),u.innerHTML="<script><\/script>",u=u.removeChild(u.firstChild)):typeof b.is=="string"?u=D.createElement(m,{is:b.is}):(u=D.createElement(m),m==="select"&&(D=u,b.multiple?D.multiple=!0:b.size&&(D.size=b.size))):u=D.createElementNS(u,m),u[Zo]=h,u[Zd]=b,mk(u,h,!1,!1),h.stateNode=u;e:{switch(D=Ra(m,b),m){case"dialog":sn("cancel",u),sn("close",u),C=b;break;case"iframe":case"object":case"embed":sn("load",u),C=b;break;case"video":case"audio":for(C=0;C<qd.length;C++)sn(qd[C],u);C=b;break;case"source":sn("error",u),C=b;break;case"img":case"image":case"link":sn("error",u),sn("load",u),C=b;break;case"details":sn("toggle",u),C=b;break;case"input":Il(u,b),C=bn(u,b),sn("invalid",u);break;case"option":C=b;break;case"select":u._wrapperState={wasMultiple:!!b.multiple},C=ge({},b,{value:void 0}),sn("invalid",u);break;case"textarea":Kr(u,b),C=zs(u,b),sn("invalid",u);break;default:C=b}Wo(m,C),H=C;for(T in H)if(H.hasOwnProperty(T)){var Y=H[T];T==="style"?Ea(u,Y):T==="dangerouslySetInnerHTML"?(Y=Y?Y.__html:void 0,Y!=null&&Na(u,Y)):T==="children"?typeof Y=="string"?(m!=="textarea"||Y!=="")&&Mo(u,Y):typeof Y=="number"&&Mo(u,""+Y):T!=="suppressContentEditableWarning"&&T!=="suppressHydrationWarning"&&T!=="autoFocus"&&(s.hasOwnProperty(T)?Y!=null&&T==="onScroll"&&sn("scroll",u):Y!=null&&I(u,T,Y,D))}switch(m){case"input":Jn(u),Nl(u,b,!1);break;case"textarea":Jn(u),Ia(u);break;case"option":b.value!=null&&u.setAttribute("value",""+mt(b.value));break;case"select":u.multiple=!!b.multiple,T=b.value,T!=null?bs(u,!!b.multiple,T,!1):b.defaultValue!=null&&bs(u,!!b.multiple,b.defaultValue,!0);break;default:typeof C.onClick=="function"&&(u.onclick=vp)}switch(m){case"button":case"input":case"select":case"textarea":b=!!b.autoFocus;break e;case"img":b=!0;break e;default:b=!1}}b&&(h.flags|=4)}h.ref!==null&&(h.flags|=512,h.flags|=2097152)}return yr(h),null;case 6:if(u&&h.stateNode!=null)yk(u,h,u.memoizedProps,b);else{if(typeof b!="string"&&h.stateNode===null)throw Error(n(166));if(m=ql(rh.current),ql(Jo.current),Tp(h)){if(b=h.stateNode,m=h.memoizedProps,b[Zo]=h,(T=b.nodeValue!==m)&&(u=$s,u!==null))switch(u.tag){case 3:xp(b.nodeValue,m,(u.mode&1)!==0);break;case 5:u.memoizedProps.suppressHydrationWarning!==!0&&xp(b.nodeValue,m,(u.mode&1)!==0)}T&&(h.flags|=4)}else b=(m.nodeType===9?m:m.ownerDocument).createTextNode(b),b[Zo]=h,h.stateNode=b}return yr(h),null;case 13:if(on(cn),b=h.memoizedState,u===null||u.memoizedState!==null&&u.memoizedState.dehydrated!==null){if(ln&&ks!==null&&(h.mode&1)!==0&&(h.flags&128)===0)b$(),fc(),h.flags|=98560,T=!1;else if(T=Tp(h),b!==null&&b.dehydrated!==null){if(u===null){if(!T)throw Error(n(318));if(T=h.memoizedState,T=T!==null?T.dehydrated:null,!T)throw Error(n(317));T[Zo]=h}else fc(),(h.flags&128)===0&&(h.memoizedState=null),h.flags|=4;yr(h),T=!1}else $o!==null&&(G0($o),$o=null),T=!0;if(!T)return h.flags&65536?h:null}return(h.flags&128)!==0?(h.lanes=m,h):(b=b!==null,b!==(u!==null&&u.memoizedState!==null)&&b&&(h.child.flags|=8192,(h.mode&1)!==0&&(u===null||(cn.current&1)!==0?An===0&&(An=3):X0())),h.updateQueue!==null&&(h.flags|=4),yr(h),null);case 4:return yc(),D0(u,h),u===null&&Yd(h.stateNode.containerInfo),yr(h),null;case 10:return l0(h.type._context),yr(h),null;case 17:return ns(h.type)&&wp(),yr(h),null;case 19:if(on(cn),T=h.memoizedState,T===null)return yr(h),null;if(b=(h.flags&128)!==0,D=T.rendering,D===null)if(b)lh(T,!1);else{if(An!==0||u!==null&&(u.flags&128)!==0)for(u=h.child;u!==null;){if(D=Pp(u),D!==null){for(h.flags|=128,lh(T,!1),b=D.updateQueue,b!==null&&(h.updateQueue=b,h.flags|=4),h.subtreeFlags=0,b=m,m=h.child;m!==null;)T=m,u=b,T.flags&=14680066,D=T.alternate,D===null?(T.childLanes=0,T.lanes=u,T.child=null,T.subtreeFlags=0,T.memoizedProps=null,T.memoizedState=null,T.updateQueue=null,T.dependencies=null,T.stateNode=null):(T.childLanes=D.childLanes,T.lanes=D.lanes,T.child=D.child,T.subtreeFlags=0,T.deletions=null,T.memoizedProps=D.memoizedProps,T.memoizedState=D.memoizedState,T.updateQueue=D.updateQueue,T.type=D.type,u=D.dependencies,T.dependencies=u===null?null:{lanes:u.lanes,firstContext:u.firstContext}),m=m.sibling;return Jt(cn,cn.current&1|2),h.child}u=u.sibling}T.tail!==null&&Ut()>wc&&(h.flags|=128,b=!0,lh(T,!1),h.lanes=4194304)}else{if(!b)if(u=Pp(D),u!==null){if(h.flags|=128,b=!0,m=u.updateQueue,m!==null&&(h.updateQueue=m,h.flags|=4),lh(T,!0),T.tail===null&&T.tailMode==="hidden"&&!D.alternate&&!ln)return yr(h),null}else 2*Ut()-T.renderingStartTime>wc&&m!==1073741824&&(h.flags|=128,b=!0,lh(T,!1),h.lanes=4194304);T.isBackwards?(D.sibling=h.child,h.child=D):(m=T.last,m!==null?m.sibling=D:h.child=D,T.last=D)}return T.tail!==null?(h=T.tail,T.rendering=h,T.tail=h.sibling,T.renderingStartTime=Ut(),h.sibling=null,m=cn.current,Jt(cn,b?m&1|2:m&1),h):(yr(h),null);case 22:case 23:return K0(),b=h.memoizedState!==null,u!==null&&u.memoizedState!==null!==b&&(h.flags|=8192),b&&(h.mode&1)!==0?(Ts&1073741824)!==0&&(yr(h),h.subtreeFlags&6&&(h.flags|=8192)):yr(h),null;case 24:return null;case 25:return null}throw Error(n(156,h.tag))}function L4(u,h){switch(n0(h),h.tag){case 1:return ns(h.type)&&wp(),u=h.flags,u&65536?(h.flags=u&-65537|128,h):null;case 3:return yc(),on(ts),on(mr),m0(),u=h.flags,(u&65536)!==0&&(u&128)===0?(h.flags=u&-65537|128,h):null;case 5:return f0(h),null;case 13:if(on(cn),u=h.memoizedState,u!==null&&u.dehydrated!==null){if(h.alternate===null)throw Error(n(340));fc()}return u=h.flags,u&65536?(h.flags=u&-65537|128,h):null;case 19:return on(cn),null;case 4:return yc(),null;case 10:return l0(h.type._context),null;case 22:case 23:return K0(),null;case 24:return null;default:return null}}var Vp=!1,xr=!1,z4=typeof WeakSet=="function"?WeakSet:Set,ze=null;function vc(u,h){var m=u.ref;if(m!==null)if(typeof m=="function")try{m(null)}catch(b){yn(u,h,b)}else m.current=null}function F0(u,h,m){try{m()}catch(b){yn(u,h,b)}}var xk=!1;function B4(u,h){if(Ky=U,u=YC(),By(u)){if("selectionStart"in u)var m={start:u.selectionStart,end:u.selectionEnd};else e:{m=(m=u.ownerDocument)&&m.defaultView||window;var b=m.getSelection&&m.getSelection();if(b&&b.rangeCount!==0){m=b.anchorNode;var C=b.anchorOffset,T=b.focusNode;b=b.focusOffset;try{m.nodeType,T.nodeType}catch{m=null;break e}var D=0,H=-1,Y=-1,ce=0,Se=0,ke=u,we=null;t:for(;;){for(var Le;ke!==m||C!==0&&ke.nodeType!==3||(H=D+C),ke!==T||b!==0&&ke.nodeType!==3||(Y=D+b),ke.nodeType===3&&(D+=ke.nodeValue.length),(Le=ke.firstChild)!==null;)we=ke,ke=Le;for(;;){if(ke===u)break t;if(we===m&&++ce===C&&(H=D),we===T&&++Se===b&&(Y=D),(Le=ke.nextSibling)!==null)break;ke=we,we=ke.parentNode}ke=Le}m=H===-1||Y===-1?null:{start:H,end:Y}}else m=null}m=m||{start:0,end:0}}else m=null;for(Xy={focusedElem:u,selectionRange:m},U=!1,ze=h;ze!==null;)if(h=ze,u=h.child,(h.subtreeFlags&1028)!==0&&u!==null)u.return=h,ze=u;else for(;ze!==null;){h=ze;try{var Me=h.alternate;if((h.flags&1024)!==0)switch(h.tag){case 0:case 11:case 15:break;case 1:if(Me!==null){var je=Me.memoizedProps,Sn=Me.memoizedState,ie=h.stateNode,te=ie.getSnapshotBeforeUpdate(h.elementType===h.type?je:ko(h.type,je),Sn);ie.__reactInternalSnapshotBeforeUpdate=te}break;case 3:var le=h.stateNode.containerInfo;le.nodeType===1?le.textContent="":le.nodeType===9&&le.documentElement&&le.removeChild(le.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(n(163))}}catch(Ie){yn(h,h.return,Ie)}if(u=h.sibling,u!==null){u.return=h.return,ze=u;break}ze=h.return}return Me=xk,xk=!1,Me}function uh(u,h,m){var b=h.updateQueue;if(b=b!==null?b.lastEffect:null,b!==null){var C=b=b.next;do{if((C.tag&u)===u){var T=C.destroy;C.destroy=void 0,T!==void 0&&F0(h,m,T)}C=C.next}while(C!==b)}}function Wp(u,h){if(h=h.updateQueue,h=h!==null?h.lastEffect:null,h!==null){var m=h=h.next;do{if((m.tag&u)===u){var b=m.create;m.destroy=b()}m=m.next}while(m!==h)}}function O0(u){var h=u.ref;if(h!==null){var m=u.stateNode;switch(u.tag){case 5:u=m;break;default:u=m}typeof h=="function"?h(u):h.current=u}}function vk(u){var h=u.alternate;h!==null&&(u.alternate=null,vk(h)),u.child=null,u.deletions=null,u.sibling=null,u.tag===5&&(h=u.stateNode,h!==null&&(delete h[Zo],delete h[Zd],delete h[Zy],delete h[w4],delete h[S4])),u.stateNode=null,u.return=null,u.dependencies=null,u.memoizedProps=null,u.memoizedState=null,u.pendingProps=null,u.stateNode=null,u.updateQueue=null}function bk(u){return u.tag===5||u.tag===3||u.tag===4}function wk(u){e:for(;;){for(;u.sibling===null;){if(u.return===null||bk(u.return))return null;u=u.return}for(u.sibling.return=u.return,u=u.sibling;u.tag!==5&&u.tag!==6&&u.tag!==18;){if(u.flags&2||u.child===null||u.tag===4)continue e;u.child.return=u,u=u.child}if(!(u.flags&2))return u.stateNode}}function L0(u,h,m){var b=u.tag;if(b===5||b===6)u=u.stateNode,h?m.nodeType===8?m.parentNode.insertBefore(u,h):m.insertBefore(u,h):(m.nodeType===8?(h=m.parentNode,h.insertBefore(u,m)):(h=m,h.appendChild(u)),m=m._reactRootContainer,m!=null||h.onclick!==null||(h.onclick=vp));else if(b!==4&&(u=u.child,u!==null))for(L0(u,h,m),u=u.sibling;u!==null;)L0(u,h,m),u=u.sibling}function z0(u,h,m){var b=u.tag;if(b===5||b===6)u=u.stateNode,h?m.insertBefore(u,h):m.appendChild(u);else if(b!==4&&(u=u.child,u!==null))for(z0(u,h,m),u=u.sibling;u!==null;)z0(u,h,m),u=u.sibling}var sr=null,To=!1;function Ka(u,h,m){for(m=m.child;m!==null;)Sk(u,h,m),m=m.sibling}function Sk(u,h,m){if(nr&&typeof nr.onCommitFiberUnmount=="function")try{nr.onCommitFiberUnmount(Vn,m)}catch{}switch(m.tag){case 5:xr||vc(m,h);case 6:var b=sr,C=To;sr=null,Ka(u,h,m),sr=b,To=C,sr!==null&&(To?(u=sr,m=m.stateNode,u.nodeType===8?u.parentNode.removeChild(m):u.removeChild(m)):sr.removeChild(m.stateNode));break;case 18:sr!==null&&(To?(u=sr,m=m.stateNode,u.nodeType===8?Qy(u.parentNode,m):u.nodeType===1&&Qy(u,m),wo(u)):Qy(sr,m.stateNode));break;case 4:b=sr,C=To,sr=m.stateNode.containerInfo,To=!0,Ka(u,h,m),sr=b,To=C;break;case 0:case 11:case 14:case 15:if(!xr&&(b=m.updateQueue,b!==null&&(b=b.lastEffect,b!==null))){C=b=b.next;do{var T=C,D=T.destroy;T=T.tag,D!==void 0&&((T&2)!==0||(T&4)!==0)&&F0(m,h,D),C=C.next}while(C!==b)}Ka(u,h,m);break;case 1:if(!xr&&(vc(m,h),b=m.stateNode,typeof b.componentWillUnmount=="function"))try{b.props=m.memoizedProps,b.state=m.memoizedState,b.componentWillUnmount()}catch(H){yn(m,h,H)}Ka(u,h,m);break;case 21:Ka(u,h,m);break;case 22:m.mode&1?(xr=(b=xr)||m.memoizedState!==null,Ka(u,h,m),xr=b):Ka(u,h,m);break;default:Ka(u,h,m)}}function Ck(u){var h=u.updateQueue;if(h!==null){u.updateQueue=null;var m=u.stateNode;m===null&&(m=u.stateNode=new z4),h.forEach(function(b){var C=X4.bind(null,u,b);m.has(b)||(m.add(b),b.then(C,C))})}}function Io(u,h){var m=h.deletions;if(m!==null)for(var b=0;b<m.length;b++){var C=m[b];try{var T=u,D=h,H=D;e:for(;H!==null;){switch(H.tag){case 5:sr=H.stateNode,To=!1;break e;case 3:sr=H.stateNode.containerInfo,To=!0;break e;case 4:sr=H.stateNode.containerInfo,To=!0;break e}H=H.return}if(sr===null)throw Error(n(160));Sk(T,D,C),sr=null,To=!1;var Y=C.alternate;Y!==null&&(Y.return=null),C.return=null}catch(ce){yn(C,h,ce)}}if(h.subtreeFlags&12854)for(h=h.child;h!==null;)$k(h,u),h=h.sibling}function $k(u,h){var m=u.alternate,b=u.flags;switch(u.tag){case 0:case 11:case 14:case 15:if(Io(h,u),ti(u),b&4){try{uh(3,u,u.return),Wp(3,u)}catch(je){yn(u,u.return,je)}try{uh(5,u,u.return)}catch(je){yn(u,u.return,je)}}break;case 1:Io(h,u),ti(u),b&512&&m!==null&&vc(m,m.return);break;case 5:if(Io(h,u),ti(u),b&512&&m!==null&&vc(m,m.return),u.flags&32){var C=u.stateNode;try{Mo(C,"")}catch(je){yn(u,u.return,je)}}if(b&4&&(C=u.stateNode,C!=null)){var T=u.memoizedProps,D=m!==null?m.memoizedProps:T,H=u.type,Y=u.updateQueue;if(u.updateQueue=null,Y!==null)try{H==="input"&&T.type==="radio"&&T.name!=null&&Xu(C,T),Ra(H,D);var ce=Ra(H,T);for(D=0;D<Y.length;D+=2){var Se=Y[D],ke=Y[D+1];Se==="style"?Ea(C,ke):Se==="dangerouslySetInnerHTML"?Na(C,ke):Se==="children"?Mo(C,ke):I(C,Se,ke,ce)}switch(H){case"input":ka(C,T);break;case"textarea":ws(C,T);break;case"select":var we=C._wrapperState.wasMultiple;C._wrapperState.wasMultiple=!!T.multiple;var Le=T.value;Le!=null?bs(C,!!T.multiple,Le,!1):we!==!!T.multiple&&(T.defaultValue!=null?bs(C,!!T.multiple,T.defaultValue,!0):bs(C,!!T.multiple,T.multiple?[]:"",!1))}C[Zd]=T}catch(je){yn(u,u.return,je)}}break;case 6:if(Io(h,u),ti(u),b&4){if(u.stateNode===null)throw Error(n(162));C=u.stateNode,T=u.memoizedProps;try{C.nodeValue=T}catch(je){yn(u,u.return,je)}}break;case 3:if(Io(h,u),ti(u),b&4&&m!==null&&m.memoizedState.isDehydrated)try{wo(h.containerInfo)}catch(je){yn(u,u.return,je)}break;case 4:Io(h,u),ti(u);break;case 13:Io(h,u),ti(u),C=u.child,C.flags&8192&&(T=C.memoizedState!==null,C.stateNode.isHidden=T,!T||C.alternate!==null&&C.alternate.memoizedState!==null||(V0=Ut())),b&4&&Ck(u);break;case 22:if(Se=m!==null&&m.memoizedState!==null,u.mode&1?(xr=(ce=xr)||Se,Io(h,u),xr=ce):Io(h,u),ti(u),b&8192){if(ce=u.memoizedState!==null,(u.stateNode.isHidden=ce)&&!Se&&(u.mode&1)!==0)for(ze=u,Se=u.child;Se!==null;){for(ke=ze=Se;ze!==null;){switch(we=ze,Le=we.child,we.tag){case 0:case 11:case 14:case 15:uh(4,we,we.return);break;case 1:vc(we,we.return);var Me=we.stateNode;if(typeof Me.componentWillUnmount=="function"){b=we,m=we.return;try{h=b,Me.props=h.memoizedProps,Me.state=h.memoizedState,Me.componentWillUnmount()}catch(je){yn(b,m,je)}}break;case 5:vc(we,we.return);break;case 22:if(we.memoizedState!==null){Ik(ke);continue}}Le!==null?(Le.return=we,ze=Le):Ik(ke)}Se=Se.sibling}e:for(Se=null,ke=u;;){if(ke.tag===5){if(Se===null){Se=ke;try{C=ke.stateNode,ce?(T=C.style,typeof T.setProperty=="function"?T.setProperty("display","none","important"):T.display="none"):(H=ke.stateNode,Y=ke.memoizedProps.style,D=Y!=null&&Y.hasOwnProperty("display")?Y.display:null,H.style.display=Vo("display",D))}catch(je){yn(u,u.return,je)}}}else if(ke.tag===6){if(Se===null)try{ke.stateNode.nodeValue=ce?"":ke.memoizedProps}catch(je){yn(u,u.return,je)}}else if((ke.tag!==22&&ke.tag!==23||ke.memoizedState===null||ke===u)&&ke.child!==null){ke.child.return=ke,ke=ke.child;continue}if(ke===u)break e;for(;ke.sibling===null;){if(ke.return===null||ke.return===u)break e;Se===ke&&(Se=null),ke=ke.return}Se===ke&&(Se=null),ke.sibling.return=ke.return,ke=ke.sibling}}break;case 19:Io(h,u),ti(u),b&4&&Ck(u);break;case 21:break;default:Io(h,u),ti(u)}}function ti(u){var h=u.flags;if(h&2){try{e:{for(var m=u.return;m!==null;){if(bk(m)){var b=m;break e}m=m.return}throw Error(n(160))}switch(b.tag){case 5:var C=b.stateNode;b.flags&32&&(Mo(C,""),b.flags&=-33);var T=wk(u);z0(u,T,C);break;case 3:case 4:var D=b.stateNode.containerInfo,H=wk(u);L0(u,H,D);break;default:throw Error(n(161))}}catch(Y){yn(u,u.return,Y)}u.flags&=-3}h&4096&&(u.flags&=-4097)}function M4(u,h,m){ze=u,kk(u)}function kk(u,h,m){for(var b=(u.mode&1)!==0;ze!==null;){var C=ze,T=C.child;if(C.tag===22&&b){var D=C.memoizedState!==null||Vp;if(!D){var H=C.alternate,Y=H!==null&&H.memoizedState!==null||xr;H=Vp;var ce=xr;if(Vp=D,(xr=Y)&&!ce)for(ze=C;ze!==null;)D=ze,Y=D.child,D.tag===22&&D.memoizedState!==null?Nk(C):Y!==null?(Y.return=D,ze=Y):Nk(C);for(;T!==null;)ze=T,kk(T),T=T.sibling;ze=C,Vp=H,xr=ce}Tk(u)}else(C.subtreeFlags&8772)!==0&&T!==null?(T.return=C,ze=T):Tk(u)}}function Tk(u){for(;ze!==null;){var h=ze;if((h.flags&8772)!==0){var m=h.alternate;try{if((h.flags&8772)!==0)switch(h.tag){case 0:case 11:case 15:xr||Wp(5,h);break;case 1:var b=h.stateNode;if(h.flags&4&&!xr)if(m===null)b.componentDidMount();else{var C=h.elementType===h.type?m.memoizedProps:ko(h.type,m.memoizedProps);b.componentDidUpdate(C,m.memoizedState,b.__reactInternalSnapshotBeforeUpdate)}var T=h.updateQueue;T!==null&&I$(h,T,b);break;case 3:var D=h.updateQueue;if(D!==null){if(m=null,h.child!==null)switch(h.child.tag){case 5:m=h.child.stateNode;break;case 1:m=h.child.stateNode}I$(h,D,m)}break;case 5:var H=h.stateNode;if(m===null&&h.flags&4){m=H;var Y=h.memoizedProps;switch(h.type){case"button":case"input":case"select":case"textarea":Y.autoFocus&&m.focus();break;case"img":Y.src&&(m.src=Y.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(h.memoizedState===null){var ce=h.alternate;if(ce!==null){var Se=ce.memoizedState;if(Se!==null){var ke=Se.dehydrated;ke!==null&&wo(ke)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(n(163))}xr||h.flags&512&&O0(h)}catch(we){yn(h,h.return,we)}}if(h===u){ze=null;break}if(m=h.sibling,m!==null){m.return=h.return,ze=m;break}ze=h.return}}function Ik(u){for(;ze!==null;){var h=ze;if(h===u){ze=null;break}var m=h.sibling;if(m!==null){m.return=h.return,ze=m;break}ze=h.return}}function Nk(u){for(;ze!==null;){var h=ze;try{switch(h.tag){case 0:case 11:case 15:var m=h.return;try{Wp(4,h)}catch(Y){yn(h,m,Y)}break;case 1:var b=h.stateNode;if(typeof b.componentDidMount=="function"){var C=h.return;try{b.componentDidMount()}catch(Y){yn(h,C,Y)}}var T=h.return;try{O0(h)}catch(Y){yn(h,T,Y)}break;case 5:var D=h.return;try{O0(h)}catch(Y){yn(h,D,Y)}}}catch(Y){yn(h,h.return,Y)}if(h===u){ze=null;break}var H=h.sibling;if(H!==null){H.return=h.return,ze=H;break}ze=h.return}}var V4=Math.ceil,Up=R.ReactCurrentDispatcher,B0=R.ReactCurrentOwner,qs=R.ReactCurrentBatchConfig,Nt=0,Kn=null,In=null,or=0,Ts=0,bc=Wa(0),An=0,ch=null,Ql=0,jp=0,M0=0,dh=null,ss=null,V0=0,wc=1/0,Hi=null,Gp=!1,W0=null,Xa=null,Hp=!1,qa=null,Kp=0,hh=0,U0=null,Xp=-1,qp=0;function Or(){return(Nt&6)!==0?Ut():Xp!==-1?Xp:Xp=Ut()}function Ya(u){return(u.mode&1)===0?1:(Nt&2)!==0&&or!==0?or&-or:$4.transition!==null?(qp===0&&(qp=Ai()),qp):(u=wt,u!==0||(u=window.event,u=u===void 0?16:It(u.type)),u)}function No(u,h,m,b){if(50<hh)throw hh=0,U0=null,Error(n(185));Ko(u,m,b),((Nt&2)===0||u!==Kn)&&(u===Kn&&((Nt&2)===0&&(jp|=m),An===4&&Qa(u,or)),os(u,b),m===1&&Nt===0&&(h.mode&1)===0&&(wc=Ut()+500,Cp&&ja()))}function os(u,h){var m=u.callbackNode;Fa(u,h);var b=Pi(u,u===Kn?or:0);if(b===0)m!==null&&Mn(m),u.callbackNode=null,u.callbackPriority=0;else if(h=b&-b,u.callbackPriority!==h){if(m!=null&&Mn(m),h===1)u.tag===0?C4(Rk.bind(null,u)):m$(Rk.bind(null,u)),v4(function(){(Nt&6)===0&&ja()}),m=null;else{switch(Ll(b)){case 1:m=xo;break;case 4:m=Ni;break;case 16:m=tr;break;case 536870912:m=Ei;break;default:m=tr}m=zk(m,Ek.bind(null,u))}u.callbackPriority=h,u.callbackNode=m}}function Ek(u,h){if(Xp=-1,qp=0,(Nt&6)!==0)throw Error(n(327));var m=u.callbackNode;if(Sc()&&u.callbackNode!==m)return null;var b=Pi(u,u===Kn?or:0);if(b===0)return null;if((b&30)!==0||(b&u.expiredLanes)!==0||h)h=Yp(u,b);else{h=b;var C=Nt;Nt|=2;var T=Pk();(Kn!==u||or!==h)&&(Hi=null,wc=Ut()+500,Jl(u,h));do try{j4();break}catch(H){_k(u,H)}while(!0);a0(),Up.current=T,Nt=C,In!==null?h=0:(Kn=null,or=0,h=An)}if(h!==0){if(h===2&&(C=Oa(u),C!==0&&(b=C,h=j0(u,C))),h===1)throw m=ch,Jl(u,0),Qa(u,b),os(u,Ut()),m;if(h===6)Qa(u,b);else{if(C=u.current.alternate,(b&30)===0&&!W4(C)&&(h=Yp(u,b),h===2&&(T=Oa(u),T!==0&&(b=T,h=j0(u,T))),h===1))throw m=ch,Jl(u,0),Qa(u,b),os(u,Ut()),m;switch(u.finishedWork=C,u.finishedLanes=b,h){case 0:case 1:throw Error(n(345));case 2:eu(u,ss,Hi);break;case 3:if(Qa(u,b),(b&130023424)===b&&(h=V0+500-Ut(),10<h)){if(Pi(u,0)!==0)break;if(C=u.suspendedLanes,(C&b)!==b){Or(),u.pingedLanes|=u.suspendedLanes&C;break}u.timeoutHandle=Yy(eu.bind(null,u,ss,Hi),h);break}eu(u,ss,Hi);break;case 4:if(Qa(u,b),(b&4194240)===b)break;for(h=u.eventTimes,C=-1;0<b;){var D=31-fr(b);T=1<<D,D=h[D],D>C&&(C=D),b&=~T}if(b=C,b=Ut()-b,b=(120>b?120:480>b?480:1080>b?1080:1920>b?1920:3e3>b?3e3:4320>b?4320:1960*V4(b/1960))-b,10<b){u.timeoutHandle=Yy(eu.bind(null,u,ss,Hi),b);break}eu(u,ss,Hi);break;case 5:eu(u,ss,Hi);break;default:throw Error(n(329))}}}return os(u,Ut()),u.callbackNode===m?Ek.bind(null,u):null}function j0(u,h){var m=dh;return u.current.memoizedState.isDehydrated&&(Jl(u,h).flags|=256),u=Yp(u,h),u!==2&&(h=ss,ss=m,h!==null&&G0(h)),u}function G0(u){ss===null?ss=u:ss.push.apply(ss,u)}function W4(u){for(var h=u;;){if(h.flags&16384){var m=h.updateQueue;if(m!==null&&(m=m.stores,m!==null))for(var b=0;b<m.length;b++){var C=m[b],T=C.getSnapshot;C=C.value;try{if(!Co(T(),C))return!1}catch{return!1}}}if(m=h.child,h.subtreeFlags&16384&&m!==null)m.return=h,h=m;else{if(h===u)break;for(;h.sibling===null;){if(h.return===null||h.return===u)return!0;h=h.return}h.sibling.return=h.return,h=h.sibling}}return!0}function Qa(u,h){for(h&=~M0,h&=~jp,u.suspendedLanes|=h,u.pingedLanes&=~h,u=u.expirationTimes;0<h;){var m=31-fr(h),b=1<<m;u[m]=-1,h&=~b}}function Rk(u){if((Nt&6)!==0)throw Error(n(327));Sc();var h=Pi(u,0);if((h&1)===0)return os(u,Ut()),null;var m=Yp(u,h);if(u.tag!==0&&m===2){var b=Oa(u);b!==0&&(h=b,m=j0(u,b))}if(m===1)throw m=ch,Jl(u,0),Qa(u,h),os(u,Ut()),m;if(m===6)throw Error(n(345));return u.finishedWork=u.current.alternate,u.finishedLanes=h,eu(u,ss,Hi),os(u,Ut()),null}function H0(u,h){var m=Nt;Nt|=1;try{return u(h)}finally{Nt=m,Nt===0&&(wc=Ut()+500,Cp&&ja())}}function Zl(u){qa!==null&&qa.tag===0&&(Nt&6)===0&&Sc();var h=Nt;Nt|=1;var m=qs.transition,b=wt;try{if(qs.transition=null,wt=1,u)return u()}finally{wt=b,qs.transition=m,Nt=h,(Nt&6)===0&&ja()}}function K0(){Ts=bc.current,on(bc)}function Jl(u,h){u.finishedWork=null,u.finishedLanes=0;var m=u.timeoutHandle;if(m!==-1&&(u.timeoutHandle=-1,x4(m)),In!==null)for(m=In.return;m!==null;){var b=m;switch(n0(b),b.tag){case 1:b=b.type.childContextTypes,b!=null&&wp();break;case 3:yc(),on(ts),on(mr),m0();break;case 5:f0(b);break;case 4:yc();break;case 13:on(cn);break;case 19:on(cn);break;case 10:l0(b.type._context);break;case 22:case 23:K0()}m=m.return}if(Kn=u,In=u=Za(u.current,null),or=Ts=h,An=0,ch=null,M0=jp=Ql=0,ss=dh=null,Xl!==null){for(h=0;h<Xl.length;h++)if(m=Xl[h],b=m.interleaved,b!==null){m.interleaved=null;var C=b.next,T=m.pending;if(T!==null){var D=T.next;T.next=C,b.next=D}m.pending=b}Xl=null}return u}function _k(u,h){do{var m=In;try{if(a0(),Ap.current=Lp,Dp){for(var b=dn.memoizedState;b!==null;){var C=b.queue;C!==null&&(C.pending=null),b=b.next}Dp=!1}if(Yl=0,Hn=Pn=dn=null,sh=!1,oh=0,B0.current=null,m===null||m.return===null){An=1,ch=h,In=null;break}e:{var T=u,D=m.return,H=m,Y=h;if(h=or,H.flags|=32768,Y!==null&&typeof Y=="object"&&typeof Y.then=="function"){var ce=Y,Se=H,ke=Se.tag;if((Se.mode&1)===0&&(ke===0||ke===11||ke===15)){var we=Se.alternate;we?(Se.updateQueue=we.updateQueue,Se.memoizedState=we.memoizedState,Se.lanes=we.lanes):(Se.updateQueue=null,Se.memoizedState=null)}var Le=nk(D);if(Le!==null){Le.flags&=-257,rk(Le,D,H,T,h),Le.mode&1&&tk(T,ce,h),h=Le,Y=ce;var Me=h.updateQueue;if(Me===null){var je=new Set;je.add(Y),h.updateQueue=je}else Me.add(Y);break e}else{if((h&1)===0){tk(T,ce,h),X0();break e}Y=Error(n(426))}}else if(ln&&H.mode&1){var Sn=nk(D);if(Sn!==null){(Sn.flags&65536)===0&&(Sn.flags|=256),rk(Sn,D,H,T,h),o0(xc(Y,H));break e}}T=Y=xc(Y,H),An!==4&&(An=2),dh===null?dh=[T]:dh.push(T),T=D;do{switch(T.tag){case 3:T.flags|=65536,h&=-h,T.lanes|=h;var ie=J$(T,Y,h);T$(T,ie);break e;case 1:H=Y;var te=T.type,le=T.stateNode;if((T.flags&128)===0&&(typeof te.getDerivedStateFromError=="function"||le!==null&&typeof le.componentDidCatch=="function"&&(Xa===null||!Xa.has(le)))){T.flags|=65536,h&=-h,T.lanes|=h;var Ie=ek(T,H,h);T$(T,Ie);break e}}T=T.return}while(T!==null)}Dk(m)}catch(Ge){h=Ge,In===m&&m!==null&&(In=m=m.return);continue}break}while(!0)}function Pk(){var u=Up.current;return Up.current=Lp,u===null?Lp:u}function X0(){(An===0||An===3||An===2)&&(An=4),Kn===null||(Ql&268435455)===0&&(jp&268435455)===0||Qa(Kn,or)}function Yp(u,h){var m=Nt;Nt|=2;var b=Pk();(Kn!==u||or!==h)&&(Hi=null,Jl(u,h));do try{U4();break}catch(C){_k(u,C)}while(!0);if(a0(),Nt=m,Up.current=b,In!==null)throw Error(n(261));return Kn=null,or=0,An}function U4(){for(;In!==null;)Ak(In)}function j4(){for(;In!==null&&!Yr();)Ak(In)}function Ak(u){var h=Lk(u.alternate,u,Ts);u.memoizedProps=u.pendingProps,h===null?Dk(u):In=h,B0.current=null}function Dk(u){var h=u;do{var m=h.alternate;if(u=h.return,(h.flags&32768)===0){if(m=O4(m,h,Ts),m!==null){In=m;return}}else{if(m=L4(m,h),m!==null){m.flags&=32767,In=m;return}if(u!==null)u.flags|=32768,u.subtreeFlags=0,u.deletions=null;else{An=6,In=null;return}}if(h=h.sibling,h!==null){In=h;return}In=h=u}while(h!==null);An===0&&(An=5)}function eu(u,h,m){var b=wt,C=qs.transition;try{qs.transition=null,wt=1,G4(u,h,m,b)}finally{qs.transition=C,wt=b}return null}function G4(u,h,m,b){do Sc();while(qa!==null);if((Nt&6)!==0)throw Error(n(327));m=u.finishedWork;var C=u.finishedLanes;if(m===null)return null;if(u.finishedWork=null,u.finishedLanes=0,m===u.current)throw Error(n(177));u.callbackNode=null,u.callbackPriority=0;var T=m.lanes|m.childLanes;if(Wd(u,T),u===Kn&&(In=Kn=null,or=0),(m.subtreeFlags&2064)===0&&(m.flags&2064)===0||Hp||(Hp=!0,zk(tr,function(){return Sc(),null})),T=(m.flags&15990)!==0,(m.subtreeFlags&15990)!==0||T){T=qs.transition,qs.transition=null;var D=wt;wt=1;var H=Nt;Nt|=4,B0.current=null,B4(u,m),$k(m,u),d4(Xy),U=!!Ky,Xy=Ky=null,u.current=m,M4(m),Us(),Nt=H,wt=D,qs.transition=T}else u.current=m;if(Hp&&(Hp=!1,qa=u,Kp=C),T=u.pendingLanes,T===0&&(Xa=null),Bd(m.stateNode),os(u,Ut()),h!==null)for(b=u.onRecoverableError,m=0;m<h.length;m++)C=h[m],b(C.value,{componentStack:C.stack,digest:C.digest});if(Gp)throw Gp=!1,u=W0,W0=null,u;return(Kp&1)!==0&&u.tag!==0&&Sc(),T=u.pendingLanes,(T&1)!==0?u===U0?hh++:(hh=0,U0=u):hh=0,ja(),null}function Sc(){if(qa!==null){var u=Ll(Kp),h=qs.transition,m=wt;try{if(qs.transition=null,wt=16>u?16:u,qa===null)var b=!1;else{if(u=qa,qa=null,Kp=0,(Nt&6)!==0)throw Error(n(331));var C=Nt;for(Nt|=4,ze=u.current;ze!==null;){var T=ze,D=T.child;if((ze.flags&16)!==0){var H=T.deletions;if(H!==null){for(var Y=0;Y<H.length;Y++){var ce=H[Y];for(ze=ce;ze!==null;){var Se=ze;switch(Se.tag){case 0:case 11:case 15:uh(8,Se,T)}var ke=Se.child;if(ke!==null)ke.return=Se,ze=ke;else for(;ze!==null;){Se=ze;var we=Se.sibling,Le=Se.return;if(vk(Se),Se===ce){ze=null;break}if(we!==null){we.return=Le,ze=we;break}ze=Le}}}var Me=T.alternate;if(Me!==null){var je=Me.child;if(je!==null){Me.child=null;do{var Sn=je.sibling;je.sibling=null,je=Sn}while(je!==null)}}ze=T}}if((T.subtreeFlags&2064)!==0&&D!==null)D.return=T,ze=D;else e:for(;ze!==null;){if(T=ze,(T.flags&2048)!==0)switch(T.tag){case 0:case 11:case 15:uh(9,T,T.return)}var ie=T.sibling;if(ie!==null){ie.return=T.return,ze=ie;break e}ze=T.return}}var te=u.current;for(ze=te;ze!==null;){D=ze;var le=D.child;if((D.subtreeFlags&2064)!==0&&le!==null)le.return=D,ze=le;else e:for(D=te;ze!==null;){if(H=ze,(H.flags&2048)!==0)try{switch(H.tag){case 0:case 11:case 15:Wp(9,H)}}catch(Ge){yn(H,H.return,Ge)}if(H===D){ze=null;break e}var Ie=H.sibling;if(Ie!==null){Ie.return=H.return,ze=Ie;break e}ze=H.return}}if(Nt=C,ja(),nr&&typeof nr.onPostCommitFiberRoot=="function")try{nr.onPostCommitFiberRoot(Vn,u)}catch{}b=!0}return b}finally{wt=m,qs.transition=h}}return!1}function Fk(u,h,m){h=xc(m,h),h=J$(u,h,1),u=Ha(u,h,1),h=Or(),u!==null&&(Ko(u,1,h),os(u,h))}function yn(u,h,m){if(u.tag===3)Fk(u,u,m);else for(;h!==null;){if(h.tag===3){Fk(h,u,m);break}else if(h.tag===1){var b=h.stateNode;if(typeof h.type.getDerivedStateFromError=="function"||typeof b.componentDidCatch=="function"&&(Xa===null||!Xa.has(b))){u=xc(m,u),u=ek(h,u,1),h=Ha(h,u,1),u=Or(),h!==null&&(Ko(h,1,u),os(h,u));break}}h=h.return}}function H4(u,h,m){var b=u.pingCache;b!==null&&b.delete(h),h=Or(),u.pingedLanes|=u.suspendedLanes&m,Kn===u&&(or&m)===m&&(An===4||An===3&&(or&130023424)===or&&500>Ut()-V0?Jl(u,0):M0|=m),os(u,h)}function Ok(u,h){h===0&&((u.mode&1)===0?h=1:(h=_i,_i<<=1,(_i&130023424)===0&&(_i=4194304)));var m=Or();u=Ui(u,h),u!==null&&(Ko(u,h,m),os(u,m))}function K4(u){var h=u.memoizedState,m=0;h!==null&&(m=h.retryLane),Ok(u,m)}function X4(u,h){var m=0;switch(u.tag){case 13:var b=u.stateNode,C=u.memoizedState;C!==null&&(m=C.retryLane);break;case 19:b=u.stateNode;break;default:throw Error(n(314))}b!==null&&b.delete(h),Ok(u,m)}var Lk;Lk=function(u,h,m){if(u!==null)if(u.memoizedProps!==h.pendingProps||ts.current)rs=!0;else{if((u.lanes&m)===0&&(h.flags&128)===0)return rs=!1,F4(u,h,m);rs=(u.flags&131072)!==0}else rs=!1,ln&&(h.flags&1048576)!==0&&g$(h,kp,h.index);switch(h.lanes=0,h.tag){case 2:var b=h.type;Mp(u,h),u=h.pendingProps;var C=cc(h,mr.current);gc(h,m),C=x0(null,h,b,u,C,m);var T=v0();return h.flags|=1,typeof C=="object"&&C!==null&&typeof C.render=="function"&&C.$$typeof===void 0?(h.tag=1,h.memoizedState=null,h.updateQueue=null,ns(b)?(T=!0,Sp(h)):T=!1,h.memoizedState=C.state!==null&&C.state!==void 0?C.state:null,d0(h),C.updater=zp,h.stateNode=C,C._reactInternals=h,k0(h,b,u,m),h=E0(null,h,b,!0,T,m)):(h.tag=0,ln&&T&&t0(h),Fr(null,h,C,m),h=h.child),h;case 16:b=h.elementType;e:{switch(Mp(u,h),u=h.pendingProps,C=b._init,b=C(b._payload),h.type=b,C=h.tag=Y4(b),u=ko(b,u),C){case 0:h=N0(null,h,b,u,m);break e;case 1:h=uk(null,h,b,u,m);break e;case 11:h=sk(null,h,b,u,m);break e;case 14:h=ok(null,h,b,ko(b.type,u),m);break e}throw Error(n(306,b,""))}return h;case 0:return b=h.type,C=h.pendingProps,C=h.elementType===b?C:ko(b,C),N0(u,h,b,C,m);case 1:return b=h.type,C=h.pendingProps,C=h.elementType===b?C:ko(b,C),uk(u,h,b,C,m);case 3:e:{if(ck(h),u===null)throw Error(n(387));b=h.pendingProps,T=h.memoizedState,C=T.element,k$(u,h),_p(h,b,null,m);var D=h.memoizedState;if(b=D.element,T.isDehydrated)if(T={element:b,isDehydrated:!1,cache:D.cache,pendingSuspenseBoundaries:D.pendingSuspenseBoundaries,transitions:D.transitions},h.updateQueue.baseState=T,h.memoizedState=T,h.flags&256){C=xc(Error(n(423)),h),h=dk(u,h,b,m,C);break e}else if(b!==C){C=xc(Error(n(424)),h),h=dk(u,h,b,m,C);break e}else for(ks=Va(h.stateNode.containerInfo.firstChild),$s=h,ln=!0,$o=null,m=C$(h,null,b,m),h.child=m;m;)m.flags=m.flags&-3|4096,m=m.sibling;else{if(fc(),b===C){h=Gi(u,h,m);break e}Fr(u,h,b,m)}h=h.child}return h;case 5:return N$(h),u===null&&s0(h),b=h.type,C=h.pendingProps,T=u!==null?u.memoizedProps:null,D=C.children,qy(b,C)?D=null:T!==null&&qy(b,T)&&(h.flags|=32),lk(u,h),Fr(u,h,D,m),h.child;case 6:return u===null&&s0(h),null;case 13:return hk(u,h,m);case 4:return h0(h,h.stateNode.containerInfo),b=h.pendingProps,u===null?h.child=pc(h,null,b,m):Fr(u,h,b,m),h.child;case 11:return b=h.type,C=h.pendingProps,C=h.elementType===b?C:ko(b,C),sk(u,h,b,C,m);case 7:return Fr(u,h,h.pendingProps,m),h.child;case 8:return Fr(u,h,h.pendingProps.children,m),h.child;case 12:return Fr(u,h,h.pendingProps.children,m),h.child;case 10:e:{if(b=h.type._context,C=h.pendingProps,T=h.memoizedProps,D=C.value,Jt(Np,b._currentValue),b._currentValue=D,T!==null)if(Co(T.value,D)){if(T.children===C.children&&!ts.current){h=Gi(u,h,m);break e}}else for(T=h.child,T!==null&&(T.return=h);T!==null;){var H=T.dependencies;if(H!==null){D=T.child;for(var Y=H.firstContext;Y!==null;){if(Y.context===b){if(T.tag===1){Y=ji(-1,m&-m),Y.tag=2;var ce=T.updateQueue;if(ce!==null){ce=ce.shared;var Se=ce.pending;Se===null?Y.next=Y:(Y.next=Se.next,Se.next=Y),ce.pending=Y}}T.lanes|=m,Y=T.alternate,Y!==null&&(Y.lanes|=m),u0(T.return,m,h),H.lanes|=m;break}Y=Y.next}}else if(T.tag===10)D=T.type===h.type?null:T.child;else if(T.tag===18){if(D=T.return,D===null)throw Error(n(341));D.lanes|=m,H=D.alternate,H!==null&&(H.lanes|=m),u0(D,m,h),D=T.sibling}else D=T.child;if(D!==null)D.return=T;else for(D=T;D!==null;){if(D===h){D=null;break}if(T=D.sibling,T!==null){T.return=D.return,D=T;break}D=D.return}T=D}Fr(u,h,C.children,m),h=h.child}return h;case 9:return C=h.type,b=h.pendingProps.children,gc(h,m),C=Ks(C),b=b(C),h.flags|=1,Fr(u,h,b,m),h.child;case 14:return b=h.type,C=ko(b,h.pendingProps),C=ko(b.type,C),ok(u,h,b,C,m);case 15:return ik(u,h,h.type,h.pendingProps,m);case 17:return b=h.type,C=h.pendingProps,C=h.elementType===b?C:ko(b,C),Mp(u,h),h.tag=1,ns(b)?(u=!0,Sp(h)):u=!1,gc(h,m),Q$(h,b,C),k0(h,b,C,m),E0(null,h,b,!0,u,m);case 19:return pk(u,h,m);case 22:return ak(u,h,m)}throw Error(n(156,h.tag))};function zk(u,h){return Al(u,h)}function q4(u,h,m,b){this.tag=u,this.key=m,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=h,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=b,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ys(u,h,m,b){return new q4(u,h,m,b)}function q0(u){return u=u.prototype,!(!u||!u.isReactComponent)}function Y4(u){if(typeof u=="function")return q0(u)?1:0;if(u!=null){if(u=u.$$typeof,u===re)return 11;if(u===ye)return 14}return 2}function Za(u,h){var m=u.alternate;return m===null?(m=Ys(u.tag,h,u.key,u.mode),m.elementType=u.elementType,m.type=u.type,m.stateNode=u.stateNode,m.alternate=u,u.alternate=m):(m.pendingProps=h,m.type=u.type,m.flags=0,m.subtreeFlags=0,m.deletions=null),m.flags=u.flags&14680064,m.childLanes=u.childLanes,m.lanes=u.lanes,m.child=u.child,m.memoizedProps=u.memoizedProps,m.memoizedState=u.memoizedState,m.updateQueue=u.updateQueue,h=u.dependencies,m.dependencies=h===null?null:{lanes:h.lanes,firstContext:h.firstContext},m.sibling=u.sibling,m.index=u.index,m.ref=u.ref,m}function Qp(u,h,m,b,C,T){var D=2;if(b=u,typeof u=="function")q0(u)&&(D=1);else if(typeof u=="string")D=5;else e:switch(u){case O:return tu(m.children,C,T,h);case M:D=8,C|=8;break;case B:return u=Ys(12,m,h,C|2),u.elementType=B,u.lanes=T,u;case ae:return u=Ys(13,m,h,C),u.elementType=ae,u.lanes=T,u;case pe:return u=Ys(19,m,h,C),u.elementType=pe,u.lanes=T,u;case $e:return Zp(m,C,T,h);default:if(typeof u=="object"&&u!==null)switch(u.$$typeof){case V:D=10;break e;case A:D=9;break e;case re:D=11;break e;case ye:D=14;break e;case ve:D=16,b=null;break e}throw Error(n(130,u==null?u:typeof u,""))}return h=Ys(D,m,h,C),h.elementType=u,h.type=b,h.lanes=T,h}function tu(u,h,m,b){return u=Ys(7,u,b,h),u.lanes=m,u}function Zp(u,h,m,b){return u=Ys(22,u,b,h),u.elementType=$e,u.lanes=m,u.stateNode={isHidden:!1},u}function Y0(u,h,m){return u=Ys(6,u,null,h),u.lanes=m,u}function Q0(u,h,m){return h=Ys(4,u.children!==null?u.children:[],u.key,h),h.lanes=m,h.stateNode={containerInfo:u.containerInfo,pendingChildren:null,implementation:u.implementation},h}function Q4(u,h,m,b,C){this.tag=h,this.containerInfo=u,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=Di(0),this.expirationTimes=Di(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Di(0),this.identifierPrefix=b,this.onRecoverableError=C,this.mutableSourceEagerHydrationData=null}function Z0(u,h,m,b,C,T,D,H,Y){return u=new Q4(u,h,m,H,Y),h===1?(h=1,T===!0&&(h|=8)):h=0,T=Ys(3,null,null,h),u.current=T,T.stateNode=u,T.memoizedState={element:b,isDehydrated:m,cache:null,transitions:null,pendingSuspenseBoundaries:null},d0(T),u}function Z4(u,h,m){var b=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:F,key:b==null?null:""+b,children:u,containerInfo:h,implementation:m}}function Bk(u){if(!u)return Ua;u=u._reactInternals;e:{if(Bn(u)!==u||u.tag!==1)throw Error(n(170));var h=u;do{switch(h.tag){case 3:h=h.stateNode.context;break e;case 1:if(ns(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break e}}h=h.return}while(h!==null);throw Error(n(171))}if(u.tag===1){var m=u.type;if(ns(m))return f$(u,m,h)}return h}function Mk(u,h,m,b,C,T,D,H,Y){return u=Z0(m,b,!0,u,C,T,D,H,Y),u.context=Bk(null),m=u.current,b=Or(),C=Ya(m),T=ji(b,C),T.callback=h??null,Ha(m,T,C),u.current.lanes=C,Ko(u,C,b),os(u,b),u}function Jp(u,h,m,b){var C=h.current,T=Or(),D=Ya(C);return m=Bk(m),h.context===null?h.context=m:h.pendingContext=m,h=ji(T,D),h.payload={element:u},b=b===void 0?null:b,b!==null&&(h.callback=b),u=Ha(C,h,D),u!==null&&(No(u,C,D,T),Rp(u,C,D)),D}function em(u){if(u=u.current,!u.child)return null;switch(u.child.tag){case 5:return u.child.stateNode;default:return u.child.stateNode}}function Vk(u,h){if(u=u.memoizedState,u!==null&&u.dehydrated!==null){var m=u.retryLane;u.retryLane=m!==0&&m<h?m:h}}function J0(u,h){Vk(u,h),(u=u.alternate)&&Vk(u,h)}function J4(){return null}var Wk=typeof reportError=="function"?reportError:function(u){console.error(u)};function e1(u){this._internalRoot=u}tm.prototype.render=e1.prototype.render=function(u){var h=this._internalRoot;if(h===null)throw Error(n(409));Jp(u,h,null,null)},tm.prototype.unmount=e1.prototype.unmount=function(){var u=this._internalRoot;if(u!==null){this._internalRoot=null;var h=u.containerInfo;Zl(function(){Jp(null,u,null,null)}),h[Bi]=null}};function tm(u){this._internalRoot=u}tm.prototype.unstable_scheduleHydration=function(u){if(u){var h=Xo();u={blockedOn:null,target:u,priority:h};for(var m=0;m<Zr.length&&h!==0&&h<Zr[m].priority;m++);Zr.splice(m,0,u),m===0&&bo(u)}};function t1(u){return!(!u||u.nodeType!==1&&u.nodeType!==9&&u.nodeType!==11)}function nm(u){return!(!u||u.nodeType!==1&&u.nodeType!==9&&u.nodeType!==11&&(u.nodeType!==8||u.nodeValue!==" react-mount-point-unstable "))}function Uk(){}function eL(u,h,m,b,C){if(C){if(typeof b=="function"){var T=b;b=function(){var ce=em(D);T.call(ce)}}var D=Mk(h,b,u,0,null,!1,!1,"",Uk);return u._reactRootContainer=D,u[Bi]=D.current,Yd(u.nodeType===8?u.parentNode:u),Zl(),D}for(;C=u.lastChild;)u.removeChild(C);if(typeof b=="function"){var H=b;b=function(){var ce=em(Y);H.call(ce)}}var Y=Z0(u,0,!1,null,null,!1,!1,"",Uk);return u._reactRootContainer=Y,u[Bi]=Y.current,Yd(u.nodeType===8?u.parentNode:u),Zl(function(){Jp(h,Y,m,b)}),Y}function rm(u,h,m,b,C){var T=m._reactRootContainer;if(T){var D=T;if(typeof C=="function"){var H=C;C=function(){var Y=em(D);H.call(Y)}}Jp(h,D,u,C)}else D=eL(m,h,u,C,b);return em(D)}Fi=function(u){switch(u.tag){case 3:var h=u.stateNode;if(h.current.memoizedState.isDehydrated){var m=Ho(h.pendingLanes);m!==0&&(Ol(h,m|1),os(h,Ut()),(Nt&6)===0&&(wc=Ut()+500,ja()))}break;case 13:Zl(function(){var b=Ui(u,1);if(b!==null){var C=Or();No(b,u,1,C)}}),J0(u,1)}},La=function(u){if(u.tag===13){var h=Ui(u,134217728);if(h!==null){var m=Or();No(h,u,134217728,m)}J0(u,134217728)}},Oi=function(u){if(u.tag===13){var h=Ya(u),m=Ui(u,h);if(m!==null){var b=Or();No(m,u,h,b)}J0(u,h)}},Xo=function(){return wt},Qu=function(u,h){var m=wt;try{return wt=u,h()}finally{wt=m}},Ms=function(u,h,m){switch(h){case"input":if(ka(u,m),h=m.name,m.type==="radio"&&h!=null){for(m=u;m.parentNode;)m=m.parentNode;for(m=m.querySelectorAll("input[name="+JSON.stringify(""+h)+'][type="radio"]'),h=0;h<m.length;h++){var b=m[h];if(b!==u&&b.form===u.form){var C=bp(b);if(!C)throw Error(n(90));Ls(b),ka(b,C)}}}break;case"textarea":ws(u,m);break;case"select":h=m.value,h!=null&&bs(u,!!m.multiple,h,!1)}},_a=H0,_l=Zl;var tL={usingClientEntryPoint:!1,Events:[Jd,lc,bp,Rl,Vs,H0]},fh={findFiberByHostInstance:jl,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},nL={bundleType:fh.bundleType,version:fh.version,rendererPackageName:fh.rendererPackageName,rendererConfig:fh.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:R.ReactCurrentDispatcher,findHostInstanceByFiber:function(u){return u=Aa(u),u===null?null:u.stateNode},findFiberByHostInstance:fh.findFiberByHostInstance||J4,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var sm=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!sm.isDisabled&&sm.supportsFiber)try{Vn=sm.inject(nL),nr=sm}catch{}}return is.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=tL,is.createPortal=function(u,h){var m=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!t1(h))throw Error(n(200));return Z4(u,h,null,m)},is.createRoot=function(u,h){if(!t1(u))throw Error(n(299));var m=!1,b="",C=Wk;return h!=null&&(h.unstable_strictMode===!0&&(m=!0),h.identifierPrefix!==void 0&&(b=h.identifierPrefix),h.onRecoverableError!==void 0&&(C=h.onRecoverableError)),h=Z0(u,1,!1,null,null,m,!1,b,C),u[Bi]=h.current,Yd(u.nodeType===8?u.parentNode:u),new e1(h)},is.findDOMNode=function(u){if(u==null)return null;if(u.nodeType===1)return u;var h=u._reactInternals;if(h===void 0)throw typeof u.render=="function"?Error(n(188)):(u=Object.keys(u).join(","),Error(n(268,u)));return u=Aa(h),u=u===null?null:u.stateNode,u},is.flushSync=function(u){return Zl(u)},is.hydrate=function(u,h,m){if(!nm(h))throw Error(n(200));return rm(null,u,h,!0,m)},is.hydrateRoot=function(u,h,m){if(!t1(u))throw Error(n(405));var b=m!=null&&m.hydratedSources||null,C=!1,T="",D=Wk;if(m!=null&&(m.unstable_strictMode===!0&&(C=!0),m.identifierPrefix!==void 0&&(T=m.identifierPrefix),m.onRecoverableError!==void 0&&(D=m.onRecoverableError)),h=Mk(h,null,u,1,m??null,C,!1,T,D),u[Bi]=h.current,Yd(u),b)for(u=0;u<b.length;u++)m=b[u],C=m._getVersion,C=C(m._source),h.mutableSourceEagerHydrationData==null?h.mutableSourceEagerHydrationData=[m,C]:h.mutableSourceEagerHydrationData.push(m,C);return new tm(h)},is.render=function(u,h,m){if(!nm(h))throw Error(n(200));return rm(null,u,h,!1,m)},is.unmountComponentAtNode=function(u){if(!nm(u))throw Error(n(40));return u._reactRootContainer?(Zl(function(){rm(null,null,u,!1,function(){u._reactRootContainer=null,u[Bi]=null})}),!0):!1},is.unstable_batchedUpdates=H0,is.unstable_renderSubtreeIntoContainer=function(u,h,m,b){if(!nm(m))throw Error(n(200));if(u==null||u._reactInternals===void 0)throw Error(n(38));return rm(u,h,m,!1,b)},is.version="18.3.1-next-f1338f8080-20240426",is}var Zk;function z3(){if(Zk)return s1.exports;Zk=1;function t(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t)}catch(e){console.error(e)}}return t(),s1.exports=cL(),s1.exports}var Jk;function dL(){if(Jk)return om;Jk=1;var t=z3();return om.createRoot=t.createRoot,om.hydrateRoot=t.hydrateRoot,om}var hL=dL();const fL=Df(hL),pL="/tapfit-app/assets/body_measurement-Be1IKEjH.png";function mL(){return!!(globalThis!=null&&globalThis.document)}function gL(t,...e){if(t==null)throw new TypeError("Cannot convert undefined or null to object");const n={...t};for(const r of e)if(r!=null)for(const s in r)Object.prototype.hasOwnProperty.call(r,s)&&(s in n&&delete n[s],n[s]=r[s]);return n}const si=t=>t?"":void 0,a1=t=>t?!0:void 0;function mx(t){return Array.isArray(t)}function Mr(t){const e=typeof t;return t!=null&&(e==="object"||e==="function")&&!mx(t)}function yL(t){const e=t==null?0:t.length;return e?t[e-1]:void 0}function xL(t){const e=parseFloat(t.toString()),n=t.toString().replace(String(e),"");return{unitless:!n,value:e,unit:n}}function gx(t){if(t==null)return t;const{unitless:e}=xL(t);return e||typeof t=="number"?`${t}px`:t}const B3=(t,e)=>parseInt(t[1],10)>parseInt(e[1],10)?1:-1,Uv=t=>Object.fromEntries(Object.entries(t).sort(B3));function eT(t){const e=Uv(t);return Object.assign(Object.values(e),e)}function vL(t){const e=Object.keys(Uv(t));return new Set(e)}function tT(t){if(!t)return t;t=gx(t)??t;const e=-.02;return typeof t=="number"?`${t+e}`:t.replace(/(\d+\.?\d*)/u,n=>`${parseFloat(n)+e}`)}function $h(t,e){const n=["@media screen"];return t&&n.push("and",`(min-width: ${gx(t)})`),e&&n.push("and",`(max-width: ${gx(e)})`),n.join(" ")}function bL(t){if(!t)return null;t.base=t.base??"0px";const e=eT(t),n=Object.entries(t).sort(B3).map(([o,i],a,l)=>{let[,c]=l[a+1]??[];return c=parseFloat(c)>0?tT(c):void 0,{_minW:tT(i),breakpoint:o,minW:i,maxW:c,maxWQuery:$h(null,c),minWQuery:$h(i),minMaxQuery:$h(i,c)}}),r=vL(t),s=Array.from(r.values());return{keys:r,normalized:e,isResponsive(o){const i=Object.keys(o);return i.length>0&&i.every(a=>r.has(a))},asObject:Uv(t),asArray:eT(t),details:n,get(o){return n.find(i=>i.breakpoint===o)},media:[null,...e.map(o=>$h(o)).slice(1)],toArrayValue(o){if(!Mr(o))throw new Error("toArrayValue: value must be an object");const i=s.map(a=>o[a]??null);for(;yL(i)===null;)i.pop();return i},toObjectValue(o){if(!Array.isArray(o))throw new Error("toObjectValue: value must be an array");return o.reduce((i,a,l)=>{const c=s[l];return c!=null&&a!=null&&(i[c]=a),i},{})}}}function nT(...t){return function(n){t.some(r=>(r==null||r(n),n==null?void 0:n.defaultPrevented))}}function jv(t){return ee.Children.toArray(t).filter(e=>ee.isValidElement(e))}function Wg(t){const e=Object.assign({},t);for(let n in e)e[n]===void 0&&delete e[n];return e}function wL(t,e){return`${t} returned \`undefined\`. Seems you forgot to wrap component within ${e}`}function Gr(t={}){const{name:e,strict:n=!0,hookName:r="useContext",providerName:s="Provider",errorMessage:o,defaultValue:i}=t,a=ee.createContext(i);a.displayName=e;function l(){var d;const c=ee.useContext(a);if(!c&&n){const f=new Error(o??wL(r,s));throw f.name="ContextError",(d=Error.captureStackTrace)==null||d.call(Error,f,l),f}return c}return[a.Provider,l,a]}const Lt=(...t)=>t.filter(Boolean).join(" ");function SL(t,e,n,r){const s=typeof e=="string"?e.split("."):[e];for(r=0;r<s.length&&t;r+=1)t=t[s[r]];return t===void 0?n:t}const CL=t=>{const e=new WeakMap;return(r,s,o,i)=>{if(typeof r>"u")return t(r,s,o);e.has(r)||e.set(r,new Map);const a=e.get(r);if(a.has(s))return a.get(s);const l=t(r,s,o,i);return a.set(s,l),l}},M3=CL(SL),$L=t=>t.default||t;function Gv(t,e=[]){const n=Object.assign({},t);for(const r of e)r in n&&delete n[r];return n}function kL(t,e){const n={};for(const r of e)r in t&&(n[r]=t[r]);return n}function Hv(t,e){return Array.isArray(t)?t.map(n=>n===null?null:e(n)):Mr(t)?Object.keys(t).reduce((n,r)=>(n[r]=e(t[r]),n),{}):t!=null?e(t):null}const TL=t=>typeof t=="function";function ro(t,...e){return TL(t)?t(...e):t}function IL(t,...e){const n=Object.getOwnPropertyDescriptors(t),r=Object.keys(n),s=i=>{const a={};for(let l=0;l<i.length;l++){const c=i[l];n[c]&&(Object.defineProperty(a,c,n[c]),delete n[c])}return a},o=i=>s(Array.isArray(i)?i:r.filter(i));return e.map(o).concat(s(r))}function rT(t,e,n={}){const{stop:r,getKey:s}=n;function o(i,a=[]){if(Mr(i)||Array.isArray(i)){const l={};for(const[c,d]of Object.entries(i)){const f=(s==null?void 0:s(c))??c,p=[...a,f];if(r!=null&&r(i,p))return e(i,a);l[f]=o(d,p)}return l}return e(i,a)}return o(t)}var kh={exports:{}};kh.exports;var sT;function NL(){return sT||(sT=1,function(t,e){var n=200,r="__lodash_hash_undefined__",s=800,o=16,i=9007199254740991,a="[object Arguments]",l="[object Array]",c="[object AsyncFunction]",d="[object Boolean]",f="[object Date]",p="[object Error]",g="[object Function]",y="[object GeneratorFunction]",x="[object Map]",w="[object Number]",S="[object Null]",$="[object Object]",I="[object Proxy]",R="[object RegExp]",_="[object Set]",F="[object String]",O="[object Undefined]",M="[object WeakMap]",B="[object ArrayBuffer]",V="[object DataView]",A="[object Float32Array]",re="[object Float64Array]",ae="[object Int8Array]",pe="[object Int16Array]",ye="[object Int32Array]",ve="[object Uint8Array]",$e="[object Uint8ClampedArray]",se="[object Uint16Array]",me="[object Uint32Array]",ge=/[\\^$.*+?()[\]{}|]/g,Q=/^\[object .+?Constructor\]$/,he=/^(?:0|[1-9]\d*)$/,be={};be[A]=be[re]=be[ae]=be[pe]=be[ye]=be[ve]=be[$e]=be[se]=be[me]=!0,be[a]=be[l]=be[B]=be[d]=be[V]=be[f]=be[p]=be[g]=be[x]=be[w]=be[$]=be[R]=be[_]=be[F]=be[M]=!1;var We=typeof Pc=="object"&&Pc&&Pc.Object===Object&&Pc,nt=typeof self=="object"&&self&&self.Object===Object&&self,Xe=We||nt||Function("return this")(),kt=e&&!e.nodeType&&e,mt=kt&&!0&&t&&!t.nodeType&&t,Et=mt&&mt.exports===kt,rn=Et&&We.process,Jn=function(){try{var U=mt&&mt.require&&mt.require("util").types;return U||rn&&rn.binding&&rn.binding("util")}catch{}}(),Ls=Jn&&Jn.isTypedArray;function Wt(U,J,de){switch(de.length){case 0:return U.call(J);case 1:return U.call(J,de[0]);case 2:return U.call(J,de[0],de[1]);case 3:return U.call(J,de[0],de[1],de[2])}return U.apply(J,de)}function bn(U,J){for(var de=-1,Oe=Array(U);++de<U;)Oe[de]=J(de);return Oe}function Il(U){return function(J){return U(J)}}function Xu(U,J){return U==null?void 0:U[J]}function ka(U,J){return function(de){return U(J(de))}}var Nl=Array.prototype,Ta=Function.prototype,vs=Object.prototype,bs=Xe["__core-js_shared__"],zs=Ta.toString,Kr=vs.hasOwnProperty,ws=function(){var U=/[^.]+$/.exec(bs&&bs.keys&&bs.keys.IE_PROTO||"");return U?"Symbol(src)_1."+U:""}(),Ia=vs.toString,Ci=zs.call(Object),$i=RegExp("^"+zs.call(Kr).replace(ge,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),mo=Et?Xe.Buffer:void 0,Na=Xe.Symbol,Mo=Xe.Uint8Array;mo&&mo.allocUnsafe;var go=ka(Object.getPrototypeOf,Object),El=Object.create,Vo=vs.propertyIsEnumerable,Ea=Nl.splice,Bs=Na?Na.toStringTag:void 0,Wo=function(){try{var U=Fa(Object,"defineProperty");return U({},"",{}),U}catch{}}(),Ra=mo?mo.isBuffer:void 0,Uo=Math.max,Ss=Date.now,Ms=Fa(Xe,"Map"),_r=Fa(Object,"create"),yo=function(){function U(){}return function(J){if(!Jr(J))return{};if(El)return El(J);U.prototype=J;var de=new U;return U.prototype=void 0,de}}();function Xr(U){var J=-1,de=U==null?0:U.length;for(this.clear();++J<de;){var Oe=U[J];this.set(Oe[0],Oe[1])}}function Rl(){this.__data__=_r?_r(null):{},this.size=0}function Vs(U){var J=this.has(U)&&delete this.__data__[U];return this.size-=J?1:0,J}function _a(U){var J=this.__data__;if(_r){var de=J[U];return de===r?void 0:de}return Kr.call(J,U)?J[U]:void 0}function _l(U){var J=this.__data__;return _r?J[U]!==void 0:Kr.call(J,U)}function jo(U,J){var de=this.__data__;return this.size+=this.has(U)?0:1,de[U]=_r&&J===void 0?r:J,this}Xr.prototype.clear=Rl,Xr.prototype.delete=Vs,Xr.prototype.get=_a,Xr.prototype.has=_l,Xr.prototype.set=jo;function er(U){var J=-1,de=U==null?0:U.length;for(this.clear();++J<de;){var Oe=U[J];this.set(Oe[0],Oe[1])}}function ki(){this.__data__=[],this.size=0}function Ws(U){var J=this.__data__,de=Us(J,U);if(de<0)return!1;var Oe=J.length-1;return de==Oe?J.pop():Ea.call(J,de,1),--this.size,!0}function Ti(U){var J=this.__data__,de=Us(J,U);return de<0?void 0:J[de][1]}function Cs(U){return Us(this.__data__,U)>-1}function Pr(U,J){var de=this.__data__,Oe=Us(de,U);return Oe<0?(++this.size,de.push([U,J])):de[Oe][1]=J,this}er.prototype.clear=ki,er.prototype.delete=Ws,er.prototype.get=Ti,er.prototype.has=Cs,er.prototype.set=Pr;function qr(U){var J=-1,de=U==null?0:U.length;for(this.clear();++J<de;){var Oe=U[J];this.set(Oe[0],Oe[1])}}function Xt(){this.size=0,this.__data__={hash:new Xr,map:new(Ms||er),string:new Xr}}function hr(U){var J=wn(this,U).delete(U);return this.size-=J?1:0,J}function Pl(U){return wn(this,U).get(U)}function zd(U){return wn(this,U).has(U)}function Pa(U,J){var de=wn(this,U),Oe=de.size;return de.set(U,J),this.size+=de.size==Oe?0:1,this}qr.prototype.clear=Xt,qr.prototype.delete=hr,qr.prototype.get=Pl,qr.prototype.has=zd,qr.prototype.set=Pa;function Bn(U){var J=this.__data__=new er(U);this.size=J.size}function Ii(){this.__data__=new er,this.size=0}function Go(U){var J=this.__data__,de=J.delete(U);return this.size=J.size,de}function qu(U){return this.__data__.get(U)}function Aa(U){return this.__data__.has(U)}function Da(U,J){var de=this.__data__;if(de instanceof er){var Oe=de.__data__;if(!Ms||Oe.length<n-1)return Oe.push([U,J]),this.size=++de.size,this;de=this.__data__=new qr(Oe)}return de.set(U,J),this.size=de.size,this}Bn.prototype.clear=Ii,Bn.prototype.delete=Go,Bn.prototype.get=qu,Bn.prototype.has=Aa,Bn.prototype.set=Da;function Al(U,J){var de=pr(U),Oe=!de&&Qr(U),dt=!de&&!Oe&&qo(U),Tt=!de&&!Oe&&!dt&&bo(U),It=de||Oe||dt||Tt,at=It?bn(U.length,String):[],_t=at.length;for(var jn in U)It&&(jn=="length"||dt&&(jn=="offset"||jn=="parent")||Tt&&(jn=="buffer"||jn=="byteLength"||jn=="byteOffset")||Di(jn,_t))||at.push(jn);return at}function Mn(U,J,de){(de!==void 0&&!vo(U[J],de)||de===void 0&&!(J in U))&&Ut(U,J,de)}function Yr(U,J,de){var Oe=U[J];(!(Kr.call(U,J)&&vo(Oe,de))||de===void 0&&!(J in U))&&Ut(U,J,de)}function Us(U,J){for(var de=U.length;de--;)if(vo(U[de][0],J))return de;return-1}function Ut(U,J,de){J=="__proto__"&&Wo?Wo(U,J,{configurable:!0,enumerable:!0,value:de,writable:!0}):U[J]=de}var Dl=Pi();function xo(U){return U==null?U===void 0?O:S:Bs&&Bs in Object(U)?Oa(U):Fi(U)}function Ni(U){return es(U)&&xo(U)==a}function tr(U){if(!Jr(U)||Ol(U))return!1;var J=Zr(U)?$i:Q;return J.test(zl(U))}function Yu(U){return es(U)&&Zu(U.length)&&!!be[xo(U)]}function Ei(U){if(!Jr(U))return Ll(U);var J=wt(U),de=[];for(var Oe in U)Oe=="constructor"&&(J||!Kr.call(U,Oe))||de.push(Oe);return de}function Vn(U,J,de,Oe,dt){U!==J&&Dl(J,function(Tt,It){if(dt||(dt=new Bn),Jr(Tt))nr(U,J,It,de,Vn,Oe,dt);else{var at=Oe?Oe(Oi(U,It),Tt,It+"",U,J,dt):void 0;at===void 0&&(at=Tt),Mn(U,It,at)}},Bl)}function nr(U,J,de,Oe,dt,Tt,It){var at=Oi(U,de),_t=Oi(J,de),jn=It.get(_t);if(jn){Mn(U,de,jn);return}var Gn=Tt?Tt(at,_t,de+"",U,J,It):void 0,Ar=Gn===void 0;if(Ar){var So=pr(_t),za=!So&&qo(_t),Rn=!So&&!za&&bo(_t);Gn=_t,So||za||Rn?pr(at)?Gn=at:Li(at)?Gn=Ri(at):za?(Ar=!1,Gn=Fl(_t)):Rn?(Ar=!1,Gn=Vd(_t)):Gn=[]:Ju(_t)||Qr(_t)?(Gn=at,Qr(at)?Gn=Un(at):(!Jr(at)||Zr(at))&&(Gn=Ai(_t))):Ar=!1}Ar&&(It.set(_t,Gn),dt(Gn,_t,Oe,Tt,It),It.delete(_t)),Mn(U,de,Gn)}function Bd(U,J){return Xo(La(U,J,wo),U+"")}var fr=Wo?function(U,J){return Wo(U,"toString",{configurable:!0,enumerable:!1,value:Yo(J),writable:!0})}:wo;function Fl(U,J){return U.slice()}function Md(U){var J=new U.constructor(U.byteLength);return new Mo(J).set(new Mo(U)),J}function Vd(U,J){var de=Md(U.buffer);return new U.constructor(de,U.byteOffset,U.length)}function Ri(U,J){var de=-1,Oe=U.length;for(J||(J=Array(Oe));++de<Oe;)J[de]=U[de];return J}function _i(U,J,de,Oe){var dt=!de;de||(de={});for(var Tt=-1,It=J.length;++Tt<It;){var at=J[Tt],_t=void 0;_t===void 0&&(_t=U[at]),dt?Ut(de,at,_t):Yr(de,at,_t)}return de}function Ho(U){return Bd(function(J,de){var Oe=-1,dt=de.length,Tt=dt>1?de[dt-1]:void 0,It=dt>2?de[2]:void 0;for(Tt=U.length>3&&typeof Tt=="function"?(dt--,Tt):void 0,It&&Ko(de[0],de[1],It)&&(Tt=dt<3?void 0:Tt,dt=1),J=Object(J);++Oe<dt;){var at=de[Oe];at&&U(J,at,Oe,Tt)}return J})}function Pi(U){return function(J,de,Oe){for(var dt=-1,Tt=Object(J),It=Oe(J),at=It.length;at--;){var _t=It[++dt];if(de(Tt[_t],_t,Tt)===!1)break}return J}}function wn(U,J){var de=U.__data__;return Wd(J)?de[typeof J=="string"?"string":"hash"]:de.map}function Fa(U,J){var de=Xu(U,J);return tr(de)?de:void 0}function Oa(U){var J=Kr.call(U,Bs),de=U[Bs];try{U[Bs]=void 0;var Oe=!0}catch{}var dt=Ia.call(U);return Oe&&(J?U[Bs]=de:delete U[Bs]),dt}function Ai(U){return typeof U.constructor=="function"&&!wt(U)?yo(go(U)):{}}function Di(U,J){var de=typeof U;return J=J??i,!!J&&(de=="number"||de!="symbol"&&he.test(U))&&U>-1&&U%1==0&&U<J}function Ko(U,J,de){if(!Jr(de))return!1;var Oe=typeof J;return(Oe=="number"?Wn(de)&&Di(J,de.length):Oe=="string"&&J in de)?vo(de[J],U):!1}function Wd(U){var J=typeof U;return J=="string"||J=="number"||J=="symbol"||J=="boolean"?U!=="__proto__":U===null}function Ol(U){return!!ws&&ws in U}function wt(U){var J=U&&U.constructor,de=typeof J=="function"&&J.prototype||vs;return U===de}function Ll(U){var J=[];if(U!=null)for(var de in Object(U))J.push(de);return J}function Fi(U){return Ia.call(U)}function La(U,J,de){return J=Uo(J===void 0?U.length-1:J,0),function(){for(var Oe=arguments,dt=-1,Tt=Uo(Oe.length-J,0),It=Array(Tt);++dt<Tt;)It[dt]=Oe[J+dt];dt=-1;for(var at=Array(J+1);++dt<J;)at[dt]=Oe[dt];return at[J]=de(It),Wt(U,this,at)}}function Oi(U,J){if(!(J==="constructor"&&typeof U[J]=="function")&&J!="__proto__")return U[J]}var Xo=Qu(fr);function Qu(U){var J=0,de=0;return function(){var Oe=Ss(),dt=o-(Oe-de);if(de=Oe,dt>0){if(++J>=s)return arguments[0]}else J=0;return U.apply(void 0,arguments)}}function zl(U){if(U!=null){try{return zs.call(U)}catch{}try{return U+""}catch{}}return""}function vo(U,J){return U===J||U!==U&&J!==J}var Qr=Ni(function(){return arguments}())?Ni:function(U){return es(U)&&Kr.call(U,"callee")&&!Vo.call(U,"callee")},pr=Array.isArray;function Wn(U){return U!=null&&Zu(U.length)&&!Zr(U)}function Li(U){return es(U)&&Wn(U)}var qo=Ra||js;function Zr(U){if(!Jr(U))return!1;var J=xo(U);return J==g||J==y||J==c||J==I}function Zu(U){return typeof U=="number"&&U>-1&&U%1==0&&U<=i}function Jr(U){var J=typeof U;return U!=null&&(J=="object"||J=="function")}function es(U){return U!=null&&typeof U=="object"}function Ju(U){if(!es(U)||xo(U)!=$)return!1;var J=go(U);if(J===null)return!0;var de=Kr.call(J,"constructor")&&J.constructor;return typeof de=="function"&&de instanceof de&&zs.call(de)==Ci}var bo=Ls?Il(Ls):Yu;function Un(U){return _i(U,Bl(U))}function Bl(U){return Wn(U)?Al(U):Ei(U)}var Ud=Ho(function(U,J,de,Oe){Vn(U,J,de,Oe)});function Yo(U){return function(){return U}}function wo(U){return U}function js(){return!1}t.exports=Ud}(kh,kh.exports)),kh.exports}var EL=NL();const so=Df(EL);function RL(t,e=[]){const n=ee.useRef(t);return ee.useEffect(()=>{n.current=t}),ee.useCallback((...r)=>{var s;return(s=n.current)==null?void 0:s.call(n,...r)},e)}const rg=globalThis!=null&&globalThis.document?ee.useLayoutEffect:ee.useEffect,oT=(t,e)=>{const n=ee.useRef(!1),r=ee.useRef(!1);ee.useEffect(()=>{if(n.current&&r.current)return t();r.current=!0},e),ee.useEffect(()=>(n.current=!0,()=>{n.current=!1}),[])};function _L(t,e){if(t!=null){if(typeof t=="function"){t(e);return}try{t.current=e}catch{throw new Error(`Cannot assign value '${e}' to ref '${t}'`)}}}function yx(...t){return e=>{t.forEach(n=>{_L(n,e)})}}function PL(...t){return ee.useMemo(()=>yx(...t),t)}function AL(t,e){const n=RL(t);ee.useEffect(()=>{if(e==null)return;let r=null;return r=window.setTimeout(()=>{n()},e),()=>{r&&window.clearTimeout(r)}},[e,n])}const Dn={open:(t,e)=>`${t}[data-open], ${t}[open], ${t}[data-state=open] ${e}`,closed:(t,e)=>`${t}[data-closed], ${t}[data-state=closed] ${e}`,hover:(t,e)=>`${t}:hover ${e}, ${t}[data-hover] ${e}`,focus:(t,e)=>`${t}:focus ${e}, ${t}[data-focus] ${e}`,focusVisible:(t,e)=>`${t}:focus-visible ${e}`,focusWithin:(t,e)=>`${t}:focus-within ${e}`,active:(t,e)=>`${t}:active ${e}, ${t}[data-active] ${e}`,disabled:(t,e)=>`${t}:disabled ${e}, ${t}[data-disabled] ${e}`,invalid:(t,e)=>`${t}:invalid ${e}, ${t}[data-invalid] ${e}`,checked:(t,e)=>`${t}:checked ${e}, ${t}[data-checked] ${e}`,placeholderShown:(t,e)=>`${t}:placeholder-shown ${e}`},ni=t=>V3(e=>t(e,"&"),"[role=group]","[data-group]",".group"),Ki=t=>V3(e=>t(e,"~ &"),"[data-peer]",".peer"),V3=(t,...e)=>e.map(t).join(", "),jc={_hover:"&:hover, &[data-hover]",_active:"&:active, &[data-active]",_focus:"&:focus, &[data-focus]",_highlighted:"&[data-highlighted]",_focusWithin:"&:focus-within, &[data-focus-within]",_focusVisible:"&:focus-visible, &[data-focus-visible]",_disabled:"&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]",_readOnly:"&[aria-readonly=true], &[readonly], &[data-readonly]",_before:"&::before",_after:"&::after",_empty:"&:empty, &[data-empty]",_expanded:"&[aria-expanded=true], &[data-expanded], &[data-state=expanded]",_checked:"&[aria-checked=true], &[data-checked], &[data-state=checked]",_grabbed:"&[aria-grabbed=true], &[data-grabbed]",_pressed:"&[aria-pressed=true], &[data-pressed]",_invalid:"&[aria-invalid=true], &[data-invalid]",_valid:"&[data-valid], &[data-state=valid]",_loading:"&[data-loading], &[aria-busy=true]",_selected:"&[aria-selected=true], &[data-selected]",_hidden:"&[hidden], &[data-hidden]",_autofill:"&:-webkit-autofill",_even:"&:nth-of-type(even)",_odd:"&:nth-of-type(odd)",_first:"&:first-of-type",_firstLetter:"&::first-letter",_last:"&:last-of-type",_notFirst:"&:not(:first-of-type)",_notLast:"&:not(:last-of-type)",_visited:"&:visited",_activeLink:"&[aria-current=page]",_activeStep:"&[aria-current=step]",_indeterminate:"&:indeterminate, &[aria-checked=mixed], &[data-indeterminate], &[data-state=indeterminate]",_groupOpen:ni(Dn.open),_groupClosed:ni(Dn.closed),_groupHover:ni(Dn.hover),_peerHover:Ki(Dn.hover),_groupFocus:ni(Dn.focus),_peerFocus:Ki(Dn.focus),_groupFocusVisible:ni(Dn.focusVisible),_peerFocusVisible:Ki(Dn.focusVisible),_groupActive:ni(Dn.active),_peerActive:Ki(Dn.active),_groupDisabled:ni(Dn.disabled),_peerDisabled:Ki(Dn.disabled),_groupInvalid:ni(Dn.invalid),_peerInvalid:Ki(Dn.invalid),_groupChecked:ni(Dn.checked),_peerChecked:Ki(Dn.checked),_groupFocusWithin:ni(Dn.focusWithin),_peerFocusWithin:Ki(Dn.focusWithin),_peerPlaceholderShown:Ki(Dn.placeholderShown),_placeholder:"&::placeholder, &[data-placeholder]",_placeholderShown:"&:placeholder-shown, &[data-placeholder-shown]",_fullScreen:"&:fullscreen, &[data-fullscreen]",_selection:"&::selection",_rtl:"[dir=rtl] &, &[dir=rtl]",_ltr:"[dir=ltr] &, &[dir=ltr]",_mediaDark:"@media (prefers-color-scheme: dark)",_mediaReduceMotion:"@media (prefers-reduced-motion: reduce)",_dark:".chakra-ui-dark &:not([data-theme]),[data-theme=dark] &:not([data-theme]),&[data-theme=dark]",_light:".chakra-ui-light &:not([data-theme]),[data-theme=light] &:not([data-theme]),&[data-theme=light]",_horizontal:"&[data-orientation=horizontal]",_vertical:"&[data-orientation=vertical]",_open:"&[data-open], &[open], &[data-state=open]",_closed:"&[data-closed], &[data-state=closed]",_complete:"&[data-complete]",_incomplete:"&[data-incomplete]",_current:"&[data-current]"},W3=Object.keys(jc),DL=t=>/!(important)?$/.test(t),iT=t=>typeof t=="string"?t.replace(/!(important)?$/,"").trim():t,FL=(t,e)=>n=>{const r=String(e),s=DL(r),o=iT(r),i=t?`${t}.${o}`:o;let a=Mr(n.__cssMap)&&i in n.__cssMap?n.__cssMap[i].varRef:e;return a=iT(a),s?`${a} !important`:a};function Kv(t){const{scale:e,transform:n,compose:r}=t;return(o,i)=>{const a=FL(e,o)(i);let l=(n==null?void 0:n(a,i))??a;return r&&(l=r(l,i)),l}}const im=(...t)=>e=>t.reduce((n,r)=>r(n),e);function Qs(t,e){return n=>{const r={property:n,scale:t};return r.transform=Kv({scale:t,transform:e}),r}}const OL=({rtl:t,ltr:e})=>n=>n.direction==="rtl"?t:e;function LL(t){const{property:e,scale:n,transform:r}=t;return{scale:n,property:OL(e),transform:n?Kv({scale:n,compose:r}):r}}const U3=["rotate(var(--chakra-rotate, 0))","scaleX(var(--chakra-scale-x, 1))","scaleY(var(--chakra-scale-y, 1))","skewX(var(--chakra-skew-x, 0))","skewY(var(--chakra-skew-y, 0))"];function zL(){return["translateX(var(--chakra-translate-x, 0))","translateY(var(--chakra-translate-y, 0))",...U3].join(" ")}function BL(){return["translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)",...U3].join(" ")}const ML={"--chakra-blur":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-brightness":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-contrast":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-grayscale":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-hue-rotate":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-invert":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-saturate":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-sepia":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-drop-shadow":"var(--chakra-empty,/*!*/ /*!*/)",filter:["var(--chakra-blur)","var(--chakra-brightness)","var(--chakra-contrast)","var(--chakra-grayscale)","var(--chakra-hue-rotate)","var(--chakra-invert)","var(--chakra-saturate)","var(--chakra-sepia)","var(--chakra-drop-shadow)"].join(" ")},VL={backdropFilter:["var(--chakra-backdrop-blur)","var(--chakra-backdrop-brightness)","var(--chakra-backdrop-contrast)","var(--chakra-backdrop-grayscale)","var(--chakra-backdrop-hue-rotate)","var(--chakra-backdrop-invert)","var(--chakra-backdrop-opacity)","var(--chakra-backdrop-saturate)","var(--chakra-backdrop-sepia)"].join(" "),"--chakra-backdrop-blur":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-brightness":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-contrast":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-grayscale":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-hue-rotate":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-invert":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-opacity":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-saturate":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-backdrop-sepia":"var(--chakra-empty,/*!*/ /*!*/)"};function WL(t){return{"--chakra-ring-offset-shadow":"var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)","--chakra-ring-shadow":"var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)","--chakra-ring-width":t,boxShadow:["var(--chakra-ring-offset-shadow)","var(--chakra-ring-shadow)","var(--chakra-shadow, 0 0 #0000)"].join(", ")}}const UL={"row-reverse":{space:"--chakra-space-x-reverse",divide:"--chakra-divide-x-reverse"},"column-reverse":{space:"--chakra-space-y-reverse",divide:"--chakra-divide-y-reverse"}},xx={"to-t":"to top","to-tr":"to top right","to-r":"to right","to-br":"to bottom right","to-b":"to bottom","to-bl":"to bottom left","to-l":"to left","to-tl":"to top left"},jL=new Set(Object.values(xx)),vx=new Set(["none","-moz-initial","inherit","initial","revert","unset"]),GL=t=>t.trim();function HL(t,e){if(t==null||vx.has(t))return t;if(!(bx(t)||vx.has(t)))return`url('${t}')`;const s=/(^[a-z-A-Z]+)\((.*)\)/g.exec(t),o=s==null?void 0:s[1],i=s==null?void 0:s[2];if(!o||!i)return t;const a=o.includes("-gradient")?o:`${o}-gradient`,[l,...c]=i.split(",").map(GL).filter(Boolean);if((c==null?void 0:c.length)===0)return t;const d=l in xx?xx[l]:l;c.unshift(d);const f=c.map(p=>{if(jL.has(p))return p;const g=p.indexOf(" "),[y,x]=g!==-1?[p.substr(0,g),p.substr(g+1)]:[p],w=bx(x)?x:x&&x.split(" "),S=`colors.${y}`,$=S in e.__cssMap?e.__cssMap[S].varRef:y;return w?[$,...Array.isArray(w)?w:[w]].join(" "):$});return`${a}(${f.join(", ")})`}const bx=t=>typeof t=="string"&&t.includes("(")&&t.includes(")"),KL=(t,e)=>HL(t,e??{});function XL(t){return/^var\(--.+\)$/.test(t)}const qL=t=>{const e=parseFloat(t.toString()),n=t.toString().replace(String(e),"");return{unitless:!n,value:e,unit:n}},ri=t=>e=>`${t}(${e})`,St={filter(t){return t!=="auto"?t:ML},backdropFilter(t){return t!=="auto"?t:VL},ring(t){return WL(St.px(t))},bgClip(t){return t==="text"?{color:"transparent",backgroundClip:"text"}:{backgroundClip:t}},transform(t){return t==="auto"?zL():t==="auto-gpu"?BL():t},vh(t){return t==="$100vh"?"var(--chakra-vh)":t},px(t){if(t==null)return t;const{unitless:e}=qL(t);return e||typeof t=="number"?`${t}px`:t},fraction(t){return typeof t!="number"||t>1?t:`${t*100}%`},float(t,e){const n={left:"right",right:"left"};return e.direction==="rtl"?n[t]:t},degree(t){if(XL(t)||t==null)return t;const e=typeof t=="string"&&!t.endsWith("deg");return typeof t=="number"||e?`${t}deg`:t},gradient:KL,blur:ri("blur"),opacity:ri("opacity"),brightness:ri("brightness"),contrast:ri("contrast"),dropShadow:ri("drop-shadow"),grayscale:ri("grayscale"),hueRotate:t=>ri("hue-rotate")(St.degree(t)),invert:ri("invert"),saturate:ri("saturate"),sepia:ri("sepia"),bgImage(t){return t==null||bx(t)||vx.has(t)?t:`url(${t})`},outline(t){const e=String(t)==="0"||String(t)==="none";return t!==null&&e?{outline:"2px solid transparent",outlineOffset:"2px"}:{outline:t}},flexDirection(t){const{space:e,divide:n}=UL[t]??{},r={flexDirection:t};return e&&(r[e]=1),n&&(r[n]=1),r}},ne={borderWidths:Qs("borderWidths"),borderStyles:Qs("borderStyles"),colors:Qs("colors"),borders:Qs("borders"),gradients:Qs("gradients",St.gradient),radii:Qs("radii",St.px),space:Qs("space",im(St.vh,St.px)),spaceT:Qs("space",im(St.vh,St.px)),degreeT(t){return{property:t,transform:St.degree}},prop(t,e,n){return{property:t,scale:e,...e&&{transform:Kv({scale:e,transform:n})}}},propT(t,e){return{property:t,transform:e}},sizes:Qs("sizes",im(St.vh,St.px)),sizesT:Qs("sizes",im(St.vh,St.fraction)),shadows:Qs("shadows"),logical:LL,blur:Qs("blur",St.blur)},Rm={background:ne.colors("background"),backgroundColor:ne.colors("backgroundColor"),backgroundImage:ne.gradients("backgroundImage"),backgroundSize:!0,backgroundPosition:!0,backgroundRepeat:!0,backgroundAttachment:!0,backgroundClip:{transform:St.bgClip},bgSize:ne.prop("backgroundSize"),bgPosition:ne.prop("backgroundPosition"),bg:ne.colors("background"),bgColor:ne.colors("backgroundColor"),bgPos:ne.prop("backgroundPosition"),bgRepeat:ne.prop("backgroundRepeat"),bgAttachment:ne.prop("backgroundAttachment"),bgGradient:ne.gradients("backgroundImage"),bgClip:{transform:St.bgClip}};Object.assign(Rm,{bgImage:Rm.backgroundImage,bgImg:Rm.backgroundImage});const Pt={border:ne.borders("border"),borderWidth:ne.borderWidths("borderWidth"),borderStyle:ne.borderStyles("borderStyle"),borderColor:ne.colors("borderColor"),borderRadius:ne.radii("borderRadius"),borderTop:ne.borders("borderTop"),borderBlockStart:ne.borders("borderBlockStart"),borderTopLeftRadius:ne.radii("borderTopLeftRadius"),borderStartStartRadius:ne.logical({scale:"radii",property:{ltr:"borderTopLeftRadius",rtl:"borderTopRightRadius"}}),borderEndStartRadius:ne.logical({scale:"radii",property:{ltr:"borderBottomLeftRadius",rtl:"borderBottomRightRadius"}}),borderTopRightRadius:ne.radii("borderTopRightRadius"),borderStartEndRadius:ne.logical({scale:"radii",property:{ltr:"borderTopRightRadius",rtl:"borderTopLeftRadius"}}),borderEndEndRadius:ne.logical({scale:"radii",property:{ltr:"borderBottomRightRadius",rtl:"borderBottomLeftRadius"}}),borderRight:ne.borders("borderRight"),borderInlineEnd:ne.borders("borderInlineEnd"),borderBottom:ne.borders("borderBottom"),borderBlockEnd:ne.borders("borderBlockEnd"),borderBottomLeftRadius:ne.radii("borderBottomLeftRadius"),borderBottomRightRadius:ne.radii("borderBottomRightRadius"),borderLeft:ne.borders("borderLeft"),borderInlineStart:{property:"borderInlineStart",scale:"borders"},borderInlineStartRadius:ne.logical({scale:"radii",property:{ltr:["borderTopLeftRadius","borderBottomLeftRadius"],rtl:["borderTopRightRadius","borderBottomRightRadius"]}}),borderInlineEndRadius:ne.logical({scale:"radii",property:{ltr:["borderTopRightRadius","borderBottomRightRadius"],rtl:["borderTopLeftRadius","borderBottomLeftRadius"]}}),borderX:ne.borders(["borderLeft","borderRight"]),borderInline:ne.borders("borderInline"),borderY:ne.borders(["borderTop","borderBottom"]),borderBlock:ne.borders("borderBlock"),borderTopWidth:ne.borderWidths("borderTopWidth"),borderBlockStartWidth:ne.borderWidths("borderBlockStartWidth"),borderTopColor:ne.colors("borderTopColor"),borderBlockStartColor:ne.colors("borderBlockStartColor"),borderTopStyle:ne.borderStyles("borderTopStyle"),borderBlockStartStyle:ne.borderStyles("borderBlockStartStyle"),borderBottomWidth:ne.borderWidths("borderBottomWidth"),borderBlockEndWidth:ne.borderWidths("borderBlockEndWidth"),borderBottomColor:ne.colors("borderBottomColor"),borderBlockEndColor:ne.colors("borderBlockEndColor"),borderBottomStyle:ne.borderStyles("borderBottomStyle"),borderBlockEndStyle:ne.borderStyles("borderBlockEndStyle"),borderLeftWidth:ne.borderWidths("borderLeftWidth"),borderInlineStartWidth:ne.borderWidths("borderInlineStartWidth"),borderLeftColor:ne.colors("borderLeftColor"),borderInlineStartColor:ne.colors("borderInlineStartColor"),borderLeftStyle:ne.borderStyles("borderLeftStyle"),borderInlineStartStyle:ne.borderStyles("borderInlineStartStyle"),borderRightWidth:ne.borderWidths("borderRightWidth"),borderInlineEndWidth:ne.borderWidths("borderInlineEndWidth"),borderRightColor:ne.colors("borderRightColor"),borderInlineEndColor:ne.colors("borderInlineEndColor"),borderRightStyle:ne.borderStyles("borderRightStyle"),borderInlineEndStyle:ne.borderStyles("borderInlineEndStyle"),borderTopRadius:ne.radii(["borderTopLeftRadius","borderTopRightRadius"]),borderBottomRadius:ne.radii(["borderBottomLeftRadius","borderBottomRightRadius"]),borderLeftRadius:ne.radii(["borderTopLeftRadius","borderBottomLeftRadius"]),borderRightRadius:ne.radii(["borderTopRightRadius","borderBottomRightRadius"])};Object.assign(Pt,{rounded:Pt.borderRadius,roundedTop:Pt.borderTopRadius,roundedTopLeft:Pt.borderTopLeftRadius,roundedTopRight:Pt.borderTopRightRadius,roundedTopStart:Pt.borderStartStartRadius,roundedTopEnd:Pt.borderStartEndRadius,roundedBottom:Pt.borderBottomRadius,roundedBottomLeft:Pt.borderBottomLeftRadius,roundedBottomRight:Pt.borderBottomRightRadius,roundedBottomStart:Pt.borderEndStartRadius,roundedBottomEnd:Pt.borderEndEndRadius,roundedLeft:Pt.borderLeftRadius,roundedRight:Pt.borderRightRadius,roundedStart:Pt.borderInlineStartRadius,roundedEnd:Pt.borderInlineEndRadius,borderStart:Pt.borderInlineStart,borderEnd:Pt.borderInlineEnd,borderTopStartRadius:Pt.borderStartStartRadius,borderTopEndRadius:Pt.borderStartEndRadius,borderBottomStartRadius:Pt.borderEndStartRadius,borderBottomEndRadius:Pt.borderEndEndRadius,borderStartRadius:Pt.borderInlineStartRadius,borderEndRadius:Pt.borderInlineEndRadius,borderStartWidth:Pt.borderInlineStartWidth,borderEndWidth:Pt.borderInlineEndWidth,borderStartColor:Pt.borderInlineStartColor,borderEndColor:Pt.borderInlineEndColor,borderStartStyle:Pt.borderInlineStartStyle,borderEndStyle:Pt.borderInlineEndStyle});const YL={color:ne.colors("color"),textColor:ne.colors("color"),fill:ne.colors("fill"),stroke:ne.colors("stroke"),accentColor:ne.colors("accentColor"),textFillColor:ne.colors("textFillColor")},sg={alignItems:!0,alignContent:!0,justifyItems:!0,justifyContent:!0,flexWrap:!0,flexDirection:{transform:St.flexDirection},flex:!0,flexFlow:!0,flexGrow:!0,flexShrink:!0,flexBasis:ne.sizes("flexBasis"),justifySelf:!0,alignSelf:!0,order:!0,placeItems:!0,placeContent:!0,placeSelf:!0,gap:ne.space("gap"),rowGap:ne.space("rowGap"),columnGap:ne.space("columnGap")};Object.assign(sg,{flexDir:sg.flexDirection});const eo={width:ne.sizesT("width"),inlineSize:ne.sizesT("inlineSize"),height:ne.sizes("height"),blockSize:ne.sizes("blockSize"),boxSize:ne.sizes(["width","height"]),minWidth:ne.sizes("minWidth"),minInlineSize:ne.sizes("minInlineSize"),minHeight:ne.sizes("minHeight"),minBlockSize:ne.sizes("minBlockSize"),maxWidth:ne.sizes("maxWidth"),maxInlineSize:ne.sizes("maxInlineSize"),maxHeight:ne.sizes("maxHeight"),maxBlockSize:ne.sizes("maxBlockSize"),overflow:!0,overflowX:!0,overflowY:!0,overscrollBehavior:!0,overscrollBehaviorX:!0,overscrollBehaviorY:!0,display:!0,aspectRatio:!0,hideFrom:{scale:"breakpoints",transform:(t,e)=>{var s,o;return{[`@media screen and (min-width: ${((o=(s=e.__breakpoints)==null?void 0:s.get(t))==null?void 0:o.minW)??t})`]:{display:"none"}}}},hideBelow:{scale:"breakpoints",transform:(t,e)=>{var s,o;return{[`@media screen and (max-width: ${((o=(s=e.__breakpoints)==null?void 0:s.get(t))==null?void 0:o._minW)??t})`]:{display:"none"}}}},verticalAlign:!0,boxSizing:!0,boxDecorationBreak:!0,float:ne.propT("float",St.float),objectFit:!0,objectPosition:!0,visibility:!0,isolation:!0};Object.assign(eo,{w:eo.width,h:eo.height,minW:eo.minWidth,maxW:eo.maxWidth,minH:eo.minHeight,maxH:eo.maxHeight,overscroll:eo.overscrollBehavior,overscrollX:eo.overscrollBehaviorX,overscrollY:eo.overscrollBehaviorY});const QL={filter:{transform:St.filter},blur:ne.blur("--chakra-blur"),brightness:ne.propT("--chakra-brightness",St.brightness),contrast:ne.propT("--chakra-contrast",St.contrast),hueRotate:ne.propT("--chakra-hue-rotate",St.hueRotate),invert:ne.propT("--chakra-invert",St.invert),saturate:ne.propT("--chakra-saturate",St.saturate),dropShadow:ne.propT("--chakra-drop-shadow",St.dropShadow),backdropFilter:{transform:St.backdropFilter},backdropBlur:ne.blur("--chakra-backdrop-blur"),backdropBrightness:ne.propT("--chakra-backdrop-brightness",St.brightness),backdropContrast:ne.propT("--chakra-backdrop-contrast",St.contrast),backdropHueRotate:ne.propT("--chakra-backdrop-hue-rotate",St.hueRotate),backdropInvert:ne.propT("--chakra-backdrop-invert",St.invert),backdropSaturate:ne.propT("--chakra-backdrop-saturate",St.saturate)},ZL={ring:{transform:St.ring},ringColor:ne.colors("--chakra-ring-color"),ringOffset:ne.prop("--chakra-ring-offset-width"),ringOffsetColor:ne.colors("--chakra-ring-offset-color"),ringInset:ne.prop("--chakra-ring-inset")},JL={appearance:!0,cursor:!0,resize:!0,userSelect:!0,pointerEvents:!0,outline:{transform:St.outline},outlineOffset:!0,outlineColor:ne.colors("outlineColor")},j3={gridGap:ne.space("gridGap"),gridColumnGap:ne.space("gridColumnGap"),gridRowGap:ne.space("gridRowGap"),gridColumn:!0,gridRow:!0,gridAutoFlow:!0,gridAutoColumns:!0,gridColumnStart:!0,gridColumnEnd:!0,gridRowStart:!0,gridRowEnd:!0,gridAutoRows:!0,gridTemplate:!0,gridTemplateColumns:!0,gridTemplateRows:!0,gridTemplateAreas:!0,gridArea:!0};function ez(t,e,n,r){const s=typeof e=="string"?e.split("."):[e];for(r=0;r<s.length&&t;r+=1)t=t[s[r]];return t===void 0?n:t}const tz=t=>{const e=new WeakMap;return(r,s,o,i)=>{if(typeof r>"u")return t(r,s,o);e.has(r)||e.set(r,new Map);const a=e.get(r);if(a.has(s))return a.get(s);const l=t(r,s,o,i);return a.set(s,l),l}},nz=tz(ez),rz={border:"0px",clip:"rect(0, 0, 0, 0)",width:"1px",height:"1px",margin:"-1px",padding:"0px",overflow:"hidden",whiteSpace:"nowrap",position:"absolute"},sz={position:"static",width:"auto",height:"auto",clip:"auto",padding:"0",margin:"0",overflow:"visible",whiteSpace:"normal"},l1=(t,e,n)=>{const r={},s=nz(t,e,{});for(const o in s)o in n&&n[o]!=null||(r[o]=s[o]);return r},oz={srOnly:{transform(t){return t===!0?rz:t==="focusable"?sz:{}}},layerStyle:{processResult:!0,transform:(t,e,n)=>l1(e,`layerStyles.${t}`,n)},textStyle:{processResult:!0,transform:(t,e,n)=>l1(e,`textStyles.${t}`,n)},apply:{processResult:!0,transform:(t,e,n)=>l1(e,t,n)}},Mh={position:!0,pos:ne.prop("position"),zIndex:ne.prop("zIndex","zIndices"),inset:ne.spaceT("inset"),insetX:ne.spaceT(["left","right"]),insetInline:ne.spaceT("insetInline"),insetY:ne.spaceT(["top","bottom"]),insetBlock:ne.spaceT("insetBlock"),top:ne.spaceT("top"),insetBlockStart:ne.spaceT("insetBlockStart"),bottom:ne.spaceT("bottom"),insetBlockEnd:ne.spaceT("insetBlockEnd"),left:ne.spaceT("left"),insetInlineStart:ne.logical({scale:"space",property:{ltr:"left",rtl:"right"}}),right:ne.spaceT("right"),insetInlineEnd:ne.logical({scale:"space",property:{ltr:"right",rtl:"left"}})};Object.assign(Mh,{insetStart:Mh.insetInlineStart,insetEnd:Mh.insetInlineEnd});const wx={boxShadow:ne.shadows("boxShadow"),mixBlendMode:!0,blendMode:ne.prop("mixBlendMode"),backgroundBlendMode:!0,bgBlendMode:ne.prop("backgroundBlendMode"),opacity:!0};Object.assign(wx,{shadow:wx.boxShadow});const an={margin:ne.spaceT("margin"),marginTop:ne.spaceT("marginTop"),marginBlockStart:ne.spaceT("marginBlockStart"),marginRight:ne.spaceT("marginRight"),marginInlineEnd:ne.spaceT("marginInlineEnd"),marginBottom:ne.spaceT("marginBottom"),marginBlockEnd:ne.spaceT("marginBlockEnd"),marginLeft:ne.spaceT("marginLeft"),marginInlineStart:ne.spaceT("marginInlineStart"),marginX:ne.spaceT(["marginInlineStart","marginInlineEnd"]),marginInline:ne.spaceT("marginInline"),marginY:ne.spaceT(["marginTop","marginBottom"]),marginBlock:ne.spaceT("marginBlock"),padding:ne.space("padding"),paddingTop:ne.space("paddingTop"),paddingBlockStart:ne.space("paddingBlockStart"),paddingRight:ne.space("paddingRight"),paddingBottom:ne.space("paddingBottom"),paddingBlockEnd:ne.space("paddingBlockEnd"),paddingLeft:ne.space("paddingLeft"),paddingInlineStart:ne.space("paddingInlineStart"),paddingInlineEnd:ne.space("paddingInlineEnd"),paddingX:ne.space(["paddingInlineStart","paddingInlineEnd"]),paddingInline:ne.space("paddingInline"),paddingY:ne.space(["paddingTop","paddingBottom"]),paddingBlock:ne.space("paddingBlock")};Object.assign(an,{m:an.margin,mt:an.marginTop,mr:an.marginRight,me:an.marginInlineEnd,marginEnd:an.marginInlineEnd,mb:an.marginBottom,ml:an.marginLeft,ms:an.marginInlineStart,marginStart:an.marginInlineStart,mx:an.marginX,my:an.marginY,p:an.padding,pt:an.paddingTop,py:an.paddingY,px:an.paddingX,pb:an.paddingBottom,pl:an.paddingLeft,ps:an.paddingInlineStart,paddingStart:an.paddingInlineStart,pr:an.paddingRight,pe:an.paddingInlineEnd,paddingEnd:an.paddingInlineEnd});const iz={scrollBehavior:!0,scrollSnapAlign:!0,scrollSnapStop:!0,scrollSnapType:!0,scrollMargin:ne.spaceT("scrollMargin"),scrollMarginTop:ne.spaceT("scrollMarginTop"),scrollMarginBottom:ne.spaceT("scrollMarginBottom"),scrollMarginLeft:ne.spaceT("scrollMarginLeft"),scrollMarginRight:ne.spaceT("scrollMarginRight"),scrollMarginX:ne.spaceT(["scrollMarginLeft","scrollMarginRight"]),scrollMarginY:ne.spaceT(["scrollMarginTop","scrollMarginBottom"]),scrollPadding:ne.spaceT("scrollPadding"),scrollPaddingTop:ne.spaceT("scrollPaddingTop"),scrollPaddingBottom:ne.spaceT("scrollPaddingBottom"),scrollPaddingLeft:ne.spaceT("scrollPaddingLeft"),scrollPaddingRight:ne.spaceT("scrollPaddingRight"),scrollPaddingX:ne.spaceT(["scrollPaddingLeft","scrollPaddingRight"]),scrollPaddingY:ne.spaceT(["scrollPaddingTop","scrollPaddingBottom"])},az={fontFamily:ne.prop("fontFamily","fonts"),fontSize:ne.prop("fontSize","fontSizes",St.px),fontWeight:ne.prop("fontWeight","fontWeights"),lineHeight:ne.prop("lineHeight","lineHeights"),letterSpacing:ne.prop("letterSpacing","letterSpacings"),textAlign:!0,fontStyle:!0,textIndent:!0,wordBreak:!0,overflowWrap:!0,textOverflow:!0,textTransform:!0,whiteSpace:!0,isTruncated:{transform(t){if(t===!0)return{overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"}}},noOfLines:{static:{overflow:"hidden",textOverflow:"ellipsis",display:"-webkit-box",WebkitBoxOrient:"vertical",WebkitLineClamp:"var(--chakra-line-clamp)"},property:"--chakra-line-clamp"}},lz={textDecorationColor:ne.colors("textDecorationColor"),textDecoration:!0,textDecor:{property:"textDecoration"},textDecorationLine:!0,textDecorationStyle:!0,textDecorationThickness:!0,textUnderlineOffset:!0,textShadow:ne.shadows("textShadow")},uz={clipPath:!0,transform:ne.propT("transform",St.transform),transformOrigin:!0,translateX:ne.spaceT("--chakra-translate-x"),translateY:ne.spaceT("--chakra-translate-y"),skewX:ne.degreeT("--chakra-skew-x"),skewY:ne.degreeT("--chakra-skew-y"),scaleX:ne.prop("--chakra-scale-x"),scaleY:ne.prop("--chakra-scale-y"),scale:ne.prop(["--chakra-scale-x","--chakra-scale-y"]),rotate:ne.degreeT("--chakra-rotate")},cz={listStyleType:!0,listStylePosition:!0,listStylePos:ne.prop("listStylePosition"),listStyleImage:!0,listStyleImg:ne.prop("listStyleImage")},dz={transition:!0,transitionDelay:!0,animation:!0,willChange:!0,transitionDuration:ne.prop("transitionDuration","transition.duration"),transitionProperty:ne.prop("transitionProperty","transition.property"),transitionTimingFunction:ne.prop("transitionTimingFunction","transition.easing")},Xv=so({},Rm,Pt,YL,sg,eo,QL,ZL,JL,j3,oz,Mh,wx,an,iz,az,lz,uz,cz,dz);Object.assign({},an,eo,sg,j3,Mh);const hz=[...Object.keys(Xv),...W3],fz={...Xv,...jc},pz=t=>t in fz,mz=t=>e=>{if(!e.__breakpoints)return t;const{isResponsive:n,toArrayValue:r,media:s}=e.__breakpoints,o={};for(const i in t){let a=ro(t[i],e);if(a==null)continue;if(a=Mr(a)&&n(a)?r(a):a,!Array.isArray(a)){o[i]=a;continue}const l=a.slice(0,s.length).length;for(let c=0;c<l;c+=1){const d=s==null?void 0:s[c];if(!d){o[i]=a[c];continue}o[d]=o[d]||{},a[c]!=null&&(o[d][i]=a[c])}}return o};function gz(t){const e=[];let n="",r=!1;for(let s=0;s<t.length;s++){const o=t[s];o==="("?(r=!0,n+=o):o===")"?(r=!1,n+=o):o===","&&!r?(e.push(n),n=""):n+=o}return n=n.trim(),n&&e.push(n),e}function yz(t){return/^var\(--.+\)$/.test(t)}const xz=(t,e)=>t.startsWith("--")&&typeof e=="string"&&!yz(e),vz=(t,e)=>{if(e==null)return e;const n=i=>{var a,l;return(l=(a=t.__cssMap)==null?void 0:a[i])==null?void 0:l.varRef},r=i=>n(i)??i,[s,o]=gz(e);return e=n(s)??r(o)??r(e),e};function bz(t){const{configs:e={},pseudos:n={},theme:r}=t,s=(o,i=!1)=>{var d;const a=ro(o,r),l=mz(a)(r);let c={};for(let f in l){const p=l[f];let g=ro(p,r);f in n&&(f=n[f]),xz(f,g)&&(g=vz(r,g));let y=e[f];if(y===!0&&(y={property:f}),Mr(g)){c[f]=c[f]??{},c[f]=so({},c[f],s(g,!0));continue}let x=((d=y==null?void 0:y.transform)==null?void 0:d.call(y,g,r,a))??g;x=y!=null&&y.processResult?s(x,!0):x;const w=ro(y==null?void 0:y.property,r);if(!i&&(y!=null&&y.static)){const S=ro(y.static,r);c=so({},c,S)}if(w&&Array.isArray(w)){for(const S of w)c[S]=x;continue}if(w){w==="&"&&Mr(x)?c=so({},c,x):c[w]=x;continue}if(Mr(x)){c=so({},c,x);continue}c[f]=x}return c};return s}const G3=t=>e=>bz({theme:e,pseudos:jc,configs:Xv})(t);function tn(t){return{definePartsStyle(e){return e},defineMultiStyleConfig(e){return{parts:t,...e}}}}function wz(t,e){if(Array.isArray(t))return t;if(Mr(t))return e(t);if(t!=null)return[t]}function Sz(t,e){for(let n=e+1;n<t.length;n++)if(t[n]!=null)return n;return-1}function Cz(t){const e=t.__breakpoints;return function(r,s,o,i){var p,g;if(!e)return;const a={},l=wz(o,e.toArrayValue);if(!l)return a;const c=l.length,d=c===1,f=!!r.parts;for(let y=0;y<c;y++){const x=e.details[y],w=e.details[Sz(l,y)],S=$h(x.minW,w==null?void 0:w._minW),$=ro((p=r[s])==null?void 0:p[l[y]],i);if($){if(f){(g=r.parts)==null||g.forEach(I=>{so(a,{[I]:d?$[I]:{[S]:$[I]}})});continue}if(!f){d?so(a,$):a[S]=$;continue}a[S]=$}}return a}}function $z(t){return e=>{const{variant:n,size:r,theme:s}=e,o=Cz(s);return so({},ro(t.baseStyle??{},e),o(t,"sizes",r,e),o(t,"variants",n,e))}}function Nr(t){return Gv(t,["styleConfig","size","variant","colorScheme"])}function H3(t){return Mr(t)&&t.reference?t.reference:String(t)}const Ug=(t,...e)=>e.map(H3).join(` ${t} `).replace(/calc/g,""),aT=(...t)=>`calc(${Ug("+",...t)})`,lT=(...t)=>`calc(${Ug("-",...t)})`,Sx=(...t)=>`calc(${Ug("*",...t)})`,uT=(...t)=>`calc(${Ug("/",...t)})`,cT=t=>{const e=H3(t);return e!=null&&!Number.isNaN(parseFloat(e))?String(e).startsWith("-")?String(e).slice(1):`-${e}`:Sx(e,-1)},Yi=Object.assign(t=>({add:(...e)=>Yi(aT(t,...e)),subtract:(...e)=>Yi(lT(t,...e)),multiply:(...e)=>Yi(Sx(t,...e)),divide:(...e)=>Yi(uT(t,...e)),negate:()=>Yi(cT(t)),toString:()=>t.toString()}),{add:aT,subtract:lT,multiply:Sx,divide:uT,negate:cT});function kz(t,e="-"){return t.replace(/\s+/g,e)}function Tz(t){const e=kz(t.toString());return Nz(Iz(e))}function Iz(t){return t.includes("\\.")?t:!Number.isInteger(parseFloat(t.toString()))?t.replace(".","\\."):t}function Nz(t){return t.replace(/[!-,/:-@[-^`{-~]/g,"\\$&")}function Ez(t,e=""){return[e,t].filter(Boolean).join("-")}function Rz(t,e){return`var(${t}${e?`, ${e}`:""})`}function _z(t,e=""){return Tz(`--${Ez(t,e)}`)}function Ze(t,e,n){const r=_z(t,n);return{variable:r,reference:Rz(r,e)}}function Pz(t,e){const n={};for(const r of e){if(Array.isArray(r)){const[s,o]=r;n[s]=Ze(`${t}-${s}`,o);continue}n[r]=Ze(`${t}-${r}`)}return n}const Az=["colors","borders","borderWidths","borderStyles","fonts","fontSizes","fontWeights","gradients","letterSpacings","lineHeights","radii","space","shadows","sizes","zIndices","transition","blur","breakpoints"];function Dz(t){return kL(t,Az)}function Fz(t){return t.semanticTokens}function Oz(t){const{__cssMap:e,__cssVars:n,__breakpoints:r,...s}=t;return s}function Lz(t){const e=Dz(t),n=Fz(t),r=o=>W3.includes(o)||o==="default",s={};return rT(e,(o,i)=>{o!=null&&(s[i.join(".")]={isSemantic:!1,value:o})}),rT(n,(o,i)=>{o!=null&&(s[i.join(".")]={isSemantic:!0,value:o})},{stop:o=>Object.keys(o).every(r)}),s}function dT(t,e){return Ze(String(t).replace(/\./g,"-"),void 0,e)}function zz(t){var i;const e=Lz(t),n=(i=t.config)==null?void 0:i.cssVarPrefix;let r={};const s={};function o(a,l){const d=[String(a).split(".")[0],l].join(".");if(!e[d])return l;const{reference:p}=dT(d,n);return p}for(const[a,l]of Object.entries(e)){const{isSemantic:c,value:d}=l,{variable:f,reference:p}=dT(a,n);if(!c){if(a.startsWith("space")){const y=a.split("."),[x,...w]=y,S=`${x}.-${w.join(".")}`,$=Yi.negate(d),I=Yi.negate(p);s[S]={value:$,var:f,varRef:I}}r[f]=d,s[a]={value:d,var:f,varRef:p};continue}const g=Mr(d)?d:{default:d};r=so(r,Object.entries(g).reduce((y,[x,w])=>{if(!w)return y;const S=o(a,`${w}`);if(x==="default")return y[f]=S,y;const $=(jc==null?void 0:jc[x])??x;return y[$]={[f]:S},y},{})),s[a]={value:p,var:f,varRef:p}}return{cssVars:r,cssMap:s}}function Bz(t){const e=Oz(t),{cssMap:n,cssVars:r}=zz(e);return Object.assign(e,{__cssVars:{...{"--chakra-ring-inset":"var(--chakra-empty,/*!*/ /*!*/)","--chakra-ring-offset-width":"0px","--chakra-ring-offset-color":"#fff","--chakra-ring-color":"rgba(66, 153, 225, 0.6)","--chakra-ring-offset-shadow":"0 0 #0000","--chakra-ring-shadow":"0 0 #0000","--chakra-space-x-reverse":"0","--chakra-space-y-reverse":"0"},...r},__cssMap:n,__breakpoints:bL(e.breakpoints)}),e}function Ot(t,e={}){let n=!1;function r(){if(!n){n=!0;return}throw new Error("[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?")}function s(...d){r();for(const f of d)e[f]=l(f);return Ot(t,e)}function o(...d){for(const f of d)f in e||(e[f]=l(f));return Ot(t,e)}function i(){return Object.fromEntries(Object.entries(e).map(([f,p])=>[f,p.selector]))}function a(){return Object.fromEntries(Object.entries(e).map(([f,p])=>[f,p.className]))}function l(d){const g=`chakra-${(["container","root"].includes(d??"")?[t]:[t,d]).filter(Boolean).join("__")}`;return{className:g,selector:`.${g}`,toString:()=>d}}return{parts:s,toPart:l,extend:o,selectors:i,classnames:a,get keys(){return Object.keys(e)},__type:{}}}const Mz=Ot("accordion").parts("root","container","button","panel","icon"),Vz=Ot("alert").parts("title","description","container","icon","spinner"),Wz=Ot("avatar").parts("label","badge","container","excessLabel","group"),Uz=Ot("breadcrumb").parts("link","item","container","separator");Ot("button").parts();const jz=Ot("checkbox").parts("control","icon","container","label");Ot("progress").parts("track","filledTrack","label");const Gz=Ot("drawer").parts("overlay","dialogContainer","dialog","header","closeButton","body","footer"),Hz=Ot("editable").parts("preview","input","textarea"),Kz=Ot("form").parts("container","requiredIndicator","helperText"),Xz=Ot("formError").parts("text","icon"),qz=Ot("input").parts("addon","field","element","group"),Yz=Ot("list").parts("container","item","icon"),Qz=Ot("menu").parts("button","list","item","groupTitle","icon","command","divider"),Zz=Ot("modal").parts("overlay","dialogContainer","dialog","header","closeButton","body","footer"),Jz=Ot("numberinput").parts("root","field","stepperGroup","stepper");Ot("pininput").parts("field");const eB=Ot("popover").parts("content","header","body","footer","popper","arrow","closeButton"),tB=Ot("progress").parts("label","filledTrack","track"),nB=Ot("radio").parts("container","control","label"),rB=Ot("select").parts("field","icon"),sB=Ot("slider").parts("container","track","thumb","filledTrack","mark"),oB=Ot("stat").parts("container","label","helpText","number","icon"),iB=Ot("switch").parts("container","track","thumb","label"),aB=Ot("table").parts("table","thead","tbody","tr","th","td","tfoot","caption"),lB=Ot("tabs").parts("root","tab","tablist","tabpanel","tabpanels","indicator"),uB=Ot("tag").parts("container","label","closeButton"),cB=Ot("card").parts("container","header","body","footer");Ot("stepper").parts("stepper","step","title","description","indicator","separator","icon","number");const{definePartsStyle:dB,defineMultiStyleConfig:hB}=tn(Mz.keys),fB={borderTopWidth:"1px",borderColor:"inherit",_last:{borderBottomWidth:"1px"}},pB={transitionProperty:"common",transitionDuration:"normal",fontSize:"md",_focusVisible:{boxShadow:"outline"},_hover:{bg:"blackAlpha.50"},_disabled:{opacity:.4,cursor:"not-allowed"},px:"4",py:"2"},mB={pt:"2",px:"4",pb:"5"},gB={fontSize:"1.25em"},yB=dB({container:fB,button:pB,panel:mB,icon:gB}),xB=hB({baseStyle:yB});function mu(t,e,n){return Math.min(Math.max(t,n),e)}class vB extends Error{constructor(e){super(`Failed to parse color: "${e}"`)}}var Th=vB;function qv(t){if(typeof t!="string")throw new Th(t);if(t.trim().toLowerCase()==="transparent")return[0,0,0,0];let e=t.trim();e=IB.test(t)?SB(t):t;const n=CB.exec(e);if(n){const i=Array.from(n).slice(1);return[...i.slice(0,3).map(a=>parseInt(tf(a,2),16)),parseInt(tf(i[3]||"f",2),16)/255]}const r=$B.exec(e);if(r){const i=Array.from(r).slice(1);return[...i.slice(0,3).map(a=>parseInt(a,16)),parseInt(i[3]||"ff",16)/255]}const s=kB.exec(e);if(s){const i=Array.from(s).slice(1);return[...i.slice(0,3).map(a=>parseInt(a,10)),parseFloat(i[3]||"1")]}const o=TB.exec(e);if(o){const[i,a,l,c]=Array.from(o).slice(1).map(parseFloat);if(mu(0,100,a)!==a)throw new Th(t);if(mu(0,100,l)!==l)throw new Th(t);return[...NB(i,a,l),Number.isNaN(c)?1:c]}throw new Th(t)}function bB(t){let e=5381,n=t.length;for(;n;)e=e*33^t.charCodeAt(--n);return(e>>>0)%2341}const hT=t=>parseInt(t.replace(/_/g,""),36),wB="1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((t,e)=>{const n=hT(e.substring(0,3)),r=hT(e.substring(3)).toString(16);let s="";for(let o=0;o<6-r.length;o++)s+="0";return t[n]=`${s}${r}`,t},{});function SB(t){const e=t.toLowerCase().trim(),n=wB[bB(e)];if(!n)throw new Th(t);return`#${n}`}const tf=(t,e)=>Array.from(Array(e)).map(()=>t).join(""),CB=new RegExp(`^#${tf("([a-f0-9])",3)}([a-f0-9])?$`,"i"),$B=new RegExp(`^#${tf("([a-f0-9]{2})",3)}([a-f0-9]{2})?$`,"i"),kB=new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${tf(",\\s*(\\d+)\\s*",2)}(?:,\\s*([\\d.]+))?\\s*\\)$`,"i"),TB=/^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i,IB=/^[a-z]+$/i,fT=t=>Math.round(t*255),NB=(t,e,n)=>{let r=n/100;if(e===0)return[r,r,r].map(fT);const s=(t%360+360)%360/60,o=(1-Math.abs(2*r-1))*(e/100),i=o*(1-Math.abs(s%2-1));let a=0,l=0,c=0;s>=0&&s<1?(a=o,l=i):s>=1&&s<2?(a=i,l=o):s>=2&&s<3?(l=o,c=i):s>=3&&s<4?(l=i,c=o):s>=4&&s<5?(a=i,c=o):s>=5&&s<6&&(a=o,c=i);const d=r-o/2,f=a+d,p=l+d,g=c+d;return[f,p,g].map(fT)};function EB(t,e,n,r){return`rgba(${mu(0,255,t).toFixed()}, ${mu(0,255,e).toFixed()}, ${mu(0,255,n).toFixed()}, ${parseFloat(mu(0,1,r).toFixed(3))})`}function RB(t,e){const[n,r,s,o]=qv(t);return EB(n,r,s,o-e)}function _B(t){const[e,n,r,s]=qv(t);let o=i=>{const a=mu(0,255,i).toString(16);return a.length===1?`0${a}`:a};return`#${o(e)}${o(n)}${o(r)}${s<1?o(Math.round(s*255)):""}`}const PB=t=>Object.keys(t).length===0;function AB(t,e,n,r,s){for(e=e.split?e.split("."):e,r=0;r<e.length;r++)t=t?t[e[r]]:s;return t===s?n:t}const zr=(t,e,n)=>{const r=AB(t,`colors.${e}`,e);try{return _B(r),r}catch{return n??"#000000"}},DB=t=>{const[e,n,r]=qv(t);return(e*299+n*587+r*114)/1e3},FB=t=>e=>{const n=zr(e,t);return DB(n)<128?"dark":"light"},OB=t=>e=>FB(t)(e)==="dark",ed=(t,e)=>n=>{const r=zr(n,t);return RB(r,1-e)};function pT(t="1rem",e="rgba(255, 255, 255, 0.15)"){return{backgroundImage:`linear-gradient(
    45deg,
    ${e} 25%,
    transparent 25%,
    transparent 50%,
    ${e} 50%,
    ${e} 75%,
    transparent 75%,
    transparent
  )`,backgroundSize:`${t} ${t}`}}const LB=()=>`#${Math.floor(Math.random()*16777215).toString(16).padEnd(6,"0")}`;function zB(t){const e=LB();return!t||PB(t)?e:t.string&&t.colors?MB(t.string,t.colors):t.string&&!t.colors?BB(t.string):t.colors&&!t.string?VB(t.colors):e}function BB(t){let e=0;if(t.length===0)return e.toString();for(let r=0;r<t.length;r+=1)e=t.charCodeAt(r)+((e<<5)-e),e=e&e;let n="#";for(let r=0;r<3;r+=1){const s=e>>r*8&255;n+=`00${s.toString(16)}`.substr(-2)}return n}function MB(t,e){let n=0;if(t.length===0)return e[0];for(let r=0;r<t.length;r+=1)n=t.charCodeAt(r)+((n<<5)-n),n=n&n;return n=(n%e.length+e.length)%e.length,e[n]}function VB(t){return t[Math.floor(Math.random()*t.length)]}function Qe(t,e){return n=>n.colorMode==="dark"?e:t}function Yv(t){const{orientation:e,vertical:n,horizontal:r}=t;return e?e==="vertical"?n:r:{}}function K3(t){return Mr(t)&&t.reference?t.reference:String(t)}const jg=(t,...e)=>e.map(K3).join(` ${t} `).replace(/calc/g,""),mT=(...t)=>`calc(${jg("+",...t)})`,gT=(...t)=>`calc(${jg("-",...t)})`,Cx=(...t)=>`calc(${jg("*",...t)})`,yT=(...t)=>`calc(${jg("/",...t)})`,xT=t=>{const e=K3(t);return e!=null&&!Number.isNaN(parseFloat(e))?String(e).startsWith("-")?String(e).slice(1):`-${e}`:Cx(e,-1)},Qi=Object.assign(t=>({add:(...e)=>Qi(mT(t,...e)),subtract:(...e)=>Qi(gT(t,...e)),multiply:(...e)=>Qi(Cx(t,...e)),divide:(...e)=>Qi(yT(t,...e)),negate:()=>Qi(xT(t)),toString:()=>t.toString()}),{add:mT,subtract:gT,multiply:Cx,divide:yT,negate:xT});function WB(t){return!Number.isInteger(parseFloat(t.toString()))}function UB(t,e="-"){return t.replace(/\s+/g,e)}function X3(t){const e=UB(t.toString());return e.includes("\\.")?t:WB(t)?e.replace(".","\\."):t}function jB(t,e=""){return[e,X3(t)].filter(Boolean).join("-")}function GB(t,e){return`var(${X3(t)}${e?`, ${e}`:""})`}function HB(t,e=""){return`--${jB(t,e)}`}function Ln(t,e){const n=HB(t,e==null?void 0:e.prefix);return{variable:n,reference:GB(n,KB(e==null?void 0:e.fallback))}}function KB(t){return t==null?void 0:t.reference}const{definePartsStyle:Ff,defineMultiStyleConfig:XB}=tn(Vz.keys),_s=Ze("alert-fg"),ia=Ze("alert-bg"),qB=Ff({container:{bg:ia.reference,px:"4",py:"3"},title:{fontWeight:"bold",lineHeight:"6",marginEnd:"2"},description:{lineHeight:"6"},icon:{color:_s.reference,flexShrink:0,marginEnd:"3",w:"5",h:"6"},spinner:{color:_s.reference,flexShrink:0,marginEnd:"3",w:"5",h:"5"}});function Qv(t){const{theme:e,colorScheme:n}=t,r=ed(`${n}.200`,.16)(e);return{light:`colors.${n}.100`,dark:r}}const YB=Ff(t=>{const{colorScheme:e}=t,n=Qv(t);return{container:{[_s.variable]:`colors.${e}.600`,[ia.variable]:n.light,_dark:{[_s.variable]:`colors.${e}.200`,[ia.variable]:n.dark}}}}),QB=Ff(t=>{const{colorScheme:e}=t,n=Qv(t);return{container:{[_s.variable]:`colors.${e}.600`,[ia.variable]:n.light,_dark:{[_s.variable]:`colors.${e}.200`,[ia.variable]:n.dark},paddingStart:"3",borderStartWidth:"4px",borderStartColor:_s.reference}}}),ZB=Ff(t=>{const{colorScheme:e}=t,n=Qv(t);return{container:{[_s.variable]:`colors.${e}.600`,[ia.variable]:n.light,_dark:{[_s.variable]:`colors.${e}.200`,[ia.variable]:n.dark},pt:"2",borderTopWidth:"4px",borderTopColor:_s.reference}}}),JB=Ff(t=>{const{colorScheme:e}=t;return{container:{[_s.variable]:"colors.white",[ia.variable]:`colors.${e}.600`,_dark:{[_s.variable]:"colors.gray.900",[ia.variable]:`colors.${e}.200`},color:_s.reference}}}),eM={subtle:YB,"left-accent":QB,"top-accent":ZB,solid:JB},tM=XB({baseStyle:qB,variants:eM,defaultProps:{variant:"subtle",colorScheme:"blue"}}),q3={px:"1px",.5:"0.125rem",1:"0.25rem",1.5:"0.375rem",2:"0.5rem",2.5:"0.625rem",3:"0.75rem",3.5:"0.875rem",4:"1rem",5:"1.25rem",6:"1.5rem",7:"1.75rem",8:"2rem",9:"2.25rem",10:"2.5rem",12:"3rem",14:"3.5rem",16:"4rem",20:"5rem",24:"6rem",28:"7rem",32:"8rem",36:"9rem",40:"10rem",44:"11rem",48:"12rem",52:"13rem",56:"14rem",60:"15rem",64:"16rem",72:"18rem",80:"20rem",96:"24rem"},nM={max:"max-content",min:"min-content",full:"100%","3xs":"14rem","2xs":"16rem",xs:"20rem",sm:"24rem",md:"28rem",lg:"32rem",xl:"36rem","2xl":"42rem","3xl":"48rem","4xl":"56rem","5xl":"64rem","6xl":"72rem","7xl":"80rem","8xl":"90rem",prose:"60ch"},rM={sm:"640px",md:"768px",lg:"1024px",xl:"1280px"},Y3={...q3,...nM,container:rM},sM=t=>typeof t=="function";function Vr(t,...e){return sM(t)?t(...e):t}const{definePartsStyle:Q3,defineMultiStyleConfig:oM}=tn(Wz.keys),Gc=Ze("avatar-border-color"),Vh=Ze("avatar-bg"),nf=Ze("avatar-font-size"),td=Ze("avatar-size"),iM={borderRadius:"full",border:"0.2em solid",borderColor:Gc.reference,[Gc.variable]:"white",_dark:{[Gc.variable]:"colors.gray.800"}},aM={bg:Vh.reference,fontSize:nf.reference,width:td.reference,height:td.reference,lineHeight:"1",[Vh.variable]:"colors.gray.200",_dark:{[Vh.variable]:"colors.whiteAlpha.400"}},lM=t=>{const{name:e,theme:n}=t,r=e?zB({string:e}):"colors.gray.400",s=OB(r)(n);let o="white";return s||(o="gray.800"),{bg:Vh.reference,fontSize:nf.reference,color:o,borderColor:Gc.reference,verticalAlign:"top",width:td.reference,height:td.reference,"&:not([data-loaded])":{[Vh.variable]:r},[Gc.variable]:"colors.white",_dark:{[Gc.variable]:"colors.gray.800"}}},uM={fontSize:nf.reference,lineHeight:"1"},cM=Q3(t=>({badge:Vr(iM,t),excessLabel:Vr(aM,t),container:Vr(lM,t),label:uM}));function el(t){const e=t!=="100%"?Y3[t]:void 0;return Q3({container:{[td.variable]:e??t,[nf.variable]:`calc(${e??t} / 2.5)`},excessLabel:{[td.variable]:e??t,[nf.variable]:`calc(${e??t} / 2.5)`}})}const dM={"2xs":el(4),xs:el(6),sm:el(8),md:el(12),lg:el(16),xl:el(24),"2xl":el(32),full:el("100%")},hM=oM({baseStyle:cM,sizes:dM,defaultProps:{size:"md"}}),$n=Pz("badge",["bg","color","shadow"]),fM={px:1,textTransform:"uppercase",fontSize:"xs",borderRadius:"sm",fontWeight:"bold",bg:$n.bg.reference,color:$n.color.reference,boxShadow:$n.shadow.reference},pM=t=>{const{colorScheme:e,theme:n}=t,r=ed(`${e}.500`,.6)(n);return{[$n.bg.variable]:`colors.${e}.500`,[$n.color.variable]:"colors.white",_dark:{[$n.bg.variable]:r,[$n.color.variable]:"colors.whiteAlpha.800"}}},mM=t=>{const{colorScheme:e,theme:n}=t,r=ed(`${e}.200`,.16)(n);return{[$n.bg.variable]:`colors.${e}.100`,[$n.color.variable]:`colors.${e}.800`,_dark:{[$n.bg.variable]:r,[$n.color.variable]:`colors.${e}.200`}}},gM=t=>{const{colorScheme:e,theme:n}=t,r=ed(`${e}.200`,.8)(n);return{[$n.color.variable]:`colors.${e}.500`,_dark:{[$n.color.variable]:r},[$n.shadow.variable]:`inset 0 0 0px 1px ${$n.color.reference}`}},yM={solid:pM,subtle:mM,outline:gM},Wh={baseStyle:fM,variants:yM,defaultProps:{variant:"subtle",colorScheme:"gray"}},{defineMultiStyleConfig:xM,definePartsStyle:vM}=tn(Uz.keys),u1=Ze("breadcrumb-link-decor"),bM={transitionProperty:"common",transitionDuration:"fast",transitionTimingFunction:"ease-out",outline:"none",color:"inherit",textDecoration:u1.reference,[u1.variable]:"none","&:not([aria-current=page])":{cursor:"pointer",_hover:{[u1.variable]:"underline"},_focusVisible:{boxShadow:"outline"}}},wM=vM({link:bM}),SM=xM({baseStyle:wM}),CM={lineHeight:"1.2",borderRadius:"md",fontWeight:"semibold",transitionProperty:"common",transitionDuration:"normal",_focusVisible:{boxShadow:"outline"},_disabled:{opacity:.4,cursor:"not-allowed",boxShadow:"none"},_hover:{_disabled:{bg:"initial"}}},Z3=t=>{const{colorScheme:e,theme:n}=t;if(e==="gray")return{color:Qe("gray.800","whiteAlpha.900")(t),_hover:{bg:Qe("gray.100","whiteAlpha.200")(t)},_active:{bg:Qe("gray.200","whiteAlpha.300")(t)}};const r=ed(`${e}.200`,.12)(n),s=ed(`${e}.200`,.24)(n);return{color:Qe(`${e}.600`,`${e}.200`)(t),bg:"transparent",_hover:{bg:Qe(`${e}.50`,r)(t)},_active:{bg:Qe(`${e}.100`,s)(t)}}},$M=t=>{const{colorScheme:e}=t,n=Qe("gray.200","whiteAlpha.300")(t);return{border:"1px solid",borderColor:e==="gray"?n:"currentColor",".chakra-button__group[data-attached][data-orientation=horizontal] > &:not(:last-of-type)":{marginEnd:"-1px"},".chakra-button__group[data-attached][data-orientation=vertical] > &:not(:last-of-type)":{marginBottom:"-1px"},...Vr(Z3,t)}},kM={yellow:{bg:"yellow.400",color:"black",hoverBg:"yellow.500",activeBg:"yellow.600"},cyan:{bg:"cyan.400",color:"black",hoverBg:"cyan.500",activeBg:"cyan.600"}},TM=t=>{const{colorScheme:e}=t;if(e==="gray"){const a=Qe("gray.100","whiteAlpha.200")(t);return{bg:a,color:Qe("gray.800","whiteAlpha.900")(t),_hover:{bg:Qe("gray.200","whiteAlpha.300")(t),_disabled:{bg:a}},_active:{bg:Qe("gray.300","whiteAlpha.400")(t)}}}const{bg:n=`${e}.500`,color:r="white",hoverBg:s=`${e}.600`,activeBg:o=`${e}.700`}=kM[e]??{},i=Qe(n,`${e}.200`)(t);return{bg:i,color:Qe(r,"gray.800")(t),_hover:{bg:Qe(s,`${e}.300`)(t),_disabled:{bg:i}},_active:{bg:Qe(o,`${e}.400`)(t)}}},IM=t=>{const{colorScheme:e}=t;return{padding:0,height:"auto",lineHeight:"normal",verticalAlign:"baseline",color:Qe(`${e}.500`,`${e}.200`)(t),_hover:{textDecoration:"underline",_disabled:{textDecoration:"none"}},_active:{color:Qe(`${e}.700`,`${e}.500`)(t)}}},NM={bg:"none",color:"inherit",display:"inline",lineHeight:"inherit",m:"0",p:"0"},EM={ghost:Z3,outline:$M,solid:TM,link:IM,unstyled:NM},RM={lg:{h:"12",minW:"12",fontSize:"lg",px:"6"},md:{h:"10",minW:"10",fontSize:"md",px:"4"},sm:{h:"8",minW:"8",fontSize:"sm",px:"3"},xs:{h:"6",minW:"6",fontSize:"xs",px:"2"}},_M={baseStyle:CM,variants:EM,sizes:RM,defaultProps:{variant:"solid",size:"md",colorScheme:"gray"}},{definePartsStyle:wu,defineMultiStyleConfig:PM}=tn(cB.keys),og=Ze("card-bg"),na=Ze("card-padding"),J3=Ze("card-shadow"),_m=Ze("card-radius"),eR=Ze("card-border-width","0"),tR=Ze("card-border-color"),AM=wu({container:{[og.variable]:"colors.chakra-body-bg",backgroundColor:og.reference,boxShadow:J3.reference,borderRadius:_m.reference,color:"chakra-body-text",borderWidth:eR.reference,borderColor:tR.reference},body:{padding:na.reference,flex:"1 1 0%"},header:{padding:na.reference},footer:{padding:na.reference}}),DM={sm:wu({container:{[_m.variable]:"radii.base",[na.variable]:"space.3"}}),md:wu({container:{[_m.variable]:"radii.md",[na.variable]:"space.5"}}),lg:wu({container:{[_m.variable]:"radii.xl",[na.variable]:"space.7"}})},FM={elevated:wu({container:{[J3.variable]:"shadows.base",_dark:{[og.variable]:"colors.gray.700"}}}),outline:wu({container:{[eR.variable]:"1px",[tR.variable]:"colors.chakra-border-color"}}),filled:wu({container:{[og.variable]:"colors.chakra-subtle-bg"}}),unstyled:{body:{[na.variable]:0},header:{[na.variable]:0},footer:{[na.variable]:0}}},OM=PM({baseStyle:AM,variants:FM,sizes:DM,defaultProps:{variant:"elevated",size:"md"}}),{definePartsStyle:Pm,defineMultiStyleConfig:LM}=tn(jz.keys),Uh=Ze("checkbox-size"),zM=t=>{const{colorScheme:e}=t;return{w:Uh.reference,h:Uh.reference,transitionProperty:"box-shadow",transitionDuration:"normal",border:"2px solid",borderRadius:"sm",borderColor:"inherit",color:"white",_checked:{bg:Qe(`${e}.500`,`${e}.200`)(t),borderColor:Qe(`${e}.500`,`${e}.200`)(t),color:Qe("white","gray.900")(t),_hover:{bg:Qe(`${e}.600`,`${e}.300`)(t),borderColor:Qe(`${e}.600`,`${e}.300`)(t)},_disabled:{borderColor:Qe("gray.200","transparent")(t),bg:Qe("gray.200","whiteAlpha.300")(t),color:Qe("gray.500","whiteAlpha.500")(t)}},_indeterminate:{bg:Qe(`${e}.500`,`${e}.200`)(t),borderColor:Qe(`${e}.500`,`${e}.200`)(t),color:Qe("white","gray.900")(t)},_disabled:{bg:Qe("gray.100","whiteAlpha.100")(t),borderColor:Qe("gray.100","transparent")(t)},_focusVisible:{boxShadow:"outline"},_invalid:{borderColor:Qe("red.500","red.300")(t)}}},BM={_disabled:{cursor:"not-allowed"}},MM={userSelect:"none",_disabled:{opacity:.4}},VM={transitionProperty:"transform",transitionDuration:"normal"},WM=Pm(t=>({icon:VM,container:BM,control:Vr(zM,t),label:MM})),UM={sm:Pm({control:{[Uh.variable]:"sizes.3"},label:{fontSize:"sm"},icon:{fontSize:"3xs"}}),md:Pm({control:{[Uh.variable]:"sizes.4"},label:{fontSize:"md"},icon:{fontSize:"2xs"}}),lg:Pm({control:{[Uh.variable]:"sizes.5"},label:{fontSize:"lg"},icon:{fontSize:"2xs"}})},rl=LM({baseStyle:WM,sizes:UM,defaultProps:{size:"md",colorScheme:"blue"}}),jh=Ln("close-button-size"),mh=Ln("close-button-bg"),jM={w:[jh.reference],h:[jh.reference],borderRadius:"md",transitionProperty:"common",transitionDuration:"normal",_disabled:{opacity:.4,cursor:"not-allowed",boxShadow:"none"},_hover:{[mh.variable]:"colors.blackAlpha.100",_dark:{[mh.variable]:"colors.whiteAlpha.100"}},_active:{[mh.variable]:"colors.blackAlpha.200",_dark:{[mh.variable]:"colors.whiteAlpha.200"}},_focusVisible:{boxShadow:"outline"},bg:mh.reference},GM={lg:{[jh.variable]:"sizes.10",fontSize:"md"},md:{[jh.variable]:"sizes.8",fontSize:"xs"},sm:{[jh.variable]:"sizes.6",fontSize:"2xs"}},HM={baseStyle:jM,sizes:GM,defaultProps:{size:"md"}},{variants:KM,defaultProps:XM}=Wh,qM={fontFamily:"mono",fontSize:"sm",px:"0.2em",borderRadius:"sm",bg:$n.bg.reference,color:$n.color.reference,boxShadow:$n.shadow.reference},YM={baseStyle:qM,variants:KM,defaultProps:XM},QM={w:"100%",mx:"auto",maxW:"prose",px:"4"},ZM={baseStyle:QM},JM={opacity:.6,borderColor:"inherit"},eV={borderStyle:"solid"},tV={borderStyle:"dashed"},nV={solid:eV,dashed:tV},rV={baseStyle:JM,variants:nV,defaultProps:{variant:"solid"}},{definePartsStyle:$x,defineMultiStyleConfig:sV}=tn(Gz.keys),c1=Ze("drawer-bg"),d1=Ze("drawer-box-shadow");function Cc(t){return $x(t==="full"?{dialog:{maxW:"100vw",h:"100vh"}}:{dialog:{maxW:t}})}const oV={bg:"blackAlpha.600",zIndex:"modal"},iV={display:"flex",zIndex:"modal",justifyContent:"center"},aV=t=>{const{isFullHeight:e}=t;return{...e&&{height:"100vh"},zIndex:"modal",maxH:"100vh",color:"inherit",[c1.variable]:"colors.white",[d1.variable]:"shadows.lg",_dark:{[c1.variable]:"colors.gray.700",[d1.variable]:"shadows.dark-lg"},bg:c1.reference,boxShadow:d1.reference}},lV={px:"6",py:"4",fontSize:"xl",fontWeight:"semibold"},uV={position:"absolute",top:"2",insetEnd:"3"},cV={px:"6",py:"2",flex:"1",overflow:"auto"},dV={px:"6",py:"4"},hV=$x(t=>({overlay:oV,dialogContainer:iV,dialog:Vr(aV,t),header:lV,closeButton:uV,body:cV,footer:dV})),fV={xs:Cc("xs"),sm:Cc("md"),md:Cc("lg"),lg:Cc("2xl"),xl:Cc("4xl"),full:Cc("full")},pV=sV({baseStyle:hV,sizes:fV,defaultProps:{size:"xs"}}),{definePartsStyle:mV,defineMultiStyleConfig:gV}=tn(Hz.keys),yV={borderRadius:"md",py:"1",transitionProperty:"common",transitionDuration:"normal"},xV={borderRadius:"md",py:"1",transitionProperty:"common",transitionDuration:"normal",width:"full",_focusVisible:{boxShadow:"outline"},_placeholder:{opacity:.6}},vV={borderRadius:"md",py:"1",transitionProperty:"common",transitionDuration:"normal",width:"full",_focusVisible:{boxShadow:"outline"},_placeholder:{opacity:.6}},bV=mV({preview:yV,input:xV,textarea:vV}),wV=gV({baseStyle:bV}),{definePartsStyle:SV,defineMultiStyleConfig:CV}=tn(Kz.keys),Hc=Ze("form-control-color"),$V={marginStart:"1",[Hc.variable]:"colors.red.500",_dark:{[Hc.variable]:"colors.red.300"},color:Hc.reference},kV={mt:"2",[Hc.variable]:"colors.gray.600",_dark:{[Hc.variable]:"colors.whiteAlpha.600"},color:Hc.reference,lineHeight:"normal",fontSize:"sm"},TV=SV({container:{width:"100%",position:"relative"},requiredIndicator:$V,helperText:kV}),IV=CV({baseStyle:TV}),{definePartsStyle:NV,defineMultiStyleConfig:EV}=tn(Xz.keys),Kc=Ze("form-error-color"),RV={[Kc.variable]:"colors.red.500",_dark:{[Kc.variable]:"colors.red.300"},color:Kc.reference,mt:"2",fontSize:"sm",lineHeight:"normal"},_V={marginEnd:"0.5em",[Kc.variable]:"colors.red.500",_dark:{[Kc.variable]:"colors.red.300"},color:Kc.reference},PV=NV({text:RV,icon:_V}),AV=EV({baseStyle:PV}),DV={fontSize:"md",marginEnd:"3",mb:"2",fontWeight:"medium",transitionProperty:"common",transitionDuration:"normal",opacity:1,_disabled:{opacity:.4}},FV={baseStyle:DV},OV={fontFamily:"heading",fontWeight:"bold"},LV={"4xl":{fontSize:["6xl",null,"7xl"],lineHeight:1},"3xl":{fontSize:["5xl",null,"6xl"],lineHeight:1},"2xl":{fontSize:["4xl",null,"5xl"],lineHeight:[1.2,null,1]},xl:{fontSize:["3xl",null,"4xl"],lineHeight:[1.33,null,1.2]},lg:{fontSize:["2xl",null,"3xl"],lineHeight:[1.33,null,1.2]},md:{fontSize:"xl",lineHeight:1.2},sm:{fontSize:"md",lineHeight:1.2},xs:{fontSize:"sm",lineHeight:1.2}},zV={baseStyle:OV,sizes:LV,defaultProps:{size:"xl"}},{definePartsStyle:ea,defineMultiStyleConfig:BV}=tn(qz.keys),Ac=Ze("input-height"),Dc=Ze("input-font-size"),Fc=Ze("input-padding"),Oc=Ze("input-border-radius"),MV=ea({addon:{height:Ac.reference,fontSize:Dc.reference,px:Fc.reference,borderRadius:Oc.reference},field:{width:"100%",height:Ac.reference,fontSize:Dc.reference,px:Fc.reference,borderRadius:Oc.reference,minWidth:0,outline:0,position:"relative",appearance:"none",transitionProperty:"common",transitionDuration:"normal",_disabled:{opacity:.4,cursor:"not-allowed"}}}),tl={lg:{[Dc.variable]:"fontSizes.lg",[Fc.variable]:"space.4",[Oc.variable]:"radii.md",[Ac.variable]:"sizes.12"},md:{[Dc.variable]:"fontSizes.md",[Fc.variable]:"space.4",[Oc.variable]:"radii.md",[Ac.variable]:"sizes.10"},sm:{[Dc.variable]:"fontSizes.sm",[Fc.variable]:"space.3",[Oc.variable]:"radii.sm",[Ac.variable]:"sizes.8"},xs:{[Dc.variable]:"fontSizes.xs",[Fc.variable]:"space.2",[Oc.variable]:"radii.sm",[Ac.variable]:"sizes.6"}},VV={lg:ea({field:tl.lg,group:tl.lg}),md:ea({field:tl.md,group:tl.md}),sm:ea({field:tl.sm,group:tl.sm}),xs:ea({field:tl.xs,group:tl.xs})};function Zv(t){const{focusBorderColor:e,errorBorderColor:n}=t;return{focusBorderColor:e||Qe("blue.500","blue.300")(t),errorBorderColor:n||Qe("red.500","red.300")(t)}}const WV=ea(t=>{const{theme:e}=t,{focusBorderColor:n,errorBorderColor:r}=Zv(t);return{field:{border:"1px solid",borderColor:"inherit",bg:"inherit",_hover:{borderColor:Qe("gray.300","whiteAlpha.400")(t)},_readOnly:{boxShadow:"none !important",userSelect:"all"},_invalid:{borderColor:zr(e,r),boxShadow:`0 0 0 1px ${zr(e,r)}`},_focusVisible:{zIndex:1,borderColor:zr(e,n),boxShadow:`0 0 0 1px ${zr(e,n)}`}},addon:{border:"1px solid",borderColor:Qe("inherit","whiteAlpha.50")(t),bg:Qe("gray.100","whiteAlpha.300")(t)}}}),UV=ea(t=>{const{theme:e}=t,{focusBorderColor:n,errorBorderColor:r}=Zv(t);return{field:{border:"2px solid",borderColor:"transparent",bg:Qe("gray.100","whiteAlpha.50")(t),_hover:{bg:Qe("gray.200","whiteAlpha.100")(t)},_readOnly:{boxShadow:"none !important",userSelect:"all"},_invalid:{borderColor:zr(e,r)},_focusVisible:{bg:"transparent",borderColor:zr(e,n)}},addon:{border:"2px solid",borderColor:"transparent",bg:Qe("gray.100","whiteAlpha.50")(t)}}}),jV=ea(t=>{const{theme:e}=t,{focusBorderColor:n,errorBorderColor:r}=Zv(t);return{field:{borderBottom:"1px solid",borderColor:"inherit",borderRadius:"0",px:"0",bg:"transparent",_readOnly:{boxShadow:"none !important",userSelect:"all"},_invalid:{borderColor:zr(e,r),boxShadow:`0px 1px 0px 0px ${zr(e,r)}`},_focusVisible:{borderColor:zr(e,n),boxShadow:`0px 1px 0px 0px ${zr(e,n)}`}},addon:{borderBottom:"2px solid",borderColor:"inherit",borderRadius:"0",px:"0",bg:"transparent"}}}),GV=ea({field:{bg:"transparent",px:"0",height:"auto"},addon:{bg:"transparent",px:"0",height:"auto"}}),HV={outline:WV,filled:UV,flushed:jV,unstyled:GV},Ft=BV({baseStyle:MV,sizes:VV,variants:HV,defaultProps:{size:"md",variant:"outline"}}),h1=Ze("kbd-bg"),KV={[h1.variable]:"colors.gray.100",_dark:{[h1.variable]:"colors.whiteAlpha.100"},bg:h1.reference,borderRadius:"md",borderWidth:"1px",borderBottomWidth:"3px",fontSize:"0.8em",fontWeight:"bold",lineHeight:"normal",px:"0.4em",whiteSpace:"nowrap"},XV={baseStyle:KV},qV={transitionProperty:"common",transitionDuration:"fast",transitionTimingFunction:"ease-out",cursor:"pointer",textDecoration:"none",outline:"none",color:"inherit",_hover:{textDecoration:"underline"},_focusVisible:{boxShadow:"outline"}},YV={baseStyle:qV},{defineMultiStyleConfig:QV,definePartsStyle:ZV}=tn(Yz.keys),JV={marginEnd:"2",display:"inline",verticalAlign:"text-bottom"},e5=ZV({icon:JV}),t5=QV({baseStyle:e5}),{defineMultiStyleConfig:n5,definePartsStyle:r5}=tn(Qz.keys),ii=Ze("menu-bg"),f1=Ze("menu-shadow"),s5={[ii.variable]:"#fff",[f1.variable]:"shadows.sm",_dark:{[ii.variable]:"colors.gray.700",[f1.variable]:"shadows.dark-lg"},color:"inherit",minW:"3xs",py:"2",zIndex:"dropdown",borderRadius:"md",borderWidth:"1px",bg:ii.reference,boxShadow:f1.reference},o5={py:"1.5",px:"3",transitionProperty:"background",transitionDuration:"ultra-fast",transitionTimingFunction:"ease-in",_focus:{[ii.variable]:"colors.gray.100",_dark:{[ii.variable]:"colors.whiteAlpha.100"}},_active:{[ii.variable]:"colors.gray.200",_dark:{[ii.variable]:"colors.whiteAlpha.200"}},_expanded:{[ii.variable]:"colors.gray.100",_dark:{[ii.variable]:"colors.whiteAlpha.100"}},_disabled:{opacity:.4,cursor:"not-allowed"},bg:ii.reference},i5={mx:4,my:2,fontWeight:"semibold",fontSize:"sm"},a5={display:"inline-flex",alignItems:"center",justifyContent:"center",flexShrink:0},l5={opacity:.6},u5={border:0,borderBottom:"1px solid",borderColor:"inherit",my:"2",opacity:.6},c5={transitionProperty:"common",transitionDuration:"normal"},d5=r5({button:c5,list:s5,item:o5,groupTitle:i5,icon:a5,command:l5,divider:u5}),h5=n5({baseStyle:d5}),{defineMultiStyleConfig:f5,definePartsStyle:kx}=tn(Zz.keys),p1=Ze("modal-bg"),m1=Ze("modal-shadow"),p5={bg:"blackAlpha.600",zIndex:"modal"},m5=t=>{const{isCentered:e,scrollBehavior:n}=t;return{display:"flex",zIndex:"modal",justifyContent:"center",alignItems:e?"center":"flex-start",overflow:n==="inside"?"hidden":"auto",overscrollBehaviorY:"none"}},g5=t=>{const{isCentered:e,scrollBehavior:n}=t;return{borderRadius:"md",color:"inherit",my:e?"auto":"16",mx:e?"auto":void 0,zIndex:"modal",maxH:n==="inside"?"calc(100% - 7.5rem)":void 0,[p1.variable]:"colors.white",[m1.variable]:"shadows.lg",_dark:{[p1.variable]:"colors.gray.700",[m1.variable]:"shadows.dark-lg"},bg:p1.reference,boxShadow:m1.reference}},y5={px:"6",py:"4",fontSize:"xl",fontWeight:"semibold"},x5={position:"absolute",top:"2",insetEnd:"3"},v5=t=>{const{scrollBehavior:e}=t;return{px:"6",py:"2",flex:"1",overflow:e==="inside"?"auto":void 0}},b5={px:"6",py:"4"},w5=kx(t=>({overlay:p5,dialogContainer:Vr(m5,t),dialog:Vr(g5,t),header:y5,closeButton:x5,body:Vr(v5,t),footer:b5}));function Eo(t){return kx(t==="full"?{dialog:{maxW:"100vw",minH:"$100vh",my:"0",borderRadius:"0"}}:{dialog:{maxW:t}})}const S5={xs:Eo("xs"),sm:Eo("sm"),md:Eo("md"),lg:Eo("lg"),xl:Eo("xl"),"2xl":Eo("2xl"),"3xl":Eo("3xl"),"4xl":Eo("4xl"),"5xl":Eo("5xl"),"6xl":Eo("6xl"),full:Eo("full")},C5=f5({baseStyle:w5,sizes:S5,defaultProps:{size:"md"}}),nR={letterSpacings:{tighter:"-0.05em",tight:"-0.025em",normal:"0",wide:"0.025em",wider:"0.05em",widest:"0.1em"},lineHeights:{normal:"normal",none:1,shorter:1.25,short:1.375,base:1.5,tall:1.625,taller:"2",3:".75rem",4:"1rem",5:"1.25rem",6:"1.5rem",7:"1.75rem",8:"2rem",9:"2.25rem",10:"2.5rem"},fontWeights:{hairline:100,thin:200,light:300,normal:400,medium:500,semibold:600,bold:700,extrabold:800,black:900},fonts:{heading:'-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',body:'-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',mono:'SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace'},fontSizes:{"3xs":"0.45rem","2xs":"0.625rem",xs:"0.75rem",sm:"0.875rem",md:"1rem",lg:"1.125rem",xl:"1.25rem","2xl":"1.5rem","3xl":"1.875rem","4xl":"2.25rem","5xl":"3rem","6xl":"3.75rem","7xl":"4.5rem","8xl":"6rem","9xl":"8rem"}},{defineMultiStyleConfig:$5,definePartsStyle:rR}=tn(Jz.keys),Jv=Ln("number-input-stepper-width"),sR=Ln("number-input-input-padding"),k5=Qi(Jv).add("0.5rem").toString(),g1=Ln("number-input-bg"),y1=Ln("number-input-color"),x1=Ln("number-input-border-color"),T5={[Jv.variable]:"sizes.6",[sR.variable]:k5},I5=t=>{var e;return((e=Vr(Ft.baseStyle,t))==null?void 0:e.field)??{}},N5={width:Jv.reference},E5={borderStart:"1px solid",borderStartColor:x1.reference,color:y1.reference,bg:g1.reference,[y1.variable]:"colors.chakra-body-text",[x1.variable]:"colors.chakra-border-color",_dark:{[y1.variable]:"colors.whiteAlpha.800",[x1.variable]:"colors.whiteAlpha.300"},_active:{[g1.variable]:"colors.gray.200",_dark:{[g1.variable]:"colors.whiteAlpha.300"}},_disabled:{opacity:.4,cursor:"not-allowed"}},R5=rR(t=>({root:T5,field:Vr(I5,t)??{},stepperGroup:N5,stepper:E5}));function am(t){var o,i;const e=(o=Ft.sizes)==null?void 0:o[t],n={lg:"md",md:"md",sm:"sm",xs:"sm"},r=((i=e.field)==null?void 0:i.fontSize)??"md",s=nR.fontSizes[r];return rR({field:{...e.field,paddingInlineEnd:sR.reference,verticalAlign:"top"},stepper:{fontSize:Qi(s).multiply(.75).toString(),_first:{borderTopEndRadius:n[t]},_last:{borderBottomEndRadius:n[t],mt:"-1px",borderTopWidth:1}}})}const _5={xs:am("xs"),sm:am("sm"),md:am("md"),lg:am("lg")},P5=$5({baseStyle:R5,sizes:_5,variants:Ft.variants,defaultProps:Ft.defaultProps});var b3;const A5={...(b3=Ft.baseStyle)==null?void 0:b3.field,textAlign:"center"},D5={lg:{fontSize:"lg",w:12,h:12,borderRadius:"md"},md:{fontSize:"md",w:10,h:10,borderRadius:"md"},sm:{fontSize:"sm",w:8,h:8,borderRadius:"sm"},xs:{fontSize:"xs",w:6,h:6,borderRadius:"sm"}};var w3;const F5={outline:t=>{var e,n;return((n=Vr((e=Ft.variants)==null?void 0:e.outline,t))==null?void 0:n.field)??{}},flushed:t=>{var e,n;return((n=Vr((e=Ft.variants)==null?void 0:e.flushed,t))==null?void 0:n.field)??{}},filled:t=>{var e,n;return((n=Vr((e=Ft.variants)==null?void 0:e.filled,t))==null?void 0:n.field)??{}},unstyled:((w3=Ft.variants)==null?void 0:w3.unstyled.field)??{}},O5={baseStyle:A5,sizes:D5,variants:F5,defaultProps:Ft.defaultProps},{defineMultiStyleConfig:L5,definePartsStyle:z5}=tn(eB.keys),lm=Ln("popper-bg"),B5=Ln("popper-arrow-bg"),vT=Ln("popper-arrow-shadow-color"),M5={zIndex:"popover"},V5={[lm.variable]:"colors.white",bg:lm.reference,[B5.variable]:lm.reference,[vT.variable]:"colors.gray.200",_dark:{[lm.variable]:"colors.gray.700",[vT.variable]:"colors.whiteAlpha.300"},width:"xs",border:"1px solid",borderColor:"inherit",borderRadius:"md",boxShadow:"sm",zIndex:"inherit",_focusVisible:{outline:0,boxShadow:"outline"}},W5={px:3,py:2,borderBottomWidth:"1px"},U5={px:3,py:2},j5={px:3,py:2,borderTopWidth:"1px"},G5={position:"absolute",borderRadius:"md",top:1,insetEnd:2,padding:2},H5=z5({popper:M5,content:V5,header:W5,body:U5,footer:j5,closeButton:G5}),K5=L5({baseStyle:H5}),{defineMultiStyleConfig:X5,definePartsStyle:Ih}=tn(tB.keys),q5=t=>{const{colorScheme:e,theme:n,isIndeterminate:r,hasStripe:s}=t,o=Qe(pT(),pT("1rem","rgba(0,0,0,0.1)"))(t),i=Qe(`${e}.500`,`${e}.200`)(t),a=`linear-gradient(
    to right,
    transparent 0%,
    ${zr(n,i)} 50%,
    transparent 100%
  )`;return{...!r&&s&&o,...r?{bgImage:a}:{bgColor:i}}},Y5={lineHeight:"1",fontSize:"0.25em",fontWeight:"bold",color:"white"},Q5=t=>({bg:Qe("gray.100","whiteAlpha.300")(t)}),Z5=t=>({transitionProperty:"common",transitionDuration:"slow",...q5(t)}),J5=Ih(t=>({label:Y5,filledTrack:Z5(t),track:Q5(t)})),eW={xs:Ih({track:{h:"1"}}),sm:Ih({track:{h:"2"}}),md:Ih({track:{h:"3"}}),lg:Ih({track:{h:"4"}})},tW=X5({sizes:eW,baseStyle:J5,defaultProps:{size:"md",colorScheme:"blue"}}),{defineMultiStyleConfig:nW,definePartsStyle:Am}=tn(nB.keys),rW=t=>{var n;const e=(n=Vr(rl.baseStyle,t))==null?void 0:n.control;return{...e,borderRadius:"full",_checked:{...e==null?void 0:e._checked,_before:{content:'""',display:"inline-block",pos:"relative",w:"50%",h:"50%",borderRadius:"50%",bg:"currentColor"}}}},sW=Am(t=>{var e,n;return{label:(e=rl.baseStyle)==null?void 0:e.call(rl,t).label,container:(n=rl.baseStyle)==null?void 0:n.call(rl,t).container,control:rW(t)}}),oW={md:Am({control:{w:"4",h:"4"},label:{fontSize:"md"}}),lg:Am({control:{w:"5",h:"5"},label:{fontSize:"lg"}}),sm:Am({control:{width:"3",height:"3"},label:{fontSize:"sm"}})},iW=nW({baseStyle:sW,sizes:oW,defaultProps:{size:"md",colorScheme:"blue"}}),{defineMultiStyleConfig:aW,definePartsStyle:lW}=tn(rB.keys),um=Ze("select-bg");var S3;const uW={...(S3=Ft.baseStyle)==null?void 0:S3.field,appearance:"none",paddingBottom:"1px",lineHeight:"normal",bg:um.reference,[um.variable]:"colors.white",_dark:{[um.variable]:"colors.gray.700"},"> option, > optgroup":{bg:um.reference}},cW={width:"6",height:"100%",insetEnd:"2",position:"relative",color:"currentColor",fontSize:"xl",_disabled:{opacity:.5}},dW=lW({field:uW,icon:cW}),cm={paddingInlineEnd:"8"};var C3,$3,k3,T3,I3,N3,E3,R3;const hW={lg:{...(C3=Ft.sizes)==null?void 0:C3.lg,field:{...($3=Ft.sizes)==null?void 0:$3.lg.field,...cm}},md:{...(k3=Ft.sizes)==null?void 0:k3.md,field:{...(T3=Ft.sizes)==null?void 0:T3.md.field,...cm}},sm:{...(I3=Ft.sizes)==null?void 0:I3.sm,field:{...(N3=Ft.sizes)==null?void 0:N3.sm.field,...cm}},xs:{...(E3=Ft.sizes)==null?void 0:E3.xs,field:{...(R3=Ft.sizes)==null?void 0:R3.xs.field,...cm},icon:{insetEnd:"1"}}},fW=aW({baseStyle:dW,sizes:hW,variants:Ft.variants,defaultProps:Ft.defaultProps}),v1=Ze("skeleton-start-color"),b1=Ze("skeleton-end-color"),pW={[v1.variable]:"colors.gray.100",[b1.variable]:"colors.gray.400",_dark:{[v1.variable]:"colors.gray.800",[b1.variable]:"colors.gray.600"},background:v1.reference,borderColor:b1.reference,opacity:.7,borderRadius:"sm"},mW={baseStyle:pW},w1=Ze("skip-link-bg"),gW={borderRadius:"md",fontWeight:"semibold",_focusVisible:{boxShadow:"outline",padding:"4",position:"fixed",top:"6",insetStart:"6",[w1.variable]:"colors.white",_dark:{[w1.variable]:"colors.gray.700"},bg:w1.reference}},yW={baseStyle:gW},{defineMultiStyleConfig:xW,definePartsStyle:Gg}=tn(sB.keys),Nu=Ze("slider-thumb-size"),rf=Ze("slider-track-size"),ol=Ze("slider-bg"),vW=t=>{const{orientation:e}=t;return{display:"inline-block",position:"relative",cursor:"pointer",_disabled:{opacity:.6,cursor:"default",pointerEvents:"none"},...Yv({orientation:e,vertical:{h:"100%",px:Yi(Nu.reference).divide(2).toString()},horizontal:{w:"100%",py:Yi(Nu.reference).divide(2).toString()}})}},bW=t=>({...Yv({orientation:t.orientation,horizontal:{h:rf.reference},vertical:{w:rf.reference}}),overflow:"hidden",borderRadius:"sm",[ol.variable]:"colors.gray.200",_dark:{[ol.variable]:"colors.whiteAlpha.200"},_disabled:{[ol.variable]:"colors.gray.300",_dark:{[ol.variable]:"colors.whiteAlpha.300"}},bg:ol.reference}),wW=t=>{const{orientation:e}=t;return{...Yv({orientation:e,vertical:{left:"50%",transform:"translateX(-50%)",_active:{transform:"translateX(-50%) scale(1.15)"}},horizontal:{top:"50%",transform:"translateY(-50%)",_active:{transform:"translateY(-50%) scale(1.15)"}}}),w:Nu.reference,h:Nu.reference,display:"flex",alignItems:"center",justifyContent:"center",position:"absolute",outline:0,zIndex:1,borderRadius:"full",bg:"white",boxShadow:"base",border:"1px solid",borderColor:"transparent",transitionProperty:"transform",transitionDuration:"normal",_focusVisible:{boxShadow:"outline"},_disabled:{bg:"gray.300"}}},SW=t=>{const{colorScheme:e}=t;return{width:"inherit",height:"inherit",[ol.variable]:`colors.${e}.500`,_dark:{[ol.variable]:`colors.${e}.200`},bg:ol.reference}},CW=Gg(t=>({container:vW(t),track:bW(t),thumb:wW(t),filledTrack:SW(t)})),$W=Gg({container:{[Nu.variable]:"sizes.4",[rf.variable]:"sizes.1"}}),kW=Gg({container:{[Nu.variable]:"sizes.3.5",[rf.variable]:"sizes.1"}}),TW=Gg({container:{[Nu.variable]:"sizes.2.5",[rf.variable]:"sizes.0.5"}}),IW={lg:$W,md:kW,sm:TW},NW=xW({baseStyle:CW,sizes:IW,defaultProps:{size:"md",colorScheme:"blue"}}),uu=Ln("spinner-size"),EW={width:[uu.reference],height:[uu.reference]},RW={xs:{[uu.variable]:"sizes.3"},sm:{[uu.variable]:"sizes.4"},md:{[uu.variable]:"sizes.6"},lg:{[uu.variable]:"sizes.8"},xl:{[uu.variable]:"sizes.12"}},_W={baseStyle:EW,sizes:RW,defaultProps:{size:"md"}},{defineMultiStyleConfig:PW,definePartsStyle:oR}=tn(oB.keys),AW={fontWeight:"medium"},DW={opacity:.8,marginBottom:"2"},FW={verticalAlign:"baseline",fontWeight:"semibold"},OW={marginEnd:1,w:"3.5",h:"3.5",verticalAlign:"middle"},LW=oR({container:{},label:AW,helpText:DW,number:FW,icon:OW}),zW={md:oR({label:{fontSize:"sm"},helpText:{fontSize:"sm"},number:{fontSize:"2xl"}})},BW=PW({baseStyle:LW,sizes:zW,defaultProps:{size:"md"}}),{defineMultiStyleConfig:MW,definePartsStyle:Nh}=tn(["stepper","step","title","description","indicator","separator","icon","number"]),Zi=Ze("stepper-indicator-size"),Lc=Ze("stepper-icon-size"),zc=Ze("stepper-title-font-size"),Eh=Ze("stepper-description-font-size"),gh=Ze("stepper-accent-color"),VW=Nh(({colorScheme:t})=>({stepper:{display:"flex",justifyContent:"space-between",gap:"4","&[data-orientation=vertical]":{flexDirection:"column",alignItems:"flex-start"},"&[data-orientation=horizontal]":{flexDirection:"row",alignItems:"center"},[gh.variable]:`colors.${t}.500`,_dark:{[gh.variable]:`colors.${t}.200`}},title:{fontSize:zc.reference,fontWeight:"medium"},description:{fontSize:Eh.reference,color:"chakra-subtle-text"},number:{fontSize:zc.reference},step:{flexShrink:0,position:"relative",display:"flex",gap:"2","&[data-orientation=horizontal]":{alignItems:"center"},flex:"1","&:last-of-type:not([data-stretch])":{flex:"initial"}},icon:{flexShrink:0,width:Lc.reference,height:Lc.reference},indicator:{flexShrink:0,borderRadius:"full",width:Zi.reference,height:Zi.reference,display:"flex",justifyContent:"center",alignItems:"center","&[data-status=active]":{borderWidth:"2px",borderColor:gh.reference},"&[data-status=complete]":{bg:gh.reference,color:"chakra-inverse-text"},"&[data-status=incomplete]":{borderWidth:"2px"}},separator:{bg:"chakra-border-color",flex:"1","&[data-status=complete]":{bg:gh.reference},"&[data-orientation=horizontal]":{width:"100%",height:"2px",marginStart:"2"},"&[data-orientation=vertical]":{width:"2px",position:"absolute",height:"100%",maxHeight:`calc(100% - ${Zi.reference} - 8px)`,top:`calc(${Zi.reference} + 4px)`,insetStart:`calc(${Zi.reference} / 2 - 1px)`}}})),WW=MW({baseStyle:VW,sizes:{xs:Nh({stepper:{[Zi.variable]:"sizes.4",[Lc.variable]:"sizes.3",[zc.variable]:"fontSizes.xs",[Eh.variable]:"fontSizes.xs"}}),sm:Nh({stepper:{[Zi.variable]:"sizes.6",[Lc.variable]:"sizes.4",[zc.variable]:"fontSizes.sm",[Eh.variable]:"fontSizes.xs"}}),md:Nh({stepper:{[Zi.variable]:"sizes.8",[Lc.variable]:"sizes.5",[zc.variable]:"fontSizes.md",[Eh.variable]:"fontSizes.sm"}}),lg:Nh({stepper:{[Zi.variable]:"sizes.10",[Lc.variable]:"sizes.6",[zc.variable]:"fontSizes.lg",[Eh.variable]:"fontSizes.md"}})},defaultProps:{size:"md",colorScheme:"blue"}}),{defineMultiStyleConfig:UW,definePartsStyle:Dm}=tn(iB.keys),Gh=Ln("switch-track-width"),Su=Ln("switch-track-height"),S1=Ln("switch-track-diff"),jW=Qi.subtract(Gh,Su),Tx=Ln("switch-thumb-x"),yh=Ln("switch-bg"),GW=t=>{const{colorScheme:e}=t;return{borderRadius:"full",p:"0.5",width:[Gh.reference],height:[Su.reference],transitionProperty:"common",transitionDuration:"fast",[yh.variable]:"colors.gray.300",_dark:{[yh.variable]:"colors.whiteAlpha.400"},_focusVisible:{boxShadow:"outline"},_disabled:{opacity:.4,cursor:"not-allowed"},_checked:{[yh.variable]:`colors.${e}.500`,_dark:{[yh.variable]:`colors.${e}.200`}},bg:yh.reference}},HW={bg:"white",transitionProperty:"transform",transitionDuration:"normal",borderRadius:"inherit",width:[Su.reference],height:[Su.reference],_checked:{transform:`translateX(${Tx.reference})`}},KW=Dm(t=>({container:{[S1.variable]:jW,[Tx.variable]:S1.reference,_rtl:{[Tx.variable]:Qi(S1).negate().toString()}},track:GW(t),thumb:HW})),XW={sm:Dm({container:{[Gh.variable]:"1.375rem",[Su.variable]:"sizes.3"}}),md:Dm({container:{[Gh.variable]:"1.875rem",[Su.variable]:"sizes.4"}}),lg:Dm({container:{[Gh.variable]:"2.875rem",[Su.variable]:"sizes.6"}})},qW=UW({baseStyle:KW,sizes:XW,defaultProps:{size:"md",colorScheme:"blue"}}),{defineMultiStyleConfig:YW,definePartsStyle:Xc}=tn(aB.keys),QW=Xc({table:{fontVariantNumeric:"lining-nums tabular-nums",borderCollapse:"collapse",width:"full"},th:{fontFamily:"heading",fontWeight:"bold",textTransform:"uppercase",letterSpacing:"wider",textAlign:"start"},td:{textAlign:"start"},caption:{mt:4,fontFamily:"heading",textAlign:"center",fontWeight:"medium"}}),ig={"&[data-is-numeric=true]":{textAlign:"end"}},ZW=Xc(t=>{const{colorScheme:e}=t;return{th:{color:Qe("gray.600","gray.400")(t),borderBottom:"1px",borderColor:Qe(`${e}.100`,`${e}.700`)(t),...ig},td:{borderBottom:"1px",borderColor:Qe(`${e}.100`,`${e}.700`)(t),...ig},caption:{color:Qe("gray.600","gray.100")(t)},tfoot:{tr:{"&:last-of-type":{th:{borderBottomWidth:0}}}}}}),JW=Xc(t=>{const{colorScheme:e}=t;return{th:{color:Qe("gray.600","gray.400")(t),borderBottom:"1px",borderColor:Qe(`${e}.100`,`${e}.700`)(t),...ig},td:{borderBottom:"1px",borderColor:Qe(`${e}.100`,`${e}.700`)(t),...ig},caption:{color:Qe("gray.600","gray.100")(t)},tbody:{tr:{"&:nth-of-type(odd)":{"th, td":{borderBottomWidth:"1px",borderColor:Qe(`${e}.100`,`${e}.700`)(t)},td:{background:Qe(`${e}.100`,`${e}.700`)(t)}}}},tfoot:{tr:{"&:last-of-type":{th:{borderBottomWidth:0}}}}}}),e6={simple:ZW,striped:JW,unstyled:{}},t6={sm:Xc({th:{px:"4",py:"1",lineHeight:"4",fontSize:"xs"},td:{px:"4",py:"2",fontSize:"sm",lineHeight:"4"},caption:{px:"4",py:"2",fontSize:"xs"}}),md:Xc({th:{px:"6",py:"3",lineHeight:"4",fontSize:"xs"},td:{px:"6",py:"4",lineHeight:"5"},caption:{px:"6",py:"2",fontSize:"sm"}}),lg:Xc({th:{px:"8",py:"4",lineHeight:"5",fontSize:"sm"},td:{px:"8",py:"5",lineHeight:"6"},caption:{px:"6",py:"2",fontSize:"md"}})},n6=YW({baseStyle:QW,variants:e6,sizes:t6,defaultProps:{variant:"simple",size:"md",colorScheme:"gray"}}),ds=Ze("tabs-color"),Fo=Ze("tabs-bg"),dm=Ze("tabs-border-color"),{defineMultiStyleConfig:r6,definePartsStyle:hi}=tn(lB.keys),s6=t=>{const{orientation:e}=t;return{display:e==="vertical"?"flex":"block"}},o6=t=>{const{isFitted:e}=t;return{flex:e?1:void 0,transitionProperty:"common",transitionDuration:"normal",_focusVisible:{zIndex:1,boxShadow:"outline"},_disabled:{cursor:"not-allowed",opacity:.4}}},i6=t=>{const{align:e="start",orientation:n}=t;return{justifyContent:{end:"flex-end",center:"center",start:"flex-start"}[e],flexDirection:n==="vertical"?"column":"row"}},a6={p:4},l6=hi(t=>({root:s6(t),tab:o6(t),tablist:i6(t),tabpanel:a6})),u6={sm:hi({tab:{py:1,px:4,fontSize:"sm"}}),md:hi({tab:{fontSize:"md",py:2,px:4}}),lg:hi({tab:{fontSize:"lg",py:3,px:4}})},c6=hi(t=>{const{colorScheme:e,orientation:n}=t,r=n==="vertical",s=r?"borderStart":"borderBottom",o=r?"marginStart":"marginBottom";return{tablist:{[s]:"2px solid",borderColor:"inherit"},tab:{[s]:"2px solid",borderColor:"transparent",[o]:"-2px",_selected:{[ds.variable]:`colors.${e}.600`,_dark:{[ds.variable]:`colors.${e}.300`},borderColor:"currentColor"},_active:{[Fo.variable]:"colors.gray.200",_dark:{[Fo.variable]:"colors.whiteAlpha.300"}},_disabled:{_active:{bg:"none"}},color:ds.reference,bg:Fo.reference}}}),d6=hi(t=>{const{colorScheme:e}=t;return{tab:{borderTopRadius:"md",border:"1px solid",borderColor:"transparent",mb:"-1px",[dm.variable]:"transparent",_selected:{[ds.variable]:`colors.${e}.600`,[dm.variable]:"colors.white",_dark:{[ds.variable]:`colors.${e}.300`,[dm.variable]:"colors.gray.800"},borderColor:"inherit",borderBottomColor:dm.reference},color:ds.reference},tablist:{mb:"-1px",borderBottom:"1px solid",borderColor:"inherit"}}}),h6=hi(t=>{const{colorScheme:e}=t;return{tab:{border:"1px solid",borderColor:"inherit",[Fo.variable]:"colors.gray.50",_dark:{[Fo.variable]:"colors.whiteAlpha.50"},mb:"-1px",_notLast:{marginEnd:"-1px"},_selected:{[Fo.variable]:"colors.white",[ds.variable]:`colors.${e}.600`,_dark:{[Fo.variable]:"colors.gray.800",[ds.variable]:`colors.${e}.300`},borderColor:"inherit",borderTopColor:"currentColor",borderBottomColor:"transparent"},color:ds.reference,bg:Fo.reference},tablist:{mb:"-1px",borderBottom:"1px solid",borderColor:"inherit"}}}),f6=hi(t=>{const{colorScheme:e,theme:n}=t;return{tab:{borderRadius:"full",fontWeight:"semibold",color:"gray.600",_selected:{color:zr(n,`${e}.700`),bg:zr(n,`${e}.100`)}}}}),p6=hi(t=>{const{colorScheme:e}=t;return{tab:{borderRadius:"full",fontWeight:"semibold",[ds.variable]:"colors.gray.600",_dark:{[ds.variable]:"inherit"},_selected:{[ds.variable]:"colors.white",[Fo.variable]:`colors.${e}.600`,_dark:{[ds.variable]:"colors.gray.800",[Fo.variable]:`colors.${e}.300`}},color:ds.reference,bg:Fo.reference}}}),m6=hi({}),g6={line:c6,enclosed:d6,"enclosed-colored":h6,"soft-rounded":f6,"solid-rounded":p6,unstyled:m6},y6=r6({baseStyle:l6,sizes:u6,variants:g6,defaultProps:{size:"md",variant:"line",colorScheme:"blue"}}),{defineMultiStyleConfig:x6,definePartsStyle:Cu}=tn(uB.keys),bT=Ze("tag-bg"),wT=Ze("tag-color"),C1=Ze("tag-shadow"),Fm=Ze("tag-min-height"),Om=Ze("tag-min-width"),Lm=Ze("tag-font-size"),zm=Ze("tag-padding-inline"),v6={fontWeight:"medium",lineHeight:1.2,outline:0,[wT.variable]:$n.color.reference,[bT.variable]:$n.bg.reference,[C1.variable]:$n.shadow.reference,color:wT.reference,bg:bT.reference,boxShadow:C1.reference,borderRadius:"md",minH:Fm.reference,minW:Om.reference,fontSize:Lm.reference,px:zm.reference,_focusVisible:{[C1.variable]:"shadows.outline"}},b6={lineHeight:1.2,overflow:"visible"},w6={fontSize:"lg",w:"5",h:"5",transitionProperty:"common",transitionDuration:"normal",borderRadius:"full",marginStart:"1.5",marginEnd:"-1",opacity:.5,_disabled:{opacity:.4},_focusVisible:{boxShadow:"outline",bg:"rgba(0, 0, 0, 0.14)"},_hover:{opacity:.8},_active:{opacity:1}},S6=Cu({container:v6,label:b6,closeButton:w6}),C6={sm:Cu({container:{[Fm.variable]:"sizes.5",[Om.variable]:"sizes.5",[Lm.variable]:"fontSizes.xs",[zm.variable]:"space.2"},closeButton:{marginEnd:"-2px",marginStart:"0.35rem"}}),md:Cu({container:{[Fm.variable]:"sizes.6",[Om.variable]:"sizes.6",[Lm.variable]:"fontSizes.sm",[zm.variable]:"space.2"}}),lg:Cu({container:{[Fm.variable]:"sizes.8",[Om.variable]:"sizes.8",[Lm.variable]:"fontSizes.md",[zm.variable]:"space.3"}})},$6={subtle:Cu(t=>{var e;return{container:(e=Wh.variants)==null?void 0:e.subtle(t)}}),solid:Cu(t=>{var e;return{container:(e=Wh.variants)==null?void 0:e.solid(t)}}),outline:Cu(t=>{var e;return{container:(e=Wh.variants)==null?void 0:e.outline(t)}})},k6=x6({variants:$6,baseStyle:S6,sizes:C6,defaultProps:{size:"md",variant:"subtle",colorScheme:"gray"}});var _3;const T6={...(_3=Ft.baseStyle)==null?void 0:_3.field,paddingY:"2",minHeight:"20",lineHeight:"short",verticalAlign:"top"};var P3;const I6={outline:t=>{var e;return((e=Ft.variants)==null?void 0:e.outline(t).field)??{}},flushed:t=>{var e;return((e=Ft.variants)==null?void 0:e.flushed(t).field)??{}},filled:t=>{var e;return((e=Ft.variants)==null?void 0:e.filled(t).field)??{}},unstyled:((P3=Ft.variants)==null?void 0:P3.unstyled.field)??{}};var A3,D3,F3,O3;const N6={xs:((A3=Ft.sizes)==null?void 0:A3.xs.field)??{},sm:((D3=Ft.sizes)==null?void 0:D3.sm.field)??{},md:((F3=Ft.sizes)==null?void 0:F3.md.field)??{},lg:((O3=Ft.sizes)==null?void 0:O3.lg.field)??{}},E6={baseStyle:T6,sizes:N6,variants:I6,defaultProps:{size:"md",variant:"outline"}},hm=Ln("tooltip-bg"),$1=Ln("tooltip-fg"),R6=Ln("popper-arrow-bg"),_6={bg:hm.reference,color:$1.reference,[hm.variable]:"colors.gray.700",[$1.variable]:"colors.whiteAlpha.900",_dark:{[hm.variable]:"colors.gray.300",[$1.variable]:"colors.gray.900"},[R6.variable]:hm.reference,px:"2",py:"0.5",borderRadius:"sm",fontWeight:"medium",fontSize:"sm",boxShadow:"md",maxW:"xs",zIndex:"tooltip"},P6={baseStyle:_6},A6={Accordion:xB,Alert:tM,Avatar:hM,Badge:Wh,Breadcrumb:SM,Button:_M,Checkbox:rl,CloseButton:HM,Code:YM,Container:ZM,Divider:rV,Drawer:pV,Editable:wV,Form:IV,FormError:AV,FormLabel:FV,Heading:zV,Input:Ft,Kbd:XV,Link:YV,List:t5,Menu:h5,Modal:C5,NumberInput:P5,PinInput:O5,Popover:K5,Progress:tW,Radio:iW,Select:fW,Skeleton:mW,SkipLink:yW,Slider:NW,Spinner:_W,Stat:BW,Switch:qW,Table:n6,Tabs:y6,Tag:k6,Textarea:E6,Tooltip:P6,Card:OM,Stepper:WW},D6={none:0,"1px":"1px solid","2px":"2px solid","4px":"4px solid","8px":"8px solid"},F6={base:"0em",sm:"30em",md:"48em",lg:"62em",xl:"80em","2xl":"96em"},O6={transparent:"transparent",current:"currentColor",black:"#000000",white:"#FFFFFF",whiteAlpha:{50:"rgba(255, 255, 255, 0.04)",100:"rgba(255, 255, 255, 0.06)",200:"rgba(255, 255, 255, 0.08)",300:"rgba(255, 255, 255, 0.16)",400:"rgba(255, 255, 255, 0.24)",500:"rgba(255, 255, 255, 0.36)",600:"rgba(255, 255, 255, 0.48)",700:"rgba(255, 255, 255, 0.64)",800:"rgba(255, 255, 255, 0.80)",900:"rgba(255, 255, 255, 0.92)"},blackAlpha:{50:"rgba(0, 0, 0, 0.04)",100:"rgba(0, 0, 0, 0.06)",200:"rgba(0, 0, 0, 0.08)",300:"rgba(0, 0, 0, 0.16)",400:"rgba(0, 0, 0, 0.24)",500:"rgba(0, 0, 0, 0.36)",600:"rgba(0, 0, 0, 0.48)",700:"rgba(0, 0, 0, 0.64)",800:"rgba(0, 0, 0, 0.80)",900:"rgba(0, 0, 0, 0.92)"},gray:{50:"#F7FAFC",100:"#EDF2F7",200:"#E2E8F0",300:"#CBD5E0",400:"#A0AEC0",500:"#718096",600:"#4A5568",700:"#2D3748",800:"#1A202C",900:"#171923"},red:{50:"#FFF5F5",100:"#FED7D7",200:"#FEB2B2",300:"#FC8181",400:"#F56565",500:"#E53E3E",600:"#C53030",700:"#9B2C2C",800:"#822727",900:"#63171B"},orange:{50:"#FFFAF0",100:"#FEEBC8",200:"#FBD38D",300:"#F6AD55",400:"#ED8936",500:"#DD6B20",600:"#C05621",700:"#9C4221",800:"#7B341E",900:"#652B19"},yellow:{50:"#FFFFF0",100:"#FEFCBF",200:"#FAF089",300:"#F6E05E",400:"#ECC94B",500:"#D69E2E",600:"#B7791F",700:"#975A16",800:"#744210",900:"#5F370E"},green:{50:"#F0FFF4",100:"#C6F6D5",200:"#9AE6B4",300:"#68D391",400:"#48BB78",500:"#38A169",600:"#2F855A",700:"#276749",800:"#22543D",900:"#1C4532"},teal:{50:"#E6FFFA",100:"#B2F5EA",200:"#81E6D9",300:"#4FD1C5",400:"#38B2AC",500:"#319795",600:"#2C7A7B",700:"#285E61",800:"#234E52",900:"#1D4044"},blue:{50:"#ebf8ff",100:"#bee3f8",200:"#90cdf4",300:"#63b3ed",400:"#4299e1",500:"#3182ce",600:"#2b6cb0",700:"#2c5282",800:"#2a4365",900:"#1A365D"},cyan:{50:"#EDFDFD",100:"#C4F1F9",200:"#9DECF9",300:"#76E4F7",400:"#0BC5EA",500:"#00B5D8",600:"#00A3C4",700:"#0987A0",800:"#086F83",900:"#065666"},purple:{50:"#FAF5FF",100:"#E9D8FD",200:"#D6BCFA",300:"#B794F4",400:"#9F7AEA",500:"#805AD5",600:"#6B46C1",700:"#553C9A",800:"#44337A",900:"#322659"},pink:{50:"#FFF5F7",100:"#FED7E2",200:"#FBB6CE",300:"#F687B3",400:"#ED64A6",500:"#D53F8C",600:"#B83280",700:"#97266D",800:"#702459",900:"#521B41"}},L6={none:"0",sm:"0.125rem",base:"0.25rem",md:"0.375rem",lg:"0.5rem",xl:"0.75rem","2xl":"1rem","3xl":"1.5rem",full:"9999px"},z6={xs:"0 0 0 1px rgba(0, 0, 0, 0.05)",sm:"0 1px 2px 0 rgba(0, 0, 0, 0.05)",base:"0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",md:"0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",lg:"0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",xl:"0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)","2xl":"0 25px 50px -12px rgba(0, 0, 0, 0.25)",outline:"0 0 0 3px rgba(66, 153, 225, 0.6)",inner:"inset 0 2px 4px 0 rgba(0,0,0,0.06)",none:"none","dark-lg":"rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px"},B6={common:"background-color, border-color, color, fill, stroke, opacity, box-shadow, transform",colors:"background-color, border-color, color, fill, stroke",dimensions:"width, height",position:"left, right, top, bottom",background:"background-color, background-image, background-position"},M6={"ease-in":"cubic-bezier(0.4, 0, 1, 1)","ease-out":"cubic-bezier(0, 0, 0.2, 1)","ease-in-out":"cubic-bezier(0.4, 0, 0.2, 1)"},V6={"ultra-fast":"50ms",faster:"100ms",fast:"150ms",normal:"200ms",slow:"300ms",slower:"400ms","ultra-slow":"500ms"},W6={property:B6,easing:M6,duration:V6},U6={hide:-1,auto:"auto",base:0,docked:10,dropdown:1e3,sticky:1100,banner:1200,overlay:1300,modal:1400,popover:1500,skipLink:1600,toast:1700,tooltip:1800},j6={none:0,sm:"4px",base:"8px",md:"12px",lg:"16px",xl:"24px","2xl":"40px","3xl":"64px"},G6={breakpoints:F6,zIndices:U6,radii:L6,blur:j6,colors:O6,...nR,sizes:Y3,shadows:z6,space:q3,borders:D6,transition:W6},H6={colors:{"chakra-body-text":{_light:"gray.800",_dark:"whiteAlpha.900"},"chakra-body-bg":{_light:"white",_dark:"gray.800"},"chakra-border-color":{_light:"gray.200",_dark:"whiteAlpha.300"},"chakra-inverse-text":{_light:"white",_dark:"gray.800"},"chakra-subtle-bg":{_light:"gray.100",_dark:"gray.700"},"chakra-subtle-text":{_light:"gray.600",_dark:"gray.400"},"chakra-placeholder-color":{_light:"gray.500",_dark:"whiteAlpha.400"}}},K6={global:{body:{fontFamily:"body",color:"chakra-body-text",bg:"chakra-body-bg",transitionProperty:"background-color",transitionDuration:"normal",lineHeight:"base"},"*::placeholder":{color:"chakra-placeholder-color"},"*, *::before, &::after":{borderColor:"chakra-border-color"}}},X6=["borders","breakpoints","colors","components","config","direction","fonts","fontSizes","fontWeights","letterSpacings","lineHeights","radii","shadows","sizes","space","styles","transition","zIndices"];function q6(t){return Mr(t)?X6.every(e=>Object.prototype.hasOwnProperty.call(t,e)):!1}const Y6="ltr",Q6={useSystemColorMode:!1,initialColorMode:"light",cssVarPrefix:"chakra"},iR={semanticTokens:H6,direction:Y6,...G6,components:A6,styles:K6,config:Q6};function Z6(t){if(t.sheet)return t.sheet;for(var e=0;e<document.styleSheets.length;e++)if(document.styleSheets[e].ownerNode===t)return document.styleSheets[e]}function J6(t){var e=document.createElement("style");return e.setAttribute("data-emotion",t.key),t.nonce!==void 0&&e.setAttribute("nonce",t.nonce),e.appendChild(document.createTextNode("")),e.setAttribute("data-s",""),e}var eU=function(){function t(n){var r=this;this._insertTag=function(s){var o;r.tags.length===0?r.insertionPoint?o=r.insertionPoint.nextSibling:r.prepend?o=r.container.firstChild:o=r.before:o=r.tags[r.tags.length-1].nextSibling,r.container.insertBefore(s,o),r.tags.push(s)},this.isSpeedy=n.speedy===void 0?!0:n.speedy,this.tags=[],this.ctr=0,this.nonce=n.nonce,this.key=n.key,this.container=n.container,this.prepend=n.prepend,this.insertionPoint=n.insertionPoint,this.before=null}var e=t.prototype;return e.hydrate=function(r){r.forEach(this._insertTag)},e.insert=function(r){this.ctr%(this.isSpeedy?65e3:1)===0&&this._insertTag(J6(this));var s=this.tags[this.tags.length-1];if(this.isSpeedy){var o=Z6(s);try{o.insertRule(r,o.cssRules.length)}catch{}}else s.appendChild(document.createTextNode(r));this.ctr++},e.flush=function(){this.tags.forEach(function(r){var s;return(s=r.parentNode)==null?void 0:s.removeChild(r)}),this.tags=[],this.ctr=0},t}(),br="-ms-",ag="-moz-",At="-webkit-",aR="comm",eb="rule",tb="decl",tU="@import",lR="@keyframes",nU="@layer",rU=Math.abs,Hg=String.fromCharCode,sU=Object.assign;function oU(t,e){return ar(t,0)^45?(((e<<2^ar(t,0))<<2^ar(t,1))<<2^ar(t,2))<<2^ar(t,3):0}function uR(t){return t.trim()}function iU(t,e){return(t=e.exec(t))?t[0]:t}function Dt(t,e,n){return t.replace(e,n)}function Ix(t,e){return t.indexOf(e)}function ar(t,e){return t.charCodeAt(e)|0}function sf(t,e,n){return t.slice(e,n)}function ai(t){return t.length}function nb(t){return t.length}function fm(t,e){return e.push(t),t}function aU(t,e){return t.map(e).join("")}var Kg=1,nd=1,cR=0,fs=0,Nn=0,gd="";function Xg(t,e,n,r,s,o,i){return{value:t,root:e,parent:n,type:r,props:s,children:o,line:Kg,column:nd,length:i,return:""}}function xh(t,e){return sU(Xg("",null,null,"",null,null,0),t,{length:-t.length},e)}function lU(){return Nn}function uU(){return Nn=fs>0?ar(gd,--fs):0,nd--,Nn===10&&(nd=1,Kg--),Nn}function Ps(){return Nn=fs<cR?ar(gd,fs++):0,nd++,Nn===10&&(nd=1,Kg++),Nn}function fi(){return ar(gd,fs)}function Bm(){return fs}function Of(t,e){return sf(gd,t,e)}function of(t){switch(t){case 0:case 9:case 10:case 13:case 32:return 5;case 33:case 43:case 44:case 47:case 62:case 64:case 126:case 59:case 123:case 125:return 4;case 58:return 3;case 34:case 39:case 40:case 91:return 2;case 41:case 93:return 1}return 0}function dR(t){return Kg=nd=1,cR=ai(gd=t),fs=0,[]}function hR(t){return gd="",t}function Mm(t){return uR(Of(fs-1,Nx(t===91?t+2:t===40?t+1:t)))}function cU(t){for(;(Nn=fi())&&Nn<33;)Ps();return of(t)>2||of(Nn)>3?"":" "}function dU(t,e){for(;--e&&Ps()&&!(Nn<48||Nn>102||Nn>57&&Nn<65||Nn>70&&Nn<97););return Of(t,Bm()+(e<6&&fi()==32&&Ps()==32))}function Nx(t){for(;Ps();)switch(Nn){case t:return fs;case 34:case 39:t!==34&&t!==39&&Nx(Nn);break;case 40:t===41&&Nx(t);break;case 92:Ps();break}return fs}function hU(t,e){for(;Ps()&&t+Nn!==57;)if(t+Nn===84&&fi()===47)break;return"/*"+Of(e,fs-1)+"*"+Hg(t===47?t:Ps())}function fU(t){for(;!of(fi());)Ps();return Of(t,fs)}function pU(t){return hR(Vm("",null,null,null,[""],t=dR(t),0,[0],t))}function Vm(t,e,n,r,s,o,i,a,l){for(var c=0,d=0,f=i,p=0,g=0,y=0,x=1,w=1,S=1,$=0,I="",R=s,_=o,F=r,O=I;w;)switch(y=$,$=Ps()){case 40:if(y!=108&&ar(O,f-1)==58){Ix(O+=Dt(Mm($),"&","&\f"),"&\f")!=-1&&(S=-1);break}case 34:case 39:case 91:O+=Mm($);break;case 9:case 10:case 13:case 32:O+=cU(y);break;case 92:O+=dU(Bm()-1,7);continue;case 47:switch(fi()){case 42:case 47:fm(mU(hU(Ps(),Bm()),e,n),l);break;default:O+="/"}break;case 123*x:a[c++]=ai(O)*S;case 125*x:case 59:case 0:switch($){case 0:case 125:w=0;case 59+d:S==-1&&(O=Dt(O,/\f/g,"")),g>0&&ai(O)-f&&fm(g>32?CT(O+";",r,n,f-1):CT(Dt(O," ","")+";",r,n,f-2),l);break;case 59:O+=";";default:if(fm(F=ST(O,e,n,c,d,s,a,I,R=[],_=[],f),o),$===123)if(d===0)Vm(O,e,F,F,R,o,f,a,_);else switch(p===99&&ar(O,3)===110?100:p){case 100:case 108:case 109:case 115:Vm(t,F,F,r&&fm(ST(t,F,F,0,0,s,a,I,s,R=[],f),_),s,_,f,a,r?R:_);break;default:Vm(O,F,F,F,[""],_,0,a,_)}}c=d=g=0,x=S=1,I=O="",f=i;break;case 58:f=1+ai(O),g=y;default:if(x<1){if($==123)--x;else if($==125&&x++==0&&uU()==125)continue}switch(O+=Hg($),$*x){case 38:S=d>0?1:(O+="\f",-1);break;case 44:a[c++]=(ai(O)-1)*S,S=1;break;case 64:fi()===45&&(O+=Mm(Ps())),p=fi(),d=f=ai(I=O+=fU(Bm())),$++;break;case 45:y===45&&ai(O)==2&&(x=0)}}return o}function ST(t,e,n,r,s,o,i,a,l,c,d){for(var f=s-1,p=s===0?o:[""],g=nb(p),y=0,x=0,w=0;y<r;++y)for(var S=0,$=sf(t,f+1,f=rU(x=i[y])),I=t;S<g;++S)(I=uR(x>0?p[S]+" "+$:Dt($,/&\f/g,p[S])))&&(l[w++]=I);return Xg(t,e,n,s===0?eb:a,l,c,d)}function mU(t,e,n){return Xg(t,e,n,aR,Hg(lU()),sf(t,2,-2),0)}function CT(t,e,n,r){return Xg(t,e,n,tb,sf(t,0,r),sf(t,r+1,-1),r)}function qc(t,e){for(var n="",r=nb(t),s=0;s<r;s++)n+=e(t[s],s,t,e)||"";return n}function gU(t,e,n,r){switch(t.type){case nU:if(t.children.length)break;case tU:case tb:return t.return=t.return||t.value;case aR:return"";case lR:return t.return=t.value+"{"+qc(t.children,r)+"}";case eb:t.value=t.props.join(",")}return ai(n=qc(t.children,r))?t.return=t.value+"{"+n+"}":""}function yU(t){var e=nb(t);return function(n,r,s,o){for(var i="",a=0;a<e;a++)i+=t[a](n,r,s,o)||"";return i}}function xU(t){return function(e){e.root||(e=e.return)&&t(e)}}var $T=function(e){var n=new WeakMap;return function(r){if(n.has(r))return n.get(r);var s=e(r);return n.set(r,s),s}};function fR(t){var e=Object.create(null);return function(n){return e[n]===void 0&&(e[n]=t(n)),e[n]}}var vU=function(e,n,r){for(var s=0,o=0;s=o,o=fi(),s===38&&o===12&&(n[r]=1),!of(o);)Ps();return Of(e,fs)},bU=function(e,n){var r=-1,s=44;do switch(of(s)){case 0:s===38&&fi()===12&&(n[r]=1),e[r]+=vU(fs-1,n,r);break;case 2:e[r]+=Mm(s);break;case 4:if(s===44){e[++r]=fi()===58?"&\f":"",n[r]=e[r].length;break}default:e[r]+=Hg(s)}while(s=Ps());return e},wU=function(e,n){return hR(bU(dR(e),n))},kT=new WeakMap,SU=function(e){if(!(e.type!=="rule"||!e.parent||e.length<1)){for(var n=e.value,r=e.parent,s=e.column===r.column&&e.line===r.line;r.type!=="rule";)if(r=r.parent,!r)return;if(!(e.props.length===1&&n.charCodeAt(0)!==58&&!kT.get(r))&&!s){kT.set(e,!0);for(var o=[],i=wU(n,o),a=r.props,l=0,c=0;l<i.length;l++)for(var d=0;d<a.length;d++,c++)e.props[c]=o[l]?i[l].replace(/&\f/g,a[d]):a[d]+" "+i[l]}}},CU=function(e){if(e.type==="decl"){var n=e.value;n.charCodeAt(0)===108&&n.charCodeAt(2)===98&&(e.return="",e.value="")}};function pR(t,e){switch(oU(t,e)){case 5103:return At+"print-"+t+t;case 5737:case 4201:case 3177:case 3433:case 1641:case 4457:case 2921:case 5572:case 6356:case 5844:case 3191:case 6645:case 3005:case 6391:case 5879:case 5623:case 6135:case 4599:case 4855:case 4215:case 6389:case 5109:case 5365:case 5621:case 3829:return At+t+t;case 5349:case 4246:case 4810:case 6968:case 2756:return At+t+ag+t+br+t+t;case 6828:case 4268:return At+t+br+t+t;case 6165:return At+t+br+"flex-"+t+t;case 5187:return At+t+Dt(t,/(\w+).+(:[^]+)/,At+"box-$1$2"+br+"flex-$1$2")+t;case 5443:return At+t+br+"flex-item-"+Dt(t,/flex-|-self/,"")+t;case 4675:return At+t+br+"flex-line-pack"+Dt(t,/align-content|flex-|-self/,"")+t;case 5548:return At+t+br+Dt(t,"shrink","negative")+t;case 5292:return At+t+br+Dt(t,"basis","preferred-size")+t;case 6060:return At+"box-"+Dt(t,"-grow","")+At+t+br+Dt(t,"grow","positive")+t;case 4554:return At+Dt(t,/([^-])(transform)/g,"$1"+At+"$2")+t;case 6187:return Dt(Dt(Dt(t,/(zoom-|grab)/,At+"$1"),/(image-set)/,At+"$1"),t,"")+t;case 5495:case 3959:return Dt(t,/(image-set\([^]*)/,At+"$1$`$1");case 4968:return Dt(Dt(t,/(.+:)(flex-)?(.*)/,At+"box-pack:$3"+br+"flex-pack:$3"),/s.+-b[^;]+/,"justify")+At+t+t;case 4095:case 3583:case 4068:case 2532:return Dt(t,/(.+)-inline(.+)/,At+"$1$2")+t;case 8116:case 7059:case 5753:case 5535:case 5445:case 5701:case 4933:case 4677:case 5533:case 5789:case 5021:case 4765:if(ai(t)-1-e>6)switch(ar(t,e+1)){case 109:if(ar(t,e+4)!==45)break;case 102:return Dt(t,/(.+:)(.+)-([^]+)/,"$1"+At+"$2-$3$1"+ag+(ar(t,e+3)==108?"$3":"$2-$3"))+t;case 115:return~Ix(t,"stretch")?pR(Dt(t,"stretch","fill-available"),e)+t:t}break;case 4949:if(ar(t,e+1)!==115)break;case 6444:switch(ar(t,ai(t)-3-(~Ix(t,"!important")&&10))){case 107:return Dt(t,":",":"+At)+t;case 101:return Dt(t,/(.+:)([^;!]+)(;|!.+)?/,"$1"+At+(ar(t,14)===45?"inline-":"")+"box$3$1"+At+"$2$3$1"+br+"$2box$3")+t}break;case 5936:switch(ar(t,e+11)){case 114:return At+t+br+Dt(t,/[svh]\w+-[tblr]{2}/,"tb")+t;case 108:return At+t+br+Dt(t,/[svh]\w+-[tblr]{2}/,"tb-rl")+t;case 45:return At+t+br+Dt(t,/[svh]\w+-[tblr]{2}/,"lr")+t}return At+t+br+t+t}return t}var $U=function(e,n,r,s){if(e.length>-1&&!e.return)switch(e.type){case tb:e.return=pR(e.value,e.length);break;case lR:return qc([xh(e,{value:Dt(e.value,"@","@"+At)})],s);case eb:if(e.length)return aU(e.props,function(o){switch(iU(o,/(::plac\w+|:read-\w+)/)){case":read-only":case":read-write":return qc([xh(e,{props:[Dt(o,/:(read-\w+)/,":"+ag+"$1")]})],s);case"::placeholder":return qc([xh(e,{props:[Dt(o,/:(plac\w+)/,":"+At+"input-$1")]}),xh(e,{props:[Dt(o,/:(plac\w+)/,":"+ag+"$1")]}),xh(e,{props:[Dt(o,/:(plac\w+)/,br+"input-$1")]})],s)}return""})}},kU=[$U],TU=function(e){var n=e.key;if(n==="css"){var r=document.querySelectorAll("style[data-emotion]:not([data-s])");Array.prototype.forEach.call(r,function(x){var w=x.getAttribute("data-emotion");w.indexOf(" ")!==-1&&(document.head.appendChild(x),x.setAttribute("data-s",""))})}var s=e.stylisPlugins||kU,o={},i,a=[];i=e.container||document.head,Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="'+n+' "]'),function(x){for(var w=x.getAttribute("data-emotion").split(" "),S=1;S<w.length;S++)o[w[S]]=!0;a.push(x)});var l,c=[SU,CU];{var d,f=[gU,xU(function(x){d.insert(x)})],p=yU(c.concat(s,f)),g=function(w){return qc(pU(w),p)};l=function(w,S,$,I){d=$,g(w?w+"{"+S.styles+"}":S.styles),I&&(y.inserted[S.name]=!0)}}var y={key:n,sheet:new eU({key:n,container:i,nonce:e.nonce,speedy:e.speedy,prepend:e.prepend,insertionPoint:e.insertionPoint}),nonce:e.nonce,inserted:o,registered:{},insert:l};return y.sheet.hydrate(a),y};function lg(){return lg=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)({}).hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},lg.apply(null,arguments)}var k1={exports:{}},zt={};/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var TT;function IU(){if(TT)return zt;TT=1;var t=typeof Symbol=="function"&&Symbol.for,e=t?Symbol.for("react.element"):60103,n=t?Symbol.for("react.portal"):60106,r=t?Symbol.for("react.fragment"):60107,s=t?Symbol.for("react.strict_mode"):60108,o=t?Symbol.for("react.profiler"):60114,i=t?Symbol.for("react.provider"):60109,a=t?Symbol.for("react.context"):60110,l=t?Symbol.for("react.async_mode"):60111,c=t?Symbol.for("react.concurrent_mode"):60111,d=t?Symbol.for("react.forward_ref"):60112,f=t?Symbol.for("react.suspense"):60113,p=t?Symbol.for("react.suspense_list"):60120,g=t?Symbol.for("react.memo"):60115,y=t?Symbol.for("react.lazy"):60116,x=t?Symbol.for("react.block"):60121,w=t?Symbol.for("react.fundamental"):60117,S=t?Symbol.for("react.responder"):60118,$=t?Symbol.for("react.scope"):60119;function I(_){if(typeof _=="object"&&_!==null){var F=_.$$typeof;switch(F){case e:switch(_=_.type,_){case l:case c:case r:case o:case s:case f:return _;default:switch(_=_&&_.$$typeof,_){case a:case d:case y:case g:case i:return _;default:return F}}case n:return F}}}function R(_){return I(_)===c}return zt.AsyncMode=l,zt.ConcurrentMode=c,zt.ContextConsumer=a,zt.ContextProvider=i,zt.Element=e,zt.ForwardRef=d,zt.Fragment=r,zt.Lazy=y,zt.Memo=g,zt.Portal=n,zt.Profiler=o,zt.StrictMode=s,zt.Suspense=f,zt.isAsyncMode=function(_){return R(_)||I(_)===l},zt.isConcurrentMode=R,zt.isContextConsumer=function(_){return I(_)===a},zt.isContextProvider=function(_){return I(_)===i},zt.isElement=function(_){return typeof _=="object"&&_!==null&&_.$$typeof===e},zt.isForwardRef=function(_){return I(_)===d},zt.isFragment=function(_){return I(_)===r},zt.isLazy=function(_){return I(_)===y},zt.isMemo=function(_){return I(_)===g},zt.isPortal=function(_){return I(_)===n},zt.isProfiler=function(_){return I(_)===o},zt.isStrictMode=function(_){return I(_)===s},zt.isSuspense=function(_){return I(_)===f},zt.isValidElementType=function(_){return typeof _=="string"||typeof _=="function"||_===r||_===c||_===o||_===s||_===f||_===p||typeof _=="object"&&_!==null&&(_.$$typeof===y||_.$$typeof===g||_.$$typeof===i||_.$$typeof===a||_.$$typeof===d||_.$$typeof===w||_.$$typeof===S||_.$$typeof===$||_.$$typeof===x)},zt.typeOf=I,zt}var IT;function NU(){return IT||(IT=1,k1.exports=IU()),k1.exports}var T1,NT;function EU(){if(NT)return T1;NT=1;var t=NU(),e={childContextTypes:!0,contextType:!0,contextTypes:!0,defaultProps:!0,displayName:!0,getDefaultProps:!0,getDerivedStateFromError:!0,getDerivedStateFromProps:!0,mixins:!0,propTypes:!0,type:!0},n={name:!0,length:!0,prototype:!0,caller:!0,callee:!0,arguments:!0,arity:!0},r={$$typeof:!0,render:!0,defaultProps:!0,displayName:!0,propTypes:!0},s={$$typeof:!0,compare:!0,defaultProps:!0,displayName:!0,propTypes:!0,type:!0},o={};o[t.ForwardRef]=r,o[t.Memo]=s;function i(y){return t.isMemo(y)?s:o[y.$$typeof]||e}var a=Object.defineProperty,l=Object.getOwnPropertyNames,c=Object.getOwnPropertySymbols,d=Object.getOwnPropertyDescriptor,f=Object.getPrototypeOf,p=Object.prototype;function g(y,x,w){if(typeof x!="string"){if(p){var S=f(x);S&&S!==p&&g(y,S,w)}var $=l(x);c&&($=$.concat(c(x)));for(var I=i(y),R=i(x),_=0;_<$.length;++_){var F=$[_];if(!n[F]&&!(w&&w[F])&&!(R&&R[F])&&!(I&&I[F])){var O=d(x,F);try{a(y,F,O)}catch{}}}}return y}return T1=g,T1}EU();var RU=!0;function mR(t,e,n){var r="";return n.split(" ").forEach(function(s){t[s]!==void 0?e.push(t[s]+";"):s&&(r+=s+" ")}),r}var rb=function(e,n,r){var s=e.key+"-"+n.name;(r===!1||RU===!1)&&e.registered[s]===void 0&&(e.registered[s]=n.styles)},sb=function(e,n,r){rb(e,n,r);var s=e.key+"-"+n.name;if(e.inserted[n.name]===void 0){var o=n;do e.insert(n===o?"."+s:"",o,e.sheet,!0),o=o.next;while(o!==void 0)}};function _U(t){for(var e=0,n,r=0,s=t.length;s>=4;++r,s-=4)n=t.charCodeAt(r)&255|(t.charCodeAt(++r)&255)<<8|(t.charCodeAt(++r)&255)<<16|(t.charCodeAt(++r)&255)<<24,n=(n&65535)*1540483477+((n>>>16)*59797<<16),n^=n>>>24,e=(n&65535)*1540483477+((n>>>16)*59797<<16)^(e&65535)*1540483477+((e>>>16)*59797<<16);switch(s){case 3:e^=(t.charCodeAt(r+2)&255)<<16;case 2:e^=(t.charCodeAt(r+1)&255)<<8;case 1:e^=t.charCodeAt(r)&255,e=(e&65535)*1540483477+((e>>>16)*59797<<16)}return e^=e>>>13,e=(e&65535)*1540483477+((e>>>16)*59797<<16),((e^e>>>15)>>>0).toString(36)}var PU={animationIterationCount:1,aspectRatio:1,borderImageOutset:1,borderImageSlice:1,borderImageWidth:1,boxFlex:1,boxFlexGroup:1,boxOrdinalGroup:1,columnCount:1,columns:1,flex:1,flexGrow:1,flexPositive:1,flexShrink:1,flexNegative:1,flexOrder:1,gridRow:1,gridRowEnd:1,gridRowSpan:1,gridRowStart:1,gridColumn:1,gridColumnEnd:1,gridColumnSpan:1,gridColumnStart:1,msGridRow:1,msGridRowSpan:1,msGridColumn:1,msGridColumnSpan:1,fontWeight:1,lineHeight:1,opacity:1,order:1,orphans:1,scale:1,tabSize:1,widows:1,zIndex:1,zoom:1,WebkitLineClamp:1,fillOpacity:1,floodOpacity:1,stopOpacity:1,strokeDasharray:1,strokeDashoffset:1,strokeMiterlimit:1,strokeOpacity:1,strokeWidth:1},AU=/[A-Z]|^ms/g,DU=/_EMO_([^_]+?)_([^]*?)_EMO_/g,gR=function(e){return e.charCodeAt(1)===45},ET=function(e){return e!=null&&typeof e!="boolean"},I1=fR(function(t){return gR(t)?t:t.replace(AU,"-$&").toLowerCase()}),RT=function(e,n){switch(e){case"animation":case"animationName":if(typeof n=="string")return n.replace(DU,function(r,s,o){return li={name:s,styles:o,next:li},s})}return PU[e]!==1&&!gR(e)&&typeof n=="number"&&n!==0?n+"px":n};function af(t,e,n){if(n==null)return"";var r=n;if(r.__emotion_styles!==void 0)return r;switch(typeof n){case"boolean":return"";case"object":{var s=n;if(s.anim===1)return li={name:s.name,styles:s.styles,next:li},s.name;var o=n;if(o.styles!==void 0){var i=o.next;if(i!==void 0)for(;i!==void 0;)li={name:i.name,styles:i.styles,next:li},i=i.next;var a=o.styles+";";return a}return FU(t,e,n)}case"function":{if(t!==void 0){var l=li,c=n(t);return li=l,af(t,e,c)}break}}var d=n;if(e==null)return d;var f=e[d];return f!==void 0?f:d}function FU(t,e,n){var r="";if(Array.isArray(n))for(var s=0;s<n.length;s++)r+=af(t,e,n[s])+";";else for(var o in n){var i=n[o];if(typeof i!="object"){var a=i;e!=null&&e[a]!==void 0?r+=o+"{"+e[a]+"}":ET(a)&&(r+=I1(o)+":"+RT(o,a)+";")}else if(Array.isArray(i)&&typeof i[0]=="string"&&(e==null||e[i[0]]===void 0))for(var l=0;l<i.length;l++)ET(i[l])&&(r+=I1(o)+":"+RT(o,i[l])+";");else{var c=af(t,e,i);switch(o){case"animation":case"animationName":{r+=I1(o)+":"+c+";";break}default:r+=o+"{"+c+"}"}}}return r}var _T=/label:\s*([^\s;{]+)\s*(;|$)/g,li;function qg(t,e,n){if(t.length===1&&typeof t[0]=="object"&&t[0]!==null&&t[0].styles!==void 0)return t[0];var r=!0,s="";li=void 0;var o=t[0];if(o==null||o.raw===void 0)r=!1,s+=af(n,e,o);else{var i=o;s+=i[0]}for(var a=1;a<t.length;a++)if(s+=af(n,e,t[a]),r){var l=o;s+=l[a]}_T.lastIndex=0;for(var c="",d;(d=_T.exec(s))!==null;)c+="-"+d[1];var f=_U(s)+c;return{name:f,styles:s,next:li}}var OU=function(e){return e()},yR=Xk.useInsertionEffect?Xk.useInsertionEffect:!1,xR=yR||OU,PT=yR||ee.useLayoutEffect,ob=ee.createContext(typeof HTMLElement<"u"?TU({key:"css"}):null);ob.Provider;var LU=function(){return ee.useContext(ob)},ib=function(e){return ee.forwardRef(function(n,r){var s=ee.useContext(ob);return e(n,s,r)})},rd=ee.createContext({}),zU=function(e,n){if(typeof n=="function"){var r=n(e);return r}return lg({},e,n)},BU=$T(function(t){return $T(function(e){return zU(t,e)})}),MU=function(e){var n=ee.useContext(rd);return e.theme!==n&&(n=BU(n)(e.theme)),ee.createElement(rd.Provider,{value:n},e.children)},ab={}.hasOwnProperty,Ex="__EMOTION_TYPE_PLEASE_DO_NOT_USE__",VU=function(e,n){var r={};for(var s in n)ab.call(n,s)&&(r[s]=n[s]);return r[Ex]=e,r},WU=function(e){var n=e.cache,r=e.serialized,s=e.isStringTag;return rb(n,r,s),xR(function(){return sb(n,r,s)}),null},UU=ib(function(t,e,n){var r=t.css;typeof r=="string"&&e.registered[r]!==void 0&&(r=e.registered[r]);var s=t[Ex],o=[r],i="";typeof t.className=="string"?i=mR(e.registered,o,t.className):t.className!=null&&(i=t.className+" ");var a=qg(o,void 0,ee.useContext(rd));i+=e.key+"-"+a.name;var l={};for(var c in t)ab.call(t,c)&&c!=="css"&&c!==Ex&&(l[c]=t[c]);return l.className=i,n&&(l.ref=n),ee.createElement(ee.Fragment,null,ee.createElement(WU,{cache:e,serialized:a,isStringTag:typeof s=="string"}),ee.createElement(s,l))}),jU=UU,AT=function(e,n){var r=arguments;if(n==null||!ab.call(n,"css"))return ee.createElement.apply(void 0,r);var s=r.length,o=new Array(s);o[0]=jU,o[1]=VU(e,n);for(var i=2;i<s;i++)o[i]=r[i];return ee.createElement.apply(null,o)};(function(t){var e;e||(e=t.JSX||(t.JSX={}))})(AT||(AT={}));var Yg=ib(function(t,e){var n=t.styles,r=qg([n],void 0,ee.useContext(rd)),s=ee.useRef();return PT(function(){var o=e.key+"-global",i=new e.sheet.constructor({key:o,nonce:e.sheet.nonce,container:e.sheet.container,speedy:e.sheet.isSpeedy}),a=!1,l=document.querySelector('style[data-emotion="'+o+" "+r.name+'"]');return e.sheet.tags.length&&(i.before=e.sheet.tags[0]),l!==null&&(a=!0,l.setAttribute("data-emotion",o),i.hydrate([l])),s.current=[i,a],function(){i.flush()}},[e]),PT(function(){var o=s.current,i=o[0],a=o[1];if(a){o[1]=!1;return}if(r.next!==void 0&&sb(e,r.next,!0),i.tags.length){var l=i.tags[i.tags.length-1].nextElementSibling;i.before=l,i.flush()}e.insert("",r,i,!1)},[e,r.name]),null});function GU(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];return qg(e)}function Lf(){var t=GU.apply(void 0,arguments),e="animation-"+t.name;return{name:e,styles:"@keyframes "+e+"{"+t.styles+"}",anim:1,toString:function(){return"_EMO_"+this.name+"_"+this.styles+"_EMO_"}}}const lb=ee.createContext({});lb.displayName="ColorModeContext";function ub(){const t=ee.useContext(lb);if(t===void 0)throw new Error("useColorMode must be used within a ColorModeProvider");return t}const pm={light:"chakra-ui-light",dark:"chakra-ui-dark"};function HU(t={}){const{preventTransition:e=!0,nonce:n}=t,r={setDataset:s=>{const o=e?r.preventTransition():void 0;document.documentElement.dataset.theme=s,document.documentElement.style.colorScheme=s,o==null||o()},setClassName(s){document.body.classList.add(s?pm.dark:pm.light),document.body.classList.remove(s?pm.light:pm.dark)},query(){return window.matchMedia("(prefers-color-scheme: dark)")},getSystemTheme(s){return r.query().matches??s==="dark"?"dark":"light"},addListener(s){const o=r.query(),i=a=>{s(a.matches?"dark":"light")};return typeof o.addListener=="function"?o.addListener(i):o.addEventListener("change",i),()=>{typeof o.removeListener=="function"?o.removeListener(i):o.removeEventListener("change",i)}},preventTransition(){const s=document.createElement("style");return s.appendChild(document.createTextNode("*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")),n!==void 0&&(s.nonce=n),document.head.appendChild(s),()=>{window.getComputedStyle(document.body),requestAnimationFrame(()=>{requestAnimationFrame(()=>{document.head.removeChild(s)})})}}};return r}const KU="chakra-ui-color-mode";function XU(t){return{ssr:!1,type:"localStorage",get(e){if(!(globalThis!=null&&globalThis.document))return e;let n;try{n=localStorage.getItem(t)||e}catch{}return n||e},set(e){try{localStorage.setItem(t,e)}catch{}}}}const qU=XU(KU),DT=()=>{},YU=mL()?ee.useLayoutEffect:ee.useEffect;function FT(t,e){return t.type==="cookie"&&t.ssr?t.get(e):e}const vR=function(e){const{value:n,children:r,options:{useSystemColorMode:s,initialColorMode:o,disableTransitionOnChange:i}={},colorModeManager:a=qU}=e,l=LU(),c=o==="dark"?"dark":"light",[d,f]=ee.useState(()=>FT(a,c)),[p,g]=ee.useState(()=>FT(a)),{getSystemTheme:y,setClassName:x,setDataset:w,addListener:S}=ee.useMemo(()=>HU({preventTransition:i,nonce:l==null?void 0:l.nonce}),[i,l==null?void 0:l.nonce]),$=o==="system"&&!d?p:d,I=ee.useCallback(F=>{const O=F==="system"?y():F;f(O),x(O==="dark"),w(O),a.set(O)},[a,y,x,w]);YU(()=>{o==="system"&&g(y())},[]),ee.useEffect(()=>{const F=a.get();if(F){I(F);return}if(o==="system"){I("system");return}I(c)},[a,c,o,I]);const R=ee.useCallback(()=>{I($==="dark"?"light":"dark")},[$,I]);ee.useEffect(()=>{if(s)return S(I)},[s,S,I]);const _=ee.useMemo(()=>({colorMode:n??$,toggleColorMode:n?DT:R,setColorMode:n?DT:I,forced:n!==void 0}),[$,R,I,n]);return K.jsx(lb.Provider,{value:_,children:r})};vR.displayName="ColorModeProvider";const bR=String.raw,wR=bR`
  :root,
  :host {
    --chakra-vh: 100vh;
  }

  @supports (height: -webkit-fill-available) {
    :root,
    :host {
      --chakra-vh: -webkit-fill-available;
    }
  }

  @supports (height: -moz-fill-available) {
    :root,
    :host {
      --chakra-vh: -moz-fill-available;
    }
  }

  @supports (height: 100dvh) {
    :root,
    :host {
      --chakra-vh: 100dvh;
    }
  }
`,QU=()=>K.jsx(Yg,{styles:wR}),ZU=({scope:t=""})=>K.jsx(Yg,{styles:bR`
      html {
        line-height: 1.5;
        -webkit-text-size-adjust: 100%;
        font-family: system-ui, sans-serif;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        -moz-osx-font-smoothing: grayscale;
        touch-action: manipulation;
      }

      body {
        position: relative;
        min-height: 100%;
        margin: 0;
        font-feature-settings: "kern";
      }

      ${t} :where(*, *::before, *::after) {
        border-width: 0;
        border-style: solid;
        box-sizing: border-box;
        word-wrap: break-word;
      }

      main {
        display: block;
      }

      ${t} hr {
        border-top-width: 1px;
        box-sizing: content-box;
        height: 0;
        overflow: visible;
      }

      ${t} :where(pre, code, kbd,samp) {
        font-family: SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: 1em;
      }

      ${t} a {
        background-color: transparent;
        color: inherit;
        text-decoration: inherit;
      }

      ${t} abbr[title] {
        border-bottom: none;
        text-decoration: underline;
        -webkit-text-decoration: underline dotted;
        text-decoration: underline dotted;
      }

      ${t} :where(b, strong) {
        font-weight: bold;
      }

      ${t} small {
        font-size: 80%;
      }

      ${t} :where(sub,sup) {
        font-size: 75%;
        line-height: 0;
        position: relative;
        vertical-align: baseline;
      }

      ${t} sub {
        bottom: -0.25em;
      }

      ${t} sup {
        top: -0.5em;
      }

      ${t} img {
        border-style: none;
      }

      ${t} :where(button, input, optgroup, select, textarea) {
        font-family: inherit;
        font-size: 100%;
        line-height: 1.15;
        margin: 0;
      }

      ${t} :where(button, input) {
        overflow: visible;
      }

      ${t} :where(button, select) {
        text-transform: none;
      }

      ${t} :where(
          button::-moz-focus-inner,
          [type="button"]::-moz-focus-inner,
          [type="reset"]::-moz-focus-inner,
          [type="submit"]::-moz-focus-inner
        ) {
        border-style: none;
        padding: 0;
      }

      ${t} fieldset {
        padding: 0.35em 0.75em 0.625em;
      }

      ${t} legend {
        box-sizing: border-box;
        color: inherit;
        display: table;
        max-width: 100%;
        padding: 0;
        white-space: normal;
      }

      ${t} progress {
        vertical-align: baseline;
      }

      ${t} textarea {
        overflow: auto;
      }

      ${t} :where([type="checkbox"], [type="radio"]) {
        box-sizing: border-box;
        padding: 0;
      }

      ${t} input[type="number"]::-webkit-inner-spin-button,
      ${t} input[type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none !important;
      }

      ${t} input[type="number"] {
        -moz-appearance: textfield;
      }

      ${t} input[type="search"] {
        -webkit-appearance: textfield;
        outline-offset: -2px;
      }

      ${t} input[type="search"]::-webkit-search-decoration {
        -webkit-appearance: none !important;
      }

      ${t} ::-webkit-file-upload-button {
        -webkit-appearance: button;
        font: inherit;
      }

      ${t} details {
        display: block;
      }

      ${t} summary {
        display: list-item;
      }

      template {
        display: none;
      }

      [hidden] {
        display: none !important;
      }

      ${t} :where(
          blockquote,
          dl,
          dd,
          h1,
          h2,
          h3,
          h4,
          h5,
          h6,
          hr,
          figure,
          p,
          pre
        ) {
        margin: 0;
      }

      ${t} button {
        background: transparent;
        padding: 0;
      }

      ${t} fieldset {
        margin: 0;
        padding: 0;
      }

      ${t} :where(ol, ul) {
        margin: 0;
        padding: 0;
      }

      ${t} textarea {
        resize: vertical;
      }

      ${t} :where(button, [role="button"]) {
        cursor: pointer;
      }

      ${t} button::-moz-focus-inner {
        border: 0 !important;
      }

      ${t} table {
        border-collapse: collapse;
      }

      ${t} :where(h1, h2, h3, h4, h5, h6) {
        font-size: inherit;
        font-weight: inherit;
      }

      ${t} :where(button, input, optgroup, select, textarea) {
        padding: 0;
        line-height: inherit;
        color: inherit;
      }

      ${t} :where(img, svg, video, canvas, audio, iframe, embed, object) {
        display: block;
      }

      ${t} :where(img, video) {
        max-width: 100%;
        height: auto;
      }

      [data-js-focus-visible]
        :focus:not([data-focus-visible-added]):not(
          [data-focus-visible-disabled]
        ) {
        outline: none;
        box-shadow: none;
      }

      ${t} select::-ms-expand {
        display: none;
      }

      ${wR}
    `});function JU(t){const{cssVarsRoot:e,theme:n,children:r}=t,s=ee.useMemo(()=>Bz(n),[n]);return K.jsxs(MU,{theme:s,children:[K.jsx(e8,{root:e}),r]})}function e8({root:t=":host, :root"}){const e=[t,"[data-theme]"].join(",");return K.jsx(Yg,{styles:n=>({[e]:n.__cssVars})})}Gr({name:"StylesContext",errorMessage:"useStyles: `styles` is undefined. Seems you forgot to wrap the components in `<StylesProvider />` "});function t8(t){return Gr({name:`${t}StylesContext`,errorMessage:`useStyles: "styles" is undefined. Seems you forgot to wrap the components in "<${t} />" `})}function n8(){const{colorMode:t}=ub();return K.jsx(Yg,{styles:e=>{const n=M3(e,"styles.global"),r=ro(n,{theme:e,colorMode:t});return r?G3(r)(e):void 0}})}const[r8,s8]=Gr({strict:!1,name:"PortalManagerContext"});function SR(t){const{children:e,zIndex:n}=t;return K.jsx(r8,{value:{zIndex:n},children:e})}SR.displayName="PortalManager";const CR=ee.createContext({getDocument(){return document},getWindow(){return window}});CR.displayName="EnvironmentContext";function $R(t){const{children:e,environment:n,disabled:r}=t,s=ee.useRef(null),o=ee.useMemo(()=>n||{getDocument:()=>{var a;return((a=s.current)==null?void 0:a.ownerDocument)??document},getWindow:()=>{var a;return((a=s.current)==null?void 0:a.ownerDocument.defaultView)??window}},[n]),i=!r||!n;return K.jsxs(CR.Provider,{value:o,children:[e,i&&K.jsx("span",{id:"__chakra_env",hidden:!0,ref:s})]})}$R.displayName="EnvironmentProvider";const o8=t=>{const{children:e,colorModeManager:n,portalZIndex:r,resetScope:s,resetCSS:o=!0,theme:i={},environment:a,cssVarsRoot:l,disableEnvironment:c,disableGlobalStyle:d}=t,f=K.jsx($R,{environment:a,disabled:c,children:e});return K.jsx(JU,{theme:i,cssVarsRoot:l,children:K.jsxs(vR,{colorModeManager:n,options:i.config,children:[o?K.jsx(ZU,{scope:s}):K.jsx(QU,{}),!d&&K.jsx(n8,{}),r?K.jsx(SR,{zIndex:r,children:f}):f]})})},cb=ee.createContext({});function db(t){const e=ee.useRef(null);return e.current===null&&(e.current=t()),e.current}const hb=typeof window<"u",kR=hb?ee.useLayoutEffect:ee.useEffect,zf=ee.createContext(null),fb=ee.createContext({transformPagePoint:t=>t,isStatic:!1,reducedMotion:"never"});class i8 extends ee.Component{getSnapshotBeforeUpdate(e){const n=this.props.childRef.current;if(n&&e.isPresent&&!this.props.isPresent){const r=n.offsetParent,s=r instanceof HTMLElement&&r.offsetWidth||0,o=this.props.sizeRef.current;o.height=n.offsetHeight||0,o.width=n.offsetWidth||0,o.top=n.offsetTop,o.left=n.offsetLeft,o.right=s-o.width-o.left}return null}componentDidUpdate(){}render(){return this.props.children}}function a8({children:t,isPresent:e,anchorX:n}){const r=ee.useId(),s=ee.useRef(null),o=ee.useRef({width:0,height:0,top:0,left:0,right:0}),{nonce:i}=ee.useContext(fb);return ee.useInsertionEffect(()=>{const{width:a,height:l,top:c,left:d,right:f}=o.current;if(e||!s.current||!a||!l)return;const p=n==="left"?`left: ${d}`:`right: ${f}`;s.current.dataset.motionPopId=r;const g=document.createElement("style");return i&&(g.nonce=i),document.head.appendChild(g),g.sheet&&g.sheet.insertRule(`
          [data-motion-pop-id="${r}"] {
            position: absolute !important;
            width: ${a}px !important;
            height: ${l}px !important;
            ${p}px !important;
            top: ${c}px !important;
          }
        `),()=>{document.head.removeChild(g)}},[e]),K.jsx(i8,{isPresent:e,childRef:s,sizeRef:o,children:ee.cloneElement(t,{ref:s})})}const l8=({children:t,initial:e,isPresent:n,onExitComplete:r,custom:s,presenceAffectsLayout:o,mode:i,anchorX:a})=>{const l=db(u8),c=ee.useId();let d=!0,f=ee.useMemo(()=>(d=!1,{id:c,initial:e,isPresent:n,custom:s,onExitComplete:p=>{l.set(p,!0);for(const g of l.values())if(!g)return;r&&r()},register:p=>(l.set(p,!1),()=>l.delete(p))}),[n,l,r]);return o&&d&&(f={...f}),ee.useMemo(()=>{l.forEach((p,g)=>l.set(g,!1))},[n]),ee.useEffect(()=>{!n&&!l.size&&r&&r()},[n]),i==="popLayout"&&(t=K.jsx(a8,{isPresent:n,anchorX:a,children:t})),K.jsx(zf.Provider,{value:f,children:t})};function u8(){return new Map}function TR(t=!0){const e=ee.useContext(zf);if(e===null)return[!0,null];const{isPresent:n,onExitComplete:r,register:s}=e,o=ee.useId();ee.useEffect(()=>{if(t)return s(o)},[t]);const i=ee.useCallback(()=>t&&r&&r(o),[o,r,t]);return!n&&r?[!1,i]:[!0]}function c8(){return d8(ee.useContext(zf))}function d8(t){return t===null?!0:t.isPresent}const mm=t=>t.key||"";function OT(t){const e=[];return ee.Children.forEach(t,n=>{ee.isValidElement(n)&&e.push(n)}),e}const pb=({children:t,custom:e,initial:n=!0,onExitComplete:r,presenceAffectsLayout:s=!0,mode:o="sync",propagate:i=!1,anchorX:a="left"})=>{const[l,c]=TR(i),d=ee.useMemo(()=>OT(t),[t]),f=i&&!l?[]:d.map(mm),p=ee.useRef(!0),g=ee.useRef(d),y=db(()=>new Map),[x,w]=ee.useState(d),[S,$]=ee.useState(d);kR(()=>{p.current=!1,g.current=d;for(let _=0;_<S.length;_++){const F=mm(S[_]);f.includes(F)?y.delete(F):y.get(F)!==!0&&y.set(F,!1)}},[S,f.length,f.join("-")]);const I=[];if(d!==x){let _=[...d];for(let F=0;F<S.length;F++){const O=S[F],M=mm(O);f.includes(M)||(_.splice(F,0,O),I.push(O))}return o==="wait"&&I.length&&(_=I),$(OT(_)),w(d),null}const{forceRender:R}=ee.useContext(cb);return K.jsx(K.Fragment,{children:S.map(_=>{const F=mm(_),O=i&&!l?!1:d===S||f.includes(F),M=()=>{if(y.has(F))y.set(F,!0);else return;let B=!0;y.forEach(V=>{V||(B=!1)}),B&&(R==null||R(),$(g.current),i&&(c==null||c()),r&&r())};return K.jsx(l8,{isPresent:O,initial:!p.current||n?void 0:!1,custom:e,presenceAffectsLayout:s,mode:o,onExitComplete:O?void 0:M,anchorX:a,children:_},F)})})};function mb(t,e){t.indexOf(e)===-1&&t.push(e)}function gb(t,e){const n=t.indexOf(e);n>-1&&t.splice(n,1)}const aa=(t,e,n)=>n>e?e:n<t?t:n;let yb=()=>{};const la={},IR=t=>/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t),NR=t=>/^0[^.\s]+$/u.test(t);function xb(t){let e;return()=>(e===void 0&&(e=t()),e)}const io=t=>t,h8=(t,e)=>n=>e(t(n)),Bf=(...t)=>t.reduce(h8),lf=(t,e,n)=>{const r=e-t;return r===0?1:(n-t)/r};class vb{constructor(){this.subscriptions=[]}add(e){return mb(this.subscriptions,e),()=>gb(this.subscriptions,e)}notify(e,n,r){const s=this.subscriptions.length;if(s)if(s===1)this.subscriptions[0](e,n,r);else for(let o=0;o<s;o++){const i=this.subscriptions[o];i&&i(e,n,r)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}const pi=t=>t*1e3,mi=t=>t/1e3;function ER(t,e){return e?t*(1e3/e):0}const RR=(t,e,n)=>(((1-3*n+3*e)*t+(3*n-6*e))*t+3*e)*t,f8=1e-7,p8=12;function m8(t,e,n,r,s){let o,i,a=0;do i=e+(n-e)/2,o=RR(i,r,s)-t,o>0?n=i:e=i;while(Math.abs(o)>f8&&++a<p8);return i}function Mf(t,e,n,r){if(t===e&&n===r)return io;const s=o=>m8(o,0,1,t,n);return o=>o===0||o===1?o:RR(s(o),e,r)}const _R=t=>e=>e<=.5?t(2*e)/2:(2-t(2*(1-e)))/2,PR=t=>e=>1-t(1-e),AR=Mf(.33,1.53,.69,.99),bb=PR(AR),DR=_R(bb),FR=t=>(t*=2)<1?.5*bb(t):.5*(2-Math.pow(2,-10*(t-1))),wb=t=>1-Math.sin(Math.acos(t)),OR=PR(wb),LR=_R(wb),g8=Mf(.42,0,1,1),y8=Mf(0,0,.58,1),zR=Mf(.42,0,.58,1),x8=t=>Array.isArray(t)&&typeof t[0]!="number",BR=t=>Array.isArray(t)&&typeof t[0]=="number",v8={linear:io,easeIn:g8,easeInOut:zR,easeOut:y8,circIn:wb,circInOut:LR,circOut:OR,backIn:bb,backInOut:DR,backOut:AR,anticipate:FR},b8=t=>typeof t=="string",LT=t=>{if(BR(t)){yb(t.length===4);const[e,n,r,s]=t;return Mf(e,n,r,s)}else if(b8(t))return v8[t];return t},gm=["setup","read","resolveKeyframes","preUpdate","update","preRender","render","postRender"],zT={value:null};function w8(t,e){let n=new Set,r=new Set,s=!1,o=!1;const i=new WeakSet;let a={delta:0,timestamp:0,isProcessing:!1},l=0;function c(f){i.has(f)&&(d.schedule(f),t()),l++,f(a)}const d={schedule:(f,p=!1,g=!1)=>{const x=g&&s?n:r;return p&&i.add(f),x.has(f)||x.add(f),f},cancel:f=>{r.delete(f),i.delete(f)},process:f=>{if(a=f,s){o=!0;return}s=!0,[n,r]=[r,n],n.forEach(c),e&&zT.value&&zT.value.frameloop[e].push(l),l=0,n.clear(),s=!1,o&&(o=!1,d.process(f))}};return d}const S8=40;function MR(t,e){let n=!1,r=!0;const s={delta:0,timestamp:0,isProcessing:!1},o=()=>n=!0,i=gm.reduce((I,R)=>(I[R]=w8(o,e?R:void 0),I),{}),{setup:a,read:l,resolveKeyframes:c,preUpdate:d,update:f,preRender:p,render:g,postRender:y}=i,x=()=>{const I=la.useManualTiming?s.timestamp:performance.now();n=!1,la.useManualTiming||(s.delta=r?1e3/60:Math.max(Math.min(I-s.timestamp,S8),1)),s.timestamp=I,s.isProcessing=!0,a.process(s),l.process(s),c.process(s),d.process(s),f.process(s),p.process(s),g.process(s),y.process(s),s.isProcessing=!1,n&&e&&(r=!1,t(x))},w=()=>{n=!0,r=!0,s.isProcessing||t(x)};return{schedule:gm.reduce((I,R)=>{const _=i[R];return I[R]=(F,O=!1,M=!1)=>(n||w(),_.schedule(F,O,M)),I},{}),cancel:I=>{for(let R=0;R<gm.length;R++)i[gm[R]].cancel(I)},state:s,steps:i}}const{schedule:pn,cancel:fl,state:ir,steps:N1}=MR(typeof requestAnimationFrame<"u"?requestAnimationFrame:io,!0);let Wm;function C8(){Wm=void 0}const hs={now:()=>(Wm===void 0&&hs.set(ir.isProcessing||la.useManualTiming?ir.timestamp:performance.now()),Wm),set:t=>{Wm=t,queueMicrotask(C8)}},VR=t=>e=>typeof e=="string"&&e.startsWith(t),Sb=VR("--"),$8=VR("var(--"),Cb=t=>$8(t)?k8.test(t.split("/*")[0].trim()):!1,k8=/var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,yd={test:t=>typeof t=="number",parse:parseFloat,transform:t=>t},uf={...yd,transform:t=>aa(0,1,t)},ym={...yd,default:1},Hh=t=>Math.round(t*1e5)/1e5,$b=/-?(?:\d+(?:\.\d+)?|\.\d+)/gu;function T8(t){return t==null}const I8=/^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,kb=(t,e)=>n=>!!(typeof n=="string"&&I8.test(n)&&n.startsWith(t)||e&&!T8(n)&&Object.prototype.hasOwnProperty.call(n,e)),WR=(t,e,n)=>r=>{if(typeof r!="string")return r;const[s,o,i,a]=r.match($b);return{[t]:parseFloat(s),[e]:parseFloat(o),[n]:parseFloat(i),alpha:a!==void 0?parseFloat(a):1}},N8=t=>aa(0,255,t),E1={...yd,transform:t=>Math.round(N8(t))},gu={test:kb("rgb","red"),parse:WR("red","green","blue"),transform:({red:t,green:e,blue:n,alpha:r=1})=>"rgba("+E1.transform(t)+", "+E1.transform(e)+", "+E1.transform(n)+", "+Hh(uf.transform(r))+")"};function E8(t){let e="",n="",r="",s="";return t.length>5?(e=t.substring(1,3),n=t.substring(3,5),r=t.substring(5,7),s=t.substring(7,9)):(e=t.substring(1,2),n=t.substring(2,3),r=t.substring(3,4),s=t.substring(4,5),e+=e,n+=n,r+=r,s+=s),{red:parseInt(e,16),green:parseInt(n,16),blue:parseInt(r,16),alpha:s?parseInt(s,16)/255:1}}const Rx={test:kb("#"),parse:E8,transform:gu.transform},Vf=t=>({test:e=>typeof e=="string"&&e.endsWith(t)&&e.split(" ").length===1,parse:parseFloat,transform:e=>`${e}${t}`}),nl=Vf("deg"),gi=Vf("%"),rt=Vf("px"),R8=Vf("vh"),_8=Vf("vw"),BT={...gi,parse:t=>gi.parse(t)/100,transform:t=>gi.transform(t*100)},Bc={test:kb("hsl","hue"),parse:WR("hue","saturation","lightness"),transform:({hue:t,saturation:e,lightness:n,alpha:r=1})=>"hsla("+Math.round(t)+", "+gi.transform(Hh(e))+", "+gi.transform(Hh(n))+", "+Hh(uf.transform(r))+")"},wr={test:t=>gu.test(t)||Rx.test(t)||Bc.test(t),parse:t=>gu.test(t)?gu.parse(t):Bc.test(t)?Bc.parse(t):Rx.parse(t),transform:t=>typeof t=="string"?t:t.hasOwnProperty("red")?gu.transform(t):Bc.transform(t)},P8=/(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;function A8(t){var e,n;return isNaN(t)&&typeof t=="string"&&(((e=t.match($b))==null?void 0:e.length)||0)+(((n=t.match(P8))==null?void 0:n.length)||0)>0}const UR="number",jR="color",D8="var",F8="var(",MT="${}",O8=/var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;function cf(t){const e=t.toString(),n=[],r={color:[],number:[],var:[]},s=[];let o=0;const a=e.replace(O8,l=>(wr.test(l)?(r.color.push(o),s.push(jR),n.push(wr.parse(l))):l.startsWith(F8)?(r.var.push(o),s.push(D8),n.push(l)):(r.number.push(o),s.push(UR),n.push(parseFloat(l))),++o,MT)).split(MT);return{values:n,split:a,indexes:r,types:s}}function GR(t){return cf(t).values}function HR(t){const{split:e,types:n}=cf(t),r=e.length;return s=>{let o="";for(let i=0;i<r;i++)if(o+=e[i],s[i]!==void 0){const a=n[i];a===UR?o+=Hh(s[i]):a===jR?o+=wr.transform(s[i]):o+=s[i]}return o}}const L8=t=>typeof t=="number"?0:t;function z8(t){const e=GR(t);return HR(t)(e.map(L8))}const pl={test:A8,parse:GR,createTransformer:HR,getAnimatableNone:z8};function R1(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+(e-t)*6*n:n<1/2?e:n<2/3?t+(e-t)*(2/3-n)*6:t}function B8({hue:t,saturation:e,lightness:n,alpha:r}){t/=360,e/=100,n/=100;let s=0,o=0,i=0;if(!e)s=o=i=n;else{const a=n<.5?n*(1+e):n+e-n*e,l=2*n-a;s=R1(l,a,t+1/3),o=R1(l,a,t),i=R1(l,a,t-1/3)}return{red:Math.round(s*255),green:Math.round(o*255),blue:Math.round(i*255),alpha:r}}function ug(t,e){return n=>n>0?e:t}const fn=(t,e,n)=>t+(e-t)*n,_1=(t,e,n)=>{const r=t*t,s=n*(e*e-r)+r;return s<0?0:Math.sqrt(s)},M8=[Rx,gu,Bc],V8=t=>M8.find(e=>e.test(t));function VT(t){const e=V8(t);if(!e)return!1;let n=e.parse(t);return e===Bc&&(n=B8(n)),n}const WT=(t,e)=>{const n=VT(t),r=VT(e);if(!n||!r)return ug(t,e);const s={...n};return o=>(s.red=_1(n.red,r.red,o),s.green=_1(n.green,r.green,o),s.blue=_1(n.blue,r.blue,o),s.alpha=fn(n.alpha,r.alpha,o),gu.transform(s))},_x=new Set(["none","hidden"]);function W8(t,e){return _x.has(t)?n=>n<=0?t:e:n=>n>=1?e:t}function U8(t,e){return n=>fn(t,e,n)}function Tb(t){return typeof t=="number"?U8:typeof t=="string"?Cb(t)?ug:wr.test(t)?WT:H8:Array.isArray(t)?KR:typeof t=="object"?wr.test(t)?WT:j8:ug}function KR(t,e){const n=[...t],r=n.length,s=t.map((o,i)=>Tb(o)(o,e[i]));return o=>{for(let i=0;i<r;i++)n[i]=s[i](o);return n}}function j8(t,e){const n={...t,...e},r={};for(const s in n)t[s]!==void 0&&e[s]!==void 0&&(r[s]=Tb(t[s])(t[s],e[s]));return s=>{for(const o in r)n[o]=r[o](s);return n}}function G8(t,e){const n=[],r={color:0,var:0,number:0};for(let s=0;s<e.values.length;s++){const o=e.types[s],i=t.indexes[o][r[o]],a=t.values[i]??0;n[s]=a,r[o]++}return n}const H8=(t,e)=>{const n=pl.createTransformer(e),r=cf(t),s=cf(e);return r.indexes.var.length===s.indexes.var.length&&r.indexes.color.length===s.indexes.color.length&&r.indexes.number.length>=s.indexes.number.length?_x.has(t)&&!s.values.length||_x.has(e)&&!r.values.length?W8(t,e):Bf(KR(G8(r,s),s.values),n):ug(t,e)};function XR(t,e,n){return typeof t=="number"&&typeof e=="number"&&typeof n=="number"?fn(t,e,n):Tb(t)(t,e)}const K8=t=>{const e=({timestamp:n})=>t(n);return{start:()=>pn.update(e,!0),stop:()=>fl(e),now:()=>ir.isProcessing?ir.timestamp:hs.now()}},qR=(t,e,n=10)=>{let r="";const s=Math.max(Math.round(e/n),2);for(let o=0;o<s;o++)r+=t(o/(s-1))+", ";return`linear(${r.substring(0,r.length-2)})`},cg=2e4;function Ib(t){let e=0;const n=50;let r=t.next(e);for(;!r.done&&e<cg;)e+=n,r=t.next(e);return e>=cg?1/0:e}function X8(t,e=100,n){const r=n({...t,keyframes:[0,e]}),s=Math.min(Ib(r),cg);return{type:"keyframes",ease:o=>r.next(s*o).value/e,duration:mi(s)}}const q8=5;function YR(t,e,n){const r=Math.max(e-q8,0);return ER(n-t(r),e-r)}const xn={stiffness:100,damping:10,mass:1,velocity:0,duration:800,bounce:.3,visualDuration:.3,restSpeed:{granular:.01,default:2},restDelta:{granular:.005,default:.5},minDuration:.01,maxDuration:10,minDamping:.05,maxDamping:1},UT=.001;function Y8({duration:t=xn.duration,bounce:e=xn.bounce,velocity:n=xn.velocity,mass:r=xn.mass}){let s,o,i=1-e;i=aa(xn.minDamping,xn.maxDamping,i),t=aa(xn.minDuration,xn.maxDuration,mi(t)),i<1?(s=c=>{const d=c*i,f=d*t,p=d-n,g=Px(c,i),y=Math.exp(-f);return UT-p/g*y},o=c=>{const f=c*i*t,p=f*n+n,g=Math.pow(i,2)*Math.pow(c,2)*t,y=Math.exp(-f),x=Px(Math.pow(c,2),i);return(-s(c)+UT>0?-1:1)*((p-g)*y)/x}):(s=c=>{const d=Math.exp(-c*t),f=(c-n)*t+1;return-.001+d*f},o=c=>{const d=Math.exp(-c*t),f=(n-c)*(t*t);return d*f});const a=5/t,l=Z8(s,o,a);if(t=pi(t),isNaN(l))return{stiffness:xn.stiffness,damping:xn.damping,duration:t};{const c=Math.pow(l,2)*r;return{stiffness:c,damping:i*2*Math.sqrt(r*c),duration:t}}}const Q8=12;function Z8(t,e,n){let r=n;for(let s=1;s<Q8;s++)r=r-t(r)/e(r);return r}function Px(t,e){return t*Math.sqrt(1-e*e)}const J8=["duration","bounce"],ej=["stiffness","damping","mass"];function jT(t,e){return e.some(n=>t[n]!==void 0)}function tj(t){let e={velocity:xn.velocity,stiffness:xn.stiffness,damping:xn.damping,mass:xn.mass,isResolvedFromDuration:!1,...t};if(!jT(t,ej)&&jT(t,J8))if(t.visualDuration){const n=t.visualDuration,r=2*Math.PI/(n*1.2),s=r*r,o=2*aa(.05,1,1-(t.bounce||0))*Math.sqrt(s);e={...e,mass:xn.mass,stiffness:s,damping:o}}else{const n=Y8(t);e={...e,...n,mass:xn.mass},e.isResolvedFromDuration=!0}return e}function dg(t=xn.visualDuration,e=xn.bounce){const n=typeof t!="object"?{visualDuration:t,keyframes:[0,1],bounce:e}:t;let{restSpeed:r,restDelta:s}=n;const o=n.keyframes[0],i=n.keyframes[n.keyframes.length-1],a={done:!1,value:o},{stiffness:l,damping:c,mass:d,duration:f,velocity:p,isResolvedFromDuration:g}=tj({...n,velocity:-mi(n.velocity||0)}),y=p||0,x=c/(2*Math.sqrt(l*d)),w=i-o,S=mi(Math.sqrt(l/d)),$=Math.abs(w)<5;r||(r=$?xn.restSpeed.granular:xn.restSpeed.default),s||(s=$?xn.restDelta.granular:xn.restDelta.default);let I;if(x<1){const _=Px(S,x);I=F=>{const O=Math.exp(-x*S*F);return i-O*((y+x*S*w)/_*Math.sin(_*F)+w*Math.cos(_*F))}}else if(x===1)I=_=>i-Math.exp(-S*_)*(w+(y+S*w)*_);else{const _=S*Math.sqrt(x*x-1);I=F=>{const O=Math.exp(-x*S*F),M=Math.min(_*F,300);return i-O*((y+x*S*w)*Math.sinh(M)+_*w*Math.cosh(M))/_}}const R={calculatedDuration:g&&f||null,next:_=>{const F=I(_);if(g)a.done=_>=f;else{let O=_===0?y:0;x<1&&(O=_===0?pi(y):YR(I,_,F));const M=Math.abs(O)<=r,B=Math.abs(i-F)<=s;a.done=M&&B}return a.value=a.done?i:F,a},toString:()=>{const _=Math.min(Ib(R),cg),F=qR(O=>R.next(_*O).value,_,30);return _+"ms "+F},toTransition:()=>{}};return R}dg.applyToOptions=t=>{const e=X8(t,100,dg);return t.ease=e.ease,t.duration=pi(e.duration),t.type="keyframes",t};function Ax({keyframes:t,velocity:e=0,power:n=.8,timeConstant:r=325,bounceDamping:s=10,bounceStiffness:o=500,modifyTarget:i,min:a,max:l,restDelta:c=.5,restSpeed:d}){const f=t[0],p={done:!1,value:f},g=M=>a!==void 0&&M<a||l!==void 0&&M>l,y=M=>a===void 0?l:l===void 0||Math.abs(a-M)<Math.abs(l-M)?a:l;let x=n*e;const w=f+x,S=i===void 0?w:i(w);S!==w&&(x=S-f);const $=M=>-x*Math.exp(-M/r),I=M=>S+$(M),R=M=>{const B=$(M),V=I(M);p.done=Math.abs(B)<=c,p.value=p.done?S:V};let _,F;const O=M=>{g(p.value)&&(_=M,F=dg({keyframes:[p.value,y(p.value)],velocity:YR(I,M,p.value),damping:s,stiffness:o,restDelta:c,restSpeed:d}))};return O(0),{calculatedDuration:null,next:M=>{let B=!1;return!F&&_===void 0&&(B=!0,R(M),O(M)),_!==void 0&&M>=_?F.next(M-_):(!B&&R(M),p)}}}function nj(t,e,n){const r=[],s=n||la.mix||XR,o=t.length-1;for(let i=0;i<o;i++){let a=s(t[i],t[i+1]);if(e){const l=Array.isArray(e)?e[i]||io:e;a=Bf(l,a)}r.push(a)}return r}function rj(t,e,{clamp:n=!0,ease:r,mixer:s}={}){const o=t.length;if(yb(o===e.length),o===1)return()=>e[0];if(o===2&&e[0]===e[1])return()=>e[1];const i=t[0]===t[1];t[0]>t[o-1]&&(t=[...t].reverse(),e=[...e].reverse());const a=nj(e,r,s),l=a.length,c=d=>{if(i&&d<t[0])return e[0];let f=0;if(l>1)for(;f<t.length-2&&!(d<t[f+1]);f++);const p=lf(t[f],t[f+1],d);return a[f](p)};return n?d=>c(aa(t[0],t[o-1],d)):c}function sj(t,e){const n=t[t.length-1];for(let r=1;r<=e;r++){const s=lf(0,e,r);t.push(fn(n,1,s))}}function oj(t){const e=[0];return sj(e,t.length-1),e}function ij(t,e){return t.map(n=>n*e)}function aj(t,e){return t.map(()=>e||zR).splice(0,t.length-1)}function Kh({duration:t=300,keyframes:e,times:n,ease:r="easeInOut"}){const s=x8(r)?r.map(LT):LT(r),o={done:!1,value:e[0]},i=ij(n&&n.length===e.length?n:oj(e),t),a=rj(i,e,{ease:Array.isArray(s)?s:aj(e,s)});return{calculatedDuration:t,next:l=>(o.value=a(l),o.done=l>=t,o)}}const lj=t=>t!==null;function Nb(t,{repeat:e,repeatType:n="loop"},r,s=1){const o=t.filter(lj),a=s<0||e&&n!=="loop"&&e%2===1?0:o.length-1;return!a||r===void 0?o[a]:r}const uj={decay:Ax,inertia:Ax,tween:Kh,keyframes:Kh,spring:dg};function QR(t){typeof t.type=="string"&&(t.type=uj[t.type])}class Eb{constructor(){this.count=0,this.updateFinished()}get finished(){return this._finished}updateFinished(){this.count++,this._finished=new Promise(e=>{this.resolve=e})}notifyFinished(){this.resolve()}then(e,n){return this.finished.then(e,n)}}const cj=t=>t/100;class ZR extends Eb{constructor(e){super(),this.state="idle",this.startTime=null,this.isStopped=!1,this.currentTime=0,this.holdTime=null,this.playbackSpeed=1,this.stop=()=>{const{motionValue:n}=this.options;if(n&&n.updatedAt!==hs.now()&&this.tick(hs.now()),this.isStopped=!0,this.state==="idle")return;this.teardown();const{onStop:r}=this.options;r&&r()},this.options=e,this.initAnimation(),this.play(),e.autoplay===!1&&this.pause()}initAnimation(){const{options:e}=this;QR(e);const{type:n=Kh,repeat:r=0,repeatDelay:s=0,repeatType:o,velocity:i=0}=e;let{keyframes:a}=e;const l=n||Kh;l!==Kh&&typeof a[0]!="number"&&(this.mixKeyframes=Bf(cj,XR(a[0],a[1])),a=[0,100]);const c=l({...e,keyframes:a});o==="mirror"&&(this.mirroredGenerator=l({...e,keyframes:[...a].reverse(),velocity:-i})),c.calculatedDuration===null&&(c.calculatedDuration=Ib(c));const{calculatedDuration:d}=c;this.calculatedDuration=d,this.resolvedDuration=d+s,this.totalDuration=this.resolvedDuration*(r+1)-s,this.generator=c}updateTime(e){const n=Math.round(e-this.startTime)*this.playbackSpeed;this.holdTime!==null?this.currentTime=this.holdTime:this.currentTime=n}tick(e,n=!1){const{generator:r,totalDuration:s,mixKeyframes:o,mirroredGenerator:i,resolvedDuration:a,calculatedDuration:l}=this;if(this.startTime===null)return r.next(0);const{delay:c=0,keyframes:d,repeat:f,repeatType:p,repeatDelay:g,type:y,onUpdate:x,finalKeyframe:w}=this.options;this.speed>0?this.startTime=Math.min(this.startTime,e):this.speed<0&&(this.startTime=Math.min(e-s/this.speed,this.startTime)),n?this.currentTime=e:this.updateTime(e);const S=this.currentTime-c*(this.playbackSpeed>=0?1:-1),$=this.playbackSpeed>=0?S<0:S>s;this.currentTime=Math.max(S,0),this.state==="finished"&&this.holdTime===null&&(this.currentTime=s);let I=this.currentTime,R=r;if(f){const M=Math.min(this.currentTime,s)/a;let B=Math.floor(M),V=M%1;!V&&M>=1&&(V=1),V===1&&B--,B=Math.min(B,f+1),!!(B%2)&&(p==="reverse"?(V=1-V,g&&(V-=g/a)):p==="mirror"&&(R=i)),I=aa(0,1,V)*a}const _=$?{done:!1,value:d[0]}:R.next(I);o&&(_.value=o(_.value));let{done:F}=_;!$&&l!==null&&(F=this.playbackSpeed>=0?this.currentTime>=s:this.currentTime<=0);const O=this.holdTime===null&&(this.state==="finished"||this.state==="running"&&F);return O&&y!==Ax&&(_.value=Nb(d,this.options,w,this.speed)),x&&x(_.value),O&&this.finish(),_}then(e,n){return this.finished.then(e,n)}get duration(){return mi(this.calculatedDuration)}get time(){return mi(this.currentTime)}set time(e){e=pi(e),this.currentTime=e,this.startTime===null||this.holdTime!==null||this.playbackSpeed===0?this.holdTime=e:this.driver&&(this.startTime=this.driver.now()-e/this.playbackSpeed)}get speed(){return this.playbackSpeed}set speed(e){this.updateTime(hs.now());const n=this.playbackSpeed!==e;this.playbackSpeed=e,n&&(this.time=mi(this.currentTime))}play(){if(this.isStopped)return;const{driver:e=K8,onPlay:n,startTime:r}=this.options;this.driver||(this.driver=e(o=>this.tick(o))),n&&n();const s=this.driver.now();this.state==="finished"?(this.updateFinished(),this.startTime=s):this.holdTime!==null?this.startTime=s-this.holdTime:this.startTime||(this.startTime=r??s),this.state==="finished"&&this.speed<0&&(this.startTime+=this.calculatedDuration),this.holdTime=null,this.state="running",this.driver.start()}pause(){this.state="paused",this.updateTime(hs.now()),this.holdTime=this.currentTime}complete(){this.state!=="running"&&this.play(),this.state="finished",this.holdTime=null}finish(){this.teardown(),this.state="finished";const{onComplete:e}=this.options;e&&e()}cancel(){this.holdTime=null,this.startTime=0,this.tick(0),this.teardown()}teardown(){this.notifyFinished(),this.state="idle",this.stopDriver(),this.startTime=this.holdTime=null}stopDriver(){this.driver&&(this.driver.stop(),this.driver=void 0)}sample(e){return this.startTime=0,this.tick(e,!0)}attachTimeline(e){return this.options.allowFlatten&&(this.options.type="keyframes",this.options.ease="linear",this.initAnimation()),e.observe(this)}}function dj(t){for(let e=1;e<t.length;e++)t[e]??(t[e]=t[e-1])}const yu=t=>t*180/Math.PI,Dx=t=>{const e=yu(Math.atan2(t[1],t[0]));return Fx(e)},hj={x:4,y:5,translateX:4,translateY:5,scaleX:0,scaleY:3,scale:t=>(Math.abs(t[0])+Math.abs(t[3]))/2,rotate:Dx,rotateZ:Dx,skewX:t=>yu(Math.atan(t[1])),skewY:t=>yu(Math.atan(t[2])),skew:t=>(Math.abs(t[1])+Math.abs(t[2]))/2},Fx=t=>(t=t%360,t<0&&(t+=360),t),GT=Dx,HT=t=>Math.sqrt(t[0]*t[0]+t[1]*t[1]),KT=t=>Math.sqrt(t[4]*t[4]+t[5]*t[5]),fj={x:12,y:13,z:14,translateX:12,translateY:13,translateZ:14,scaleX:HT,scaleY:KT,scale:t=>(HT(t)+KT(t))/2,rotateX:t=>Fx(yu(Math.atan2(t[6],t[5]))),rotateY:t=>Fx(yu(Math.atan2(-t[2],t[0]))),rotateZ:GT,rotate:GT,skewX:t=>yu(Math.atan(t[4])),skewY:t=>yu(Math.atan(t[1])),skew:t=>(Math.abs(t[1])+Math.abs(t[4]))/2};function XT(t){return t.includes("scale")?1:0}function Ox(t,e){if(!t||t==="none")return XT(e);const n=t.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);let r,s;if(n)r=fj,s=n;else{const a=t.match(/^matrix\(([-\d.e\s,]+)\)$/u);r=hj,s=a}if(!s)return XT(e);const o=r[e],i=s[1].split(",").map(mj);return typeof o=="function"?o(i):i[o]}const pj=(t,e)=>{const{transform:n="none"}=getComputedStyle(t);return Ox(n,e)};function mj(t){return parseFloat(t.trim())}const xd=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],vd=new Set(xd),qT=t=>t===yd||t===rt,gj=new Set(["x","y","z"]),yj=xd.filter(t=>!gj.has(t));function xj(t){const e=[];return yj.forEach(n=>{const r=t.getValue(n);r!==void 0&&(e.push([n,r.get()]),r.set(n.startsWith("scale")?1:0))}),e}const sd={width:({x:t},{paddingLeft:e="0",paddingRight:n="0"})=>t.max-t.min-parseFloat(e)-parseFloat(n),height:({y:t},{paddingTop:e="0",paddingBottom:n="0"})=>t.max-t.min-parseFloat(e)-parseFloat(n),top:(t,{top:e})=>parseFloat(e),left:(t,{left:e})=>parseFloat(e),bottom:({y:t},{top:e})=>parseFloat(e)+(t.max-t.min),right:({x:t},{left:e})=>parseFloat(e)+(t.max-t.min),x:(t,{transform:e})=>Ox(e,"x"),y:(t,{transform:e})=>Ox(e,"y")};sd.translateX=sd.x;sd.translateY=sd.y;const $u=new Set;let Lx=!1,zx=!1,Bx=!1;function JR(){if(zx){const t=Array.from($u).filter(r=>r.needsMeasurement),e=new Set(t.map(r=>r.element)),n=new Map;e.forEach(r=>{const s=xj(r);s.length&&(n.set(r,s),r.render())}),t.forEach(r=>r.measureInitialState()),e.forEach(r=>{r.render();const s=n.get(r);s&&s.forEach(([o,i])=>{var a;(a=r.getValue(o))==null||a.set(i)})}),t.forEach(r=>r.measureEndState()),t.forEach(r=>{r.suspendedScrollY!==void 0&&window.scrollTo(0,r.suspendedScrollY)})}zx=!1,Lx=!1,$u.forEach(t=>t.complete(Bx)),$u.clear()}function e_(){$u.forEach(t=>{t.readKeyframes(),t.needsMeasurement&&(zx=!0)})}function vj(){Bx=!0,e_(),JR(),Bx=!1}class Rb{constructor(e,n,r,s,o,i=!1){this.isComplete=!1,this.isAsync=!1,this.needsMeasurement=!1,this.isScheduled=!1,this.unresolvedKeyframes=[...e],this.onComplete=n,this.name=r,this.motionValue=s,this.element=o,this.isAsync=i}scheduleResolve(){this.isScheduled=!0,this.isAsync?($u.add(this),Lx||(Lx=!0,pn.read(e_),pn.resolveKeyframes(JR))):(this.readKeyframes(),this.complete())}readKeyframes(){const{unresolvedKeyframes:e,name:n,element:r,motionValue:s}=this;if(e[0]===null){const o=s==null?void 0:s.get(),i=e[e.length-1];if(o!==void 0)e[0]=o;else if(r&&n){const a=r.readValue(n,i);a!=null&&(e[0]=a)}e[0]===void 0&&(e[0]=i),s&&o===void 0&&s.set(e[0])}dj(e)}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(e=!1){this.isComplete=!0,this.onComplete(this.unresolvedKeyframes,this.finalKeyframe,e),$u.delete(this)}cancel(){this.isComplete||(this.isScheduled=!1,$u.delete(this))}resume(){this.isComplete||this.scheduleResolve()}}const bj=t=>t.startsWith("--");function wj(t,e,n){bj(e)?t.style.setProperty(e,n):t.style[e]=n}const Sj=xb(()=>window.ScrollTimeline!==void 0),Cj={};function $j(t,e){const n=xb(t);return()=>Cj[e]??n()}const t_=$j(()=>{try{document.createElement("div").animate({opacity:0},{easing:"linear(0, 1)"})}catch{return!1}return!0},"linearEasing"),Rh=([t,e,n,r])=>`cubic-bezier(${t}, ${e}, ${n}, ${r})`,YT={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:Rh([0,.65,.55,1]),circOut:Rh([.55,0,1,.45]),backIn:Rh([.31,.01,.66,-.59]),backOut:Rh([.33,1.53,.69,.99])};function n_(t,e){if(t)return typeof t=="function"?t_()?qR(t,e):"ease-out":BR(t)?Rh(t):Array.isArray(t)?t.map(n=>n_(n,e)||YT.easeOut):YT[t]}function kj(t,e,n,{delay:r=0,duration:s=300,repeat:o=0,repeatType:i="loop",ease:a="easeOut",times:l}={},c=void 0){const d={[e]:n};l&&(d.offset=l);const f=n_(a,s);Array.isArray(f)&&(d.easing=f);const p={delay:r,duration:s,easing:Array.isArray(f)?"linear":f,fill:"both",iterations:o+1,direction:i==="reverse"?"alternate":"normal"};return c&&(p.pseudoElement=c),t.animate(d,p)}function r_(t){return typeof t=="function"&&"applyToOptions"in t}function Tj({type:t,...e}){return r_(t)&&t_()?t.applyToOptions(e):(e.duration??(e.duration=300),e.ease??(e.ease="easeOut"),e)}class Ij extends Eb{constructor(e){if(super(),this.finishedTime=null,this.isStopped=!1,!e)return;const{element:n,name:r,keyframes:s,pseudoElement:o,allowFlatten:i=!1,finalKeyframe:a,onComplete:l}=e;this.isPseudoElement=!!o,this.allowFlatten=i,this.options=e,yb(typeof e.type!="string");const c=Tj(e);this.animation=kj(n,r,s,c,o),c.autoplay===!1&&this.animation.pause(),this.animation.onfinish=()=>{if(this.finishedTime=this.time,!o){const d=Nb(s,this.options,a,this.speed);this.updateMotionValue?this.updateMotionValue(d):wj(n,r,d),this.animation.cancel()}l==null||l(),this.notifyFinished()},this.animation.oncancel=()=>this.notifyFinished()}play(){this.isStopped||(this.animation.play(),this.state==="finished"&&this.updateFinished())}pause(){this.animation.pause()}complete(){var e,n;(n=(e=this.animation).finish)==null||n.call(e)}cancel(){try{this.animation.cancel()}catch{}}stop(){if(this.isStopped)return;this.isStopped=!0;const{state:e}=this;e==="idle"||e==="finished"||(this.updateMotionValue?this.updateMotionValue():this.commitStyles(),this.isPseudoElement||this.cancel())}commitStyles(){var e,n;this.isPseudoElement||(n=(e=this.animation).commitStyles)==null||n.call(e)}get duration(){var n,r;const e=((r=(n=this.animation.effect)==null?void 0:n.getComputedTiming)==null?void 0:r.call(n).duration)||0;return mi(Number(e))}get time(){return mi(Number(this.animation.currentTime)||0)}set time(e){this.finishedTime=null,this.animation.currentTime=pi(e)}get speed(){return this.animation.playbackRate}set speed(e){e<0&&(this.finishedTime=null),this.animation.playbackRate=e}get state(){return this.finishedTime!==null?"finished":this.animation.playState}get startTime(){return Number(this.animation.startTime)}set startTime(e){this.animation.startTime=e}attachTimeline({timeline:e,observe:n}){var r;return this.allowFlatten&&((r=this.animation.effect)==null||r.updateTiming({easing:"linear"})),this.animation.onfinish=null,e&&Sj()?(this.animation.timeline=e,io):n(this)}}const s_={anticipate:FR,backInOut:DR,circInOut:LR};function Nj(t){return t in s_}function Ej(t){typeof t.ease=="string"&&Nj(t.ease)&&(t.ease=s_[t.ease])}const QT=10;class Rj extends Ij{constructor(e){Ej(e),QR(e),super(e),e.startTime&&(this.startTime=e.startTime),this.options=e}updateMotionValue(e){const{motionValue:n,onUpdate:r,onComplete:s,element:o,...i}=this.options;if(!n)return;if(e!==void 0){n.set(e);return}const a=new ZR({...i,autoplay:!1}),l=pi(this.finishedTime??this.time);n.setWithVelocity(a.sample(l-QT).value,a.sample(l).value,QT),a.stop()}}const ZT=(t,e)=>e==="zIndex"?!1:!!(typeof t=="number"||Array.isArray(t)||typeof t=="string"&&(pl.test(t)||t==="0")&&!t.startsWith("url("));function _j(t){const e=t[0];if(t.length===1)return!0;for(let n=0;n<t.length;n++)if(t[n]!==e)return!0}function Pj(t,e,n,r){const s=t[0];if(s===null)return!1;if(e==="display"||e==="visibility")return!0;const o=t[t.length-1],i=ZT(s,e),a=ZT(o,e);return!i||!a?!1:_j(t)||(n==="spring"||r_(n))&&r}const Aj=new Set(["opacity","clipPath","filter","transform"]),Dj=xb(()=>Object.hasOwnProperty.call(Element.prototype,"animate"));function Fj(t){const{motionValue:e,name:n,repeatDelay:r,repeatType:s,damping:o,type:i}=t;if(!e||!e.owner||!(e.owner.current instanceof HTMLElement))return!1;const{onUpdate:a,transformTemplate:l}=e.owner.getProps();return Dj()&&n&&Aj.has(n)&&(n!=="transform"||!l)&&!a&&!r&&s!=="mirror"&&o!==0&&i!=="inertia"}const Oj=40;class Lj extends Eb{constructor({autoplay:e=!0,delay:n=0,type:r="keyframes",repeat:s=0,repeatDelay:o=0,repeatType:i="loop",keyframes:a,name:l,motionValue:c,element:d,...f}){var y;super(),this.stop=()=>{var x,w;this._animation?(this._animation.stop(),(x=this.stopTimeline)==null||x.call(this)):(w=this.keyframeResolver)==null||w.cancel()},this.createdAt=hs.now();const p={autoplay:e,delay:n,type:r,repeat:s,repeatDelay:o,repeatType:i,name:l,motionValue:c,element:d,...f},g=(d==null?void 0:d.KeyframeResolver)||Rb;this.keyframeResolver=new g(a,(x,w,S)=>this.onKeyframesResolved(x,w,p,!S),l,c,d),(y=this.keyframeResolver)==null||y.scheduleResolve()}onKeyframesResolved(e,n,r,s){this.keyframeResolver=void 0;const{name:o,type:i,velocity:a,delay:l,isHandoff:c,onUpdate:d}=r;this.resolvedAt=hs.now(),Pj(e,o,i,a)||((la.instantAnimations||!l)&&(d==null||d(Nb(e,r,n))),e[0]=e[e.length-1],r.duration=0,r.repeat=0);const p={startTime:s?this.resolvedAt?this.resolvedAt-this.createdAt>Oj?this.resolvedAt:this.createdAt:this.createdAt:void 0,finalKeyframe:n,...r,keyframes:e},g=!c&&Fj(p)?new Rj({...p,element:p.motionValue.owner.current}):new ZR(p);g.finished.then(()=>this.notifyFinished()).catch(io),this.pendingTimeline&&(this.stopTimeline=g.attachTimeline(this.pendingTimeline),this.pendingTimeline=void 0),this._animation=g}get finished(){return this._animation?this.animation.finished:this._finished}then(e,n){return this.finished.finally(e).then(()=>{})}get animation(){return this._animation||vj(),this._animation}get duration(){return this.animation.duration}get time(){return this.animation.time}set time(e){this.animation.time=e}get speed(){return this.animation.speed}get state(){return this.animation.state}set speed(e){this.animation.speed=e}get startTime(){return this.animation.startTime}attachTimeline(e){return this._animation?this.stopTimeline=this.animation.attachTimeline(e):this.pendingTimeline=e,()=>this.stop()}play(){this.animation.play()}pause(){this.animation.pause()}complete(){this.animation.complete()}cancel(){this.animation.cancel()}}const zj=/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;function Bj(t){const e=zj.exec(t);if(!e)return[,];const[,n,r,s]=e;return[`--${n??r}`,s]}function o_(t,e,n=1){const[r,s]=Bj(t);if(!r)return;const o=window.getComputedStyle(e).getPropertyValue(r);if(o){const i=o.trim();return IR(i)?parseFloat(i):i}return Cb(s)?o_(s,e,n+1):s}function _b(t,e){return(t==null?void 0:t[e])??(t==null?void 0:t.default)??t}const i_=new Set(["width","height","top","left","right","bottom",...xd]),Mj={test:t=>t==="auto",parse:t=>t},a_=t=>e=>e.test(t),l_=[yd,rt,gi,nl,_8,R8,Mj],JT=t=>l_.find(a_(t));function Vj(t){return typeof t=="number"?t===0:t!==null?t==="none"||t==="0"||NR(t):!0}const Wj=new Set(["brightness","contrast","saturate","opacity"]);function Uj(t){const[e,n]=t.slice(0,-1).split("(");if(e==="drop-shadow")return t;const[r]=n.match($b)||[];if(!r)return t;const s=n.replace(r,"");let o=Wj.has(e)?1:0;return r!==n&&(o*=100),e+"("+o+s+")"}const jj=/\b([a-z-]*)\(.*?\)/gu,Mx={...pl,getAnimatableNone:t=>{const e=t.match(jj);return e?e.map(Uj).join(" "):t}},eI={...yd,transform:Math.round},Gj={rotate:nl,rotateX:nl,rotateY:nl,rotateZ:nl,scale:ym,scaleX:ym,scaleY:ym,scaleZ:ym,skew:nl,skewX:nl,skewY:nl,distance:rt,translateX:rt,translateY:rt,translateZ:rt,x:rt,y:rt,z:rt,perspective:rt,transformPerspective:rt,opacity:uf,originX:BT,originY:BT,originZ:rt},Pb={borderWidth:rt,borderTopWidth:rt,borderRightWidth:rt,borderBottomWidth:rt,borderLeftWidth:rt,borderRadius:rt,radius:rt,borderTopLeftRadius:rt,borderTopRightRadius:rt,borderBottomRightRadius:rt,borderBottomLeftRadius:rt,width:rt,maxWidth:rt,height:rt,maxHeight:rt,top:rt,right:rt,bottom:rt,left:rt,padding:rt,paddingTop:rt,paddingRight:rt,paddingBottom:rt,paddingLeft:rt,margin:rt,marginTop:rt,marginRight:rt,marginBottom:rt,marginLeft:rt,backgroundPositionX:rt,backgroundPositionY:rt,...Gj,zIndex:eI,fillOpacity:uf,strokeOpacity:uf,numOctaves:eI},Hj={...Pb,color:wr,backgroundColor:wr,outlineColor:wr,fill:wr,stroke:wr,borderColor:wr,borderTopColor:wr,borderRightColor:wr,borderBottomColor:wr,borderLeftColor:wr,filter:Mx,WebkitFilter:Mx},u_=t=>Hj[t];function c_(t,e){let n=u_(t);return n!==Mx&&(n=pl),n.getAnimatableNone?n.getAnimatableNone(e):void 0}const Kj=new Set(["auto","none","0"]);function Xj(t,e,n){let r=0,s;for(;r<t.length&&!s;){const o=t[r];typeof o=="string"&&!Kj.has(o)&&cf(o).values.length&&(s=t[r]),r++}if(s&&n)for(const o of e)t[o]=c_(n,s)}class qj extends Rb{constructor(e,n,r,s,o){super(e,n,r,s,o,!0)}readKeyframes(){const{unresolvedKeyframes:e,element:n,name:r}=this;if(!n||!n.current)return;super.readKeyframes();for(let l=0;l<e.length;l++){let c=e[l];if(typeof c=="string"&&(c=c.trim(),Cb(c))){const d=o_(c,n.current);d!==void 0&&(e[l]=d),l===e.length-1&&(this.finalKeyframe=c)}}if(this.resolveNoneKeyframes(),!i_.has(r)||e.length!==2)return;const[s,o]=e,i=JT(s),a=JT(o);if(i!==a)if(qT(i)&&qT(a))for(let l=0;l<e.length;l++){const c=e[l];typeof c=="string"&&(e[l]=parseFloat(c))}else this.needsMeasurement=!0}resolveNoneKeyframes(){const{unresolvedKeyframes:e,name:n}=this,r=[];for(let s=0;s<e.length;s++)(e[s]===null||Vj(e[s]))&&r.push(s);r.length&&Xj(e,r,n)}measureInitialState(){const{element:e,unresolvedKeyframes:n,name:r}=this;if(!e||!e.current)return;r==="height"&&(this.suspendedScrollY=window.pageYOffset),this.measuredOrigin=sd[r](e.measureViewportBox(),window.getComputedStyle(e.current)),n[0]=this.measuredOrigin;const s=n[n.length-1];s!==void 0&&e.getValue(r,s).jump(s,!1)}measureEndState(){var a;const{element:e,name:n,unresolvedKeyframes:r}=this;if(!e||!e.current)return;const s=e.getValue(n);s&&s.jump(this.measuredOrigin,!1);const o=r.length-1,i=r[o];r[o]=sd[n](e.measureViewportBox(),window.getComputedStyle(e.current)),i!==null&&this.finalKeyframe===void 0&&(this.finalKeyframe=i),(a=this.removedTransforms)!=null&&a.length&&this.removedTransforms.forEach(([l,c])=>{e.getValue(l).set(c)}),this.resolveNoneKeyframes()}}function Yj(t,e,n){if(t instanceof EventTarget)return[t];if(typeof t=="string"){let r=document;const s=(n==null?void 0:n[t])??r.querySelectorAll(t);return s?Array.from(s):[]}return Array.from(t)}const{schedule:Ab}=MR(queueMicrotask,!1),Ro={x:!1,y:!1};function d_(){return Ro.x||Ro.y}function Qj(t){return t==="x"||t==="y"?Ro[t]?null:(Ro[t]=!0,()=>{Ro[t]=!1}):Ro.x||Ro.y?null:(Ro.x=Ro.y=!0,()=>{Ro.x=Ro.y=!1})}function h_(t,e){const n=Yj(t),r=new AbortController,s={passive:!0,...e,signal:r.signal};return[n,s,()=>r.abort()]}function tI(t){return!(t.pointerType==="touch"||d_())}function Zj(t,e,n={}){const[r,s,o]=h_(t,n),i=a=>{if(!tI(a))return;const{target:l}=a,c=e(l,a);if(typeof c!="function"||!l)return;const d=f=>{tI(f)&&(c(f),l.removeEventListener("pointerleave",d))};l.addEventListener("pointerleave",d,s)};return r.forEach(a=>{a.addEventListener("pointerenter",i,s)}),o}const f_=(t,e)=>e?t===e?!0:f_(t,e.parentElement):!1,Db=t=>t.pointerType==="mouse"?typeof t.button!="number"||t.button<=0:t.isPrimary!==!1,Jj=new Set(["BUTTON","INPUT","SELECT","TEXTAREA","A"]);function eG(t){return Jj.has(t.tagName)||t.tabIndex!==-1}const _h=new WeakSet;function nI(t){return e=>{e.key==="Enter"&&t(e)}}function P1(t,e){t.dispatchEvent(new PointerEvent("pointer"+e,{isPrimary:!0,bubbles:!0}))}const tG=(t,e)=>{const n=t.currentTarget;if(!n)return;const r=nI(()=>{if(_h.has(n))return;P1(n,"down");const s=nI(()=>{P1(n,"up")}),o=()=>P1(n,"cancel");n.addEventListener("keyup",s,e),n.addEventListener("blur",o,e)});n.addEventListener("keydown",r,e),n.addEventListener("blur",()=>n.removeEventListener("keydown",r),e)};function rI(t){return Db(t)&&!d_()}function nG(t,e,n={}){const[r,s,o]=h_(t,n),i=a=>{const l=a.currentTarget;if(!rI(a)||_h.has(l))return;_h.add(l);const c=e(l,a),d=(g,y)=>{window.removeEventListener("pointerup",f),window.removeEventListener("pointercancel",p),!(!rI(g)||!_h.has(l))&&(_h.delete(l),typeof c=="function"&&c(g,{success:y}))},f=g=>{d(g,l===window||l===document||n.useGlobalTarget||f_(l,g.target))},p=g=>{d(g,!1)};window.addEventListener("pointerup",f,s),window.addEventListener("pointercancel",p,s)};return r.forEach(a=>{(n.useGlobalTarget?window:a).addEventListener("pointerdown",i,s),a instanceof HTMLElement&&(a.addEventListener("focus",c=>tG(c,s)),!eG(a)&&!a.hasAttribute("tabindex")&&(a.tabIndex=0))}),o}const sI=30,rG=t=>!isNaN(parseFloat(t));class sG{constructor(e,n={}){this.version="12.9.1",this.canTrackVelocity=null,this.events={},this.updateAndNotify=(r,s=!0)=>{var i,a;const o=hs.now();this.updatedAt!==o&&this.setPrevFrameValue(),this.prev=this.current,this.setCurrent(r),this.current!==this.prev&&((i=this.events.change)==null||i.notify(this.current)),s&&((a=this.events.renderRequest)==null||a.notify(this.current))},this.hasAnimated=!1,this.setCurrent(e),this.owner=n.owner}setCurrent(e){this.current=e,this.updatedAt=hs.now(),this.canTrackVelocity===null&&e!==void 0&&(this.canTrackVelocity=rG(this.current))}setPrevFrameValue(e=this.current){this.prevFrameValue=e,this.prevUpdatedAt=this.updatedAt}onChange(e){return this.on("change",e)}on(e,n){this.events[e]||(this.events[e]=new vb);const r=this.events[e].add(n);return e==="change"?()=>{r(),pn.read(()=>{this.events.change.getSize()||this.stop()})}:r}clearListeners(){for(const e in this.events)this.events[e].clear()}attach(e,n){this.passiveEffect=e,this.stopPassiveEffect=n}set(e,n=!0){!n||!this.passiveEffect?this.updateAndNotify(e,n):this.passiveEffect(e,this.updateAndNotify)}setWithVelocity(e,n,r){this.set(n),this.prev=void 0,this.prevFrameValue=e,this.prevUpdatedAt=this.updatedAt-r}jump(e,n=!0){this.updateAndNotify(e),this.prev=e,this.prevUpdatedAt=this.prevFrameValue=void 0,n&&this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}get(){return this.current}getPrevious(){return this.prev}getVelocity(){const e=hs.now();if(!this.canTrackVelocity||this.prevFrameValue===void 0||e-this.updatedAt>sI)return 0;const n=Math.min(this.updatedAt-this.prevUpdatedAt,sI);return ER(parseFloat(this.current)-parseFloat(this.prevFrameValue),n)}start(e){return this.stop(),new Promise(n=>{this.hasAnimated=!0,this.animation=e(n),this.events.animationStart&&this.events.animationStart.notify()}).then(()=>{this.events.animationComplete&&this.events.animationComplete.notify(),this.clearAnimation()})}stop(){this.animation&&(this.animation.stop(),this.events.animationCancel&&this.events.animationCancel.notify()),this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){var e;(e=this.events.destroy)==null||e.notify(),this.clearListeners(),this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}}function df(t,e){return new sG(t,e)}const oG=[...l_,wr,pl],iG=t=>oG.find(a_(t)),p_=(t,e)=>e&&typeof t=="number"?e.transform(t):t,m_=ee.createContext({strict:!1}),oI={animation:["animate","variants","whileHover","whileTap","exit","whileInView","whileFocus","whileDrag"],exit:["exit"],drag:["drag","dragControls"],focus:["whileFocus"],hover:["whileHover","onHoverStart","onHoverEnd"],tap:["whileTap","onTap","onTapStart","onTapCancel"],pan:["onPan","onPanStart","onPanSessionStart","onPanEnd"],inView:["whileInView","onViewportEnter","onViewportLeave"],layout:["layout","layoutId"]},od={};for(const t in oI)od[t]={isEnabled:e=>oI[t].some(n=>!!e[n])};function aG(t){for(const e in t)od[e]={...od[e],...t[e]}}const lG=new Set(["animate","exit","variants","initial","style","values","variants","transition","transformTemplate","custom","inherit","onBeforeLayoutMeasure","onAnimationStart","onAnimationComplete","onUpdate","onDragStart","onDrag","onDragEnd","onMeasureDragConstraints","onDirectionLock","onDragTransitionEnd","_dragX","_dragY","onHoverStart","onHoverEnd","onViewportEnter","onViewportLeave","globalTapTarget","ignoreStrict","viewport"]);function hg(t){return t.startsWith("while")||t.startsWith("drag")&&t!=="draggable"||t.startsWith("layout")||t.startsWith("onTap")||t.startsWith("onPan")||t.startsWith("onLayout")||lG.has(t)}let g_=t=>!hg(t);function uG(t){t&&(g_=e=>e.startsWith("on")?!hg(e):t(e))}try{uG(require("@emotion/is-prop-valid").default)}catch{}function cG(t,e,n){const r={};for(const s in t)s==="values"&&typeof t.values=="object"||(g_(s)||n===!0&&hg(s)||!e&&!hg(s)||t.draggable&&s.startsWith("onDrag"))&&(r[s]=t[s]);return r}function dG(t){if(typeof Proxy>"u")return t;const e=new Map,n=(...r)=>t(...r);return new Proxy(n,{get:(r,s)=>s==="create"?t:(e.has(s)||e.set(s,t(s)),e.get(s))})}const Qg=ee.createContext({});function Zg(t){return t!==null&&typeof t=="object"&&typeof t.start=="function"}function hf(t){return typeof t=="string"||Array.isArray(t)}const Fb=["animate","whileInView","whileFocus","whileHover","whileTap","whileDrag","exit"],Ob=["initial",...Fb];function Jg(t){return Zg(t.animate)||Ob.some(e=>hf(t[e]))}function y_(t){return!!(Jg(t)||t.variants)}function hG(t,e){if(Jg(t)){const{initial:n,animate:r}=t;return{initial:n===!1||hf(n)?n:void 0,animate:hf(r)?r:void 0}}return t.inherit!==!1?e:{}}function fG(t){const{initial:e,animate:n}=hG(t,ee.useContext(Qg));return ee.useMemo(()=>({initial:e,animate:n}),[iI(e),iI(n)])}function iI(t){return Array.isArray(t)?t.join(" "):t}const pG=Symbol.for("motionComponentSymbol");function Mc(t){return t&&typeof t=="object"&&Object.prototype.hasOwnProperty.call(t,"current")}function mG(t,e,n){return ee.useCallback(r=>{r&&t.onMount&&t.onMount(r),e&&(r?e.mount(r):e.unmount()),n&&(typeof n=="function"?n(r):Mc(n)&&(n.current=r))},[e])}const Lb=t=>t.replace(/([a-z])([A-Z])/gu,"$1-$2").toLowerCase(),gG="framerAppearId",x_="data-"+Lb(gG),v_=ee.createContext({});function yG(t,e,n,r,s){var x,w;const{visualElement:o}=ee.useContext(Qg),i=ee.useContext(m_),a=ee.useContext(zf),l=ee.useContext(fb).reducedMotion,c=ee.useRef(null);r=r||i.renderer,!c.current&&r&&(c.current=r(t,{visualState:e,parent:o,props:n,presenceContext:a,blockInitialAnimation:a?a.initial===!1:!1,reducedMotionConfig:l}));const d=c.current,f=ee.useContext(v_);d&&!d.projection&&s&&(d.type==="html"||d.type==="svg")&&xG(c.current,n,s,f);const p=ee.useRef(!1);ee.useInsertionEffect(()=>{d&&p.current&&d.update(n,a)});const g=n[x_],y=ee.useRef(!!g&&!((x=window.MotionHandoffIsComplete)!=null&&x.call(window,g))&&((w=window.MotionHasOptimisedAnimation)==null?void 0:w.call(window,g)));return kR(()=>{d&&(p.current=!0,window.MotionIsMounted=!0,d.updateFeatures(),Ab.render(d.render),y.current&&d.animationState&&d.animationState.animateChanges())}),ee.useEffect(()=>{d&&(!y.current&&d.animationState&&d.animationState.animateChanges(),y.current&&(queueMicrotask(()=>{var S;(S=window.MotionHandoffMarkAsComplete)==null||S.call(window,g)}),y.current=!1))}),d}function xG(t,e,n,r){const{layoutId:s,layout:o,drag:i,dragConstraints:a,layoutScroll:l,layoutRoot:c,layoutCrossfade:d}=e;t.projection=new n(t.latestValues,e["data-framer-portal-id"]?void 0:b_(t.parent)),t.projection.setOptions({layoutId:s,layout:o,alwaysMeasureLayout:!!i||a&&Mc(a),visualElement:t,animationType:typeof o=="string"?o:"both",initialPromotionConfig:r,crossfade:d,layoutScroll:l,layoutRoot:c})}function b_(t){if(t)return t.options.allowProjection!==!1?t.projection:b_(t.parent)}function vG({preloadedFeatures:t,createVisualElement:e,useRender:n,useVisualState:r,Component:s}){t&&aG(t);function o(a,l){let c;const d={...ee.useContext(fb),...a,layoutId:bG(a)},{isStatic:f}=d,p=fG(a),g=r(a,f);if(!f&&hb){wG();const y=SG(d);c=y.MeasureLayout,p.visualElement=yG(s,g,d,e,y.ProjectionNode)}return K.jsxs(Qg.Provider,{value:p,children:[c&&p.visualElement?K.jsx(c,{visualElement:p.visualElement,...d}):null,n(s,a,mG(g,p.visualElement,l),g,f,p.visualElement)]})}o.displayName=`motion.${typeof s=="string"?s:`create(${s.displayName??s.name??""})`}`;const i=ee.forwardRef(o);return i[pG]=s,i}function bG({layoutId:t}){const e=ee.useContext(cb).id;return e&&t!==void 0?e+"-"+t:t}function wG(t,e){ee.useContext(m_).strict}function SG(t){const{drag:e,layout:n}=od;if(!e&&!n)return{};const r={...e,...n};return{MeasureLayout:e!=null&&e.isEnabled(t)||n!=null&&n.isEnabled(t)?r.MeasureLayout:void 0,ProjectionNode:r.ProjectionNode}}const ff={};function CG(t){for(const e in t)ff[e]=t[e],Sb(e)&&(ff[e].isCSSVariable=!0)}function w_(t,{layout:e,layoutId:n}){return vd.has(t)||t.startsWith("origin")||(e||n!==void 0)&&(!!ff[t]||t==="opacity")}const Tr=t=>!!(t&&t.getVelocity),$G={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},kG=xd.length;function TG(t,e,n){let r="",s=!0;for(let o=0;o<kG;o++){const i=xd[o],a=t[i];if(a===void 0)continue;let l=!0;if(typeof a=="number"?l=a===(i.startsWith("scale")?1:0):l=parseFloat(a)===0,!l||n){const c=p_(a,Pb[i]);if(!l){s=!1;const d=$G[i]||i;r+=`${d}(${c}) `}n&&(e[i]=c)}}return r=r.trim(),n?r=n(e,s?"":r):s&&(r="none"),r}function zb(t,e,n){const{style:r,vars:s,transformOrigin:o}=t;let i=!1,a=!1;for(const l in e){const c=e[l];if(vd.has(l)){i=!0;continue}else if(Sb(l)){s[l]=c;continue}else{const d=p_(c,Pb[l]);l.startsWith("origin")?(a=!0,o[l]=d):r[l]=d}}if(e.transform||(i||n?r.transform=TG(e,t.transform,n):r.transform&&(r.transform="none")),a){const{originX:l="50%",originY:c="50%",originZ:d=0}=o;r.transformOrigin=`${l} ${c} ${d}`}}const Bb=()=>({style:{},transform:{},transformOrigin:{},vars:{}});function S_(t,e,n){for(const r in e)!Tr(e[r])&&!w_(r,n)&&(t[r]=e[r])}function IG({transformTemplate:t},e){return ee.useMemo(()=>{const n=Bb();return zb(n,e,t),Object.assign({},n.vars,n.style)},[e])}function NG(t,e){const n=t.style||{},r={};return S_(r,n,t),Object.assign(r,IG(t,e)),r}function EG(t,e){const n={},r=NG(t,e);return t.drag&&t.dragListener!==!1&&(n.draggable=!1,r.userSelect=r.WebkitUserSelect=r.WebkitTouchCallout="none",r.touchAction=t.drag===!0?"none":`pan-${t.drag==="x"?"y":"x"}`),t.tabIndex===void 0&&(t.onTap||t.onTapStart||t.whileTap)&&(n.tabIndex=0),n.style=r,n}const RG=["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","switch","symbol","svg","text","tspan","use","view"];function Mb(t){return typeof t!="string"||t.includes("-")?!1:!!(RG.indexOf(t)>-1||/[A-Z]/u.test(t))}const _G={offset:"stroke-dashoffset",array:"stroke-dasharray"},PG={offset:"strokeDashoffset",array:"strokeDasharray"};function AG(t,e,n=1,r=0,s=!0){t.pathLength=1;const o=s?_G:PG;t[o.offset]=rt.transform(-r);const i=rt.transform(e),a=rt.transform(n);t[o.array]=`${i} ${a}`}function C_(t,{attrX:e,attrY:n,attrScale:r,pathLength:s,pathSpacing:o=1,pathOffset:i=0,...a},l,c){if(zb(t,a,c),l){t.style.viewBox&&(t.attrs.viewBox=t.style.viewBox);return}t.attrs=t.style,t.style={};const{attrs:d,style:f}=t;d.transform&&(f.transform=d.transform,delete d.transform),(f.transform||d.transformOrigin)&&(f.transformOrigin=d.transformOrigin??"50% 50%",delete d.transformOrigin),f.transform&&(f.transformBox="fill-box",delete d.transformBox),e!==void 0&&(d.x=e),n!==void 0&&(d.y=n),r!==void 0&&(d.scale=r),s!==void 0&&AG(d,s,o,i,!1)}const $_=()=>({...Bb(),attrs:{}}),k_=t=>typeof t=="string"&&t.toLowerCase()==="svg";function DG(t,e,n,r){const s=ee.useMemo(()=>{const o=$_();return C_(o,e,k_(r),t.transformTemplate),{...o.attrs,style:{...o.style}}},[e]);if(t.style){const o={};S_(o,t.style,t),s.style={...o,...s.style}}return s}function FG(t=!1){return(n,r,s,{latestValues:o},i)=>{const l=(Mb(n)?DG:EG)(r,o,i,n),c=cG(r,typeof n=="string",t),d=n!==ee.Fragment?{...c,...l,ref:s}:{},{children:f}=r,p=ee.useMemo(()=>Tr(f)?f.get():f,[f]);return ee.createElement(n,{...d,children:p})}}function aI(t){const e=[{},{}];return t==null||t.values.forEach((n,r)=>{e[0][r]=n.get(),e[1][r]=n.getVelocity()}),e}function Vb(t,e,n,r){if(typeof e=="function"){const[s,o]=aI(r);e=e(n!==void 0?n:t.custom,s,o)}if(typeof e=="string"&&(e=t.variants&&t.variants[e]),typeof e=="function"){const[s,o]=aI(r);e=e(n!==void 0?n:t.custom,s,o)}return e}function Um(t){return Tr(t)?t.get():t}function OG({scrapeMotionValuesFromProps:t,createRenderState:e},n,r,s){return{latestValues:LG(n,r,s,t),renderState:e()}}const T_=t=>(e,n)=>{const r=ee.useContext(Qg),s=ee.useContext(zf),o=()=>OG(t,e,r,s);return n?o():db(o)};function LG(t,e,n,r){const s={},o=r(t,{});for(const p in o)s[p]=Um(o[p]);let{initial:i,animate:a}=t;const l=Jg(t),c=y_(t);e&&c&&!l&&t.inherit!==!1&&(i===void 0&&(i=e.initial),a===void 0&&(a=e.animate));let d=n?n.initial===!1:!1;d=d||i===!1;const f=d?a:i;if(f&&typeof f!="boolean"&&!Zg(f)){const p=Array.isArray(f)?f:[f];for(let g=0;g<p.length;g++){const y=Vb(t,p[g]);if(y){const{transitionEnd:x,transition:w,...S}=y;for(const $ in S){let I=S[$];if(Array.isArray(I)){const R=d?I.length-1:0;I=I[R]}I!==null&&(s[$]=I)}for(const $ in x)s[$]=x[$]}}}return s}function Wb(t,e,n){var o;const{style:r}=t,s={};for(const i in r)(Tr(r[i])||e.style&&Tr(e.style[i])||w_(i,t)||((o=n==null?void 0:n.getValue(i))==null?void 0:o.liveStyle)!==void 0)&&(s[i]=r[i]);return s}const zG={useVisualState:T_({scrapeMotionValuesFromProps:Wb,createRenderState:Bb})};function I_(t,e,n){const r=Wb(t,e,n);for(const s in t)if(Tr(t[s])||Tr(e[s])){const o=xd.indexOf(s)!==-1?"attr"+s.charAt(0).toUpperCase()+s.substring(1):s;r[o]=t[s]}return r}const BG={useVisualState:T_({scrapeMotionValuesFromProps:I_,createRenderState:$_})};function MG(t,e){return function(r,{forwardMotionProps:s}={forwardMotionProps:!1}){const i={...Mb(r)?BG:zG,preloadedFeatures:t,useRender:FG(s),createVisualElement:e,Component:r};return vG(i)}}function pf(t,e,n){const r=t.getProps();return Vb(r,e,n!==void 0?n:r.custom,t)}const Vx=t=>Array.isArray(t);function VG(t,e,n){t.hasValue(e)?t.getValue(e).set(n):t.addValue(e,df(n))}function WG(t){return Vx(t)?t[t.length-1]||0:t}function UG(t,e){const n=pf(t,e);let{transitionEnd:r={},transition:s={},...o}=n||{};o={...o,...r};for(const i in o){const a=WG(o[i]);VG(t,i,a)}}function jG(t){return!!(Tr(t)&&t.add)}function Wx(t,e){const n=t.getValue("willChange");if(jG(n))return n.add(e);if(!n&&la.WillChange){const r=new la.WillChange("auto");t.addValue("willChange",r),r.add(e)}}function N_(t){return t.props[x_]}const GG=t=>t!==null;function HG(t,{repeat:e,repeatType:n="loop"},r){const s=t.filter(GG),o=e&&n!=="loop"&&e%2===1?0:s.length-1;return s[o]}const KG={type:"spring",stiffness:500,damping:25,restSpeed:10},XG=t=>({type:"spring",stiffness:550,damping:t===0?2*Math.sqrt(550):30,restSpeed:10}),qG={type:"keyframes",duration:.8},YG={type:"keyframes",ease:[.25,.1,.35,1],duration:.3},QG=(t,{keyframes:e})=>e.length>2?qG:vd.has(t)?t.startsWith("scale")?XG(e[1]):KG:YG;function ZG({when:t,delay:e,delayChildren:n,staggerChildren:r,staggerDirection:s,repeat:o,repeatType:i,repeatDelay:a,from:l,elapsed:c,...d}){return!!Object.keys(d).length}const Ub=(t,e,n,r={},s,o)=>i=>{const a=_b(r,t)||{},l=a.delay||r.delay||0;let{elapsed:c=0}=r;c=c-pi(l);const d={keyframes:Array.isArray(n)?n:[null,n],ease:"easeOut",velocity:e.getVelocity(),...a,delay:-c,onUpdate:p=>{e.set(p),a.onUpdate&&a.onUpdate(p)},onComplete:()=>{i(),a.onComplete&&a.onComplete()},name:t,motionValue:e,element:o?void 0:s};ZG(a)||Object.assign(d,QG(t,d)),d.duration&&(d.duration=pi(d.duration)),d.repeatDelay&&(d.repeatDelay=pi(d.repeatDelay)),d.from!==void 0&&(d.keyframes[0]=d.from);let f=!1;if((d.type===!1||d.duration===0&&!d.repeatDelay)&&(d.duration=0,d.delay===0&&(f=!0)),(la.instantAnimations||la.skipAnimations)&&(f=!0,d.duration=0,d.delay=0),d.allowFlatten=!a.type&&!a.ease,f&&!o&&e.get()!==void 0){const p=HG(d.keyframes,a);if(p!==void 0){pn.update(()=>{d.onUpdate(p),d.onComplete()});return}}return new Lj(d)};function JG({protectedKeys:t,needsAnimating:e},n){const r=t.hasOwnProperty(n)&&e[n]!==!0;return e[n]=!1,r}function E_(t,e,{delay:n=0,transitionOverride:r,type:s}={}){let{transition:o=t.getDefaultTransition(),transitionEnd:i,...a}=e;r&&(o=r);const l=[],c=s&&t.animationState&&t.animationState.getState()[s];for(const d in a){const f=t.getValue(d,t.latestValues[d]??null),p=a[d];if(p===void 0||c&&JG(c,d))continue;const g={delay:n,..._b(o||{},d)},y=f.get();if(y!==void 0&&!f.isAnimating&&!Array.isArray(p)&&p===y&&!g.velocity)continue;let x=!1;if(window.MotionHandoffAnimation){const S=N_(t);if(S){const $=window.MotionHandoffAnimation(S,d,pn);$!==null&&(g.startTime=$,x=!0)}}Wx(t,d),f.start(Ub(d,f,p,t.shouldReduceMotion&&i_.has(d)?{type:!1}:g,t,x));const w=f.animation;w&&l.push(w)}return i&&Promise.all(l).then(()=>{pn.update(()=>{i&&UG(t,i)})}),l}function Ux(t,e,n={}){var l;const r=pf(t,e,n.type==="exit"?(l=t.presenceContext)==null?void 0:l.custom:void 0);let{transition:s=t.getDefaultTransition()||{}}=r||{};n.transitionOverride&&(s=n.transitionOverride);const o=r?()=>Promise.all(E_(t,r,n)):()=>Promise.resolve(),i=t.variantChildren&&t.variantChildren.size?(c=0)=>{const{delayChildren:d=0,staggerChildren:f,staggerDirection:p}=s;return eH(t,e,d+c,f,p,n)}:()=>Promise.resolve(),{when:a}=s;if(a){const[c,d]=a==="beforeChildren"?[o,i]:[i,o];return c().then(()=>d())}else return Promise.all([o(),i(n.delay)])}function eH(t,e,n=0,r=0,s=1,o){const i=[],a=(t.variantChildren.size-1)*r,l=s===1?(c=0)=>c*r:(c=0)=>a-c*r;return Array.from(t.variantChildren).sort(tH).forEach((c,d)=>{c.notify("AnimationStart",e),i.push(Ux(c,e,{...o,delay:n+l(d)}).then(()=>c.notify("AnimationComplete",e)))}),Promise.all(i)}function tH(t,e){return t.sortNodePosition(e)}function nH(t,e,n={}){t.notify("AnimationStart",e);let r;if(Array.isArray(e)){const s=e.map(o=>Ux(t,o,n));r=Promise.all(s)}else if(typeof e=="string")r=Ux(t,e,n);else{const s=typeof e=="function"?pf(t,e,n.custom):e;r=Promise.all(E_(t,s,n))}return r.then(()=>{t.notify("AnimationComplete",e)})}function R_(t,e){if(!Array.isArray(e))return!1;const n=e.length;if(n!==t.length)return!1;for(let r=0;r<n;r++)if(e[r]!==t[r])return!1;return!0}const rH=Ob.length;function __(t){if(!t)return;if(!t.isControllingVariants){const n=t.parent?__(t.parent)||{}:{};return t.props.initial!==void 0&&(n.initial=t.props.initial),n}const e={};for(let n=0;n<rH;n++){const r=Ob[n],s=t.props[r];(hf(s)||s===!1)&&(e[r]=s)}return e}const sH=[...Fb].reverse(),oH=Fb.length;function iH(t){return e=>Promise.all(e.map(({animation:n,options:r})=>nH(t,n,r)))}function aH(t){let e=iH(t),n=lI(),r=!0;const s=l=>(c,d)=>{var p;const f=pf(t,d,l==="exit"?(p=t.presenceContext)==null?void 0:p.custom:void 0);if(f){const{transition:g,transitionEnd:y,...x}=f;c={...c,...x,...y}}return c};function o(l){e=l(t)}function i(l){const{props:c}=t,d=__(t.parent)||{},f=[],p=new Set;let g={},y=1/0;for(let w=0;w<oH;w++){const S=sH[w],$=n[S],I=c[S]!==void 0?c[S]:d[S],R=hf(I),_=S===l?$.isActive:null;_===!1&&(y=w);let F=I===d[S]&&I!==c[S]&&R;if(F&&r&&t.manuallyAnimateOnMount&&(F=!1),$.protectedKeys={...g},!$.isActive&&_===null||!I&&!$.prevProp||Zg(I)||typeof I=="boolean")continue;const O=lH($.prevProp,I);let M=O||S===l&&$.isActive&&!F&&R||w>y&&R,B=!1;const V=Array.isArray(I)?I:[I];let A=V.reduce(s(S),{});_===!1&&(A={});const{prevResolvedValues:re={}}=$,ae={...re,...A},pe=$e=>{M=!0,p.has($e)&&(B=!0,p.delete($e)),$.needsAnimating[$e]=!0;const se=t.getValue($e);se&&(se.liveStyle=!1)};for(const $e in ae){const se=A[$e],me=re[$e];if(g.hasOwnProperty($e))continue;let ge=!1;Vx(se)&&Vx(me)?ge=!R_(se,me):ge=se!==me,ge?se!=null?pe($e):p.add($e):se!==void 0&&p.has($e)?pe($e):$.protectedKeys[$e]=!0}$.prevProp=I,$.prevResolvedValues=A,$.isActive&&(g={...g,...A}),r&&t.blockInitialAnimation&&(M=!1),M&&(!(F&&O)||B)&&f.push(...V.map($e=>({animation:$e,options:{type:S}})))}if(p.size){const w={};if(typeof c.initial!="boolean"){const S=pf(t,Array.isArray(c.initial)?c.initial[0]:c.initial);S&&S.transition&&(w.transition=S.transition)}p.forEach(S=>{const $=t.getBaseTarget(S),I=t.getValue(S);I&&(I.liveStyle=!0),w[S]=$??null}),f.push({animation:w})}let x=!!f.length;return r&&(c.initial===!1||c.initial===c.animate)&&!t.manuallyAnimateOnMount&&(x=!1),r=!1,x?e(f):Promise.resolve()}function a(l,c){var f;if(n[l].isActive===c)return Promise.resolve();(f=t.variantChildren)==null||f.forEach(p=>{var g;return(g=p.animationState)==null?void 0:g.setActive(l,c)}),n[l].isActive=c;const d=i(l);for(const p in n)n[p].protectedKeys={};return d}return{animateChanges:i,setActive:a,setAnimateFunction:o,getState:()=>n,reset:()=>{n=lI(),r=!0}}}function lH(t,e){return typeof e=="string"?e!==t:Array.isArray(e)?!R_(e,t):!1}function nu(t=!1){return{isActive:t,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function lI(){return{animate:nu(!0),whileInView:nu(),whileHover:nu(),whileTap:nu(),whileDrag:nu(),whileFocus:nu(),exit:nu()}}class vl{constructor(e){this.isMounted=!1,this.node=e}update(){}}class uH extends vl{constructor(e){super(e),e.animationState||(e.animationState=aH(e))}updateAnimationControlsSubscription(){const{animate:e}=this.node.getProps();Zg(e)&&(this.unmountControls=e.subscribe(this.node))}mount(){this.updateAnimationControlsSubscription()}update(){const{animate:e}=this.node.getProps(),{animate:n}=this.node.prevProps||{};e!==n&&this.updateAnimationControlsSubscription()}unmount(){var e;this.node.animationState.reset(),(e=this.unmountControls)==null||e.call(this)}}let cH=0;class dH extends vl{constructor(){super(...arguments),this.id=cH++}update(){if(!this.node.presenceContext)return;const{isPresent:e,onExitComplete:n}=this.node.presenceContext,{isPresent:r}=this.node.prevPresenceContext||{};if(!this.node.animationState||e===r)return;const s=this.node.animationState.setActive("exit",!e);n&&!e&&s.then(()=>{n(this.id)})}mount(){const{register:e,onExitComplete:n}=this.node.presenceContext||{};n&&n(this.id),e&&(this.unmount=e(this.id))}unmount(){}}const hH={animation:{Feature:uH},exit:{Feature:dH}};function mf(t,e,n,r={passive:!0}){return t.addEventListener(e,n,r),()=>t.removeEventListener(e,n)}function Wf(t){return{point:{x:t.pageX,y:t.pageY}}}const fH=t=>e=>Db(e)&&t(e,Wf(e));function Xh(t,e,n,r){return mf(t,e,fH(n),r)}function P_({top:t,left:e,right:n,bottom:r}){return{x:{min:e,max:n},y:{min:t,max:r}}}function pH({x:t,y:e}){return{top:e.min,right:t.max,bottom:e.max,left:t.min}}function mH(t,e){if(!e)return t;const n=e({x:t.left,y:t.top}),r=e({x:t.right,y:t.bottom});return{top:n.y,left:n.x,bottom:r.y,right:r.x}}const A_=1e-4,gH=1-A_,yH=1+A_,D_=.01,xH=0-D_,vH=0+D_;function Br(t){return t.max-t.min}function bH(t,e,n){return Math.abs(t-e)<=n}function uI(t,e,n,r=.5){t.origin=r,t.originPoint=fn(e.min,e.max,t.origin),t.scale=Br(n)/Br(e),t.translate=fn(n.min,n.max,t.origin)-t.originPoint,(t.scale>=gH&&t.scale<=yH||isNaN(t.scale))&&(t.scale=1),(t.translate>=xH&&t.translate<=vH||isNaN(t.translate))&&(t.translate=0)}function qh(t,e,n,r){uI(t.x,e.x,n.x,r?r.originX:void 0),uI(t.y,e.y,n.y,r?r.originY:void 0)}function cI(t,e,n){t.min=n.min+e.min,t.max=t.min+Br(e)}function wH(t,e,n){cI(t.x,e.x,n.x),cI(t.y,e.y,n.y)}function dI(t,e,n){t.min=e.min-n.min,t.max=t.min+Br(e)}function Yh(t,e,n){dI(t.x,e.x,n.x),dI(t.y,e.y,n.y)}const hI=()=>({translate:0,scale:1,origin:0,originPoint:0}),Vc=()=>({x:hI(),y:hI()}),fI=()=>({min:0,max:0}),Cn=()=>({x:fI(),y:fI()});function to(t){return[t("x"),t("y")]}function A1(t){return t===void 0||t===1}function jx({scale:t,scaleX:e,scaleY:n}){return!A1(t)||!A1(e)||!A1(n)}function ou(t){return jx(t)||F_(t)||t.z||t.rotate||t.rotateX||t.rotateY||t.skewX||t.skewY}function F_(t){return pI(t.x)||pI(t.y)}function pI(t){return t&&t!=="0%"}function fg(t,e,n){const r=t-n,s=e*r;return n+s}function mI(t,e,n,r,s){return s!==void 0&&(t=fg(t,s,r)),fg(t,n,r)+e}function Gx(t,e=0,n=1,r,s){t.min=mI(t.min,e,n,r,s),t.max=mI(t.max,e,n,r,s)}function O_(t,{x:e,y:n}){Gx(t.x,e.translate,e.scale,e.originPoint),Gx(t.y,n.translate,n.scale,n.originPoint)}const gI=.999999999999,yI=1.0000000000001;function SH(t,e,n,r=!1){const s=n.length;if(!s)return;e.x=e.y=1;let o,i;for(let a=0;a<s;a++){o=n[a],i=o.projectionDelta;const{visualElement:l}=o.options;l&&l.props.style&&l.props.style.display==="contents"||(r&&o.options.layoutScroll&&o.scroll&&o!==o.root&&Uc(t,{x:-o.scroll.offset.x,y:-o.scroll.offset.y}),i&&(e.x*=i.x.scale,e.y*=i.y.scale,O_(t,i)),r&&ou(o.latestValues)&&Uc(t,o.latestValues))}e.x<yI&&e.x>gI&&(e.x=1),e.y<yI&&e.y>gI&&(e.y=1)}function Wc(t,e){t.min=t.min+e,t.max=t.max+e}function xI(t,e,n,r,s=.5){const o=fn(t.min,t.max,s);Gx(t,e,n,o,r)}function Uc(t,e){xI(t.x,e.x,e.scaleX,e.scale,e.originX),xI(t.y,e.y,e.scaleY,e.scale,e.originY)}function L_(t,e){return P_(mH(t.getBoundingClientRect(),e))}function CH(t,e,n){const r=L_(t,n),{scroll:s}=e;return s&&(Wc(r.x,s.offset.x),Wc(r.y,s.offset.y)),r}const z_=({current:t})=>t?t.ownerDocument.defaultView:null,vI=(t,e)=>Math.abs(t-e);function $H(t,e){const n=vI(t.x,e.x),r=vI(t.y,e.y);return Math.sqrt(n**2+r**2)}class B_{constructor(e,n,{transformPagePoint:r,contextWindow:s,dragSnapToOrigin:o=!1}={}){if(this.startEvent=null,this.lastMoveEvent=null,this.lastMoveEventInfo=null,this.handlers={},this.contextWindow=window,this.updatePoint=()=>{if(!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const f=F1(this.lastMoveEventInfo,this.history),p=this.startEvent!==null,g=$H(f.offset,{x:0,y:0})>=3;if(!p&&!g)return;const{point:y}=f,{timestamp:x}=ir;this.history.push({...y,timestamp:x});const{onStart:w,onMove:S}=this.handlers;p||(w&&w(this.lastMoveEvent,f),this.startEvent=this.lastMoveEvent),S&&S(this.lastMoveEvent,f)},this.handlePointerMove=(f,p)=>{this.lastMoveEvent=f,this.lastMoveEventInfo=D1(p,this.transformPagePoint),pn.update(this.updatePoint,!0)},this.handlePointerUp=(f,p)=>{this.end();const{onEnd:g,onSessionEnd:y,resumeAnimation:x}=this.handlers;if(this.dragSnapToOrigin&&x&&x(),!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const w=F1(f.type==="pointercancel"?this.lastMoveEventInfo:D1(p,this.transformPagePoint),this.history);this.startEvent&&g&&g(f,w),y&&y(f,w)},!Db(e))return;this.dragSnapToOrigin=o,this.handlers=n,this.transformPagePoint=r,this.contextWindow=s||window;const i=Wf(e),a=D1(i,this.transformPagePoint),{point:l}=a,{timestamp:c}=ir;this.history=[{...l,timestamp:c}];const{onSessionStart:d}=n;d&&d(e,F1(a,this.history)),this.removeListeners=Bf(Xh(this.contextWindow,"pointermove",this.handlePointerMove),Xh(this.contextWindow,"pointerup",this.handlePointerUp),Xh(this.contextWindow,"pointercancel",this.handlePointerUp))}updateHandlers(e){this.handlers=e}end(){this.removeListeners&&this.removeListeners(),fl(this.updatePoint)}}function D1(t,e){return e?{point:e(t.point)}:t}function bI(t,e){return{x:t.x-e.x,y:t.y-e.y}}function F1({point:t},e){return{point:t,delta:bI(t,M_(e)),offset:bI(t,kH(e)),velocity:TH(e,.1)}}function kH(t){return t[0]}function M_(t){return t[t.length-1]}function TH(t,e){if(t.length<2)return{x:0,y:0};let n=t.length-1,r=null;const s=M_(t);for(;n>=0&&(r=t[n],!(s.timestamp-r.timestamp>pi(e)));)n--;if(!r)return{x:0,y:0};const o=mi(s.timestamp-r.timestamp);if(o===0)return{x:0,y:0};const i={x:(s.x-r.x)/o,y:(s.y-r.y)/o};return i.x===1/0&&(i.x=0),i.y===1/0&&(i.y=0),i}function IH(t,{min:e,max:n},r){return e!==void 0&&t<e?t=r?fn(e,t,r.min):Math.max(t,e):n!==void 0&&t>n&&(t=r?fn(n,t,r.max):Math.min(t,n)),t}function wI(t,e,n){return{min:e!==void 0?t.min+e:void 0,max:n!==void 0?t.max+n-(t.max-t.min):void 0}}function NH(t,{top:e,left:n,bottom:r,right:s}){return{x:wI(t.x,n,s),y:wI(t.y,e,r)}}function SI(t,e){let n=e.min-t.min,r=e.max-t.max;return e.max-e.min<t.max-t.min&&([n,r]=[r,n]),{min:n,max:r}}function EH(t,e){return{x:SI(t.x,e.x),y:SI(t.y,e.y)}}function RH(t,e){let n=.5;const r=Br(t),s=Br(e);return s>r?n=lf(e.min,e.max-r,t.min):r>s&&(n=lf(t.min,t.max-s,e.min)),aa(0,1,n)}function _H(t,e){const n={};return e.min!==void 0&&(n.min=e.min-t.min),e.max!==void 0&&(n.max=e.max-t.min),n}const Hx=.35;function PH(t=Hx){return t===!1?t=0:t===!0&&(t=Hx),{x:CI(t,"left","right"),y:CI(t,"top","bottom")}}function CI(t,e,n){return{min:$I(t,e),max:$I(t,n)}}function $I(t,e){return typeof t=="number"?t:t[e]||0}const AH=new WeakMap;class DH{constructor(e){this.openDragLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic=Cn(),this.visualElement=e}start(e,{snapToCursor:n=!1}={}){const{presenceContext:r}=this.visualElement;if(r&&r.isPresent===!1)return;const s=d=>{const{dragSnapToOrigin:f}=this.getProps();f?this.pauseAnimation():this.stopAnimation(),n&&this.snapToCursor(Wf(d).point)},o=(d,f)=>{const{drag:p,dragPropagation:g,onDragStart:y}=this.getProps();if(p&&!g&&(this.openDragLock&&this.openDragLock(),this.openDragLock=Qj(p),!this.openDragLock))return;this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),to(w=>{let S=this.getAxisMotionValue(w).get()||0;if(gi.test(S)){const{projection:$}=this.visualElement;if($&&$.layout){const I=$.layout.layoutBox[w];I&&(S=Br(I)*(parseFloat(S)/100))}}this.originPoint[w]=S}),y&&pn.postRender(()=>y(d,f)),Wx(this.visualElement,"transform");const{animationState:x}=this.visualElement;x&&x.setActive("whileDrag",!0)},i=(d,f)=>{const{dragPropagation:p,dragDirectionLock:g,onDirectionLock:y,onDrag:x}=this.getProps();if(!p&&!this.openDragLock)return;const{offset:w}=f;if(g&&this.currentDirection===null){this.currentDirection=FH(w),this.currentDirection!==null&&y&&y(this.currentDirection);return}this.updateAxis("x",f.point,w),this.updateAxis("y",f.point,w),this.visualElement.render(),x&&x(d,f)},a=(d,f)=>this.stop(d,f),l=()=>to(d=>{var f;return this.getAnimationState(d)==="paused"&&((f=this.getAxisMotionValue(d).animation)==null?void 0:f.play())}),{dragSnapToOrigin:c}=this.getProps();this.panSession=new B_(e,{onSessionStart:s,onStart:o,onMove:i,onSessionEnd:a,resumeAnimation:l},{transformPagePoint:this.visualElement.getTransformPagePoint(),dragSnapToOrigin:c,contextWindow:z_(this.visualElement)})}stop(e,n){const r=this.isDragging;if(this.cancel(),!r)return;const{velocity:s}=n;this.startAnimation(s);const{onDragEnd:o}=this.getProps();o&&pn.postRender(()=>o(e,n))}cancel(){this.isDragging=!1;const{projection:e,animationState:n}=this.visualElement;e&&(e.isAnimationBlocked=!1),this.panSession&&this.panSession.end(),this.panSession=void 0;const{dragPropagation:r}=this.getProps();!r&&this.openDragLock&&(this.openDragLock(),this.openDragLock=null),n&&n.setActive("whileDrag",!1)}updateAxis(e,n,r){const{drag:s}=this.getProps();if(!r||!xm(e,s,this.currentDirection))return;const o=this.getAxisMotionValue(e);let i=this.originPoint[e]+r[e];this.constraints&&this.constraints[e]&&(i=IH(i,this.constraints[e],this.elastic[e])),o.set(i)}resolveConstraints(){var o;const{dragConstraints:e,dragElastic:n}=this.getProps(),r=this.visualElement.projection&&!this.visualElement.projection.layout?this.visualElement.projection.measure(!1):(o=this.visualElement.projection)==null?void 0:o.layout,s=this.constraints;e&&Mc(e)?this.constraints||(this.constraints=this.resolveRefConstraints()):e&&r?this.constraints=NH(r.layoutBox,e):this.constraints=!1,this.elastic=PH(n),s!==this.constraints&&r&&this.constraints&&!this.hasMutatedConstraints&&to(i=>{this.constraints!==!1&&this.getAxisMotionValue(i)&&(this.constraints[i]=_H(r.layoutBox[i],this.constraints[i]))})}resolveRefConstraints(){const{dragConstraints:e,onMeasureDragConstraints:n}=this.getProps();if(!e||!Mc(e))return!1;const r=e.current,{projection:s}=this.visualElement;if(!s||!s.layout)return!1;const o=CH(r,s.root,this.visualElement.getTransformPagePoint());let i=EH(s.layout.layoutBox,o);if(n){const a=n(pH(i));this.hasMutatedConstraints=!!a,a&&(i=P_(a))}return i}startAnimation(e){const{drag:n,dragMomentum:r,dragElastic:s,dragTransition:o,dragSnapToOrigin:i,onDragTransitionEnd:a}=this.getProps(),l=this.constraints||{},c=to(d=>{if(!xm(d,n,this.currentDirection))return;let f=l&&l[d]||{};i&&(f={min:0,max:0});const p=s?200:1e6,g=s?40:1e7,y={type:"inertia",velocity:r?e[d]:0,bounceStiffness:p,bounceDamping:g,timeConstant:750,restDelta:1,restSpeed:10,...o,...f};return this.startAxisValueAnimation(d,y)});return Promise.all(c).then(a)}startAxisValueAnimation(e,n){const r=this.getAxisMotionValue(e);return Wx(this.visualElement,e),r.start(Ub(e,r,0,n,this.visualElement,!1))}stopAnimation(){to(e=>this.getAxisMotionValue(e).stop())}pauseAnimation(){to(e=>{var n;return(n=this.getAxisMotionValue(e).animation)==null?void 0:n.pause()})}getAnimationState(e){var n;return(n=this.getAxisMotionValue(e).animation)==null?void 0:n.state}getAxisMotionValue(e){const n=`_drag${e.toUpperCase()}`,r=this.visualElement.getProps(),s=r[n];return s||this.visualElement.getValue(e,(r.initial?r.initial[e]:void 0)||0)}snapToCursor(e){to(n=>{const{drag:r}=this.getProps();if(!xm(n,r,this.currentDirection))return;const{projection:s}=this.visualElement,o=this.getAxisMotionValue(n);if(s&&s.layout){const{min:i,max:a}=s.layout.layoutBox[n];o.set(e[n]-fn(i,a,.5))}})}scalePositionWithinConstraints(){if(!this.visualElement.current)return;const{drag:e,dragConstraints:n}=this.getProps(),{projection:r}=this.visualElement;if(!Mc(n)||!r||!this.constraints)return;this.stopAnimation();const s={x:0,y:0};to(i=>{const a=this.getAxisMotionValue(i);if(a&&this.constraints!==!1){const l=a.get();s[i]=RH({min:l,max:l},this.constraints[i])}});const{transformTemplate:o}=this.visualElement.getProps();this.visualElement.current.style.transform=o?o({},""):"none",r.root&&r.root.updateScroll(),r.updateLayout(),this.resolveConstraints(),to(i=>{if(!xm(i,e,null))return;const a=this.getAxisMotionValue(i),{min:l,max:c}=this.constraints[i];a.set(fn(l,c,s[i]))})}addListeners(){if(!this.visualElement.current)return;AH.set(this.visualElement,this);const e=this.visualElement.current,n=Xh(e,"pointerdown",l=>{const{drag:c,dragListener:d=!0}=this.getProps();c&&d&&this.start(l)}),r=()=>{const{dragConstraints:l}=this.getProps();Mc(l)&&l.current&&(this.constraints=this.resolveRefConstraints())},{projection:s}=this.visualElement,o=s.addEventListener("measure",r);s&&!s.layout&&(s.root&&s.root.updateScroll(),s.updateLayout()),pn.read(r);const i=mf(window,"resize",()=>this.scalePositionWithinConstraints()),a=s.addEventListener("didUpdate",({delta:l,hasLayoutChanged:c})=>{this.isDragging&&c&&(to(d=>{const f=this.getAxisMotionValue(d);f&&(this.originPoint[d]+=l[d].translate,f.set(f.get()+l[d].translate))}),this.visualElement.render())});return()=>{i(),n(),o(),a&&a()}}getProps(){const e=this.visualElement.getProps(),{drag:n=!1,dragDirectionLock:r=!1,dragPropagation:s=!1,dragConstraints:o=!1,dragElastic:i=Hx,dragMomentum:a=!0}=e;return{...e,drag:n,dragDirectionLock:r,dragPropagation:s,dragConstraints:o,dragElastic:i,dragMomentum:a}}}function xm(t,e,n){return(e===!0||e===t)&&(n===null||n===t)}function FH(t,e=10){let n=null;return Math.abs(t.y)>e?n="y":Math.abs(t.x)>e&&(n="x"),n}class OH extends vl{constructor(e){super(e),this.removeGroupControls=io,this.removeListeners=io,this.controls=new DH(e)}mount(){const{dragControls:e}=this.node.getProps();e&&(this.removeGroupControls=e.subscribe(this.controls)),this.removeListeners=this.controls.addListeners()||io}unmount(){this.removeGroupControls(),this.removeListeners()}}const kI=t=>(e,n)=>{t&&pn.postRender(()=>t(e,n))};class LH extends vl{constructor(){super(...arguments),this.removePointerDownListener=io}onPointerDown(e){this.session=new B_(e,this.createPanHandlers(),{transformPagePoint:this.node.getTransformPagePoint(),contextWindow:z_(this.node)})}createPanHandlers(){const{onPanSessionStart:e,onPanStart:n,onPan:r,onPanEnd:s}=this.node.getProps();return{onSessionStart:kI(e),onStart:kI(n),onMove:r,onEnd:(o,i)=>{delete this.session,s&&pn.postRender(()=>s(o,i))}}}mount(){this.removePointerDownListener=Xh(this.node.current,"pointerdown",e=>this.onPointerDown(e))}update(){this.session&&this.session.updateHandlers(this.createPanHandlers())}unmount(){this.removePointerDownListener(),this.session&&this.session.end()}}const jm={hasAnimatedSinceResize:!0,hasEverUpdated:!1};function TI(t,e){return e.max===e.min?0:t/(e.max-e.min)*100}const vh={correct:(t,e)=>{if(!e.target)return t;if(typeof t=="string")if(rt.test(t))t=parseFloat(t);else return t;const n=TI(t,e.target.x),r=TI(t,e.target.y);return`${n}% ${r}%`}},zH={correct:(t,{treeScale:e,projectionDelta:n})=>{const r=t,s=pl.parse(t);if(s.length>5)return r;const o=pl.createTransformer(t),i=typeof s[0]!="number"?1:0,a=n.x.scale*e.x,l=n.y.scale*e.y;s[0+i]/=a,s[1+i]/=l;const c=fn(a,l,.5);return typeof s[2+i]=="number"&&(s[2+i]/=c),typeof s[3+i]=="number"&&(s[3+i]/=c),o(s)}};class BH extends ee.Component{componentDidMount(){const{visualElement:e,layoutGroup:n,switchLayoutGroup:r,layoutId:s}=this.props,{projection:o}=e;CG(MH),o&&(n.group&&n.group.add(o),r&&r.register&&s&&r.register(o),o.root.didUpdate(),o.addEventListener("animationComplete",()=>{this.safeToRemove()}),o.setOptions({...o.options,onExitComplete:()=>this.safeToRemove()})),jm.hasEverUpdated=!0}getSnapshotBeforeUpdate(e){const{layoutDependency:n,visualElement:r,drag:s,isPresent:o}=this.props,i=r.projection;return i&&(i.isPresent=o,s||e.layoutDependency!==n||n===void 0||e.isPresent!==o?i.willUpdate():this.safeToRemove(),e.isPresent!==o&&(o?i.promote():i.relegate()||pn.postRender(()=>{const a=i.getStack();(!a||!a.members.length)&&this.safeToRemove()}))),null}componentDidUpdate(){const{projection:e}=this.props.visualElement;e&&(e.root.didUpdate(),Ab.postRender(()=>{!e.currentAnimation&&e.isLead()&&this.safeToRemove()}))}componentWillUnmount(){const{visualElement:e,layoutGroup:n,switchLayoutGroup:r}=this.props,{projection:s}=e;s&&(s.scheduleCheckAfterUnmount(),n&&n.group&&n.group.remove(s),r&&r.deregister&&r.deregister(s))}safeToRemove(){const{safeToRemove:e}=this.props;e&&e()}render(){return null}}function V_(t){const[e,n]=TR(),r=ee.useContext(cb);return K.jsx(BH,{...t,layoutGroup:r,switchLayoutGroup:ee.useContext(v_),isPresent:e,safeToRemove:n})}const MH={borderRadius:{...vh,applyTo:["borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]},borderTopLeftRadius:vh,borderTopRightRadius:vh,borderBottomLeftRadius:vh,borderBottomRightRadius:vh,boxShadow:zH};function VH(t,e,n){const r=Tr(t)?t:df(t);return r.start(Ub("",r,e,n)),r.animation}function WH(t){return t instanceof SVGElement&&t.tagName!=="svg"}const UH=(t,e)=>t.depth-e.depth;class jH{constructor(){this.children=[],this.isDirty=!1}add(e){mb(this.children,e),this.isDirty=!0}remove(e){gb(this.children,e),this.isDirty=!0}forEach(e){this.isDirty&&this.children.sort(UH),this.isDirty=!1,this.children.forEach(e)}}function GH(t,e){const n=hs.now(),r=({timestamp:s})=>{const o=s-n;o>=e&&(fl(r),t(o-e))};return pn.setup(r,!0),()=>fl(r)}const W_=["TopLeft","TopRight","BottomLeft","BottomRight"],HH=W_.length,II=t=>typeof t=="string"?parseFloat(t):t,NI=t=>typeof t=="number"||rt.test(t);function KH(t,e,n,r,s,o){s?(t.opacity=fn(0,n.opacity??1,XH(r)),t.opacityExit=fn(e.opacity??1,0,qH(r))):o&&(t.opacity=fn(e.opacity??1,n.opacity??1,r));for(let i=0;i<HH;i++){const a=`border${W_[i]}Radius`;let l=EI(e,a),c=EI(n,a);if(l===void 0&&c===void 0)continue;l||(l=0),c||(c=0),l===0||c===0||NI(l)===NI(c)?(t[a]=Math.max(fn(II(l),II(c),r),0),(gi.test(c)||gi.test(l))&&(t[a]+="%")):t[a]=c}(e.rotate||n.rotate)&&(t.rotate=fn(e.rotate||0,n.rotate||0,r))}function EI(t,e){return t[e]!==void 0?t[e]:t.borderRadius}const XH=U_(0,.5,OR),qH=U_(.5,.95,io);function U_(t,e,n){return r=>r<t?0:r>e?1:n(lf(t,e,r))}function RI(t,e){t.min=e.min,t.max=e.max}function Zs(t,e){RI(t.x,e.x),RI(t.y,e.y)}function _I(t,e){t.translate=e.translate,t.scale=e.scale,t.originPoint=e.originPoint,t.origin=e.origin}function PI(t,e,n,r,s){return t-=e,t=fg(t,1/n,r),s!==void 0&&(t=fg(t,1/s,r)),t}function YH(t,e=0,n=1,r=.5,s,o=t,i=t){if(gi.test(e)&&(e=parseFloat(e),e=fn(i.min,i.max,e/100)-i.min),typeof e!="number")return;let a=fn(o.min,o.max,r);t===o&&(a-=e),t.min=PI(t.min,e,n,a,s),t.max=PI(t.max,e,n,a,s)}function AI(t,e,[n,r,s],o,i){YH(t,e[n],e[r],e[s],e.scale,o,i)}const QH=["x","scaleX","originX"],ZH=["y","scaleY","originY"];function DI(t,e,n,r){AI(t.x,e,QH,n?n.x:void 0,r?r.x:void 0),AI(t.y,e,ZH,n?n.y:void 0,r?r.y:void 0)}function FI(t){return t.translate===0&&t.scale===1}function j_(t){return FI(t.x)&&FI(t.y)}function OI(t,e){return t.min===e.min&&t.max===e.max}function JH(t,e){return OI(t.x,e.x)&&OI(t.y,e.y)}function LI(t,e){return Math.round(t.min)===Math.round(e.min)&&Math.round(t.max)===Math.round(e.max)}function G_(t,e){return LI(t.x,e.x)&&LI(t.y,e.y)}function zI(t){return Br(t.x)/Br(t.y)}function BI(t,e){return t.translate===e.translate&&t.scale===e.scale&&t.originPoint===e.originPoint}class e9{constructor(){this.members=[]}add(e){mb(this.members,e),e.scheduleRender()}remove(e){if(gb(this.members,e),e===this.prevLead&&(this.prevLead=void 0),e===this.lead){const n=this.members[this.members.length-1];n&&this.promote(n)}}relegate(e){const n=this.members.findIndex(s=>e===s);if(n===0)return!1;let r;for(let s=n;s>=0;s--){const o=this.members[s];if(o.isPresent!==!1){r=o;break}}return r?(this.promote(r),!0):!1}promote(e,n){const r=this.lead;if(e!==r&&(this.prevLead=r,this.lead=e,e.show(),r)){r.instance&&r.scheduleRender(),e.scheduleRender(),e.resumeFrom=r,n&&(e.resumeFrom.preserveOpacity=!0),r.snapshot&&(e.snapshot=r.snapshot,e.snapshot.latestValues=r.animationValues||r.latestValues),e.root&&e.root.isUpdating&&(e.isLayoutDirty=!0);const{crossfade:s}=e.options;s===!1&&r.hide()}}exitAnimationComplete(){this.members.forEach(e=>{const{options:n,resumingFrom:r}=e;n.onExitComplete&&n.onExitComplete(),r&&r.options.onExitComplete&&r.options.onExitComplete()})}scheduleRender(){this.members.forEach(e=>{e.instance&&e.scheduleRender(!1)})}removeLeadSnapshot(){this.lead&&this.lead.snapshot&&(this.lead.snapshot=void 0)}}function t9(t,e,n){let r="";const s=t.x.translate/e.x,o=t.y.translate/e.y,i=(n==null?void 0:n.z)||0;if((s||o||i)&&(r=`translate3d(${s}px, ${o}px, ${i}px) `),(e.x!==1||e.y!==1)&&(r+=`scale(${1/e.x}, ${1/e.y}) `),n){const{transformPerspective:c,rotate:d,rotateX:f,rotateY:p,skewX:g,skewY:y}=n;c&&(r=`perspective(${c}px) ${r}`),d&&(r+=`rotate(${d}deg) `),f&&(r+=`rotateX(${f}deg) `),p&&(r+=`rotateY(${p}deg) `),g&&(r+=`skewX(${g}deg) `),y&&(r+=`skewY(${y}deg) `)}const a=t.x.scale*e.x,l=t.y.scale*e.y;return(a!==1||l!==1)&&(r+=`scale(${a}, ${l})`),r||"none"}const O1=["","X","Y","Z"],n9={visibility:"hidden"},MI=1e3;let r9=0;function L1(t,e,n,r){const{latestValues:s}=e;s[t]&&(n[t]=s[t],e.setStaticValue(t,0),r&&(r[t]=0))}function H_(t){if(t.hasCheckedOptimisedAppear=!0,t.root===t)return;const{visualElement:e}=t.options;if(!e)return;const n=N_(e);if(window.MotionHasOptimisedAnimation(n,"transform")){const{layout:s,layoutId:o}=t.options;window.MotionCancelOptimisedAnimation(n,"transform",pn,!(s||o))}const{parent:r}=t;r&&!r.hasCheckedOptimisedAppear&&H_(r)}function K_({attachResizeListener:t,defaultParent:e,measureScroll:n,checkIsScrollRoot:r,resetTransform:s}){return class{constructor(i={},a=e==null?void 0:e()){this.id=r9++,this.animationId=0,this.children=new Set,this.options={},this.isTreeAnimating=!1,this.isAnimationBlocked=!1,this.isLayoutDirty=!1,this.isProjectionDirty=!1,this.isSharedProjectionDirty=!1,this.isTransformDirty=!1,this.updateManuallyBlocked=!1,this.updateBlockedByResize=!1,this.isUpdating=!1,this.isSVG=!1,this.needsReset=!1,this.shouldResetTransform=!1,this.hasCheckedOptimisedAppear=!1,this.treeScale={x:1,y:1},this.eventHandlers=new Map,this.hasTreeAnimated=!1,this.updateScheduled=!1,this.scheduleUpdate=()=>this.update(),this.projectionUpdateScheduled=!1,this.checkUpdateFailed=()=>{this.isUpdating&&(this.isUpdating=!1,this.clearAllSnapshots())},this.updateProjection=()=>{this.projectionUpdateScheduled=!1,this.nodes.forEach(i9),this.nodes.forEach(d9),this.nodes.forEach(h9),this.nodes.forEach(a9)},this.resolvedRelativeTargetAt=0,this.hasProjected=!1,this.isVisible=!0,this.animationProgress=0,this.sharedNodes=new Map,this.latestValues=i,this.root=a?a.root||a:this,this.path=a?[...a.path,a]:[],this.parent=a,this.depth=a?a.depth+1:0;for(let l=0;l<this.path.length;l++)this.path[l].shouldResetTransform=!0;this.root===this&&(this.nodes=new jH)}addEventListener(i,a){return this.eventHandlers.has(i)||this.eventHandlers.set(i,new vb),this.eventHandlers.get(i).add(a)}notifyListeners(i,...a){const l=this.eventHandlers.get(i);l&&l.notify(...a)}hasListeners(i){return this.eventHandlers.has(i)}mount(i,a=this.root.hasTreeAnimated){if(this.instance)return;this.isSVG=WH(i),this.instance=i;const{layoutId:l,layout:c,visualElement:d}=this.options;if(d&&!d.current&&d.mount(i),this.root.nodes.add(this),this.parent&&this.parent.children.add(this),a&&(c||l)&&(this.isLayoutDirty=!0),t){let f;const p=()=>this.root.updateBlockedByResize=!1;t(i,()=>{this.root.updateBlockedByResize=!0,f&&f(),f=GH(p,250),jm.hasAnimatedSinceResize&&(jm.hasAnimatedSinceResize=!1,this.nodes.forEach(WI))})}l&&this.root.registerSharedNode(l,this),this.options.animate!==!1&&d&&(l||c)&&this.addEventListener("didUpdate",({delta:f,hasLayoutChanged:p,hasRelativeLayoutChanged:g,layout:y})=>{if(this.isTreeAnimationBlocked()){this.target=void 0,this.relativeTarget=void 0;return}const x=this.options.transition||d.getDefaultTransition()||y9,{onLayoutAnimationStart:w,onLayoutAnimationComplete:S}=d.getProps(),$=!this.targetLayout||!G_(this.targetLayout,y),I=!p&&g;if(this.options.layoutRoot||this.resumeFrom||I||p&&($||!this.currentAnimation)){this.resumeFrom&&(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0),this.setAnimationOrigin(f,I);const R={..._b(x,"layout"),onPlay:w,onComplete:S};(d.shouldReduceMotion||this.options.layoutRoot)&&(R.delay=0,R.type=!1),this.startAnimation(R)}else p||WI(this),this.isLead()&&this.options.onExitComplete&&this.options.onExitComplete();this.targetLayout=y})}unmount(){this.options.layoutId&&this.willUpdate(),this.root.nodes.remove(this);const i=this.getStack();i&&i.remove(this),this.parent&&this.parent.children.delete(this),this.instance=void 0,fl(this.updateProjection)}blockUpdate(){this.updateManuallyBlocked=!0}unblockUpdate(){this.updateManuallyBlocked=!1}isUpdateBlocked(){return this.updateManuallyBlocked||this.updateBlockedByResize}isTreeAnimationBlocked(){return this.isAnimationBlocked||this.parent&&this.parent.isTreeAnimationBlocked()||!1}startUpdate(){this.isUpdateBlocked()||(this.isUpdating=!0,this.nodes&&this.nodes.forEach(f9),this.animationId++)}getTransformTemplate(){const{visualElement:i}=this.options;return i&&i.getProps().transformTemplate}willUpdate(i=!0){if(this.root.hasTreeAnimated=!0,this.root.isUpdateBlocked()){this.options.onExitComplete&&this.options.onExitComplete();return}if(window.MotionCancelOptimisedAnimation&&!this.hasCheckedOptimisedAppear&&H_(this),!this.root.isUpdating&&this.root.startUpdate(),this.isLayoutDirty)return;this.isLayoutDirty=!0;for(let d=0;d<this.path.length;d++){const f=this.path[d];f.shouldResetTransform=!0,f.updateScroll("snapshot"),f.options.layoutRoot&&f.willUpdate(!1)}const{layoutId:a,layout:l}=this.options;if(a===void 0&&!l)return;const c=this.getTransformTemplate();this.prevTransformTemplateValue=c?c(this.latestValues,""):void 0,this.updateSnapshot(),i&&this.notifyListeners("willUpdate")}update(){if(this.updateScheduled=!1,this.isUpdateBlocked()){this.unblockUpdate(),this.clearAllSnapshots(),this.nodes.forEach(VI);return}this.isUpdating||this.nodes.forEach(u9),this.isUpdating=!1,this.nodes.forEach(c9),this.nodes.forEach(s9),this.nodes.forEach(o9),this.clearAllSnapshots();const a=hs.now();ir.delta=aa(0,1e3/60,a-ir.timestamp),ir.timestamp=a,ir.isProcessing=!0,N1.update.process(ir),N1.preRender.process(ir),N1.render.process(ir),ir.isProcessing=!1}didUpdate(){this.updateScheduled||(this.updateScheduled=!0,Ab.read(this.scheduleUpdate))}clearAllSnapshots(){this.nodes.forEach(l9),this.sharedNodes.forEach(p9)}scheduleUpdateProjection(){this.projectionUpdateScheduled||(this.projectionUpdateScheduled=!0,pn.preRender(this.updateProjection,!1,!0))}scheduleCheckAfterUnmount(){pn.postRender(()=>{this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()})}updateSnapshot(){this.snapshot||!this.instance||(this.snapshot=this.measure(),this.snapshot&&!Br(this.snapshot.measuredBox.x)&&!Br(this.snapshot.measuredBox.y)&&(this.snapshot=void 0))}updateLayout(){if(!this.instance||(this.updateScroll(),!(this.options.alwaysMeasureLayout&&this.isLead())&&!this.isLayoutDirty))return;if(this.resumeFrom&&!this.resumeFrom.instance)for(let l=0;l<this.path.length;l++)this.path[l].updateScroll();const i=this.layout;this.layout=this.measure(!1),this.layoutCorrected=Cn(),this.isLayoutDirty=!1,this.projectionDelta=void 0,this.notifyListeners("measure",this.layout.layoutBox);const{visualElement:a}=this.options;a&&a.notify("LayoutMeasure",this.layout.layoutBox,i?i.layoutBox:void 0)}updateScroll(i="measure"){let a=!!(this.options.layoutScroll&&this.instance);if(this.scroll&&this.scroll.animationId===this.root.animationId&&this.scroll.phase===i&&(a=!1),a){const l=r(this.instance);this.scroll={animationId:this.root.animationId,phase:i,isRoot:l,offset:n(this.instance),wasRoot:this.scroll?this.scroll.isRoot:l}}}resetTransform(){if(!s)return;const i=this.isLayoutDirty||this.shouldResetTransform||this.options.alwaysMeasureLayout,a=this.projectionDelta&&!j_(this.projectionDelta),l=this.getTransformTemplate(),c=l?l(this.latestValues,""):void 0,d=c!==this.prevTransformTemplateValue;i&&(a||ou(this.latestValues)||d)&&(s(this.instance,c),this.shouldResetTransform=!1,this.scheduleRender())}measure(i=!0){const a=this.measurePageBox();let l=this.removeElementScroll(a);return i&&(l=this.removeTransform(l)),x9(l),{animationId:this.root.animationId,measuredBox:a,layoutBox:l,latestValues:{},source:this.id}}measurePageBox(){var c;const{visualElement:i}=this.options;if(!i)return Cn();const a=i.measureViewportBox();if(!(((c=this.scroll)==null?void 0:c.wasRoot)||this.path.some(v9))){const{scroll:d}=this.root;d&&(Wc(a.x,d.offset.x),Wc(a.y,d.offset.y))}return a}removeElementScroll(i){var l;const a=Cn();if(Zs(a,i),(l=this.scroll)!=null&&l.wasRoot)return a;for(let c=0;c<this.path.length;c++){const d=this.path[c],{scroll:f,options:p}=d;d!==this.root&&f&&p.layoutScroll&&(f.wasRoot&&Zs(a,i),Wc(a.x,f.offset.x),Wc(a.y,f.offset.y))}return a}applyTransform(i,a=!1){const l=Cn();Zs(l,i);for(let c=0;c<this.path.length;c++){const d=this.path[c];!a&&d.options.layoutScroll&&d.scroll&&d!==d.root&&Uc(l,{x:-d.scroll.offset.x,y:-d.scroll.offset.y}),ou(d.latestValues)&&Uc(l,d.latestValues)}return ou(this.latestValues)&&Uc(l,this.latestValues),l}removeTransform(i){const a=Cn();Zs(a,i);for(let l=0;l<this.path.length;l++){const c=this.path[l];if(!c.instance||!ou(c.latestValues))continue;jx(c.latestValues)&&c.updateSnapshot();const d=Cn(),f=c.measurePageBox();Zs(d,f),DI(a,c.latestValues,c.snapshot?c.snapshot.layoutBox:void 0,d)}return ou(this.latestValues)&&DI(a,this.latestValues),a}setTargetDelta(i){this.targetDelta=i,this.root.scheduleUpdateProjection(),this.isProjectionDirty=!0}setOptions(i){this.options={...this.options,...i,crossfade:i.crossfade!==void 0?i.crossfade:!0}}clearMeasurements(){this.scroll=void 0,this.layout=void 0,this.snapshot=void 0,this.prevTransformTemplateValue=void 0,this.targetDelta=void 0,this.target=void 0,this.isLayoutDirty=!1}forceRelativeParentToResolveTarget(){this.relativeParent&&this.relativeParent.resolvedRelativeTargetAt!==ir.timestamp&&this.relativeParent.resolveTargetDelta(!0)}resolveTargetDelta(i=!1){var p;const a=this.getLead();this.isProjectionDirty||(this.isProjectionDirty=a.isProjectionDirty),this.isTransformDirty||(this.isTransformDirty=a.isTransformDirty),this.isSharedProjectionDirty||(this.isSharedProjectionDirty=a.isSharedProjectionDirty);const l=!!this.resumingFrom||this!==a;if(!(i||l&&this.isSharedProjectionDirty||this.isProjectionDirty||(p=this.parent)!=null&&p.isProjectionDirty||this.attemptToResolveRelativeTarget||this.root.updateBlockedByResize))return;const{layout:d,layoutId:f}=this.options;if(!(!this.layout||!(d||f))){if(this.resolvedRelativeTargetAt=ir.timestamp,!this.targetDelta&&!this.relativeTarget){const g=this.getClosestProjectingParent();g&&g.layout&&this.animationProgress!==1?(this.relativeParent=g,this.forceRelativeParentToResolveTarget(),this.relativeTarget=Cn(),this.relativeTargetOrigin=Cn(),Yh(this.relativeTargetOrigin,this.layout.layoutBox,g.layout.layoutBox),Zs(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}if(!(!this.relativeTarget&&!this.targetDelta)&&(this.target||(this.target=Cn(),this.targetWithTransforms=Cn()),this.relativeTarget&&this.relativeTargetOrigin&&this.relativeParent&&this.relativeParent.target?(this.forceRelativeParentToResolveTarget(),wH(this.target,this.relativeTarget,this.relativeParent.target)):this.targetDelta?(this.resumingFrom?this.target=this.applyTransform(this.layout.layoutBox):Zs(this.target,this.layout.layoutBox),O_(this.target,this.targetDelta)):Zs(this.target,this.layout.layoutBox),this.attemptToResolveRelativeTarget)){this.attemptToResolveRelativeTarget=!1;const g=this.getClosestProjectingParent();g&&!!g.resumingFrom==!!this.resumingFrom&&!g.options.layoutScroll&&g.target&&this.animationProgress!==1?(this.relativeParent=g,this.forceRelativeParentToResolveTarget(),this.relativeTarget=Cn(),this.relativeTargetOrigin=Cn(),Yh(this.relativeTargetOrigin,this.target,g.target),Zs(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}}}getClosestProjectingParent(){if(!(!this.parent||jx(this.parent.latestValues)||F_(this.parent.latestValues)))return this.parent.isProjecting()?this.parent:this.parent.getClosestProjectingParent()}isProjecting(){return!!((this.relativeTarget||this.targetDelta||this.options.layoutRoot)&&this.layout)}calcProjection(){var y;const i=this.getLead(),a=!!this.resumingFrom||this!==i;let l=!0;if((this.isProjectionDirty||(y=this.parent)!=null&&y.isProjectionDirty)&&(l=!1),a&&(this.isSharedProjectionDirty||this.isTransformDirty)&&(l=!1),this.resolvedRelativeTargetAt===ir.timestamp&&(l=!1),l)return;const{layout:c,layoutId:d}=this.options;if(this.isTreeAnimating=!!(this.parent&&this.parent.isTreeAnimating||this.currentAnimation||this.pendingAnimation),this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0),!this.layout||!(c||d))return;Zs(this.layoutCorrected,this.layout.layoutBox);const f=this.treeScale.x,p=this.treeScale.y;SH(this.layoutCorrected,this.treeScale,this.path,a),i.layout&&!i.target&&(this.treeScale.x!==1||this.treeScale.y!==1)&&(i.target=i.layout.layoutBox,i.targetWithTransforms=Cn());const{target:g}=i;if(!g){this.prevProjectionDelta&&(this.createProjectionDeltas(),this.scheduleRender());return}!this.projectionDelta||!this.prevProjectionDelta?this.createProjectionDeltas():(_I(this.prevProjectionDelta.x,this.projectionDelta.x),_I(this.prevProjectionDelta.y,this.projectionDelta.y)),qh(this.projectionDelta,this.layoutCorrected,g,this.latestValues),(this.treeScale.x!==f||this.treeScale.y!==p||!BI(this.projectionDelta.x,this.prevProjectionDelta.x)||!BI(this.projectionDelta.y,this.prevProjectionDelta.y))&&(this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",g))}hide(){this.isVisible=!1}show(){this.isVisible=!0}scheduleRender(i=!0){var a;if((a=this.options.visualElement)==null||a.scheduleRender(),i){const l=this.getStack();l&&l.scheduleRender()}this.resumingFrom&&!this.resumingFrom.instance&&(this.resumingFrom=void 0)}createProjectionDeltas(){this.prevProjectionDelta=Vc(),this.projectionDelta=Vc(),this.projectionDeltaWithTransform=Vc()}setAnimationOrigin(i,a=!1){const l=this.snapshot,c=l?l.latestValues:{},d={...this.latestValues},f=Vc();(!this.relativeParent||!this.relativeParent.options.layoutRoot)&&(this.relativeTarget=this.relativeTargetOrigin=void 0),this.attemptToResolveRelativeTarget=!a;const p=Cn(),g=l?l.source:void 0,y=this.layout?this.layout.source:void 0,x=g!==y,w=this.getStack(),S=!w||w.members.length<=1,$=!!(x&&!S&&this.options.crossfade===!0&&!this.path.some(g9));this.animationProgress=0;let I;this.mixTargetDelta=R=>{const _=R/1e3;UI(f.x,i.x,_),UI(f.y,i.y,_),this.setTargetDelta(f),this.relativeTarget&&this.relativeTargetOrigin&&this.layout&&this.relativeParent&&this.relativeParent.layout&&(Yh(p,this.layout.layoutBox,this.relativeParent.layout.layoutBox),m9(this.relativeTarget,this.relativeTargetOrigin,p,_),I&&JH(this.relativeTarget,I)&&(this.isProjectionDirty=!1),I||(I=Cn()),Zs(I,this.relativeTarget)),x&&(this.animationValues=d,KH(d,c,this.latestValues,_,$,S)),this.root.scheduleUpdateProjection(),this.scheduleRender(),this.animationProgress=_},this.mixTargetDelta(this.options.layoutRoot?1e3:0)}startAnimation(i){this.notifyListeners("animationStart"),this.currentAnimation&&this.currentAnimation.stop(),this.resumingFrom&&this.resumingFrom.currentAnimation&&this.resumingFrom.currentAnimation.stop(),this.pendingAnimation&&(fl(this.pendingAnimation),this.pendingAnimation=void 0),this.pendingAnimation=pn.update(()=>{jm.hasAnimatedSinceResize=!0,this.currentAnimation=VH(0,MI,{...i,onUpdate:a=>{this.mixTargetDelta(a),i.onUpdate&&i.onUpdate(a)},onStop:()=>{},onComplete:()=>{i.onComplete&&i.onComplete(),this.completeAnimation()}}),this.resumingFrom&&(this.resumingFrom.currentAnimation=this.currentAnimation),this.pendingAnimation=void 0})}completeAnimation(){this.resumingFrom&&(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0);const i=this.getStack();i&&i.exitAnimationComplete(),this.resumingFrom=this.currentAnimation=this.animationValues=void 0,this.notifyListeners("animationComplete")}finishAnimation(){this.currentAnimation&&(this.mixTargetDelta&&this.mixTargetDelta(MI),this.currentAnimation.stop()),this.completeAnimation()}applyTransformsToTarget(){const i=this.getLead();let{targetWithTransforms:a,target:l,layout:c,latestValues:d}=i;if(!(!a||!l||!c)){if(this!==i&&this.layout&&c&&X_(this.options.animationType,this.layout.layoutBox,c.layoutBox)){l=this.target||Cn();const f=Br(this.layout.layoutBox.x);l.x.min=i.target.x.min,l.x.max=l.x.min+f;const p=Br(this.layout.layoutBox.y);l.y.min=i.target.y.min,l.y.max=l.y.min+p}Zs(a,l),Uc(a,d),qh(this.projectionDeltaWithTransform,this.layoutCorrected,a,d)}}registerSharedNode(i,a){this.sharedNodes.has(i)||this.sharedNodes.set(i,new e9),this.sharedNodes.get(i).add(a);const c=a.options.initialPromotionConfig;a.promote({transition:c?c.transition:void 0,preserveFollowOpacity:c&&c.shouldPreserveFollowOpacity?c.shouldPreserveFollowOpacity(a):void 0})}isLead(){const i=this.getStack();return i?i.lead===this:!0}getLead(){var a;const{layoutId:i}=this.options;return i?((a=this.getStack())==null?void 0:a.lead)||this:this}getPrevLead(){var a;const{layoutId:i}=this.options;return i?(a=this.getStack())==null?void 0:a.prevLead:void 0}getStack(){const{layoutId:i}=this.options;if(i)return this.root.sharedNodes.get(i)}promote({needsReset:i,transition:a,preserveFollowOpacity:l}={}){const c=this.getStack();c&&c.promote(this,l),i&&(this.projectionDelta=void 0,this.needsReset=!0),a&&this.setOptions({transition:a})}relegate(){const i=this.getStack();return i?i.relegate(this):!1}resetSkewAndRotation(){const{visualElement:i}=this.options;if(!i)return;let a=!1;const{latestValues:l}=i;if((l.z||l.rotate||l.rotateX||l.rotateY||l.rotateZ||l.skewX||l.skewY)&&(a=!0),!a)return;const c={};l.z&&L1("z",i,c,this.animationValues);for(let d=0;d<O1.length;d++)L1(`rotate${O1[d]}`,i,c,this.animationValues),L1(`skew${O1[d]}`,i,c,this.animationValues);i.render();for(const d in c)i.setStaticValue(d,c[d]),this.animationValues&&(this.animationValues[d]=c[d]);i.scheduleRender()}getProjectionStyles(i){if(!this.instance||this.isSVG)return;if(!this.isVisible)return n9;const a={visibility:""},l=this.getTransformTemplate();if(this.needsReset)return this.needsReset=!1,a.opacity="",a.pointerEvents=Um(i==null?void 0:i.pointerEvents)||"",a.transform=l?l(this.latestValues,""):"none",a;const c=this.getLead();if(!this.projectionDelta||!this.layout||!c.target){const g={};return this.options.layoutId&&(g.opacity=this.latestValues.opacity!==void 0?this.latestValues.opacity:1,g.pointerEvents=Um(i==null?void 0:i.pointerEvents)||""),this.hasProjected&&!ou(this.latestValues)&&(g.transform=l?l({},""):"none",this.hasProjected=!1),g}const d=c.animationValues||c.latestValues;this.applyTransformsToTarget(),a.transform=t9(this.projectionDeltaWithTransform,this.treeScale,d),l&&(a.transform=l(d,a.transform));const{x:f,y:p}=this.projectionDelta;a.transformOrigin=`${f.origin*100}% ${p.origin*100}% 0`,c.animationValues?a.opacity=c===this?d.opacity??this.latestValues.opacity??1:this.preserveOpacity?this.latestValues.opacity:d.opacityExit:a.opacity=c===this?d.opacity!==void 0?d.opacity:"":d.opacityExit!==void 0?d.opacityExit:0;for(const g in ff){if(d[g]===void 0)continue;const{correct:y,applyTo:x,isCSSVariable:w}=ff[g],S=a.transform==="none"?d[g]:y(d[g],c);if(x){const $=x.length;for(let I=0;I<$;I++)a[x[I]]=S}else w?this.options.visualElement.renderState.vars[g]=S:a[g]=S}return this.options.layoutId&&(a.pointerEvents=c===this?Um(i==null?void 0:i.pointerEvents)||"":"none"),a}clearSnapshot(){this.resumeFrom=this.snapshot=void 0}resetTree(){this.root.nodes.forEach(i=>{var a;return(a=i.currentAnimation)==null?void 0:a.stop()}),this.root.nodes.forEach(VI),this.root.sharedNodes.clear()}}}function s9(t){t.updateLayout()}function o9(t){var n;const e=((n=t.resumeFrom)==null?void 0:n.snapshot)||t.snapshot;if(t.isLead()&&t.layout&&e&&t.hasListeners("didUpdate")){const{layoutBox:r,measuredBox:s}=t.layout,{animationType:o}=t.options,i=e.source!==t.layout.source;o==="size"?to(f=>{const p=i?e.measuredBox[f]:e.layoutBox[f],g=Br(p);p.min=r[f].min,p.max=p.min+g}):X_(o,e.layoutBox,r)&&to(f=>{const p=i?e.measuredBox[f]:e.layoutBox[f],g=Br(r[f]);p.max=p.min+g,t.relativeTarget&&!t.currentAnimation&&(t.isProjectionDirty=!0,t.relativeTarget[f].max=t.relativeTarget[f].min+g)});const a=Vc();qh(a,r,e.layoutBox);const l=Vc();i?qh(l,t.applyTransform(s,!0),e.measuredBox):qh(l,r,e.layoutBox);const c=!j_(a);let d=!1;if(!t.resumeFrom){const f=t.getClosestProjectingParent();if(f&&!f.resumeFrom){const{snapshot:p,layout:g}=f;if(p&&g){const y=Cn();Yh(y,e.layoutBox,p.layoutBox);const x=Cn();Yh(x,r,g.layoutBox),G_(y,x)||(d=!0),f.options.layoutRoot&&(t.relativeTarget=x,t.relativeTargetOrigin=y,t.relativeParent=f)}}}t.notifyListeners("didUpdate",{layout:r,snapshot:e,delta:l,layoutDelta:a,hasLayoutChanged:c,hasRelativeLayoutChanged:d})}else if(t.isLead()){const{onExitComplete:r}=t.options;r&&r()}t.options.transition=void 0}function i9(t){t.parent&&(t.isProjecting()||(t.isProjectionDirty=t.parent.isProjectionDirty),t.isSharedProjectionDirty||(t.isSharedProjectionDirty=!!(t.isProjectionDirty||t.parent.isProjectionDirty||t.parent.isSharedProjectionDirty)),t.isTransformDirty||(t.isTransformDirty=t.parent.isTransformDirty))}function a9(t){t.isProjectionDirty=t.isSharedProjectionDirty=t.isTransformDirty=!1}function l9(t){t.clearSnapshot()}function VI(t){t.clearMeasurements()}function u9(t){t.isLayoutDirty=!1}function c9(t){const{visualElement:e}=t.options;e&&e.getProps().onBeforeLayoutMeasure&&e.notify("BeforeLayoutMeasure"),t.resetTransform()}function WI(t){t.finishAnimation(),t.targetDelta=t.relativeTarget=t.target=void 0,t.isProjectionDirty=!0}function d9(t){t.resolveTargetDelta()}function h9(t){t.calcProjection()}function f9(t){t.resetSkewAndRotation()}function p9(t){t.removeLeadSnapshot()}function UI(t,e,n){t.translate=fn(e.translate,0,n),t.scale=fn(e.scale,1,n),t.origin=e.origin,t.originPoint=e.originPoint}function jI(t,e,n,r){t.min=fn(e.min,n.min,r),t.max=fn(e.max,n.max,r)}function m9(t,e,n,r){jI(t.x,e.x,n.x,r),jI(t.y,e.y,n.y,r)}function g9(t){return t.animationValues&&t.animationValues.opacityExit!==void 0}const y9={duration:.45,ease:[.4,0,.1,1]},GI=t=>typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().includes(t),HI=GI("applewebkit/")&&!GI("chrome/")?Math.round:io;function KI(t){t.min=HI(t.min),t.max=HI(t.max)}function x9(t){KI(t.x),KI(t.y)}function X_(t,e,n){return t==="position"||t==="preserve-aspect"&&!bH(zI(e),zI(n),.2)}function v9(t){var e;return t!==t.root&&((e=t.scroll)==null?void 0:e.wasRoot)}const b9=K_({attachResizeListener:(t,e)=>mf(t,"resize",e),measureScroll:()=>({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=>!0}),z1={current:void 0},q_=K_({measureScroll:t=>({x:t.scrollLeft,y:t.scrollTop}),defaultParent:()=>{if(!z1.current){const t=new b9({});t.mount(window),t.setOptions({layoutScroll:!0}),z1.current=t}return z1.current},resetTransform:(t,e)=>{t.style.transform=e!==void 0?e:"none"},checkIsScrollRoot:t=>window.getComputedStyle(t).position==="fixed"}),w9={pan:{Feature:LH},drag:{Feature:OH,ProjectionNode:q_,MeasureLayout:V_}};function XI(t,e,n){const{props:r}=t;t.animationState&&r.whileHover&&t.animationState.setActive("whileHover",n==="Start");const s="onHover"+n,o=r[s];o&&pn.postRender(()=>o(e,Wf(e)))}class S9 extends vl{mount(){const{current:e}=this.node;e&&(this.unmount=Zj(e,(n,r)=>(XI(this.node,r,"Start"),s=>XI(this.node,s,"End"))))}unmount(){}}class C9 extends vl{constructor(){super(...arguments),this.isActive=!1}onFocus(){let e=!1;try{e=this.node.current.matches(":focus-visible")}catch{e=!0}!e||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}onBlur(){!this.isActive||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}mount(){this.unmount=Bf(mf(this.node.current,"focus",()=>this.onFocus()),mf(this.node.current,"blur",()=>this.onBlur()))}unmount(){}}function qI(t,e,n){const{props:r}=t;if(t.current instanceof HTMLButtonElement&&t.current.disabled)return;t.animationState&&r.whileTap&&t.animationState.setActive("whileTap",n==="Start");const s="onTap"+(n==="End"?"":n),o=r[s];o&&pn.postRender(()=>o(e,Wf(e)))}class $9 extends vl{mount(){const{current:e}=this.node;e&&(this.unmount=nG(e,(n,r)=>(qI(this.node,r,"Start"),(s,{success:o})=>qI(this.node,s,o?"End":"Cancel")),{useGlobalTarget:this.node.props.globalTapTarget}))}unmount(){}}const Kx=new WeakMap,B1=new WeakMap,k9=t=>{const e=Kx.get(t.target);e&&e(t)},T9=t=>{t.forEach(k9)};function I9({root:t,...e}){const n=t||document;B1.has(n)||B1.set(n,{});const r=B1.get(n),s=JSON.stringify(e);return r[s]||(r[s]=new IntersectionObserver(T9,{root:t,...e})),r[s]}function N9(t,e,n){const r=I9(e);return Kx.set(t,n),r.observe(t),()=>{Kx.delete(t),r.unobserve(t)}}const E9={some:0,all:1};class R9 extends vl{constructor(){super(...arguments),this.hasEnteredView=!1,this.isInView=!1}startObserver(){this.unmount();const{viewport:e={}}=this.node.getProps(),{root:n,margin:r,amount:s="some",once:o}=e,i={root:n?n.current:void 0,rootMargin:r,threshold:typeof s=="number"?s:E9[s]},a=l=>{const{isIntersecting:c}=l;if(this.isInView===c||(this.isInView=c,o&&!c&&this.hasEnteredView))return;c&&(this.hasEnteredView=!0),this.node.animationState&&this.node.animationState.setActive("whileInView",c);const{onViewportEnter:d,onViewportLeave:f}=this.node.getProps(),p=c?d:f;p&&p(l)};return N9(this.node.current,i,a)}mount(){this.startObserver()}update(){if(typeof IntersectionObserver>"u")return;const{props:e,prevProps:n}=this.node;["amount","margin","root"].some(_9(e,n))&&this.startObserver()}unmount(){}}function _9({viewport:t={}},{viewport:e={}}={}){return n=>t[n]!==e[n]}const P9={inView:{Feature:R9},tap:{Feature:$9},focus:{Feature:C9},hover:{Feature:S9}},A9={layout:{ProjectionNode:q_,MeasureLayout:V_}},Xx={current:null},Y_={current:!1};function D9(){if(Y_.current=!0,!!hb)if(window.matchMedia){const t=window.matchMedia("(prefers-reduced-motion)"),e=()=>Xx.current=t.matches;t.addListener(e),e()}else Xx.current=!1}const F9=new WeakMap;function O9(t,e,n){for(const r in e){const s=e[r],o=n[r];if(Tr(s))t.addValue(r,s);else if(Tr(o))t.addValue(r,df(s,{owner:t}));else if(o!==s)if(t.hasValue(r)){const i=t.getValue(r);i.liveStyle===!0?i.jump(s):i.hasAnimated||i.set(s)}else{const i=t.getStaticValue(r);t.addValue(r,df(i!==void 0?i:s,{owner:t}))}}for(const r in n)e[r]===void 0&&t.removeValue(r);return e}const YI=["AnimationStart","AnimationComplete","Update","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"];class L9{scrapeMotionValuesFromProps(e,n,r){return{}}constructor({parent:e,props:n,presenceContext:r,reducedMotionConfig:s,blockInitialAnimation:o,visualState:i},a={}){this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.KeyframeResolver=Rb,this.features={},this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=()=>this.notify("Update",this.latestValues),this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))},this.renderScheduledAt=0,this.scheduleRender=()=>{const p=hs.now();this.renderScheduledAt<p&&(this.renderScheduledAt=p,pn.render(this.render,!1,!0))};const{latestValues:l,renderState:c}=i;this.latestValues=l,this.baseTarget={...l},this.initialValues=n.initial?{...l}:{},this.renderState=c,this.parent=e,this.props=n,this.presenceContext=r,this.depth=e?e.depth+1:0,this.reducedMotionConfig=s,this.options=a,this.blockInitialAnimation=!!o,this.isControllingVariants=Jg(n),this.isVariantNode=y_(n),this.isVariantNode&&(this.variantChildren=new Set),this.manuallyAnimateOnMount=!!(e&&e.current);const{willChange:d,...f}=this.scrapeMotionValuesFromProps(n,{},this);for(const p in f){const g=f[p];l[p]!==void 0&&Tr(g)&&g.set(l[p],!1)}}mount(e){this.current=e,F9.set(e,this),this.projection&&!this.projection.instance&&this.projection.mount(e),this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=this.parent.addVariantChild(this)),this.values.forEach((n,r)=>this.bindToMotionValue(r,n)),Y_.current||D9(),this.shouldReduceMotion=this.reducedMotionConfig==="never"?!1:this.reducedMotionConfig==="always"?!0:Xx.current,this.parent&&this.parent.children.add(this),this.update(this.props,this.presenceContext)}unmount(){this.projection&&this.projection.unmount(),fl(this.notifyUpdate),fl(this.render),this.valueSubscriptions.forEach(e=>e()),this.valueSubscriptions.clear(),this.removeFromVariantTree&&this.removeFromVariantTree(),this.parent&&this.parent.children.delete(this);for(const e in this.events)this.events[e].clear();for(const e in this.features){const n=this.features[e];n&&(n.unmount(),n.isMounted=!1)}this.current=null}bindToMotionValue(e,n){this.valueSubscriptions.has(e)&&this.valueSubscriptions.get(e)();const r=vd.has(e);r&&this.onBindTransform&&this.onBindTransform();const s=n.on("change",a=>{this.latestValues[e]=a,this.props.onUpdate&&pn.preRender(this.notifyUpdate),r&&this.projection&&(this.projection.isTransformDirty=!0)}),o=n.on("renderRequest",this.scheduleRender);let i;window.MotionCheckAppearSync&&(i=window.MotionCheckAppearSync(this,e,n)),this.valueSubscriptions.set(e,()=>{s(),o(),i&&i(),n.owner&&n.stop()})}sortNodePosition(e){return!this.current||!this.sortInstanceNodePosition||this.type!==e.type?0:this.sortInstanceNodePosition(this.current,e.current)}updateFeatures(){let e="animation";for(e in od){const n=od[e];if(!n)continue;const{isEnabled:r,Feature:s}=n;if(!this.features[e]&&s&&r(this.props)&&(this.features[e]=new s(this)),this.features[e]){const o=this.features[e];o.isMounted?o.update():(o.mount(),o.isMounted=!0)}}}triggerBuild(){this.build(this.renderState,this.latestValues,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):Cn()}getStaticValue(e){return this.latestValues[e]}setStaticValue(e,n){this.latestValues[e]=n}update(e,n){(e.transformTemplate||this.props.transformTemplate)&&this.scheduleRender(),this.prevProps=this.props,this.props=e,this.prevPresenceContext=this.presenceContext,this.presenceContext=n;for(let r=0;r<YI.length;r++){const s=YI[r];this.propEventSubscriptions[s]&&(this.propEventSubscriptions[s](),delete this.propEventSubscriptions[s]);const o="on"+s,i=e[o];i&&(this.propEventSubscriptions[s]=this.on(s,i))}this.prevMotionValues=O9(this,this.scrapeMotionValuesFromProps(e,this.prevProps,this),this.prevMotionValues),this.handleChildMotionValue&&this.handleChildMotionValue()}getProps(){return this.props}getVariant(e){return this.props.variants?this.props.variants[e]:void 0}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():void 0}addVariantChild(e){const n=this.getClosestVariantNode();if(n)return n.variantChildren&&n.variantChildren.add(e),()=>n.variantChildren.delete(e)}addValue(e,n){const r=this.values.get(e);n!==r&&(r&&this.removeValue(e),this.bindToMotionValue(e,n),this.values.set(e,n),this.latestValues[e]=n.get())}removeValue(e){this.values.delete(e);const n=this.valueSubscriptions.get(e);n&&(n(),this.valueSubscriptions.delete(e)),delete this.latestValues[e],this.removeValueFromRenderState(e,this.renderState)}hasValue(e){return this.values.has(e)}getValue(e,n){if(this.props.values&&this.props.values[e])return this.props.values[e];let r=this.values.get(e);return r===void 0&&n!==void 0&&(r=df(n===null?void 0:n,{owner:this}),this.addValue(e,r)),r}readValue(e,n){let r=this.latestValues[e]!==void 0||!this.current?this.latestValues[e]:this.getBaseTargetFromProps(this.props,e)??this.readValueFromInstance(this.current,e,this.options);return r!=null&&(typeof r=="string"&&(IR(r)||NR(r))?r=parseFloat(r):!iG(r)&&pl.test(n)&&(r=c_(e,n)),this.setBaseTarget(e,Tr(r)?r.get():r)),Tr(r)?r.get():r}setBaseTarget(e,n){this.baseTarget[e]=n}getBaseTarget(e){var o;const{initial:n}=this.props;let r;if(typeof n=="string"||typeof n=="object"){const i=Vb(this.props,n,(o=this.presenceContext)==null?void 0:o.custom);i&&(r=i[e])}if(n&&r!==void 0)return r;const s=this.getBaseTargetFromProps(this.props,e);return s!==void 0&&!Tr(s)?s:this.initialValues[e]!==void 0&&r===void 0?void 0:this.baseTarget[e]}on(e,n){return this.events[e]||(this.events[e]=new vb),this.events[e].add(n)}notify(e,...n){this.events[e]&&this.events[e].notify(...n)}}class Q_ extends L9{constructor(){super(...arguments),this.KeyframeResolver=qj}sortInstanceNodePosition(e,n){return e.compareDocumentPosition(n)&2?1:-1}getBaseTargetFromProps(e,n){return e.style?e.style[n]:void 0}removeValueFromRenderState(e,{vars:n,style:r}){delete n[e],delete r[e]}handleChildMotionValue(){this.childSubscription&&(this.childSubscription(),delete this.childSubscription);const{children:e}=this.props;Tr(e)&&(this.childSubscription=e.on("change",n=>{this.current&&(this.current.textContent=`${n}`)}))}}function Z_(t,{style:e,vars:n},r,s){Object.assign(t.style,e,s&&s.getProjectionStyles(r));for(const o in n)t.style.setProperty(o,n[o])}function z9(t){return window.getComputedStyle(t)}class B9 extends Q_{constructor(){super(...arguments),this.type="html",this.renderInstance=Z_}readValueFromInstance(e,n){if(vd.has(n))return pj(e,n);{const r=z9(e),s=(Sb(n)?r.getPropertyValue(n):r[n])||0;return typeof s=="string"?s.trim():s}}measureInstanceViewportBox(e,{transformPagePoint:n}){return L_(e,n)}build(e,n,r){zb(e,n,r.transformTemplate)}scrapeMotionValuesFromProps(e,n,r){return Wb(e,n,r)}}const J_=new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength","startOffset","textLength","lengthAdjust"]);function M9(t,e,n,r){Z_(t,e,void 0,r);for(const s in e.attrs)t.setAttribute(J_.has(s)?s:Lb(s),e.attrs[s])}class V9 extends Q_{constructor(){super(...arguments),this.type="svg",this.isSVGTag=!1,this.measureInstanceViewportBox=Cn}getBaseTargetFromProps(e,n){return e[n]}readValueFromInstance(e,n){if(vd.has(n)){const r=u_(n);return r&&r.default||0}return n=J_.has(n)?n:Lb(n),e.getAttribute(n)}scrapeMotionValuesFromProps(e,n,r){return I_(e,n,r)}build(e,n,r){C_(e,n,this.isSVGTag,r.transformTemplate)}renderInstance(e,n,r,s){M9(e,n,r,s)}mount(e){this.isSVGTag=k_(e.tagName),super.mount(e)}}const W9=(t,e)=>Mb(t)?new V9(e):new B9(e,{allowProjection:t!==ee.Fragment}),U9=MG({...hH,...P9,...w9,...A9},W9),Uf=dG(U9),j9=(t,e)=>t.find(n=>n.id===e);function QI(t,e){const n=eP(t,e),r=n?t[n].findIndex(s=>s.id===e):-1;return{position:n,index:r}}function eP(t,e){for(const[n,r]of Object.entries(t))if(j9(r,e))return n}function G9(t){const e=t.includes("right"),n=t.includes("left");let r="center";return e&&(r="flex-end"),n&&(r="flex-start"),{display:"flex",flexDirection:"column",alignItems:r}}function H9(t){const n=t==="top"||t==="bottom"?"0 auto":void 0,r=t.includes("top")?"env(safe-area-inset-top, 0px)":void 0,s=t.includes("bottom")?"env(safe-area-inset-bottom, 0px)":void 0,o=t.includes("left")?void 0:"env(safe-area-inset-right, 0px)",i=t.includes("right")?void 0:"env(safe-area-inset-left, 0px)";return{position:"fixed",zIndex:"var(--toast-z-index, 5500)",pointerEvents:"none",display:"flex",flexDirection:"column",margin:n,top:r,bottom:s,right:o,left:i}}var K9=/^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,X9=fR(function(t){return K9.test(t)||t.charCodeAt(0)===111&&t.charCodeAt(1)===110&&t.charCodeAt(2)<91}),q9=X9,Y9=function(e){return e!=="theme"},ZI=function(e){return typeof e=="string"&&e.charCodeAt(0)>96?q9:Y9},JI=function(e,n,r){var s;if(n){var o=n.shouldForwardProp;s=e.__emotion_forwardProp&&o?function(i){return e.__emotion_forwardProp(i)&&o(i)}:o}return typeof s!="function"&&r&&(s=e.__emotion_forwardProp),s},Q9=function(e){var n=e.cache,r=e.serialized,s=e.isStringTag;return rb(n,r,s),xR(function(){return sb(n,r,s)}),null},Z9=function t(e,n){var r=e.__emotion_real===e,s=r&&e.__emotion_base||e,o,i;n!==void 0&&(o=n.label,i=n.target);var a=JI(e,n,r),l=a||ZI(s),c=!l("as");return function(){var d=arguments,f=r&&e.__emotion_styles!==void 0?e.__emotion_styles.slice(0):[];if(o!==void 0&&f.push("label:"+o+";"),d[0]==null||d[0].raw===void 0)f.push.apply(f,d);else{var p=d[0];f.push(p[0]);for(var g=d.length,y=1;y<g;y++)f.push(d[y],p[y])}var x=ib(function(w,S,$){var I=c&&w.as||s,R="",_=[],F=w;if(w.theme==null){F={};for(var O in w)F[O]=w[O];F.theme=ee.useContext(rd)}typeof w.className=="string"?R=mR(S.registered,_,w.className):w.className!=null&&(R=w.className+" ");var M=qg(f.concat(_),S.registered,F);R+=S.key+"-"+M.name,i!==void 0&&(R+=" "+i);var B=c&&a===void 0?ZI(I):l,V={};for(var A in w)c&&A==="as"||B(A)&&(V[A]=w[A]);return V.className=R,$&&(V.ref=$),ee.createElement(ee.Fragment,null,ee.createElement(Q9,{cache:S,serialized:M,isStringTag:typeof I=="string"}),ee.createElement(I,V))});return x.displayName=o!==void 0?o:"Styled("+(typeof s=="string"?s:s.displayName||s.name||"Component")+")",x.defaultProps=e.defaultProps,x.__emotion_real=x,x.__emotion_base=s,x.__emotion_styles=f,x.__emotion_forwardProp=a,Object.defineProperty(x,"toString",{value:function(){return"."+i}}),x.withComponent=function(w,S){var $=t(w,lg({},n,S,{shouldForwardProp:JI(x,S,!0)}));return $.apply(void 0,f)},x}},J9=["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","marquee","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr","circle","clipPath","defs","ellipse","foreignObject","g","image","line","linearGradient","mask","path","pattern","polygon","polyline","radialGradient","rect","stop","svg","text","tspan"],qx=Z9.bind(null);J9.forEach(function(t){qx[t]=qx(t)});const e7=new Set([...hz,"textStyle","layerStyle","apply","noOfLines","focusBorderColor","errorBorderColor","as","__css","css","sx"]),t7=new Set(["htmlWidth","htmlHeight","htmlSize","htmlTranslate"]);function n7(t){return(t7.has(t)||!e7.has(t))&&t[0]!=="_"}const r7=$L(qx),s7=({baseStyle:t})=>e=>{const{theme:n,css:r,__css:s,sx:o,...i}=e,[a]=IL(i,pz),l=ro(t,e),c=gL({},s,l,Wg(a),o),d=G3(c)(e.theme);return r?[d,r]:d};function M1(t,e){const{baseStyle:n,...r}=e??{};r.shouldForwardProp||(r.shouldForwardProp=n7);const s=s7({baseStyle:n}),o=r7(t,r)(s);return ee.forwardRef(function(l,c){const{children:d,...f}=l,{colorMode:p,forced:g}=ub(),y=g?p:void 0;return ee.createElement(o,{ref:c,"data-theme":y,...f},d)})}function o7(){const t=new Map;return new Proxy(M1,{apply(e,n,r){return M1(...r)},get(e,n){return t.has(n)||t.set(n,M1(n)),t.get(n)}})}const it=o7(),i7={initial:t=>{const{position:e}=t,n=["top","bottom"].includes(e)?"y":"x";let r=["top-right","bottom-right"].includes(e)?1:-1;return e==="bottom"&&(r=1),{opacity:0,[n]:r*24}},animate:{opacity:1,y:0,x:0,scale:1,transition:{duration:.4,ease:[.4,0,.2,1]}},exit:{opacity:0,scale:.85,transition:{duration:.2,ease:[.4,0,1,1]}}},tP=ee.memo(t=>{const{id:e,message:n,onCloseComplete:r,onRequestRemove:s,requestClose:o=!1,position:i="bottom",duration:a=5e3,containerStyle:l,motionVariants:c=i7,toastSpacing:d="0.5rem"}=t,[f,p]=ee.useState(a),g=c8();oT(()=>{g||r==null||r()},[g]),oT(()=>{p(a)},[a]);const y=()=>p(null),x=()=>p(a),w=()=>{g&&s()};ee.useEffect(()=>{g&&o&&s()},[g,o,s]),AL(w,f);const S=ee.useMemo(()=>({pointerEvents:"auto",maxWidth:560,minWidth:300,margin:d,...l}),[l,d]),$=ee.useMemo(()=>G9(i),[i]);return K.jsx(Uf.div,{layout:!0,className:"chakra-toast",variants:c,initial:"initial",animate:"animate",exit:"exit",onHoverStart:y,onHoverEnd:x,custom:{position:i},style:$,children:K.jsx(it.div,{role:"status","aria-atomic":"true",className:"chakra-toast__inner",__css:S,children:ro(n,{id:e,onClose:w})})})});tP.displayName="ToastComponent";function lt(t){return ee.forwardRef(t)}var V1,eN;function a7(){if(eN)return V1;eN=1;var t=typeof Element<"u",e=typeof Map=="function",n=typeof Set=="function",r=typeof ArrayBuffer=="function"&&!!ArrayBuffer.isView;function s(o,i){if(o===i)return!0;if(o&&i&&typeof o=="object"&&typeof i=="object"){if(o.constructor!==i.constructor)return!1;var a,l,c;if(Array.isArray(o)){if(a=o.length,a!=i.length)return!1;for(l=a;l--!==0;)if(!s(o[l],i[l]))return!1;return!0}var d;if(e&&o instanceof Map&&i instanceof Map){if(o.size!==i.size)return!1;for(d=o.entries();!(l=d.next()).done;)if(!i.has(l.value[0]))return!1;for(d=o.entries();!(l=d.next()).done;)if(!s(l.value[1],i.get(l.value[0])))return!1;return!0}if(n&&o instanceof Set&&i instanceof Set){if(o.size!==i.size)return!1;for(d=o.entries();!(l=d.next()).done;)if(!i.has(l.value[0]))return!1;return!0}if(r&&ArrayBuffer.isView(o)&&ArrayBuffer.isView(i)){if(a=o.length,a!=i.length)return!1;for(l=a;l--!==0;)if(o[l]!==i[l])return!1;return!0}if(o.constructor===RegExp)return o.source===i.source&&o.flags===i.flags;if(o.valueOf!==Object.prototype.valueOf&&typeof o.valueOf=="function"&&typeof i.valueOf=="function")return o.valueOf()===i.valueOf();if(o.toString!==Object.prototype.toString&&typeof o.toString=="function"&&typeof i.toString=="function")return o.toString()===i.toString();if(c=Object.keys(o),a=c.length,a!==Object.keys(i).length)return!1;for(l=a;l--!==0;)if(!Object.prototype.hasOwnProperty.call(i,c[l]))return!1;if(t&&o instanceof Element)return!1;for(l=a;l--!==0;)if(!((c[l]==="_owner"||c[l]==="__v"||c[l]==="__o")&&o.$$typeof)&&!s(o[c[l]],i[c[l]]))return!1;return!0}return o!==o&&i!==i}return V1=function(i,a){try{return s(i,a)}catch(l){if((l.message||"").match(/stack|recursion/i))return console.warn("react-fast-compare cannot handle circular refs"),!1;throw l}},V1}var l7=a7();const u7=Df(l7);function nP(){const t=ee.useContext(rd);if(!t)throw Error("useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`");return t}function rP(){const t=ub(),e=nP();return{...t,theme:e}}function c7(t,e,n){if(e==null)return e;const r=s=>{var o,i;return(i=(o=t.__cssMap)==null?void 0:o[s])==null?void 0:i.value};return r(e)??r(n)??n}function d7(t,e,n){const r=Array.isArray(e)?e:[e],s=Array.isArray(n)?n:[n];return o=>{const i=s.filter(Boolean),a=r.map((l,c)=>{const d=`${t}.${l}`;return c7(o,d,i[c]??l)});return Array.isArray(e)?a:a[0]}}function sP(t,e={}){const{styleConfig:n,...r}=e,{theme:s,colorMode:o}=rP(),i=t?M3(s,`components.${t}`):void 0,a=n||i,l=so({theme:s,colorMode:o},(a==null?void 0:a.defaultProps)??{},Wg(Gv(r,["children"])),(d,f)=>d?void 0:f),c=ee.useRef({});if(a){const f=$z(a)(l);u7(c.current,f)||(c.current=f)}return c.current}function bl(t,e={}){return sP(t,e)}function ya(t,e={}){return sP(t,e)}const tN={path:K.jsxs("g",{stroke:"currentColor",strokeWidth:"1.5",children:[K.jsx("path",{strokeLinecap:"round",fill:"none",d:"M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25"}),K.jsx("path",{fill:"currentColor",strokeLinecap:"round",d:"M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0"}),K.jsx("circle",{fill:"none",strokeMiterlimit:"10",cx:"12",cy:"12",r:"11.25"})]}),viewBox:"0 0 24 24"},xa=lt((t,e)=>{const{as:n,viewBox:r,color:s="currentColor",focusable:o=!1,children:i,className:a,__css:l,...c}=t,d=Lt("chakra-icon",a),f=bl("Icon",t),p={w:"1em",h:"1em",display:"inline-block",lineHeight:"1em",flexShrink:0,color:s,...l,...f},g={ref:e,focusable:o,className:d,__css:p},y=r??tN.viewBox;if(n&&typeof n!="string")return K.jsx(it.svg,{as:n,...g,...c});const x=i??tN.path;return K.jsx(it.svg,{verticalAlign:"middle",viewBox:y,...g,...c,children:x})});xa.displayName="Icon";function h7(t){return K.jsx(xa,{viewBox:"0 0 24 24",...t,children:K.jsx("path",{fill:"currentColor",d:"M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z"})})}function f7(t){return K.jsx(xa,{viewBox:"0 0 24 24",...t,children:K.jsx("path",{fill:"currentColor",d:"M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z"})})}function nN(t){return K.jsx(xa,{viewBox:"0 0 24 24",...t,children:K.jsx("path",{fill:"currentColor",d:"M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"})})}const p7=Lf({"0%":{transform:"rotate(0deg)"},"100%":{transform:"rotate(360deg)"}}),jf=lt((t,e)=>{const n=bl("Spinner",t),{label:r="Loading...",thickness:s="2px",speed:o="0.45s",emptyColor:i="transparent",className:a,...l}=Nr(t),c=Lt("chakra-spinner",a),d={display:"inline-block",borderColor:"currentColor",borderStyle:"solid",borderRadius:"99999px",borderWidth:s,borderBottomColor:i,borderLeftColor:i,animation:`${p7} ${o} linear infinite`,...n};return K.jsx(it.div,{ref:e,__css:d,className:c,...l,children:r&&K.jsx(it.span,{srOnly:!0,children:r})})});jf.displayName="Spinner";const[m7,jb]=Gr({name:"AlertContext",hookName:"useAlertContext",providerName:"<Alert />"}),[g7,Gb]=Gr({name:"AlertStylesContext",hookName:"useAlertStyles",providerName:"<Alert />"}),oP={info:{icon:f7,colorScheme:"blue"},warning:{icon:nN,colorScheme:"orange"},success:{icon:h7,colorScheme:"green"},error:{icon:nN,colorScheme:"red"},loading:{icon:jf,colorScheme:"blue"}};function y7(t){return oP[t].colorScheme}function x7(t){return oP[t].icon}const Hb=lt(function(e,n){const{status:r="info",addRole:s=!0,...o}=Nr(e),i=e.colorScheme??y7(r),a=ya("Alert",{...e,colorScheme:i}),l={width:"100%",display:"flex",alignItems:"center",position:"relative",overflow:"hidden",...a.container};return K.jsx(m7,{value:{status:r},children:K.jsx(g7,{value:a,children:K.jsx(it.div,{"data-status":r,role:s?"alert":void 0,ref:n,...o,className:Lt("chakra-alert",e.className),__css:l})})})});Hb.displayName="Alert";function Kb(t){const{status:e}=jb(),n=x7(e),r=Gb(),s=e==="loading"?r.spinner:r.icon;return K.jsx(it.span,{display:"inherit","data-status":e,...t,className:Lt("chakra-alert__icon",t.className),__css:s,children:t.children||K.jsx(n,{h:"100%",w:"100%"})})}Kb.displayName="AlertIcon";const iP=lt(function(e,n){const r=Gb(),{status:s}=jb();return K.jsx(it.div,{ref:n,"data-status":s,...e,className:Lt("chakra-alert__title",e.className),__css:r.title})});iP.displayName="AlertTitle";const aP=lt(function(e,n){const{status:r}=jb(),s=Gb(),o={display:"inline",...s.description};return K.jsx(it.div,{ref:n,"data-status":r,...e,className:Lt("chakra-alert__desc",e.className),__css:o})});aP.displayName="AlertDescription";function v7(t){return K.jsx(xa,{focusable:"false","aria-hidden":!0,...t,children:K.jsx("path",{fill:"currentColor",d:"M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z"})})}const lP=lt(function(e,n){const r=bl("CloseButton",e),{children:s,isDisabled:o,__css:i,...a}=Nr(e),l={outline:0,display:"flex",alignItems:"center",justifyContent:"center",flexShrink:0};return K.jsx(it.button,{type:"button","aria-label":"Close",ref:n,disabled:o,__css:{...l,...r,...i},...a,children:s||K.jsx(v7,{width:"1em",height:"1em"})})});lP.displayName="CloseButton";const b7=t=>{const{status:e,variant:n="solid",id:r,title:s,isClosable:o,onClose:i,description:a,colorScheme:l,icon:c}=t,d=r?{root:`toast-${r}`,title:`toast-${r}-title`,description:`toast-${r}-description`}:void 0;return K.jsxs(Hb,{addRole:!1,status:e,variant:n,id:d==null?void 0:d.root,alignItems:"start",borderRadius:"md",boxShadow:"lg",paddingEnd:8,textAlign:"start",width:"auto",colorScheme:l,children:[K.jsx(Kb,{children:c}),K.jsxs(it.div,{flex:"1",maxWidth:"100%",children:[s&&K.jsx(iP,{id:d==null?void 0:d.title,children:s}),a&&K.jsx(aP,{id:d==null?void 0:d.description,display:"block",children:a})]}),o&&K.jsx(lP,{size:"sm",onClick:i,position:"absolute",insetEnd:1,top:1})]})};function uP(t={}){const{render:e,toastComponent:n=b7}=t;return s=>typeof e=="function"?e({...s,...t}):K.jsx(n,{...s,...t})}const w7={top:[],"top-left":[],"top-right":[],"bottom-left":[],bottom:[],"bottom-right":[]},ui=S7(w7);function S7(t){let e=t;const n=new Set,r=s=>{e=s(e),n.forEach(o=>o())};return{getState:()=>e,subscribe:s=>(n.add(s),()=>{r(()=>t),n.delete(s)}),removeToast:(s,o)=>{r(i=>({...i,[o]:i[o].filter(a=>a.id!=s)}))},notify:(s,o)=>{const i=C7(s,o),{position:a,id:l}=i;return r(c=>{const f=a.includes("top")?[i,...c[a]??[]]:[...c[a]??[],i];return{...c,[a]:f}}),l},update:(s,o)=>{s&&r(i=>{const a={...i},{position:l,index:c}=QI(a,s);return l&&c!==-1&&(a[l][c]={...a[l][c],...o,message:uP(o)}),a})},closeAll:({positions:s}={})=>{r(o=>(s??["bottom","bottom-right","bottom-left","top","top-left","top-right"]).reduce((l,c)=>(l[c]=o[c].map(d=>({...d,requestClose:!0})),l),{...o}))},close:s=>{r(o=>{const i=eP(o,s);return i?{...o,[i]:o[i].map(a=>a.id==s?{...a,requestClose:!0}:a)}:o})},isActive:s=>!!QI(ui.getState(),s).position}}let rN=0;function C7(t,e={}){rN+=1;const n=e.id??rN,r=e.position??"bottom";return{id:n,message:t,position:r,duration:e.duration,onCloseComplete:e.onCloseComplete,onRequestRemove:()=>ui.removeToast(String(n),r),status:e.status,requestClose:!1,containerStyle:e.containerStyle}}var cP=z3();const[dP,$7]=Gr({strict:!1,name:"PortalContext"}),Xb="chakra-portal",k7=".chakra-portal",T7=t=>K.jsx("div",{className:"chakra-portal-zIndex",style:{position:"absolute",zIndex:t.zIndex,top:0,left:0,right:0},children:t.children}),I7=t=>{const{appendToParentPortal:e,children:n}=t,[r,s]=ee.useState(null),o=ee.useRef(null),[,i]=ee.useState({});ee.useEffect(()=>i({}),[]);const a=$7(),l=s8();rg(()=>{if(!r)return;const d=r.ownerDocument,f=e?a??d.body:d.body;if(!f)return;o.current=d.createElement("div"),o.current.className=Xb,f.appendChild(o.current),i({});const p=o.current;return()=>{f.contains(p)&&f.removeChild(p)}},[r]);const c=l!=null&&l.zIndex?K.jsx(T7,{zIndex:l==null?void 0:l.zIndex,children:n}):n;return o.current?cP.createPortal(K.jsx(dP,{value:o.current,children:c}),o.current):K.jsx("span",{ref:d=>{d&&s(d)}})},N7=t=>{const{children:e,containerRef:n,appendToParentPortal:r}=t,s=n.current,o=s??(typeof window<"u"?document.body:void 0),i=ee.useMemo(()=>{const l=s==null?void 0:s.ownerDocument.createElement("div");return l&&(l.className=Xb),l},[s]),[,a]=ee.useState({});return rg(()=>a({}),[]),rg(()=>{if(!(!i||!o))return o.appendChild(i),()=>{o.removeChild(i)}},[i,o]),o&&i?cP.createPortal(K.jsx(dP,{value:r?i:null,children:e}),i):null};function ey(t){const e={appendToParentPortal:!0,...t},{containerRef:n,...r}=e;return n?K.jsx(N7,{containerRef:n,...r}):K.jsx(I7,{...r})}ey.className=Xb;ey.selector=k7;ey.displayName="Portal";const[E7,R7]=Gr({name:"ToastOptionsContext",strict:!1}),_7=t=>{const e=ee.useSyncExternalStore(ui.subscribe,ui.getState,ui.getState),{motionVariants:n,component:r=tP,portalProps:s,animatePresenceProps:o}=t,a=Object.keys(e).map(l=>{const c=e[l];return K.jsx("div",{role:"region","aria-live":"polite","aria-label":`Notifications-${l}`,id:`chakra-toast-manager-${l}`,style:H9(l),children:K.jsx(pb,{...o,initial:!1,children:c.map(d=>K.jsx(r,{motionVariants:n,...d},d.id))})},l)});return K.jsx(ey,{...s,children:a})},P7=t=>function({children:n,theme:r=t,toastOptions:s,...o}){return K.jsxs(o8,{theme:r,...o,children:[K.jsx(E7,{value:s==null?void 0:s.defaultOptions,children:n}),K.jsx(_7,{...s})]})},A7=P7(iR),sN={easeIn:[.4,0,1,1],easeOut:[0,0,.2,1]},pg={enter:{duration:.2,ease:sN.easeOut},exit:{duration:.1,ease:sN.easeIn}},mg={enter:(t,e)=>({...t,delay:typeof e=="number"?e:e==null?void 0:e.enter}),exit:(t,e)=>({...t,delay:typeof e=="number"?e:e==null?void 0:e.exit})};function D7(t){const{loading:e,src:n,srcSet:r,onLoad:s,onError:o,crossOrigin:i,sizes:a,ignoreFallback:l}=t,[c,d]=ee.useState("pending");ee.useEffect(()=>{d(n?"loading":"pending")},[n]);const f=ee.useRef(null),p=ee.useCallback(()=>{if(!n)return;g();const y=new Image;y.src=n,i&&(y.crossOrigin=i),r&&(y.srcset=r),a&&(y.sizes=a),e&&(y.loading=e),y.onload=x=>{g(),d("loaded"),s==null||s(x)},y.onerror=x=>{g(),d("failed"),o==null||o(x)},f.current=y},[n,i,r,a,s,o,e]),g=()=>{f.current&&(f.current.onload=null,f.current.onerror=null,f.current=null)};return rg(()=>{if(!l)return c==="loading"&&p(),()=>{g()}},[c,p,l]),l?"loaded":c}const F7=(t,e)=>t!=="loaded"&&e==="beforeLoadOrError"||t==="failed"&&e==="onError",Po=it("div");Po.displayName="Box";const hP=lt(function(e,n){const{size:r,centerContent:s=!0,...o}=e,i=s?{display:"flex",alignItems:"center",justifyContent:"center"}:{};return K.jsx(Po,{ref:n,boxSize:r,__css:{...i,flexShrink:0,flexGrow:0},...o})});hP.displayName="Square";const fP=lt(function(e,n){const{size:r,...s}=e;return K.jsx(hP,{size:r,ref:n,borderRadius:"9999px",...s})});fP.displayName="Circle";const[kTe,O7]=Gr({strict:!1,name:"ButtonGroupContext"});function Ph(t){const{children:e,className:n,...r}=t,s=ee.isValidElement(e)?ee.cloneElement(e,{"aria-hidden":!0,focusable:!1}):e,o=Lt("chakra-button__icon",n);return K.jsx(it.span,{display:"inline-flex",alignSelf:"center",flexShrink:0,...r,className:o,children:s})}Ph.displayName="ButtonIcon";function Yx(t){const{label:e,placement:n,spacing:r="0.5rem",children:s=K.jsx(jf,{color:"currentColor",width:"1em",height:"1em"}),className:o,__css:i,...a}=t,l=Lt("chakra-button__spinner",o),c=n==="start"?"marginEnd":"marginStart",d=ee.useMemo(()=>({display:"flex",alignItems:"center",position:e?"relative":"absolute",[c]:e?r:0,fontSize:"1em",lineHeight:"normal",...i}),[i,e,c,r]);return K.jsx(it.div,{className:l,...a,__css:d,children:s})}Yx.displayName="ButtonSpinner";function L7(t){const[e,n]=ee.useState(!t);return{ref:ee.useCallback(o=>{o&&n(o.tagName==="BUTTON")},[]),type:e?"button":void 0}}const bd=lt((t,e)=>{const n=O7(),r=bl("Button",{...n,...t}),{isDisabled:s=n==null?void 0:n.isDisabled,isLoading:o,isActive:i,children:a,leftIcon:l,rightIcon:c,loadingText:d,iconSpacing:f="0.5rem",type:p,spinner:g,spinnerPlacement:y="start",className:x,as:w,shouldWrapChildren:S,...$}=Nr(t),I=ee.useMemo(()=>{const O={...r==null?void 0:r._focus,zIndex:1};return{display:"inline-flex",appearance:"none",alignItems:"center",justifyContent:"center",userSelect:"none",position:"relative",whiteSpace:"nowrap",verticalAlign:"middle",outline:"none",...r,...!!n&&{_focus:O}}},[r,n]),{ref:R,type:_}=L7(w),F={rightIcon:c,leftIcon:l,iconSpacing:f,children:a,shouldWrapChildren:S};return K.jsxs(it.button,{disabled:s||o,ref:PL(e,R),as:w,type:p??_,"data-active":si(i),"data-loading":si(o),__css:I,className:Lt("chakra-button",x),...$,children:[o&&y==="start"&&K.jsx(Yx,{className:"chakra-button__spinner--start",label:d,placement:"start",spacing:f,children:g}),o?d||K.jsx(it.span,{opacity:0,children:K.jsx(oN,{...F})}):K.jsx(oN,{...F}),o&&y==="end"&&K.jsx(Yx,{className:"chakra-button__spinner--end",label:d,placement:"end",spacing:f,children:g})]})});bd.displayName="Button";function oN(t){const{leftIcon:e,rightIcon:n,children:r,iconSpacing:s,shouldWrapChildren:o}=t;return o?K.jsxs("span",{style:{display:"contents"},children:[e&&K.jsx(Ph,{marginEnd:s,children:e}),r,n&&K.jsx(Ph,{marginStart:s,children:n})]}):K.jsxs(K.Fragment,{children:[e&&K.jsx(Ph,{marginEnd:s,children:e}),r,n&&K.jsx(Ph,{marginStart:s,children:n})]})}const[z7,pP]=t8("Card"),B7=lt(function(e,n){const{className:r,children:s,direction:o="column",justify:i,align:a,...l}=Nr(e),c=ya("Card",e);return K.jsx(it.div,{ref:n,className:Lt("chakra-card",r),__css:{display:"flex",flexDirection:o,justifyContent:i,alignItems:a,position:"relative",minWidth:0,wordWrap:"break-word",...c.container},...l,children:K.jsx(z7,{value:c,children:s})})}),M7=lt(function(e,n){const{className:r,...s}=e,o=pP();return K.jsx(it.div,{ref:n,className:Lt("chakra-card__body",r),__css:o.body,...s})}),V7=lt(function(e,n){const{className:r,...s}=e,o=pP();return K.jsx(it.div,{ref:n,className:Lt("chakra-card__header",r),__css:o.header,...s})}),mP=it("div",{baseStyle:{display:"flex",alignItems:"center",justifyContent:"center"}});mP.displayName="Center";const W7={horizontal:{insetStart:"50%",transform:"translateX(-50%)"},vertical:{top:"50%",transform:"translateY(-50%)"},both:{insetStart:"50%",top:"50%",transform:"translate(-50%, -50%)"}};lt(function(e,n){const{axis:r="both",...s}=e;return K.jsx(it.div,{ref:n,__css:W7[r],...s,position:"absolute"})});const[U7,gP]=Gr({name:"FormControlStylesContext",errorMessage:`useFormControlStyles returned is 'undefined'. Seems you forgot to wrap the components in "<FormControl />" `}),[j7,wd]=Gr({strict:!1,name:"FormControlContext"});function G7(t){const{id:e,isRequired:n,isInvalid:r,isDisabled:s,isReadOnly:o,...i}=t,a=ee.useId(),l=e||`field-${a}`,c=`${l}-label`,d=`${l}-feedback`,f=`${l}-helptext`,[p,g]=ee.useState(!1),[y,x]=ee.useState(!1),[w,S]=ee.useState(!1),$=ee.useCallback((O={},M=null)=>({id:f,...O,ref:yx(M,B=>{B&&x(!0)})}),[f]),I=ee.useCallback((O={},M=null)=>({...O,ref:M,"data-focus":si(w),"data-disabled":si(s),"data-invalid":si(r),"data-readonly":si(o),id:O.id!==void 0?O.id:c,htmlFor:O.htmlFor!==void 0?O.htmlFor:l}),[l,s,w,r,o,c]),R=ee.useCallback((O={},M=null)=>({id:d,...O,ref:yx(M,B=>{B&&g(!0)}),"aria-live":"polite"}),[d]),_=ee.useCallback((O={},M=null)=>({...O,...i,ref:M,role:"group","data-focus":si(w),"data-disabled":si(s),"data-invalid":si(r),"data-readonly":si(o)}),[i,s,w,r,o]),F=ee.useCallback((O={},M=null)=>({...O,ref:M,role:"presentation","aria-hidden":!0,children:O.children||"*"}),[]);return{isRequired:!!n,isInvalid:!!r,isReadOnly:!!o,isDisabled:!!s,isFocused:!!w,onFocus:()=>S(!0),onBlur:()=>S(!1),hasFeedbackText:p,setHasFeedbackText:g,hasHelpText:y,setHasHelpText:x,id:l,labelId:c,feedbackId:d,helpTextId:f,htmlProps:i,getHelpTextProps:$,getErrorMessageProps:R,getRootProps:_,getLabelProps:I,getRequiredIndicatorProps:F}}const yP=lt(function(e,n){const r=ya("Form",e),s=Nr(e),{getRootProps:o,htmlProps:i,...a}=G7(s),l=Lt("chakra-form-control",e.className);return K.jsx(j7,{value:a,children:K.jsx(U7,{value:r,children:K.jsx(it.div,{...o({},n),className:l,__css:r.container})})})});yP.displayName="FormControl";const H7=lt(function(e,n){const r=wd(),s=gP(),o=Lt("chakra-form__helper-text",e.className);return K.jsx(it.div,{...r==null?void 0:r.getHelpTextProps(e,n),__css:s.helperText,className:o})});H7.displayName="FormHelperText";function K7(t){const{isDisabled:e,isInvalid:n,isReadOnly:r,isRequired:s,...o}=X7(t);return{...o,disabled:e,readOnly:r,required:s,"aria-invalid":a1(n),"aria-required":a1(s),"aria-readonly":a1(r)}}function X7(t){const e=wd(),{id:n,disabled:r,readOnly:s,required:o,isRequired:i,isInvalid:a,isReadOnly:l,isDisabled:c,onFocus:d,onBlur:f,...p}=t,g=t["aria-describedby"]?[t["aria-describedby"]]:[];return e!=null&&e.hasFeedbackText&&(e!=null&&e.isInvalid)&&g.push(e.feedbackId),e!=null&&e.hasHelpText&&g.push(e.helpTextId),{...p,"aria-describedby":g.join(" ")||void 0,id:n??(e==null?void 0:e.id),isDisabled:r??c??(e==null?void 0:e.isDisabled),isReadOnly:s??l??(e==null?void 0:e.isReadOnly),isRequired:o??i??(e==null?void 0:e.isRequired),isInvalid:a??(e==null?void 0:e.isInvalid),onFocus:nT(e==null?void 0:e.onFocus,d),onBlur:nT(e==null?void 0:e.onBlur,f)}}const Gf=lt(function(e,n){const{className:r,centerContent:s,...o}=Nr(e),i=bl("Container",e);return K.jsx(it.div,{ref:n,className:Lt("chakra-container",r),...o,__css:{...i,...s&&{display:"flex",flexDirection:"column",alignItems:"center"}}})});Gf.displayName="Container";function Ah(t){return typeof t=="function"}function q7(...t){return e=>t.reduce((n,r)=>r(n),e)}const Y7=t=>function(...n){let r=[...n],s=n[n.length-1];return q6(s)&&r.length>1?r=r.slice(0,r.length-1):s=t,q7(...r.map(o=>i=>Ah(o)?o(i):Z7(i,o)))(s)},Q7=Y7(iR);function Z7(...t){return so({},...t,xP)}function xP(t,e,n,r){if((Ah(t)||Ah(e))&&Object.prototype.hasOwnProperty.call(r,n))return(...s)=>{const o=Ah(t)?t(...s):t,i=Ah(e)?e(...s):e;return so({},o,i,xP)};if(Mr(t)&&mx(e)||mx(t)&&Mr(e))return e}const[J7,eK]=Gr({name:"FormErrorStylesContext",errorMessage:`useFormErrorStyles returned is 'undefined'. Seems you forgot to wrap the components in "<FormError />" `}),vP=lt((t,e)=>{const n=ya("FormError",t),r=Nr(t),s=wd();return s!=null&&s.isInvalid?K.jsx(J7,{value:n,children:K.jsx(it.div,{...s==null?void 0:s.getErrorMessageProps(r,e),className:Lt("chakra-form__error-message",t.className),__css:{display:"flex",alignItems:"center",...n.text}})}):null});vP.displayName="FormErrorMessage";const tK=lt((t,e)=>{const n=eK(),r=wd();if(!(r!=null&&r.isInvalid))return null;const s=Lt("chakra-form__error-icon",t.className);return K.jsx(xa,{ref:e,"aria-hidden":!0,...t,__css:n.icon,className:s,children:K.jsx("path",{fill:"currentColor",d:"M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"})})});tK.displayName="FormErrorIcon";const bP=lt(function(e,n){const r=bl("FormLabel",e),s=Nr(e),{className:o,children:i,requiredIndicator:a=K.jsx(wP,{}),optionalIndicator:l=null,...c}=s,d=wd(),f=(d==null?void 0:d.getLabelProps(c,n))??{ref:n,...c};return K.jsxs(it.label,{...f,className:Lt("chakra-form__label",s.className),__css:{display:"block",textAlign:"start",...r},children:[i,d!=null&&d.isRequired?a:l]})});bP.displayName="FormLabel";const wP=lt(function(e,n){const r=wd(),s=gP();if(!(r!=null&&r.isRequired))return null;const o=Lt("chakra-form__required-indicator",e.className);return K.jsx(it.span,{...r==null?void 0:r.getRequiredIndicatorProps(e,n),__css:s.requiredIndicator,className:o})});wP.displayName="RequiredIndicator";const SP=lt(function(e,n){const{templateAreas:r,gap:s,rowGap:o,columnGap:i,column:a,row:l,autoFlow:c,autoRows:d,templateRows:f,autoColumns:p,templateColumns:g,...y}=e,x={display:"grid",gridTemplateAreas:r,gridGap:s,gridRowGap:o,gridColumnGap:i,gridAutoColumns:p,gridColumn:a,gridRow:l,gridAutoFlow:c,gridAutoRows:d,gridTemplateRows:f,gridTemplateColumns:g};return K.jsx(it.div,{ref:n,__css:x,...y})});SP.displayName="Grid";const CP=lt(function(e,n){const{columns:r,spacingX:s,spacingY:o,spacing:i,minChildWidth:a,...l}=e,c=nP(),d=a?rK(a,c):sK(r);return K.jsx(SP,{ref:n,gap:i,columnGap:s,rowGap:o,templateColumns:d,...l})});CP.displayName="SimpleGrid";function nK(t){return typeof t=="number"?`${t}px`:t}function rK(t,e){return Hv(t,n=>{const r=d7("sizes",n,nK(n))(e);return n===null?null:`repeat(auto-fit, minmax(${r}, 1fr))`})}function sK(t){return Hv(t,e=>e===null?null:`repeat(${e}, minmax(0, 1fr))`)}const Qx=lt(function(e,n){const{htmlWidth:r,htmlHeight:s,alt:o,...i}=e;return K.jsx("img",{width:r,height:s,ref:n,alt:o,...i})});Qx.displayName="NativeImage";const $P=lt(function(e,n){const{fallbackSrc:r,fallback:s,src:o,srcSet:i,align:a,fit:l,loading:c,ignoreFallback:d,crossOrigin:f,fallbackStrategy:p="beforeLoadOrError",referrerPolicy:g,...y}=e,x=r!==void 0||s!==void 0,w=c!=null||d||!x,S=D7({...e,crossOrigin:f,ignoreFallback:w}),$=F7(S,p),I={ref:n,objectFit:l,objectPosition:a,...w?y:Gv(y,["onError","onLoad"])};return $?s||K.jsx(it.img,{as:Qx,className:"chakra-image__placeholder",src:r,...I}):K.jsx(it.img,{as:Qx,src:o,srcSet:i,crossOrigin:f,loading:c,referrerPolicy:g,className:"chakra-image",...I})});$P.displayName="Image";const qb=lt(function(e,n){const{htmlSize:r,...s}=e,o=ya("Input",s),i=Nr(s),a=K7(i),l=Lt("chakra-input",e.className);return K.jsx(it.input,{size:r,...a,__css:o.field,ref:n,className:l})});qb.displayName="Input";qb.id="Input";const[oK,iK]=Gr({name:"InputGroupStylesContext",errorMessage:`useInputGroupStyles returned is 'undefined'. Seems you forgot to wrap the components in "<InputGroup />" `}),kP=lt(function(e,n){const r=ya("Input",e),{children:s,className:o,...i}=Nr(e),a=Lt("chakra-input__group",o),l={},c=jv(s),d=r.field;c.forEach(p=>{r&&(d&&p.type.id==="InputLeftElement"&&(l.paddingStart=d.height??d.h),d&&p.type.id==="InputRightElement"&&(l.paddingEnd=d.height??d.h),p.type.id==="InputRightAddon"&&(l.borderEndRadius=0),p.type.id==="InputLeftAddon"&&(l.borderStartRadius=0))});const f=c.map(p=>{var y,x;const g=Wg({size:((y=p.props)==null?void 0:y.size)||e.size,variant:((x=p.props)==null?void 0:x.variant)||e.variant});return p.type.id!=="Input"?ee.cloneElement(p,g):ee.cloneElement(p,Object.assign(g,l,p.props))});return K.jsx(it.div,{className:a,ref:n,__css:{width:"100%",display:"flex",position:"relative",isolation:"isolate",...r.group},"data-group":!0,...i,children:K.jsx(oK,{value:r,children:f})})});kP.displayName="InputGroup";const aK={left:{marginEnd:"-1px",borderEndRadius:0,borderEndColor:"transparent"},right:{marginStart:"-1px",borderStartRadius:0,borderStartColor:"transparent"}},lK=it("div",{baseStyle:{flex:"0 0 auto",width:"auto",display:"flex",alignItems:"center",whiteSpace:"nowrap"}}),Yb=lt(function(e,n){const{placement:r="left",...s}=e,o=aK[r]??{},i=iK();return K.jsx(lK,{ref:n,...s,__css:{...i.addon,...o}})});Yb.displayName="InputAddon";const TP=lt(function(e,n){return K.jsx(Yb,{ref:n,placement:"left",...e,className:Lt("chakra-input__left-addon",e.className)})});TP.displayName="InputLeftAddon";TP.id="InputLeftAddon";const Qb=lt(function(e,n){return K.jsx(Yb,{ref:n,placement:"right",...e,className:Lt("chakra-input__right-addon",e.className)})});Qb.displayName="InputRightAddon";Qb.id="InputRightAddon";const[uK,IP]=Gr({name:"ListStylesContext",errorMessage:`useListStyles returned is 'undefined'. Seems you forgot to wrap the components in "<List />" `}),ty=lt(function(e,n){const r=ya("List",e),{children:s,styleType:o="none",stylePosition:i,spacing:a,...l}=Nr(e),c=jv(s),f=a?{["& > *:not(style) ~ *:not(style)"]:{mt:a}}:{};return K.jsx(uK,{value:r,children:K.jsx(it.ul,{ref:n,listStyleType:o,listStylePosition:i,role:"list",__css:{...r.container,...f},...l,children:c})})});ty.displayName="List";const cK=lt((t,e)=>{const{as:n,...r}=t;return K.jsx(ty,{ref:e,as:"ol",styleType:"decimal",marginStart:"1em",...r})});cK.displayName="OrderedList";const dK=lt(function(e,n){const{as:r,...s}=e;return K.jsx(ty,{ref:n,as:"ul",styleType:"initial",marginStart:"1em",...s})});dK.displayName="UnorderedList";const NP=lt(function(e,n){const r=IP();return K.jsx(it.li,{ref:n,...e,__css:r.item})});NP.displayName="ListItem";const iu=lt(function(e,n){const r=IP();return K.jsx(xa,{ref:n,role:"presentation",...e,__css:r.icon})});iu.displayName="ListIcon";const hK={exit:({reverse:t,initialScale:e,transition:n,transitionEnd:r,delay:s})=>({opacity:0,...t?{scale:e,transitionEnd:r==null?void 0:r.exit}:{transitionEnd:{scale:e,...r==null?void 0:r.exit}},transition:(n==null?void 0:n.exit)??mg.exit(pg.exit,s)}),enter:({transitionEnd:t,transition:e,delay:n})=>({opacity:1,scale:1,transition:(e==null?void 0:e.enter)??mg.enter(pg.enter,n),transitionEnd:t==null?void 0:t.enter})},fK={initial:"exit",animate:"enter",exit:"exit",variants:hK},EP=ee.forwardRef(function(e,n){const{unmountOnExit:r,in:s,reverse:o=!0,initialScale:i=.95,className:a,transition:l,transitionEnd:c,delay:d,animatePresenceProps:f,...p}=e,g=r?s&&r:!0,y=s||r?"enter":"exit",x={initialScale:i,reverse:o,transition:l,transitionEnd:c,delay:d};return K.jsx(pb,{...f,custom:x,children:g&&K.jsx(Uf.div,{ref:n,className:Lt("chakra-offset-slide",a),...fK,animate:y,custom:x,...p})})});EP.displayName="ScaleFade";const pK={enter:({transition:t,transitionEnd:e,delay:n}={})=>({opacity:1,transition:(t==null?void 0:t.enter)??mg.enter(pg.enter,n),transitionEnd:e==null?void 0:e.enter}),exit:({transition:t,transitionEnd:e,delay:n}={})=>({opacity:0,transition:(t==null?void 0:t.exit)??mg.exit(pg.exit,n),transitionEnd:e==null?void 0:e.exit})},mK={initial:"exit",animate:"enter",exit:"exit",variants:pK},RP=ee.forwardRef(function(e,n){const{unmountOnExit:r,in:s,className:o,transition:i,transitionEnd:a,delay:l,animatePresenceProps:c,...d}=e,f=s||r?"enter":"exit",p=r?s&&r:!0,g={transition:i,transitionEnd:a,delay:l};return K.jsx(pb,{...c,custom:g,children:p&&K.jsx(Uf.div,{ref:n,className:Lt("chakra-fade",o),custom:g,...mK,animate:f,...d})})});RP.displayName="Fade";function gK(t,e,n){return(t-e)*100/(n-e)}Lf({"0%":{strokeDasharray:"1, 400",strokeDashoffset:"0"},"50%":{strokeDasharray:"400, 400",strokeDashoffset:"-100"},"100%":{strokeDasharray:"400, 400",strokeDashoffset:"-260"}});Lf({"0%":{transform:"rotate(0deg)"},"100%":{transform:"rotate(360deg)"}});const yK=Lf({"0%":{left:"-40%"},"100%":{left:"100%"}}),xK=Lf({from:{backgroundPosition:"1rem 0"},to:{backgroundPosition:"0 0"}});function vK(t){const{value:e=0,min:n,max:r,valueText:s,getValueText:o,isIndeterminate:i,role:a="progressbar"}=t,l=gK(e,n,r);return{bind:{"data-indeterminate":i?"":void 0,"aria-valuemax":r,"aria-valuemin":n,"aria-valuenow":i?void 0:e,"aria-valuetext":(()=>{if(e!=null)return typeof o=="function"?o(e,l):s})(),role:a},percent:l,value:e}}const[bK,wK]=Gr({name:"ProgressStylesContext",errorMessage:`useProgressStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Progress />" `}),SK=lt((t,e)=>{const{min:n,max:r,value:s,isIndeterminate:o,role:i,...a}=t,l=vK({value:s,min:n,max:r,isIndeterminate:o,role:i}),d={height:"100%",...wK().filledTrack};return K.jsx(it.div,{ref:e,style:{width:`${l.percent}%`,...a.style},...l.bind,...a,__css:d})}),_P=lt((t,e)=>{var O;const{value:n,min:r=0,max:s=100,hasStripe:o,isAnimated:i,children:a,borderRadius:l,isIndeterminate:c,"aria-label":d,"aria-labelledby":f,"aria-valuetext":p,title:g,role:y,...x}=Nr(t),w=ya("Progress",t),S=l??((O=w.track)==null?void 0:O.borderRadius),$={animation:`${xK} 1s linear infinite`},_={...!c&&o&&i&&$,...c&&{position:"absolute",willChange:"left",minWidth:"50%",animation:`${yK} 1s ease infinite normal none running`}},F={overflow:"hidden",position:"relative",...w.track};return K.jsx(it.div,{ref:e,borderRadius:S,__css:F,...x,children:K.jsxs(bK,{value:w,children:[K.jsx(SK,{"aria-label":d,"aria-labelledby":f,"aria-valuetext":p,min:r,max:s,value:n,isIndeterminate:c,css:_,borderRadius:S,title:g,role:y}),a]})})});_P.displayName="Progress";const PP=t=>K.jsx(it.div,{className:"chakra-stack__item",...t,__css:{display:"inline-block",flex:"0 0 auto",minWidth:0,...t.__css}});PP.displayName="StackItem";function CK(t){const{spacing:e,direction:n}=t,r={column:{my:e,mx:0,borderLeftWidth:0,borderBottomWidth:"1px"},"column-reverse":{my:e,mx:0,borderLeftWidth:0,borderBottomWidth:"1px"},row:{mx:e,my:0,borderLeftWidth:"1px",borderBottomWidth:0},"row-reverse":{mx:e,my:0,borderLeftWidth:"1px",borderBottomWidth:0}};return{"&":Hv(n,s=>r[s])}}const AP=lt((t,e)=>{const{isInline:n,direction:r,align:s,justify:o,spacing:i="0.5rem",wrap:a,children:l,divider:c,className:d,shouldWrapChildren:f,...p}=t,g=n?"row":r??"column",y=ee.useMemo(()=>CK({spacing:i,direction:g}),[i,g]),x=!!c,w=!f&&!x,S=ee.useMemo(()=>{const I=jv(l);return w?I:I.map((R,_)=>{const F=typeof R.key<"u"?R.key:_,O=_+1===I.length,B=f?K.jsx(PP,{children:R},F):R;if(!x)return B;const V=ee.cloneElement(c,{__css:y}),A=O?null:V;return K.jsxs(ee.Fragment,{children:[B,A]},F)})},[c,y,x,w,f,l]),$=Lt("chakra-stack",d);return K.jsx(it.div,{ref:e,display:"flex",alignItems:s,justifyContent:o,flexDirection:g,flexWrap:a,gap:x?void 0:i,className:$,...p,children:S})});AP.displayName="Stack";const ra=lt((t,e)=>K.jsx(AP,{align:"center",...t,direction:"column",ref:e}));ra.displayName="VStack";const[$K,DP]=Gr({name:"StatStylesContext",errorMessage:`useStatStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Stat />" `}),FP=lt(function(e,n){const r=ya("Stat",e),s={position:"relative",flex:"1 1 0%",...r.container},{className:o,children:i,...a}=Nr(e);return K.jsx($K,{value:r,children:K.jsx(it.div,{ref:n,...a,className:Lt("chakra-stat",o),__css:s,children:K.jsx("dl",{children:i})})})});FP.displayName="Stat";const OP=lt(function(e,n){const r=DP();return K.jsx(it.dt,{ref:n,...e,className:Lt("chakra-stat__label",e.className),__css:r.label})});OP.displayName="StatLabel";const LP=lt(function(e,n){const r=DP();return K.jsx(it.dd,{ref:n,...e,className:Lt("chakra-stat__number",e.className),__css:{...r.number,fontFeatureSettings:"pnum",fontVariantNumeric:"proportional-nums"}})});LP.displayName="StatNumber";function kK(t,e){const n=t??"bottom",s={"top-start":{ltr:"top-left",rtl:"top-right"},"top-end":{ltr:"top-right",rtl:"top-left"},"bottom-start":{ltr:"bottom-left",rtl:"bottom-right"},"bottom-end":{ltr:"bottom-right",rtl:"bottom-left"}}[n];return(s==null?void 0:s[e])??n}function TK(t,e){const n=s=>({...e,...s,position:kK((s==null?void 0:s.position)??(e==null?void 0:e.position),t)}),r=s=>{const o=n(s),i=uP(o);return ui.notify(i,o)};return r.update=(s,o)=>{ui.update(s,n(o))},r.promise=(s,o)=>{const i=r({...o.loading,status:"loading",duration:null});s.then(a=>r.update(i,{status:"success",duration:5e3,...ro(o.success,a)})).catch(a=>r.update(i,{status:"error",duration:5e3,...ro(o.error,a)}))},r.closeAll=ui.closeAll,r.close=ui.close,r.isActive=ui.isActive,r}function zP(t){const{theme:e}=rP(),n=R7();return ee.useMemo(()=>TK(e.direction,{...n,...t}),[t,e.direction,n])}const Sd=lt(function(e,n){const r=bl("Heading",e),{className:s,...o}=Nr(e);return K.jsx(it.h2,{ref:n,className:Lt("chakra-heading",e.className),...o,__css:r})});Sd.displayName="Heading";const Sr=lt(function(e,n){const r=bl("Text",e),{className:s,align:o,decoration:i,casing:a,...l}=Nr(e),c=Wg({textAlign:e.align,textDecoration:e.decoration,textTransform:e.casing});return K.jsx(it.p,{ref:n,className:Lt("chakra-text",e.className),...c,...l,__css:r})});Sr.displayName="Text";function IK({onNavigate:t}){const e=()=>{console.log("Start button clicked! Navigating..."),t("INSTRUCTIONS")};return K.jsx(Po,{textAlign:"center",p:8,minHeight:"80vh",display:"flex",alignItems:"center",justifyContent:"center",children:K.jsxs(ra,{spacing:6,children:[K.jsx($P,{src:pL,alt:"TapFit Logo",boxSize:"100px"}),K.jsx(Sd,{as:"h1",size:"2xl",children:"Welcome to TapFit!"}),K.jsx(Sr,{fontSize:"lg",maxWidth:"450px",color:"gray.600",children:"Get ready to capture your pose and see relevant measurements."}),K.jsx(bd,{colorScheme:"blue",size:"lg",onClick:e,children:"Start"})]})})}var BP={color:void 0,size:void 0,className:void 0,style:void 0,attr:void 0},iN=ta.createContext&&ta.createContext(BP),NK=["attr","size","title"];function EK(t,e){if(t==null)return{};var n=RK(t,e),r,s;if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(s=0;s<o.length;s++)r=o[s],!(e.indexOf(r)>=0)&&Object.prototype.propertyIsEnumerable.call(t,r)&&(n[r]=t[r])}return n}function RK(t,e){if(t==null)return{};var n={};for(var r in t)if(Object.prototype.hasOwnProperty.call(t,r)){if(e.indexOf(r)>=0)continue;n[r]=t[r]}return n}function gg(){return gg=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},gg.apply(this,arguments)}function aN(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter(function(s){return Object.getOwnPropertyDescriptor(t,s).enumerable})),n.push.apply(n,r)}return n}function yg(t){for(var e=1;e<arguments.length;e++){var n=arguments[e]!=null?arguments[e]:{};e%2?aN(Object(n),!0).forEach(function(r){_K(t,r,n[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):aN(Object(n)).forEach(function(r){Object.defineProperty(t,r,Object.getOwnPropertyDescriptor(n,r))})}return t}function _K(t,e,n){return e=PK(e),e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function PK(t){var e=AK(t,"string");return typeof e=="symbol"?e:e+""}function AK(t,e){if(typeof t!="object"||!t)return t;var n=t[Symbol.toPrimitive];if(n!==void 0){var r=n.call(t,e);if(typeof r!="object")return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return(e==="string"?String:Number)(t)}function MP(t){return t&&t.map((e,n)=>ta.createElement(e.tag,yg({key:n},e.attr),MP(e.child)))}function va(t){return e=>ta.createElement(DK,gg({attr:yg({},t.attr)},e),MP(t.child))}function DK(t){var e=n=>{var{attr:r,size:s,title:o}=t,i=EK(t,NK),a=s||n.size||"1em",l;return n.className&&(l=n.className),t.className&&(l=(l?l+" ":"")+t.className),ta.createElement("svg",gg({stroke:"currentColor",fill:"currentColor",strokeWidth:"0"},n.attr,r,i,{className:l,style:yg(yg({color:t.color||n.color},n.style),t.style),height:a,width:a,xmlns:"http://www.w3.org/2000/svg"}),o&&ta.createElement("title",null,o),t.children)};return iN!==void 0?ta.createElement(iN.Consumer,null,n=>e(n)):e(BP)}function FK(t){return va({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"48",d:"M244 400 100 256l144-144M120 256h292"},child:[]}]})(t)}function OK(t){return va({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"48",d:"m268 112 144 144-144 144m124-144H100"},child:[]}]})(t)}function Dh(t){return va({attr:{viewBox:"0 0 512 512"},child:[{tag:"circle",attr:{cx:"256",cy:"56",r:"40",fill:"none",strokeMiterlimit:"10",strokeWidth:"32"},child:[]},{tag:"path",attr:{fill:"none",strokeMiterlimit:"10",strokeWidth:"32",d:"m199.3 295.62-30.4 172.2a24 24 0 0 0 19.5 27.8 23.76 23.76 0 0 0 27.6-19.5l21-119.9v.2s5.2-32.5 17.5-32.5h3.1c12.5 0 17.5 32.5 17.5 32.5v-.1l21 119.9a23.92 23.92 0 1 0 47.1-8.4l-30.4-172.2-4.9-29.7c-2.9-18.1-4.2-47.6.5-59.7 4-10.4 14.13-14.2 23.2-14.2H424a24 24 0 0 0 0-48H88a24 24 0 0 0 0 48h92.5c9.23 0 19.2 3.8 23.2 14.2 4.7 12.1 3.4 41.6.5 59.7z"},child:[]}]})(t)}function LK(t){return va({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"m350.54 148.68-26.62-42.06C318.31 100.08 310.62 96 302 96h-92c-8.62 0-16.31 4.08-21.92 10.62l-26.62 42.06C155.85 155.23 148.62 160 140 160H80a32 32 0 0 0-32 32v192a32 32 0 0 0 32 32h352a32 32 0 0 0 32-32V192a32 32 0 0 0-32-32h-59c-8.65 0-16.85-4.77-22.46-11.32z"},child:[]},{tag:"circle",attr:{cx:"256",cy:"272",r:"80",fill:"none",strokeMiterlimit:"10",strokeWidth:"32"},child:[]},{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M124 158v-22h-24v22"},child:[]}]})(t)}function zK(t){return va({attr:{viewBox:"0 0 512 512"},child:[{tag:"rect",attr:{width:"256",height:"480",x:"128",y:"16",fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",rx:"48",ry:"48"},child:[]},{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M176 16h24a8 8 0 0 1 8 8h0a16 16 0 0 0 16 16h64a16 16 0 0 0 16-16h0a8 8 0 0 1 8-8h24"},child:[]}]})(t)}function BK(t){return va({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M304 96h112v112m-10.23-101.8L111.98 400.02M208 416H96V304"},child:[]}]})(t)}function MK(t){return va({attr:{viewBox:"0 0 512 512"},child:[{tag:"rect",attr:{width:"416",height:"416",x:"48",y:"48",fill:"none",strokeLinejoin:"round",strokeWidth:"32",rx:"96"},child:[]},{tag:"path",attr:{fill:"none",strokeLinejoin:"round",strokeWidth:"32",d:"M388.94 151.56c-24.46-22.28-68.72-51.4-132.94-51.4s-108.48 29.12-132.94 51.4a34.66 34.66 0 0 0-3.06 48.08l33.32 39.21a26.07 26.07 0 0 0 33.6 5.21c15.92-9.83 40.91-21.64 69.1-21.64s53.18 11.81 69.1 21.64a26.07 26.07 0 0 0 33.6-5.21L392 199.64a34.66 34.66 0 0 0-3.06-48.08z"},child:[]}]})(t)}function VK(t){return va({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M314.56 48s-22.78 8-58.56 8-58.56-8-58.56-8a31.94 31.94 0 0 0-10.57 1.8L32 104l16.63 88 48.88 5.52a24 24 0 0 1 21.29 24.58L112 464h288l-6.8-241.9a24 24 0 0 1 21.29-24.58l48.88-5.52L480 104 325.13 49.8a31.94 31.94 0 0 0-10.57-1.8zm18.75 4.66a80 80 0 0 1-154.62 0"},child:[]}]})(t)}function WK(t){return va({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"m304 48 112 112-112 112m94.87-112H96m112 304L96 352l112-112m-94 112h302"},child:[]}]})(t)}const $c=Uf(NP);function UK({onNavigate:t}){const e=()=>{console.log("Next button clicked! Navigating to Height Input..."),t("HEIGHT_INPUT")},n={hidden:{opacity:0,y:10},visible:{opacity:1,y:0}};return K.jsx(Gf,{maxW:"container.md",py:{base:8,md:12},bg:"gray.50",borderRadius:"md",boxShadow:"sm",children:K.jsxs(ra,{spacing:6,align:"stretch",children:[K.jsx(Sd,{as:"h1",size:"xl",textAlign:"center",color:"teal.600",children:"How to Use TapFit"}),K.jsx(Sr,{textAlign:"center",fontSize:"lg",color:"gray.700",children:"Follow these steps for accurate results:"}),K.jsxs(ty,{spacing:5,px:{base:2,md:4},children:[" ",K.jsxs($c,{display:"flex",alignItems:"start",variants:n,initial:"hidden",animate:"visible",transition:{duration:.3,delay:.1},children:[K.jsx(iu,{as:VK,color:"teal.500",w:6,h:6,mt:1,mr:2}),K.jsxs(Po,{children:[" ",K.jsx(Sr,{as:"span",fontWeight:"bold",color:"teal.700",children:"Preparation: "}),"Wear form-fitting clothing. Ensure good, even lighting without strong shadows. Find a clear space with a plain background if possible."]})]}),K.jsxs($c,{display:"flex",alignItems:"start",variants:n,initial:"hidden",animate:"visible",transition:{duration:.3,delay:.2},children:[K.jsx(iu,{as:zK,color:"teal.500",w:6,h:6,mt:1,mr:2}),K.jsxs(Po,{children:[K.jsx(Sr,{as:"span",fontWeight:"bold",color:"teal.700",children:"Phone Placement: "}),"Place your phone upright on a stable surface (like a table or tripod) around waist height. Ensure the camera lens is clean."]})]}),K.jsxs($c,{display:"flex",alignItems:"start",variants:n,initial:"hidden",animate:"visible",transition:{duration:.3,delay:.3},children:[K.jsx(iu,{as:BK,color:"teal.500",w:6,h:6,mt:1,mr:2}),K.jsxs(Po,{children:[K.jsx(Sr,{as:"span",fontWeight:"bold",color:"teal.700",children:"Distance: "}),"Stand far enough back so your entire body, from head to toe, is clearly visible within the camera frame."]})]}),K.jsxs($c,{display:"flex",alignItems:"start",variants:n,initial:"hidden",animate:"visible",transition:{duration:.3,delay:.4},children:[K.jsx(iu,{as:Dh,color:"teal.500",w:6,h:6,mt:1,mr:2}),K.jsxs(Po,{children:[K.jsx(Sr,{as:"span",fontWeight:"bold",color:"teal.700",children:"Front Pose: "}),"Stand facing the camera directly. Keep your feet shoulder-width apart, arms relaxed at your sides (not touching your body), and look straight ahead. Hold still."]})]}),K.jsxs($c,{display:"flex",alignItems:"start",variants:n,initial:"hidden",animate:"visible",transition:{duration:.3,delay:.5},children:[K.jsx(iu,{as:WK,color:"teal.500",w:6,h:6,mt:1,mr:2}),K.jsxs(Po,{children:[K.jsx(Sr,{as:"span",fontWeight:"bold",color:"teal.700",children:"Side Pose: "}),"Turn 90 degrees (either left or right, but be consistent if asked again). Stand straight with your feet together, arms relaxed at your sides, and look straight ahead. Hold still."]})]}),K.jsxs($c,{display:"flex",alignItems:"start",variants:n,initial:"hidden",animate:"visible",transition:{duration:.3,delay:.6},children:[K.jsx(iu,{as:LK,color:"teal.500",w:6,h:6,mt:1,mr:2}),K.jsxs(Po,{children:[K.jsx(Sr,{as:"span",fontWeight:"bold",color:"teal.700",children:"Capture: "}),"The app will guide you to capture both poses. You may need to retake if the pose isn't clear or your full body isn't visible."]})]})]}),K.jsx(bd,{colorScheme:"green",size:"lg",onClick:e,alignSelf:"center",mt:4,_hover:{bg:"green.600",transform:"translateY(-2px)",boxShadow:"lg"},children:"Next"})]})})}const jK=Uf(Po);function GK({onNavigate:t}){const[e,n]=ee.useState(""),[r,s]=ee.useState(""),o=zP(),i=c=>{n(c.target.value),r&&s("")},a=()=>{const c=parseFloat(e);if(!e||isNaN(c)){s("Please enter your height.");return}if(c<140||c>180){console.log(`Validation failed: ${c} is out of range (140-180)`),s("Height must be between 140 cm and 180 cm.");return}s(""),console.log("Height submitted:",c),localStorage.setItem("userHeight",c.toString()),o({title:"Height Saved.",description:`Your height is set to ${c} cm.`,status:"success",duration:3e3,isClosable:!0}),t("CAMERA")},l={hidden:{opacity:0,y:20},visible:{opacity:1,y:0,transition:{duration:.5}}};return K.jsx(Gf,{maxW:"container.sm",py:{base:8,md:12},display:"flex",alignItems:"center",minHeight:"80vh",children:K.jsx(jK,{bg:"white",p:{base:6,md:8},boxShadow:"md",borderRadius:"lg",width:"100%",variants:l,initial:"hidden",animate:"visible",children:K.jsxs(ra,{spacing:5,align:"stretch",children:[" ",K.jsx(xa,{as:MK,boxSize:{base:"40px",md:"50px"},color:"blue.500",alignSelf:"center",mb:-1}),K.jsx(Sd,{as:"h1",size:"lg",textAlign:"center",children:"Enter Your Height"}),K.jsx(Sr,{textAlign:"center",color:"gray.600",children:"Please enter your height in centimeters (cm). This is required for measurement analysis."}),K.jsxs(yP,{isInvalid:!!r,id:"height-input",children:[K.jsx(bP,{children:"Height"}),K.jsxs(kP,{children:[K.jsx(qb,{type:"number",placeholder:"e.g., 165",value:e,onChange:i,min:"140",max:"180"}),K.jsx(Qb,{children:"cm"})]}),r&&K.jsx(vP,{children:r})]}),K.jsx(bd,{colorScheme:"blue",size:"lg",onClick:a,mt:4,rightIcon:K.jsx(OK,{}),children:"Next: Capture Pose"})]})})})}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HK=1e-7,KK=1e-4;class VP{constructor(e,n){this.backend=e,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,n){this.dataIdsCount++,this.data.set(e,n)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Zb{refCount(e){return as("refCount")}incRef(e){return as("incRef")}timerAvailable(){return!0}time(e){return as("time")}read(e){return as("read")}readSync(e){return as("readSync")}readToGPU(e,n){return as("readToGPU")}numDataIds(){return as("numDataIds")}disposeData(e,n){return as("disposeData")}write(e,n,r){return as("write")}move(e,n,r,s,o){return as("move")}createTensorFromGPUData(e,n,r){return as("createTensorFromGPUData")}memory(){return as("memory")}floatPrecision(){return as("floatPrecision")}epsilon(){return this.floatPrecision()===32?HK:KK}dispose(){return as("dispose")}}function as(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xg(t,e,n){return Math.max(t,Math.min(e,n))}function Jb(t){return t%2===0?t:t+1}function bh(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function WP(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function z(t,e){if(!t)throw new Error(typeof e=="string"?e:e())}function gs(t,e,n=""){z(Mt(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function Cd(t){z(t!=null,()=>"The input to the tensor constructor must be a non-null value.")}function fe(t){if(t.length===0)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function lN(t){return t.length===0}function XK(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==null&&e[n]!==null&&t[n]!==e[n])return!1;return!0}function Mt(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function id(t){return t%1===0}function Zx(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function Yc(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function uN(t,e=s=>0,n,r){return new Promise((s,o)=>{let i=0;const a=()=>{if(t()){s();return}i++;const l=e(i);if(n!=null&&i>=n){o();return}r!=null?r(a,l):setTimeout(a,l)};a()})}function UP(t,e){let n=1,r=-1;for(let o=0;o<t.length;++o)if(t[o]>=0)n*=t[o];else if(t[o]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(t[o]<0)throw Error(`Shapes can not be < 0. Found ${t[o]} at dim ${o}`);if(r===-1){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(n===0)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const s=t.slice();return s[r]=e/n,s}function nn(t,e){const n=e.length;return t=t==null?e.map((r,s)=>s):[].concat(t),z(t.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),z(t.every(r=>id(r)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(r=>r<0?n+r:r)}function wl(t,e){const n=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,o=e==null||s?null:nn(e,t).sort();let i=0;for(let a=0;a<t.length;++a){if(o!=null){if(o[i]===a&&t[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${t[a]}' is not 1`);(o[i]==null||o[i]>a)&&t[a]===1&&(n.push(t[a]),r.push(a)),o[i]<=a&&i++}t[a]!==1&&(n.push(t[a]),r.push(a))}return{newShape:n,keptDims:r}}function bi(t,e){return En(t,e)}function En(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else if(t==="string")n=new Array(e);else throw new Error(`Unknown data type ${t}`);return n}function qK(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function YK(t){return t==="bool"||t==="complex64"||t==="float32"||t==="int32"||t==="string"}function jP(t,e){return!(e==="complex64"||e==="float32"&&t!=="complex64"||e==="int32"&&t!=="float32"&&t!=="complex64"||e==="bool"&&t==="bool")}function vg(t){if(t==="float32"||t==="int32")return 4;if(t==="complex64")return 8;if(t==="bool")return 1;throw new Error(`Unknown dtype ${t}`)}function QK(t){if(t==null)return 0;let e=0;return t.forEach(n=>e+=n.length),e}function Hf(t){return typeof t=="string"||t instanceof String}function ZK(t){return typeof t=="boolean"}function JK(t){return typeof t=="number"}function $d(t){return Array.isArray(t)?$d(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":JK(t)?"float32":Hf(t)?"string":ZK(t)?"bool":"float32"}function Jx(t){return!!(t&&t.constructor&&t.call&&t.apply)}function ev(t,e){for(let n=e;n<t;++n)if(t%n===0)return n;return t}function mn(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function GP(t,e,n,r=!1){const s=new Array;if(e.length===1){const o=e[0]*(r?2:1);for(let i=0;i<o;i++)s[i]=n[t+i]}else{const o=e[0],i=e.slice(1),a=i.reduce((l,c)=>l*c)*(r?2:1);for(let l=0;l<o;l++)s[l]=GP(t+l*a,i,n,r)}return s}function tv(t,e,n=!1){if(t.length===0)return e[0];const r=t.reduce((s,o)=>s*o)*(n?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return GP(0,t,e,n)}function W1(t,e){if(Array.isArray(t))return t;if(e==="float32")return t instanceof Float32Array?t:new Float32Array(t);if(e==="int32")return t instanceof Int32Array?t:new Int32Array(t);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(t));throw new Error(`Unknown dtype ${e}`)}function HP(t,e){const n=ua(t,e);for(let r=0;r<n.length;r++)n[r]=1;return n}function ua(t,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool")return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function Ds(t){t.forEach(e=>{z(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function nv(t,e,n){if(e===0)return 0;if(e===1)return t[0];let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=n[s]*t[s];return r}function ew(t,e,n){if(e===0)return[];if(e===1)return[t];const r=new Array(e);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(t/n[s]),t-=r[s]*n[s];return r[r.length-1]=t,r}function Eu(t){return t&&t.then&&typeof t.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cN="tfjsflags";class eX{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=tX,this.populateURLFlags()}setPlatform(e,n){this.platform!=null&&(oe().getBool("IS_TEST")||oe().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=n}registerFlag(e,n,r){if(this.flagRegistry[e]={evaluationFn:n,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];oe().getBool("IS_TEST")||oe().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const n=this.evaluateFlag(e);if(Eu(n))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=n,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,n){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=n,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(n)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);cN in e&&e[cN].split(",").forEach(r=>{const[s,o]=r.split(":");this.urlFlags[s]=rX(s,o)})}}function tX(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(nX(e,r[0],r[1]),r.join("="))),e}function nX(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}function rX(t,e){const n=e.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:e}function oe(){return KP}let KP=null;function sX(t){KP=t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let U1;function XP(){if(U1==null){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else if(typeof self<"u")t=self;else throw new Error("Could not find a global object");U1=t}return U1}function oX(){const t=XP();return t._tfGlobals==null&&(t._tfGlobals=new Map),t._tfGlobals}function tw(t,e){const n=oX();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const nw="Abs",rw="Acos",sw="Acosh",ny="Add",ow="AddN",iw="All",aw="Any",lw="ArgMax",uw="ArgMin",cw="Asin",dw="Asinh",hw="Atan",fw="Atanh",pw="Atan2",mw="AvgPool",qP="AvgPoolGrad",gw="AvgPool3D",YP="AvgPool3DGrad",yw="BatchMatMul",xw="BatchToSpaceND",vw="Bincount",QP="BitwiseAnd",bw="BroadcastArgs",ry="Cast",ww="Ceil",Sw="ClipByValue",Cw="Complex",$w="ComplexAbs",kw="Concat",Tw="Conv2D",Iw="Conv2DBackpropFilter",Nw="Conv2DBackpropInput",Ew="Conv3D",ZP="Conv3DBackpropFilterV2",Rw="Conv3DBackpropInputV2",_w="Cos",Pw="Cosh",Aw="Cumprod",Dw="Cumsum",Fw="CropAndResize",Ow="DenseBincount",Lw="DepthToSpace",zw="DepthwiseConv2dNative",Bw="DepthwiseConv2dNativeBackpropFilter",Mw="DepthwiseConv2dNativeBackpropInput",Vw="Diag",Ww="Dilation2D",iX="Dilation2DBackpropInput",aX="Dilation2DBackpropFilter",JP="Draw",Uw="RealDiv",jw="Einsum",Gw="Elu",eA="EluGrad",Hw="Erf",Kw="Equal",Xw="Exp",qw="ExpandDims",Yw="Expm1",Qw="FFT",Zw="Fill",Jw="FlipLeftRight",e2="Floor",t2="FloorDiv",n2="FusedBatchNorm",r2="GatherV2",s2="GatherNd",o2="Greater",i2="GreaterEqual",sy="Identity",a2="IFFT",l2="Imag",u2="IsFinite",c2="IsInf",d2="IsNan",h2="LeakyRelu",f2="Less",p2="LessEqual",m2="LinSpace",g2="Log",y2="Log1p",x2="LogicalAnd",v2="LogicalNot",b2="LogicalOr",w2="LRN",tA="LRNGrad",S2="Max",C2="Maximum",$2="MaxPool",nA="MaxPoolGrad",k2="MaxPool3D",rA="MaxPool3DGrad",T2="MaxPoolWithArgmax",I2="Mean",N2="Min",E2="Minimum",R2="MirrorPad",_2="Mod",P2="Multinomial",A2="Multiply",D2="Neg",F2="NotEqual",O2="NonMaxSuppressionV3",sA="NonMaxSuppressionV4",L2="NonMaxSuppressionV5",z2="OnesLike",B2="OneHot",M2="Pack",V2="PadV2",W2="Pow",U2="Prelu",j2="Prod",oA="RaggedGather",iA="RaggedRange",aA="RaggedTensorToTensor",G2="Range",H2="Real",K2="Reciprocal",X2="Relu",q2="Reshape",Y2="ResizeNearestNeighbor",lA="ResizeNearestNeighborGrad",Q2="ResizeBilinear",uA="ResizeBilinearGrad",Z2="Relu6",J2="Reverse",eS="Round",tS="Rsqrt",nS="ScatterNd",rS="TensorScatterUpdate",sS="SearchSorted",oS="Select",iS="Selu",aS="Slice",lS="Sin",uS="Sinh",cS="Sign",dS="Sigmoid",hS="Softplus",fS="Sqrt",pS="Sum",mS="SpaceToBatchND",gS="SplitV",yS="Softmax",cA="SparseFillEmptyRows",dA="SparseReshape",xS="SparseSegmentMean",vS="SparseSegmentSum",bS="SparseToDense",wS="SquaredDifference",hA="Square",fA="StaticRegexReplace",SS="StridedSlice",CS="StringNGrams",pA="StringSplit",mA="StringToHashBucketFast",$S="Sub",kS="Tan",TS="Tanh",oy="Tile",IS="TopK",NS="Transform",Qh="Transpose",gA="Unique",ES="Unpack",RS="UnsortedSegmentSum",_S="ZerosLike",PS="Step",bg="FromPixels",AS="RotateWithOffset",wg="_FusedMatMul",Sg="FusedConv2D",Cg="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oo(...t){oe().getBool("IS_TEST")||oe().getBool("PROD")||console.warn(...t)}function lX(...t){oe().getBool("IS_TEST")||oe().getBool("PROD")||console.log(...t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $g=tw("kernelRegistry",()=>new Map),uX=tw("gradRegistry",()=>new Map);function kg(t,e){const n=xA(t,e);return $g.get(n)}function dN(t){return uX.get(t)}function hN(t){const e=$g.entries(),n=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[o,i]=s,[a]=o.split("_");a===t&&n.push(i)}return n}function yA(t){const{kernelName:e,backendName:n}=t,r=xA(e,n);$g.has(r)&&Oo(`The kernel '${e}' for backend '${n}' is already registered`),$g.set(r,t)}function xA(t,e){return`${e}_${t}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vA(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}var j1,fN;function cX(){if(fN)return j1;fN=1,j1=e;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(V,A,re){this.low=V|0,this.high=A|0,this.unsigned=!!re}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function n(V){return(V&&V.__isLong__)===!0}e.isLong=n;var r={},s={};function o(V,A){var re,ae,pe;return A?(V>>>=0,(pe=0<=V&&V<256)&&(ae=s[V],ae)?ae:(re=a(V,(V|0)<0?-1:0,!0),pe&&(s[V]=re),re)):(V|=0,(pe=-128<=V&&V<128)&&(ae=r[V],ae)?ae:(re=a(V,V<0?-1:0,!1),pe&&(r[V]=re),re))}e.fromInt=o;function i(V,A){if(isNaN(V))return A?$:S;if(A){if(V<0)return $;if(V>=y)return O}else{if(V<=-9223372036854776e3)return M;if(V+1>=x)return F}return V<0?i(-V,A).neg():a(V%g|0,V/g|0,A)}e.fromNumber=i;function a(V,A,re){return new e(V,A,re)}e.fromBits=a;var l=Math.pow;function c(V,A,re){if(V.length===0)throw Error("empty string");if(V==="NaN"||V==="Infinity"||V==="+Infinity"||V==="-Infinity")return S;if(typeof A=="number"?(re=A,A=!1):A=!!A,re=re||10,re<2||36<re)throw RangeError("radix");var ae;if((ae=V.indexOf("-"))>0)throw Error("interior hyphen");if(ae===0)return c(V.substring(1),A,re).neg();for(var pe=i(l(re,8)),ye=S,ve=0;ve<V.length;ve+=8){var $e=Math.min(8,V.length-ve),se=parseInt(V.substring(ve,ve+$e),re);if($e<8){var me=i(l(re,$e));ye=ye.mul(me).add(i(se))}else ye=ye.mul(pe),ye=ye.add(i(se))}return ye.unsigned=A,ye}e.fromString=c;function d(V,A){return typeof V=="number"?i(V,A):typeof V=="string"?c(V,A):a(V.low,V.high,typeof A=="boolean"?A:V.unsigned)}e.fromValue=d;var f=65536,p=1<<24,g=f*f,y=g*g,x=y/2,w=o(p),S=o(0);e.ZERO=S;var $=o(0,!0);e.UZERO=$;var I=o(1);e.ONE=I;var R=o(1,!0);e.UONE=R;var _=o(-1);e.NEG_ONE=_;var F=a(-1,2147483647,!1);e.MAX_VALUE=F;var O=a(-1,-1,!0);e.MAX_UNSIGNED_VALUE=O;var M=a(0,-2147483648,!1);e.MIN_VALUE=M;var B=e.prototype;return B.toInt=function(){return this.unsigned?this.low>>>0:this.low},B.toNumber=function(){return this.unsigned?(this.high>>>0)*g+(this.low>>>0):this.high*g+(this.low>>>0)},B.toString=function(A){if(A=A||10,A<2||36<A)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(M)){var re=i(A),ae=this.div(re),pe=ae.mul(re).sub(this);return ae.toString(A)+pe.toInt().toString(A)}else return"-"+this.neg().toString(A);for(var ye=i(l(A,6),this.unsigned),ve=this,$e="";;){var se=ve.div(ye),me=ve.sub(se.mul(ye)).toInt()>>>0,ge=me.toString(A);if(ve=se,ve.isZero())return ge+$e;for(;ge.length<6;)ge="0"+ge;$e=""+ge+$e}},B.getHighBits=function(){return this.high},B.getHighBitsUnsigned=function(){return this.high>>>0},B.getLowBits=function(){return this.low},B.getLowBitsUnsigned=function(){return this.low>>>0},B.getNumBitsAbs=function(){if(this.isNegative())return this.eq(M)?64:this.neg().getNumBitsAbs();for(var A=this.high!=0?this.high:this.low,re=31;re>0&&(A&1<<re)==0;re--);return this.high!=0?re+33:re+1},B.isZero=function(){return this.high===0&&this.low===0},B.eqz=B.isZero,B.isNegative=function(){return!this.unsigned&&this.high<0},B.isPositive=function(){return this.unsigned||this.high>=0},B.isOdd=function(){return(this.low&1)===1},B.isEven=function(){return(this.low&1)===0},B.equals=function(A){return n(A)||(A=d(A)),this.unsigned!==A.unsigned&&this.high>>>31===1&&A.high>>>31===1?!1:this.high===A.high&&this.low===A.low},B.eq=B.equals,B.notEquals=function(A){return!this.eq(A)},B.neq=B.notEquals,B.ne=B.notEquals,B.lessThan=function(A){return this.comp(A)<0},B.lt=B.lessThan,B.lessThanOrEqual=function(A){return this.comp(A)<=0},B.lte=B.lessThanOrEqual,B.le=B.lessThanOrEqual,B.greaterThan=function(A){return this.comp(A)>0},B.gt=B.greaterThan,B.greaterThanOrEqual=function(A){return this.comp(A)>=0},B.gte=B.greaterThanOrEqual,B.ge=B.greaterThanOrEqual,B.compare=function(A){if(n(A)||(A=d(A)),this.eq(A))return 0;var re=this.isNegative(),ae=A.isNegative();return re&&!ae?-1:!re&&ae?1:this.unsigned?A.high>>>0>this.high>>>0||A.high===this.high&&A.low>>>0>this.low>>>0?-1:1:this.sub(A).isNegative()?-1:1},B.comp=B.compare,B.negate=function(){return!this.unsigned&&this.eq(M)?M:this.not().add(I)},B.neg=B.negate,B.add=function(A){n(A)||(A=d(A));var re=this.high>>>16,ae=this.high&65535,pe=this.low>>>16,ye=this.low&65535,ve=A.high>>>16,$e=A.high&65535,se=A.low>>>16,me=A.low&65535,ge=0,Q=0,he=0,be=0;return be+=ye+me,he+=be>>>16,be&=65535,he+=pe+se,Q+=he>>>16,he&=65535,Q+=ae+$e,ge+=Q>>>16,Q&=65535,ge+=re+ve,ge&=65535,a(he<<16|be,ge<<16|Q,this.unsigned)},B.subtract=function(A){return n(A)||(A=d(A)),this.add(A.neg())},B.sub=B.subtract,B.multiply=function(A){if(this.isZero())return S;if(n(A)||(A=d(A)),t){var re=t.mul(this.low,this.high,A.low,A.high);return a(re,t.get_high(),this.unsigned)}if(A.isZero())return S;if(this.eq(M))return A.isOdd()?M:S;if(A.eq(M))return this.isOdd()?M:S;if(this.isNegative())return A.isNegative()?this.neg().mul(A.neg()):this.neg().mul(A).neg();if(A.isNegative())return this.mul(A.neg()).neg();if(this.lt(w)&&A.lt(w))return i(this.toNumber()*A.toNumber(),this.unsigned);var ae=this.high>>>16,pe=this.high&65535,ye=this.low>>>16,ve=this.low&65535,$e=A.high>>>16,se=A.high&65535,me=A.low>>>16,ge=A.low&65535,Q=0,he=0,be=0,We=0;return We+=ve*ge,be+=We>>>16,We&=65535,be+=ye*ge,he+=be>>>16,be&=65535,be+=ve*me,he+=be>>>16,be&=65535,he+=pe*ge,Q+=he>>>16,he&=65535,he+=ye*me,Q+=he>>>16,he&=65535,he+=ve*se,Q+=he>>>16,he&=65535,Q+=ae*ge+pe*me+ye*se+ve*$e,Q&=65535,a(be<<16|We,Q<<16|he,this.unsigned)},B.mul=B.multiply,B.divide=function(A){if(n(A)||(A=d(A)),A.isZero())throw Error("division by zero");if(t){if(!this.unsigned&&this.high===-2147483648&&A.low===-1&&A.high===-1)return this;var re=(this.unsigned?t.div_u:t.div_s)(this.low,this.high,A.low,A.high);return a(re,t.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?$:S;var ae,pe,ye;if(this.unsigned){if(A.unsigned||(A=A.toUnsigned()),A.gt(this))return $;if(A.gt(this.shru(1)))return R;ye=$}else{if(this.eq(M)){if(A.eq(I)||A.eq(_))return M;if(A.eq(M))return I;var ve=this.shr(1);return ae=ve.div(A).shl(1),ae.eq(S)?A.isNegative()?I:_:(pe=this.sub(A.mul(ae)),ye=ae.add(pe.div(A)),ye)}else if(A.eq(M))return this.unsigned?$:S;if(this.isNegative())return A.isNegative()?this.neg().div(A.neg()):this.neg().div(A).neg();if(A.isNegative())return this.div(A.neg()).neg();ye=S}for(pe=this;pe.gte(A);){ae=Math.max(1,Math.floor(pe.toNumber()/A.toNumber()));for(var $e=Math.ceil(Math.log(ae)/Math.LN2),se=$e<=48?1:l(2,$e-48),me=i(ae),ge=me.mul(A);ge.isNegative()||ge.gt(pe);)ae-=se,me=i(ae,this.unsigned),ge=me.mul(A);me.isZero()&&(me=I),ye=ye.add(me),pe=pe.sub(ge)}return ye},B.div=B.divide,B.modulo=function(A){if(n(A)||(A=d(A)),t){var re=(this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,A.low,A.high);return a(re,t.get_high(),this.unsigned)}return this.sub(this.div(A).mul(A))},B.mod=B.modulo,B.rem=B.modulo,B.not=function(){return a(~this.low,~this.high,this.unsigned)},B.and=function(A){return n(A)||(A=d(A)),a(this.low&A.low,this.high&A.high,this.unsigned)},B.or=function(A){return n(A)||(A=d(A)),a(this.low|A.low,this.high|A.high,this.unsigned)},B.xor=function(A){return n(A)||(A=d(A)),a(this.low^A.low,this.high^A.high,this.unsigned)},B.shiftLeft=function(A){return n(A)&&(A=A.toInt()),(A&=63)===0?this:A<32?a(this.low<<A,this.high<<A|this.low>>>32-A,this.unsigned):a(0,this.low<<A-32,this.unsigned)},B.shl=B.shiftLeft,B.shiftRight=function(A){return n(A)&&(A=A.toInt()),(A&=63)===0?this:A<32?a(this.low>>>A|this.high<<32-A,this.high>>A,this.unsigned):a(this.high>>A-32,this.high>=0?0:-1,this.unsigned)},B.shr=B.shiftRight,B.shiftRightUnsigned=function(A){if(n(A)&&(A=A.toInt()),A&=63,A===0)return this;var re=this.high;if(A<32){var ae=this.low;return a(ae>>>A|re<<32-A,re>>>A,this.unsigned)}else return A===32?a(re,0,this.unsigned):a(re>>>A-32,0,this.unsigned)},B.shru=B.shiftRightUnsigned,B.shr_u=B.shiftRightUnsigned,B.toSigned=function(){return this.unsigned?a(this.low,this.high,!1):this},B.toUnsigned=function(){return this.unsigned?this:a(this.low,this.high,!0)},B.toBytes=function(A){return A?this.toBytesLE():this.toBytesBE()},B.toBytesLE=function(){var A=this.high,re=this.low;return[re&255,re>>>8&255,re>>>16&255,re>>>24,A&255,A>>>8&255,A>>>16&255,A>>>24]},B.toBytesBE=function(){var A=this.high,re=this.low;return[A>>>24,A>>>16&255,A>>>8&255,A&255,re>>>24,re>>>16&255,re>>>8&255,re&255]},e.fromBytes=function(A,re,ae){return ae?e.fromBytesLE(A,re):e.fromBytesBE(A,re)},e.fromBytesLE=function(A,re){return new e(A[0]|A[1]<<8|A[2]<<16|A[3]<<24,A[4]|A[5]<<8|A[6]<<16|A[7]<<24,re)},e.fromBytesBE=function(A,re){return new e(A[4]<<24|A[5]<<16|A[6]<<8|A[7],A[0]<<24|A[1]<<16|A[2]<<8|A[3],re)},j1}var bA=cX();const wA=Df(bA),dX=L3({__proto__:null,default:wA},[bA]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cu=wA||dX;function iy(t){return cu.fromString(t,!0,16)}const SA=iy("c3a5c85c97cb3127"),au=iy("b492b66fbe98f273"),$r=iy("9ae16a3b2f90404f");function rv(t){return t.xor(t.shru(47))}function CA(t,e,n){const r=t.slice(e,e+n);return cu.fromBytes(Array.from(r),!0,!0)}function Zt(t,e){return CA(t,e,8)}function pN(t,e){return CA(t,e,4)}function Fn(t,e){return e===0?t:t.shru(e).or(t.shl(64-e))}function ul(t,e,n=iy("9ddfea08eb382d69")){let r=t.xor(e).mul(n);r=r.xor(r.shru(47));let s=e.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function hX(t,e,n,r,s,o){s=s.add(t),o=Fn(o.add(s).add(r),21);const i=s;return s=s.add(e),s=s.add(n),o=o.add(Fn(s,44)),[s.add(r),o.add(i)]}function vm(t,e,n,r){return hX(Zt(t,e),Zt(t,e+8),Zt(t,e+16),Zt(t,e+24),n,r)}function fX(t,e=t.length){if(e>=8){const n=$r.add(e*2),r=Zt(t,0).add($r),s=Zt(t,e-8),o=Fn(s,37).mul(n).add(r),i=Fn(r,25).add(s).mul(n);return ul(o,i,n)}if(e>=4){const n=$r.add(e*2),r=pN(t,0);return ul(r.shl(3).add(e),pN(t,e-4),n)}if(e>0){const n=t[0],r=t[e>>1],s=t[e-1],o=n+(r<<8),i=e+(s<<2);return rv($r.mul(o).xor(SA.mul(i))).mul($r)}return $r}function pX(t,e=t.length){const n=$r.add(e*2),r=Zt(t,0).mul(au),s=Zt(t,8),o=Zt(t,e-8).mul(n),i=Zt(t,e-16).mul($r);return ul(Fn(r.add(s),43).add(Fn(o,30)).add(i),r.add(Fn(s.add($r),18)).add(o),n)}function mX(t,e=t.length){const n=$r.add(e*2),r=Zt(t,0).mul($r),s=Zt(t,8),o=Zt(t,e-8).mul(n),i=Zt(t,e-16).mul($r),a=Fn(r.add(s),43).add(Fn(o,30)).add(i),l=ul(a,r.add(Fn(s.add($r),18)).add(o),n),c=Zt(t,16).mul(n),d=Zt(t,24),f=a.add(Zt(t,e-32)).mul(n),p=l.add(Zt(t,e-24)).mul(n);return ul(Fn(c.add(d),43).add(Fn(f,30)).add(p),c.add(Fn(d.add(r),18)).add(f),n)}function gX(t,e=t.length){const n=cu.fromNumber(81,!0);if(e<=32)return e<=16?fX(t,e):pX(t,e);if(e<=64)return mX(t,e);let r=n,s=n.mul(au).add(113),o=rv(s.mul($r).add(113)).mul($r),i=[cu.UZERO,cu.UZERO],a=[cu.UZERO,cu.UZERO];r=r.mul($r).add(Zt(t,0));let l=0;const c=(e-1>>6)*64,d=c+(e-1&63)-63;do r=Fn(r.add(s).add(i[0]).add(Zt(t,l+8)),37).mul(au),s=Fn(s.add(i[1]).add(Zt(t,l+48)),42).mul(au),r=r.xor(a[1]),s=s.add(i[0]).add(Zt(t,l+40)),o=Fn(o.add(a[0]),33).mul(au),i=vm(t,l,i[1].mul(au),r.add(a[0])),a=vm(t,l+32,o.add(a[1]),s.add(Zt(t,l+16))),[o,r]=[r,o],l+=64;while(l!==c);const f=au.add(o.and(255).shl(1));return l=d,a[0]=a[0].add(e-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),r=Fn(r.add(s).add(i[0]).add(Zt(t,l+8)),37).mul(f),s=Fn(s.add(i[1]).add(Zt(t,l+48)),42).mul(f),r=r.xor(a[1].mul(9)),s=s.add(i[0].mul(9).add(Zt(t,l+40))),o=Fn(o.add(a[0]),33).mul(f),i=vm(t,l,i[1].mul(f),r.add(a[0])),a=vm(t,l+32,o.add(a[1]),s.add(Zt(t,l+16))),[o,r]=[r,o],ul(ul(i[0],a[0],f).add(rv(s).mul(SA)).add(o),ul(i[1],a[1],f).add(r),f)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kd(t,e){return e==="string"?cl(t):ay([t],e)}function yX(t,e){return t instanceof Float32Array&&e==="float32"||t instanceof Int32Array&&e==="int32"||t instanceof Uint8Array&&e==="bool"}function ay(t,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=da(t)),oe().getBool("DEBUG")&&qK(t,e),yX(t,e))return t;if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool"){const n=new Uint8Array(t.length);for(let r=0;r<n.length;++r)Math.round(t[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${e}`)}function _o(){return oe().platform.now()}function cl(t,e="utf-8"){return e=e||"utf-8",oe().platform.encode(t,e)}function ca(t,e="utf-8"){return e=e||"utf-8",oe().platform.decode(t,e)}function uo(t){return oe().platform.isTypedArray!=null?oe().platform.isTypedArray(t):vA(t)}function da(t,e=[],n=!1){if(e==null&&(e=[]),typeof t=="boolean"||typeof t=="number"||typeof t=="string"||Eu(t)||t==null||uo(t)&&n)e.push(t);else if(Array.isArray(t)||uo(t))for(let r=0;r<t.length;++r)da(t[r],e,n);else{let r=-1;for(const s of Object.keys(t))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)da(t[s],e,n)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xX{constructor(e,n){this.backendTimer=e,this.logger=n,n==null&&(this.logger=new bX)}profileKernel(e,n,r){let s;const o=()=>{s=r()};let i;const a=_o();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(o);else{o();for(const c of s)c.dataSync();i=Promise.resolve({kernelMs:_o()-a})}if(oe().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<s.length;c++){const d=s[c];d.data().then(f=>{vX(f,d.dtype,e)})}return{kernelName:e,outputs:s,inputs:n,timeMs:i.then(c=>c.kernelMs),extraInfo:i.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:n,outputs:r,timeMs:s,inputs:o,extraInfo:i}=e;r.forEach(a=>{Promise.all([a.data(),s,i]).then(l=>{this.logger.logKernelProfile(n,a,l[0],l[1],o,l[2])})})}}function vX(t,e,n){if(e!=="float32")return!1;for(let r=0;r<t.length;r++){const s=t[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${n}'`),!0}return!1}class bX{logKernelProfile(e,n,r,s,o,i){const a=typeof s=="number"?Yc(`${s}ms`,9):s.error,l=Yc(e,25),c=n.rank,d=n.size,f=Yc(n.shape.toString(),14);let p="";for(const g in o){const y=o[g];if(y!=null){const x=y.shape||n.shape,w=x.length;p+=`${g}: ${w}D ${w>0?x:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${f}	%c${d}	%c${p}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wX(t,e,n){const r={},s={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<t.length;l++){const c=t[l],d=c.inputs;for(const f in d){const p=d[f];let g=!1;for(let y=0;y<e.length;y++)if(r[p.id]){c.outputs.forEach(x=>r[x.id]=!0),g=!0,s[c.id]=!0;break}if(g)break}}const o={};o[n.id]=!0;const i={};for(let l=t.length-1;l>=0;l--){const c=t[l],d=c.inputs;for(let f=0;f<c.outputs.length;f++)if(o[c.outputs[f].id]){for(const p in d)o[d[p].id]=!0,i[c.id]=!0;break}}const a=[];for(let l=0;l<t.length;l++){const c=t[l];if(s[c.id]&&i[c.id]){const d={};for(const p in c.inputs){const g=c.inputs[p];r[g.id]&&(d[p]=g)}const f=Object.assign({},c);f.inputs=d,f.outputs=c.outputs,a.push(f)}}return a}function SX(t,e,n,r){for(let s=e.length-1;s>=0;s--){const o=e[s],i=[];if(o.outputs.forEach(l=>{const c=t[l.id];c!=null?i.push(c):i.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const a=o.gradient(i);for(const l in o.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=n(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const d=o.inputs[l];if(!Mt(c.shape,d.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${d.shape}'`);if(t[d.id]==null)t[d.id]=c;else{const f=t[d.id];t[d.id]=r(f,c),f.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mN=20,wh=3,G1=7;function CX(t,e,n,r){const s=mn(e),o=$X(t,e,n,s),i=e.length,a=Gm(t,e,n,s,o),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function $X(t,e,n,r){const s=fe(e),o=r[r.length-1],i=new Array(o).fill(0),a=e.length,l=n==="complex64"?Oh(t):t;if(a>1)for(let c=0;c<s/o;c++){const d=c*o;for(let f=0;f<o;f++)i[f]=Math.max(i[f],Fh(l[d+f],0,n).length)}return i}function Fh(t,e,n){let r;return Array.isArray(t)?r=`${parseFloat(t[0].toFixed(G1))} + ${parseFloat(t[1].toFixed(G1))}j`:Hf(t)?r=`'${t}'`:n==="bool"?r=$A(t):r=parseFloat(t.toFixed(G1)).toString(),Yc(r,e)}function $A(t){return t===0?"false":"true"}function Gm(t,e,n,r,s,o=!0){const i=n==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(n==="complex64"){const x=Oh(t);return[Fh(x[0],0,n)]}return n==="bool"?[$A(t[0])]:[t[0].toString()]}if(l===1){if(a>mN){const w=wh*i;let S=Array.from(t.slice(0,w)),$=Array.from(t.slice((a-wh)*i,a*i));return n==="complex64"&&(S=Oh(S),$=Oh($)),["["+S.map((I,R)=>Fh(I,s[R],n)).join(", ")+", ..., "+$.map((I,R)=>Fh(I,s[a-wh+R],n)).join(", ")+"]"]}return["["+(n==="complex64"?Oh(t):Array.from(t)).map((w,S)=>Fh(w,s[S],n)).join(", ")+"]"]}const c=e.slice(1),d=r.slice(1),f=r[0]*i,p=[];if(a>mN){for(let x=0;x<wh;x++){const w=x*f,S=w+f;p.push(...Gm(t.slice(w,S),c,n,d,s,!1))}p.push("...");for(let x=a-wh;x<a;x++){const w=x*f,S=w+f;p.push(...Gm(t.slice(w,S),c,n,d,s,x===a-1))}}else for(let x=0;x<a;x++){const w=x*f,S=w+f;p.push(...Gm(t.slice(w,S),c,n,d,s,x===a-1))}const g=l===2?",":"";p[0]="["+(a>0?p[0]+g:"");for(let x=1;x<p.length-1;x++)p[x]=" "+p[x]+g;let y=`,
`;for(let x=2;x<l;x++)y+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(o?"":y),p}function Oh(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ad{constructor(e,n,r){if(this.dtype=n,this.shape=e.slice(),this.size=fe(e),r!=null){const s=r.length;z(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||En(n,this.size),this.strides=mn(e)}set(e,...n){n.length===0&&(n=[0]),z(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const r=this.locToIndex(n);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let n=0;for(const s of e){if(s<0||s>=this.shape[n]){const o=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(o)}n++}let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=this.strides[s]*e[s];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return n}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const n=new Array(this.shape.length);for(let r=0;r<n.length-1;++r)n[r]=Math.floor(e/this.strides[r]),e-=n[r]*this.strides[r];return n[n.length-1]=e,n}get rank(){return this.shape.length}toTensor(){return Ao().makeTensor(this.values,this.shape,this.dtype)}}let Ao=null,Ec=null;function kX(t){Ao=t}function TX(t){Ec=t}class hn{constructor(e,n,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=n||"float32",this.size=fe(e),this.strides=mn(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Ec.buffer(this.shape,this.dtype,e)}bufferSync(){return Ec.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return tv(this.shape,e,this.dtype==="complex64")}arraySync(){return tv(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Ao().read(this.dataId);if(this.dtype==="string"){const n=await e;try{return n.map(r=>ca(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Ao().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Ao().readSync(this.dataId);if(this.dtype==="string")try{return e.map(n=>ca(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Ao().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Ao().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Ec.print(this,e)}clone(){return this.throwIfDisposed(),Ec.clone(this)}toString(e=!1){const n=this.dataSync();return CX(n,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Ec.cast(this,e)}variable(e=!0,n,r){return this.throwIfDisposed(),Ao().makeVariable(this,e,n,r)}}Object.defineProperty(hn,Symbol.hasInstance,{value:t=>!!t&&t.data!=null&&t.dataSync!=null&&t.throwIfDisposed!=null});function kA(){return tw("Tensor",()=>hn)}kA();class Tg extends hn{constructor(e,n,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=n,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Mt(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Ao().disposeTensor(this),this.dataId=e.dataId,Ao().incRef(this,null)}dispose(){Ao().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Tg,Symbol.hasInstance,{value:t=>t instanceof hn&&t.assign!=null&&t.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var gN;(function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"})(gN||(gN={}));var sv;(function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"})(sv||(sv={}));var ov;(function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"})(ov||(ov={}));var iv;(function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"})(iv||(iv={}));var av;(function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"})(av||(av={}));const IX={float32:iv,int32:sv,bool:ov,complex64:av};function Ur(t,e){if(t==="string"||e==="string"){if(t==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return IX[t][e]}function ly(t){return Ur(t,"int32")}function TA(t){return t!=null&&typeof t=="object"&&"texture"in t&&t.texture instanceof WebGLTexture}function IA(t){return typeof GPUBuffer<"u"&&t!=null&&typeof t=="object"&&"buffer"in t&&t.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gn(t,e){if(t.dtype===e.dtype)return[t,e];const n=Ur(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function NX(t,e){z(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function NA(t){const e=[];return EA(t,e,new Set),e}function EA(t,e,n){if(t==null)return;if(t instanceof hn){e.push(t);return}if(!EX(t))return;const r=t;for(const s in r){const o=r[s];n.has(o)||(n.add(o),EA(o,e,n))}}function EX(t){return Array.isArray(t)||typeof t=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H1(t){return t.kernelName!=null}class yN{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class ld{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new yN}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:n}=this.initializeBackend(e);if(n)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,n,r=1){return e in this.registryFactory?(Oo(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:n,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:n,asyncInit:r}=this.initializeBackend(e);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new xX(this.backendInstance),!0}setupRegisteredKernels(){hN(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){hN(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const n=this.registryFactory[e];if(n==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=n.factory();if(r&&!(r instanceof Zb)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,o=r.then(i=>s<this.pendingBackendInitId?!1:(this.registry[e]=i,this.pendingBackendInit=null,!0)).catch(i=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,Oo(`Initialization of backend ${e} failed`),Oo(i.stack||i.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return Oo(`Initialization of backend ${e} failed`),Oo(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,n)=>this.registryFactory[n].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n],{success:s,asyncInit:o}=this.initializeBackend(r);if(o||s)return{name:r,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,n){const r=this.state.tensorInfo.get(n),s=r.backend,o=this.readSync(n),i=s.refCount(n);s.disposeData(n,!0),r.backend=e,e.move(n,o,r.shape,r.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,n){let r=null;if(n==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");n=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=n(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,n,r){e();try{const s=r();return n(),s}catch(s){throw n(),s}}nextTensorId(){return ld.nextTensorId++}nextVariableId(){return ld.nextVariableId++}clone(e){const n=q.runKernel(sy,{x:e}),r={x:e},s=i=>({x:()=>{const a="float32",l={x:i},c={dtype:a};return q.runKernel(ry,l,c)}}),o=[];return this.addTapeNode(this.state.activeScope.name,r,[n],s,o,{}),n}runKernel(e,n,r){if(this.backendName==null&&this.backend,!(kg(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,n,r){const s=this.backend.numDataIds();let o=0;r.forEach(l=>{o+=l.dtype==="complex64"?3:1});const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=s-n-o-i;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let n,r=[];const s=this.isTapeOn(),o=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const c=H1(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(H1(e)){const{kernelName:y,inputs:x,attrs:w}=e;this.backendName==null&&this.backend;const S=kg(y,this.backendName);z(S!=null,()=>`Cannot find registered kernel '${y}' for backend '${this.backendName}'`),a=()=>{const $=this.backend.numDataIds();l=S.kernelFunc({inputs:x,attrs:w,backend:this.backend});const I=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(y,$,I);const R=I.map(_=>_.rank!=null?_:this.makeTensorFromTensorInfo(_));if(s){const _=this.getTensorsForGradient(y,x,R);r=this.saveTensorsForBackwardMode(_)}return R}}else{const{forwardFunc:y}=e,x=w=>{s&&(r=w.map(S=>this.keep(this.clone(S))))};a=()=>{const w=this.backend.numDataIds();l=this.tidy(()=>y(this.backend,x));const S=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,w,S),S}}const{inputs:d,attrs:f}=e,p=H1(e)?null:e.backwardsFunc;let g;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=a():(g=this.profiler.profileKernel(c,d,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(g),n=g.outputs)}),s&&this.addTapeNode(c,d,n,p,r,f),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(y=>d[y]!=null?d[y].shape:null),outputShapes:n.map(y=>y.shape),kernelTimeMs:g.timeMs,extraInfo:g.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,n,r){const s=dN(e);if(s!=null){const o=s.inputsToSave||[],i=s.outputsToSave||[];let a;s.saveAllInputs?(z(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(n).map(c=>n[c])):a=o.map(c=>n[c]);const l=r.filter((c,d)=>i[d]);return a.concat(l)}return[]}makeTensor(e,n,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let o=e;r==="string"&&Hf(e[0])&&(o=e.map(l=>cl(l)));const i=s.write(o,n,r),a=new hn(n,r,i,this.nextTensorId());if(this.trackTensor(a,s),r==="string"){const l=this.state.tensorInfo.get(i),c=QK(o);this.state.numBytes+=c-l.bytes,l.bytes=c}return a}makeTensorFromDataId(e,n,r,s){r=r||"float32";const o={dataId:e,shape:n,dtype:r};return this.makeTensorFromTensorInfo(o,s)}makeTensorFromTensorInfo(e,n){const{dataId:r,shape:s,dtype:o}=e,i=new hn(s,o,r,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(e,n=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const o=new Tg(e,n,r,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,n){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*vg(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:n||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof Tg||this.track(e)}incRef(e,n){this.trackTensor(e,n),this.backend.incRef(e.dataId)}removeDataId(e,n){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===n&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const n=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*vg(e.dtype);this.state.numBytes-=r}n.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,n.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const n=this.state.registeredVariables[e];this.disposeVariable(n)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,n,r,s,o,i){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:n,outputs:r,saved:o},l=dN(e);l!=null&&(s=l.gradFunc),s!=null&&(a.gradient=c=>(c=c.map((d,f)=>{if(d==null){const p=r[f],g=ua(p.size,p.dtype);return this.makeTensor(g,p.shape,p.dtype)}return d}),s(c.length>1?c:c[0],o,i))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(n.name=e),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(e){const n=NA(e),r=new Set(n.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const i=this.state.activeScope.track[o];!i.kept&&!r.has(i.id)&&i.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(o=>{!o.kept&&o.scopeId===s.id&&this.track(o)})}gradients(e,n,r,s=!1){if(z(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));z(o instanceof hn,()=>"The result y returned by f() must be a tensor.");const i=wX(this.state.activeTape,n,o);if(!s&&i.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[o.id]=r??RX(o.shape),SX(a,i,c=>this.tidy(c),_X);const l=n.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const d of c.saved)d.dispose()}),this.state.activeTape=null),{value:o,grads:l}})}customGrad(e){return z(Jx(e),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{z(n.every(a=>a instanceof hn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};n.forEach((a,l)=>{s[l]=a});const o=(a,l)=>(r=e(...n,l),z(r.value instanceof hn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),z(Jx(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),i=(a,l)=>{const c=r.gradFunc(a,l),d=Array.isArray(c)?c:[c];z(d.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),z(d.every(p=>p instanceof hn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const f={};return d.forEach((p,g)=>{f[g]=()=>p}),f};return this.runKernelFunc({forwardFunc:o,backwardsFunc:i,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,n){return this.state.tensorInfo.get(e).backend.readToGPU(e,n)}async time(e){const n=_o(),r=await this.backend.time(e);return r.wallMs=_o()-n,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new yN;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}ld.nextTensorId=0;ld.nextVariableId=0;function RX(t){const e=HP(fe(t),"float32");return q.makeTensor(e,t,"float32")}function RA(){const t=XP();if(t._tfengine==null){const e=new eX(t);t._tfengine=new ld(e)}return sX(t._tfengine.ENV),kX(()=>t._tfengine),t._tfengine}const q=RA();function _X(t,e){const n={a:t,b:e};return q.runKernel(ny,n)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PX(){return typeof navigator<"u"&&navigator!=null}function _A(t){if(t||PX()){if(t||(t=navigator),t.product==="ReactNative")return!0;const e=t.userAgent||t.vendor||(typeof window<"u"?window.opera:"");if(!e){const n=t;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function PA(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jr=oe();jr.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});jr.registerFlag("IS_BROWSER",()=>PA());jr.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");jr.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));jr.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));jr.registerFlag("PROD",()=>!1);jr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>jr.getBool("DEBUG"));jr.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);jr.registerFlag("IS_TEST",()=>!1);jr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>jr.getBool("DEBUG"));jr.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);jr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);jr.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sl(t,e){let n=t;if(uo(t))return e==="string"?[]:[t.length];if(TA(t)){const s=t.channels||"RGBA";return[t.height,t.width*s.length]}else if(IA(t))return[t.buffer.size/(e==null?4:vg(e))];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||uo(n)&&e!=="string";)r.push(n.length),n=n[0];return Array.isArray(t)&&oe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&AA(t,r,[]),r}function AA(t,e,n){if(n=n||[],!Array.isArray(t)&&!uo(t)){z(e.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}z(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),z(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const r=e.slice(1);for(let s=0;s<t.length;++s)AA(t[s],r,n.concat(s))}function xN(t,e,n,r){if(t!=="string_or_numeric"){if(t==null)throw new Error("Expected dtype cannot be null.");if(t!=="numeric"&&t!==e||t==="numeric"&&e==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}}function L(t,e,n,r="numeric"){if(t instanceof kA())return xN(r,t.dtype,e,n),t;let s=$d(t);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),xN(r,s,e,n),t==null||!uo(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string"){const l=t==null?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${l}'`)}const o=Sl(t,s);!uo(t)&&!Array.isArray(t)&&(t=[t]);const a=s!=="string"?ay(t,s):da(t,[],!0);return q.makeTensor(a,o,s)}function Ig(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((o,i)=>L(o,`${e}[${i}]`,n,r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DA="__op";function X(t){const e=Object.keys(t);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+DA;const s=(...o)=>{q.startScope(n);try{const i=r(...o);return Eu(i)&&console.error("Cannot return a Promise inside of tidy."),q.endScope(i),i}catch(i){throw q.endScope(null),i}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AX(t,e){const n=L(t,"real","complex"),r=L(e,"imag","complex");gs(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return q.runKernel(Cw,s)}const ml=X({complex_:AX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cl(t,e,n,r){if(r==null)r=$d(t);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(IA(t)||TA(t)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return q.backend.createTensorFromGPUData(t,e||n,r)}if(!uo(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Ds(e);const s=fe(e),o=fe(n);z(s===o,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${o}`);for(let i=0;i<n.length;++i){const a=n[i],l=i===n.length-1?a!==fe(e.slice(i)):!0;z(n[i]===e[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return!uo(t)&&!Array.isArray(t)&&(t=[t]),e=e||n,t=r!=="string"?ay(t,r):da(t,[],!0),q.makeTensor(t,e,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yi(t,e,n){const r=Sl(t,n);return Cl(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ru={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class zo{static join(e){return new zo(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(r=>uo(r)?r.buffer:r),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let n=0;for(let r=0;r<e.length;r++){const s=e[r];r!==e.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const o=n+s.byteLength;this.shards.push({buffer:s,start:n,end:o}),n=o}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,n=isNaN(Number(n))?0:n,e=Math.max(0,e),n=Math.min(this.byteLength,n),n<=e)return new ArrayBuffer(0);const r=this.findShardForByte(e);if(r===-1)throw new Error(`Could not find start shard for byte ${e}`);const s=n-e,o=new ArrayBuffer(s),i=new Uint8Array(o);let a=0;for(let l=r;l<this.shards.length;l++){const c=this.shards[l],f=e+a-c.start,p=a,y=Math.min(n,c.end)-c.start,x=new Uint8Array(c.buffer,f,y-f);if(i.set(x,p),a+=x.length,n<c.end)break}return o}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function n(s){return e<s.start?-1:e>=s.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const r=DX(this.shards,n);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function DX(t,e){let n=0,r=t.length;for(;n<=r;){const s=Math.floor((r-n)/2)+n,o=e(t[s]);if(o===0)return s;o<0?r=s:n=s+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cs(){return q}function tt(t,e){return q.tidy(t,e)}function Bt(t){NA(t).forEach(n=>n.dispose())}function ci(t){return q.keep(t)}function FX(t){return q.setBackend(t)}function OX(){return q.ready()}function gf(){return q.backendName}function FA(t,e,n=1){return q.registerBackend(t,e,n)}function ud(){return q.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gl=4;async function LX(t,e){const n=[],r=[],s=Array.isArray(t)?t.map(i=>i.name):Object.keys(t);for(let i=0;i<s.length;++i){const a=s[i],l=Array.isArray(t)?t[i].tensor:t[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const c={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const d=new Promise(async f=>{const p=await l.bytes(),g=p.reduce((w,S)=>w+S.length,0)+gl*p.length,y=new Uint8Array(g);let x=0;for(let w=0;w<p.length;w++){const S=p[w],$=new Uint8Array(new Uint32Array([S.length]).buffer);y.set($,x),x+=gl,y.set(S,x),x+=S.length}f(y)});r.push(d)}else r.push(l.data());e!=null&&(c.group=e),n.push(c)}const o=await Promise.all(r);return{data:MX(o),specs:n}}function OA(t,e){const n=new zo(t),r={};let s=0;for(const o of e){const i=zX(o,(a,l)=>n.slice(s+a,s+l));r[o.name]=LA(o,n.slice(s,s+i)),s+=i}return r}function zX(t,e){const n=fe(t.shape);let r;if("quantization"in t){const s=t.quantization;r=Ru[s.dtype]}else if(t.dtype==="string"){let s=0;for(let o=0;o<n;o++)s+=gl+new Uint32Array(e(s,s+gl))[0];return s}else r=Ru[t.dtype];return n*r}async function BX(t,e){const n=fe(t.shape);let r;if("quantization"in t){const s=t.quantization;r=Ru[s.dtype]}else if(t.dtype==="string"){let s=0;for(let o=0;o<n;o++)s+=gl+new Uint32Array(await e(s,s+gl))[0];return s}else r=Ru[t.dtype];return n*r}function LA(t,e){const n=t.name,r=t.dtype,s=t.shape,o=fe(s);let i,a=0;if("quantization"in t){const l=t.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${t.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${t.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${t.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const c=Ru[l.dtype],d=l.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(r==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){i=new Float32Array(d.length);for(let f=0;f<d.length;f++){const p=d[f];i[f]=p*l.scale+l.min}}else if(l.dtype==="float16")i=KX()(d);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(r==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(d.length);for(let f=0;f<d.length;f++){const p=d[f];i[f]=Math.round(p*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);a+=o*c}else if(r==="string"){const l=fe(t.shape);i=[];for(let c=0;c<l;c++){const d=new Uint32Array(e.slice(a,a+gl))[0];a+=gl;const f=new Uint8Array(e.slice(a,a+d));i.push(f),a+=d}}else{const l=Ru[r];if(r==="float32")i=new Float32Array(e);else if(r==="int32")i=new Int32Array(e);else if(r==="bool")i=new Uint8Array(e);else if(r==="complex64"){i=new Float32Array(e);const c=new Float32Array(i.length/2),d=new Float32Array(i.length/2);for(let y=0;y<c.length;y++)c[y]=i[y*2],d[y]=i[y*2+1];const f=yi(c,s,"float32"),p=yi(d,s,"float32"),g=ml(f,p);return f.dispose(),p.dispose(),g}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);a+=o*l}return yi(i,s,r)}async function vN(t,e,n){let r=new Uint8Array(e);for(;r.byteLength<n;){const{done:s,value:o}=await t.read();if(s&&o==null){const a=n-r.byteLength;throw new Error(`Reader is done but ${a} bytes are still expected`)}const i=new Uint8Array(r.length+o.byteLength);i.set(r,0),i.set(new Uint8Array(o),r.length),r=i}return r.buffer}async function zA(t,e){const n={},r=t.getReader();let s=new ArrayBuffer(0);for(const o of e){const i=await BX(o,async(c,d)=>(s=await vN(r,s,d),s.slice(c,d)));s=await vN(r,s,i);const a=s.slice(0,i);s=s.slice(i);const l=LA(o,a);if(n[o.name]=l,gf()==="webgpu"){const c=ud();"uploadToGPU"in c&&fe(l.shape)>=oe().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&c.uploadToGPU(l.dataId)}}return n}function MX(t){if(t===null)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(o=>{if(e+=o.byteLength,n.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const r=new Uint8Array(e);let s=0;return n.forEach(o=>{r.set(new Uint8Array(o.buffer),s),s+=o.byteLength}),r.buffer}const DS=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function bN(t){return DS?Buffer.byteLength(t,"utf8"):new Blob([t]).size}function VX(t){if(DS)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let r=0,s=e.length;r<s;r++)n+=String.fromCharCode(e[r]);return btoa(n)}function WX(t){if(DS){const r=Buffer.from(t,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n.set([e.charCodeAt(r)],r);return n.buffer}function UX(t){return zo.join(t)}function wN(t){const e="/";for(t=t.trim();t.endsWith(e);)t=t.slice(0,t.length-1);const n=t.split(e);return n[n.length-1]}function BA(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return t.signature!=null&&(n.signature=t.signature),t.userDefinedMetadata!=null&&(n.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(n.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(n.initializerSignature=t.initializerSignature),t.trainingConfig!=null&&(n.trainingConfig=t.trainingConfig),n}function MA(t,e,n){const r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(t.trainingConfig!=null&&(r.trainingConfig=t.trainingConfig),t.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=n}return t.signature!=null&&(r.signature=t.signature),t.userDefinedMetadata!=null&&(r.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(r.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(r.initializerSignature=t.initializerSignature),r}async function FS(t,e){let n,r;return t.weightsManifest!=null&&([n,r]=await e(t.weightsManifest)),MA(t,n,r)}function Kf(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology==null?0:bN(JSON.stringify(t.modelTopology)),weightSpecsBytes:t.weightSpecs==null?0:bN(JSON.stringify(t.weightSpecs)),weightDataBytes:t.weightData==null?0:new zo(t.weightData).byteLength}}function lv(t){const e=[];for(const n of t)e.push(...n.weights);return e}function jX(){const t=n=>{let r=n<<13,s=0;for(;(r&8388608)===0;)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}function GX(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}function HX(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}function KX(){const t=jX(),e=GX(),n=HX();return r=>{const s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let i=0;i<r.length;i++){const a=r[i],l=t[n[a>>10]+(a&1023)]+e[a>>10];o[i]=l}return new Float32Array(s)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class un{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return un.instance==null&&(un.instance=new un),un.instance}static registerSaveRouter(e){un.getInstance().saveRouters.push(e)}static registerLoadRouter(e){un.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return un.getHandlers(e,"save")}static getLoadHandlers(e,n){return un.getHandlers(e,"load",n)}static getHandlers(e,n,r){const s=[];return(n==="load"?un.getInstance().loadRouters:un.getInstance().saveRouters).forEach(i=>{const a=i(e,r);a!==null&&s.push(a)}),s}}const XX=t=>un.registerSaveRouter(t),qX=t=>un.registerLoadRouter(t),YX=t=>un.getSaveHandlers(t),QX=(t,e)=>un.getLoadHandlers(t,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uv="tensorflowjs",cv=1,xu="models_store",il="model_info_store";function VA(){if(!oe().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t=typeof window>"u"?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function dv(t){const e=t.result;e.createObjectStore(xu,{keyPath:"modelPath"}),e.createObjectStore(il,{keyPath:"modelPath"})}class _u{constructor(e){if(this.indexedDB=VA(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,n){return new Promise((r,s)=>{const o=this.indexedDB.open(uv,cv);o.onupgradeneeded=()=>dv(o),o.onsuccess=()=>{const i=o.result;if(n==null){const a=i.transaction(xu,"readonly"),c=a.objectStore(xu).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return i.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(c.result.modelArtifacts)},c.onerror=d=>(i.close(),s(c.error)),a.oncomplete=()=>i.close()}else{n.weightData=zo.join(n.weightData);const a=Kf(n),l=i.transaction(il,"readwrite");let c=l.objectStore(il),d;try{d=c.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(p){return s(p)}let f;d.onsuccess=()=>{f=i.transaction(xu,"readwrite");const p=f.objectStore(xu);let g;try{g=p.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:a})}catch(y){return s(y)}g.onsuccess=()=>r({modelArtifactsInfo:a}),g.onerror=y=>{c=l.objectStore(il);const x=c.delete(this.modelPath);x.onsuccess=()=>(i.close(),s(g.error)),x.onerror=w=>(i.close(),s(g.error))}},d.onerror=p=>(i.close(),s(d.error)),l.oncomplete=()=>{f==null?i.close():f.oncomplete=()=>i.close()}}},o.onerror=i=>s(o.error)})}}_u.URL_SCHEME="indexeddb://";const WA=t=>oe().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(_u.URL_SCHEME)?ZX(t.slice(_u.URL_SCHEME.length)):null;un.registerSaveRouter(WA);un.registerLoadRouter(WA);function ZX(t){return new _u(t)}function JX(t){return t.startsWith(_u.URL_SCHEME)?t.slice(_u.URL_SCHEME.length):t}class eq{constructor(){this.indexedDB=VA()}async listModels(){return new Promise((e,n)=>{const r=this.indexedDB.open(uv,cv);r.onupgradeneeded=()=>dv(r),r.onsuccess=()=>{const s=r.result,o=s.transaction(il,"readonly"),a=o.objectStore(il).getAll();a.onsuccess=()=>{const l={};for(const c of a.result)l[c.modelPath]=c.modelArtifactsInfo;e(l)},a.onerror=l=>(s.close(),n(a.error)),o.oncomplete=()=>s.close()},r.onerror=s=>n(r.error)})}async removeModel(e){return e=JX(e),new Promise((n,r)=>{const s=this.indexedDB.open(uv,cv);s.onupgradeneeded=()=>dv(s),s.onsuccess=()=>{const o=s.result,i=o.transaction(il,"readwrite"),a=i.objectStore(il),l=a.get(e);let c;l.onsuccess=()=>{if(l.result==null)return o.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const d=a.delete(e),f=()=>{c=o.transaction(xu,"readwrite");const g=c.objectStore(xu).delete(e);g.onsuccess=()=>n(l.result.modelArtifactsInfo),g.onerror=y=>r(l.error)};d.onsuccess=f,d.onerror=p=>(f(),o.close(),r(l.error))}},l.onerror=d=>(o.close(),r(l.error)),i.oncomplete=()=>{c==null?o.close():c.oncomplete=()=>o.close()}},s.onerror=o=>r(s.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ji="/",Rc="tensorflowjs_models",UA="info",tq="model_topology",nq="weight_specs",rq="weight_data",sq="model_metadata";function jA(t){return{info:[Rc,t,UA].join(Ji),topology:[Rc,t,tq].join(Ji),weightSpecs:[Rc,t,nq].join(Ji),weightData:[Rc,t,rq].join(Ji),modelMetadata:[Rc,t,sq].join(Ji)}}function GA(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function oq(t){const e=t.split(Ji);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(Ji)}function iq(t){return t.startsWith(Pu.URL_SCHEME)?t.slice(Pu.URL_SCHEME.length):t}class Pu{constructor(e){if(!oe().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=jA(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=Kf(e),o=zo.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,VX(o));const i={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:s}}catch{throw GA(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=s;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const a=JSON.parse(o);n.format=a.format,n.generatedBy=a.generatedBy,n.convertedBy=a.convertedBy,a.signature!=null&&(n.signature=a.signature),a.userDefinedMetadata!=null&&(n.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(n.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(n.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(n.trainingConfig=a.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=WX(i),n}}Pu.URL_SCHEME="localstorage://";const HA=t=>oe().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Pu.URL_SCHEME)?aq(t.slice(Pu.URL_SCHEME.length)):null;un.registerSaveRouter(HA);un.registerLoadRouter(HA);function aq(t){return new Pu(t)}class lq{constructor(){z(oe().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),z(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},n=Rc+Ji,r=Ji+UA;for(let s=0;s<this.LS.length;++s){const o=this.LS.key(s);if(o.startsWith(n)&&o.endsWith(r)){const i=oq(o);e[i]=JSON.parse(this.LS.getItem(o))}}return e}async removeModel(e){e=iq(e);const n=jA(e);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return GA(n),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qc="://";class Cr{constructor(){this.managers={}}static getInstance(){return Cr.instance==null&&(Cr.instance=new Cr),Cr.instance}static registerManager(e,n){z(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Qc)&&(e=e.slice(0,e.indexOf(Qc))),z(e.length>0,()=>"scheme must not be an empty string.");const r=Cr.getInstance();z(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=n}static getManager(e){const n=Cr.getInstance().managers[e];if(n==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return n}static getSchemes(){return Object.keys(Cr.getInstance().managers)}}function Hm(t){if(t.indexOf(Qc)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Cr.getSchemes().join(",")}`);return{scheme:t.split(Qc)[0],path:t.split(Qc)[1]}}async function KA(t,e,n=!1){z(t!==e,()=>`Old path and new path are the same: '${t}'`);const r=un.getLoadHandlers(t);z(r.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),z(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${t}.`);const s=r[0],o=un.getSaveHandlers(e);z(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),z(o.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const i=o[0],a=Hm(t).scheme,l=Hm(t).path,c=a===Hm(t).scheme,d=await s.load();n&&c&&await Cr.getManager(a).removeModel(l);const f=await i.save(d);return n&&!c&&await Cr.getManager(a).removeModel(l),f.modelArtifactsInfo}async function uq(){const t=Cr.getSchemes(),e={};for(const n of t){const r=await Cr.getManager(n).listModels();for(const s in r){const o=n+Qc+s;e[o]=r[s]}}return e}async function cq(t){const e=Hm(t);return Cr.getManager(e.scheme).removeModel(e.path)}async function dq(t,e){return KA(t,e,!1)}async function hq(t,e){return KA(t,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fq{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,n){return fetch(e,n)}now(){return performance.now()}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,n){return new TextDecoder(n).decode(e)}setTimeoutCustom(e,n){if(typeof window>"u"||!oe().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,n);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const s=this.functionRefs[r.data.index];s(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return vA(e)}}if(oe().get("IS_BROWSER")){oe().setPlatform("browser",new fq);try{Cr.registerManager(Pu.URL_SCHEME,new lq)}catch{}try{Cr.registerManager(_u.URL_SCHEME,new eq)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pq={importFetch:()=>require("node-fetch")};let K1;class mq{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,n){return oe().global.fetch!=null?oe().global.fetch(e,n):(K1==null&&(K1=pq.importFetch()),K1(e,n))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(e)}decode(e,n){return e.length===0?"":new this.util.TextDecoder(n).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}oe().get("IS_NODE")&&!oe().get("IS_BROWSER")&&oe().setPlatform("node",new mq);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vt(t,e="float32",n){return e=e||"float32",Ds(t),new ad(t,e,n)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gq(t,e){const n=L(t,"x","cast");if(!YK(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&n.dtype!=="string"||e!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:e};return q.runKernel(ry,r,s)}const Qt=X({cast_:gq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yq(t){const n={x:L(t,"x","clone","string_or_numeric")};return q.runKernel(sy,n)}const dl=X({clone_:yq});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XA(t,e=!1){console.log(t.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */RA();const xq={buffer:Vt,cast:Qt,clone:dl,print:XA};TX(xq);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vq(t,e){let n=L(t,"a","add"),r=L(e,"b","add");[n,r]=gn(n,r);const s={a:n,b:r};return q.runKernel(ny,s)}const Ue=X({add_:vq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bq(t,e){let n=L(t,"a","floorDiv"),r=L(e,"b","floorDiv");[n,r]=gn(n,r);const s={a:n,b:r};return q.runKernel(t2,s)}const qA=X({floorDiv_:bq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wq(t,e){let n=L(t,"a","div"),r=L(e,"b","div");if([n,r]=gn(n,r),n.dtype==="int32"&&r.dtype==="int32")return qA(n,r);const s={a:n,b:r},o={};return q.runKernel(Uw,s,o)}const gt=X({div_:wq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sq(t,e){let n=L(t,"a","mul"),r=L(e,"b","mul");[n,r]=gn(n,r);const s={a:n,b:r};return q.runKernel(A2,s)}const Te=X({mul_:Sq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cq(t){const e=L(t,"x","abs");if(e.dtype==="complex64"){const n={x:e};return q.runKernel($w,n)}else{const n={x:e};return q.runKernel(nw,n)}}const Ns=X({abs_:Cq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $q(t){const n={x:L(t,"x","acos")};return q.runKernel(rw,n)}const kq=X({acos_:$q});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tq(t){const n={x:L(t,"x","acosh")};return q.runKernel(sw,n)}const Iq=X({acosh_:Tq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nq(t){z(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),z(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const e=t.map((s,o)=>L(s,`tensors${o}`,"addN")),n=e[0];e.forEach(s=>{if(s.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(s=>{if(!Mt(s.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return q.runKernel(ow,r)}const Eq=X({addN_:Nq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rq(t,e=null,n=!1){const s={x:L(t,"x","all","bool")},o={axis:e,keepDims:n};return q.runKernel(iw,s,o)}const _q=X({all_:Rq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pq(t,e=null,n=!1){const s={x:L(t,"x","any","bool")},o={axis:e,keepDims:n};return q.runKernel(aw,s,o)}const Aq=X({any_:Pq});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dq(t,e=0){const r={x:L(t,"x","argMax")},s={axis:e};return q.runKernel(lw,r,s)}const YA=X({argMax_:Dq});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fq(t,e=0){const r={x:L(t,"x","argMin")},s={axis:e};return q.runKernel(uw,r,s)}const Oq=X({argMin_:Fq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lq(t){const n={x:L(t,"x","asin")};return q.runKernel(cw,n)}const zq=X({asin_:Lq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bq(t){const n={x:L(t,"x","asinh")};return q.runKernel(dw,n)}const Mq=X({asinh_:Bq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vq(t){const n={x:L(t,"x","atan")};return q.runKernel(hw,n)}const Wq=X({atan_:Vq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uq(t,e){let n=L(t,"a","atan2"),r=L(e,"b","atan2");[n,r]=gn(n,r);const s={a:n,b:r};return q.runKernel(pw,s)}const jq=X({atan2_:Uq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gq(t){const n={x:L(t,"x","atanh")};return q.runKernel(fw,n)}const Hq=X({atanh_:Gq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xf(t,e,n,r,s="NHWC",o){const i=t[3],a=[...e,i],l=Bo(s);return kn(t,a,n,o,r,null,null,l)}function ho(t,e,n,r,s,o,i="channelsLast"){const[a,l]=yf(e);let c;if(i==="channelsLast")c=[a,l,t[3],t[3]];else if(i==="channelsFirst")c=[a,l,t[1],t[1]];else throw new Error(`Unknown dataFormat ${i}`);return kn(t,c,n,r,s,o,!1,i)}function ba(t,e,n,r,s,o,i="NDHWC"){const[a,l,c]=hv(e);let d,f;if(i==="NDHWC")f="channelsLast",d=[a,l,c,t[4],t[4]];else if(i==="NCDHW")f="channelsFirst",d=[a,l,c,t[1],t[1]];else throw new Error(`Unknown dataFormat ${i}`);return $l(t,d,n,r,s,!1,f,o)}function kn(t,e,n,r,s,o,i=!1,a="channelsLast"){let[l,c,d,f]=[-1,-1,-1,-1];if(a==="channelsLast")[l,c,d,f]=t;else if(a==="channelsFirst")[l,f,c,d]=t;else throw new Error(`Unknown dataFormat ${a}`);const[p,g,,y]=e,[x,w]=yf(n),[S,$]=yf(r),I=Zc(p,S),R=Zc(g,$),{padInfo:_,outHeight:F,outWidth:O}=qq(s,c,d,x,w,I,R,o,a),M=i?y*f:y;let B;return a==="channelsFirst"?B=[l,M,F,O]:a==="channelsLast"&&(B=[l,F,O,M]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:d,inChannels:f,outHeight:F,outWidth:O,outChannels:M,padInfo:_,strideHeight:x,strideWidth:w,filterHeight:p,filterWidth:g,effectiveFilterHeight:I,effectiveFilterWidth:R,dilationHeight:S,dilationWidth:$,inShape:t,outShape:B,filterShape:e}}function $l(t,e,n,r,s,o=!1,i="channelsLast",a){let[l,c,d,f,p]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,c,d,f,p]=t;else if(i==="channelsFirst")[l,p,c,d,f]=t;else throw new Error(`Unknown dataFormat ${i}`);const[g,y,x,,w]=e,[S,$,I]=hv(n),[R,_,F]=hv(r),O=Zc(g,R),M=Zc(y,_),B=Zc(x,F),{padInfo:V,outDepth:A,outHeight:re,outWidth:ae}=Yq(s,c,d,f,S,$,I,O,M,B,a),pe=o?w*p:w;let ye;return i==="channelsFirst"?ye=[l,pe,A,re,ae]:i==="channelsLast"&&(ye=[l,A,re,ae,pe]),{batchSize:l,dataFormat:i,inDepth:c,inHeight:d,inWidth:f,inChannels:p,outDepth:A,outHeight:re,outWidth:ae,outChannels:pe,padInfo:V,strideDepth:S,strideHeight:$,strideWidth:I,filterDepth:g,filterHeight:y,filterWidth:x,effectiveFilterDepth:O,effectiveFilterHeight:M,effectiveFilterWidth:B,dilationDepth:R,dilationHeight:_,dilationWidth:F,inShape:t,outShape:ye,filterShape:e}}function Kq(t,e,n,r,s){r==null&&(r=OS(t,e,n));const o=t[0],i=t[1],a=xf((o-e+2*r)/n+1,s),l=xf((i-e+2*r)/n+1,s);return[a,l]}function Xq(t,e,n,r,s,o){s==null&&(s=OS(t,e[0],r[0]));const i=[0,0,0,n];for(let a=0;a<3;a++)t[a]+2*s>=e[a]&&(i[a]=xf((t[a]-e[a]+2*s)/r[a]+1,o));return i}function OS(t,e,n,r=1){const s=Zc(e,r);return Math.floor((t[0]*(n-1)-n+s)/2)}function yf(t){return typeof t=="number"?[t,t,t]:t.length===2?[t[0],t[1],1]:t}function hv(t){return typeof t=="number"?[t,t,t]:t}function Zc(t,e){return e<=1?t:t+(t-1)*(e-1)}function qq(t,e,n,r,s,o,i,a,l){let c,d,f;if(typeof t=="number"){c={top:t,bottom:t,left:t,right:t,type:t===0?"VALID":"NUMBER"};const g=Kq([e,n],o,r,t,a);d=g[0],f=g[1]}else if(t==="same"){d=Math.ceil(e/r),f=Math.ceil(n/s);const p=Math.max(0,(d-1)*r+o-e),g=Math.max(0,(f-1)*s+i-n),y=Math.floor(p/2),x=p-y,w=Math.floor(g/2),S=g-w;c={top:y,bottom:x,left:w,right:S,type:"SAME"}}else if(t==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},d=Math.ceil((e-o+1)/r),f=Math.ceil((n-i+1)/s);else if(typeof t=="object"){const p=l==="channelsLast"?t[1][0]:t[2][0],g=l==="channelsLast"?t[1][1]:t[2][1],y=l==="channelsLast"?t[2][0]:t[3][0],x=l==="channelsLast"?t[2][1]:t[3][1];c={top:p,bottom:g,left:y,right:x,type:p===0&&g===0&&y===0&&x===0?"VALID":"EXPLICIT"},d=xf((e-o+p+g)/r+1,a),f=xf((n-i+y+x)/s+1,a)}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:c,outHeight:d,outWidth:f}}function Yq(t,e,n,r,s,o,i,a,l,c,d){let f,p,g,y;if(t==="valid"&&(t=0),typeof t=="number"){f={top:t,bottom:t,left:t,right:t,front:t,back:t,type:t===0?"VALID":"NUMBER"};const w=Xq([e,n,r,1],[a,l,c],1,[s,o,i],t,d);p=w[0],g=w[1],y=w[2]}else if(t==="same"){p=Math.ceil(e/s),g=Math.ceil(n/o),y=Math.ceil(r/i);const x=(p-1)*s+a-e,w=(g-1)*o+l-n,S=(y-1)*i+c-r,$=Math.floor(x/2),I=x-$,R=Math.floor(w/2),_=w-R,F=Math.floor(S/2),O=S-F;f={top:R,bottom:_,left:F,right:O,front:$,back:I,type:"SAME"}}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:f,outDepth:p,outHeight:g,outWidth:y}}function xf(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function vf(t){const[e,n,r]=yf(t);return e===1&&n===1&&r===1}function Er(t,e){return vf(t)||vf(e)}function Au(t){return yf(t).every(e=>e>0)}function Bo(t){if(t==="NHWC")return"channelsLast";if(t==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function fo(t,e,n){if(n!=null){if(typeof e=="string")throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if(typeof e=="number")z(id(e),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(s=>{z(id(s),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${s}.`)})});else throw Error(`Error in ${t}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qq(t,e){const r={x:L(t,"x","reshape","string_or_numeric")},s={shape:e};return q.runKernel(q2,r,s)}const xe=X({reshape_:Qq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zq(t,e,n,r,s){const o=L(t,"x","avgPool","float32"),i=1;z(Er(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let a=o,l=!1;o.rank===3&&(l=!0,a=xe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),z(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),fo("avgPool",r,s);const c={x:a},d={filterSize:e,strides:n,pad:r,dimRoundingMode:s};let f=q.runKernel(mw,c,d);return f=Qt(f,o.dtype),l?xe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const QA=X({avgPool_:Zq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jq(t,e,n,r,s,o="NDHWC"){const i=L(t,"x","avgPool3d","float32");let a=i,l=!1;i.rank===4&&(l=!0,a=xe(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),z(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),z(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),z(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),fo("avgPool3d",r,s);const c={x:a},d={filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:o};let f=q.runKernel(gw,c,d);return f=Qt(f,a.dtype),l?xe(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const eY=X({avgPool3d_:Jq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tY(t,e=0){z(t.length>=1,()=>"Pass at least one tensor to concat");const n=Ig(t,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),n.length===1)return dl(n[0]);const r=n,s={axis:e};return q.runKernel(kw,r,s)}const On=X({concat_:tY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nY(t,e,n=!1,r=!1){let s=L(t,"a","matMul"),o=L(e,"b","matMul");[s,o]=gn(s,o);const i={a:s,b:o},a={transposeA:n,transposeB:r};return q.runKernel(yw,i,a)}const Ht=X({matMul_:nY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rY(t){const n={x:L(t,"x","sigmoid","float32")};return q.runKernel(dS,n)}const sa=X({sigmoid_:rY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sY(t,e,n){const r=L(t,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},o={begin:e,size:n};return q.runKernel(aS,s,o)}const ft=X({slice_:sY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oY(t){const n={x:L(t,"x","tanh","float32")};return q.runKernel(TS,n)}const fv=X({tanh_:oY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iY(t,e,n,r,s,o){const i=L(t,"forgetBias","basicLSTMCell"),a=L(e,"lstmKernel","basicLSTMCell"),l=L(n,"lstmBias","basicLSTMCell"),c=L(r,"data","basicLSTMCell"),d=L(s,"c","basicLSTMCell"),f=L(o,"h","basicLSTMCell"),p=On([c,f],1),g=Ht(p,a),y=Ue(g,l),x=y.shape[0],w=y.shape[1]/4,S=[x,w],$=ft(y,[0,0],S),I=ft(y,[0,w],S),R=ft(y,[0,w*2],S),_=ft(y,[0,w*3],S),F=Ue(Te(sa($),fv(I)),Te(d,sa(Ue(i,R)))),O=Te(fv(F),sa(_));return[F,O]}const aY=X({basicLSTMCell_:iY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lY(t,e,n){const r=L(t,"x","batchToSpaceND"),s=e.reduce((a,l)=>a*l);z(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),z(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),z(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const o={x:r},i={blockShape:e,crops:n};return q.runKernel(xw,o,i)}const ZA=X({batchToSpaceND_:lY});function uY(t){let e;return t.rank===0||t.rank===1?e=xe(t,[1,1,1,t.size]):t.rank===2?e=xe(t,[1,1,t.shape[0],t.shape[1]]):t.rank===3?e=xe(t,[1,t.shape[0],t.shape[1],t.shape[2]]):e=t,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cY(t,e,n,r,s,o){o==null&&(o=.001);const i=L(t,"x","batchNorm"),a=L(e,"mean","batchNorm"),l=L(n,"variance","batchNorm");let c;s!=null&&(c=L(s,"scale","batchNorm"));let d;r!=null&&(d=L(r,"offset","batchNorm")),z(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),z(d==null||a.rank===d.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),z(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const p={x:uY(i),scale:c,offset:d,mean:a,variance:l},g={varianceEpsilon:o},y=q.runKernel(n2,p,g);return xe(y,i.shape)}const uy=X({batchNorm_:cY});function dY(t,e,n,r,s,o){const i=L(t,"x","batchNorm"),a=L(e,"mean","batchNorm"),l=L(n,"variance","batchNorm");let c;s!=null&&(c=L(s,"scale","batchNorm"));let d;return r!=null&&(d=L(r,"offset","batchNorm")),z(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),z(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),z(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&z(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),d!=null&&z(d.rank===2||d.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${d.rank}.`),uy(i,a,l,d,c,o)}const hY=X({batchNorm2d_:dY});function fY(t,e,n,r,s,o){const i=L(t,"x","batchNorm"),a=L(e,"mean","batchNorm"),l=L(n,"variance","batchNorm");let c;s!=null&&(c=L(s,"scale","batchNorm"));let d;return r!=null&&(d=L(r,"offset","batchNorm")),z(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),z(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),z(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&z(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),d!=null&&z(d.rank===3||d.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${d.rank}.`),uy(i,a,l,d,c,o)}const pY=X({batchNorm3d_:fY});function mY(t,e,n,r,s,o){const i=L(t,"x","batchNorm"),a=L(e,"mean","batchNorm"),l=L(n,"variance","batchNorm");let c;s!=null&&(c=L(s,"scale","batchNorm"));let d;return r!=null&&(d=L(r,"offset","batchNorm")),z(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),z(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),z(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&z(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),d!=null&&z(d.rank===4||d.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${d.rank}.`),uy(i,a,l,d,c,o)}const gY=X({batchNorm4d_:mY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yY(t,e,n){const r=L(t,"x","bincount"),s=L(e,"weights","bincount");z(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),z(n>=0,()=>`size must be non-negative, but got ${n}.`),z(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const o={x:r,weights:s},i={size:n};return q.runKernel(vw,o,i)}const JA=X({bincount_:yY});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xY(t,e){const n=L(t,"x","bitwiseAnd"),r=L(e,"y","bitwiseAnd");if(!Mt(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if(n.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);const s={a:n,b:r};return q.runKernel(QP,s)}const vY=X({bitwiseAnd_:xY});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bY(t,e){const n=L(t,"s0","broadcastArgs","int32"),r=L(e,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:n,s1:r};return q.runKernel(bw,s)}const wY=X({broadcastArgs_:bY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SY(t,e){let n=L(t,"broadcastTo","x");const r=n.shape;if(Ds(e),e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const c=n.shape.slice();for(;c.length<e.length;)c.unshift(1);n=xe(n,c)}const s=n.shape,o=Array.from(e);for(let c=e.length-1;c>=0;c--)if(s[c]===e[c])o[c]=1;else if(n.shape[c]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(o.map((c,d)=>c>1?d:-1).filter(c=>c>=0).length===0)return dl(n);const a={x:n},l={reps:o};return q.runKernel(oy,a,l)}const Zh=X({broadcastTo_:SY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CY(t){const n={x:L(t,"x","ceil","float32")};return q.runKernel(ww,n)}const $Y=X({ceil_:CY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qf(t,e,n){Ds(t),n=n||$d(e);const r={shape:t,value:e,dtype:n};return q.runKernel(Zw,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kY(t,e,n){const r=L(t,"x","clipByValue");if(z(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`),e===n)return qf(r.shape,e,r.dtype);const s={x:r},o={clipValueMin:e,clipValueMax:n};return q.runKernel(Sw,s,o)}const eD=X({clipByValue_:kY});function TY(t){return On(t,0)}const IY=X({concat1d_:TY});function NY(t,e){return On(t,e)}const EY=X({concat2d_:NY});function RY(t,e){return On(t,e)}const _Y=X({concat3d_:RY});function PY(t,e){return On(t,e)}const AY=X({concat4d_:PY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DY(t,e,n,r,s="NHWC",o=[1,1],i){const a=L(t,"x","conv2d","float32"),l=L(e,"filter","conv2d","float32");let c=a,d=!1;a.rank===3&&(d=!0,c=xe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),z(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),z(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),fo("conv2d",r,i);const f=s==="NHWC"?c.shape[3]:c.shape[1];z(f===l.shape[2],()=>`Error in conv2d: depth of input (${f}) must match input depth for filter ${l.shape[2]}.`),z(Er(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),z(Au(o),()=>"Error in conv2D: Dilated rates should be larger than 0."),z(Au(n),()=>"Error in conv2D: Strides should be larger than 0.");const p={x:c,filter:l},g={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i},y=q.runKernel(Tw,p,g);return d?xe(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const cy=X({conv2d_:DY});function FY(t,e,n,r,s="NWC",o=1,i){const a=L(t,"x","conv1d"),l=L(e,"filter","conv1d");let c=a,d=!1;a.rank===2&&(d=!0,c=xe(a,[1,a.shape[0],a.shape[1]])),z(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),z(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),fo("conv1d",r,i),z(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),z(Er(n,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${o}'`),z(Au(o),()=>"Error in conv1D: Dilated rates should be larger than 0."),z(Au(n),()=>"Error in conv1D: Stride should be larger than 0."),z(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const f=xe(l,[1,l.shape[0],l.shape[1],l.shape[2]]),p=xe(c,[c.shape[0],1,c.shape[1],c.shape[2]]),w=cy(p,f,[1,n],r,"NHWC",[1,o],i);return d?xe(w,[w.shape[2],w.shape[3]]):xe(w,[w.shape[0],w.shape[2],w.shape[3]])}const OY=X({conv1d_:FY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LY(t,e,n,r,s,o="NHWC",i){z(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let a=t,l=e,c=!1;e.rank===3&&(c=!0,l=xe(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,t[0],t[1],t[2]]),z(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),z(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),z(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const d=o==="NHWC"?a[3]:a[1],f=o==="NHWC"?l.shape[3]:l.shape[1];z(d===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${d}) must match input depth for filter ${n.shape[2]}.`),z(f===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${f}) must match output depth for filter ${n.shape[3]}.`),fo("conv2dDerInput",s,i);const p={dy:l,filter:n},g={strides:r,pad:s,dataFormat:o,dimRoundingMode:i,inputShape:a},y=q.runKernel(Nw,p,g);return c?xe(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const tD=X({conv2DBackpropInput_:LY});function zY(t,e,n,r,s,o){const i=L(t,"x","conv2dTranspose"),a=L(e,"filter","conv2dTranspose");return tD(n,i,a,r,s,"NHWC",o)}const BY=X({conv2dTranspose_:zY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MY(t,e,n,r,s="NDHWC",o=[1,1,1]){const i=L(t,"x","conv3d"),a=L(e,"filter","conv3d");let l=i,c=!1;i.rank===4&&(c=!0,l=xe(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),z(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),z(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),z(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),z(Er(n,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),z(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),z(Au(o),()=>"Error in conv3D: Dilated rates should be larger than 0."),z(Au(n),()=>"Error in conv3D: Strides should be larger than 0.");const d={x:l,filter:a},f={strides:n,pad:r,dataFormat:s,dilations:o},p=q.runKernel(Ew,d,f);return c?xe(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const VY=X({conv3d_:MY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WY(t,e,n,r,s){z(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let o=t,i=e,a=!1;e.rank===4&&(a=!0,i=xe(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),o=[1,t[0],t[1],t[2],t[3]]);const l=o[4],c=i.shape[4];z(o.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),z(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),z(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),z(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),z(c===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[4]}.`);const d={dy:i,filter:n},f={pad:s,strides:r,inputShape:o},p=q.runKernel(Rw,d,f);return a?xe(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const UY=X({conv3DBackpropInput_:WY});function jY(t,e,n,r,s){const o=L(t,"x","conv3dTranspose"),i=L(e,"filter","conv3dTranspose");return UY(n,o,i,r,s)}const GY=X({conv3dTranspose_:jY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HY(t){const n={x:L(t,"x","cos","float32")};return q.runKernel(_w,n)}const KY=X({cos_:HY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XY(t){const n={x:L(t,"x","cosh","float32")};return q.runKernel(Pw,n)}const qY=X({cosh_:XY});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YY(t,e=0,n=!1,r=!1){const o={x:L(t,"x","cumprod")},i={axis:e,exclusive:n,reverse:r};return q.runKernel(Aw,o,i)}const QY=X({cumprod_:YY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZY(t,e=0,n=!1,r=!1){const o={x:L(t,"x","cumsum")},i={axis:e,exclusive:n,reverse:r};return q.runKernel(Dw,o,i)}const JY=X({cumsum_:ZY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eQ(t,e,n,r=!1){const s=L(t,"x","denseBincount"),o=L(e,"weights","denseBincount");z(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),z(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),z(n>=0,()=>`size must be non-negative, but got ${n}.`),z(o.size===s.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`);const i={x:s,weights:o},a={size:n,binaryOutput:r};return q.runKernel(Ow,i,a)}const tQ=X({denseBincount_:eQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nQ(t,e,n="NHWC"){const r=L(t,"x","depthToSpace","float32"),s=n==="NHWC"?r.shape[1]:r.shape[2],o=n==="NHWC"?r.shape[2]:r.shape[3],i=n==="NHWC"?r.shape[3]:r.shape[1];z(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),z(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${r.shape}`),z(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e} for depthToSpace with input shape
        ${r.shape}`),z(i%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${i} for depthToSpace with input shape ${r.shape}`);const a={x:r},l={blockSize:e,dataFormat:n};return q.runKernel(Lw,a,l)}const rQ=X({depthToSpace_:nQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sQ(t,e,n,r,s="NHWC",o=[1,1],i){const a=L(t,"x","depthwiseConv2d","float32"),l=L(e,"filter","depthwiseConv2d","float32");let c=a,d=!1;a.rank===3&&(d=!0,c=xe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),z(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),z(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const f=s==="NHWC"?c.shape[3]:c.shape[1];z(f===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${f}) must match the inChannels dimension in filter ${l.shape[2]}.`),fo("depthwiseConv2d",r,i);const p={x:c,filter:l},g={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i},y=q.runKernel(zw,p,g);return d?xe(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const LS=X({depthwiseConv2d_:sQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oQ(t){const n={x:L(t,"x","diag")};return q.runKernel(Vw,n)}const iQ=X({diag_:oQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aQ(t,e,n,r,s=[1,1],o="NHWC"){const i=L(t,"x","dilation2d"),a=L(e,"filter","dilation2d");z(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),z(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),z(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let l=i,c=!1;i.rank===3&&(l=xe(i,[1,i.shape[0],i.shape[1],i.shape[2]]),c=!0),z(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const d={x:l,filter:a},f={strides:n,pad:r,dilations:s},p=q.runKernel(Ww,d,f);return c?xe(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const lQ=X({dilation2d_:aQ});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cd(t,e){const n=t.length,r=[];for(let s=0;s<n;s++){const o=n-1-s,i=t[o]||1;(e[e.length-1-s]||1)>1&&i===1&&r.unshift(o)}return r}function nD(t,e){const n=[];for(let r=0;r<e.length;r++){const s=t[t.length-r-1],o=e.length-r-1,i=e[o];(s==null||s===1&&i>1)&&n.unshift(o)}return n}function ct(t,e){const n=Math.max(t.length,e.length),r=new Array(n);for(let s=0;s<n;s++){let o=t[t.length-s-1];o==null&&(o=1);let i=e[e.length-s-1];if(i==null&&(i=1),o===1)r[n-s-1]=i;else if(i===1)r[n-s-1]=o;else if(o!==i){const a=`Operands could not be broadcast together with shapes ${t} and ${e}.`;throw Error(a)}else r[n-s-1]=o}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uQ(t,e){let n=L(t,"a","equal","string_or_numeric"),r=L(e,"b","equal","string_or_numeric");[n,r]=gn(n,r),ct(n.shape,r.shape);const s={a:n,b:r};return q.runKernel(Kw,s)}const rD=X({equal_:uQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cQ(t,e,n){const r=L(e,"a","where"),s=L(n,"b","where"),o=L(t,"condition","where","bool"),i=ct(ct(o.shape,r.shape),s.shape),a=Zh(o,i),l=Zh(r,i),c=Zh(s,i),d={condition:a,t:l,e:c};return q.runKernel(oS,d)}const hl=X({where_:cQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dQ(t){const n={x:L(t,"x","zerosLike")};return q.runKernel(_S,n)}const As=X({zerosLike_:dQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hQ(t,e){let n=L(t,"a","div"),r=L(e,"b","div");[n,r]=gn(n,r);const s=gt(n,r),o=As(s),i=rD(r,o);return hl(i,o,s)}const fQ=X({divNoNan_:hQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pQ(t,e){const n=L(t,"t1","dot"),r=L(e,"t2","dot");z((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);const s=n.rank===1?n.size:n.shape[1],o=r.rank===1?r.size:r.shape[0];if(z(s===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${o}.`),n.rank===1&&r.rank===1){const i=xe(n,[1,-1]),a=xe(r,[-1,1]),l=Ht(i,a);return xe(l,[])}else if(n.rank===1&&r.rank===2){const i=xe(n,[1,-1]),a=xe(r,[r.shape[0],r.shape[1]]),l=Ht(i,a);return xe(l,[l.size])}else if(n.rank===2&&r.rank===1){const i=xe(r,[-1,1]),a=Ht(n,i);return xe(a,[a.size])}else{const i=xe(r,[r.shape[0],r.shape[1]]);return Ht(n,i)}}const mQ=X({dot_:pQ});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gQ(t,...e){const n=e.map((s,o)=>L(s,`tensors${o}`,"einsum")),r={equation:t};return q.runKernel(jw,n,r)}const _c=X({einsum_:gQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yQ(t){const n={x:L(t,"x","elu","float32")};return q.runKernel(Gw,n)}const sD=X({elu_:yQ});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xQ(t,e){const n=L(t,"x","ensureShape","string_or_numeric");if(!XK(n.shape,e))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${e}`);return t}const vQ=X({ensureShape_:xQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bQ(t){let e=L(t,"x","erf");z(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Qt(e,"float32"));const n={x:e};return q.runKernel(Hw,n)}const wQ=X({erf_:bQ});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zS(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function oD(t,e,n){const r=t.length+e.length,s=[];let o=0,i=0;for(let a=0;a<r;a++)n.indexOf(a)===-1?s.push(t[o++]):s.push(e[i++]);return s}function Fs(t,e){const n=[],r=t.length;for(let o=0;o<r;o++)e.indexOf(o)===-1&&n.push(t[o]);const s=e.map(o=>t[o]);return[n,s]}function ys(t,e){const n=e.map(r=>1);return oD(t,n,e)}function xs(t,e,n){z(zS(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function ur(t,e){if(zS(t,e))return null;const n=[];for(let r=0;r<e;++r)t.indexOf(r)===-1&&n.push(r);return t.forEach(r=>n.push(r)),n}function Yf(t){return t.map((e,n)=>[n,e]).sort((e,n)=>e[1]-n[1]).map(e=>e[0])}function cr(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SQ(t,e=null,n=!1){const s={x:L(t,"x","max")},o={reductionIndices:e,keepDims:n};return q.runKernel(S2,s,o)}const Jc=X({max_:SQ});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CQ(t,e=null,n=!1){const s={x:L(t,"x","min")},o={axis:e,keepDims:n};return q.runKernel(N2,s,o)}const pv=X({min_:CQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Q(t,e){let n=L(t,"base","pow"),r=L(e,"exp","pow");[n,r]=gn(n,r);const s={a:n,b:r};return q.runKernel(W2,s)}const bf=X({pow_:$Q});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pt(t,e){if((uo(t)&&e!=="string"||Array.isArray(t))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&uo(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Cl(t,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kQ(t){const n={x:L(t,"x","sqrt","float32")};return q.runKernel(fS,n)}const ha=X({sqrt_:kQ});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TQ(t){const e=L(t,"x","square"),n={};return q.runKernel("Square",{x:e},n)}const ao=X({square_:TQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IQ(t,e=null,n=!1){let r=L(t,"x","sum");r.dtype==="bool"&&(r=Qt(r,"int32"));const s={x:r},o={axis:e,keepDims:n};return q.runKernel(pS,s,o)}const en=X({sum_:IQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NQ(t,e="euclidean",n=null,r=!1){t=L(t,"x","norm");const s=iD(t,e,n);let o=s.shape;if(r){const i=nn(n,t.shape);o=ys(s.shape,i)}return xe(s,o)}function iD(t,e,n=null){if(t.rank===0)return Ns(t);if(t.rank!==1&&n===null)return iD(xe(t,[-1]),e,n);if(t.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(e===1)return en(Ns(t),n);if(e===1/0)return Jc(Ns(t),n);if(e===-1/0)return pv(Ns(t),n);if(e==="euclidean"||e===2)return ha(en(bf(Ns(t),pt(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&n.length===2){if(e===1)return Jc(en(Ns(t),n[0]),n[1]-1);if(e===1/0)return Jc(en(Ns(t),n[1]),n[0]);if(e===-1/0)return pv(en(Ns(t),n[1]),n[0]);if(e==="fro"||e==="euclidean")return ha(en(ao(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const dy=X({norm_:NQ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EQ(t,e=null,n=!1){return dy(t,"euclidean",e,n)}const RQ=X({euclideanNorm_:EQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Q(t){const n={x:L(t,"x","exp")};return q.runKernel(Xw,n)}const fa=X({exp_:_Q});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PQ(t,e=0){const n=L(t,"x","expandDims","string_or_numeric");z(e<=n.rank,()=>"Axis must be <= rank of the tensor");const r={input:n},s={dim:e};return q.runKernel(qw,r,s)}const Es=X({expandDims_:PQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AQ(t){const n={x:L(t,"x","expm1")};return q.runKernel(Yw,n)}const DQ=X({expm1_:AQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FQ(t,e){const n=L(t,"x","tile","string_or_numeric");z(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`);const r={x:n},s={reps:e};return q.runKernel(oy,r,s)}const Jh=X({tile_:FQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OQ(t,e,n,r="float32"){e==null&&(e=t);const s=Vt([t,e],r),o=t<=e?t:e;for(let a=0;a<o;++a)s.set(1,a,a);const i=xe(s.toTensor(),[t,e]);if(n==null)return i;if(n.length===1)return Jh(Es(i,0),[n[0],1,1]);if(n.length===2)return Jh(Es(Es(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return Jh(Es(Es(Es(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const aD=X({eye_:OQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LQ(t){const n={x:L(t,"x","floor","float32")};return q.runKernel(e2,n)}const lD=X({floor_:LQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zQ(t,e,n=0,r=0){const s=L(t,"x","gather"),o=L(e,"indices","gather","int32"),i={x:s,indices:o},a={axis:n,batchDims:r};return q.runKernel(r2,i,a)}const uD=X({gather_:zQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BQ(t,e){let n=L(t,"a","greater","string_or_numeric"),r=L(e,"b","greater","string_or_numeric");[n,r]=gn(n,r),ct(n.shape,r.shape);const s={a:n,b:r};return q.runKernel(o2,s)}const hy=X({greater_:BQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MQ(t,e){let n=L(t,"a","greaterEqual","string_or_numeric"),r=L(e,"b","greaterEqual","string_or_numeric");[n,r]=gn(n,r),ct(n.shape,r.shape);const s={a:n,b:r};return q.runKernel(i2,s)}const cD=X({greaterEqual_:MQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VQ(t){const n={input:L(t,"input","imag")};return q.runKernel(l2,n)}const fy=X({imag_:VQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WQ(t){const n={x:L(t,"x","isFinite")};return q.runKernel(u2,n)}const UQ=X({isFinite_:WQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jQ(t){const n={x:L(t,"x","isInf")};return q.runKernel(c2,n)}const GQ=X({isInf_:jQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HQ(t){const n={x:L(t,"x","isNaN")};return q.runKernel(d2,n)}const KQ=X({isNaN_:HQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XQ(t,e=.2){const r={x:L(t,"x","leakyRelu")},s={alpha:e};return q.runKernel(h2,r,s)}const dD=X({leakyRelu_:XQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qQ(t,e){let n=L(t,"a","less","string_or_numeric"),r=L(e,"b","less","string_or_numeric");[n,r]=gn(n,r),ct(n.shape,r.shape);const s={a:n,b:r};return q.runKernel(f2,s)}const mv=X({less_:qQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YQ(t,e){let n=L(t,"a","lessEqual","string_or_numeric"),r=L(e,"b","lessEqual","string_or_numeric");[n,r]=gn(n,r),ct(n.shape,r.shape);const s={a:n,b:r};return q.runKernel(p2,s)}const BS=X({lessEqual_:YQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QQ(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:t,stop:e,num:n};return q.runKernel(m2,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZQ(t,e=5,n=1,r=1,s=.5){const o=L(t,"x","localResponseNormalization");z(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),z(id(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let i=o,a=!1;o.rank===3&&(a=!0,i=xe(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const l={x:i},c={depthRadius:e,bias:n,alpha:r,beta:s},d=q.runKernel(w2,l,c);return a?xe(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const JQ=X({localResponseNormalization_:ZQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eZ(t){const n={x:L(t,"x","log","float32")};return q.runKernel(g2,n)}const wf=X({log_:eZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tZ(t){const n={x:L(t,"x","log1p")};return q.runKernel(y2,n)}const hD=X({log1p_:tZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nZ(t,e){z(Jx(t),()=>"The f passed in variableGrads(f) must be a function"),z(e==null||Array.isArray(e)&&e.every(c=>c instanceof Tg),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=e!=null;if(!n){e=[];for(const c in q.registeredVariables)e.push(q.registeredVariables[c])}const r=n?e.filter(c=>!c.trainable):null,s=e.length;e=e.filter(c=>c.trainable),z(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const o=!0,{value:i,grads:a}=q.gradients(t,e,null,o);z(a.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),z(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const l={};return e.forEach((c,d)=>{a[d]!=null&&(l[c.name]=a[d])}),r!=null&&r.forEach(c=>l[c.name]=null),{value:i,grads:l}}function pa(t){return q.customGrad(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rZ(t){const n={x:L(t,"x","neg")};return q.runKernel(D2,n)}const xi=X({neg_:rZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sZ(t){const n={x:L(t,"x","softplus")};return q.runKernel(hS,n)}const fD=X({softplus_:sZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oZ(t){const e=L(t,"x","logSigmoid");return pa(r=>({value:xi(fD(xi(r))),gradFunc:i=>Te(i,sa(xi(r)))}))(e)}const iZ=X({logSigmoid_:oZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aZ(t,e){let n=L(t,"a","sub"),r=L(e,"b","sub");[n,r]=gn(n,r);const s={a:n,b:r};return q.runKernel($S,s)}const ot=X({sub_:aZ});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lZ(t,e=-1){const n=L(t,"logits","logSoftmax");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return pa((s,o)=>{const a=Jc(s,e,!0),l=ot(s,a),c=ot(Qt(l,"float32"),wf(en(fa(l),e,!0)));return o([c]),{value:c,gradFunc:(f,p)=>{const[g]=p,y=!0,x=fa(g);return ot(f,Te(en(f,e,y),x))}}})(n)}const uZ=X({logSoftmax_:lZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cZ(t,e=null,n=!1){const r=L(t,"x","logSumExp"),s=nn(e,r.shape),o=Jc(r,s,!0),i=ot(r,o),a=fa(i),l=en(a,s),c=wf(l),d=Ue(xe(o,c.shape),c);if(n){const f=ys(d.shape,s);return xe(d,f)}return d}const pD=X({logSumExp_:cZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dZ(t,e){const n=L(t,"a","logicalAnd","bool"),r=L(e,"b","logicalAnd","bool");ct(n.shape,r.shape);const s={a:n,b:r};return q.runKernel(x2,s)}const Ng=X({logicalAnd_:dZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hZ(t){const n={x:L(t,"x","logicalNot","bool")};return q.runKernel(v2,n)}const mD=X({logicalNot_:hZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fZ(t,e){const n=L(t,"a","logicalOr","bool"),r=L(e,"b","logicalOr","bool");ct(n.shape,r.shape);const s={a:n,b:r};return q.runKernel(b2,s)}const gD=X({logicalOr_:fZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pZ(t,e){const n=L(t,"a","logicalXor","bool"),r=L(e,"b","logicalXor","bool");return ct(n.shape,r.shape),Ng(gD(t,e),mD(Ng(t,e)))}const mZ=X({logicalXor_:pZ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bm=2147483648;function gZ(t,e,n="left"){const r=L(t,"sortedSequence","searchSorted"),s=L(e,"values","searchSorted"),o=r.shape[r.shape.length-1],i=s.shape[s.shape.length-1],a=xe(r,[-1,o]),l=xe(s,[-1,i]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(fe(l.shape)>=bm)throw new Error(`values tensor size must less than ${bm}`);if(a.shape[1]>=bm)throw new Error(`trailing dim_size must less than ${bm} for int32 output type, was ${a.shape[1]}`);const c={sortedSequence:a,values:l},d={side:n};return q.runKernel(sS,c,d)}const MS=X({searchSorted_:gZ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yZ(t,e){return MS(t,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xZ(t,e,n,r,s){const o=L(t,"x","maxPool"),i=1;let a=o,l=!1;o.rank===3&&(l=!0,a=xe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),z(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),z(Er(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),fo("maxPool",r,s);const c={x:a},d={filterSize:e,strides:n,pad:r,dimRoundingMode:s},f=q.runKernel($2,c,d);return l?xe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const yD=X({maxPool_:xZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vZ(t,e=[1,1,1],n,r,s,o="NDHWC"){const i=L(t,"x","maxPool3d");let a=i,l=!1;i.rank===4&&(l=!0,a=xe(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),z(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),z(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),fo("maxPool3d",r,s);const c={x:a},d={filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:o},f=q.runKernel(k2,c,d);return l?xe(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const bZ=X({maxPool3d_:vZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wZ(t,e,n,r,s=!1){const i={x:L(t,"x","maxPoolWithArgmax")},a={filterSize:e,strides:n,pad:r,includeBatchInIndex:s},l=q.runKernel(T2,i,a);return{result:l[0],indexes:l[1]}}const SZ=X({maxPoolWithArgmax_:wZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CZ(t,e){let n=L(t,"a","maximum"),r=L(e,"b","maximum");[n,r]=gn(n,r),n.dtype==="bool"&&(n=Qt(n,"int32"),r=Qt(r,"int32")),ct(n.shape,r.shape);const s={a:n,b:r};return q.runKernel(C2,s)}const xD=X({maximum_:CZ});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Z(t,e=null,n=!1){const s={x:L(t,"x","mean")},o={axis:e,keepDims:n};return q.runKernel(I2,s,o)}const Eg=X({mean_:$Z});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ma(t,e="float32"){if(Ds(t),e==="complex64"){const r=ma(t,"float32"),s=ma(t,"float32");return ml(r,s)}const n=ua(fe(t),e);return q.makeTensor(n,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vu(t,e="float32"){if(Ds(t),e==="complex64"){const r=vu(t,"float32"),s=ma(t,"float32");return ml(r,s)}const n=HP(fe(t),e);return q.makeTensor(n,t,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kZ(t,e,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(t===void 0)return[];let r=L(t,"x","meshgrid",t instanceof hn?t.dtype:"float32");if(e===void 0)return[r];let s=L(e,"y","meshgrid",e instanceof hn?e.dtype:"float32");const o=fe(r.shape),i=fe(s.shape);return n==="xy"?(r=xe(r,[1,-1]),s=xe(s,[-1,1]),[Ht(vu([i,1],r.dtype),r),Ht(s,vu([1,o],s.dtype))]):(r=xe(r,[-1,1]),s=xe(s,[1,-1]),[Ht(r,vu([1,i],r.dtype)),Ht(vu([o,1],s.dtype),s)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TZ(t,e){let n=L(t,"a","minimum"),r=L(e,"b","minimum");[n,r]=gn(n,r),n.dtype==="bool"&&(n=Qt(n,"int32"),r=Qt(r,"int32")),ct(n.shape,r.shape);const s={a:n,b:r};return q.runKernel(E2,s)}const Sf=X({minimum_:TZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IZ(t,e,n){z(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const r=L(t,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");z(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const s=n==="reflect"?1:0;for(let a=0;a<r.rank;a++)z(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),z(e[a][0]>=0&&e[a][0]<=r.shape[a]-s&&e[a][1]>=0&&e[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);const o={paddings:e,mode:n},i={x:r};return q.runKernel(R2,i,o)}const vD=X({mirrorPad_:IZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NZ(t,e){let n=L(t,"a","mod"),r=L(e,"b","mod");[n,r]=gn(n,r);const s={a:n,b:r};return q.runKernel(_2,s)}const EZ=X({mod_:NZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RZ(t,e=null,n=!1){t=L(t,"x","moments");const r=nn(e,t.shape),s=Eg(t,r,n);let o=s.shape;n||(o=ys(s.shape,r));const i=ao(ot(Qt(t,"float32"),xe(s,o))),a=Eg(i,r,n);return{mean:s,variance:a}}const _Z=X({moments_:RZ});function PZ(t,e,n,r){const s=L(e,"data","multiRNNCell"),o=Ig(n,"c","multiRNNCell"),i=Ig(r,"h","multiRNNCell");let a=s;const l=[];for(let f=0;f<t.length;f++){const p=t[f](a,o[f],i[f]);l.push(p[0]),l.push(p[1]),a=p[1]}const c=[],d=[];for(let f=0;f<l.length;f+=2)c.push(l[f]),d.push(l[f+1]);return[c,d]}const AZ=X({multiRNNCell_:PZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DZ(t,e,n,r=!1){const s=L(t,"logits","multinomial"),o=s.size,i=s.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const l={logits:i===1?xe(s,[1,-1]):s},c={numSamples:e,seed:n,normalized:r},d=q.runKernel(P2,l,c);return i===1?xe(d,[d.size]):d}const FZ=X({multinomial_:DZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OZ(t,e){let n=L(t,"a","notEqual","string_or_numeric"),r=L(e,"b","notEqual","string_or_numeric");[n,r]=gn(n,r),ct(n.shape,r.shape);const s={a:n,b:r};return q.runKernel(F2,s)}const bD=X({notEqual_:OZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LZ(t,e,n=1,r=0,s="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const i={indices:L(t,"indices","oneHot","int32")},a={dtype:s,depth:e,onValue:n,offValue:r};return q.runKernel(B2,i,a)}const zZ=X({oneHot_:LZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BZ(t){const n={x:L(t,"x","onesLike")};return q.runKernel(z2,n)}const MZ=X({onesLike_:BZ});function VZ(t,e){const n=L(t,"v1","outerProduct"),r=L(e,"v2","outerProduct");z(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);const s=xe(n,[-1,1]),o=xe(r,[1,-1]);return Ht(s,o)}const WZ=X({outerProduct_:VZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UZ(t,e,n=0){const r=L(t,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:n},o={x:r};return q.runKernel(V2,o,s)}const yl=X({pad_:UZ});function jZ(t,e,n=0){return z(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),yl(t,[e],n)}const GZ=X({pad1d_:jZ});function HZ(t,e,n=0){return z(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),yl(t,e,n)}const KZ=X({pad2d_:HZ});function XZ(t,e,n=0){return z(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),yl(t,e,n)}const qZ=X({pad3d_:XZ});function YZ(t,e,n=0){return z(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),yl(t,e,n)}const QZ=X({pad4d_:YZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZZ(t,e,n){const r=L(t,"x","spaceToBatchND");z(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),z(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),z(r.shape.reduce((i,a,l)=>l>0&&l<=e.length?i&&(a+n[l-1][0]+n[l-1][1])%e[l-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:r},o={blockShape:e,paddings:n};return q.runKernel(mS,s,o)}const wD=X({spaceToBatchND_:ZZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JZ(t,e,n,r,s,o,i){s==null&&(s=[1,1]),o==null&&(o=1),r===0&&(r="valid");const a=L(t,"x","maxPool");let l=a,c=!1;a.rank===3&&(c=!0,l=xe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),z(Er(o,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${s}'`);const d=ho(l.shape,e,o,s,r),f=[d.dilationHeight,d.dilationWidth];let p;r==="same"?p=tJ([d.filterHeight,d.filterWidth],f):p=[[0,0],[0,0]];const g=f[0]===1&&f[1]===1,[y,x]=eJ([d.inHeight,d.inWidth],f,p),w=g?r:"valid",S=g?l:wD(l,f,y),I=(n==="avg"?()=>QA(S,e,o,w,i):()=>yD(S,e,o,w,i))(),R=g?I:ZA(I,f,x);return c?xe(R,[R.shape[1],R.shape[2],R.shape[3]]):R}function eJ(t,e,n){const r=n.map(d=>d[0]),s=n.map(d=>d[1]),o=t.concat(r,s),i=e.map((d,f)=>(d-o[f]%d)%d),a=s.map((d,f)=>d+i[f]),l=e.map((d,f)=>[r[f],a[f]]),c=e.map((d,f)=>[0,i[f]]);return[l,c]}function tJ(t,e){const r=t.map((i,a)=>i+(i-1)*(e[a]-1)).map(i=>i-1),s=r.map(i=>Math.floor(i/2)),o=r.map((i,a)=>i-s[a]);return r.map((i,a)=>[s[a],o[a]])}const nJ=X({pool_:JZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rJ(t,e){const n=L(t,"x","prelu"),r=L(e,"alpha","prelu"),s={x:n,alpha:r};return q.runKernel(U2,s)}const SD=X({prelu_:rJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sJ(t,e=null,n=!1){let r=L(t,"x","prod");r.dtype==="bool"&&(r=Qt(r,"int32"));const s={x:r},o={axis:e,keepDims:n};return q.runKernel(j2,s,o)}const oJ=X({prod_:sJ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iJ(t,e,n,r){const s=t.map((d,f)=>L(d,`tensors${f}`,"raggedGather","int32")),o=L(e,"paramsDenseValues","raggedGather"),i=L(n,"indices","raggedGather","int32"),a={paramsNestedSplits:s,paramsDenseValues:o,indices:i},l={outputRaggedRank:r},c=q.runKernel(oA,a,l);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}const aJ=X({raggedGather_:iJ});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lJ(t,e,n){const r=L(t,"starts","raggedRange"),s=L(e,"limits","raggedRange",r.dtype),o=L(n,"deltas","raggedRange",r.dtype),i={starts:r,limits:s,deltas:o},a=q.runKernel(iA,i);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}const uJ=X({raggedRange_:lJ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cJ(t,e,n,r,s){const o=L(t,"shape","raggedTensorToTensor","int32"),i=L(e,"values","raggedTensorToTensor"),a=L(n,"defaultValue","raggedTensorToTensor",i.dtype),l=r.map((f,p)=>L(f,`tensors${p}`,"raggedTensorToTensor","int32")),c={shape:o,values:i,defaultValue:a,rowPartitionTensors:l},d={rowPartitionTypes:s};return q.runKernel(aA,c,d)}const dJ=X({raggedTensorToTensor_:cJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hJ(t,e,n){Ds(t);const r=fe(t);let s=null;if(n==null||n==="float32")s=new Float32Array(r);else if(n==="int32")s=new Int32Array(r);else if(n==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let o=0;o<r;o++)s[o]=e();return q.makeTensor(s,t,n)}const fJ=X({rand_:hJ});var Km={exports:{}},pJ=Km.exports,SN;function mJ(){return SN||(SN=1,function(t){(function(e,n,r){function s(l){var c=this,d=a();c.next=function(){var f=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=f-(c.c=f|0)},c.c=1,c.s0=d(" "),c.s1=d(" "),c.s2=d(" "),c.s0-=d(l),c.s0<0&&(c.s0+=1),c.s1-=d(l),c.s1<0&&(c.s1+=1),c.s2-=d(l),c.s2<0&&(c.s2+=1),d=null}function o(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function i(l,c){var d=new s(l),f=c&&c.state,p=d.next;return p.int32=function(){return d.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,f&&(typeof f=="object"&&o(f,d),p.state=function(){return o(d,{})}),p}function a(){var l=4022871197,c=function(d){d=String(d);for(var f=0;f<d.length;f++){l+=d.charCodeAt(f);var p=.02519603282416938*l;l=p>>>0,p-=l,p*=l,l=p>>>0,p-=l,l+=p*4294967296}return(l>>>0)*23283064365386963e-26};return c}n&&n.exports?n.exports=i:this.alea=i})(pJ,t)}(Km)),Km.exports}var Xm={exports:{}},gJ=Xm.exports,CN;function yJ(){return CN||(CN=1,function(t){(function(e,n,r){function s(a){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var f=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^f^f>>>8},a===(a|0)?l.x=a:c+=a;for(var d=0;d<c.length+64;d++)l.x^=c.charCodeAt(d)|0,l.next()}function o(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function i(a,l){var c=new s(a),d=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(p+g)/(1<<21);while(y===0);return y},f.int32=c.next,f.quick=f,d&&(typeof d=="object"&&o(d,c),f.state=function(){return o(c,{})}),f}n&&n.exports?n.exports=i:this.xor128=i})(gJ,t)}(Xm)),Xm.exports}var qm={exports:{}},xJ=qm.exports,$N;function vJ(){return $N||($N=1,function(t){(function(e,n,r){function s(a){var l=this,c="";l.next=function(){var f=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(f^f<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:c+=a;for(var d=0;d<c.length+64;d++)l.x^=c.charCodeAt(d)|0,d==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function o(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function i(a,l){var c=new s(a),d=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(p+g)/(1<<21);while(y===0);return y},f.int32=c.next,f.quick=f,d&&(typeof d=="object"&&o(d,c),f.state=function(){return o(c,{})}),f}n&&n.exports?n.exports=i:this.xorwow=i})(xJ,t)}(qm)),qm.exports}var Ym={exports:{}},bJ=Ym.exports,kN;function wJ(){return kN||(kN=1,function(t){(function(e,n,r){function s(a){var l=this;l.next=function(){var d=l.x,f=l.i,p,g;return p=d[f],p^=p>>>7,g=p^p<<24,p=d[f+1&7],g^=p^p>>>10,p=d[f+3&7],g^=p^p>>>3,p=d[f+4&7],g^=p^p<<7,p=d[f+7&7],p=p^p<<13,g^=p^p<<9,d[f]=g,l.i=f+1&7,g};function c(d,f){var p,g=[];if(f===(f|0))g[0]=f;else for(f=""+f,p=0;p<f.length;++p)g[p&7]=g[p&7]<<15^f.charCodeAt(p)+g[p+1&7]<<13;for(;g.length<8;)g.push(0);for(p=0;p<8&&g[p]===0;++p);for(p==8?g[7]=-1:g[p],d.x=g,d.i=0,p=256;p>0;--p)d.next()}c(l,a)}function o(a,l){return l.x=a.x.slice(),l.i=a.i,l}function i(a,l){a==null&&(a=+new Date);var c=new s(a),d=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(p+g)/(1<<21);while(y===0);return y},f.int32=c.next,f.quick=f,d&&(d.x&&o(d,c),f.state=function(){return o(c,{})}),f}n&&n.exports?n.exports=i:this.xorshift7=i})(bJ,t)}(Ym)),Ym.exports}var Qm={exports:{}},SJ=Qm.exports,TN;function CJ(){return TN||(TN=1,function(t){(function(e,n,r){function s(a){var l=this;l.next=function(){var d=l.w,f=l.X,p=l.i,g,y;return l.w=d=d+1640531527|0,y=f[p+34&127],g=f[p=p+1&127],y^=y<<13,g^=g<<17,y^=y>>>15,g^=g>>>12,y=f[p]=y^g,l.i=p,y+(d^d>>>16)|0};function c(d,f){var p,g,y,x,w,S=[],$=128;for(f===(f|0)?(g=f,f=null):(f=f+"\0",g=0,$=Math.max($,f.length)),y=0,x=-32;x<$;++x)f&&(g^=f.charCodeAt((x+32)%f.length)),x===0&&(w=g),g^=g<<10,g^=g>>>15,g^=g<<4,g^=g>>>13,x>=0&&(w=w+1640531527|0,p=S[x&127]^=g+w,y=p==0?y+1:0);for(y>=128&&(S[(f&&f.length||0)&127]=-1),y=127,x=4*128;x>0;--x)g=S[y+34&127],p=S[y=y+1&127],g^=g<<13,p^=p<<17,g^=g>>>15,p^=p>>>12,S[y]=g^p;d.w=w,d.X=S,d.i=y}c(l,a)}function o(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function i(a,l){a==null&&(a=+new Date);var c=new s(a),d=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(p+g)/(1<<21);while(y===0);return y},f.int32=c.next,f.quick=f,d&&(d.X&&o(d,c),f.state=function(){return o(c,{})}),f}n&&n.exports?n.exports=i:this.xor4096=i})(SJ,t)}(Qm)),Qm.exports}var Zm={exports:{}},$J=Zm.exports,IN;function kJ(){return IN||(IN=1,function(t){(function(e,n,r){function s(a){var l=this,c="";l.next=function(){var f=l.b,p=l.c,g=l.d,y=l.a;return f=f<<25^f>>>7^p,p=p-g|0,g=g<<24^g>>>8^y,y=y-f|0,l.b=f=f<<20^f>>>12^p,l.c=p=p-g|0,l.d=g<<16^p>>>16^y,l.a=y-f|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):c+=a;for(var d=0;d<c.length+20;d++)l.b^=c.charCodeAt(d)|0,l.next()}function o(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function i(a,l){var c=new s(a),d=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};return f.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(p+g)/(1<<21);while(y===0);return y},f.int32=c.next,f.quick=f,d&&(typeof d=="object"&&o(d,c),f.state=function(){return o(c,{})}),f}n&&n.exports?n.exports=i:this.tychei=i})($J,t)}(Zm)),Zm.exports}var Jm={exports:{}};const TJ={},IJ=Object.freeze(Object.defineProperty({__proto__:null,default:TJ},Symbol.toStringTag,{value:"Module"})),NJ=sL(IJ);var EJ=Jm.exports,NN;function RJ(){return NN||(NN=1,function(t){(function(e,n,r){var s=256,o=6,i=52,a="random",l=r.pow(s,o),c=r.pow(2,i),d=c*2,f=s-1,p;function g(R,_,F){var O=[];_=_==!0?{entropy:!0}:_||{};var M=S(w(_.entropy?[R,I(n)]:R??$(),3),O),B=new y(O),V=function(){for(var A=B.g(o),re=l,ae=0;A<c;)A=(A+ae)*s,re*=s,ae=B.g(1);for(;A>=d;)A/=2,re/=2,ae>>>=1;return(A+ae)/re};return V.int32=function(){return B.g(4)|0},V.quick=function(){return B.g(4)/4294967296},V.double=V,S(I(B.S),n),(_.pass||F||function(A,re,ae,pe){return pe&&(pe.S&&x(pe,B),A.state=function(){return x(B,{})}),ae?(r[a]=A,re):A})(V,M,"global"in _?_.global:this==r,_.state)}function y(R){var _,F=R.length,O=this,M=0,B=O.i=O.j=0,V=O.S=[];for(F||(R=[F++]);M<s;)V[M]=M++;for(M=0;M<s;M++)V[M]=V[B=f&B+R[M%F]+(_=V[M])],V[B]=_;(O.g=function(A){for(var re,ae=0,pe=O.i,ye=O.j,ve=O.S;A--;)re=ve[pe=f&pe+1],ae=ae*s+ve[f&(ve[pe]=ve[ye=f&ye+re])+(ve[ye]=re)];return O.i=pe,O.j=ye,ae})(s)}function x(R,_){return _.i=R.i,_.j=R.j,_.S=R.S.slice(),_}function w(R,_){var F=[],O=typeof R,M;if(_&&O=="object")for(M in R)try{F.push(w(R[M],_-1))}catch{}return F.length?F:O=="string"?R:R+"\0"}function S(R,_){for(var F=R+"",O,M=0;M<F.length;)_[f&M]=f&(O^=_[f&M]*19)+F.charCodeAt(M++);return I(_)}function $(){try{var R;return p&&(R=p.randomBytes)?R=R(s):(R=new Uint8Array(s),(e.crypto||e.msCrypto).getRandomValues(R)),I(R)}catch{var _=e.navigator,F=_&&_.plugins;return[+new Date,e,F,e.screen,I(n)]}}function I(R){return String.fromCharCode.apply(0,R)}if(S(r.random(),n),t.exports){t.exports=g;try{p=NJ}catch{}}else r["seed"+a]=g})(typeof self<"u"?self:EJ,[],Math)}(Jm)),Jm.exports}var X1,EN;function _J(){if(EN)return X1;EN=1;var t=mJ(),e=yJ(),n=vJ(),r=wJ(),s=CJ(),o=kJ(),i=RJ();return i.alea=t,i.xor128=e,i.xorwow=n,i.xorshift7=r,i.xor4096=s,i.tychei=o,X1=i,X1}var VS=_J();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WS{constructor(e,n,r,s,o){this.mean=e,this.stdDev=n,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const i=o||Math.random();this.random=VS.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,n,r=!1;for(;!r;){let s,o,i;do s=2*this.random()-1,o=2*this.random()-1,i=s*s+o*o;while(i>=1||i===0);const a=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*s*a,n=this.mean+this.stdDev*o*a,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class PJ{constructor(e,n,r,s){this.alpha=e,this.beta=1/n,this.dtype=r;const o=s||Math.random();this.randu=VS.alea(o.toString()),this.randn=new WS(0,1,r,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,n,r,s,o,i;for(;;){do s=this.randn.nextValue(),i=1+this.c*s;while(i<=0);if(i*=i*i,e=s*s,n=1-.331*e*e,r=.5*e+this.d*(1-i+Math.log(i)),o=this.randu(),o<n||Math.log(o)<r)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class AJ{constructor(e=0,n=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=n-e,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${n} <= 1 and dtype is not float`);this.random=VS.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DJ(t,e,n=1,r="float32",s){if(Ds(t),n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);const o=new PJ(e,n,r,s),i=Vt(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const FJ=X({randomGamma_:DJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OJ(t,e=0,n=1,r,s){if(Ds(t),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const o=new WS(e,n,r,!1,s),i=Vt(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const CD=X({randomNormal_:OJ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LJ(t,e,n){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return CD(t,0,1,e,n)}const zJ=X({randomStandardNormal_:LJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BJ(t,e=0,n=1,r="float32",s){Ds(t);const o=Vt(t,r),i=new AJ(e,n,null,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const US=X({randomUniform_:BJ});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MJ(t,e,n,r){return US(t,e,n,"int32",r)}const VJ=X({randomUniformInt_:MJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cf(t,e,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");const s={start:t,stop:e,step:n,dtype:r};return q.runKernel(G2,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WJ(t){const n={input:L(t,"input","real")};return q.runKernel(H2,n)}const $f=X({real_:WJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UJ(t){const n={x:L(t,"x","reciprocal")};return q.runKernel(K2,n)}const jJ=X({reciprocal_:UJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GJ(t){const n={x:L(t,"x","relu")};return q.runKernel(X2,n)}const py=X({relu_:GJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HJ(t){const n={x:L(t,"x","relu6")};return q.runKernel(Z2,n)}const $D=X({relu6_:HJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KJ(t,e){const r={x:L(t,"x","reverse")},s={dims:e};return q.runKernel(J2,r,s)}const Du=X({reverse_:KJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XJ(t){const e=L(t,"x","reverse");return z(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Du(e,0)}const qJ=X({reverse1d_:XJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YJ(t,e){const n=L(t,"x","reverse");return z(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),Du(n,e)}const QJ=X({reverse2d_:YJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZJ(t,e){const n=L(t,"x","reverse");return z(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),Du(n,e)}const JJ=X({reverse3d_:ZJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eee(t,e){const n=L(t,"x","reverse");return z(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),Du(n,e)}const tee=X({reverse4d_:eee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nee(t){const n={x:L(t,"x","round")};return q.runKernel(eS,n)}const kD=X({round_:nee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ree(t){const n={x:L(t,"x","rsqrt","float32")};return q.runKernel(tS,n)}const see=X({rsqrt_:ree});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oee(t){const n={x:L(t,"x","selu")};return q.runKernel(iS,n)}const iee=X({selu_:oee});function aee(t,e,n,r,s,o=[1,1],i="NHWC"){const a=L(t,"x","separableConv2d"),l=L(e,"depthwiseFilter","separableConv2d"),c=L(n,"pointwiseFilter","separableConv2d");let d=a,f=!1;if(a.rank===3&&(f=!0,d=xe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");z(d.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${d.rank}.`),z(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),z(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),z(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),z(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const p=l.shape[2],g=l.shape[3];z(c.shape[2]===p*g,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*g}, but got ${c.shape[2]}.`);const y=LS(d,l,r,s,i,o),w=cy(y,c,1,"valid",i);return f?xe(w,[w.shape[1],w.shape[2],w.shape[3]]):w}const lee=X({separableConv2d_:aee});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function uee(t,e){const n=L(t,"x","setdiff1d"),r=L(e,"y","setdiff1d");z(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),z(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),z(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await n.data(),o=await r.data(),i=new Set(o);let a=0;for(let d=0;d<s.length;d++)i.has(s[d])||a++;const l=new ad([a],n.dtype),c=new ad([a],"int32");for(let d=0,f=0;d<s.length;d++)i.has(s[d])||(l.values[f]=s[d],c.values[f]=d,f++);return[l.toTensor(),c.toTensor()]}const cee=uee;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dee(t){const n={x:L(t,"x","sign")};return q.runKernel(cS,n)}const hee=X({sign_:dee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fee(t){const n={x:L(t,"x","sin","float32")};return q.runKernel(lS,n)}const pee=X({sin_:fee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mee(t){const n={x:L(t,"x","sinh")};return q.runKernel(uS,n)}const gee=X({sinh_:mee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yee(t,e,n){const r=L(t,"x","slice1d");return z(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),ft(r,[e],[n])}const xee=X({slice1d_:yee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vee(t,e,n){const r=L(t,"x","slice2d");return z(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),ft(r,e,n)}const bee=X({slice2d_:vee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wee(t,e,n){const r=L(t,"x","slice3d");return z(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),ft(r,e,n)}const See=X({slice3d_:wee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cee(t,e,n){const r=L(t,"x","slice4d");return z(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),ft(r,e,n)}const $ee=X({slice4d_:Cee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kee(t,e=-1){const n=L(t,"logits","softmax","float32");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const r={logits:n},s={dim:e};return q.runKernel(yS,r,s)}const Tee=X({softmax_:kee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iee(t){z(t.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);const e={input:t};return q.runKernel(Qw,e)}const jS=X({fft_:Iee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nee(t){z(t.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);const e={input:t};return q.runKernel(a2,e)}const Rg=X({ifft_:Nee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eee(t){const e=t.shape[t.shape.length-1],n=t.size/e;let r;if(e<=2){const s=xe(t,[n,e]);r=Rg(s)}else{const s=[n,2*(e-1)],o=xe($f(t),[n,e]),i=xe(fy(t),[n,e]),a=Du(ft(o,[0,1],[n,e-2]),1),l=Te(Du(ft(i,[0,1],[n,e-2]),1),pt(-1)),c=On([o,a],1),d=On([i,l],1),f=xe(ml(c,d),[s[0],s[1]]);r=Rg(f)}if(r=$f(r),t.rank===3&&t.shape[0]!==0){const s=r,o=t.shape[0];r=xe(r,[o,r.shape[0]/o,r.shape[1]]),s.dispose()}return r}const TD=X({irfft_:Eee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ree(t,e,n=0){const s={x:L(t,"x","split")},o={numOrSizeSplits:e,axis:n};return q.runKernel(gS,s,o)}const kf=X({split_:Ree});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ee(t,e){z(t.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const r=t.size/n;let s;if(e!=null&&e<n){const y=t.shape.map(w=>0),x=t.shape.map(w=>w);x[t.shape.length-1]=e,s=ft(t,y,x),n=e}else if(e!=null&&e>n){const y=t.shape.map(x=>x);y[t.shape.length-1]=e-n,s=On([t,ma(y)],t.shape.length-1),n=e}else s=t;const o=As(s),i=xe(ml(s,o),[r,n]),a=jS(i),l=Math.floor(n/2)+1,c=$f(a),d=fy(a),f=kf(c,[l,n-l],c.shape.length-1),p=kf(d,[l,n-l],d.shape.length-1),g=s.shape.slice();return g[s.shape.length-1]=l,xe(ml(f[0],p[0]),g)}const GS=X({rfft_:_ee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pee(t,e){let n=L(t,"a","squaredDifference"),r=L(e,"b","squaredDifference");[n,r]=gn(n,r),ct(n.shape,r.shape);const s={a:n,b:r},o={};return q.runKernel(wS,s,o)}const ID=X({squaredDifference_:Pee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aee(t,e){const n=L(t,"x","squeeze","string_or_numeric");return xe(n,wl(n.shape,e).newShape)}const Gt=X({squeeze_:Aee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dee(t,e=0){const n=Ig(t,"tensors","stack","string_or_numeric");z(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&z(e<=n[0].rank,()=>"Axis must be <= rank of the tensor");const r=n,s={axis:e};return q.runKernel(M2,r,s)}const ga=X({stack_:Dee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fee(t,e=0){const r={x:L(t,"x","step")},s={alpha:e};return q.runKernel(PS,r,s)}const ND=X({step_:Fee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oee(t,e,n,r,s=0,o=0,i=0,a=0,l=0){const d={x:L(t,"x","stridedSlice","string_or_numeric")},f={begin:e,end:n,strides:r,beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};return q.runKernel(SS,d,f)}const Lee=X({stridedSlice_:Oee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zee(t){const n={x:L(t,"x","tan","float32")};return q.runKernel(kS,n)}const Bee=X({tan_:zee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lr(t,e){Cd(t);const n=Sl(t,e);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Cl(t,null,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lo(t,e,n){if(Cd(t),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=Sl(t,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Cl(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ED(t,e,n){if(Cd(t),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=Sl(t,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Cl(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mee(t,e,n){if(Cd(t),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=Sl(t,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Cl(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vee(t,e,n){if(Cd(t),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const r=Sl(t,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Cl(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wee(t,e,n){if(Cd(t),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const r=Sl(t,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,Cl(t,e,r,n)}function RD(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(o+` update.rank < ${s}. `);if(t.length<r+(n.rank-s))throw new Error(o+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+t.length-r)throw new Error(o+` update.rank != ${s+t.length-r}`);for(let i=0;i<s;++i)if(n.shape[i]!==e.shape[i])throw new Error(o+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${e.shape[i]}).`);for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==t[i+r])throw new Error(o+` updates.shape[${i+s}] (${n.shape[i+s]}) != shape[${i+s}] (${t[i+s]})`)}function HS(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(t.size===0)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}RD(n,e,t)}function zu(t,e,n){const r=e.shape.length,s=r>1?e.shape[r-1]:1,o=n.length;let i=1;for(let f=s;f<o;++f)i*=n[f];const a=s<1?1:s,l=fe(e.shape)/a,c=[...mn(n.slice(0,s)),1],d=fe(n);return{sliceRank:s,numUpdates:l,sliceSize:i,strides:c,outputSize:d}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uee(t,e,n){const r=L(t,"tensor","tensorScatterupdate"),s=L(e,"indices","tensorScatterupdate","int32"),o=L(n,"updates","tensorScatterupdate");if(HS(o,s,r.shape),r.dtype!==o.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${o.dtype}.`);const i={tensor:r,indices:s,updates:o},a={};return q.runKernel(rS,i,a)}const jee=X({tensorScatterUpdate_:Uee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gee(t,e=1,n=!0){const r=L(t,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const o={x:r},i={k:e,sorted:n},[a,l]=q.runKernel(IS,o,i);return{values:a,indices:l}}const Hee=X({topk_:Gee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kee(t,e=0,n=1,r,s){if(Ds(t),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const o=new WS(e,n,r,!0,s),i=Vt(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const Xee=X({truncatedNormal_:Kee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qee(t,e=0){const n=L(t,"x","unique","string_or_numeric");z(n.rank>0,()=>"The input tensor must be at least 1D");const r={x:n},s={axis:e},[o,i]=q.runKernel(gA,r,s);return{values:o,indices:i}}const Yee=X({unique_:qee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qee(t,e,n){const r=L(t,"x","unsortedSegmentSum"),s=L(e,"segmentIds","unsortedSegmentSum","int32");z(id(n),()=>"numSegments must be of dtype int");const o={x:r,segmentIds:s},i={numSegments:n};return q.runKernel(RS,o,i)}const Zee=X({unsortedSegmentSum_:Qee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jee(t,e=0){const n=L(t,"x","unstack","string_or_numeric");z(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`);const r={value:n},s={axis:e};return q.runKernel(ES,r,s)}const Bu=X({unstack_:Jee});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ete(t,e){return MS(t,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tte(t,e=!0,n,r){return q.makeVariable(t,e,n,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _D(t,e){const n=[];for(let o=0;o<e.length;o++)e[o]&&n.push(o);const r=Vt(t,"int32"),s=Vt([n.length,t.length],"int32");for(let o=0;o<n.length;o++){const i=r.indexToLoc(n[o]),a=o*t.length;s.values.set(i,a)}return s.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function nte(t){const e=L(t,"condition","whereAsync","bool"),n=await e.data(),r=_D(e.shape,n);return t!==e&&e.dispose(),r}const PD=nte;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function rte(t,e,n){const r=L(t,"tensor","boolMask"),s=L(e,"mask","boolMask","bool"),o=n??0,i=s.rank,a=r.shape;z(i>0,()=>"mask cannot be scalar"),gs(a.slice(o,o+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let x=o;x<o+i;x++)l*=a[x];const c=a.slice(0,o).concat([l],a.slice(o+i)),d=xe(r,c),f=xe(s,[-1]),p=await PD(f),g=Gt(p,[1]),y=uD(d,g,o);return t!==r&&r.dispose(),e!==s&&s.dispose(),g.dispose(),d.dispose(),f.dispose(),p.dispose(),y}const ste=rte;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ote(t,e,n){const r=L(t,"x","transpose");if(e==null&&(e=r.shape.map((i,a)=>a).reverse()),z(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(i=>{z(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();const s={x:r},o={perm:e};return r.dtype==="complex64"?tt(()=>{let i=$f(r),a=fy(r);return i=q.runKernel(Qh,{x:i},o),a=q.runKernel(Qh,{x:a},o),n&&(a=xi(a)),ml(i,a)}):q.runKernel(Qh,s,o)}const gv=X({transpose_:ote});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ite(t,e,n,r,s=!0){const o=L(t,"v","movingAverage"),i=L(e,"x","movingAverage"),a=L(n,"decay","movingAverage");NX(o,i),z(Mt(o.shape,i.shape),()=>"Shape mismatch in v and x");const l=pt(1),c=ot(l,a);let d=Te(ot(i,o),c);if(s){z(r!=null,()=>"When using zeroDebias: true, step is required.");const f=L(r,"step","movingAverage");d=gt(d,ot(l,bf(a,f)))}return Ue(o,d)}const ate=X({movingAverage_:ite});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lte(t,e,n){Ds(n);const r=L(t,"indices","scatterND","int32"),s=L(e,"updates","scatterND");HS(s,r,n);const o={indices:r,updates:s},i={shape:n};return q.runKernel(nS,o,i)}const ute=X({scatterND_:lte});function cte(t,e,n,r){if(t.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const s=t.rank>0?t.shape[0]:1,o=t.rank>1?t.shape[1]:1;if(n.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${o}.`);const i=e.size;if(!(e.rank===0||e.rank===1&&i===s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dte(t,e,n,r=0){Ds(n);const s=L(t,"sparseIndices","sparseToDense","int32"),o=L(e,"sparseValues","sparseToDense","string_or_numeric"),i=L(r,"defaultValue","sparseToDense",o.dtype);cte(s,o,n,i);const a={sparseIndices:s,sparseValues:o,defaultValue:i},l={outputShape:n};return q.runKernel(bS,a,l)}const hte=X({sparseToDense_:dte});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fte(t,e){const n=L(e,"indices","gatherND","int32"),s={params:L(t,"x","gatherND","string_or_numeric"),indices:n};return q.runKernel(s2,s)}const pte=X({gatherND_:fte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mte(t,e){if(e==null)return t.shape.slice();if(Mt(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)e[r]==null&&t.shape[r]!=null?n.push(t.shape[r]):n.push(e[r]);return n}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gte(t,e,n,r){const s=L(t,"x","dropout");if(z(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),z(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return t instanceof hn?s.clone():s;const o=mte(s,n),i=1-e,a=gt(lD(Ue(US(o,0,1,"float32",r),i)),i);return Te(s,a)}const yte=X({dropout_:gte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AD(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function KS(t,e,n){const r=1-t%2,s=new Float32Array(t);for(let o=0;o<t;++o){const i=2*Math.PI*o/(t+r-1);s[o]=e-n*Math.cos(i)}return lr(s,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function xte(t,e,n=1){const r=L(t,"predictions","inTopK"),s=L(e,"targets","inTopK");z(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),z(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),gs(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=r.shape[r.shape.length-1];z(n>0&&n<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${n}`);const i=await r.data(),a=await s.data(),[l,c]=[i.length/o,o],d=bi("bool",l);for(let f=0;f<l;f++){const p=f*c,g=i.subarray(p,p+c),y=[];for(let x=0;x<g.length;x++)y.push({value:g[x],index:x});y.sort((x,w)=>w.value-x.value),d[f]=0;for(let x=0;x<n;x++)if(y[x].index===a[f]){d[f]=1;break}}return t!==r&&r.dispose(),e!==s&&s.dispose(),yi(d,s.shape,"bool")}const vte=xte;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bte(t,e,n,r,s,o="NHWC",i){let a=t;t.rank===3&&(a=xe(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=xe(e,[1,e.shape[0],e.shape[1],e.shape[2]])),z(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),z(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),z(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const c=o==="NHWC"?a.shape[3]:a.shape[1],d=o==="NHWC"?l.shape[3]:l.shape[1];z(c===n[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${n[2]}.`),z(d===n[3],()=>`Error in conv2dDerFilter: depth of dy (${d}) must match output depth for filter (${n[3]}).`),fo("conv2dDerFilter",s,i);const f={x:a,dy:l},p={strides:r,pad:s,dataFormat:o,dimRoundingMode:i,filterShape:n};return q.runKernel(Iw,f,p)}const wte=X({conv2DBackpropFilter_:bte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function my(t,e,n){if(n==null||n==="linear")return t;if(n==="relu")return Te(t,ND(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function gy(t,e){let n=e;const r=nD(t.shape,e.shape);return r.length>0&&(n=en(n,r)),xe(n,t.shape)}function yy(t,e,n,r){if(e==="linear")return t;if(e==="relu")return py(t);if(e==="elu")return sD(t);if(e==="relu6")return $D(t);if(e==="prelu")return SD(t,n);if(e==="leakyrelu")return dD(t,r);if(e==="sigmoid")return sa(t);throw new Error(`Unknown fused activation ${e}.`)}const xy=(t,e)=>!(t>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ste({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:d}){if(l=l||"linear",xy(q.state.gradientDepth,l)===!1){z(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let F=cy(t,e,n,r,s,o,i);return a!=null&&(F=Ue(F,a)),yy(F,l,c,d)}const f=L(t,"x","conv2d","float32"),p=L(e,"filter","conv2d","float32");let g=f,y=!1;f.rank===3&&(y=!0,g=xe(f,[1,f.shape[0],f.shape[1],f.shape[2]])),z(g.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${g.rank}.`),z(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),fo("fused conv2d",r,i);const x=s==="NHWC"?g.shape[3]:g.shape[1];z(p.shape[2]===x,()=>`Error in conv2d: depth of input (${x}) must match input depth for filter ${p.shape[2]}.`),z(Er(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);const w=kn(g.shape,p.shape,n,o,r,i);let S;a!=null&&(S=L(a,"bias","fused conv2d"),[S]=gn(S,f),s==="NHWC"?ct(w.outShape,S.shape):(z(S.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${S.shape.length}.`),z(S.shape.length===0||S.shape[0]===w.outChannels||S.shape[0]===1,()=>`Error in fused conv2d: bias shape (${S.shape}) is not compatible with the number of output channels (${w.outChannels})`)));let $;if(c!=null){const F=c.shape;if(z(F.length<=1||F.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${F.length}.`),F.length===1)z(F[0]===1||F[0]===w.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${F}) is not compatible with the number of output channels (${w.outChannels}).`);else if(F.length===3)try{ct(F,w.outShape)}catch{const M=`Error in fused conv2d: PReLU activation weights (${F}) is not compatible with the output shape of the conv2d (${w.outShape}).`;throw Error(M)}$=L(c,"prelu weights","fused conv2d")}const I=(F,O)=>{z(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[M,B,V,A]=O,re=my(F,V,l);z(vf(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const ae=tD(B.shape,re,M,n,r),pe=wte(B,re,M.shape,n,r),ye=[ae,pe];if(A!=null){const ve=gy(A,re);ye.push(ve)}return ye},R={x:g,filter:p,bias:S,preluActivationWeights:$},_={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:d};return a==null?pa((O,M,B)=>{let V=q.runKernel(Sg,R,_);return B([M,O,V]),y&&(V=xe(V,[V.shape[1],V.shape[2],V.shape[3]])),{value:V,gradFunc:I}})(g,p):pa((O,M,B,V)=>{let A=q.runKernel(Sg,R,_);return V([M,O,A,B]),y&&(A=xe(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:I}})(g,p,S)}const Cte=X({fusedConv2d_:Ste});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $te(t,e,n,r,s,o=[1,1],i){let a=t;t.rank===3&&(a=xe(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=xe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:a,dy:l},d={strides:r,pad:s,dimRoundingMode:i,dilations:o,filterShape:n};return q.runKernel(Bw,c,d)}const kte=X({depthwiseConv2dNativeBackpropFilter_:$te});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tte(t,e,n,r,s,o=[1,1],i){let a=e,l=!1;e.rank===3&&(l=!0,a=xe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:a,filter:n},d={strides:r,pad:s,dimRoundingMode:i,dilations:o,inputShape:t},f=q.runKernel(Mw,c,d);return l?xe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Ite=X({depthwiseConv2dNativeBackpropInput_:Tte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nte({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:d}){if(xy(q.state.gradientDepth,l)===!1){let _=LS(t,e,n,r,s,o,i);return a!=null&&(_=Ue(_,a)),yy(_,l,c,d)}const f=L(t,"x","depthwiseConv2d","float32"),p=L(e,"filter","depthwiseConv2d","float32");let g=f,y=!1;f.rank===3&&(y=!0,g=xe(f,[1,f.shape[0],f.shape[1],f.shape[2]])),z(g.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${g.rank}.`),z(p.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),z(g.shape[3]===p.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${g.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),o==null&&(o=[1,1]),z(Er(n,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),fo("fused depthwiseConv2d",r,i);const x=kn(g.shape,p.shape,n,o,r,i,!0);let w;a!=null&&(w=L(a,"bias","fused conv2d"),[w]=gn(w,f),ct(x.outShape,w.shape));let S;c!=null&&(S=L(c,"prelu weights","fused depthwiseConv2d"));const $=(_,F)=>{z(vf(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[O,M,B,V]=F,A=my(_,B,l),re=Ite(M.shape,A,O,n,r,o,i),ae=kte(M,A,O.shape,n,r,o,i);if(V!=null){const pe=gy(w,A);return[re,ae,pe]}return[re,ae]},I={x:g,filter:p,bias:w,preluActivationWeights:S},R={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:d};return a==null?pa((F,O,M)=>{let B=q.runKernel(Cg,I,R);return M([O,F,B]),y&&(B=xe(B,[B.shape[1],B.shape[2],B.shape[3]])),{value:B,gradFunc:$}})(g,p):pa((F,O,M,B)=>{let V=q.runKernel(Cg,I,R);return B([O,F,V,M]),y&&(V=xe(V,[V.shape[1],V.shape[2],V.shape[3]])),{value:V,gradFunc:$}})(g,p,w)}const Ete=X({fusedDepthwiseConv2d_:Nte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rte({a:t,b:e,transposeA:n=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(xy(q.state.gradientDepth,o)===!1){let A=Ht(t,e,n,r);return s!=null&&(A=Ue(A,s)),yy(A,o,i,a)}let l=L(t,"a","fused matMul"),c=L(e,"b","fused matMul");[l,c]=gn(l,c);const d=n?l.shape[l.rank-2]:l.shape[l.rank-1],f=r?c.shape[c.rank-1]:c.shape[c.rank-2],p=n?l.shape[l.rank-1]:l.shape[l.rank-2],g=r?c.shape[c.rank-2]:c.shape[c.rank-1],y=l.shape.slice(0,-2),x=c.shape.slice(0,-2),w=fe(y),S=fe(x);z(d===f,()=>`Error in fused matMul: inner shapes (${d}) and (${f}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${n} and transposeB=${r} must match.`);const I=ct(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([p,g]),R=n?xe(l,[w,d,p]):xe(l,[w,p,d]),_=r?xe(c,[S,g,f]):xe(c,[S,f,g]);let F;s!=null&&(F=L(s,"bias","fused matMul"),[F]=gn(F,l),ct(I,F.shape));let O;i!=null&&(O=L(i,"prelu weights","fused matMul"));const M=(A,re)=>{const[ae,pe,ye,ve]=re,$e=my(xe(A,ye.shape),ye,o);let se,me;if(!n&&!r?(se=Ht($e,pe,!1,!0),me=Ht(ae,$e,!0,!1)):!n&&r?(se=Ht($e,pe,!1,!1),me=Ht($e,ae,!0,!1)):n&&!r?(se=Ht(pe,$e,!1,!0),me=Ht(ae,$e,!1,!1)):(se=Ht(pe,$e,!0,!0),me=Ht($e,ae,!0,!0)),s!=null){const ge=gy(ve,$e);return[se,me,ge]}else return[se,me]},B={a:R,b:_,bias:F,preluActivationWeights:O},V={transposeA:n,transposeB:r,activation:o,leakyreluAlpha:a};return s==null?pa((re,ae,pe)=>{const ye=q.runKernel(wg,B,V);return pe([re,ae,ye]),{value:xe(ye,I),gradFunc:M}})(R,_):pa((re,ae,pe,ye)=>{const ve=q.runKernel(wg,B,V);return ye([re,ae,ve,pe]),{value:xe(ve,I),gradFunc:M}})(R,_,F)}const _te=X({fusedMatMul_:Rte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pte=Object.freeze(Object.defineProperty({__proto__:null,conv2d:Cte,depthwiseConv2d:Ete,matMul:_te},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ate(t){return KS(t,.54,.46)}const Dte=X({hammingWindow_:Ate});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fte(t){return KS(t,.5,.5)}const DD=X({hannWindow_:Fte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ote(t,e,n,r=!1,s=0){let o=0;const i=[];for(;o+e<=t.size;)i.push(ft(t,o,e)),o+=n;if(r)for(;o<t.size;){const a=o+e-t.size,l=On([ft(t,o,e-a),qf([a],s)]);i.push(l),o+=n}return i.length===0?lo([],[0,e]):xe(On(i),[i.length,e])}const FD=X({frame_:Ote});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lte(t,e,n,r,s=DD){r==null&&(r=AD(e));const o=FD(t,e,n),i=Te(o,s(e));return GS(i,r)}const zte=X({stft_:Lte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bte(t,e,n,r,s="bilinear",o=0){const i=L(t,"image","cropAndResize"),a=L(e,"boxes","cropAndResize","float32"),l=L(n,"boxInd","cropAndResize","int32"),c=a.shape[0];z(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),z(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),z(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),z(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),z(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),z(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const d={image:i,boxes:a,boxInd:l},f={method:s,extrapolationValue:o,cropSize:r};return q.runKernel(Fw,d,f)}const Mte=X({cropAndResize_:Bte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vte(t){const e=L(t,"image","flipLeftRight","float32");z(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const n={image:e};return q.runKernel(Jw,n,{})}const Wte=X({flipLeftRight_:Vte});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ute(t){const e=L(t,"image","grayscaleToRGB"),n=e.rank-1,r=e.shape[n];z(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),z(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,n),s[n]=3,Jh(e,s)}const jte=X({grayscaleToRGB_:Ute});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gte(t){const e=L(t,"image","RGBToGrayscale"),n=e.rank-1,r=e.shape[n];z(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),z(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const s=e.dtype,o=Qt(e,"float32"),i=lr([.2989,.587,.114]);let a;switch(e.rank){case 2:a=_c("ij,j->i",o,i);break;case 3:a=_c("ijk,k->ij",o,i);break;case 4:a=_c("ijkl,l->ijk",o,i);break;case 5:a=_c("ijklm,m->ijkl",o,i);break;case 6:a=_c("ijklmn,n->ijklm",o,i);break;default:throw new Error("Not a valid tensor rank.")}return a=Es(a,-1),Qt(a,s)}const Hte=X({rgbToGrayscale_:Gte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kte(t,e,n=0,r=.5){const s=L(t,"image","rotateWithOffset","float32");z(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const o={image:s},i={radians:e,fillValue:n,center:r};return q.runKernel(AS,o,i)}const Xte=X({rotateWithOffset_:Kte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Td(t,e,n,r,s,o){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),o==null&&(o=0);const i=t.shape[0];return n=Math.min(n,i),z(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),z(t.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),z(t.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),z(e.rank===1,()=>"scores must be a 1D tensor"),z(e.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${e.shape[0]}`),z(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qte(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const o=L(t,"boxes","nonMaxSuppression","float32"),i=L(e,"scores","nonMaxSuppression","float32"),a=Td(o,i,n,r,s);n=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return q.runKernel(O2,{boxes:o,scores:i},l)}const Yte=X({nonMaxSuppression_:qte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qte(t,e,n){const r=Zte(t,e,n),s=r<0?-(r+1):r;t.splice(s,0,e)}function Zte(t,e,n){return ene(t,e,n||Jte)}function Jte(t,e){return t>e?1:t<e?-1:0}function ene(t,e,n){let r=0,s=t.length,o=0,i=!1;for(;r<s;){o=r+(s-r>>>1);const a=n(e,t[o]);a>0?r=o+1:(s=o,i=!a)}return i?r:-r-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XS(t,e,n,r,s){return YS(t,e,n,r,s,0)}function OD(t,e,n,r,s,o){return YS(t,e,n,r,s,0,!1,o,!0)}function qS(t,e,n,r,s,o){return YS(t,e,n,r,s,o,!0)}function YS(t,e,n,r,s,o,i=!1,a=!1,l=!1){const c=[];for(let w=0;w<e.length;w++)e[w]>s&&c.push({score:e[w],boxIndex:w,suppressBeginIndex:0});c.sort(RN);const d=o>0?-.5/o:0,f=[],p=[];for(;f.length<n&&c.length>0;){const w=c.pop(),{score:S,boxIndex:$,suppressBeginIndex:I}=w;if(S<s)break;let R=!1;for(let _=f.length-1;_>=I;--_){const F=tne(t,$,f[_]);if(F>=r){R=!0;break}if(w.score=w.score*nne(r,d,F),w.score<=s)break}w.suppressBeginIndex=f.length,R||(w.score===S?(f.push($),p.push(w.score)):w.score>s&&Qte(c,w,RN))}const g=f.length,y=n-g;a&&y>0&&(f.push(...new Array(y).fill(0)),p.push(...new Array(y).fill(0)));const x={selectedIndices:f};return i&&(x.selectedScores=p),l&&(x.validOutputs=g),x}function tne(t,e,n){const r=t.subarray(e*4,e*4+4),s=t.subarray(n*4,n*4+4),o=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(s[0],s[2]),d=Math.min(s[1],s[3]),f=Math.max(s[0],s[2]),p=Math.max(s[1],s[3]),g=(a-o)*(l-i),y=(f-c)*(p-d);if(g<=0||y<=0)return 0;const x=Math.max(o,c),w=Math.max(i,d),S=Math.min(a,f),$=Math.min(l,p),I=Math.max(S-x,0)*Math.max($-w,0);return I/(g+y-I)}function nne(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function RN(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function rne(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const o=L(t,"boxes","nonMaxSuppressionAsync"),i=L(e,"scores","nonMaxSuppressionAsync"),a=Td(o,i,n,r,s);n=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l=await Promise.all([o.data(),i.data()]),c=l[0],d=l[1],{selectedIndices:f}=XS(c,d,n,r,s);return o!==t&&o.dispose(),i!==e&&i.dispose(),lr(f,"int32")}const sne=rne;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function one(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=L(t,"boxes","nonMaxSuppression"),a=L(e,"scores","nonMaxSuppression"),l=Td(i,a,n,r,s,o);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,o=l.softNmsSigma;const c={boxes:i,scores:a},d={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:o},f=q.runKernel(L2,c,d);return{selectedIndices:f[0],selectedScores:f[1]}}const ine=X({nonMaxSuppressionWithScore_:one});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function ane(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=L(t,"boxes","nonMaxSuppressionAsync"),a=L(e,"scores","nonMaxSuppressionAsync"),l=Td(i,a,n,r,s,o);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,o=l.softNmsSigma;const c=await Promise.all([i.data(),a.data()]),d=c[0],f=c[1],{selectedIndices:p,selectedScores:g}=qS(d,f,n,r,s,o);return i!==t&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:lr(p,"int32"),selectedScores:lr(g)}}const lne=ane;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function une(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=L(t,"boxes","nonMaxSuppression"),a=L(e,"scores","nonMaxSuppression"),l=Td(i,a,n,r,s,null),c=l.maxOutputSize,d=l.iouThreshold,f=l.scoreThreshold,p={boxes:i,scores:a},g={maxOutputSize:c,iouThreshold:d,scoreThreshold:f,padToMaxOutputSize:o},y=q.runKernel(sA,p,g);return{selectedIndices:y[0],validOutputs:y[1]}}const cne=X({nonMaxSuppressionPadded_:une});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function dne(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=L(t,"boxes","nonMaxSuppressionAsync"),a=L(e,"scores","nonMaxSuppressionAsync"),l=Td(i,a,n,r,s,null),c=l.maxOutputSize,d=l.iouThreshold,f=l.scoreThreshold,[p,g]=await Promise.all([i.data(),a.data()]),{selectedIndices:y,validOutputs:x}=OD(p,g,c,d,f,o);return i!==t&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:lr(y,"int32"),validOutputs:pt(x,"int32")}}const hne=dne;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fne(t,e,n=!1,r=!1){const s=L(t,"images","resizeBilinear");z(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),z(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),z(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;s.rank===3&&(i=!0,o=xe(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:o},l={alignCorners:n,halfPixelCenters:r,size:e},c=q.runKernel(Q2,a,l);return i?xe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const pne=X({resizeBilinear_:fne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mne(t,e,n=!1,r=!1){const s=L(t,"images","resizeNearestNeighbor");z(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),z(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),z(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),z(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;s.rank===3&&(i=!0,o=xe(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:o},l={alignCorners:n,halfPixelCenters:r,size:e},c=q.runKernel(Y2,a,l);return i?xe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const gne=X({resizeNearestNeighbor_:mne});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yne(t,e="binary",n=!1,r=.5){const s=L(t,"image","threshold"),o=.2989,i=.587,a=.114,l=s.shape[0]*s.shape[1];let c=Te(lr([r]),255),d,f,p,g;if(z(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),z(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),z(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),z(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[d,f,p]=kf(s,[1,1,1],-1);const w=Te(d,o),S=Te(f,i),$=Te(p,a);g=Ue(Ue(w,S),$)}else g=t;if(e==="otsu"){const w=JA(Qt(kD(g),"int32"),yi([]),256);c=xne(w,l)}const y=n?BS(g,c):hy(g,c);return Qt(Te(y,255),"int32")}function xne(t,e){let n=lr([-1]),r=lr([0]),s=lr([0]),o,i,a,l,c,d;for(let f=0;f<t.size-1;f++){o=ft(t,0,f+1),i=ft(t,f+1),c=gt(en(o),e),d=gt(en(i),e);const p=en(Te(o,Cf(0,o.size)));a=gt(p,en(o));const g=qf(i.shape,o.size),y=Ue(Cf(0,i.size),g),x=Te(i,y);l=gt(en(x),en(i));const w=ot(a,l),S=ot(a,l),$=Te(c,d);s=Te(Te($,w),S);const I=hy(s,r);r=hl(I,s,r),n=hl(I,lr([f]),n)}return n}const vne=X({threshold_:yne});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bne(t,e,n="nearest",r="constant",s=0,o){const i=L(t,"image","transform","float32"),a=L(e,"transforms","transform","float32");z(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),z(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),z(o==null||o.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);const l={image:i,transforms:a},c={interpolation:n,fillMode:r,fillValue:s,outputShape:o};return q.runKernel(NS,l,c)}const wne=X({transform_:bne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sne(t,e,n){const r=L(t,"a","bandPart");z(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[o,i]=r.shape.slice(-2);let a,l;typeof e=="number"?(z(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),z(e<=o,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${o}).`),a=L(e<0?o:e,"numLower","bandPart")):(z(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=hl(mv(e,0),o,Sf(e,o))),typeof n=="number"?(z(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),z(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),l=L(n<0?i:n,"numUpper","bandPart")):(z(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=hl(mv(n,0),i,Sf(n,i)));const c=xe(Cf(0,o,1,"int32"),[-1,1]),d=Cf(0,i,1,"int32"),f=ot(c,d),p=Ng(BS(f,a),cD(f,xi(l))),g=ma([o,i],r.dtype);return xe(ga(Bu(xe(r,[-1,o,i])).map(y=>hl(p,y,g))),s)}const Cne=X({bandPart_:Sne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ne(t){let e;if(Array.isArray(t)){e=!1,z(t!=null&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=t[0].shape[0];for(let o=1;o<t.length;++o)z(t[o].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[o].shape[0]} vs. ${s})`)}else e=!0,t=kf(t,t.shape[0],0).map(s=>Gt(s,[0]));z(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],r=t;for(let s=0;s<t.length;++s)n.push(q.tidy(()=>{let o=r[s];if(s>0)for(let i=0;i<s;++i){const a=Te(en(Te(n[i],o)),n[i]);o=ot(o,a)}return gt(o,dy(o,"euclidean"))}));return e?ga(n,0):n}const kne=X({gramSchmidt_:$ne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tne(t,e=!1){if(z(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),t.rank===2)return _N(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((l,c)=>l*c),r=Bu(xe(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),s=[],o=[];r.forEach(l=>{const[c,d]=_N(l,e);s.push(c),o.push(d)});const i=xe(ga(s,0),t.shape),a=xe(ga(o,0),t.shape);return[i,a]}}function _N(t,e=!1){return q.tidy(()=>{z(t.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],r=t.shape[1];let s=aD(n),o=dl(t);const i=lo([[1]],[1,1]);let a=dl(i);const l=n>=r?r:n;for(let c=0;c<l;++c){const d=o,f=a,p=s;[a,o,s]=q.tidy(()=>{const g=ft(o,[c,c],[n-c,1]),y=dy(g),x=ft(o,[c,c],[1,1]),w=hl(hy(x,0),lo([[-1]]),lo([[1]])),S=ot(x,Te(w,y)),$=gt(g,S);$.shape[0]===1?a=dl(i):a=On([i,ft($,[1,0],[$.shape[0]-1,$.shape[1]])],0);const I=xi(gt(Ht(w,S),y)),R=ft(o,[c,0],[n-c,r]),_=Te(I,a),F=gv(a);if(c===0)o=ot(R,Ht(_,Ht(F,R)));else{const B=ot(R,Ht(_,Ht(F,R)));o=On([ft(o,[0,0],[c,r]),B],0)}const O=gv(_),M=ft(s,[0,c],[n,s.shape[1]-c]);if(c===0)s=ot(M,Ht(Ht(M,a),O));else{const B=ot(M,Ht(Ht(M,a),O));s=On([ft(s,[0,0],[n,c]),B],1)}return[a,o,s]}),Bt([d,f,p])}return!e&&n>r&&(s=ft(s,[0,0],[n,r]),o=ft(o,[0,0],[r,r])),[s,o]})}const Ine=X({qr_:Tne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Lr;(function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Lr||(Lr={}));function Nne(t,e,n=Lr.SUM_BY_NONZERO_WEIGHTS){const r=L(t,"losses","computeWeightedLoss");let s=null;e!=null&&(s=L(e,"weights","computeWeightedLoss"));const o=s==null?r:Te(r,s);if(n===Lr.NONE)return o;if(n===Lr.SUM)return en(o);if(n===Lr.MEAN){if(s==null)return Eg(o);{const i=r.size/s.size,a=gt(en(o),en(s));return i>1?gt(a,pt(i)):a}}if(n===Lr.SUM_BY_NONZERO_WEIGHTS){if(s==null)return gt(en(o),pt(r.size));{const i=Te(s,vu(r.shape)),a=Qt(en(bD(i,pt(0))),"float32");return gt(en(o),a)}}throw Error(`Unknown reduction: ${n}`)}const wa=X({computeWeightedLoss_:Nne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ene(t,e,n,r=Lr.SUM_BY_NONZERO_WEIGHTS){const s=L(t,"labels","absoluteDifference"),o=L(e,"predictions","absoluteDifference");let i=null;n!=null&&(i=L(n,"weights","absoluteDifference")),gs(s.shape,o.shape,"Error in absoluteDifference: ");const a=Ns(ot(s,o));return wa(a,i,r)}const Rne=X({absoluteDifference_:Ene});function _ne(t,e,n,r,s=Lr.SUM_BY_NONZERO_WEIGHTS){const o=L(t,"labels","cosineDistance"),i=L(e,"predictions","cosineDistance");let a=null;r!=null&&(a=L(r,"weights","cosineDistance")),gs(o.shape,i.shape,"Error in cosineDistance: ");const l=pt(1),c=ot(l,en(Te(o,i),n,!0));return wa(c,a,s)}const Pne=X({cosineDistance_:_ne});function Ane(t,e,n,r=Lr.SUM_BY_NONZERO_WEIGHTS){let s=L(t,"labels","hingeLoss");const o=L(e,"predictions","hingeLoss");let i=null;n!=null&&(i=L(n,"weights","hingeLoss")),gs(s.shape,o.shape,"Error in hingeLoss: ");const a=pt(1);s=ot(Te(pt(2),s),a);const l=py(ot(a,Te(s,o)));return wa(l,i,r)}const Dne=X({hingeLoss_:Ane});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fne(t,e,n,r=1,s=Lr.SUM_BY_NONZERO_WEIGHTS){const o=L(t,"labels","huberLoss"),i=L(e,"predictions","huberLoss");let a=null;n!=null&&(a=L(n,"weights","huberLoss")),gs(o.shape,i.shape,"Error in huberLoss: ");const l=pt(r),c=Ns(ot(i,o)),d=Sf(c,l),f=ot(c,d),p=Ue(Te(pt(.5),ao(d)),Te(l,f));return wa(p,a,s)}const One=X({huberLoss_:Fne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lne(t,e,n,r=1e-7,s=Lr.SUM_BY_NONZERO_WEIGHTS){const o=L(t,"labels","logLoss"),i=L(e,"predictions","logLoss");let a=null;n!=null&&(a=L(n,"weights","logLoss")),gs(o.shape,i.shape,"Error in logLoss: ");const l=pt(1),c=pt(r),d=xi(Te(o,wf(Ue(i,c)))),f=Te(ot(l,o),wf(Ue(ot(l,i),c))),p=ot(d,f);return wa(p,a,s)}const zne=X({logLoss_:Lne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bne(t,e,n,r=Lr.SUM_BY_NONZERO_WEIGHTS){const s=L(t,"labels","meanSquaredError"),o=L(e,"predictions","meanSquaredError");let i=null;n!=null&&(i=L(n,"weights","meanSquaredError")),gs(s.shape,o.shape,"Error in meanSquaredError: ");const a=ID(s,o);return wa(a,i,r)}const Mne=X({meanSquaredError_:Bne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vne(t,e){const n=L(t,"labels","sigmoidCrossEntropyWithLogits"),r=L(e,"logits","sigmoidCrossEntropyWithLogits");gs(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=py(r),o=Te(r,n),i=hD(fa(xi(Ns(r))));return Ue(ot(s,o),i)}function Wne(t,e,n,r=0,s=Lr.SUM_BY_NONZERO_WEIGHTS){let o=L(t,"multiClassLabels","sigmoidCrossEntropy");const i=L(e,"logits","sigmoidCrossEntropy");let a=null;if(n!=null&&(a=L(n,"weights","sigmoidCrossEntropy")),gs(o.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const c=pt(r),d=pt(1),f=pt(.5);o=Ue(Te(o,ot(d,c)),Te(f,c))}const l=Vne(o,i);return wa(l,a,s)}const Une=X({sigmoidCrossEntropy_:Wne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jne(t,e,n=-1){if(n===-1&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return pa((s,o,i)=>{const l=pD(o,[n],!0),c=ot(Qt(o,"float32"),l);i([s,c]);const d=xi(Te(c,s));return{value:en(d,[n]),gradFunc:(g,y)=>{const[x,w]=y,S=ys(g.shape,[n]);return[Te(xe(g,S),ot(Qt(x,"float32"),fa(w))),Te(xe(g,S),ot(fa(w),Qt(x,"float32")))]}}})(t,e)}function Gne(t,e,n,r=0,s=Lr.SUM_BY_NONZERO_WEIGHTS){let o=L(t,"onehotLabels","softmaxCrossEntropy");const i=L(e,"logits","softmaxCrossEntropy");let a=null;if(n!=null&&(a=L(n,"weights","softmaxCrossEntropy")),gs(o.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const c=pt(r),d=pt(1),f=pt(o.shape[1]);o=Ue(Te(o,ot(d,c)),gt(c,f))}const l=jne(o,i);return wa(l,a,s)}const Hne=X({softmaxCrossEntropy_:Gne});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kne(t,e,n,r){const s=L(t,"indices","sparseFillEmptyRows","int32"),o=L(e,"values","sparseFillEmptyRows"),i=L(n,"denseShape","sparseFillEmptyRows","int32"),a=L(r,"defaultValue","sparseFillEmptyRows",o.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(o.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const l={indices:s,values:o,denseShape:i,defaultValue:a},c=q.runKernel(cA,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const Xne=X({sparseFillEmptyRows_:Kne});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qne(t,e,n){const r=L(t,"inputIndices","sparseReshape","int32"),s=L(e,"inputShape","sparseReshape","int32"),o=L(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(o.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const i={inputIndices:r,inputShape:s,newShape:o},a=q.runKernel(dA,i);return{outputIndices:a[0],outputShape:a[1]}}const Yne=X({sparseReshape_:qne});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qne(t,e,n){const r=L(t,"data","sparseSegmentMean"),s=L(e,"indices","sparseSegmentMean","int32"),o=L(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${o.shape}`);const i={data:r,indices:s,segmentIds:o};return q.runKernel(xS,i)}const Zne=X({sparseSegmentMean_:Qne});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jne(t,e,n){const r=L(t,"data","sparseSegmentSum"),s=L(e,"indices","sparseSegmentSum","int32"),o=L(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${o.shape}`);const i={data:r,indices:s,segmentIds:o};return q.runKernel(vS,i)}const ere=X({sparseSegmentSum_:Jne});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tre(t,e,n,r,s,o,i,a){const l=L(t,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=L(e,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const d={separator:n,nGramWidths:r,leftPad:s,rightPad:o,padWidth:i,preserveShortSequences:a},f={data:l,dataSplits:c},p=q.runKernel(CS,f,d);return{nGrams:p[0],nGramsSplits:p[1]}}const nre=X({stringNGrams_:tre});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rre(t,e,n=!0){const r=L(t,"input","stringSplit","string"),s=L(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const o={skipEmpty:n},i={input:r,delimiter:s},a=q.runKernel(pA,i,o);return{indices:a[0],values:a[1],shape:a[2]}}const sre=X({stringSplit_:rre});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ore(t,e){const n=L(t,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return q.runKernel(mA,s,r)}const ire=X({stringToHashBucketFast_:ore});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function are(t,e,n,r=!0){const s=L(t,"input","staticRegexReplace","string"),o={pattern:e,rewrite:n,replaceGlobal:r};return q.runKernel(fA,{x:s},o)}const lre=X({staticRegexReplace_:are});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ure={fft:jS,ifft:Rg,rfft:GS,irfft:TD},cre={hammingWindow:Dte,hannWindow:DD,frame:FD,stft:zte},ku={flipLeftRight:Wte,grayscaleToRGB:jte,resizeNearestNeighbor:gne,resizeBilinear:pne,rgbToGrayscale:Hte,rotateWithOffset:Xte,cropAndResize:Mte,nonMaxSuppression:Yte,nonMaxSuppressionAsync:sne,nonMaxSuppressionWithScore:ine,nonMaxSuppressionWithScoreAsync:lne,nonMaxSuppressionPadded:cne,nonMaxSuppressionPaddedAsync:hne,threshold:vne,transform:wne},dre={bandPart:Cne,gramSchmidt:kne,qr:Ine},hre={absoluteDifference:Rne,computeWeightedLoss:wa,cosineDistance:Pne,hingeLoss:Dne,huberLoss:One,logLoss:zne,meanSquaredError:Mne,sigmoidCrossEntropy:Une,softmaxCrossEntropy:Hne},fre={sparseFillEmptyRows:Xne,sparseReshape:Yne,sparseSegmentMean:Zne,sparseSegmentSum:ere},pre={stringNGrams:nre,stringSplit:sre,stringToHashBucketFast:ire,staticRegexReplace:lre};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mre=new Map,gre=new Map;class yre{getClassName(){return this.constructor.className}static fromConfig(e,n){return new e(n)}}class du{constructor(){this.classNameMap={}}static getMap(){return du.instance==null&&(du.instance=new du),du.instance}static register(e){du.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function xre(t,e,n){z(t.className!=null,()=>"Class being registered does not have the static className property defined."),z(typeof t.className=="string",()=>"className is required to be a string, but got type "+typeof t.className),z(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof n>"u"&&(n=t.className);const r=n,s=e+">"+r;return du.register(t),mre.set(s,t),gre.set(t,s),t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mu extends yre{minimize(e,n=!1,r){const{value:s,grads:o}=this.computeGradients(e,r);if(r!=null){const i=r.map(a=>({name:a.name,tensor:o[a.name]}));this.applyGradients(i)}else this.applyGradients(o);return Bt(o),n?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,n){return nZ(e,n)}dispose(){this.iterations_!=null&&Bt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:pt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Mu,Symbol.hasInstance,{value:t=>t.minimize!=null&&t.computeGradients!=null&&t.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vre extends Mu{static get className(){return"Adadelta"}constructor(e,n,r=null){super(),this.learningRate=e,this.rho=n,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=q.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=q.registeredVariables[r],i=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:tt(()=>As(o).variable(i))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:tt(()=>As(o).variable(i))});const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const l=this.accumulatedGrads[s].variable,c=this.accumulatedUpdates[s].variable;tt(()=>{const d=Ue(Te(l,this.rho),Te(ao(a),1-this.rho)),f=Te(gt(ha(Ue(c,this.epsilon)),ha(Ue(l,this.epsilon))),a),p=Ue(Te(c,this.rho),Te(ao(f),1-this.rho));l.assign(d),c.assign(p);const g=Ue(Te(f,-this.learningRate),o);o.assign(g)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Bt(this.accumulatedGrads.map(e=>e.variable)),Bt(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=e.length/2,r=!1;this.accumulatedGrads=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.rho,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bre extends Mu{static get className(){return"Adagrad"}constructor(e,n=.1){super(),this.learningRate=e,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=q.registeredVariables[r];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:tt(()=>qf(o.shape,this.initialAccumulatorValue).variable(!1))});const i=Array.isArray(e)?e[s].tensor:e[r];if(i==null)return;const a=this.accumulatedGrads[s].variable;tt(()=>{const l=Ue(a,ao(i));a.assign(l);const c=Ue(Te(gt(i,ha(Ue(l,q.backend.epsilon()))),-this.learningRate),o);o.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Bt(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,n){return new e(n.learningRate,n.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wre extends Mu{static get className(){return"Adam"}constructor(e,n,r,s=null){super(),this.learningRate=e,this.beta1=n,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],tt(()=>{this.accBeta1=pt(n).variable(),this.accBeta2=pt(r).variable()}),s==null&&(this.epsilon=q.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);tt(()=>{const r=ot(1,this.accBeta1),s=ot(1,this.accBeta2);n.forEach((o,i)=>{const a=q.registeredVariables[o],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:tt(()=>As(a).variable(l))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${o}/v`,variable:tt(()=>As(a).variable(l))});const c=Array.isArray(e)?e[i].tensor:e[o];if(c==null)return;const d=this.accumulatedFirstMoment[i].variable,f=this.accumulatedSecondMoment[i].variable,p=Ue(Te(d,this.beta1),Te(c,1-this.beta1)),g=Ue(Te(f,this.beta2),Te(ao(c),1-this.beta2)),y=gt(p,r),x=gt(g,s);d.assign(p),f.assign(g);const w=Ue(Te(gt(y,Ue(ha(x),this.epsilon)),-this.learningRate),a);a.assign(w)}),this.accBeta1.assign(Te(this.accBeta1,this.beta1)),this.accBeta2.assign(Te(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Bt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Bt(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e),tt(()=>{this.accBeta1.assign(bf(this.beta1,this.iterations_+1)),this.accBeta2.assign(bf(this.beta2,this.iterations_+1))});const n=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sre extends Mu{static get className(){return"Adamax"}constructor(e,n,r,s=null,o=0){super(),this.learningRate=e,this.beta1=n,this.beta2=r,this.epsilon=s,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],tt(()=>{this.iteration=pt(0).variable(),this.accBeta1=pt(n).variable()}),s==null&&(this.epsilon=q.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);tt(()=>{const r=ot(1,this.accBeta1),s=gt(-this.learningRate,Ue(Te(this.iteration,this.decay),1));n.forEach((o,i)=>{const a=q.registeredVariables[o],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:As(a).variable(l)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${o}/v`,variable:As(a).variable(l)});const c=Array.isArray(e)?e[i].tensor:e[o];if(c==null)return;const d=this.accumulatedFirstMoment[i].variable,f=this.accumulatedWeightedInfNorm[i].variable,p=Ue(Te(d,this.beta1),Te(c,1-this.beta1)),g=Te(f,this.beta2),y=Ns(c),x=xD(g,y);d.assign(p),f.assign(x);const w=Ue(Te(gt(s,r),gt(p,Ue(x,this.epsilon))),a);a.assign(w)}),this.iteration.assign(Ue(this.iteration,1)),this.accBeta1.assign(Te(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Bt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Bt(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LD extends Mu{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=Array.isArray(e)?e[s].tensor:e[r];if(o==null)return;const i=q.registeredVariables[r];tt(()=>{const a=Ue(Te(this.c,o),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=ci(pt(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,n){return new e(n.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cre extends LD{static get className(){return"Momentum"}constructor(e,n,r=!1){super(e),this.learningRate=e,this.momentum=n,this.useNesterov=r,this.accumulations=[],this.m=pt(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=q.registeredVariables[r];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:tt(()=>As(o).variable(!1))});const i=this.accumulations[s].variable,a=Array.isArray(e)?e[s].tensor:e[r];a!=null&&tt(()=>{let l;const c=Ue(Te(this.m,i),a);this.useNesterov?l=Ue(Te(this.c,Ue(a,Te(c,this.m))),o):l=Ue(Te(this.c,c),o),i.assign(c),o.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Bt(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,n){return new e(n.learningRate,n.momentum,n.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $re extends Mu{static get className(){return"RMSProp"}constructor(e,n=.9,r=0,s=null,o=!1){if(super(),this.learningRate=e,this.decay=n,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,s==null&&(this.epsilon=q.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=q.registeredVariables[r],i=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:tt(()=>As(o).variable(i))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:tt(()=>As(o).variable(i))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:tt(()=>As(o).variable(i))});const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const l=this.accumulatedMeanSquares[s].variable,c=this.accumulatedMoments[s].variable;tt(()=>{const d=Ue(Te(l,this.decay),Te(ao(a),1-this.decay));if(this.centered){const f=this.accumulatedMeanGrads[s].variable,p=Ue(Te(f,this.decay),Te(a,1-this.decay)),g=gt(Te(a,this.learningRate),ha(ot(d,Ue(ao(p),this.epsilon)))),y=Ue(Te(c,this.momentum),g);l.assign(d),f.assign(p),c.assign(y);const x=ot(o,y);o.assign(x)}else{const f=Ue(Te(l,this.decay),Te(ao(a),1-this.decay)),p=Ue(Te(c,this.momentum),gt(Te(a,this.learningRate),ha(Ue(f,this.epsilon))));l.assign(f),c.assign(p);const g=ot(o,p);o.assign(g)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Bt(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Bt(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Bt(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(n*2,n*3).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,n){return new e(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kre=[vre,bre,wre,Sre,Cre,$re,LD];function Tre(){for(const t of kre)xre(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ire="model",Nre=".json",Ere=".weights.bin";function PN(t){return new Promise(e=>setTimeout(e)).then(t)}class Fu{constructor(e){if(!oe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Fu.URL_SCHEME)&&(e=e.slice(Fu.URL_SCHEME.length)),(e==null||e.length===0)&&(e=Ire),this.modelJsonFileName=e+Nre,this.weightDataFileName=e+Ere}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=zo.join(e.weightData),r=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],o=BA(e,s),i=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=i,await PN(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=r,await PN(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Kf(e)}}}}Fu.URL_SCHEME="downloads://";class Rre{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,n)=>{const r=new FileReader;r.onload=s=>{const o=JSON.parse(s.target.result),i=o.modelTopology;if(i==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(o.weightsManifest==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:i});return}const l=FS(o,c=>this.loadWeights(c));e(l)},r.onerror=s=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(e){const n=[],r=[];for(const i of e)n.push(...i.weights),r.push(...i.paths);const s=this.checkManifestAndWeightFiles(e),o=r.map(i=>this.loadWeightsFile(i,s[i]));return Promise.all(o).then(i=>[n,i])}loadWeightsFile(e,n){return new Promise((r,s)=>{const o=new FileReader;o.onload=i=>{const a=i.target.result;r(a)},o.onerror=i=>s(`Failed to weights data from file of path '${e}'.`),o.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(e){const n=[],r=this.weightsFiles.map(o=>wN(o.name)),s={};for(const o of e)o.paths.forEach(i=>{const a=wN(i);if(n.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(n.push(a),r.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);s[i]=this.weightsFiles[r.indexOf(a)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}const _re=t=>oe().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Fu.URL_SCHEME)?Pre(t.slice(Fu.URL_SCHEME.length)):null;un.registerSaveRouter(_re);function Pre(t="model"){return new Fu(t)}function Are(t){return new Rre(t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AN(t,e,n,r){i(t),n=n??0,r=r??1,a(n,r);let s=0;const o=l=>(l.then(c=>{const d=n+ ++s/t.length*(r-n);return e(d),c}),l);function i(l){z(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,c){z(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),z(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),z(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(t.map(o))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function zD(t,e){e==null&&(e={});const n=e.fetchFunc==null?oe().platform.fetch:e.fetchFunc,r=t.map(f=>n(f,e.requestInit,{isBinary:!0})),a=(e.onProgress==null?await Promise.all(r):await AN(r,e.onProgress,0,.5)).map(f=>f.arrayBuffer());return e.onProgress==null?await Promise.all(a):await AN(a,e.onProgress,.5,1)}function Dre(t,e){var n;const r=e.fetchFunc==null?oe().platform.fetch:e.fetchFunc;let s=0,o;return(n=e.onProgress)===null||n===void 0||n.call(e,0),new ReadableStream({pull:async i=>{for(var a;s<t.length;){o||(o=(await r(t[s],e.requestInit,{isBinary:!0})).body.getReader());const{done:l,value:c}=await o.read();if(l){s++,o=void 0,(a=e.onProgress)===null||a===void 0||a.call(e,s/t.length);continue}i.enqueue(c);return}i.close()}})}async function Fre(t,e="",n,r){return BD(i=>zD(i,{requestInit:r}))(t,e,n)}function BD(t){return async(e,n="",r)=>{const s=e.map(()=>!1),o={},i=r!=null?r.map(()=>!1):[],a=[];if(e.forEach((g,y)=>{let x=0;g.weights.forEach(w=>{const S="quantization"in w?w.quantization.dtype:w.dtype,$=Ru[S]*fe(w.shape),I=()=>{s[y]=!0,o[y]==null&&(o[y]=[]),o[y].push({manifestEntry:w,groupOffset:x,sizeBytes:$})};r!=null?r.forEach((R,_)=>{R===w.name&&(I(),i[_]=!0)}):I(),a.push(w.name),x+=$})}),!i.every(g=>g)){const g=r.filter((y,x)=>!i[x]);throw new Error(`Could not find weights in manifest with names: ${g.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const l=s.reduce((g,y,x)=>(y&&g.push(x),g),[]),c=[];l.forEach(g=>{e[g].paths.forEach(y=>{const x=n+(n.endsWith("/")?"":"/")+y;c.push(x)})});const d=await t(c),f={};let p=0;return l.forEach(g=>{const y=e[g].paths.length,x=new zo(d.slice(p,p+y));o[g].forEach(S=>{const $=x.slice(S.groupOffset,S.groupOffset+S.sizeBytes),I=OA($,[S.manifestEntry]);for(const R in I)f[R]=I[R]}),p+=y}),f}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ore="application/octet-stream",Lre="application/json";class QS{constructor(e,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(z(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=oe().platform.fetch,z(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&z(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{},this.loadOptions=n}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=BA(e,r);if(n.body.append("model.json",new Blob([JSON.stringify(s)],{type:Lre}),"model.json"),e.weightData!=null){const i=zo.join(e.weightData);n.body.append("model.weights.bin",new Blob([i],{type:Ore}),"model.weights.bin")}const o=await this.fetch(this.path,n);if(o.ok)return{modelArtifactsInfo:Kf(e),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await e.json()}catch{let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}const r=n.modelTopology,s=n.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return n}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return FS(e,n=>this.loadWeights(n))}async loadStream(){const e=await this.loadModelJSON(),n=await this.getWeightUrls(e.weightsManifest),r=lv(e.weightsManifest),s=()=>Dre(n,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:r,getWeightStream:s})}async getWeightUrls(e){const n=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=zre(n),o=this.weightPathPrefix||r,i=[],a=[];for(const l of e)for(const c of l.paths)this.weightUrlConverter!=null?a.push(this.weightUrlConverter(c)):i.push(o+c+s);return this.weightUrlConverter&&i.push(...await Promise.all(a)),i}async loadWeights(e){const n=await this.getWeightUrls(e),r=lv(e),s=await zD(n,this.loadOptions);return[r,s]}}QS.URL_SCHEME_REGEX=/^https?:\/\//;function zre(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),s=n>e?t.substring(n):"";return[r+"/",s]}function yv(t){return t.match(QS.URL_SCHEME_REGEX)!=null}const MD=(t,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let n=!0;if(Array.isArray(t)?n=t.every(r=>yv(r)):n=yv(t),n)return ZS(t,e)}return null};un.registerSaveRouter(MD);un.registerLoadRouter(MD);function ZS(t,e){return new QS(t,e)}function Bre(t,e){return ZS(t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class q1{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class VD{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class Mre{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=n=>Promise.resolve(e.save(n)))}}function Vre(t,e,n,r){const s=arguments;return new Mre(WD(...s))}function WD(t,e,n,r){return arguments.length===1?t.modelTopology!=null||t.weightSpecs!=null?new q1(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new q1({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new q1({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:r}))}function Wre(t){return new VD(t)}function Ure(t){return new VD(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UD=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:zo,browserFiles:Are,browserHTTPRequest:Bre,concatenateArrayBuffers:UX,copyModel:dq,decodeWeights:OA,decodeWeightsStream:zA,encodeWeights:LX,fromMemory:Vre,fromMemorySync:WD,getLoadHandlers:QX,getModelArtifactsForJSON:FS,getModelArtifactsForJSONSync:MA,getModelArtifactsInfoForJSON:Kf,getSaveHandlers:YX,getWeightSpecs:lv,http:ZS,isHTTPScheme:yv,listModels:uq,loadWeights:Fre,moveModel:hq,registerLoadRouter:qX,registerSaveRouter:XX,removeModel:cq,weightsLoaderFactory:BD,withSaveHandler:Wre,withSaveHandlerSync:Ure},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ru,DN=!1;function jre(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(t==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,o=!1,i=!1,a=!1;if(t.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&t instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)o=!0;else if(t.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&t instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);if(kg(bg,q.backendName)!=null){const y={pixels:t},x={numChannels:e};return q.runKernel(bg,y,x)}const[c,d]=s?[t.videoWidth,t.videoHeight]:[t.width,t.height];let f;if(i)f=t.getContext("2d").getImageData(0,0,c,d).data;else if(r||n)f=t.data;else if(o||s||a){if(ru==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")ru=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else ru=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});ru.canvas.width=c,ru.canvas.height=d,ru.drawImage(t,0,0,c,d),f=ru.getImageData(0,0,c,d).data}let p;if(e===4)p=new Int32Array(f);else{const y=c*d;p=new Int32Array(y*e);for(let x=0;x<y;x++)for(let w=0;w<e;++w)p[x*e+w]=f[x*4+w]}return ED(p,[d,c,e],"int32")}function Gre(t){if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);const e=t.rank===2?1:t.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`)}async function JS(t,e){let n=L(t,"img","toPixels");if(!(t instanceof hn)){const c=n;n=Qt(c,"int32"),c.dispose()}Gre(n);const[r,s]=n.shape.slice(0,2),o=n.rank===2?1:n.shape[2],i=await n.data(),a=n.dtype==="float32"?255:1,l=new Uint8ClampedArray(s*r*4);for(let c=0;c<r*s;++c){const d=[0,0,0,255];for(let p=0;p<o;p++){const g=i[c*o+p];if(n.dtype==="float32"){if(g<0||g>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${g}.`)}else if(n.dtype==="int32"&&(g<0||g>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${g}.`);o===1?(d[0]=g*a,d[1]=g*a,d[2]=g*a):d[p]=g*a}const f=c*4;l[f+0]=Math.round(d[0]),l[f+1]=Math.round(d[1]),l[f+2]=Math.round(d[2]),l[f+3]=Math.round(d[3])}if(e!=null){DN||kg(JP,q.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),DN=!0),e.width=s,e.height=r;const c=e.getContext("2d"),d=new ImageData(l,s,r);c.putImageData(d,0,0)}return n!==t&&n.dispose(),l}const jD=X({fromPixels_:jre});function eC(t,e){const n=t.shape.length,r=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${n}`);if(fe(t.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const s=e.shape,o=s[s.length-1];let i=1;for(let f=0;f<s.length-1;++f)i*=s[f];const a=t.shape,l=s.slice();l.pop();let c=1;for(let f=o;f<n;++f)c*=a[f],l.push(a[f]);const d=[...mn(t.shape).map(f=>f/c),1].slice(0,o);return[l,i,c,d]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xv=-2,Hre=-1;function tC(t,e,n){const r=t.shape.length;z(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),z(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)z(e[s]+n[s]<=t.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${e[s]+n[s]}) would overflow input.shape[${s}] (${t.shape[s]})`)}function Kre(t){const e=[];let n=0;for(;t>0;)t&1&&e.push(n),t/=2,n++;return e}function nC(t,e,n){const r=[];for(let s=0;s<t.length;s++)r[s]=Math.ceil((e[s]-t[s])/n[s]);return r}function GD(t,e,n,r){const s=[...t];for(let o=s.length;o<r.length;o++)s.push(1);for(let o=0;o<n;o++)o===0?s[e]=1:(s.splice(e,0,1),s.pop());return s}function HD(t,e,n){return n<=t?n:n-(e-1)}function KD(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function Xre(t,e,n,r,s,o,i,a,l){const c=t.length;let d=new Array(c),f=new Array(c),p=new Array(c);if(e.length&&n>0){const g=e[0],y=n+1;d=XD(i,g,y,r,t),f=qD(a,g,y,s,t),p=GD(o,g,y,t)}else for(let g=0;g<c;g++)d[g]=QD(i,r,o,t,g,l),f[g]=ZD(a,s,o,t,g,l),p[g]=YD(o,g,l);return{begin:d,end:f,strides:p}}function XD(t,e,n,r,s){const o=[...s],i=KD(n,e);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=0;else{const l=HD(e,n,a);let c=r[l];t&1<<l&&(c=0),o[a]=c}return o}function qD(t,e,n,r,s){const o=[...s],i=KD(n,e);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=Number.MAX_SAFE_INTEGER;else{const l=HD(e,n,a);let c=r[l];t&1<<l&&(c=Number.MAX_SAFE_INTEGER),o[a]=c}for(let a=0;a<o.length;a++){const l=s[a];o[a]<0&&(o[a]+=l),o[a]=xg(0,o[a],s[a])}return o}function YD(t,e,n){let r=t[e];return(n&1<<e||r==null)&&(r=1),r}function QD(t,e,n,r,s,o){let i=e[s];const a=n[s]||1;(t&1<<s||o&1<<s||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=xg(0,i,l-1),i}function ZD(t,e,n,r,s,o){let i=e[s];const a=n[s]||1;(t&1<<s||o&1<<s||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),a>0?i=xg(0,i,l):i=xg(-1,i,l-1),i}function rC(t,e,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(e[s]>0||n[s]!==t[s])return!1;return!0}function sC(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function oC(t,e,n){let r;const s=t.shape.length;typeof e=="number"?r=[e,...new Array(s-1).fill(0)]:e.length<s?r=e.concat(new Array(s-e.length).fill(0)):r=e.slice(),r.forEach(i=>{z(i!==-1,()=>"slice() does not support negative begin indexing.")});let o;return n==null?o=new Array(s).fill(-1):typeof n=="number"?o=[n,...new Array(s-1).fill(-1)]:n.length<s?o=n.concat(new Array(s-n.length).fill(-1)):o=n,o=o.map((i,a)=>i>=0?i:(z(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),t.shape[a]-r[a])),[r,o]}function iC(t,e,n,r,s,o,i,a,l){let c;if(r==null?(c=new Array(e.length),c.fill(1)):c=r,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let d=!1;const f={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:c.slice(),beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};for(let I=0;I<f.dims;I++)d&&(1<<I&a)!==0&&f.numAddAxisAfterEllipsis++,1<<I&i&&(d=!0);d||(f.ellipsisMask|=1<<f.dims,f.dims++);const p={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};qre(f,p);let g=!0,y=!0,x=!0;const w=[],S=[];for(let I=0;I<t.length;++I){if(p.strides[I]===0)throw Error(`strides[${I}] must be non-zero`);const R=!!(p.shrinkAxisMask&1<<I),_=t[I];if(_===-1){w.push(R?1:-1);continue}const F=[p.beginMask&1<<I,p.endMask&1<<I],O=[p.strides[I]>0?0:-1,p.strides[I]>0?_:_-1];if(R&&p.strides[I]<=0)throw Error("only stride 1 allowed on non-range indexing.");x=x&&p.strides[I]===1;const M=!!(p.beginMask&1<<I&&p.endMask&1<<I);if(p.beginValid&&p.endValid){if(R){const re=p.begin[I]<0?_+p.begin[I]:p.begin[I];if(p.begin[I]=re,p.end[I]=p.begin[I]+1,re<0||re>=_)throw Error(`slice index ${p.begin[I]} of dimension ${I} out of bounds.`)}else p.begin[I]=FN(p.begin[I],0,p.strides[I],_,F,O),p.end[I]=FN(p.end[I],1,p.strides[I],_,F,O);const A=p.strides[I]===1&&p.begin[I]===0&&p.end[I]===_;g=g&&A,y=y&&(I===0&&p.strides[I]===1||A)}else g=g&&p.strides[I]===1&&M,y=y&&(I===0&&p.strides[I]===1||M);let B,V=!1;if(p.beginValid&&p.endValid?(B=p.end[I]-p.begin[I],V=!0):R?(B=1,V=!0):M&&_>=0&&(p.strides[I]<0?B=-_:B=_,V=!0),V){let A;B===0||B<0!=p.strides[I]<0?A=0:A=Math.trunc(B/p.strides[I])+(B%p.strides[I]!==0?1:0),w.push(A)}else w.push(-1)}for(let I=0;I<p.finalShapeGatherIndices.length;++I){const R=p.finalShapeGatherIndices[I];R>=0?S.push(w[R]):R===xv&&S.push(1)}return{finalShapeSparse:S.filter((I,R)=>p.finalShapeGatherIndices[R]!==xv),finalShape:S,isIdentity:g,sliceDim0:y,isSimpleSlice:x,begin:p.begin,end:p.end,strides:p.strides}}function qre(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=t.begin!=null,e.endValid=t.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){const s=Math.min(e.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<s;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&t.newAxisMask)e.finalShapeGatherIndices.push(xv),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);t.begin!=null&&(e.begin[n]=t.begin[r]),t.end!=null&&(e.end[n]=t.end[r]),e.strides[n]=t.strides[r],t.beginMask&1<<r&&(e.beginMask|=1<<n),t.endMask&1<<r&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(Hre),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[n]=r,n++}}function FN(t,e,n,r,s,o){if(s[e])return n>0?o[e]:o[e+1&1];{const i=t<0?r+t:t;return i<o[0]?o[0]:i>o[1]?o[1]:i}}const Yre=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:tC,computeFlatOffset:sC,computeOutShape:nC,getNormalizedAxes:Xre,isSliceContinous:rC,maskToAxes:Kre,parseSliceParams:oC,sliceInfo:iC,startForAxis:QD,startIndicesWithElidedDims:XD,stopForAxis:ZD,stopIndicesWithElidedDims:qD,stridesForAxis:YD,stridesWithElidedDims:GD},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qre=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t();function Zre(){return new Promise(t=>Qre(()=>t()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aC(t,e){const n=t[0].length;t.forEach((s,o)=>{z(s.length===n,()=>`Error in concat${n}D: rank of tensors[${o}] must be the same as the rank of the rest (${n})`)}),z(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=t[0];t.forEach((s,o)=>{for(let i=0;i<n;i++)z(i===e||s[i]===r[i],()=>`Error in concat${n}D: Shape of tensors[${o}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`)})}function co(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Do;(function(t){t[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS"})(Do||(Do={}));function JD(t,e,n){let r=new Array;if(n==null&&e==null)return r;if(e==null)for(;r.length<t+n.length;)r.push(-1);else r=e.slice();if(n==null)return r;if(t+n.length!==r.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${t+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){const o=n[s],i=r[r.length-n.length+s],a=r[i];if(o>=0)if(a>=0){if(a!==o)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${s+t}] = ${o} but shape[${s+t}] = ${a}`)}else r[i]=o}return r}function eF(t){const e={FIRST_DIM_SIZE:Do.FIRST_DIM_SIZE,VALUE_ROWIDS:Do.VALUE_ROWIDS,ROW_LENGTHS:Do.ROW_LENGTHS,ROW_SPLITS:Do.ROW_SPLITS,ROW_LIMITS:Do.ROW_LIMITS,ROW_STARTS:Do.ROW_STARTS},n=[];for(const r of t)if(r in e)n.push(e[r]);else break;return n}function tF(t){return t.length===0?0:t[0]===Do.FIRST_DIM_SIZE?t.length-1:t.length}function nF(t,e){if(t==null||e==null)return;const n=t.length,r=e.length;if(n>=r)throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){const o=t[s],i=e[s+1];if(o>=0&&i>=0&&o!==1&&o!==i)throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${s-t.length}] = ${o} but ragged tensor input.flatValues.shape[${s-t.length}] = ${i}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lC=30;function vy(t){return t<=lC?t:ev(t,Math.floor(Math.sqrt(t)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uC(t,e,n){const r=n*(typeof t=="number"?t:t[0]),s=e*(typeof t=="number"?t:t[1]);return[r,s]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qf(t,e,n,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(t[0]/n),s=s.concat(t.slice(1));else{s=s.concat(t[0]);const o=e.length;for(let i=0;i<o;++i)s=s.concat([t[i+1]/e[i],e[i]]);s=s.concat(t.slice(o+1))}return s}function Zf(t,e,n=!0){const r=[];if(n){r.push(e);for(let s=e+1;s<t;++s)s<=2*e?(r.push(s),r.push(s-(e+1))):r.push(s)}else{const s=[],o=[];for(let i=1;i<t;++i)i>=e*2+1||i%2===1?o.push(i):s.push(i);r.push(...s),r.push(0),r.push(...o)}return r}function Jf(t,e,n,r=!0){const s=[];r?s.push(t[0]/n):s.push(t[0]*n);for(let o=1;o<t.length;++o)o<=e.length?r?s.push(e[o-1]*t[o]):s.push(t[o]/e[o-1]):s.push(t[o]);return s}function cC(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function dC(t,e,n){const r=t.slice(0,1);for(let s=0;s<n;++s)r.push(t[s+1]-e[s][0]-e[s][1]);return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hC=1.7580993408473768,fC=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pC=.3275911,mC=.254829592,gC=-.284496736,yC=1.421413741,xC=-1.453152027,vC=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tf(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(t.length*2);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function Jre(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function ese(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=0;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function tse(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=2;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function nse(t,e){const n=t[e*2],r=t[e*2+1];return{real:n,imag:r}}function rse(t,e,n,r){t[r*2]=e,t[r*2+1]=n}function sse(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let s=0;s<Math.ceil(t/2);s++){const o=(e?2:-2)*Math.PI*(s/t);n[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:n,imag:r}}function ose(t,e,n){const r=(n?2:-2)*Math.PI*(t/e),s=Math.cos(r),o=Math.sin(r);return{real:s,imag:o}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y1="->",ise=/->/g,ON=",",LN="...";function bC(t,e){t=t.replace(/\s/g,"");const n=(t.length-t.replace(ise,"").length)/Y1.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Y1}").`);const[r,s]=t.split(Y1);z(r.indexOf(LN)===-1,()=>`The ellipsis notation ("${LN}") is not supported yet.`);const o=r.split(ON),i=o.length;if(e!==i)throw new Error(`Expected ${i} input tensors, received ${e}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let p=0;p<s.length;++p){const g=s[p];if(!o.some(y=>y.indexOf(g)!==-1))throw new Error(`Output subscripts contain the label ${g} not present in the input subscripts.`);a.indexOf(g)===-1&&a.push(g)}for(let p=0;p<r.length;++p){const g=r[p];a.indexOf(g)===-1&&g!==ON&&a.push(g)}const l=new Array(o.length);for(let p=0;p<i;++p){if(new Set(o[p].split("")).size!==o[p].length)throw new Error(`Found duplicate axes in input component ${o[p]}. Support for duplicate axes in input is not implemented yet.`);l[p]=[];for(let g=0;g<o[p].length;++g)l[p].push(a.indexOf(o[p][g]))}const c=a.length,d=s.length,f=[];for(let p=d;p<c;++p)f.push(p);return{allDims:a,summedDims:f,idDims:l}}function wC(t,e){let n=new Array(t);n.fill(-1);for(let s=0;s<e.length;++s)n[e[s]]=s;const r=[];for(let s=0;s<t;++s)n[s]===-1&&r.push(s);return n=n.filter(s=>s!==-1),{permutationIndices:n,expandDims:r}}function SC(t,e,n){const r=new Array(t);for(let s=0;s<n.length;++s){const o=n[s].shape;for(let i=0;i<e[s].length;++i)r[e[s][i]]===void 0?r[e[s][i]]=o[i]:z(r[e[s][i]]===o[i],()=>`Expected dimension ${r[e[s][i]]} at axis ${i} of input shaped ${JSON.stringify(o)}, but got dimension ${o[i]}`)}}function CC(t,e){const n=t,r=[];let s=0;t.length===0&&n.push(-1),s=t.length+1;for(let i=0;i<s;++i)r.push([]);const o=[];for(let i=0;i<n.length;++i){const a=n[i],l=ase(e,a);for(const c of l)o.indexOf(c)===-1&&(r[i].push(c),o.push(c))}return{path:n,steps:r}}function $C(t){return t.every((e,n)=>e===n)}function ase(t,e){const n=[];for(let r=0;r<t.length;++r)(t[r].length===0||t[r].indexOf(e)!==-1||e===-1)&&n.push(r);return n}function kC(t,e,n=0){let r=[];if(typeof e=="number")z(t.shape[n]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(t.shape[n]/e);else{const s=e.reduce((i,a)=>(a===-1&&(i+=1),i),0);z(s<=1,()=>"There should be only one negative value in split array.");const o=e.indexOf(-1);if(o!==-1){const i=e.reduce((a,l)=>l>0?a+l:a);e[o]=t.shape[n]-i}z(t.shape[n]===e.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rF(t){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${t}`}function sF(t,e){return`indices(${t}, 0) is invalid: ${e} < 0`}function oF(t,e,n){return`indices(${t}, 0) is invalid: ${e} >= ${n}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iF(t,e){return`only one output dimension may be -1, not both ${t} and ${e}`}function aF(t,e){return`size ${t} must be non-negative, not ${e}`}function lF(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function uF(t,e){const n=fe(t),r=fe(e);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${t} outputShape= ${e}`}function cF(t,e){const n=fe(t),r=fe(e);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${t} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vv(){return"segment ids must be >= 0"}function dF(){return"segment ids are not increasing"}function hF(t,e){return`Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function fF(t,e,n){return`Bad: indices[${t}] == ${e} out of range [0, ${n})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pF(t,e){let n=!1,r;for(t<=lC?(r=t,n=!0):r=ev(t,Math.floor(Math.sqrt(t)));!n;)r>e||r===t?n=!0:r=ev(t,r+1);return r}function TC(t,e,n){const r=[],s=t.length;for(let o=0;o<s;o++)o!==e?r.push(t[o]):r.push(n);return r}function IC(t,e,n,r){const s=e.shape.length,o=t.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${o}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let f=0;f<r;++f)if(t.shape[f]!==e.shape[f])throw new Error(`x.shape[${f}]: ${t.shape[f]} should be equal to indices.shape[${f}]: ${e.shape[f]}.`);const i=t.shape[n],a=[];let l=1,c=1,d=1;for(let f=0;f<r;++f)a.push(t.shape[f]),l*=t.shape[f];for(let f=r;f<n;f++)a.push(t.shape[f]),c*=t.shape[f];for(let f=r;f<s;f++)a.push(e.shape[f]);for(let f=n+1;f<o;f++)a.push(t.shape[f]),d*=t.shape[f];return{batchSize:l,sliceSize:d,outerSize:c,dimSize:i,outputShape:a}}const lse=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:IC,computeOutShape:TC,segOpComputeOptimalWindowSize:pF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xl(t){try{return t.map(e=>ca(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function mF(t){return t.map(e=>cl(e))}const use=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:mC,ERF_A2:gC,ERF_A3:yC,ERF_A4:xC,ERF_A5:vC,ERF_P:pC,PARALLELIZE_THRESHOLD:lC,get RowPartitionType(){return Do},SELU_SCALE:fC,SELU_SCALEALPHA:hC,applyActivation:yy,assertAndGetBroadcastShape:ct,assertAxesAreInnerMostDims:xs,assertParamsConsistent:aC,assignToTypedArray:rse,axesAreInnerMostDims:zS,calculateShapes:zu,checkEinsumDimSizes:SC,checkPadOnDimRoundingMode:fo,combineLocations:oD,combineRaggedTensorToTensorShapes:JD,complexWithEvenIndex:ese,complexWithOddIndex:tse,computeConv2DInfo:kn,computeConv3DInfo:$l,computeDefaultPad:OS,computeDilation2DInfo:Xf,computeOptimalWindowSize:vy,computeOutAndReduceShapes:Fs,computeOutShape:co,computePool2DInfo:ho,computePool3DInfo:ba,convertConv2DDataFormat:Bo,decodeEinsumEquation:bC,eitherStridesOrDilationsAreOne:Er,expandShapeToKeepDim:ys,exponent:ose,exponents:sse,fromStringArrayToUint8:mF,fromUint8ToStringArray:xl,getAxesPermutation:ur,getBroadcastDims:cd,getComplexWithIndex:nse,getEinsumComputePath:CC,getEinsumPermutation:wC,getFusedBiasGradient:gy,getFusedDyActivation:my,getImageCenter:uC,getInnerMostAxes:cr,getPermuted:Zf,getRaggedRank:tF,getReductionAxes:nD,getReshaped:Qf,getReshapedPermuted:Jf,getRowPartitionTypesHelper:eF,getSliceBeginCoords:cC,getSliceSize:dC,getSparseFillEmptyRowsIndicesDenseShapeMismatch:rF,getSparseFillEmptyRowsNegativeIndexErrorMessage:sF,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:oF,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:lF,getSparseReshapeInputOutputMismatchErrorMessage:cF,getSparseReshapeInputOutputMultipleErrorMessage:uF,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:iF,getSparseReshapeNegativeOutputDimErrorMessage:aF,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:fF,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:vv,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:dF,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:hF,getUndoAxesPermutation:Yf,isIdentityPermutation:$C,log:lX,mergeRealAndImagArrays:Tf,prepareAndValidate:eC,prepareSplitSize:kC,segment_util:lse,shouldFuse:xy,slice_util:Yre,splitRealAndImagArrays:Jre,stridesOrDilationsArePositive:Au,tupleValuesAreOne:vf,upcastType:Ur,validateDefaultValueShape:nF,validateInput:HS,validateUpdateShape:RD,warn:Oo},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Tre();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hu={},wm={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function cse(t,e){hu[t]=e}function Lo(t,e){if(!(t in hu)||e!=null){const r=hse(t,e);if(r!==null)hu[t]=r;else return console.log("Could not get context for WebGL version",t),null}const n=hu[t];return n==null||n.isContextLost()?(delete hu[t],Lo(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),hu[t])}function dse(t){if(!oe().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&t===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function hse(t,e){if(t!==1&&t!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=e??dse(t);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete hu[t]},!1),oe().getBool("SOFTWARE_WEBGL_ENABLED")&&(wm.failIfMajorPerformanceCaveat=!1),t===1?n.getContext("webgl",wm)||n.getContext("experimental-webgl",wm):n.getContext("webgl2",wm)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var If;(function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"})(If||(If={}));var Rs;(function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"})(Rs||(Rs={}));var qn;(function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(qn||(qn={}));function ep(t,e){return[e,t]}function fse(t,e){return t*e}function Sm(t){const e=fe(t),n=Math.ceil(e/4);return Zx(n)}function Id(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function pse(t,e){const[n,r]=Id(t,e);return n*r*4}function NC(t,e){const n=t;let r,s,o,i,a,l,c,d,f,p;return oe().getNumber("WEBGL_VERSION")===2?(r=n.R32F,s=n.R16F,o=n.RGBA16F,i=n.RGBA32F,a=n.RED,c=4,d=1,f=n.HALF_FLOAT,p=n.FLOAT,l=n.RGBA8):(r=t.RGBA,s=t.RGBA,o=t.RGBA,i=n.RGBA,a=t.RGBA,c=4,d=4,f=e!=null?e.HALF_FLOAT_OES:null,p=t.FLOAT,l=t.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:d,textureTypeHalfFloat:f,textureTypeFloat:p}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fe(t,e){const n=e();return oe().getBool("DEBUG")&&mse(t),n}function mse(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+vse(t,e))}const gse=596e-10,yse=65504;function xse(t){return!!(oe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||t===0||gse<Math.abs(t)&&Math.abs(t)<yse)}function vse(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Cm(t,e){return Sa(t,()=>t.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function bse(t,e){const n=Sa(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Fe(t,()=>t.shaderSource(n,e)),Fe(t,()=>t.compileShader(n)),t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function wse(t,e){const n=Sa(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Fe(t,()=>t.shaderSource(n,e)),Fe(t,()=>t.compileShader(n)),oe().get("ENGINE_COMPILE_ONLY"))return n;if(t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw gF(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const Sse=/ERROR: [0-9]+:([0-9]+):/g;function gF(t,e){const n=Sse.exec(e);if(n==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(t);return}const r=+n[1],s=t.split(`
`),o=s.length.toString().length+2,i=s.map((f,p)=>Yc((p+1).toString(),o)+f);let a=0;for(let f=0;f<i.length;f++)a=Math.max(i[f].length,a);const l=i.slice(0,r-1),c=i.slice(r-1,r),d=i.slice(r);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Yc(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join(`
`))}function Cse(t){return Sa(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}function $se(t,e){if(Fe(t,()=>t.linkProgram(e)),!oe().get("ENGINE_COMPILE_ONLY")&&t.getProgramParameter(e,t.LINK_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function Q1(t,e){if(Fe(t,()=>t.validateProgram(e)),t.getProgramParameter(e,t.VALIDATE_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function kse(t,e){const n=Sa(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Fe(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),Fe(t,()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function Tse(t,e){const n=Sa(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Fe(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)),Fe(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function Ise(t){return Sa(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}function Nse(t,e){const n=oe().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){const r=`[${t}x${e}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(t>n||e>n){const r=`[${t}x${e}]`,s=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function Ese(t){return Sa(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function zN(t,e,n,r,s,o,i){const a=t.getAttribLocation(e,n);return a===-1?!1:(Fe(t,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),Fe(t,()=>t.vertexAttribPointer(a,s,t.FLOAT,!1,o,i)),Fe(t,()=>t.enableVertexAttribArray(a)),!0)}function Rse(t,e,n){Fse(t,n),Fe(t,()=>t.activeTexture(t.TEXTURE0+n)),Fe(t,()=>t.bindTexture(t.TEXTURE_2D,e))}function _se(t,e,n){return Sa(t,()=>t.getUniformLocation(e,n),'uniform "'+n+'" not present in program.')}function Pse(t,e,n){return t.getUniformLocation(e,n)}function Ase(t,e,n,r){Fe(t,()=>Rse(t,e,r)),Fe(t,()=>t.uniform1i(n,r))}function Z1(t,e,n){Fe(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),Fe(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0))}function BN(t,e){Fe(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),Fe(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function $m(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Dse(t,e))}function Dse(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Sa(t,e,n){const r=Fe(t,()=>e());if(r==null)throw new Error(n);return r}function Fse(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n){const s=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${s}.`)}}function dd(t,e=2){return fe(t.slice(0,t.length-e))}function hd(t){if(t.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function km(t){let e=[1,1,1];return t.length===0||t.length===1&&t[0]===1||(e=[dd(t),...hd(t)]),e}function Ose(t,e=!1){let n=oe().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=oe().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&oe().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),e&&(n=n*2,r=r*2,t=t.map((a,l)=>l>=t.length-2?Jb(t[l]):t[l]),t.length===1&&(t=[2,t[0]])),t.length!==2&&(t=wl(t).newShape);let s=fe(t),o=null;t.length<=1&&s<=n?o=[1,s]:t.length===2&&t[0]<=n&&t[1]<=n?o=t:t.length===3&&t[0]*t[1]<=n&&t[2]<=n?o=[t[0]*t[1],t[2]]:t.length===3&&t[0]<=n&&t[1]*t[2]<=n?o=[t[0],t[1]*t[2]]:t.length===4&&t[0]*t[1]*t[2]<=n&&t[3]<=n?o=[t[0]*t[1]*t[2],t[3]]:t.length===4&&t[0]<=n&&t[1]*t[2]*t[3]<=n&&(o=[t[0],t[1]*t[2]*t[3]]);const i=o!=null&&Math.max(...o)>r&&Math.min(...o)<=(e?2:1)&&Math.min(...o)>0;if(o==null||i)if(e){const a=dd(t);let l=2,c=2;t.length&&([l,c]=hd(t)),s=a*(l/2)*(c/2),o=Zx(s).map(d=>d*2)}else o=Zx(s);return o}function Tm(t){return t%2===0}function _g(t,e){if(t=t.slice(-2),e=e.slice(-2),Mt(t,e)||!t.length||!e.length||t[0]===0||t[1]===0||e[0]===0||e[1]===0)return!0;if(t.length!==e.length){const n=t[t.length-1],r=e[e.length-1];if(n===r||Tm(n)&&Tm(r)&&(t[0]===1||e[0]===1))return!0}return t[1]===e[1]&&Tm(t[0])&&Tm(e[0])}let J1,ex;function Lse(t){if(J1==null){const e=Lo(t);J1=e.getParameter(e.MAX_TEXTURE_SIZE)}return J1}function zse(t){if(ex==null){const e=Lo(t);ex=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,ex)}function Bse(t){if(t===0)return 0;let e;const n=Lo(t);return oo(n,"EXT_disjoint_timer_query_webgl2")&&t===2?e=2:oo(n,"EXT_disjoint_timer_query")?e=1:e=0,e}function oo(t,e){return t.getExtension(e)!=null}function MN(t){try{if(Lo(t)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function Mse(t){if(t===0)return!1;const e=Lo(t);if(t===1){if(!oo(e,"OES_texture_float"))return!1}else if(!oo(e,"EXT_color_buffer_float"))return!1;return bv(e)}function Vse(t){if(t===0)return!1;const e=Lo(t);if(t===1){if(!oo(e,"OES_texture_float")||!oo(e,"WEBGL_color_buffer_float"))return!1}else{if(oo(e,"EXT_color_buffer_float"))return bv(e);const r="EXT_color_buffer_half_float";if(oo(e,r)){const s=e.getExtension(r);return Wse(e,s)}return!1}return bv(e)}function bv(t){const e=NC(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(o),i}function Wse(t,e){const n=NC(t,e),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(i),a}function Use(t){return t!==2?!1:Lo(t).fenceSync!=null}function tp(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&z(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ve=oe();Ve.registerFlag("HAS_WEBGL",()=>Ve.getNumber("WEBGL_VERSION")>0);Ve.registerFlag("WEBGL_VERSION",()=>MN(2)?2:MN(1)?1:0);Ve.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Ve.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Ve.get("WEBGL_VERSION")===2);Ve.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Ve.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Ve.registerFlag("WEBGL_PACK",()=>Ve.getBool("HAS_WEBGL"));Ve.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_CLIP",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_REDUCE",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_LAZILY_UNPACK",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_CONV_IM2COL",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Lse(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>zse(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=Ve.getNumber("WEBGL_VERSION");return t===0?0:Bse(t)});Ve.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Ve.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!_A());Ve.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Mse(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Ve.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Ve.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Ve.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Vse(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_FENCE_API_ENABLED",()=>Use(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Ve.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Ve.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)});Ve.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>_A()?1:-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)});Ve.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Ve.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Ve.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Ve.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Ve.registerFlag("WEBGL_EXP_CONV",()=>!1);Ve.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Ve.getBool("IS_TEST"));Ve.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Ve.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Ve.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Ve.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rr(){let t,e,n,r,s,o,i,a,l,c;return oe().getNumber("WEBGL_VERSION")===2?(t="#version 300 es",e="in",n="out",r="in",s="texture",o="outputColor",i="out vec4 outputColor;",a=oe().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(t="",e="attribute",n="varying",r="varying",s="texture2D",o="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:s,output:o,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vu(t,e,n="index"){const r=mn(e);return r.map((s,o)=>{const i=`int ${t[o]} = ${n} / ${s}`,a=o===r.length-1?`int ${t[o+1]} = ${n} - ${t[o]} * ${s}`:`index -= ${t[o]} * ${s}`;return`${i}; ${a};`}).join("")}function by(t,e,n="index"){const r=mn(e);return r.map((s,o)=>{const i=`int ${t[o]} = ${n} / outShapeStrides[${o}]`,a=o===r.length-1?`int ${t[o+1]} = ${n} - ${t[o]} * outShapeStrides[${o}]`:`index -= ${t[o]} * outShapeStrides[${o}]`;return`${i}; ${a};`}).join("")}function jse(t,e){const n=t.length,r=t.map(o=>`${e}[${o}]`),s=new Array(n-1);s[n-2]=r[n-1];for(let o=n-3;o>=0;--o)s[o]=`(${s[o+1]} * ${r[o+1]})`;return s}function Gse(t,e,n="index"){const r=t.map((o,i)=>i),s=jse(r,e);return s.map((o,i)=>{const a=`int ${t[i]} = ${n} / ${s[i]}`,l=i===s.length-1?`int ${t[i+1]} = ${n} - ${t[i]} * ${s[i]}`:`index -= ${t[i]} * ${s[i]}`;return`${a}; ${l};`}).join("")}function EC(t){const e=mn(t).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function RC(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const yF=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:xF}=use;function Hse(t,e,n){const r=[];if(t.forEach(g=>{const y=fe(g.shapeInfo.logicalShape);if(g.shapeInfo.isUniform?r.push(`uniform float ${g.name}${y>1?`[${y}]`:""};`):(r.push(`uniform sampler2D ${g.name};`),r.push(`uniform int offset${g.name};`)),n.enableShapeUniforms){const{uniformShape:x}=_C(n.packedInputs,g.shapeInfo.logicalShape,g.shapeInfo.texShape);switch(x.length){case 1:r.push(`uniform int ${g.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${g.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${g.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${g.name}Shape;`);break}r.push(`uniform ivec2 ${g.name}TexShape;`)}}),n.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(g=>{r.push(`uniform ${g.type} ${g.name}${g.arrayIndex?`[${g.arrayIndex}]`:""};`)});const s=r.join(`
`),o=t.map(g=>Kse(g,e,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=e.texShape,a=Rr(),l=Yse(a);let c,d,f=Jse(a);return e.isPacked?(c=Xse(e.logicalShape,i,n.enableShapeUniforms),d=Zse(a)):(c=qse(e.logicalShape,i,n.enableShapeUniforms),d=Qse(a)),n.packedInputs&&(f+=roe),[f,l,d,s,c,o,n.userCode].join(`
`)}function Nd(t,e=!1){const n=t.shapeInfo.logicalShape;switch(n.length){case 0:return moe(t,e);case 1:return yoe(t,e);case 2:return voe(t,e);case 3:return woe(t,e);case 4:return Coe(t,e);case 5:return $oe(t);case 6:return koe(t);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function vF(t,e){switch(t.shapeInfo.logicalShape.length){case 0:return poe(t);case 1:return goe(t,e);case 2:return xoe(t,e);case 3:return boe(t,e);default:return Soe(t,e)}}function Kse(t,e,n=!1,r){let s="";n?s+=vF(t,r):s+=Nd(t,r);const o=t.shapeInfo.logicalShape,i=e.logicalShape;return o.length<=i.length&&(n?s+=Toe(t,e):s+=Ioe(t,e)),s}function Xse(t,e,n){switch(t.length){case 0:return bF();case 1:return soe(t,e,n);case 2:return hoe(t,e,n);case 3:return ioe(t,e,n);default:return loe(t,e,n)}}function qse(t,e,n){switch(t.length){case 0:return bF();case 1:return ooe(t,e,n);case 2:return foe(t,e,n);case 3:return aoe(t,e,n);case 4:return uoe(t,e,n);case 5:return coe(t,e);case 6:return doe(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}function Yse(t){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${t.texture2D}(textureSampler, uv).r;
    }
  `}function Qse(t){return`
    void setOutput(float val) {
      ${t.output} = vec4(val, 0, 0, 0);
    }
  `}function Zse(t){return`
    void setOutput(vec4 val) {
      ${t.output} = val;
    }
  `}function Jse(t){return`${t.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${t.varyingFs} vec2 resultUV;
    ${t.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${t.defineSpecialNaN}
    ${t.defineSpecialInf}
    ${t.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${eoe}
    ${toe}
    ${noe}
  `}const eoe=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,toe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,noe=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,roe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function bF(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function soe(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function ooe(t,e,n){return e[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function ioe(t,e,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[2]/2),o=s*Math.ceil(t[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function aoe(t,e,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${by(["r","c","d"],t)}
    return ivec3(r, c, d);
  }
`;const r=Vu(["r","c","d"],t);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function loe(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[t.length-1]/2),o=s*Math.ceil(t[t.length-2]/2);let i=o,a="",l="b, r, c";for(let c=2;c<t.length-1;c++)i*=t[t.length-c-1],a=`
      int b${c} = index / ${i};
      index -= b${c} * ${i};
    `+a,l=`b${c}, `+l;return`
    ivec${t.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${a}

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${t.length}(${l});
    }
  `}function uoe(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${by(["r","c","d","d2"],t)}
      return ivec4(r, c, d, d2);
    }
  `;const r=Vu(["r","c","d","d2"],t);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function coe(t,e){const n=Vu(["r","c","d","d2","d3"],t);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function doe(t,e){const n=Vu(["r","c","d","d2","d3","d4"],t);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function hoe(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Mt(t,e))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const s=Math.ceil(t[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function foe(t,e,n){return Mt(t,e)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:t[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:t[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${t[1]};
      int c = index - r * ${t[1]};
      return ivec2(r, c);
    }
  `}function Wu(t){return`offset${t}`}function poe(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=Rr();return`
    vec4 ${n}() {
      return ${r.texture2D}(${e}, halfCR);
    }
  `}function moe(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[s,o]=t.shapeInfo.texShape;if(s===1&&o===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;const i=Wu(n);if(e)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;const[a,l]=t.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function goe(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t.shapeInfo.texShape,o=Rr();if(e)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${o.texture2D}(${n}, uv);
    }
  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${o.texture2D}(${n}, uv);
    }
  `}function yoe(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Ed(t)}
      }
    `;const s=t.shapeInfo.texShape,o=s[0],i=s[1];if(i===1&&o===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;const a=Wu(n);return i===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${o}.0);
        return sampleTexture(${n}, uv);
      }
    `:o===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:e?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${a});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${o}, ${i}, index + ${a});
      return sampleTexture(${n}, uv);
    }
  `}function xoe(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape,i=o[0],a=o[1],l=Rr();if(o!=null&&Mt(n,o))return e?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(e)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;const c=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],d=Math.ceil(n[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${d}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function voe(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape;if(o!=null&&Mt(n,o)){if(e)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const p=o[0],g=o[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${g}.0, ${p}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:i,keptDims:a}=wl(n),l=i;if(l.length<n.length){const p=Rd(t,l),g=["row","col"];return`
      ${Nd(p,e)}
      float ${s}(int row, int col) {
        return ${s}(${_d(g,a)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${Ed(t)}
      }
    `;const c=o[0],d=o[1],f=Wu(r);return d===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${r}, uv);
    }
  `:c===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:e?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${f};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${f};
    vec2 uv = uvFromFlat(${c}, ${d}, index);
    return sampleTexture(${r}, uv);
  }
`}function boe(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(n[0]===1){const p=n.slice(1),g=[1,2],y=Rd(t,p),x=["b","row","col"];return`
        ${vF(y,e)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${_d(x,g)});
        }
      `}const a=Rr();if(e)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `;const l=i[0],c=i[1],d=Math.ceil(n[2]/2),f=d*Math.ceil(n[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${f}, ${d}, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `}function woe(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[1]*n[2],i=n[2],{newShape:a,keptDims:l}=wl(n),c=a;if(c.length<n.length){const x=Rd(t,c),w=["row","col","depth"];return`
        ${Nd(x,e)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${_d(w,l)});
        }
      `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${o}, ${i}, 1)));
        ${Ed(t)}
      }
    `;const d=t.shapeInfo.texShape,f=d[0],p=d[1],g=t.shapeInfo.flatOffset;if(p===o&&g==null)return e?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${p}.0, ${f}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(p===i&&g==null)return e?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${f}.0);
      return sampleTexture(${r}, uv);
    }
  `;const y=Wu(r);return e?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${y};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o} + col * ${i} + depth + ${y};
        vec2 uv = uvFromFlat(${f}, ${p}, index);
        return sampleTexture(${r}, uv);
      }
  `}function Soe(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=Rr();if(e)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);
    }
  `;const o=t.shapeInfo.logicalShape,i=o.length,a=t.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],d=l[1],f=Math.ceil(o[i-1]/2);let p=f*Math.ceil(o[i-2]/2),g="int b, int row, int col",y=`b * ${p} + (row / 2) * ${f} + (col / 2)`;for(let x=2;x<i-1;x++)g=`int b${x}, `+g,p*=o[i-x-1],y=`b${x} * ${p} + `+y;return`
    vec4 ${r}(${g}) {
      int index = ${y};
      int texR = index / ${d};
      int texC = index - texR * ${d};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${c});
      return ${s.texture2D}(${n}, uv);
    }
  `}function Coe(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[3],i=n[2]*o,a=n[1]*i,{newShape:l,keptDims:c}=wl(n);if(l.length<n.length){const $=Rd(t,l),I=["row","col","depth","depth2"];return`
      ${Nd($,e)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${_d(I,c)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${o}, 1)));
        ${Ed(t)}
      }
    `;const d=t.shapeInfo.flatOffset,f=t.shapeInfo.texShape,p=f[0],g=f[1],y=`int stride2 = ${r}Shape[3];`,x=`int stride1 = ${r}Shape[2] * stride2;`,w=`int stride0 = ${r}Shape[1] * stride1;`;if(g===a&&d==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${y}
        ${x}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${p}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(g===o&&d==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${p}.0);
        return sampleTexture(${r}, uv);
      }
    `;const S=Wu(r);return e?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${y}
      ${x}
      ${w}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${S});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${o} + depth2;
      vec2 uv = uvFromFlat(${p}, ${g}, index + ${S});
      return sampleTexture(${r}, uv);
    }
  `}function $oe(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[4],o=e[3]*s,i=e[2]*o,a=e[1]*i,{newShape:l,keptDims:c}=wl(e);if(l.length<e.length){const x=Rd(t,l),w=["row","col","depth","depth2","depth3"];return`
      ${Nd(x)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${_d(w,c)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${o}, ${s})) +
          depth3;
        ${Ed(t)}
      }
    `;const d=t.shapeInfo.flatOffset,f=t.shapeInfo.texShape,p=f[0],g=f[1];if(g===a&&d==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${o}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(g===s&&d==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;const y=Wu(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${o} +
          depth2 * ${s} + depth3 + ${y};
      vec2 uv = uvFromFlat(${p}, ${g}, index);
      return sampleTexture(${n}, uv);
    }
  `}function koe(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:o}=wl(e);if(s.length<e.length){const w=Rd(t,s),S=["row","col","depth","depth2","depth3","depth4"];return`
      ${Nd(w)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${_d(S,o)});
      }
    `}const i=e[5],a=e[4]*i,l=e[3]*a,c=e[2]*l,d=e[1]*c;if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${d}, ${c}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Ed(t)}
      }
    `;const f=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,g=p[0],y=p[1];if(y===d&&f==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${g}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(y===i&&f==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${g}.0);
        return sampleTexture(${n}, uv);
      }
    `;const x=Wu(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${d} + col * ${c} + depth * ${l} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${x};
      vec2 uv = uvFromFlat(${g}, ${y}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Ed(t){const e=t.name,n=fe(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function Toe(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",o=t.shapeInfo.logicalShape.length,i=e.logicalShape.length,a=xF(t.shapeInfo.logicalShape,e.logicalShape),l=Kt(i),c=i-o;let d;const f=["x","y","z","w","u","v"];o===0?d="":i<2&&a.length>=1?d="coords = 0;":d=a.map($=>`coords.${f[$+c]} = 0;`).join(`
`);let p="";i<2&&o>0?p="coords":p=t.shapeInfo.logicalShape.map(($,I)=>`coords.${f[I+c]}`).join(", ");let g="return outputValue;";const x=fe(t.shapeInfo.logicalShape)===1,S=fe(e.logicalShape)===1;if(o===1&&!x&&!S)g=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(x&&!S)i===1?g=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:g=`
        return vec4(outputValue.x);
      `;else if(a.length){const $=o-2,I=o-1;a.indexOf($)>-1&&a.indexOf(I)>-1?g="return vec4(outputValue.x);":a.indexOf($)>-1?g="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(I)>-1&&(g="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${l} coords = getOutputCoords();
      ${d}
      vec4 outputValue = get${r}(${p});
      ${g}
    }
  `}function Ioe(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",o=e.texShape,i=t.shapeInfo.texShape,a=t.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!t.shapeInfo.isUniform&&a===l&&t.shapeInfo.flatOffset==null&&Mt(i,o))return`
      float ${s}() {
        return sampleTexture(${n}, resultUV);
      }
    `;const c=Kt(l),d=xF(t.shapeInfo.logicalShape,e.logicalShape),f=l-a;let p;const g=["x","y","z","w","u","v"];a===0?p="":l<2&&d.length>=1?p="coords = 0;":p=d.map(x=>`coords.${g[x+f]} = 0;`).join(`
`);let y="";return l<2&&a>0?y="coords":y=t.shapeInfo.logicalShape.map((x,w)=>`coords.${g[w+f]}`).join(", "),`
    float ${s}() {
      ${c} coords = getOutputCoords();
      ${p}
      return get${r}(${y});
    }
  `}function Kt(t){if(t<=1)return"int";if(t===2)return"ivec2";if(t===3)return"ivec3";if(t===4)return"ivec4";if(t===5)return"ivec5";if(t===6)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function _C(t,e,n){const{newShape:r,keptDims:s}=wl(e),o=e.length,i=t&&o===3&&e[0]===1,a=i?e.slice(1):r,l=!t&&o>1&&!Mt(e,n)&&r.length<o||i;return{useSqueezeShape:l,uniformShape:l?a:e,keptDims:s}}function Rd(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function _d(t,e){return e.map(n=>t[n]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Noe(t,e,n,r){const s=n.map((d,f)=>{const p={logicalShape:d.shape,texShape:d.isUniform?null:d.texData.texShape,isUniform:d.isUniform,isPacked:d.isUniform?!1:d.texData.isPacked,flatOffset:null};return d.texData!=null&&d.texData.slice!=null&&d.texData.slice.flatOffset>0&&(p.flatOffset=d.texData.slice.flatOffset),{name:e.variableNames[f],shapeInfo:p}}),o=s.map(d=>d.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=Hse(s,i,e),l=wse(t.gl,a),c=t.createProgram(l);return oe().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:o,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(t.buildVao(c),Object.assign({program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:o,outShapeInfo:i},wF(t,e,c)))}function wF(t,e,n){const r=[],s=[];let o,i,a,l=null,c=null;c=t.getUniformLocation(n,"NAN",!1),oe().getNumber("WEBGL_VERSION")===1&&(l=t.getUniformLocation(n,"INFINITY",!1));const d=!1;for(const f of e.variableNames){const p={name:f,uniform:t.getUniformLocation(n,f,d),offset:t.getUniformLocation(n,`offset${f}`,d)};e.enableShapeUniforms&&(p.shape=t.getUniformLocation(n,`${f}Shape`,d),p.texShape=t.getUniformLocation(n,`${f}TexShape`,d)),r.push(p)}if(e.enableShapeUniforms&&(o=t.getUniformLocation(n,"outShape",d),a=t.getUniformLocation(n,"outShapeStrides",d),i=t.getUniformLocation(n,"outTexShape",d)),e.customUniforms)for(const f of e.customUniforms)s.push(t.getUniformLocation(n,f.name,d));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:c,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:i}}function VN(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((n,r)=>{const s=n.logicalShape,o=e[r],i=o.shape;if(!Mt(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(n.isUniform&&o.isUniform)return;const a=n.texShape,l=o.isUniform?null:o.texData.texShape;if(!Mt(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function Eoe(t,e,n,r,s){e.program.enableShapeUniforms||(VN(e.inShapeInfos,n),VN([e.outShapeInfo],[r]));const o=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(o.texture,i[0],i[1]):t.setOutputMatrixTexture(o.texture,i[0],i[1]),t.setProgram(e.webGLProgram),t.bindVertexArray(e.webGLProgram.vao),oe().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&t.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&t.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<n.length;++l){const c=n[l],{uniform:d,offset:f,shape:p,texShape:g}=e.variablesLocations[l];if(p){const{uniformShape:y}=_C(e.program.packedInputs,c.shape,c.texData.texShape);switch(y.length){case 1:t.gl.uniform1iv(p,new Int32Array(y));break;case 2:t.gl.uniform2iv(p,new Int32Array(y));break;case 3:t.gl.uniform3iv(p,new Int32Array(y));break;case 4:t.gl.uniform4iv(p,new Int32Array(y));break}}if(g&&t.gl.uniform2i(g,c.texData.texShape[0],c.texData.texShape[1]),d!=null){if(c.isUniform){if(fe(c.shape)<2)t.gl.uniform1f(d,c.uniformValues[0]);else{let y=c.uniformValues;y instanceof Float32Array||(y=new Float32Array(y)),t.gl.uniform1fv(d,y)}continue}c.texData.slice!=null&&f!=null&&t.gl.uniform1i(f,c.texData.slice.flatOffset),t.setInputMatrixTexture(c.texData.texture.texture,d,l)}}const a=e.outShapeLocation;if(a)switch(r.shape.length){case 1:t.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:t.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:t.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:t.gl.uniform4iv(a,new Int32Array(r.shape));break}if(e.outShapeStridesLocation){const l=mn(r.shape);switch(r.shape.length){case 2:t.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:t.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:t.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&t.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&s)for(let l=0;l<e.program.customUniforms.length;++l){const c=e.program.customUniforms[l],d=e.customUniformLocations[l],f=s[l];if(c.type==="float")t.gl.uniform1fv(d,f);else if(c.type==="vec2")t.gl.uniform2fv(d,f);else if(c.type==="vec3")t.gl.uniform3fv(d,f);else if(c.type==="vec4")t.gl.uniform4fv(d,f);else if(c.type==="int")t.gl.uniform1iv(d,f);else if(c.type==="ivec2")t.gl.uniform2iv(d,f);else if(c.type==="ivec3")t.gl.uniform3iv(d,f);else if(c.type==="ivec4")t.gl.uniform4iv(d,f);else throw Error(`uniform type ${c.type} is not supported yet.`)}t.executeProgram()}function Roe(t,e,n){let r="";e.concat(n).forEach(i=>{const a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!i.isUniform){const l=i.texData.texShape,{useSqueezeShape:c,uniformShape:d,keptDims:f}=_C(t.packedInputs,i.shape,l);let p="",g="",y="";if(d.length===1&&t.packedInputs){const _=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];p=`${_[0]>1}_${_[1]>1}`}else if(d.length===2&&!t.packedInputs)g=`${d[0]>1}_${d[1]>1}`;else if(d.length>2&&!t.packedInputs){const _=mn(d);y=`${_[0]===l[1]}_${_[_.length-1]===l[1]}`}const x=i.shape.length,w=d.length===2&&Mt(i.shape,l),S=fe(i.shape)===1,$=cd(i.shape,n.shape),I=!t.packedInputs&&x===n.shape.length&&Mt(l,n.texData.texShape),R=t.packedInputs||d.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${x}_${I}_${c?f:""}_${d.length}_${S}_${$}_${w}_${p}_${g}_${y}_${R}_${a}`}else{const l=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${l}_${a}`}});const s=t.userCode;let o=t.constructor.name;return o+="_"+r+"_"+s+`${oe().getNumber("WEBGL_VERSION")}`,o}function dr(t){return oe().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _oe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=If.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Rr();this.outputShape=e,this.enableShapeUniforms=dr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?by(["r","c","d"],e):Vu(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Poe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=If.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Rr();this.outputShape=e,this.enableShapeUniforms=dr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?by(["r","c","d"],e):Vu(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Aoe{constructor(e){this.variableNames=["A"],this.outTexUsage=Rs.DOWNLOAD;const n=Rr();this.outputShape=e,this.userCode=`
      ${yF}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Doe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Rs.DOWNLOAD;const n=Rr();this.outputShape=e,this.userCode=`
      ${yF}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Foe={R:0,G:1,B:2,A:3};class WN{constructor(e,n=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Rr();this.outputShape=e,this.enableShapeUniforms=dr(this.outputShape.length);let o="result";n&&(o="floor(result * 255. + 0.5)");let i="";for(let a=0;a<r.length;a++){const l=r[a];i+=`
          if(offset == ${a}) {
            result = values[${Foe[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?RC():EC(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${s.texture2D}(A, uv);
          ${i}
        }
        ${s.output} = vec4(${o}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ooe{constructor(e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Rr();this.outputShape=e,this.enableShapeUniforms=dr(this.outputShape.length);let s="",o="result";n&&(o="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){const l=i*2+a;s+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?RC():EC(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${s}

          ${r.output} = ${o};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Loe(t){const e=Rr(),n=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return bse(t,n)}function zoe(t){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return kse(t,e)}function Boe(t){const e=new Uint16Array([0,1,2,2,1,3]);return Tse(t,e)}function np(t,e,n,r,s,o){Nse(e,n);const i=Ise(t),a=t.TEXTURE_2D;return Fe(t,()=>t.bindTexture(a,i)),Fe(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),Fe(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),Fe(t,()=>t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.NEAREST)),Fe(t,()=>t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.NEAREST)),oe().getNumber("WEBGL_VERSION")===1?Fe(t,()=>t.texImage2D(a,0,r,e,n,0,s,o,null)):Fe(t,()=>t.texStorage2D(a,1,r,e,n)),Fe(t,()=>t.bindTexture(t.TEXTURE_2D,null)),{texture:i,texShape:[n,e]}}function SF(t){return t.internalFormatFloat}function Moe(t,e,n,r){const[s,o]=ep(e,n);return np(t,s,o,SF(r),r.textureFormatFloat,t.FLOAT)}function CF(t){return t.internalFormatHalfFloat}function Voe(t,e,n,r){const[s,o]=ep(e,n);return np(t,s,o,CF(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function $F(t){return t.downloadTextureFormat}function Woe(t,e,n,r){const[s,o]=ep(e,n);return np(t,s,o,$F(r),t.RGBA,t.UNSIGNED_BYTE)}function kF(t){return t.internalFormatPackedFloat}function Uoe(t,e,n,r){const[s,o]=Id(e,n);return np(t,s,o,kF(r),t.RGBA,t.FLOAT)}function TF(t){return t.internalFormatPackedHalfFloat}function joe(t,e,n,r){const[s,o]=Id(e,n);return np(t,s,o,TF(r),t.RGBA,r.textureTypeHalfFloat)}function Goe(t,e,n){return Fe(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),zN(t,e,"clipSpacePos",n,3,20,0)&&zN(t,e,"uv",n,2,20,12)}function Hoe(t,e,n,r,s,o){Fe(t,()=>t.bindTexture(t.TEXTURE_2D,e));let i,a,l;s instanceof Uint8Array?(i=new Uint8Array(n*r*4),a=t.UNSIGNED_BYTE,l=t.RGBA):(i=new Float32Array(n*r*4),a=t.FLOAT,l=o.internalFormatPackedFloat),i.set(s),oe().getNumber("WEBGL_VERSION")===2?Fe(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n,r,t.RGBA,a,i)):Fe(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,n,r,0,t.RGBA,a,i)),Fe(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function Koe(t,e,n){Fe(t,()=>t.bindTexture(t.TEXTURE_2D,e)),n.data instanceof Uint8Array?oe().getNumber("WEBGL_VERSION")===2?Fe(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n.width,n.height,t.RGBA,t.UNSIGNED_BYTE,n.data)):Fe(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data)):oe().getNumber("WEBGL_VERSION")===2?Fe(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,n)):Fe(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),Fe(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function Xoe(t,e,n,r){const s=t.createBuffer();Fe(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,s));const a=4*4*e*n;return Fe(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,a,t.STREAM_READ)),Fe(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0)),Fe(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),s}function qoe(t,e,n){const r=t,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function Yoe(t,e,n,r){const[s,o]=ep(e,n),i=4,a=new Uint8Array(fse(e*n,i));return Fe(t,()=>t.readPixels(0,0,s,o,r.downloadTextureFormat,t.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function Qoe(t,e,n,r,s,o,i,a){const l=t,c=new Float32Array(pse(o,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function Zoe(t,e,n){const r=new Float32Array(e*n*4);return Fe(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,r)),r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tx{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const n=oe().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,cse(n,e)):this.gl=Lo(n),e=this.gl,oe().getNumber("WEBGL_VERSION")===2){const o=e;this.createVertexArray=()=>Fe(o,()=>o.createVertexArray()),this.bindVertexArray=i=>Fe(o,()=>o.bindVertexArray(i)),this.deleteVertexArray=i=>Fe(o,()=>o.deleteVertexArray(i)),this.getVertexArray=()=>Fe(o,()=>o.getParameter(o.VERTEX_ARRAY_BINDING))}else if(e!=null){const o=e.getExtension("OES_vertex_array_object");if(o==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Fe(e,()=>o.createVertexArrayOES()),this.bindVertexArray=i=>Fe(e,()=>o.bindVertexArrayOES(i)),this.deleteVertexArray=i=>Fe(e,()=>o.deleteVertexArrayOES(i)),this.getVertexArray=()=>Fe(e,()=>e.getParameter(o.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),oe().getNumber("WEBGL_VERSION")===1){const o="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=Cm(this.gl,o),oo(this.gl,i))this.textureHalfFloatExtension=Cm(this.gl,i);else if(oe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),oo(this.gl,s))this.colorBufferHalfFloatExtension=Cm(this.gl,s);else if(oe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",oo(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(oo(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=zoe(this.gl),this.indexBuffer=Boe(this.gl),this.framebuffer=Ese(this.gl),this.textureConfig=NC(this.gl,this.textureHalfFloatExtension)}get debug(){return oe().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Fe(e,()=>e.finish()),Fe(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Fe(e,()=>e.deleteFramebuffer(this.framebuffer)),Fe(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Fe(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Fe(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,n){return this.throwIfDisposed(),Moe(this.gl,e,n,this.textureConfig)}createFloat16MatrixTexture(e,n){return this.throwIfDisposed(),Voe(this.gl,e,n,this.textureConfig)}createUnsignedBytesMatrixTexture(e,n){return this.throwIfDisposed(),Woe(this.gl,e,n,this.textureConfig)}uploadPixelDataToTexture(e,n){this.throwIfDisposed(),Koe(this.gl,e,n)}uploadDenseMatrixToTexture(e,n,r,s){this.throwIfDisposed(),Hoe(this.gl,e,n,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(e,n){return this.throwIfDisposed(),joe(this.gl,e,n,this.textureConfig)}createPackedMatrixTexture(e,n){return this.throwIfDisposed(),Uoe(this.gl,e,n,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(BN(this.gl,this.framebuffer),this.outputTexture=null),Fe(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,n,r){return this.downloadMatrixDriver(e,()=>Yoe(this.gl,n,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,n,r,s,o,i){return Qoe(this.gl,e,n,r,s,o,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,n){return qoe(this.gl,e,n)}createBufferFromTexture(e,n,r){this.bindTextureToFrameBuffer(e);const s=Xoe(this.gl,n,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let n,r;if(oe().getBool("WEBGL_FENCE_API_ENABLED")){const s=e,o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{const i=s.clientWaitSync(o,0,0);return i===s.ALREADY_SIGNALED||i===s.CONDITION_SATISFIED},n=o}else oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(n,oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:n,isFencePassed:r}}downloadMatrixFromPackedTexture(e,n,r){return this.downloadMatrixDriver(e,()=>Zoe(this.gl,n,r))}createProgram(e){this.throwIfDisposed();const n=this.gl;this.vertexShader==null&&(this.vertexShader=Loe(n));const r=Cse(n);Fe(n,()=>n.attachShader(r,this.vertexShader)),Fe(n,()=>n.attachShader(r,e)),$se(n,r);const s=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&Q1(n,s),s}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const n=this.gl;Fe(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),Goe(n,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Fe(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Q1(this.gl,this.program),Fe(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,n,r=!0){return this.throwIfDisposed(),r?_se(this.gl,e,n):Pse(this.gl,e,n)}getAttributeLocation(e,n){return this.throwIfDisposed(),Fe(this.gl,()=>this.gl.getAttribLocation(e,n))}getUniformLocationNoThrow(e,n){return this.throwIfDisposed(),this.gl.getUniformLocation(e,n)}setInputMatrixTexture(e,n,r){this.throwIfDisposed(),this.throwIfNoProgram(),Ase(this.gl,e,n,r)}setOutputMatrixTexture(e,n,r){this.setOutputMatrixTextureDriver(e,r,n)}setOutputPackedMatrixTexture(e,n,r){this.throwIfDisposed();const[s,o]=Id(n,r);this.setOutputMatrixTextureDriver(e,s,o)}setOutputMatrixWriteRegion(e,n,r,s){this.setOutputMatrixWriteRegionDriver(r,e,s,n)}setOutputPackedMatrixWriteRegion(e,n,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Q1(this.gl,this.program),$m(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const n=this.getVertexArray();console.assert(n===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Fe(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Fe(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Cm(this.gl,oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,o),o}const e=this.getQueryTimerExtensionWebGL1(),n=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,n),n}endQuery(){if(oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,r=this.getQueryTimerExtensionWebGL2();n.endQuery(r.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await uN(()=>this.disposed||this.isQueryAvailable(e,oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,n){if(n===0)return null;if(n===2){const r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,n){if(n===0)return!0;if(n===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(e){return new Promise(n=>{this.addItemToPoll(()=>e.isFencePassed(),()=>n())})}pollItems(){const e=Joe(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=e;++n){const{resolveFn:r}=this.itemsToPoll[n];r()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,n){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:n}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in oe().platform&&(r=oe().platform.setTimeoutCustom.bind(oe().platform)),uN(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Z1(this.gl,e,this.framebuffer),this.debug&&$m(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Z1(this.gl,this.outputTexture,this.framebuffer),this.debug&&$m(this.gl)):BN(this.gl,this.framebuffer)}downloadMatrixDriver(e,n){this.bindTextureToFrameBuffer(e);const r=n();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,n,r){this.throwIfDisposed();const s=this.gl;Z1(s,e,this.framebuffer),this.debug&&$m(s),this.outputTexture=e,Fe(s,()=>s.viewport(0,0,n,r)),Fe(s,()=>s.scissor(0,0,n,r))}setOutputMatrixWriteRegionDriver(e,n,r,s){this.throwIfDisposed(),Fe(this.gl,()=>this.gl.scissor(e,n,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function Joe(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eie(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hr(t){return(e,n,r,s,o)=>{const i=ct(e,n),a=i.length,l=mn(i),c=fe(i),d=bi(o,c),f=e.length,p=n.length,g=mn(e),y=mn(n),x=cd(e,i),w=cd(n,i);if(x.length+w.length===0)for(let S=0;S<d.length;++S)d[S]=t(r[S%r.length],s[S%s.length]);else for(let S=0;S<d.length;++S){const $=ew(S,a,l),I=$.slice(-f);x.forEach(O=>I[O]=0);const R=nv(I,f,g),_=$.slice(-p);w.forEach(O=>_[O]=0);const F=nv(_,p,y);d[S]=t(r[R],s[F])}return[d,i]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tie(t,e,n,r){if(r==="int32"){const s=Int32Array.from(t);return[e,"int32",s]}if(r==="bool"){const s=ay([0],n),[o,i]=Hr((a,l)=>a!==l?1:0)(e,[],t,s,"bool");return[i,"bool",o]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nie=Hr((t,e)=>t+e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rie(t,e,n,r,s){const o=fe(r),i=ua(s,n);for(let a=0;a<t.length;a++){const l=t[a];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(o>0?i[l]+=e[a]:i[l]+=1)}return i}function sie(t,e,n,r=!1){const s=t.shape[0],o=t.shape[1],i=Vt([s,n],e.dtype);for(let a=0;a<s;a++)for(let l=0;l<o;l++){const c=t.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=n||(r?i.set(1,a,c):e.size>0?i.set(i.get(a,c)+e.get(a,l),a,c):i.set(i.get(a,c)+1,a,c))}return i}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oie=Hr((t,e)=>t&e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ca(t){return(e,n,r)=>{const s=En(n,e.length);for(let o=0;o<e.length;++o)s[o]=t(e[o],r);return s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iie=Ca(t=>Math.ceil(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aie(t,e,n,r){const s=En(n,fe(e));if(r&&n!=="string"){let o=0;t.forEach(i=>{const a=fe(i.shape);s.set(i.vals,o),o+=a})}else{let o=0;t.forEach(i=>{const a=n==="string"?xl(i.vals):i.vals;let l=0;for(let c=0;c<i.shape[0];++c){const d=c*e[1]+o;for(let f=0;f<i.shape[1];++f)s[d+f]=a[l++]}o+=i.shape[1]})}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lie=Hr((t,e)=>t===e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uie=Ca(t=>Math.exp(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cie=Ca(t=>Math.expm1(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const die=Ca(t=>Math.floor(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hie=Hr((t,e)=>Math.floor(t/e));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fie(t,e,n,r,s,o,i,a,l){const c=Vt([r,o],n);for(let d=0;d<r;d++){const f=[];let p=0;for(let g=0;g<s;g++){const y=t[d*s+g];p+=y*i[g],f.push(y)}if(p<0||p>=l/o)throw new Error(`Invalid indices: ${f} does not index into ${a}`);for(let g=0;g<o;g++)c.values[d*o+g]=e.get(...e.indexToLoc(p*o+g))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pie(t,e,n){const r=Vt(n,t.dtype);for(let s=0;s<r.size;++s){const i=r.indexToLoc(s).slice(),a=i[0],l=i[2],c=e.locToIndex([a,l]);i[2]=e.values[c];const d=t.locToIndex(i);0<=d&&d<t.values.length&&(r.values[s]=t.values[d])}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mie=Hr((t,e)=>t>e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gie=Hr((t,e)=>t>=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yie=Hr((t,e)=>t<e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xie=Hr((t,e)=>t<=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vie(t,e,n){const r=(e-t)/(n-1),s=ua(n,"float32");s[0]=t;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bie=Ca(t=>Math.log(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wie(t,e,n,r){const s=bi(r,fe(n));for(let o=0;o<s.length;++o){const i=o*e;let a=t[i];for(let l=0;l<e;++l){const c=t[i+l];(Number.isNaN(c)||c>a)&&(a=c)}s[o]=a}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sie=Hr((t,e)=>Math.max(t,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cie=Hr((t,e)=>Math.min(t,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IF=Hr((t,e)=>t*e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ie(t,e,n){const r=kd(-1,n);return IF([],e,r,t,n)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kie=Hr((t,e)=>t!==e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tie(t,e,n,r,s){const o=e.length,i=fe(e),a=mn(e),l=mn(s),c=bi(n,fe(s));for(let d=0;d<i;++d){const f=ew(d,o,a),p=new Array(f.length);for(let y=0;y<p.length;y++)p[y]=f[r[y]];const g=nv(p,o,l);c[g]=t[d]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iie(t,e,n,r){const[s,o]=Fs(t,r),i=Ur(e,"int32"),a=ua(fe(s),i),l=fe(o);for(let c=0;c<a.length;++c){const d=c*l;let f=1;for(let p=0;p<l;++p)f*=n[d+p];a[c]=f}return{outVals:a,outShape:s,outDtype:i}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nie(t,e,n){t.forEach((r,s)=>{if(r<0||r>=n){const o=ew(s,e.length,mn(e)).join(",");throw new Error(`indices[${o}] = ${r} is not in [0, ${n})`)}})}function Eie(t,e){for(let n=0;n<t.length;++n){const r=t[n],s=n===t.length-1?e:t[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let o=1;o<r.length;++o)if(r[o-1]>r[o])throw new Error("Ragged splits must be sorted in ascending order")}}function Rie(t,e,n,r){const s=[];let o=0;const i=e.length-1+n.length,a=new Array(i).fill(null).map(()=>[0]);Eie(n,r);let l=1;for(let c=0;c<e.length-1;++c){l*=e[c];const d=e[c+1];for(let f=1;f<l+1;++f)a[c].push(f*d)}for(let c=0;c<t.length;++c){let d=t[c],f=t[c]+1;for(let p=0;p<n.length;++p){const g=n[p],y=p+e.length-1;if(y>=0){const x=a[y],w=x[x.length-1]-g[d];for(let S=d;S<f;++S)a[y].push(g[S+1]+w)}d=g[d],f=g[f]}f!==d&&(s.push([d,f]),o+=f-d)}return{outSplits:a,valueSlices:s,numValues:o}}function _ie(t){const e=[];for(let n=0;n<t.length;++n){const r=t[n].length,s=En("int32",r);e.push(s),t[n].forEach((o,i)=>s[i]=o)}return e}function UN(t,e){const n=t.slice(0,e);for(;n.length<e;)n.push(1);for(let r=e;r<t.length;r++)n[e-1]*=t[r];return n}function Pie(t,e,n,r,s,o){const i=UN(e,2)[1],a=UN(o,2)[1];let l=0;for(const c of n)for(let d=c[0];d<c[1];++d){for(let f=0;f<r;++f)s[l*a+f]=t[d*i+f];++l}}function Aie(t,e,n,r,s){const o=e.slice();o[0]=s;const i=En(n,fe(o)),a=t.length,l=a===0?0:a/e[0];return Pie(t,e,r,l,i,o),[i,o]}function Die(t,e,n,r,s,o,i,a){if(t.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(Nie(o,i,l),r.length===0)throw new Error("params.rank must be nonzero");const c=r[0],{outSplits:d,valueSlices:f,numValues:p}=Rie(o,i,t,c),g=_ie(d),y=Aie(n,r,s,f,p);return[g,y[0],y[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jN=2147483647;function Fie(t,e,n,r,s,o,i){if(e.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,l=s.length===0,c=i.length===0,d=[];a||d.push(e[0]),l||d.push(s[0]),c||d.push(i[0]);for(let w=1;w<d.length;++w)if(d[w]!==d[w-1])throw new Error("starts, limits, and deltas must have the same shape");const f=d.length===0?1:d[0],p=En("int32",f+1);p[0]=0;for(let w=0;w<f;++w){const S=a?t[0]:t[w],$=l?r[0]:r[w],I=c?o[0]:o[w];if(I===0)throw new Error("Requires delta != 0");let R;if(I>0&&$<S||I<0&&$>S)R=0;else if(R=Math.ceil(Math.abs(($-S)/I)),R>jN)throw new Error(`Requires ((limit - start) / delta) <= ${jN}`);p[w+1]=p[w]+R}const g=p[f],y=En(n,g);let x=0;for(let w=0;w<f;++w){const S=p[w+1]-p[w];let $=a?t[0]:t[w];const I=c?o[0]:o[w];for(let R=0;R<S;++R)y[x++]=$,$+=I}return[p,y]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Js=Do;class Pg{constructor(e,n,r,s,o,i,a,l,c,d){this.shape=e,this.shapeShape=n,this.values=r,this.valuesShape=s,this.valuesDType=o,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=eF(d),this.raggedRank=tF(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Js.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Js.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const n=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Js.VALUE_ROWIDS:return Pg.getMaxWidthValueRowID(n);case Js.ROW_SPLITS:return Pg.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${Js[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const n=e.length;if(n===0||n===1)return 0;let r=0;for(let s=0;s<n-1;++s){const o=e[s+1]-e[s];o>r&&(r=o)}return r}static getMaxWidthValueRowID(e){const n=e.length;if(n===0)return 0;let r=0,s=e[0],o=0;for(let i=1;i<n;++i){const a=e[i];a!==s&&(s=a,o=Math.max(i-r,o),r=i)}return Math.max(n-r,o)}tensorShapeFromTensor(e,n,r=!0){if(n.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return HN(e,r)}calculateOutputSize(e){const n=this.valuesShape,r=this.defaultValueShape;nF(r,n);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=JD(this.raggedRank,s,n);i[0]<0&&(i[0]=e);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(e,n,r){const s=Math.min(e,r),o=[];let i=0;for(let a=0;a<s;++a,i+=n)o.push(i);for(let a=s;a<e;++a)o.push(-1);return z(o.length===e,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(e,n,r,s){const o=e.length,i=[];for(let a=0;a<o-1;++a){const l=e[a+1]-e[a];let c=Math.min(s,l),d=n[a];d===-1&&(c=0);for(let f=0;f<c;++f)i.push(d),d+=r;for(let f=0;f<l-c;++f)i.push(-1)}if(o>0&&i.length!==e[o-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(e,n,r,s){const o=e.length,i=[];if(o===0)return[];let a=0,l=e[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let c=n[l];i.push(c);for(let d=1;d<o;++d){const f=e[d];if(f===l)c>=0&&(++a,a<s?c+=r:c=-1);else{if(a=0,l=f,f>=n.length)throw new Error(`Got nextValueRowId=${f} which is not less than ${n.length}`);c=n[f]}i.push(c)}if(i.length!==e.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(e,n,r,s){const o=this.getRowPartitionTensor(e),i=this.getRowPartitionTypeByDimension(e);switch(i){case Js.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,n,r,s);case Js.ROW_SPLITS:if(o.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(o,n,r,s);default:throw new Error(`Unsupported partition type: ${Js[i]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const n=this.rowPartitionTypes[0];switch(n){case Js.FIRST_DIM_SIZE:return e[0];case Js.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Js.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Js[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const n=this.getFirstDimensionSize(),r=this.calculateOutputSize(n),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let l=s.length-2;l>=0;--l)s[l]=s[l+1]*r[l+1];const o=HN(r,!1),i=En(this.valuesDType,fe(o));if(s[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(n,s[0],r[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,s[c],r[c]);this.setOutput(this.raggedRank,l,i,o)}return[o,i]}setOutput(e,n,r,s){if(r.length===0)return;const o=this.values,i=r;let a=s.slice();a=a.slice(e+1);const l=fe(a),c=n.length;let d=this.defaultValue;if(d.length!==l&&d.length!==1){const y=this.defaultValueShape;tt(()=>{const x=xe(d,y);d=Zh(x,a).dataSync()})}let f=0,p=0,g=0;for(let y=0;y<=c;++y){let x=y<c?n[y]:-1;if(x===g){++g;continue}if(p<g){const w=o.subarray(f*l),S=i.subarray(p*l),$=(g-p)*l;GN(S,w,$)}if(y>=c){const w=r.length;x=Math.floor(w/l)}if(x>g)if(this.defaultValue.length===1)i.subarray(g*l,x*l).fill(this.defaultValue[0]),g=x;else for(;x>g;){const w=i.slice(g*l);GN(w,d,l),++g}x<0?(f=y+1,p=g):(f=y,p=g,g=p+1)}}}function GN(t,e,n){for(let r=0;r<n;r++)t[r]=e[r]}function HN(t,e){const n=[];for(let r of t){if(r<0){if(!e)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function Oie(t,e,n,r,s,o,i,a,l,c){return new Pg(t,e,n,r,s,o,i,a,l,c).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lie(t,e,n,r){const s=t===e,o=t<e&&n<0,i=e<t&&n>1;if(s||o||i)return ua(0,r);const a=Math.abs(Math.ceil((e-t)/n)),l=ua(a,r);e<t&&n===1&&(n=-1),l[0]=t;for(let c=1;c<l.length;c++)l[c]=l[c-1]+n;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zie=Ca(t=>1/Math.sqrt(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bie(t,e,n,r,s,o,i,a,l,c){const d=[r/s,s],f=t.values,p=e.values;if(r===0)return Vt(n,e.dtype);const g=l instanceof ad?l:Vt(d,e.dtype);typeof l=="string"||typeof l=="number"?g.values.fill(l):typeof l=="boolean"&&g.values.fill(+l);for(let y=0;y<o;y++){const x=[];let w=0;for(let S=0;S<i;S++){const $=f[y*i+S];x.push($),w+=$*a[S]}if(w<0||w>=r/s)throw new Error(`Invalid indices: ${x} does not index into ${n}`);for(let S=0;S<s;S++)c?g.values[w*s+S]+=p[y*s+S]:g.values[w*s+S]=e.rank===0?p[0]:p[y*s+S]}return g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mie=Ca(t=>1/(1+Math.exp(-t)));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vie(t,e,n,r,s){const o=rC(r,e,n),i=fe(n),a=mn(r);if(o){const f=sC(e,a);return s==="string"?t.slice(f,f+i):t.subarray(f,f+i)}const l=s==="string"?xl(t):t,c=Vt(r,s,l),d=Vt(n,s);for(let f=0;f<d.size;++f){const p=d.indexToLoc(f),g=p.map((y,x)=>y+e[x]);d.set(c.get(...g),...p)}return s==="string"?mF(d.values):d.values}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wie(t,e,n,r,s,o,i){const a=e[0],l=o[0],c=new Array(l),d=new Array(a),f=e[1];if(l===0){if(a!==0)throw new Error(rF(a));const w=En(n,0),S=En(s,0);return[w,[0,f],S,c,d]}let p=!0,g=0;const y=new Array(l).fill(0);for(let w=0;w<a;++w){const S=t[w*f];if(S<0)throw new Error(sF(w,S));if(S>=l)throw new Error(oF(w,S,l));++y[S],p=p&&S>=g,g=S}let x=!0;for(let w=0;w<l;++w){const S=y[w]===0;c[w]=S,x=x&&!S,y[w]=Math.max(y[w],1),w>0&&(y[w]+=y[w-1])}if(x&&p){const w=t,S=r;for(let $=0;$<a;++$)d[$]=$;return[w,[a,f],S,c,d]}else{const w=y[l-1],S=En(n,w*f),$=En(s,w),I=new Array(l).fill(0);for(let R=0;R<a;++R){const _=t[R*f],F=I[_],O=(_===0?0:y[_-1])+F;I[_]++;for(let M=0;M<f;++M)S[O*f+M]=t[R*f+M];$[O]=r[R],d[R]=O}for(let R=0;R<l;++R)if(I[R]===0){const F=R===0?0:y[R-1];S[F*f+0]=R;for(let O=1;O<f;++O)S[F*f+O]=0;$[F]=i}return[S,[w,f],$,c,d]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uie(t,e,n,r,s){const o=fe(r),i=e[0],a=s.length,l=[];let c=1,d=-1;for(let w=0;w<a;++w){const S=s[w];if(S===-1){if(d!==-1)throw new Error(iF(d,w));d=w,l.push(1)}else{if(S<0)throw new Error(aF(w,S));c*=S,l.push(S)}}if(d!==-1){if(c<=0)throw new Error(lF());const w=Math.trunc(o/c);if(c*w!==o)throw new Error(uF(r,l));l[d]=w}if(fe(l)!==o)throw new Error(cF(r,l));const p=r.length,g=[];if(p>0){g[p-1]=1;for(let w=p-2;w>=0;--w)g[w]=g[w+1]*r[w+1]}const y=[];if(a>0){y[a-1]=1;for(let w=a-2;w>=0;--w)y[w]=y[w+1]*l[w+1]}const x=En(n,i*a);for(let w=0;w<i;++w){let S=0;for(let $=0;$<p;++$)S+=t[w*p+$]*g[$];for(let $=0;$<a;++$)x[w*a+$]=Math.trunc(S/y[$]),S%=y[$]}return[x,[i,a],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jie(t,e,n,r,s,o=!1,i=0){const a=r.length,l=[e[0],t.length/e[0]],c=l[1],f=a>0?s[a-1]+1:0;if(f<0)throw new Error(vv());const p=e.slice();p[0]=f;const g=p.reduce((I,R)=>I*R,1),y=En(n,g);if(a===0)return f>0&&y.fill(i),[y,p];if(f<=0)throw new Error(vv());let x=0,w=1,S=0,$=s[x];for(;;){let I=0;if(w<a){if(I=s[w],$===I){++w;continue}if($>=I)throw new Error(dF())}if($<0||$>=f)throw new Error(hF($,f));$>S&&y.fill(i,S*c,$*c);for(let R=x;R<w;++R){const _=r[R];if(_<0||_>=l[0])throw new Error(fF(R,r[R],l[0]));for(let F=0;F<c;F++)y[$*c+F]+=t[_*c+F]}if(o)for(let R=0;R<c;R++)y[$*c+R]/=w-x;if(x=w,++w,S=$+1,$=I,w>a)break}return S<f&&y.fill(i,S*c,f*c),[y,p]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gie=Ca(t=>Math.sqrt(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hie=Hr((t,e)=>{const n=t-e;return n*n});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kie=Ca((t,e)=>{const{pattern:n,replaceGlobal:r,rewrite:s}=e;return t.replace(new RegExp(n,r?"g":""),s)});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xie(t,e,n,r){const s=Vt(t,e.dtype);for(let o=0;o<s.size;o++){const i=s.indexToLoc(o),a=new Array(i.length);for(let l=0;l<a.length;l++)a[l]=i[l]*n[l]+r[l];s.set(e.get(...a),...i)}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qie{constructor(e,n,r,s,o,i){this.separator=cl(e),this.nGramWidths=n,this.leftPad=cl(r),this.rightPad=cl(s),this.padWidth=o,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,n){const r=this.getPadWidth(n);return Math.max(0,e+2*r-n+1)}createNGrams(e,n,r,s,o,i){for(let a=0;a<o;++a){const l=this.getPadWidth(i),c=Math.max(0,l-a),d=Math.max(0,l-(o-(a+1))),f=i-(c+d),p=n+(c>0?0:a-l);let g=0;g+=c*this.leftPad.length;for(let $=0;$<f;++$)g+=e[p+$].length;g+=d*this.rightPad.length;const y=c+d+f-1;g+=y*this.separator.length,r[s+a]=new Uint8Array(g);const x=r[s+a];let w=0;const S=$=>$.forEach(I=>x[w++]=I);for(let $=0;$<c;++$)S(this.leftPad),S(this.separator);for(let $=0;$<f-1;++$)S(e[p+$]),S(this.separator);if(f>0){S(e[p+f-1]);for(let $=0;$<d;++$)S(this.separator),S(this.rightPad)}else{for(let $=0;$<d-1;++$)S(this.rightPad),S(this.separator);S(this.rightPad)}}}compute(e,n){const r=e.length,s=n.length;if(s>0){let l=n[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<s;++c){let d=n[c]>=l;if(d=d&&n[c]<=r,!d)throw new Error(`Invalid split value ${n[c]}, must be in [${l}, ${r}]`);l=n[c]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const o=s-1,i=En("int32",s);if(r===0||s===0){const l=new Array(r);for(let c=0;c<=o;++c)i[c]=0;return[l,i]}i[0]=0;for(let l=1;l<=o;++l){const c=n[l]-n[l-1];let d=0;this.nGramWidths.forEach(f=>{d+=this.getNumNGrams(c,f)}),this.preserveShort&&c>0&&d===0&&(d=1),i[l]=i[l-1]+d}const a=new Array(i[o]);for(let l=0;l<o;++l){const c=n[l];let d=i[l];if(this.nGramWidths.forEach(f=>{const p=n[l+1]-n[l],g=this.getNumNGrams(p,f);this.createNGrams(e,c,a,d,g,f),d+=g}),this.preserveShort&&d===i[l]){const f=n[l+1]-n[l];if(f===0)continue;const p=f+2*this.padWidth;this.createNGrams(e,c,a,d,1,p)}}return[a,i]}}function Yie(t,e,n,r,s,o,i,a){return new qie(n,r,s,o,i,a).compute(t,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qie(t,e,n,r){if(!t.length)return;if(e.length===0){for(let o=0;o<t.length;++o)r.push(t.subarray(o,o+1));return}if(e.length===1){const o=e[0];let i=t.indexOf(o);for(;i!==-1;){const a=t.subarray(0,i);(!n||a.length!==0)&&r.push(a),t=t.subarray(i+1),i=t.indexOf(o)}(!n||t.length!==0)&&r.push(t);return}let s=0;for(let o=0;o<t.length+1;o++)if(o===t.length||e.indexOf(t[o])!==-1){const i=t.subarray(s,o);(!n||i.length!==0)&&r.push(i),s=o+1}}function Zie(t,e,n){const r=t.length,s=[];let o=0,i=0;const a=new Array(r);for(let p=0;p<r;++p){const g=s.length;Qie(t[p],e,n,s);const y=s.length-g;a[p]=y,o+=y,i=Math.max(i,y)}const l=En("int32",o*2),c=new Array(o),d=[r,i];let f=0;for(let p=0;p<r;++p)for(let g=0;g<a[p];++g)l[f*2]=p,l[f*2+1]=g,c[f]=s[f],++f;return[l,c,d]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jie(t,e){const n=En("int32",t.length);for(let r=0;r<t.length;++r)n[r]=gX(t[r]).modulo(e).getLowBitsUnsigned();return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eae=Hr((t,e)=>t-e);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tae(t,e){const n=new Array(t.rank);for(let s=0;s<n.length;s++)n[s]=t.shape[s]*e[s];const r=Vt(n,t.dtype);for(let s=0;s<r.values.length;++s){const o=r.indexToLoc(s),i=new Array(t.rank);for(let l=0;l<i.length;l++)i[l]=o[l]%t.shape[l];const a=t.locToIndex(i);r.values[s]=t.values[a]}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lh=(t,e)=>{const n=e.value-t.value;return n===0?t.index-e.index:n};function NF(t,e,n=0,r=t.length-1){for(;r>n;){if(r-n>600){const a=r-n+1,l=e-n+1,c=Math.log(a),d=.5*Math.exp(2*c/3),f=.5*Math.sqrt(c*d*(a-d)/a)*Math.sign(l-a/2),p=Math.max(n,Math.floor(e-l*d/a+f)),g=Math.min(r,Math.floor(e+(a-l)*d/a+f));NF(t,e,p,g)}const s=t[e];let o=n,i=r;for(bh(t,n,e),Lh(t[r],s)>0&&bh(t,n,r);o<i;){for(bh(t,o,i),o++,i--;Lh(t[o],s)<0;)o=o+1;for(;Lh(t[i],s)>0;)i=i-1}Lh(t[n],s)===0?bh(t,n,i):(i=i+1,bh(t,i,r)),i<=e&&(n=i+1),e<=i&&(r=i-1)}}function nae(t,e,n,r,s){const o=e[e.length-1],[i,a]=[t.length/o,o],l=bi(n,i*r),c=bi("int32",i*r);for(let f=0;f<i;f++){const p=f*a,g=t.subarray(p,p+a);let y=new Array(g.length);g.forEach(($,I)=>y[I]={value:$,index:I}),r<y.length&&(NF(y,r),y=y.slice(0,r)),s&&y.sort(Lh);const x=f*r,w=l.subarray(x,x+r),S=c.subarray(x,x+r);for(let $=0;$<r;$++)w[$]=y[$].value,S[$]=y[$].index}const d=e.slice();return d[d.length-1]=r,[Vt(d,n,l),Vt(d,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rae(t,e,n,r){const s=nn(e,n)[0],o=[1,n[0],1];for(let y=0;y<s;y++)o[0]*=n[y];o[1]=n[s];for(let y=s+1;y<n.length;y++)o[2]*=n[y];const i=new Map,a=new Int32Array(n[s]),l=new ad(o,r,t),c=[],d=o[0]===1&&o[2]===1;for(let y=0;y<n[s];y++){let x;if(d)x=t[y].toString();else{const S=[];for(let $=0;$<o[0];$++)for(let I=0;I<o[2];I++)S.push(l.get($,y,I));x=S.join(",")}const w=i.get(x);if(w!=null)a[y]=w;else{const S=i.size;i.set(x,S),a[y]=S,c.push(y)}}const f=o.slice();f[1]=i.size;const p=new ad(f,r);c.forEach((y,x)=>{for(let w=0;w<o[0];w++)for(let S=0;S<o[2];S++)p.set(l.get(w,y,S),w,x,S)});const g=n.slice();return g[s]=f[1],{outputValues:p.values,outputShape:g,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EF=Object.freeze(Object.defineProperty({__proto__:null,addImpl:nie,bincountImpl:rie,bincountReduceImpl:sie,bitwiseAndImpl:oie,castImpl:tie,ceilImpl:iie,concatImpl:aie,equalImpl:lie,expImpl:uie,expm1Impl:cie,floorDivImpl:hie,floorImpl:die,gatherNdImpl:fie,gatherV2Impl:pie,greaterEqualImpl:gie,greaterImpl:mie,lessEqualImpl:xie,lessImpl:yie,linSpaceImpl:vie,logImpl:bie,maxImpl:wie,maximumImpl:Sie,minimumImpl:Cie,multiplyImpl:IF,negImpl:$ie,notEqualImpl:kie,prodImpl:Iie,raggedGatherImpl:Die,raggedRangeImpl:Fie,raggedTensorToTensorImpl:Oie,rangeImpl:Lie,rsqrtImpl:zie,scatterImpl:Bie,sigmoidImpl:Mie,simpleAbsImpl:eie,sliceImpl:Vie,sparseFillEmptyRowsImpl:Wie,sparseReshapeImpl:Uie,sparseSegmentReductionImpl:jie,sqrtImpl:Gie,squaredDifferenceImpl:Hie,staticRegexReplaceImpl:Kie,stridedSliceImpl:Xie,stringNGramsImpl:Yie,stringSplitImpl:Zie,stringToHashBucketFastImpl:Jie,subImpl:eae,tileImpl:tae,topKImpl:nae,transposeImpl:Tie,uniqueImpl:rae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:sae,bincountImpl:RF,bincountReduceImpl:oae,bitwiseAndImpl:iae,castImpl:aae,ceilImpl:lae,concatImpl:uae,equalImpl:cae,expImpl:dae,expm1Impl:hae,floorImpl:fae,gatherNdImpl:pae,gatherV2Impl:mae,greaterImpl:gae,greaterEqualImpl:yae,lessImpl:xae,lessEqualImpl:vae,linSpaceImpl:bae,logImpl:wae,maxImpl:Sae,maximumImpl:Cae,minimumImpl:$ae,multiplyImpl:kae,negImpl:Tae,notEqualImpl:Iae,prodImpl:Nae,raggedGatherImpl:Eae,raggedRangeImpl:Rae,raggedTensorToTensorImpl:_ae,rangeImpl:Pae,rsqrtImpl:Aae,scatterImpl:Dae,sigmoidImpl:Fae,simpleAbsImpl:_F,sliceImpl:Oae,sparseFillEmptyRowsImpl:Lae,sparseReshapeImpl:zae,sparseSegmentReductionImpl:PF,sqrtImpl:Bae,staticRegexReplaceImpl:Mae,stridedSliceImpl:Vae,stringNGramsImpl:Wae,stringSplitImpl:Uae,stringToHashBucketFastImpl:jae,subImpl:Gae,tileImpl:Hae,topKImpl:Kae,transposeImpl:PC,uniqueImpl:Xae}=EF;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AF(t,e){return["x","y","z","w","u","v"].slice(0,e).map(n=>`${t}.${n}`)}function kr(t,e){return e===1?[t]:AF(t,e)}function qae(t,e){if(t===1)return"rc";let n="";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yae{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=dr(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const n=kr("rc",this.rank),r=Kt(this.rank),s=this.getOutOfBoundsCondition(n),o=this.getSetup(n),i=this.getOutput(n);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${s}) {
            setOutput(vec4(0));
          } else {
            ${o}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(e){const n=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let o=`${r===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)o=`${e[e.length-1-i]},`+o;n.push(o)}return n}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let n="";for(let r=this.rank-2;r<this.rank;r++)n+=`${e[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(n+="||");return n}getSetup(e){if(this.rank===1)return"";const n=e.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],s=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${n[0]};
      int c = ${n[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${s};
    `}getOutput(e){const n=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${n[0]}),
            cEdge ? 0. : getA(${n[1]}),
            rEdge ? 0. : getA(${n[2]}),
            rEdge || cEdge ? 0. : getA(${n[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DF{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=dr(this.outputShape.length);let r="";for(let s=0;s<4;s++){let o="thisRC = rc;";s%2===1&&(o+="thisRC.z += 1;"),s>1&&(o+="thisRC.y += 1;"),r+=`
        ${o}
        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s>0?"}":""}
      `}this.userCode=`
      ${Qae(n,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?RC():EC(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}}function Qae(t,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?Gse(["r","c","d"],"inputShape"):Vu(["r","c","d"],t)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Zae=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,n,r){const s=XN(n,r),o=qN(e,s,r);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const i=KN(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const l=this.freeTextures[o].pop();return this.usedTextures[o].push(l),l}let a;return s===qn.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):s===qn.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):s===qn.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):s===qn.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):s===qn.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(e,n,r,s){if(this.freeTextures==null)return;const o=XN(r,s),i=qN(n,o,s);i in this.freeTextures||(this.freeTextures[i]=[]);const a=KN(n,o,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=oe().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[i],d=c&&c.indexOf(e);if(d==null||d<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[d]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function Jae(t,e){const n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;if(e===n.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function KN(t,e,n,r,s){const o=ele(e,r);let i;if(s){const[l,c]=Id(t[0],t[1]);i=l*c}else{const[l,c]=ep(t[0],t[1]);i=l*c}const a=Jae(n,o);return i*a}function ele(t,e){switch(t){case qn.PACKED_2X2_FLOAT32:return kF(e);case qn.PACKED_2X2_FLOAT16:return TF(e);case qn.UNPACKED_FLOAT32:return SF(e);case qn.UNPACKED_FLOAT16:return CF(e);case qn.PACKED_4X1_UNSIGNED_BYTE:return $F(e);default:throw new Error(`Unknown physical texture type ${t}`)}}function tle(t){return oe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?qn.PACKED_2X2_FLOAT32:qn.UNPACKED_FLOAT32:t?qn.PACKED_2X2_FLOAT16:qn.UNPACKED_FLOAT16}function XN(t,e){if(t===Rs.UPLOAD)return qn.PACKED_2X2_FLOAT32;if(t===Rs.RENDER||t==null)return tle(e);if(t===Rs.DOWNLOAD||t===Rs.PIXELS)return qn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function qN(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let di=class{constructor(e,n){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=dr(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${n}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}};const po="if (isnan(x)) return x;",nle="return x;",YN="return abs(x);",rle="return (x >= 0.0) ? x : (exp(x) - 1.0);",sle=po+`
  return (x < 0.0) ? 0.0 : x;
`,ole=po+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,sl="return x;",ile="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ale="return x;",lle=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,ule=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cle=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,dle="return 1.0 / (1.0 + exp(-1.0 * x));";class al{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=dr(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hle{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=dr(this.outputShape.length);const n=e.length,r=kr("rc",n),s=Kt(n),o=qae(n,r),i=r.slice(-2),a=n<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${o});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fle=_D,ple=1e-7,mle=1e-4,Im={};function gle(t){return t in Im||(Im[t]={}),Im[t]}const yle=oe().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),xle=600;function vle(){return oe().global.screen==null?1024:oe().global.screen.height*oe().global.screen.width*window.devicePixelRatio*xle/1024/1024}class wy extends Zb{nextDataId(){return wy.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!oe().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(e!=null){if(e instanceof tx)n=e;else{const r=Lo(oe().getNumber("WEBGL_VERSION"),e);n=new tx(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=Lo(oe().getNumber("WEBGL_VERSION"));n=new tx(r),this.binaryCache=gle(oe().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Zae(this.gpgpu),this.numMBBeforeWarning=vle(),this.texData=new VP(this,cs())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,n,r,s,o,i){const a=this.makeTensorInfo(n,r),l=this.texData.get(a.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[s,o]},l.texShape=[s,o];const c=km(n),d=new WN(c,!1,i),f=this.runWebGLProgram(d,[a],r,[[s,o]]);return f.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(a),f.dataId}write(e,n,r){if((oe().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||oe().getBool("DEBUG"))&&this.checkNumericalProblems(e),r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:n,dtype:r,values:e,usage:Rs.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const n=this.texData.get(e);n.refCount++}decRef(e){if(this.texData.has(e)){const n=this.texData.get(e);n.refCount--}}move(e,n,r,s,o){if(oe().getBool("DEBUG")&&this.checkNumericalProblems(n),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:s,values:n,usage:Rs.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const n=this.texData.get(e),{values:r,dtype:s,complexTensorInfos:o,slice:i,shape:a,isPacked:l}=n;if(i!=null){let p;l?p=new al(a,sl):p=new di(a,sl);const g=this.runWebGLProgram(p,[{dataId:e,shape:a,dtype:s}],s),y=this.readSync(g.dataId);return this.disposeIntermediateTensorInfo(g),y}if(r!=null)return this.convertAndCacheOnCPU(e);if(s==="string")return r;const c=this.activeTimers!=null;let d;c&&(d=_o());let f;if(s==="complex64"){const p=this.readSync(o.real.dataId),g=this.readSync(o.imag.dataId);f=Tf(p,g)}else f=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=_o()-d),this.convertAndCacheOnCPU(e,f)}async read(e){if(this.pendingRead.has(e)){const y=this.pendingRead.get(e);return new Promise(x=>y.push(x))}const n=this.texData.get(e),{values:r,shape:s,slice:o,dtype:i,complexTensorInfos:a,isPacked:l}=n;if(o!=null){let y;l?y=new al(s,sl):y=new di(s,sl);const x=this.runWebGLProgram(y,[{dataId:e,shape:s,dtype:i}],i),w=this.read(x.dataId);return this.disposeIntermediateTensorInfo(x),w}if(r!=null)return this.convertAndCacheOnCPU(e);if(oe().getBool("DEBUG")&&!oe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&oe().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,d;if(i!=="complex64"&&oe().get("WEBGL_BUFFER_SUPPORTED")){d=this.decode(e);const y=this.texData.get(d.dataId);c=this.gpgpu.createBufferFromTexture(y.texture.texture,...Sm(s))}this.pendingRead.set(e,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let f;if(i==="complex64"){const y=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),x=y[0],w=y[1];f=Tf(x,w)}else if(c==null)f=this.getValuesFromTexture(e);else{const y=fe(s);f=this.gpgpu.downloadFloat32MatrixFromBuffer(c,y)}if(d!=null&&this.disposeIntermediateTensorInfo(d),c!=null){const y=this.gpgpu.gl;Fe(y,()=>y.deleteBuffer(c))}const p=this.convertAndCacheOnCPU(e,f),g=this.pendingRead.get(e);return this.pendingRead.delete(e),g.forEach(y=>y(p)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&cs().removeDataId(e,this),this.pendingDeletes--),p}readToGPU(e,n={}){const r=this.texData.get(e),{values:s,shape:o,slice:i,dtype:a,isPacked:l,texture:c}=r;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let g;l?g=new al(o,sl):g=new di(o,sl);const y=this.runWebGLProgram(g,[{dataId:e,shape:o,dtype:a}],a),x=this.readToGPU(y,n);return this.disposeIntermediateTensorInfo(y),x}if(c==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(e,n.customTexShape),f=cs().makeTensorFromTensorInfo(d),p=this.texData.get(d.dataId);return Object.assign({tensorRef:f},p.texture)}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const r=n.map(s=>ca(s));return Vt(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Vt(e.shape,e.dtype,n)}checkNumericalProblems(e){if(e!=null)for(let n=0;n<e.length;n++){const r=e[n];if(!xse(r))throw oe().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:n,dtype:r,isPacked:s}=this.texData.get(e),o=fe(n);if(oe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const p=this.decode(e),g=this.texData.get(p.dataId),y=this.gpgpu.downloadMatrixFromPackedTexture(g.texture.texture,...Sm(n)).subarray(0,o);return this.disposeIntermediateTensorInfo(p),y}const i=oe().getBool("WEBGL_PACK")&&s===!0,a=i?km(n):n,l=i?new Doe(a):new Aoe(a),c=this.runWebGLProgram(l,[{shape:a,dtype:r,dataId:e}],"float32"),d=this.texData.get(c.dataId),f=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(c),f}timerAvailable(){return oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const n=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const o=da(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=da(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,s&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(o);a.kernelMs=WP(l),a.getExtraProfileInfo=()=>l.map((c,d)=>({name:i[d],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:_o(),endMs:null}}endTimer(e){return oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=_o(),e)}async getQueryTime(e){if(oe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const n=e;return n.endMs-n.startMs}disposeData(e,n=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(n?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!n&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return r!=null&&(this.disposeData(r.real.dataId,n),this.disposeData(r.imag.dataId,n)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:n,dtype:r,texShape:s,usage:o,isPacked:i,slice:a}=this.texData.get(e),l=a&&a.origDataId||e,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(n,s,o,i)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,n=yle){return oe().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>this.texData.get(r.dataId).texture==null&&fe(r.shape)<n)}getGPGPUContext(){return this.gpgpu}where(e){Oo("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=e.dataSync();return fle(e.shape,n)}packedUnaryOp(e,n,r){const s=new al(e.shape,n),o=this.compileAndRun(s,[e],r);return cs().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const s=_F(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if(oe().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,YN,e.dtype);const n=new di(e.shape,YN),r=this.compileAndRun(n,[e]);return cs().makeTensorFromTensorInfo(r)}makeTensorInfo(e,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&Hf(r[0])){const o=r.map(i=>cl(i));s=this.write(o,e,n)}else s=this.write(r,e,n);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:n}}makeOutput(e,n,r){return cs().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,r),this)}unpackTensor(e){const n=new hle(e.shape);return this.runWebGLProgram(n,[e],e.dtype)}packTensor(e){const n=new Yae(e.shape);return this.runWebGLProgram(n,[e],e.dtype,null,!0)}packedReshape(e,n){const r=[dd(e.shape),...hd(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},o=[dd(n),...hd(n)],i=new DF(o,r),a=!0,l=[r],c=this.runWebGLProgram(i,[s],e.dtype,l,a);return{dataId:c.dataId,shape:n,dtype:c.dtype}}decode(e,n){const r=this.texData.get(e),{isPacked:s,shape:o,dtype:i}=r;if(n!=null){const p=fe(o),g=n[0]*n[1]*4;z(p<=g,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=km(o);let l;s?l=new Poe(a):l=new _oe(a);const c=!0,d=[n??Sm(a)],f=this.runWebGLProgram(l,[{shape:a,dtype:i,dataId:e}],i,d,c,n);return{dtype:i,shape:o,dataId:f.dataId}}runWebGLProgram(e,n,r,s,o=!1,i){const a=this.makeTensorInfo(e.outputShape,r),l=this.texData.get(a.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===If.DENSE){const S=i??Sm(e.outputShape);l.texShape=S.map($=>$*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),fe(a.shape)===0)return l.values=bi(a.dtype,0),a;const c=[],d=n.map(S=>{if(S.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let $=this.texData.get(S.dataId);if($.texture==null){if(!e.packedInputs&&fe(S.shape)<=oe().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:S.shape,texData:null,isUniform:!0,uniformValues:$.values};e.packedInputs&&($.isPacked=!0,$.shape=S.shape)}if(this.uploadToGPU(S.dataId),!!$.isPacked!=!!e.packedInputs)S=$.isPacked?this.unpackTensor(S):this.packTensor(S),c.push(S),$=this.texData.get(S.dataId);else if($.isPacked&&!_g($.shape,S.shape)){const I=S,R=S.shape;S.shape=$.shape,S=this.packedReshape(S,R),c.push(S),$=this.texData.get(S.dataId),I.shape=R}return{shape:S.shape,texData:$,isUniform:!1}});this.uploadToGPU(a.dataId);const f={shape:a.shape,texData:l,isUniform:!1},p=Roe(e,d,f),g=this.getAndSaveBinary(p,()=>Noe(this.gpgpu,e,d,f)),y=this.activeTimers!=null;let x;y&&(x=this.startTimer()),oe().get("ENGINE_COMPILE_ONLY")||Eoe(this.gpgpu,g,d,f,s),c.forEach(S=>this.disposeIntermediateTensorInfo(S)),y&&(x=this.endTimer(x),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(x)}));const w=oe().getNumber("WEBGL_FLUSH_THRESHOLD");if(w>0){const S=_o();S-this.lastGlFlushTime>w&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=S)}if(!oe().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&o===!1){const S=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),S}return a}compileAndRun(e,n,r,s,o=!1){return r=r||n[0].dtype,this.runWebGLProgram(e,n,r,s,o)}getAndSaveBinary(e,n){return e in this.binaryCache||(this.binaryCache[e]=n()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(oe().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=tt(()=>{if(!oe().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=oe().getBool("DEBUG");oe().set("DEBUG",!1);const n=this.abs(pt(1e-8)).dataSync()[0];if(oe().set("DEBUG",e),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?ple:mle}uploadToGPU(e){const n=this.texData.get(e),{shape:r,dtype:s,values:o,texture:i,usage:a,isPacked:l}=n;if(i!=null)return;const c=this.activeTimers!=null;let d;c&&(d=_o());let f=n.texShape;if(f==null&&(f=Ose(r,l),n.texShape=f),o!=null){const p=km(r);let g,y=f[1],x=f[0];const w=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(l||!w)&&([y,x]=Id(f[0],f[1])),l?g=new Ooe(p,w):g=new WN(p,w);const S=w?[x,y]:f,$=this.makeTensorInfo(S,s),I=this.texData.get($.dataId);w?I.usage=Rs.PIXELS:I.usage=Rs.UPLOAD,I.texShape=S,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture($.dataId),y,x,o);const R=[[x,y]],F=this.runWebGLProgram(g,[$],s,R,!0),O=this.texData.get(F.dataId);n.texShape=O.texShape,n.isPacked=O.isPacked,n.usage=O.usage,oe().get("ENGINE_COMPILE_ONLY")?this.disposeData(F.dataId):(n.texture=O.texture,n.values=null,this.texData.delete(F.dataId)),this.disposeIntermediateTensorInfo($),c&&(this.uploadWaitMs+=_o()-d)}else{const p=this.acquireTexture(f,a,s,l);n.texture=p}}convertAndCacheOnCPU(e,n){const r=this.texData.get(e),{dtype:s}=r;return n!=null&&(r.values=ble(n,s)),r.values}acquireTexture(e,n,r,s){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,n,s)}computeBytes(e,n){return e[0]*e[1]*vg(n)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(n));return Promise.all(e)}else{for(const[,n]of Object.entries(this.binaryCache)){const r=new Promise(s=>{try{this.checkCompletion_(n),s(!0)}catch(o){throw o}});e.push(r)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Zre(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(gF(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:n,customUniformLocations:r,infLoc:s,nanLoc:o,outShapeLocation:i,outShapeStridesLocation:a,outTexShapeLocation:l}=wF(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=n,e.customUniformLocations=r,e.infLoc=s,e.nanLoc=o,e.outShapeLocation=i,e.outShapeStridesLocation=a,e.outTexShapeLocation=l}}createTensorFromGPUData(e,n,r){e.channels=e.channels||"RGBA";const{texture:s,height:o,width:i,channels:a}=e,l=cs().backend;if(!l.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=l.writeTexture(s,n,r,o,i,a);return cs().makeTensorFromDataId(c,n,r,l)}}wy.nextDataId=0;function ble(t,e){if(e==="float32"||e==="complex64")return t;if(e==="int32"||e==="bool"){const n=e==="int32"?new Int32Array(t.length):new Uint8Array(t.length);for(let r=0;r<n.length;++r)n[r]=Math.round(t[r]);return n}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */PA()&&FA("webgl",()=>new wy,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AC=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;let Ou=class{constructor(e,n,r){this.variableNames=["A","B"],this.outputShape=ct(n,r),this.enableShapeUniforms=dr(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uu=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Pd{constructor(e,n,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=ct(n,r);const o=this.outputShape.length;this.enableShapeUniforms=dr(o);let i="";if(s)if(o===0||fe(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${Kt(o)} coords = getOutputCoords();
        `,o===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=kr("coords",o);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${l[o-2]} + 1) >= outShape[${o} - 2];
            bool nextColOutOfBounds =
              (${l[o-1]} + 1) >= outShape[${o} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${l[o-2]} + 1) >= ${this.outputShape[o-2]};
            bool nextColOutOfBounds =
              (${l[o-1]} + 1) >= ${this.outputShape[o-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ps(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const wle={kernelName:sy,backendName:"webgl",kernelFunc:ps};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kl(t){const{inputs:e,backend:n}=t,{real:r,imag:s}=e,o=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(o.dataId),a=ps({inputs:{x:r},backend:n}),l=ps({inputs:{x:s},backend:n});return i.complexTensorInfos={real:a,imag:l},o}const Sle={kernelName:Cw,backendName:"webgl",kernelFunc:kl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FF="return (a < 0.) ? b * a : a;",OF=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Cle(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{alpha:o}=r,i=n.makeTensorInfo([],"float32",kd(o,"float32")),a=oe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Pd(OF,s.shape,i.shape):new Ou(FF,s.shape,i.shape),l=n.runWebGLProgram(a,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),l}const $le={kernelName:h2,backendName:"webgl",kernelFunc:Cle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LF="return (a < 0.) ? b * a : a;",zF=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function kle(t){const{inputs:e,backend:n}=t,{x:r,alpha:s}=e,o=oe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Pd(zF,r.shape,s.shape):new Ou(LF,r.shape,s.shape);return n.runWebGLProgram(o,[r,s],"float32")}const Tle={kernelName:U2,backendName:"webgl",kernelFunc:kle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ad="if (isnan(x)) return x;";function Ct({opSnippet:t,packedOpSnippet:e,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:o})=>{const{x:i}=s,a=o,l=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&n!=null){const f=a.texData.get(i.dataId),p=n(f.values,l);return a.makeTensorInfo(i.shape,l,p)}const c=oe().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let d;return c?d=new al(i.shape,e):d=new di(i.shape,t),a.runWebGLProgram(d,[i],l)}}function Qn({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}){return({inputs:i,backend:a})=>{const{a:l,b:c}=i,d=a;if(r&&l.dtype==="complex64"){const y=d.texData.get(l.dataId),x=d.texData.get(c.dataId),[w,S]=[[y.complexTensorInfos.real,x.complexTensorInfos.real],[y.complexTensorInfos.imag,x.complexTensorInfos.imag]].map(I=>{const[R,_]=I,F={dataId:R.dataId,dtype:R.dtype,shape:l.shape},O={dataId:_.dataId,dtype:_.dtype,shape:c.shape},M=new Ou(t,l.shape,c.shape);return d.runWebGLProgram(M,[F,O],Ur(R.dtype,_.dtype))}),$=kl({inputs:{real:w,imag:S},backend:d});return d.disposeIntermediateTensorInfo(w),d.disposeIntermediateTensorInfo(S),$}const f=o||Ur(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||d.shouldExecuteOnCPU([l,c]))&&s!=null){const y=d.texData.get(l.dataId).values,x=d.texData.get(c.dataId).values,w=l.dtype==="string"?xl(y):y,S=l.dtype==="string"?xl(x):x,[$,I]=s(l.shape,c.shape,w,S,f),R=d.makeTensorInfo(I,f),_=d.texData.get(R.dataId);return _.values=$,R}const p=oe().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let g;return p?g=new Pd(e,l.shape,c.shape,n):g=new Ou(t,l.shape,c.shape),d.runWebGLProgram(g,[l,c],f)}}function Nf(t,e=!1){if(t==="linear")return e?ale:nle;if(t==="relu")return e?ule:sle;if(t==="elu")return e?lle:rle;if(t==="relu6")return e?cle:ole;if(t==="prelu")return e?zF:LF;if(t==="leakyrelu")return e?OF:FF;if(t==="sigmoid")return e?dle:ile;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let BF=class{constructor(e,n,r,s=!1,o=!1,i=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=dr(this.outputShape.length);const d=s?e[1]:e[2],f=Math.ceil(d/2),p=s?"i * 2, rc.y":"rc.y, i * 2",g=o?"rc.z, i * 2":"i * 2, rc.z",y=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],x=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let w="",S="";a&&(l?w=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:c?w=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:w=`vec4 activation(vec4 x) {
          ${a}
        }`,S="result = activation(result);");const $=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let I="rc.x",R="rc.x";e[0]<n[0]?I=`imod(rc.x, ${e[0]})`:n[0]<e[0]&&(R=`imod(rc.x, ${n[0]})`),this.userCode=`
      ${w}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${f}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${I};
        int batchB = ${R};
        for (int i = 0; i < ${f}; i++) {
          vec4 a = getMatrixA(batchA, ${p});
          vec4 b = getMatrixB(batchB, ${g});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${y[0]} * ${x[0]});
          result += (${y[1]} * ${x[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${$}

        ${S}

        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QN={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};let ZN=class{constructor(e,n,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=ct(n,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JN="return a * b;";function DC(t){const{inputs:e,backend:n}=t,{a:r,b:s}=e,o=Ur(r.dtype,s.dtype);if(r.dtype==="complex64"){const a=n.texData.get(r.dataId),l=n.texData.get(s.dataId),c=new ZN(QN.REAL,r.shape,s.shape),d=new ZN(QN.IMAG,r.shape,s.shape),f=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],p=n.runWebGLProgram(c,f,"float32"),g=n.runWebGLProgram(d,f,"float32"),y=kl({inputs:{real:p,imag:g},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g),y}if(n.shouldExecuteOnCPU([r,s])){const a=n.texData.get(r.dataId),l=n.texData.get(s.dataId),[c,d]=kae(r.shape,s.shape,a.values,l.values,o),f=n.makeTensorInfo(d,o),p=n.texData.get(f.dataId);return p.values=c,f}let i;return oe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Pd(JN,r.shape,s.shape):i=new Ou(JN,r.shape,s.shape),n.runWebGLProgram(i,[r,s],o)}const Ile={kernelName:A2,backendName:"webgl",kernelFunc:DC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nle(t,e,n){const r=[dd(t.shape),...hd(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},o=[dd(e),...hd(e)],i=new DF(o,r),a=!0,l=[r],c=n.runWebGLProgram(i,[s],t.dtype,l,a);return{dataId:c.dataId,shape:e,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{shape:o}=r,i=n,a=fe(s.shape),l=UP(o,a),c=fe(l);z(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const d=i.texData.get(s.dataId);return d.isPacked&&!_g(s.shape,l)&&!(d.texture!==null&&_g(d.shape,l))?Nle(s,l,i):(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype})}const Ele={kernelName:q2,backendName:"webgl",kernelFunc:Pe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eE{constructor(e,n){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=e;this.outputShape=[s,i];const a=Math.floor(r/4)*4,l=r%4;let c="sumValue += dot(values, ones);";if(n!=null){const f=1/n;c=`sumValue += dot(values * ${id(f)?f.toPrecision(2):f}, ones);`}let d="";o%r>0&&(d=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Rle=class{constructor(e,n){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=e;this.outputShape=[s,i];let a="0.0",l="";n==="prod"?a="1.0":n==="min"?(a="1.0 / 1e-20",l="min"):n==="max"&&(a="-1.0 / 1e-20",l="max");let c=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="sum"?c="sumValue":n==="prod"?c="prodValue":n==="all"?c="allValue":n==="any"&&(c="anyValue");const d=Math.floor(r/4)*4,f=r%4;let p=`
      if (${n==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${n==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${n==="min"} || ${n==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,g="vec4";n==="all"?(a="1.0",p=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,g="bvec4"):n==="any"&&(a="0.0",p=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,g="bvec4");let y="";o%r>0&&(y=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${y}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${d};
        if (${f===1}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${f===2}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${f===3}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${p}
        }
        setOutput(${c});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _le(t){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const n=e.length?e[e.length-1].outSize:t[1],r=vy(n);e.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return e}function ju(t,e,n,r){const s=_le(t.shape);let o=t;for(let i=0;i<s.length;i++){const{inSize:a,windowSize:l,outSize:c}=s[i];let d,f;n==="mean"?d=i===0?new eE({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:c},a):new eE({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:c}):d=new Rle({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:c},n),f=o,o=r.runWebGLProgram(d,[o],e),f.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(f)}return o}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ple=class{constructor(e,n){this.variableNames=["A"];const r=new Array(e.length);for(let i=0;i<r.length;i++)r[i]=e[n[i]];this.outputShape=r,this.rank=r.length;const s=Kt(this.rank),o=Ale(n);this.userCode=`
    void main() {
      ${s} resRC = getOutputCoords();
      setOutput(getA(${o}));
    }
    `}};function Ale(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let s=0;s<t.length;s++)r[t[s]]=n[s];return r.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dle{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(e.length);for(let d=0;d<r.length;d++)r[d]=e[n[d]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=Kt(this.rank),o=AF("rc",this.rank),i=new Array(this.rank);for(let d=0;d<n.length;d++)i[n[d]]=o[d];const a=`vec2(${i.slice(-2).join()})`,l=`++${o[this.rank-1]} < ${r[this.rank-1]}`,c=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${o[this.rank-1]};
      if(++${o[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sy(t,e,n){const r=oe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Dle(t.shape,e):new Ple(t.shape,e);return n.runWebGLProgram(r,[t],t.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fle(t,e,n,r){const s=e,o=t.shape.length,i=nn(s,t.shape);let a=i;const l=ur(a,o),c=l!=null;let d=t;c&&(d=Sy(t,l,r),a=cr(a.length,o)),xs("sum",a,o);const[f,p]=Fs(d.shape,a);let g=f;n&&(g=ys(f,i));const y=fe(p),w=fe(t.shape)/y,S=Pe({inputs:{x:d},attrs:{shape:[w,y]},backend:r}),$=ly(t.dtype),I=ju(S,$,"sum",r),R=Pe({inputs:{x:I},attrs:{shape:g},backend:r});return r.disposeIntermediateTensorInfo(S),r.disposeIntermediateTensorInfo(I),c&&r.disposeIntermediateTensorInfo(d),R}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cy(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r;return Fle(s,o,i,n)}const Ole={kernelName:pS,backendName:"webgl",kernelFunc:Cy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ir(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{perm:o}=r,i=n,a=s.shape.length,l=new Array(a);for(let d=0;d<l.length;d++)l[d]=s.shape[o[d]];let c;if(i.shouldExecuteOnCPU([s])){const f=i.texData.get(s.dataId).values,p=PC(f,s.shape,s.dtype,o,l);c=i.makeTensorInfo(l,s.dtype);const g=i.texData.get(c.dataId);g.values=p}else c=Sy(s,o,i);return c}const Lle={kernelName:Qh,backendName:"webgl",kernelFunc:Ir};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MF=1e3;function Ag({a:t,b:e,transposeA:n,transposeB:r,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:l=null}){const c=t.shape.length,d=e.shape.length,f=n?t.shape[c-2]:t.shape[c-1],p=r?e.shape[d-1]:e.shape[d-2],g=n?t.shape[c-1]:t.shape[c-2],y=r?e.shape[d-2]:e.shape[d-1],x=t.shape.slice(0,-2),w=e.shape.slice(0,-2),S=fe(x),$=fe(w),R=ct(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([g,y]);z(f===p,()=>`Error in matMul: inner shapes (${f}) and (${p}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${r} must match.`);const _=n?[S,f,g]:[S,g,f],F=r?[$,y,p]:[$,p,y],O=Pe({inputs:{x:t},backend:s,attrs:{shape:_}}),M=Pe({inputs:{x:e},backend:s,attrs:{shape:F}}),B=[O,M],V=Math.max(S,$),A=n?O.shape[1]:O.shape[2],re=o!=null,ae=i!=null,pe=l==="leakyrelu",ye=l!=null?Nf(l,!0):null,ve=re||ae||pe||ye!=null;let $e;if((g===1||y===1)&&A>MF&&ve===!1){let me=O,ge=M;n&&(me=Ir({inputs:{x:O},backend:s,attrs:{perm:[0,2,1]}}),B.push(me)),r&&(ge=Ir({inputs:{x:M},backend:s,attrs:{perm:[0,2,1]}}),B.push(ge));const Q=y!==1,he=y===1;let be=me;Q&&(be=Pe({inputs:{x:me},backend:s,attrs:{shape:[V,A,1]}}),B.push(be));const We=y===1?2:1;let nt=ge;he&&(nt=Pe({inputs:{x:ge},backend:s,attrs:{shape:[V,1,A]}}),B.push(nt));const Xe=DC({inputs:{a:be,b:nt},backend:s});$e=Cy({inputs:{x:Xe},backend:s,attrs:{axis:We,keepDims:!0}}),B.push(Xe)}else{const me=Ur(t.dtype,e.dtype),ge=new BF(_,F,[V,g,y],n,r,re,ye,ae,pe),Q=[O,M];if(o!=null&&Q.push(o),ae&&Q.push(i),pe){const he=s.makeTensorInfo([],"float32",kd(a,"float32"));Q.push(he),B.push(he)}$e=s.runWebGLProgram(ge,Q,me)}const se=Pe({inputs:{x:$e},backend:s,attrs:{shape:R}});B.push($e);for(const me of B)s.disposeIntermediateTensorInfo(me);return se}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zle(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:o,bias:i,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:d,leakyreluAlpha:f}=r;return Ag({a:s,b:o,transposeA:l,transposeB:c,backend:n,bias:i,preluActivationWeights:a,leakyreluAlpha:f,activation:d})}const Ble={kernelName:wg,backendName:"webgl",kernelFunc:zle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tE="return abs(x);";function Mle(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const o=n.texData.get(r.dataId),i=_F(o.values);return n.makeTensorInfo(r.shape,r.dtype,i)}let s;return oe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new al(r.shape,tE):s=new di(r.shape,tE),n.runWebGLProgram(s,[r],r.dtype)}const Vle={kernelName:nw,backendName:"webgl",kernelFunc:Mle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wle=po+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Ule=Ct({opSnippet:Wle}),jle={kernelName:rw,backendName:"webgl",kernelFunc:Ule};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gle=po+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Hle=Ct({opSnippet:Gle}),Kle={kernelName:sw,backendName:"webgl",kernelFunc:Hle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nE="return a + b;",Xle=Qn({opSnippet:nE,packedOpSnippet:nE,supportsComplex:!0,cpuKernelImpl:sae}),qle={kernelName:ny,backendName:"webgl",kernelFunc:Xle};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yle{constructor(e,n){this.outputShape=[],this.outputShape=e,this.variableNames=n.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`float v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Qle=class{constructor(e,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=n.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`vec4 v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${s};
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eg(t){const{inputs:e,backend:n}=t,r=e;if(r.length===1)return ps({inputs:{x:r[0]},backend:n});if(r.length>oe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),c=eg({inputs:r.slice(0,l),backend:n}),d=eg({inputs:r.slice(l),backend:n});return eg({inputs:[c,d],backend:n})}const s=r.map(l=>l.dtype).reduce((l,c)=>Ur(l,c)),o=r.map(l=>l.shape),a=oe().getBool("WEBGL_PACK")?new Qle(r[0].shape,o):new Yle(r[0].shape,o);return n.runWebGLProgram(a,r,s)}const Zle={kernelName:ow,backendName:"webgl",kernelFunc:eg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jle(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,l=nn(o,s.shape);let c=l;const d=ur(c,a);let f=s;d!=null&&(f=Ir({inputs:{x:s},backend:n,attrs:{perm:d}}),c=cr(c.length,a)),xs("all",c,a);const[p,g]=Fs(f.shape,c),y=fe(g),x=Pe({inputs:{x:f},backend:n,attrs:{shape:[-1,y]}}),w=ju(x,x.dtype,"all",n);let S;if(i){const $=ys(p,l);S=Pe({inputs:{x:w},backend:n,attrs:{shape:$}})}else S=Pe({inputs:{x:w},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),d!=null&&n.disposeIntermediateTensorInfo(f),S}const eue={kernelName:iw,backendName:"webgl",kernelFunc:Jle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tue(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,l=nn(o,s.shape);let c=l;const d=ur(c,a);let f=s;d!=null&&(f=Ir({inputs:{x:s},backend:n,attrs:{perm:d}}),c=cr(c.length,a)),xs("any",c,a);const[p,g]=Fs(f.shape,c),y=fe(g),x=Pe({inputs:{x:f},backend:n,attrs:{shape:[-1,y]}}),w=ju(x,x.dtype,"any",n);let S;if(i){const $=ys(p,l);S=Pe({inputs:{x:w},backend:n,attrs:{shape:$}})}else S=Pe({inputs:{x:w},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),d!=null&&n.disposeIntermediateTensorInfo(f),S}const nue={kernelName:aw,backendName:"webgl",kernelFunc:tue};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rue=class{constructor(e,n,r){this.variableNames=["A"];const{windowSize:s,batchSize:o,outSize:i}=e;r||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i];const a=n==="max"?">":"<",l=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sue{constructor(e,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,z(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const o=e[e.length-1],i=Math.ceil(o/n);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,c=Kt(l),d=kr("coords",l);let f,p;if(i===1){p=l+1;const M=Kt(p);f=`
        ${M} sourceLocR = ${M}(${d.join()}, 0);
        ++${d[l-1]};
        ${M} sourceLocG = ${M}(${d.join()}, 0);
        ++${d[l-2]};
        ${M} sourceLocA = ${M}(${d.join()}, 0);
        --${d[l-1]};
        ${M} sourceLocB = ${M}(${d.join()}, 0);
        --${d[l-2]};`}else p=l,f=`
        ${c} sourceLocR = coords;
        ++${d[l-1]};
        ${c} sourceLocG = coords;
        ++${d[l-2]};
        ${c} sourceLocA = coords;
        --${d[l-1]};
        ${c} sourceLocB = coords;
        --${d[l-2]};`;const g=["x","y","z","w","u","v"].slice(0,p),y="."+g[p-1],x=g.map(M=>"int "+M),w=kr("sourceLocR",p-1).concat("inIdx.r"),S=kr("sourceLocG",p-1).concat("inIdx.g"),$=kr("sourceLocB",p-1).concat("inIdx.b"),I=kr("sourceLocA",p-1).concat("inIdx.a"),R=r==="max"?"greaterThan":"lessThan",_=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${S.join()}),
                             getBestIndicesAChannel(${$.join()}),
                             getBestIndicesAChannel(${I.join()})));`,F=`vec4(
            getAChannel(${w.join()}),
            hasNextCol ? getAChannel(${S.join()}) : 0.,
            hasNextRow ? getAChannel(${$.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${I.join()}) : 0.)`,O=s?"":`
      float getBestIndicesAChannel(${x.join()}) {
        return getChannel(getBestIndicesA(${g.join()}),
                                          vec2(${g.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${x.join()}) {
        return getChannel(getA(${g.join()}),
                               vec2(${g.slice(-2).join()}));
      }
      ${O}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${d[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${d[l-2]} < ${a[l-2]-1};
        ${f}
        ivec4 srcIdx = ivec4(sourceLocR${y}, sourceLocG${y},
          sourceLocB${y}, sourceLocA${y}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${F};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${_}
          vec4 candidate = ${F};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${R}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VF(t,e,n,r=null){let s=e.shape[0],o=e.shape[1];r!=null&&(s=r.shape[0],o=r.shape[1]);const i=vy(o),a={windowSize:i,inSize:o,batchSize:s,outSize:Math.ceil(o/i)},l=new rue(a,n,r==null),c=[e];r!=null&&c.push(r);const d=t.runWebGLProgram(l,c,"int32");if(d.shape[1]===1)return d;const f=VF(t,e,n,d);return t.disposeIntermediateTensorInfo(d),f}function WF(t,e,n,r=null){const s=r!=null?r.shape:e.shape,o=s[s.length-1],i=vy(o),a=new sue(s,i,n,r==null),l=r==null?[e]:[e,r],c=t.runWebGLProgram(a,l,"int32");if(c.shape.length===e.shape.length){const d=WF(t,e,n,c);return t.disposeIntermediateTensorInfo(c),d}return c}function UF(t,e,n,r){const s=[n];if(xs("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,e.shape.length),!oe().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const o=[],i=t.texData.get(e.dataId),a=i!==null&&i.isPacked;let l=e;a&&(l=t.unpackTensor(e),o.push(l));const[c,d]=Fs(l.shape,s),f=fe(d),p=Pe({inputs:{x:l},backend:t,attrs:{shape:[-1,f]}});o.push(p);const g=VF(t,p,r);o.push(g);const y=Pe({inputs:{x:g},backend:t,attrs:{shape:c}});return o.forEach(x=>t.disposeIntermediateTensorInfo(x)),y}return WF(t,e,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oue(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o}=r;let i=nn(o,s.shape);const a=ur(i,s.shape.length);let l=s;const c=[];a!=null&&(l=Ir({inputs:{x:s},backend:n,attrs:{perm:a}}),c.push(l),i=cr(i.length,l.shape.length)),xs("argMax",[i[0]],l.shape.length);const d=UF(n,l,i[0],"max");return c.forEach(f=>n.disposeIntermediateTensorInfo(f)),d}const iue={kernelName:lw,backendName:"webgl",kernelFunc:oue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aue(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o}=r;let i=nn(o,s.shape);const a=ur(i,s.shape.length);let l=s;const c=[];a!=null&&(l=Ir({inputs:{x:s},backend:n,attrs:{perm:a}}),c.push(l),i=cr(i.length,l.shape.length)),xs("argMin",[i[0]],l.shape.length);const d=UF(n,l,i[0],"min");return c.forEach(f=>n.disposeIntermediateTensorInfo(f)),d}const lue={kernelName:uw,backendName:"webgl",kernelFunc:aue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uue=po+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,cue=Ct({opSnippet:uue}),due={kernelName:cw,backendName:"webgl",kernelFunc:cue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hue=po+"return log(x + sqrt(x * x + 1.0));",fue=Ct({opSnippet:hue}),pue={kernelName:dw,backendName:"webgl",kernelFunc:fue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mue=po+`
  return atan(x);
`,gue=Ct({opSnippet:mue}),yue={kernelName:hw,backendName:"webgl",kernelFunc:gue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xue=AC+`
  return atan(a, b);
`,vue=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Uu+`
  return result;
`,bue=Qn({opSnippet:xue,packedOpSnippet:vue}),wue={kernelName:pw,backendName:"webgl",kernelFunc:bue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sue=po+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Cue=Ct({opSnippet:Sue}),$ue={kernelName:fw,backendName:"webgl",kernelFunc:Cue};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ef=class{constructor(e,n,r,s=!1,o=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,d=e.dilationWidth,f=e.effectiveFilterHeight,p=e.effectiveFilterWidth,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const x=n==="avg",w=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,S=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let $="0.0";if(x||($="-1.0 / 1e-20"),r){const M=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${g}, ${y});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${f};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p};
                wC += ${d}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${M} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s?o?w:S:`wR * ${p} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const I="max";let R=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(R="avgValue / max(count, 1.0)");const _=Math.floor(i/4)*4,F=i%4,O=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${I}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${g}, ${y});
      const float initializationValue = ${$};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${$});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${f};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${_}; wC += 4) {
            int xC = xCCorner + wC * ${d};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              getValue(batch, xR, xC + 3 * ${d}, d)
            );

            ${O}
          }

          int xC = xCCorner + ${_};
          if (${F===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${O}
          } else if (${F===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              initializationValue,
              initializationValue
            );

            ${O}
          } else if (${F===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              initializationValue
            );

            ${O}
          }
        }
        setOutput(${R});
      }
    `}},FC=class{constructor(e,n,r,s=!1,o=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideDepth,l=e.strideHeight,c=e.strideWidth,d=e.dilationDepth,f=e.dilationHeight,p=e.dilationWidth,g=e.effectiveFilterDepth,y=e.effectiveFilterHeight,x=e.effectiveFilterWidth,w=e.padInfo.front,S=e.padInfo.top,$=e.padInfo.left;this.outputShape=e.outShape;const I=n==="avg";let R="0.0";if(I||(R="-1.0 / 1e-20"),r){const V=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${c});
        const ivec3 pads = ivec3(${w}, ${S}, ${$});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${g};
              wD += ${d}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${y};
                wR += ${f}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${x};
                  wC += ${p}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${V} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s?o?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${y} * ${x} +
                      wR * ${x} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const _="max";let F=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(F="avgValue / max(count, 1.0)");const O=Math.floor(i/4)*4,M=i%4,B=`
      if (${I}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${_}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${c});
      const ivec3 pads = ivec3(${w}, ${S}, ${$});
      const float initializationValue = ${R};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${R});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${g};
            wD += ${d}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${y};
            wR += ${f}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${O}; wC += 4) {
              int xC = xCCorner + wC * ${p};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                getValue(batch, xD, xR, xC + 3 * ${p}, ch)
              );

              ${B}
            }

            int xC = xCCorner + ${O};
            if (${M===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${B}
            } else if (${M===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                initializationValue,
                initializationValue
              );

              ${B}
            } else if (${M===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                initializationValue
              );

              ${B}
            }
          }
        }
        setOutput(${F});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kue(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;tp(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r,c=1;z(Er(i,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const d=ho(s.shape,o,i,c,a,l);if(d.filterWidth===1&&d.filterHeight===1&&Mt(d.inShape,d.outShape))return ps({inputs:{x:s},backend:n});const f=new Ef(d,"avg",!1);return n.runWebGLProgram(f,[s],"float32")}const Tue={kernelName:mw,backendName:"webgl",kernelFunc:kue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iue(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:c}=r,d=[1,1,1],f=ba(s.shape,o,i,d,a,l,c),p=new FC(f,"avg",!1);return n.runWebGLProgram(p,[s],"float32")}const Nue={kernelName:gw,backendName:"webgl",kernelFunc:Iue};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Eue=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,i=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,d=l-1-e.padInfo.top,f=c-1-e.padInfo.left,p=1/(n*r);this.userCode=`
      const ivec2 pads = ivec2(${d}, ${f});
      const float avgMultiplier = float(${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},Rue=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterDepth,r=e.filterHeight,s=e.filterWidth,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,f=e.effectiveFilterDepth,p=e.effectiveFilterHeight,g=e.effectiveFilterWidth,y=f-1-e.padInfo.front,x=p-1-e.padInfo.top,w=g-1-e.padInfo.left,S=1/(n*r*s);this.userCode=`
      const ivec3 pads = ivec3(${y}, ${x}, ${w});
      const float avgMultiplier = float(${S});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${o}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${g};
                wC += ${d}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ue(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,i=o,{filterSize:a,strides:l,pad:c,dimRoundingMode:d}=r,f=[1,1,1],p=ba(i.shape,a,l,f,c,d),g=new Rue(p);return n.runWebGLProgram(g,[s],i.dtype)}const Pue={kernelName:YP,backendName:"webgl",kernelFunc:_ue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aue(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,i=o;tp([s,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,d=ho(i.shape,a,l,1,c),f=new Eue(d);return n.runWebGLProgram(f,[s],i.dtype)}const Due={kernelName:qP,backendName:"webgl",kernelFunc:Aue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fue(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:o}=e,{transposeA:i,transposeB:a}=r;return Ag({a:s,b:o,transposeA:i,transposeB:a,backend:n})}const Oue={kernelName:yw,backendName:"webgl",kernelFunc:Fue};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Lue=class{constructor(e,n,r,s,o,i){this.outputShape=[],this.variableNames=["x","mean","variance"],ct(e,n),ct(e,r);let a="0.0";s!=null&&(ct(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";o!=null&&(ct(e,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zue{constructor(e,n,r,s,o,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],ct(e,n),ct(e,r);let a="vec4(0.0)";s!=null&&(ct(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";o!=null&&(ct(e,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bue=({inputs:t,backend:e,attrs:n})=>{const{x:r,mean:s,variance:o,offset:i,scale:a}=t;z(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),z(i==null||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),z(a==null||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);const c=[r,s,o];let d=null;i!=null&&(d=i.shape,c.push(i));let f=null;a!=null&&(f=a.shape,c.push(a));const p=oe().getBool("WEBGL_PACK_NORMALIZATION")?new zue(r.shape,s.shape,o.shape,d,f,l):new Lue(r.shape,s.shape,o.shape,d,f,l);return e.runWebGLProgram(p,c,c[0].dtype)},Mue={kernelName:n2,backendName:"webgl",kernelFunc:Bue};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Vue=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const n=Kt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=Wue(this.rank);let s;const o=e.map((i,a)=>`sourceLoc.${wv[a]} = start[${a}] + coords.${wv[a]};`);s=`
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${o.join(`
`)}
      `,this.userCode=`
      void main() {
        ${s}
        setOutput(getSource(${r}));
      }
    `}};const wv=["x","y","z","w","u","v"];function Wue(t){if(t===1)return"sourceLoc";if(t<=6)return wv.slice(0,t).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uue{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=Kt(this.rank),r=kr("coords",this.rank),s=kr("sourceLoc",this.rank),o=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${o})`,a=`
      result.x = ${i};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${i};
        --${s[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${i};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${i};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${n}(${e.map((d,f)=>`start[${f}]`).join()});`:e.map((d,f)=>`${s[f]} = ${r[f]} + start[${f}];`).join(`
`);this.userCode=`
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jue(t,e,n,r){const s=r.texData.get(t.dataId),o=r.makeTensorInfo(n,t.dtype),i=r.texData.get(o.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=t.dtype;let a=sC(e,mn(t.shape));s.slice&&(a+=s.slice.flatOffset),i.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||t.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),o}function Dd(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:o,size:i}=r,[a,l]=oC(s,o,i);if(tC(s,a,l),fe(l)===0)return n.makeTensorInfo(l,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||s.dtype==="string"){const f=n.texData.get(s.dataId),p=Oae(f.values,a,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,p)}const{isPacked:c}=n.texData.get(s.dataId),d=rC(s.shape,a,l);if(c||!d){const f=oe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Uue(l):new Vue(l),p=[a];return n.runWebGLProgram(f,[s],s.dtype,p)}return n.uploadToGPU(s.dataId),jue(s,a,l,n)}const Gue={kernelName:aS,backendName:"webgl",kernelFunc:Dd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hue=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:o,crops:i}=r;z(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce(($,I)=>$*I),l=Qf(s.shape,o,a),c=Zf(l.length,o.length),d=Jf(s.shape,o,a),f=cC(i,o.length),p=dC(d,i,o.length),g=[],y=Pe({inputs:{x:s},backend:n,attrs:{shape:l}}),x=Ir({inputs:{x:y},backend:n,attrs:{perm:c}}),w=Pe({inputs:{x},backend:n,attrs:{shape:d}}),S=Dd({inputs:{x:w},backend:n,attrs:{begin:f,size:p}});return g.push(y),g.push(x),g.push(w),g.forEach($=>n.disposeIntermediateTensorInfo($)),S},Kue={kernelName:xw,backendName:"webgl",kernelFunc:Hue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xue(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:o}=e,{size:i}=r,a=n.readSync(s.dataId),l=n.readSync(o.dataId),c=RF(a,l,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,c)}const que={kernelName:vw,backendName:"webgl",kernelFunc:Xue};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yue=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,Que=`
  return float(int(a.r) & int(b.r));
`;function Zue(t){const{inputs:e,backend:n}=t,{a:r,b:s}=e,o=oe().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=oe().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,s])||i===1){const l=n.texData.get(r.dataId).values,c=n.texData.get(s.dataId).values,[d,f]=iae(r.shape,s.shape,l,c,r.dtype),p=n.makeTensorInfo(f,r.dtype),g=n.texData.get(p.dataId);return g.values=d,p}let a;return o?a=new Pd(Yue,r.shape,s.shape,!1):a=new Ou(Que,r.shape,s.shape),n.runWebGLProgram(a,[r,s],r.dtype)}const Jue={kernelName:QP,backendName:"webgl",kernelFunc:Zue};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ece(t){const{inputs:e,backend:n}=t,{s0:r,s1:s}=e,o=n.readSync(r.dataId),i=n.readSync(s.dataId),a=ct(Array.from(o),Array.from(i));return n.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const tce={kernelName:bw,backendName:"webgl",kernelFunc:ece};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nce="return float(a != b);",jF=Qn({opSnippet:nce,cpuKernelImpl:Iae,dtype:"bool"}),rce={kernelName:F2,backendName:"webgl",kernelFunc:jF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rp(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.texData.get(r.dataId);return ps({inputs:{x:s.complexTensorInfos.real},backend:n})}const sce={kernelName:H2,backendName:"webgl",kernelFunc:rp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oce="return float(int(x));";function ice(t,e){const n=new di(t.shape,oce),r=e.runWebGLProgram(n,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sv(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dtype:o}=r;if(o==="complex64"){if(s.dtype==="complex64")return ps({inputs:{x:s},backend:n});const i=ma(s.shape),a=Sv({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),l=kl({inputs:{real:a,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(a),l}if(s.dtype==="complex64"){const i=rp({inputs:{input:s},backend:n}),a=Sv({inputs:{x:i},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(i),a}if(!jP(s.dtype,o)){const i=ps({inputs:{x:s},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:o}}if(n.shouldExecuteOnCPU([s])){const i=n.texData.get(s.dataId).values,[a,l,c]=aae(i,s.shape,s.dtype,o);return n.makeTensorInfo(a,l,c)}if(o==="int32")return ice(s,n);if(o==="bool"){const i=n.makeTensorInfo([],"bool",bi("bool",1)),l=jF({inputs:{a:s,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}const ace={kernelName:ry,backendName:"webgl",kernelFunc:Sv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rE="return ceil(x);",lce=Ct({opSnippet:rE,packedOpSnippet:rE,cpuKernelImpl:lae}),uce={kernelName:ww,backendName:"webgl",kernelFunc:lce};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let cce=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dce{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hce(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{clipValueMin:o,clipValueMax:i}=r;let a;oe().getBool("WEBGL_PACK_CLIP")?a=new dce(s.shape):a=new cce(s.shape);const l=[[o],[i]];return n.runWebGLProgram(a,[s],s.dtype,l)}const fce={kernelName:Sw,backendName:"webgl",kernelFunc:hce};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let pce=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sE(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}function mce(t){const{inputs:e,backend:n}=t,{x:r}=e,s=n.texData.get(r.dataId),o=new pce(r.shape),i=[sE(r,s.complexTensorInfos.real),sE(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(o,i,i[0].dtype)}const gce={kernelName:$w,backendName:"webgl",kernelFunc:mce};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let yce=class{constructor(e){this.outputShape=[],this.outputShape=co(e,1),this.variableNames=e.map((i,a)=>`T${a}`);const n=new Array(e.length-1);n[0]=e[0][1];for(let i=1;i<n.length;i++)n[i]=n[i-1]+e[i][1];const r=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<n.length;i++){const a=n[i-1];r.push(`else if (yC < ${n[i]}) setOutput(getT${i}(yR, yC-${a}));`)}const s=n.length,o=n[n.length-1];r.push(`else setOutput(getT${s}(yR, yC-${o}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xce{constructor(e,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=co(e,n);const r=this.outputShape,s=r.length,o=Kt(s),i=kr("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=e.map((x,w)=>`T${w}`);const l=new Array(e.length-1);l[0]=e[0][n];for(let x=1;x<l.length;x++)l[x]=l[x-1]+e[x][n];const c=a[n],d=a.slice(-2),f=a.join();let p=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${f}), vec2(${d.join()}));
        }`;for(let x=1;x<l.length;x++){const w=l[x-1];p+=`
        if (${c} < ${l[x]}  && ${c} >= ${l[x-1]}) {
          return getChannel(
            getT${x}(${Nm(a,c,w)}),
            vec2(${Nm(d,c,w)}));
        }`}const g=l.length,y=l[l.length-1];p+=`
        return getChannel(
          getT${g}(${Nm(a,c,y)}),
          vec2(${Nm(d,c,y)}));`,this.userCode=`
      float getValue(${a.map(x=>"int "+x)}) {
        ${p}
      }

      void main() {
        ${o} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[s-1]} = ${i[s-1]} + 1;
        if (${i[s-1]} < ${r[s-1]}) {
          result.g = getValue(${i});
        }

        ${i[s-2]} = ${i[s-2]} + 1;
        if (${i[s-2]} < ${r[s-2]}) {
          result.a = getValue(${i});
        }

        ${i[s-1]} = ${i[s-1]} - 1;
        if (${i[s-2]} < ${r[s-2]} &&
            ${i[s-1]} < ${r[s-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}}function Nm(t,e,n){const r=t.indexOf(e);return t.map((o,i)=>i===r?`${o} - ${n}`:o).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $y(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.texData.get(r.dataId);return ps({inputs:{x:s.complexTensorInfos.imag},backend:n})}const vce={kernelName:l2,backendName:"webgl",kernelFunc:$y};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zh(t,e,n){const r=t[0].dtype;if(r==="complex64"){const g=t.map($=>rp({inputs:{input:$},backend:n})),y=t.map($=>$y({inputs:{input:$},backend:n})),x=zh(g,e,n),w=zh(y,e,n),S=kl({inputs:{real:x,imag:w},backend:n});return g.forEach($=>n.disposeIntermediateTensorInfo($)),y.forEach($=>n.disposeIntermediateTensorInfo($)),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),S}let s=n.shouldExecuteOnCPU(t);if(r==="string"&&(s=!0),s){const g=t.map(R=>{const F=[-1,fe(R.shape.slice(e))];return Pe({inputs:{x:R},backend:n,attrs:{shape:F}})}),y=g.map(R=>({vals:n.readSync(R.dataId),shape:R.shape})),x=co(g.map(R=>R.shape),1),w=g[0].shape[0]===1,S=uae(y,x,r,w),$=co(t.map(R=>R.shape),e),I=n.makeTensorInfo($,r,S);return g.forEach(R=>n.disposeIntermediateTensorInfo(R)),I}const o=t.filter(g=>fe(g.shape)>0),i=oe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(o.length===1){const g=i?new di(t[0].shape,sl):new al(t[0].shape,sl);return n.runWebGLProgram(g,t,r)}const a=oe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>a){const g=[];for(let x=0;x<o.length;x+=a){const w=o.slice(x,x+a);g.push(zh(w,e,n))}const y=zh(g,e,n);for(const x of g)n.disposeIntermediateTensorInfo(x);return y}if(i){const g=new xce(o.map(y=>y.shape),e);return n.runWebGLProgram(g,o,r)}const{tensors2D:l,outShape:c}=bce(o,e,n),d=new yce(l.map(g=>g.shape)),f=n.runWebGLProgram(d,l,r);l.forEach(g=>n.disposeIntermediateTensorInfo(g));const p=Pe({inputs:{x:f},attrs:{shape:c},backend:n});return n.disposeIntermediateTensorInfo(f),p}function bce(t,e,n){const r=co(t.map(o=>o.shape),e);return{tensors2D:t.map(o=>Pe({inputs:{x:o},attrs:{shape:[-1,fe(o.shape.slice(e))]},backend:n})),outShape:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GF(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r,o=nn(s,e[0].shape)[0],i=e.map(c=>c.shape);aC(i,o);const a=co(e.map(c=>c.shape),o);if(fe(a)===0)return n.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(c=>fe(c.shape)>0);return l.length===1?ps({inputs:{x:l[0]},backend:n}):zh(l,o,n)}const wce={kernelName:kw,backendName:"webgl",kernelFunc:GF};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HF{constructor(e,n=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const i=e.padInfo.top,a=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,d=e.dilationHeight,f=e.dilationWidth,p=e.filterHeight,g=e.filterWidth,y=Math.floor(e.inChannels/4)*4,x=e.inChannels%4,w=e.dataFormat==="channelsLast",S=w?1:2,$=w?2:3,I=w?3:1;let R="",_="";r&&(s?R=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?R=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:R=`
          float activation(float x) {
            ${r}
          }
        `,_="result = activation(result);");const F=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${R}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${I}];

        ivec2 xRCCorner =
            ivec2(coords[${S}], coords[${$}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p}; wR++) {
          int xR = xRCorner + wR * ${d};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${g}; wC++) {
            int xC = xCCorner + wC * ${f};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${y}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${w}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${x===1}) {

              if (${w}) {
                dotProd +=
                    getX(batch, xR, xC, ${y}) *
                    getW(wR, wC, ${y}, d2);
              } else {
                dotProd +=
                    getX(batch, ${y}, xR, xC) *
                    getW(wR, wC, ${y}, d2);
              }

            } else if (${x===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${y}, d2),
                getW(wR, wC, ${y} + 1, d2)
              );

              if (${w}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${y}),
                  getX(batch, xR, xC, ${y} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${y}, xR, xC),
                  getX(batch, ${y} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${x===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${y}, d2),
                getW(wR, wC, ${y} + 1, d2),
                getW(wR, wC, ${y} + 2, d2)
              );

              if (${w}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${y}),
                  getX(batch, xR, xC, ${y} + 1),
                  getX(batch, xR, xC, ${y} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${y}, xR, xC),
                  getX(batch, ${y} + 1, xR, xC),
                  getX(batch, ${y} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${F}
        ${_}
        setOutput(result);
      }
    `}}class Sce{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const n=e.padInfo.front,r=e.padInfo.top,s=e.padInfo.left,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,f=e.filterDepth,p=e.filterHeight,g=e.filterWidth,y=Math.floor(e.inChannels/4)*4,x=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${o}, ${i}, ${a});
      const ivec3 pads = ivec3(${n}, ${r}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${f}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${g}; wC++) {
              int xC = xCCorner + wC * ${d};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${y}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${x===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${y}) *
                  getW(wF, wR, wC, ${y}, d2);
              } else if (${x===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${y}),
                  getX(batch, xF, xR, xC, ${y} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${y}, d2),
                  getW(wF, wR, wC, ${y} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${x===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${y}),
                  getX(batch, xF, xR, xC, ${y} + 1),
                  getX(batch, xF, xR, xC, ${y} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${y}, d2),
                  getW(wF, wR, wC, ${y} + 1, d2),
                  getW(wF, wR, wC, ${y} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KF{constructor(e,n=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=dr(this.outputShape.length);const i=e.padInfo.left,a=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,f=d;let p=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let w=0;w<d;w++)p+=`
           vec4 xTexelC${w*2};
           int xTexelC${w*2}Ready;
           vec4 xTexelC${w*2+1};
           int xTexelC${w*2+1}Ready;
           vec4 xC${w};`;p+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let w=0;w<d;w++)p+=`
           xTexelC${w*2} = vec4(0.0);
           xTexelC${w*2}Ready = 0;
           xTexelC${w*2+1} = vec4(0.0);
           xTexelC${w*2+1}Ready = 0;
           xC${w} = vec4(0.0);`;p+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let w=0;w<(f+1)/2;w++){const S=w*2;if(p+=`
           xC = xCCorner + ${S*l};
           `,a===1){if(S<d&&(i%2===1?(p+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }
               `,l===1&&S>0?p+=`
                 xC${S} = vec4(xTexelC${S-2}.zw, xTexelC${S}.xy);
                 `:p+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${S} = vec4(previous.zw, xTexelC${S}.xy);
                   } else {
                     xC${S} = vec4(0.0, 0.0, xTexelC${S}.xy);
                   }
                   `):p+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 xC${S} = xTexelC${S};
                 `,S+1<d)){const $=i%2===0?Jb(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(p+=`
                   xCOffset = xC + imod(pads[1], 2) + ${$};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                     xTexelC${S+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${S+1}.zw = vec2(0.0);
                     }
                     xTexelC${S+1}Ready = 1;
                   }
                   `,l>1?p+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${S+1} = vec4(previous.zw, xTexelC${S+1}.xy);
                     } else {
                      xC${S+1} = vec4(0.0, 0.0, xTexelC${S+1}.xy);
                     }
                     `:p+=`
                     xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.xy);
                     `):$===1?p+=`
                     xC${S+1} = xTexelC${S};
                     `:p+=`
                     xCOffset = xC + ${$};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                       xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${S+1}.zw = vec2(0.0);
                       }
                       xTexelC${S+1}Ready = 1;
                     }

                     xC${S+1} = xTexelC${S+1};
                     `}}else S<d&&(i%2===1?(p+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${S+1}Ready == 0) {
                   xTexelC${S+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${S+1}.zw = vec2(0.0);
                   }
                   xTexelC${S+1}Ready = 1;
                 }

                 xC${S} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
               `,S+1<d&&(p+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${S+1} = vec4(xTexelC${S+1}.xy, final.xy);
                 `)):(p+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                   xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S+1}.zw = vec2(0.);
                   }
                   xTexelC${S+1}Ready = 1;
                 }

                 xC${S} = vec4(
                   xTexelC${S}.xy, xTexelC${S+1}.xy);
               `,S+1<d&&(p+=`
                   xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
                 `)));S<d&&(p+=`
             wTexel = getW(r, ${S}, d1, d2);
             dotProd += xC${S}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${S}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,S+1<d&&(p+=`
               wTexel = getW(r, ${S+1}, d1, d2);
               dotProd += xC${S+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${S+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}p+=`
     }
   `,p+=`
     }
   `,p+=`
     }
   `;let g="",y="";r&&(s?g=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:o?g=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:g=`vec4 activation(vec4 x) {
           ${r}
         }`,y="result = activation(result);");const x=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${g}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${p}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${x}
         ${y}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cce{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=dr(this.outputShape.length);const{dataFormat:r}=n,s=Rr(),o=r==="channelsLast",i=o?1:2,a=o?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let c="";for(let d=0;d<=1;d++)for(let f=0;f<=1;f++)c+=`
          blockIndex = rc.z + ${f};
          pos = rc.y + ${d};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${o}) {
                  innerDims = vec2(d1, ch);
                  result[${d*2+f}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${d*2+f}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${s.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dg(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&n===1&&t[0]>1?[t[0],1]:null}function XF({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const l=t.shape,c=r.texData.get(t.dataId),d=n.inChannels,f=l[0]*l[1]*l[2],p=n.outChannels,g=n.dataFormat==="channelsLast",y=!1,x=!1;let w;const S=[];if(o!=null){const R=Dg(o.shape,g);R!=null&&(o=Pe({inputs:{x:o},backend:r,attrs:{shape:R}}),S.push(o))}if(s!=null){const R=Dg(s.shape,g);R!=null&&(s=Pe({inputs:{x:s},backend:r,attrs:{shape:R}}),S.push(s))}if(!((f===1||p===1)&&d>MF)&&c.isPacked&&g&&c.texture!=null&&l[2]%2!==0&&Mt(c.shape.slice(-3),l.slice(-3))){const R=l[0]*l[1]*(l[2]+1),_={dataId:t.dataId,shape:[1,R,n.inChannels],dtype:t.dtype},F=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,z(_g(c.shape,_.shape),()=>`packed reshape ${c.shape} to ${_.shape} isn't free`);const O=Pe({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});S.push(O);const M=Ag({a:_,b:O,backend:r,transposeA:y,transposeB:x,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),B=r.texData.get(M.dataId);z(B.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=F,B.shape=n.outShape,w=ps({inputs:{x:M},backend:r}),w.shape=n.outShape,S.push(M)}else{const R=n.outHeight*n.outWidth,_=Pe({inputs:{x:t},backend:r,attrs:{shape:g?[n.batchSize,R,n.inChannels]:[n.batchSize,n.inChannels,R]}}),F=Pe({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),O=Ag({a:g?_:F,b:g?F:_,transposeA:!g,transposeB:x,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i});w=Pe({inputs:{x:O},backend:r,attrs:{shape:n.outShape}}),S.push(_),S.push(F),S.push(O)}for(const R of S)r.disposeIntermediateTensorInfo(R);return w}function qF({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:d,outWidth:f,outHeight:p,dataFormat:g}=n,y=g==="channelsLast",x=l*c*d,w=p*f,S=[n.batchSize,x,w],$=!0,I=!1,R=[];if(o!=null){const se=Dg(o.shape,y);se!=null&&(o=Pe({inputs:{x:o},backend:r,attrs:{shape:se}}),R.push(o))}if(s!=null){const se=Dg(s.shape,y);se!=null&&(s=Pe({inputs:{x:s},backend:r,attrs:{shape:se}}),R.push(s))}const _=Pe({inputs:{x:e},backend:r,attrs:{shape:[1,x,fe(e.shape)/x]}});R.push(_);const F=new Cce(S,n),O=[t.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],M=r.runWebGLProgram(F,[t],"float32",O),B=Pe({inputs:{x:M},backend:r,attrs:{shape:S}});R.push(M),R.push(B);const V=s!=null,A=o!=null,re=a==="leakyrelu",ae=a?Nf(a,!0):null,pe=new BF(y?B.shape:_.shape,y?_.shape:B.shape,y?[n.batchSize,w,n.outChannels]:[n.batchSize,n.outChannels,w],$,I,V,ae,A,re),ye=y?[B,_]:[_,B];if(s&&ye.push(s),A&&ye.push(o),re){const se=r.makeTensorInfo([],"float32",kd(i,"float32"));ye.push(se),R.push(se)}const ve=r.runWebGLProgram(pe,ye,"float32"),$e=Pe({inputs:{x:ve},backend:r,attrs:{shape:n.outShape}});R.push(ve);for(const se of R)r.disposeIntermediateTensorInfo(se);return $e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ce(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dataFormat:l,dilations:c,dimRoundingMode:d}=r,f=Bo(l),p=kn(s.shape,o.shape,i,c,a,d,!1,f);let g;if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))g=XF({x:s,filter:o,convInfo:p,backend:n});else if(p.strideWidth<=2&&f==="channelsLast"&&oe().getBool("WEBGL_EXP_CONV")){const x=new KF(p),w=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];g=n.runWebGLProgram(x,[s,o],"float32",w)}else if(oe().getBool("WEBGL_CONV_IM2COL"))g=qF({x:s,filter:o,convInfo:p,backend:n});else{const x=new HF(p);g=n.runWebGLProgram(x,[s,o],"float32")}const y=Pe({inputs:{x:g},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(g),y}const kce={kernelName:Tw,backendName:"webgl",kernelFunc:$ce};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Tce=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,o=e.padInfo.left,i=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Ice=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,i=e.dataFormat==="channelsLast",a=n-1-e.padInfo.top,l=r-1-e.padInfo.left,c=i?1:2,d=i?2:3,f=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${f}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${d}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Nce=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideDepth,r=e.strideHeight,s=e.strideWidth,o=e.padInfo.front,i=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${n} - ${o};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${i};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${s} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Ece=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterDepth,r=e.filterHeight,s=e.filterWidth,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,l=n-1-e.padInfo.front,c=r-1-e.padInfo.top,d=s-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${n}; wF++) {
          float dyF = float(dyFCorner + wF) / ${o}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${n} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${s}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rce(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:i,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:d}=r,f=Bo(l),p=kn(s.shape,d,i,1,a,c,!1,f),g=new Tce(p);return n.runWebGLProgram(g,[s,o],"float32")}const _ce={kernelName:Iw,backendName:"webgl",kernelFunc:Rce};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pce{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=dr(this.outputShape.length);const n=e.filterHeight,r=e.filterWidth,s=n-1-e.padInfo.top,o=r-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ace(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{inputShape:i,strides:a,pad:l,dataFormat:c,dimRoundingMode:d}=r,f=Bo(c),p=kn(i,o.shape,a,1,l,d,!1,f);if(oe().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&f==="channelsLast"){const g=[[p.strideHeight,p.strideWidth]],y=new Pce(p);return n.runWebGLProgram(y,[s,o],"float32",g)}else{const g=new Ice(p);return n.runWebGLProgram(g,[s,o],"float32")}}const Dce={kernelName:Nw,backendName:"webgl",kernelFunc:Ace};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fce(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dilations:l}=r,c=$l(s.shape,o.shape,i,l,a),d=new Sce(c);return n.runWebGLProgram(d,[s,o],"float32")}const Oce={kernelName:Ew,backendName:"webgl",kernelFunc:Fce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lce(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:i,pad:a,filterShape:l}=r,c=$l(s.shape,l,i,1,a),d=new Nce(c);return n.runWebGLProgram(d,[s,o],"float32")}const zce={kernelName:ZP,backendName:"webgl",kernelFunc:Lce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bce(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{pad:i,strides:a,inputShape:l}=r,c=$l(l,o.shape,a,1,i),d=new Ece(c);return n.runWebGLProgram(d,[s,o],"float32")}const Mce={kernelName:Rw,backendName:"webgl",kernelFunc:Bce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vce=Ad+`
  return cos(x);
`,Wce=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Uu}
  return result;
`,Uce=Ct({opSnippet:Vce,packedOpSnippet:Wce}),jce={kernelName:_w,backendName:"webgl",kernelFunc:Uce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gce=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Hce=Ct({opSnippet:Gce}),Kce={kernelName:Pw,backendName:"webgl",kernelFunc:Hce};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Xce=class{constructor(e,n,r,s,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,l,c]=e,[d]=n,[f,p]=r;this.outputShape=[d,f,p,c];const g=s==="bilinear"?1:0,[y,x]=[`${a-1}.0`,`${l-1}.0`],[w,S,$]=f>1?[`${(a-1)/(f-1)}`,"(y2-y1) * height_ratio",`y1*${y} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${y}`],[I,R,_]=p>1?[`${(l-1)/(p-1)}`,"(x2-x1) * width_ratio",`x1*${x} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${x}`];this.userCode=`
      const float height_ratio = float(${w});
      const float width_ratio = float(${I});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${S};
        float width_scale = ${R};

        float in_y = ${$};
        if( in_y < 0.0 || in_y > ${y} ) {
          setOutput(float(${o}));
          return;
        }
        float in_x = ${_};
        if( in_x < 0.0 || in_x > ${x} ) {
          setOutput(float(${o}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${g} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qce=t=>{const{inputs:e,backend:n,attrs:r}=t,{image:s,boxes:o,boxInd:i}=e,{cropSize:a,method:l,extrapolationValue:c}=r,d=new Xce(s.shape,o.shape,a,l,c);return n.runWebGLProgram(d,[s,o,i],"float32")},Yce={kernelName:Fw,backendName:"webgl",kernelFunc:qce};var Rf;(function(t){t.Prod="*",t.Sum="+"})(Rf||(Rf={}));let oE=class{constructor(e,n,r,s){this.op=e,this.outputShape=n,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,i=this.op===Rf.Prod?"1.0":"0.0",a=r?i:`getX(${iE(o,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",d="";r?(c=s?`end != ${l-1}`:"end != 0",d=s?"end + 1":"end - 1"):(c=s?`end + pow2 < ${l}`:"end >= pow2",d=s?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Kt(o)} coords = getOutputCoords();
        int end = ${aE(o,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${d};
          ${aE(o,"coords",this.op)} = idx;
          val ${this.op}= getX(${iE(o,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function iE(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.x, ${e}.y`;if(t===3)return`${e}.x, ${e}.y, ${e}.z`;if(t===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function aE(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.y`;if(t===3)return`${e}.z`;if(t===4)return`${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YF(t,e,n,r,s,o){const i=e.shape.length,a=ur([r],i);let l=e;a!=null&&(l=Ir({inputs:{x:e},backend:n,attrs:{perm:a}}));const c=cr(1,i)[0];if(c!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const d=l.shape[c];let f=ps({inputs:{x:l},backend:n});for(let p=0;p<=Math.ceil(Math.log2(d))-1;p++){const g=new oE(t,l.shape,!1,o),y=[[p]],x=f;f=n.runWebGLProgram(g,[f],f.dtype,y),n.disposeIntermediateTensorInfo(x)}if(s){const p=new oE(t,l.shape,s,o),g=f;f=n.runWebGLProgram(p,[f],f.dtype),n.disposeIntermediateTensorInfo(g)}if(a!=null){const p=Yf(a),g=Ir({inputs:{x:f},backend:n,attrs:{perm:p}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(l),g}return f}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qce(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,exclusive:i,reverse:a}=r;return YF(Rf.Prod,s,n,o,i,a)}const Zce={kernelName:Aw,backendName:"webgl",kernelFunc:Qce};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jce(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,exclusive:i,reverse:a}=r;return YF(Rf.Sum,s,n,o,i,a)}const ede={kernelName:Dw,backendName:"webgl",kernelFunc:Jce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tde(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:o}=e,{size:i,binaryOutput:a}=r;if(s.shape.length===1){const l=n.readSync(s.dataId),c=n.readSync(o.dataId),d=RF(l,c,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,d)}else if(s.shape.length===2){const l=n.bufferSync(s),c=n.bufferSync(o),d=oae(l,c,i,a);return n.makeTensorInfo(d.shape,o.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const nde={kernelName:Ow,backendName:"webgl",kernelFunc:tde};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rde=class{constructor(e,n,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=n,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${n};
      int offset_h = imod(h, ${n});
      int in_w = w / ${n};
      int offset_w = imod(w, ${n});
      int offset_d = (offset_h * ${n} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sde(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockSize:o,dataFormat:i}=r,a=s.shape[0],l=i==="NHWC"?s.shape[1]:s.shape[2],c=i==="NHWC"?s.shape[2]:s.shape[3],d=i==="NHWC"?s.shape[3]:s.shape[1],f=l*o,p=c*o,g=d/(o*o),y=i==="NHWC"?[a,f,p,g]:[a,g,f,p],x=new rde(y,o,i);return n.runWebGLProgram(x,[s],s.dtype)}const ode={kernelName:Lw,backendName:"webgl",kernelFunc:sde};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let QF=class{constructor(e,n=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=dr(this.outputShape.length);const i=e.filterHeight,a=e.filterWidth,l=e.outChannels/e.inChannels;let c="",d="";r&&(s?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:c=`
          float activation(float x) {
            ${r}
          }
        `,d="result = activation(result);");const f=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${f}
        ${d}
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZF{constructor(e,n=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=dr(this.outputShape.length);const i=e.outChannels/e.inChannels,a=e.padInfo.left,l=e.strideWidth,c=e.dilationWidth,d=e.filterHeight,f=e.filterWidth,p=f;let g=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let S=0;S<f;S++)g+=`
          vec4 xTexelC${S*2};
          int xTexelC${S*2}Ready;
          vec4 xTexelC${S*2+1};
          int xTexelC${S*2+1}Ready;
          vec4 xC${S};`;g+=`
    for (int r = 0; r < ${d}; r++) {
      `;for(let S=0;S<f;S++)g+=`
          xTexelC${S*2} = vec4(0.0);
          xTexelC${S*2}Ready = 0;
          xTexelC${S*2+1} = vec4(0.0);
          xTexelC${S*2+1}Ready = 0;
          xC${S} = vec4(0.0);`;g+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let S=0;S<(p+1)/2;S++){const $=S*2;if(g+=`
          xC = xCCorner + ${$*c};
          `,l===1){if($<f&&(a%2===1?(g+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }
              `,c===1&&$>0?g+=`
                xC${$} = vec4(xTexelC${$-2}.zw, xTexelC${$}.xy);
                `:g+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${$} = vec4(previous.zw, xTexelC${$}.xy);
                  } else {
                    xC${$} = vec4(0.0, 0.0, xTexelC${$}.xy);
                  }
                  `):g+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                xC${$} = xTexelC${$};
                `,$+1<f)){const I=a%2===0?Jb(c):c;c%2===0&&a%2===1||c%2!==0&&a%2!==1?(g+=`
                  xCOffset = xC + imod(pads[1], 2) + ${I};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                    xTexelC${$+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${$+1}.zw = vec2(0.0);
                    }
                    xTexelC${$+1}Ready = 1;
                  }
                  `,c>1?g+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${$+1} = vec4(previous.zw, xTexelC${$+1}.xy);
                    } else {
                     xC${$+1} = vec4(0.0, 0.0, xTexelC${$+1}.xy);
                    }
                    `:g+=`
                    xC${$+1} = vec4(xTexelC${$}.zw, xTexelC${$+1}.xy);
                    `):I===1?g+=`
                    xC${$+1} = xTexelC${$};
                    `:g+=`
                    xCOffset = xC + ${I};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                      xTexelC${$+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${$+1}.zw = vec2(0.0);
                      }
                      xTexelC${$+1}Ready = 1;
                    }

                    xC${$+1} = xTexelC${$+1};
                    `}}else $<f&&(a%2===1?(g+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${$+1}Ready == 0) {
                  xTexelC${$+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${$+1}.zw = vec2(0.0);
                  }
                  xTexelC${$+1}Ready = 1;
                }

                xC${$} = vec4(xTexelC${$}.zw, xTexelC${$+1}.zw);
              `,$+1<f&&(g+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${$+1} = vec4(xTexelC${$+1}.xy, final.xy);
                `)):(g+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                  xTexelC${$+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$+1}.zw = vec2(0.);
                  }
                  xTexelC${$+1}Ready = 1;
                }

                xC${$} = vec4(
                  xTexelC${$}.xy, xTexelC${$+1}.xy);
              `,$+1<f&&(g+=`
                  xC${$+1} = vec4(xTexelC${$}.zw, xTexelC${$+1}.zw);
                `)));$<f&&(g+=`
            wTexel = getW(r, ${$}, d1, q);
            dotProd += xC${$} * vec4(wTexel.xz, wTexel.xz);
          `,$+1<f&&(g+=`
              wTexel = getW(r, ${$+1}, d1, q);
              dotProd += xC${$+1} * vec4(wTexel.xz, wTexel.xz);
            `))}g+=`
    }
  `,g+=`
      }
    `;let y="",x="";r&&(s?y=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?y=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:y=`vec4 activation(vec4 x) {
          ${r}
        }`,x="result = activation(result);");const w=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${y}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${g}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${w}
        ${x}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ide(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dilations:l,dimRoundingMode:c}=r;let d=l;d==null&&(d=[1,1]),z(Er(i,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);const f=kn(s.shape,o.shape,i,d,a,c,!0);let p;oe().getBool("WEBGL_PACK_DEPTHWISECONV")&&f.strideWidth<=2&&f.outChannels/f.inChannels===1?p=new ZF(f):p=new QF(f);const g=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];return n.runWebGLProgram(p,[s,o],"float32",g)}const ade={kernelName:zw,backendName:"webgl",kernelFunc:ide};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let lde=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,o=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},ude=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,i=n-1-e.padInfo.top,a=r-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cde(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:i,dilations:a,pad:l,dimRoundingMode:c,filterShape:d}=r,f=kn(s.shape,d,i,a,l,c,!0),p=new lde(f);return n.runWebGLProgram(p,[s,o],"float32")}const dde={kernelName:Bw,backendName:"webgl",kernelFunc:cde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hde(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{strides:i,dilations:a,pad:l,dimRoundingMode:c,inputShape:d}=r,f=kn(d,o.shape,i,a,l,c,!0),p=new ude(f);return n.runWebGLProgram(p,[s,o],"float32")}const fde={kernelName:Mw,backendName:"webgl",kernelFunc:hde};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let pde=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mde(t){const{inputs:e,backend:n}=t,{x:r}=e,s=[...r.shape,...r.shape],o=fe(r.shape),i=Pe({inputs:{x:r},backend:n,attrs:{shape:[o]}}),a=new pde(o),l=n.runWebGLProgram(a,[i],i.dtype),c=Pe({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),c}const gde={kernelName:Vw,backendName:"webgl",kernelFunc:mde};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let yde=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:n,inWidth:r,padInfo:s,strideHeight:o,strideWidth:i,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:d}=e,{top:f,left:p}=s;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${i});
      const ivec2 pads = ivec2(${f}, ${p});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${n}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${d};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xde(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dilations:l}=r,c=Xf(s.shape,o.shape,i,a,"NHWC",l);let d;const f=new yde(c);d=n.runWebGLProgram(f,[s,o],"float32");const p=Pe({inputs:{x:d},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(d),p}const vde={kernelName:Ww,backendName:"webgl",kernelFunc:xde};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bde(t){const{inputs:e,backend:n,attrs:r}=t,{equation:s}=r,o=e,{allDims:i,summedDims:a,idDims:l}=bC(s,o.length);SC(i.length,l,o);const{path:c,steps:d}=CC(a,l),f=d.length;let p=null,g=i.length;const y=[];for(let x=0;x<f;++x){for(const w of d[x]){const{permutationIndices:S,expandDims:$}=wC(g,l[w]);let I;$C(S)?I=o[w]:(I=Ir({inputs:{x:o[w]},backend:n,attrs:{perm:S}}),y.push(I));const R=I.shape.slice();for(let _=0;_<$.length;++_)R.splice($[_],0,1);Mt(I.shape,R)||(I=Pe({inputs:{x:I},backend:n,attrs:{shape:R}}),y.push(I)),p===null?p=I:(p=DC({inputs:{a:I,b:p},backend:n}),y.push(p))}x<f-1&&(c[x]>=0&&(p=Cy({inputs:{x:p},backend:n,attrs:{axis:c[x]-(i.length-g),keepDims:!1}}),y.push(p)),g--)}for(const x of y)x!==p&&n.disposeIntermediateTensorInfo(x);return p}const wde={kernelName:jw,backendName:"webgl",kernelFunc:bde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sde="return (x >= 0.0) ? x : (exp(x) - 1.0);",Cde=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,$de=Ct({opSnippet:Sde,packedOpSnippet:Cde}),kde={kernelName:Gw,backendName:"webgl",kernelFunc:$de};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tde="return (b >= 0.0) ? a : a * (b + 1.0);",Ide=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Nde=t=>{const{inputs:e,backend:n}=t,{dy:r,y:s}=e,o=oe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Pd(Ide,r.shape,s.shape):new Ou(Tde,r.shape,s.shape);return n.runWebGLProgram(o,[r,s],r.dtype)},Ede={kernelName:eA,backendName:"webgl",kernelFunc:Nde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rde=`
  return vec4(equal(a, b));
`,_de="return float(a == b);",Pde=Qn({opSnippet:_de,packedOpSnippet:Rde,dtype:"bool",cpuKernelImpl:cae}),Ade={kernelName:Kw,backendName:"webgl",kernelFunc:Pde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dde=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${pC};
  float a1 = ${mC};
  float a2 = ${gC};
  float a3 = ${yC};
  float a4 = ${xC};
  float a5 = ${vC};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Fde=Ct({opSnippet:Dde}),Ode={kernelName:Hw,backendName:"webgl",kernelFunc:Fde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lde=Ad+`
  return exp(x);
`,zde=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,JF=Ct({opSnippet:Lde,packedOpSnippet:zde,cpuKernelImpl:dae,dtype:"float32"}),Bde={kernelName:Xw,backendName:"webgl",kernelFunc:JF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cv(t){const{inputs:e,attrs:n,backend:r}=t,{dim:s}=n,{input:o}=e,i=o.shape.length,a=o.shape.slice();let l=s;return s<0&&(z(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),a.splice(l,0,1),Pe({inputs:{x:o},backend:r,attrs:{shape:a}})}const Mde={kernelName:qw,backendName:"webgl",kernelFunc:Cv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lE="return exp(x) - 1.0;",Vde=Ct({opSnippet:lE,packedOpSnippet:lE,cpuKernelImpl:hae}),Wde={kernelName:Yw,backendName:"webgl",kernelFunc:Vde};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let uE=class{constructor(e,n,r){this.variableNames=["real","imag"];const s=n[1];this.outputShape=n;const o=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${s}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${o};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eO(t,e,n){const r=n.texData.get(t.dataId),s=fe(t.shape),o=t.shape[t.shape.length-1],i=s/o,a=Pe({inputs:{x:t},backend:n,attrs:{shape:[i,o]}}),l=a.shape,c=new uE("real",l,e),d=new uE("imag",l,e),f=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],p=n.runWebGLProgram(c,f,"float32"),g=n.runWebGLProgram(d,f,"float32"),y=kl({inputs:{real:p,imag:g},backend:n});n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g);const x=Pe({inputs:{x:y},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(y),x}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ude(t){const{inputs:e,backend:n}=t,{input:r}=e;return eO(r,!1,n)}const jde={kernelName:Qw,backendName:"webgl",kernelFunc:Ude};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Gde=class{constructor(e,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sp(t){const{backend:e,attrs:n}=t,{shape:r,value:s}=n;let{dtype:o}=n;if(o=o||$d(s),o==="string"){const i=En(o,fe(r));return i.fill(s),e.makeTensorInfo(r,o,i)}else{const i=new Gde(r,s),a=[[s]];return e.runWebGLProgram(i,[],o,a)}}const Hde={kernelName:Zw,backendName:"webgl",kernelFunc:sp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Kde=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];const n=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${n} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${n}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xde={kernelName:Jw,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,r=e,s=new Kde(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cE="return floor(x);",qde=Ct({opSnippet:cE,packedOpSnippet:cE,cpuKernelImpl:fae}),Yde={kernelName:e2,backendName:"webgl",kernelFunc:qde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qde=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Zde=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Jde=Qn({opSnippet:Qde,packedOpSnippet:Zde,dtype:"int32"}),ehe={kernelName:t2,backendName:"webgl",kernelFunc:Jde};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let the=class{constructor(e){this.variableNames=["A"];const n=Rr(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);

        vec4 values = ${n.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nhe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=Rr(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${r}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rhe={kernelName:bg,backendName:"webgl",kernelFunc:she};let kc,nx=oe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function she(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:s}=e;const{numChannels:o}=r,i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,c]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],d=[c,l],f=[c,l,o];if(a||i){const x=oe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(kc==null||x!==nx)&&(nx=x,kc=document.createElement("canvas").getContext("2d",{willReadFrequently:nx})),kc.canvas.width=l,kc.canvas.height=c,kc.drawImage(s,0,0,l,c),s=kc.canvas}const p=n.makeTensorInfo(d,"int32");n.texData.get(p.dataId).usage=Rs.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId),s);const g=oe().getBool("WEBGL_PACK")?new nhe(f):new the(f),y=n.runWebGLProgram(g,[p],"int32");return n.disposeData(p.dataId),y}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ohe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:d,dilations:f,dimRoundingMode:p,activation:g,leakyreluAlpha:y}=r,x=Bo(d),w=kn(s.shape,o.shape,l,f,c,p,!1,x);let S;const $=[],I=i!=null,R=a!=null,_=g==="leakyrelu",F=()=>{const M=[s,o],B=(V,A)=>{if(A==="NCHW"&&V.shape.length===1&&V.shape[0]!==1){const re=Pe({inputs:{x:V},backend:n,attrs:{shape:[V.shape[0],1,1]}});return $.push(re),re}return V};if(I&&M.push(B(i,d)),R&&M.push(B(a,d)),_){const V=n.makeTensorInfo([],"float32",kd(y,"float32"));M.push(V),$.push(V)}return M};if(w.filterHeight===1&&w.filterWidth===1&&w.dilationHeight===1&&w.dilationWidth===1&&w.strideHeight===1&&w.strideWidth===1&&(w.padInfo.type==="SAME"||w.padInfo.type==="VALID"))S=XF({x:s,filter:o,convInfo:w,backend:n,bias:i,activation:g,preluActivationWeights:a,leakyreluAlpha:y});else if(w.strideWidth<=2&&x==="channelsLast"&&oe().getBool("WEBGL_EXP_CONV")){const M=g?Nf(g,!0):null,B=new KF(w,I,M,R,_),V=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],A=F();S=n.runWebGLProgram(B,A,"float32",V)}else if(oe().getBool("WEBGL_CONV_IM2COL"))S=qF({x:s,filter:o,convInfo:w,backend:n,bias:i,activation:g,preluActivationWeights:a,leakyreluAlpha:y});else{const M=g?Nf(g,!1):null,B=new HF(w,I,M,R,_),V=F();S=n.runWebGLProgram(B,V,"float32")}const O=Pe({inputs:{x:S},backend:n,attrs:{shape:w.outShape}});return $.push(S),$.forEach(M=>n.disposeIntermediateTensorInfo(M)),O}const ihe={kernelName:Sg,backendName:"webgl",kernelFunc:ohe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ahe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=e,{strides:l,pad:c,dilations:d,dimRoundingMode:f,activation:p,leakyreluAlpha:g}=r,y=[];let x=d;x==null&&(x=[1,1]),z(Er(l,x),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${x}'`);const w=kn(s.shape,o.shape,l,x,c,f,!0),S=oe().getBool("WEBGL_PACK_DEPTHWISECONV")&&w.strideWidth<=2&&w.outChannels/w.inChannels===1,$=p?Nf(p,S):null,I=[s,o],R=i!=null,_=a!=null,F=p==="leakyrelu";if(R&&I.push(i),_&&I.push(a),F){const V=n.makeTensorInfo([],"float32",kd(g,"float32"));I.push(V),y.push(V)}let O;S?O=new ZF(w,R,$,_,F):O=new QF(w,R,$,_,F);const M=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],B=n.runWebGLProgram(O,I,"float32",M);return y.forEach(V=>n.disposeIntermediateTensorInfo(V)),B}const lhe={kernelName:Cg,backendName:"webgl",kernelFunc:ahe};let uhe=class{constructor(e,n,r,s){this.sliceDim=e,this.strides=n,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const o=Kt(r.length);let i=`
    int index;`;for(let a=0;a<this.sliceDim;a++)i+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${o} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function che(t){const{inputs:e,backend:n}=t,{params:r,indices:s}=e,o=s.shape,i=o[o.length-1],a=fe(r.shape),[l,c,d,f]=eC(r,s),p=Pe({inputs:{x:s},backend:n,attrs:{shape:[c,i]}}),g=Pe({inputs:{x:r},backend:n,attrs:{shape:[fe(r.shape)/d,d]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const S=n.readSync(s.dataId),$=n.bufferSync(r),I=pae(S,$,r.dtype,c,i,d,f,r.shape,a);return n.makeTensorInfo(l,r.dtype,I.values)}const y=new uhe(i,f,[c,d],r.shape),x=n.runWebGLProgram(y,[g,p],g.dtype),w=Pe({inputs:{x},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(x),w}const dhe={kernelName:s2,backendName:"webgl",kernelFunc:che};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let hhe=class{constructor(e,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;const r=Kt(this.rank),s=fhe(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${s}));
      }
    `}};function fhe(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<t.length;s++)s===2?r.push("index"):r.push(`${n[s]}`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tO(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,indices:o}=e,{axis:i,batchDims:a}=r,l=nn(i,s.shape)[0];if(oe().get("DEBUG")){const $=n.readSync(o.dataId),I=s.shape[l];for(let R=0;R<$.length;++R){const _=$[R];z(_<=I-1&&_>=0,()=>`GatherV2: the index value ${_} is not in [0, ${I-1}]`)}}const c=IC(s,o,l,a),d=fe(o.shape),f=[],p=Pe({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),g=Pe({inputs:{x:o},backend:n,attrs:{shape:[c.batchSize,d/c.batchSize]}});f.push(p),f.push(g);const y=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([s,o])||s.dtype==="string"){const $=n.bufferSync(g),I=n.bufferSync(p),R=mae(I,$,y);return f.forEach(_=>n.disposeIntermediateTensorInfo(_)),n.makeTensorInfo(c.outputShape,R.dtype,R.values)}const x=new hhe(p.shape,y),w=n.runWebGLProgram(x,[p,g],p.dtype);f.push(w);const S=Pe({inputs:{x:w},backend:n,attrs:{shape:c.outputShape}});return f.forEach($=>n.disposeIntermediateTensorInfo($)),S}const phe={kernelName:r2,backendName:"webgl",kernelFunc:tO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mhe="return float(a > b);",ghe=`
  return vec4(greaterThan(a, b));
`,yhe=Qn({opSnippet:mhe,packedOpSnippet:ghe,cpuKernelImpl:gae,dtype:"bool"}),xhe={kernelName:o2,backendName:"webgl",kernelFunc:yhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vhe="return float(a >= b);",bhe=`
  return vec4(greaterThanEqual(a, b));
`,whe=Qn({opSnippet:vhe,packedOpSnippet:bhe,dtype:"bool",cpuKernelImpl:yae}),She={kernelName:i2,backendName:"webgl",kernelFunc:whe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Che(t){const{inputs:e,backend:n}=t,{input:r}=e;return eO(r,!0,n)}const $he={kernelName:a2,backendName:"webgl",kernelFunc:Che};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const khe="return float(!isnan(x) && !isinf(x));",The=Ct({opSnippet:khe,dtype:"bool"}),Ihe={kernelName:u2,backendName:"webgl",kernelFunc:The};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nhe="return float(isinf(x));",Ehe=Ct({opSnippet:Nhe,dtype:"bool"}),Rhe={kernelName:c2,backendName:"webgl",kernelFunc:Ehe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _he="return float(isnan(x));",Phe=Ct({opSnippet:_he,dtype:"bool"}),Ahe={kernelName:d2,backendName:"webgl",kernelFunc:Phe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dhe="return float(a < b);",Fhe=`
  return vec4(lessThan(a, b));
`,Ohe=Qn({opSnippet:Dhe,packedOpSnippet:Fhe,cpuKernelImpl:xae,dtype:"bool"}),Lhe={kernelName:f2,backendName:"webgl",kernelFunc:Ohe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zhe="return float(a <= b);",Bhe=`
  return vec4(lessThanEqual(a, b));
`,Mhe=Qn({opSnippet:zhe,packedOpSnippet:Bhe,cpuKernelImpl:vae,dtype:"bool"}),Vhe={kernelName:p2,backendName:"webgl",kernelFunc:Mhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Whe(t){const{backend:e,attrs:n}=t,{start:r,stop:s,num:o}=n,i=bae(r,s,o);return e.makeTensorInfo([i.length],"float32",i)}const Uhe={kernelName:m2,backendName:"webgl",kernelFunc:Whe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jhe=Ad+`
  return x < 0.0 ? 0./0. : log(x);
`,Ghe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Hhe=Ct({opSnippet:jhe,packedOpSnippet:Ghe,cpuKernelImpl:wae}),Khe={kernelName:g2,backendName:"webgl",kernelFunc:Hhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xhe=Ad+`
  return log(1.0 + x);
`,qhe=Ct({opSnippet:Xhe}),Yhe={kernelName:y2,backendName:"webgl",kernelFunc:qhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qhe="return float(a >= 1.0 && b >= 1.0);",Zhe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Jhe=Qn({opSnippet:Qhe,packedOpSnippet:Zhe,dtype:"bool"}),efe={kernelName:x2,backendName:"webgl",kernelFunc:Jhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tfe="return float(!(x >= 1.0));",nfe=Ct({opSnippet:tfe}),rfe={kernelName:v2,backendName:"webgl",kernelFunc:nfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sfe="return float(a >= 1.0 || b >= 1.0);",ofe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,ife=Qn({opSnippet:sfe,packedOpSnippet:ofe,dtype:"bool"}),afe={kernelName:b2,backendName:"webgl",kernelFunc:ife};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let lfe=class{constructor(e,n,r,s,o){this.variableNames=["x"],this.outputShape=[];const i=n,a=e[3]-1;this.outputShape=e;let l;const c=`float(${r}) + float(${s}) * sum`;o===.5?l=`inversesqrt(${c})`:o===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ufe{constructor(e,n,r,s,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=n,a=e[3]-1;this.outputShape=e;let l;const c=`float(${r}) + float(${s}) * sum`;o===.5?l=`inversesqrt(${c})`:o===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cfe=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{depthRadius:o,bias:i,alpha:a,beta:l}=r,c=oe().getBool("WEBGL_PACK_NORMALIZATION")?new ufe(s.shape,o,i,a,l):new lfe(s.shape,o,i,a,l);return n.runWebGLProgram(c,[s],s.dtype)},dfe={kernelName:w2,backendName:"webgl",kernelFunc:cfe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let hfe=class{constructor(e,n,r,s,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=n,this.bias=r,this.alpha=s,this.beta=o,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${n})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${n} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s})
                * float(${o})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${o});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ffe=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s,y:o,dy:i}=e,{depthRadius:a,bias:l,alpha:c,beta:d}=r,f=new hfe(s.shape,a,l,c,d);return n.runWebGLProgram(f,[s,o,i],s.dtype)},pfe={kernelName:tA,backendName:"webgl",kernelFunc:ffe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mfe(t,e,n,r){const s=fe(e),i=fe(t.shape)/s,a=Pe({inputs:{x:t},attrs:{shape:[i,s]},backend:r}),l=ju(a,t.dtype,"max",r),c=Pe({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nO(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reductionIndices:o,keepDims:i}=r,a=s.shape.length,l=nn(o,s.shape);let c=l;const d=ur(c,a),f=d!=null,p=n.shouldExecuteOnCPU([s]);let g=s;if(f){if(p){const I=n.texData.get(g.dataId).values,R=new Array(a);for(let O=0;O<R.length;O++)R[O]=s.shape[d[O]];const _=PC(I,s.shape,s.dtype,d,R);g=n.makeTensorInfo(R,s.dtype);const F=n.texData.get(g.dataId);F.values=_}else g=Sy(s,d,n);c=cr(c.length,a)}xs("max",c,a);const[y,x]=Fs(g.shape,c);let w=y;i&&(w=ys(y,l));let S;if(p){const I=n.texData.get(g.dataId).values,R=Sae(I,fe(x),w,s.dtype);S=n.makeTensorInfo(w,s.dtype);const _=n.texData.get(S.dataId);_.values=R}else S=mfe(g,x,w,n);return f&&n.disposeIntermediateTensorInfo(g),S}const gfe={kernelName:S2,backendName:"webgl",kernelFunc:nO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yfe=AC+`
  return max(a, b);
`,xfe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Uu+`
  return result;
`,vfe=Qn({opSnippet:yfe,packedOpSnippet:xfe,cpuKernelImpl:Cae}),bfe={kernelName:C2,backendName:"webgl",kernelFunc:vfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wfe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;tp(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r,c=1;z(Er(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const d=ho(s.shape,o,i,c,a,l);if(d.filterWidth===1&&d.filterHeight===1&&Mt(d.inShape,d.outShape))return ps({inputs:{x:s},backend:n});const f=new Ef(d,"max",!1);return n.runWebGLProgram(f,[s],s.dtype)}const Sfe={kernelName:$2,backendName:"webgl",kernelFunc:wfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cfe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:i,pad:a,dataFormat:l,dimRoundingMode:c}=r,d=[1,1,1],f=ba(s.shape,o,i,d,a,c,l),p=new FC(f,"max",!1);return n.runWebGLProgram(p,[s],s.dtype)}const $fe={kernelName:k2,backendName:"webgl",kernelFunc:Cfe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let kfe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,o=e.effectiveFilterHeight,i=e.effectiveFilterWidth,a=o-1-e.padInfo.top,l=i-1-e.padInfo.left,c=o*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
          wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},Tfe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideDepth,r=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,i=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterDepth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,f=l-1-e.padInfo.front,p=c-1-e.padInfo.top,g=d-1-e.padInfo.left,y=l*c*d-1;this.userCode=`
      const ivec3 pads = ivec3(${f}, ${p}, ${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${n}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${y} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${d} +
                  wR * ${d} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ife(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,i=o,{filterSize:a,strides:l,pad:c,dimRoundingMode:d}=r,f=[1,1,1],p=ba(i.shape,a,l,f,c,d),g=new FC(p,"max",!0),y=n.runWebGLProgram(g,[i],i.dtype),x=new Tfe(p),w=n.runWebGLProgram(x,[s,y],i.dtype);return n.disposeIntermediateTensorInfo(y),w}const Nfe={kernelName:rA,backendName:"webgl",kernelFunc:Ife};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Efe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o,output:i}=e,a=o;tp([o,i],"maxPoolGrad");const{filterSize:l,strides:c,pad:d,dimRoundingMode:f}=r,p=ho(a.shape,l,c,1,d,f),g=!0,y=new Ef(p,"max",g),x=n.runWebGLProgram(y,[a],a.dtype),w=new kfe(p),S=n.runWebGLProgram(w,[s,x],a.dtype);return n.disposeIntermediateTensorInfo(x),S}const Rfe={kernelName:nA,backendName:"webgl",kernelFunc:Efe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _fe(t,e,n,r){let s=new Ef(n,"max",!1);const o=r.runWebGLProgram(s,[t],"float32");s=new Ef(n,"max",!0,!0,e);const i=r.runWebGLProgram(s,[t],"float32");return[o,i]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pfe={kernelName:T2,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=e,l=n;z(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const c=[1,1];z(Er(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const d=ho(r.shape,s,o,c,i),[f,p]=_fe(r,a,d,l);return[f,p]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Afe(t,e,n,r){const s=fe(e),i=fe(t.shape)/s,a=Pe({inputs:{x:t},attrs:{shape:[i,s]},backend:r}),l=ju(a,"float32","mean",r),c=Pe({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dfe={kernelName:I2,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{keepDims:s,axis:o}=e,i=n,a=r.shape.length,l=nn(o,r.shape);let c=l;const d=ur(c,a),f=d!=null,p=i.shouldExecuteOnCPU([r]),g=[];let y=r;if(f){if(p){const R=i.texData.get(y.dataId).values,_=new Array(a);for(let M=0;M<_.length;M++)_[M]=r.shape[d[M]];const F=PC(R,r.shape,r.dtype,d,_);y=i.makeTensorInfo(_,r.dtype);const O=i.texData.get(y.dataId);O.values=F}else y=Sy(r,d,i);g.push(y),c=cr(c.length,a)}xs("sum",c,a);const[x,w]=Fs(y.shape,c);let S=x;s&&(S=ys(x,l));const $=Afe(y,w,S,i);for(const I of g)i.disposeIntermediateTensorInfo(I);return $}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ffe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,l=nn(o,s.shape);let c=l;const d=ur(c,a);let f=s;d!=null&&(f=Ir({inputs:{x:s},backend:n,attrs:{perm:d}}),c=cr(c.length,s.shape.length)),xs("min",c,a);const[p,g]=Fs(f.shape,c),y=fe(g),x=Pe({inputs:{x:f},backend:n,attrs:{shape:[-1,y]}}),w=ju(x,x.dtype,"min",n);let S;if(i){const $=ys(p,l);S=Pe({inputs:{x:w},backend:n,attrs:{shape:$}})}else S=Pe({inputs:{x:w},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),d!=null&&n.disposeIntermediateTensorInfo(f),S}const Ofe={kernelName:N2,backendName:"webgl",kernelFunc:Ffe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lfe=AC+`
  return min(a, b);
`,zfe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Uu+`
  return result;
`,Bfe=Qn({opSnippet:Lfe,packedOpSnippet:zfe,cpuKernelImpl:$ae}),Mfe={kernelName:E2,backendName:"webgl",kernelFunc:Bfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Vfe=class{constructor(e,n,r){this.variableNames=["x"],this.outputShape=n.map((d,f)=>d[0]+e[f]+d[1]);const s=e.length,o=Kt(s),i=n.map(d=>d[0]).join(","),a=n.map((d,f)=>d[0]+e[f]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),c=r==="reflect"?0:1;if(s===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${i});
      ${o} end = ${o}(${a});

      void main() {
        ${o} outC = getOutputCoords();
        for (int i = 0; i < ${s}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${o} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wfe{constructor(e,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((y,x)=>y[0]+e[x]+y[1]);const s=e.length,o=Kt(s),i=n.map(y=>y[0]).join(","),a=n.map((y,x)=>y[0]+e[x]).join(","),l=kr("rc",s),c=kr("source",s),d=`${l[s-1]} < ${this.outputShape[s-1]}`,f=s===1?"source":`vec2(${c.slice(-2).join()})`,p=r==="reflect"?0:1;let g="";if(s===1){const y=`
        ${o} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p};
        }
        source -= start;
      `;g=`
        ${o} rc = outputLoc;
        ${y}
        result[0] = getChannel(getX(${c.join()}), ${f});
        ${l[s-1]} += 1;
        if(${d}) {
          ${y}
          result[1] = getChannel(getX(${c.join()}), ${f});
        }
      `}else{const y=`
        ${o} source = rc;
        ${o} lt = ${o}(lessThan(source, start));
        ${o} gte = ${o}(greaterThanEqual(source, end));
        ${o} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p}) +
                gte * ((end - 1) * 2 - source + ${p});
        source -= start;
      `;g=`
        ${o} rc = outputLoc;
        ${y}
        result[0] = getChannel(getX(${c.join()}), ${f});
        ${l[s-1]} += 1;
        if(${d}) {
          ${y}
          result[1] = getChannel(getX(${c.join()}), ${f});
        }
        rc = outputLoc;
        ${l[s-2]} += 1;
        if(${l[s-2]} < ${this.outputShape[s-2]}) {
          ${y}
          result[2] = getChannel(getX(${c.join()}), ${f});
          ${l[s-1]} += 1;
          if(${d}) {
            ${y}
            result[3] = getChannel(getX(${c.join()}), ${f});
          }
        }
      `}this.userCode=`
      const ${o} start = ${o}(${i});
      const ${o} end = ${o}(${a});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ufe=({inputs:t,backend:e,attrs:n})=>{const{x:r}=t,{paddings:s,mode:o}=n,i=oe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Wfe(r.shape,s,o):new Vfe(r.shape,s,o);return e.runWebGLProgram(i,[r],r.dtype)},jfe={kernelName:R2,backendName:"webgl",kernelFunc:Ufe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gfe=`if (b == 0.0) return NAN;
  return mod(a, b);`,Hfe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Uu+`
  return result;
`,Kfe=Qn({opSnippet:Gfe,packedOpSnippet:Hfe}),Xfe={kernelName:_2,backendName:"webgl",kernelFunc:Kfe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let qfe=class{constructor(e,n,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${n-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${n-1}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yfe=`
if (a == b) {
  return 1.0;
};
return a / b;`,Qfe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,rO=Qn({opSnippet:Yfe,packedOpSnippet:Qfe,checkOutOfBounds:!0}),Zfe={kernelName:Uw,backendName:"webgl",kernelFunc:rO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dE="return a - b;",sO=Qn({opSnippet:dE,packedOpSnippet:dE,supportsComplex:!0,cpuKernelImpl:Gae}),Jfe={kernelName:$S,backendName:"webgl",kernelFunc:sO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oO(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{dim:o}=r,i=nn([o],s.shape),a=nO({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=ys(a.shape,i),c=Pe({inputs:{x:a},backend:n,attrs:{shape:l}}),d=sO({inputs:{a:s,b:c},backend:n}),f=JF({inputs:{x:d},backend:n}),p=Cy({inputs:{x:f},backend:n,attrs:{axis:i,keepDims:!1}}),g=Pe({inputs:{x:p},backend:n,attrs:{shape:l}}),y=rO({inputs:{a:f,b:g},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g),y}const epe={kernelName:yS,backendName:"webgl",kernelFunc:oO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tpe(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{numSamples:o,seed:i,normalized:a}=r,l=a?s:oO({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),c=l.shape[0],d=l.shape[1],f=new qfe(c,d,o),p=[[i]],g=n.runWebGLProgram(f,[l],"int32",p);return a||n.disposeIntermediateTensorInfo(l),g}const npe={kernelName:P2,backendName:"webgl",kernelFunc:tpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rpe=po+`
  return -x;
`,spe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function ope(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])){const o=n.texData.get(r.dataId),[i,a]=Tae(o.values,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,i)}let s;return oe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new al(r.shape,spe):s=new di(r.shape,rpe),n.runWebGLProgram(s,[r],r.dtype)}const ipe={kernelName:D2,backendName:"webgl",kernelFunc:ope};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ape=XS;function lpe(t){Oo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r,c=n.readSync(s.dataId),d=n.readSync(o.dataId),{selectedIndices:f}=ape(c,d,i,a,l);return n.makeTensorInfo([f.length],"int32",new Int32Array(f))}const upe={kernelName:O2,backendName:"webgl",kernelFunc:lpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cpe=OD;function dpe(t){Oo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r,d=n.readSync(s.dataId),f=n.readSync(o.dataId),{selectedIndices:p,validOutputs:g}=cpe(d,f,i,a,l,c);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([g]))]}const hpe={kernelName:sA,backendName:"webgl",kernelFunc:dpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fpe=qS;function ppe(t){Oo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r,d=n.readSync(s.dataId),f=n.readSync(o.dataId),p=i,g=a,y=l,x=c,{selectedIndices:w,selectedScores:S}=fpe(d,f,p,g,y,x);return[n.makeTensorInfo([w.length],"int32",new Int32Array(w)),n.makeTensorInfo([S.length],"float32",new Float32Array(S))]}const mpe={kernelName:L2,backendName:"webgl",kernelFunc:ppe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let gpe=class{constructor(e,n,r,s){this.variableNames=["indices"],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s}), float(${r}),
                      float(index == coords.y)));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ype=t=>{const{inputs:e,backend:n,attrs:r}=t,{indices:s}=e,{dtype:o,depth:i,onValue:a,offValue:l}=r,c=fe(s.shape),d=new gpe(c,i,a,l),f=Pe({inputs:{x:s},backend:n,attrs:{shape:[c]}}),p=n.runWebGLProgram(d,[f],o);n.disposeIntermediateTensorInfo(f);const g=[...s.shape,i],y=Pe({inputs:{x:p},backend:n,attrs:{shape:g}});return n.disposeIntermediateTensorInfo(p),y},xpe={kernelName:B2,backendName:"webgl",kernelFunc:ype};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fg(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="complex64"){const s=rp({inputs:{input:r},backend:n}),o=Fg({inputs:{x:s},backend:n}),i=$y({inputs:{input:r},backend:n}),a=Fg({inputs:{x:i},backend:n}),l=kl({inputs:{real:o,imag:a},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),l}else return sp({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}const vpe={kernelName:_S,backendName:"webgl",kernelFunc:Fg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iO(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=rp({inputs:{input:r},backend:n}),o=iO({inputs:{x:s},backend:n}),i=$y({inputs:{input:r},backend:n}),a=Fg({inputs:{x:i},backend:n}),l=kl({inputs:{real:o,imag:a},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),l}else return sp({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}const bpe={kernelName:z2,backendName:"webgl",kernelFunc:iO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wpe(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r;if(e.length===1)return Cv({inputs:{input:e[0]},backend:n,attrs:{dim:s}});const o=e[0].shape,i=e[0].dtype;e.forEach(d=>{gs(o,d.shape,"All tensors passed to stack must have matching shapes"),z(i===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(d=>{const f=Cv({inputs:{input:d},backend:n,attrs:{dim:s}});return a.push(f),f}),c=GF({inputs:l,backend:n,attrs:{axis:s}});return a.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}const Spe={kernelName:M2,backendName:"webgl",kernelFunc:wpe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Cpe=class{constructor(e,n,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((c,d)=>c[0]+e[d]+c[1]);const s=e.length,o=Kt(s),i=n.map(c=>c[0]).join(","),a=n.map((c,d)=>c[0]+e[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${i});
      ${o} end = ${o}(${a});

      void main() {
        ${o} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${o} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $pe{constructor(e,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((x,w)=>x[0]+e[w]+x[1]);const s=e.length,o=Kt(s),i=n.map(x=>x[0]).join(","),a=n.map((x,w)=>x[0]+e[w]).join(","),l=kr("rc",s),c=kr("source",s),d=`${l[s-1]} < ${this.outputShape[s-1]}`,f=s===1?"source":`vec2(${c.slice(-2).join()})`,p=[`${o} rc = outputLoc;`,`${l[s-1]} += 1;
       if(${d}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${l[s-2]} += 1;
       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${l[s-1]} += 1;
         if(${d}) {`],g=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let y="";for(let x=0,w=s===1?2:4;x<w;x++)y+=`
        ${p[x]}
        if (${g}) {
          result[${x}] = float(value);
        } else {
          ${o} source = rc - start;
          result[${x}] = getChannel(getX(${c.join()}), ${f});
        }
      `;y+=s===1?"} ":"}}",this.userCode=`
      const ${o} start = ${o}(${i});
      const ${o} end = ${o}(${a});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${y}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aO=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{paddings:o,constantValue:i}=r;if(fe(s.shape)===0){const c=o.map((d,f)=>d[0]+s.shape[f]+d[1]);return sp({backend:n,attrs:{shape:c,value:i,dtype:s.dtype}})}const a=oe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new $pe(s.shape,o,i):new Cpe(s.shape,o,i),l=[[i]];return n.runWebGLProgram(a,[s],s.dtype,l)},kpe={kernelName:V2,backendName:"webgl",kernelFunc:aO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tpe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Ipe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Uu+`
  return result;
`,Npe=Qn({opSnippet:Tpe,packedOpSnippet:Ipe}),Epe={kernelName:W2,backendName:"webgl",kernelFunc:Npe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rpe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,l=[],c=nn(o,s.shape);let d=c;const f=ur(d,a);let p=s;f!=null&&(p=Ir({inputs:{x:s},backend:n,attrs:{perm:f}}),d=cr(d.length,a),l.push(p)),xs("prod",d,a);let g;if(n.shouldExecuteOnCPU([p])){const y=n.texData.get(p.dataId).values,{outVals:x,outShape:w,outDtype:S}=Nae(p.shape,p.dtype,y,d);g=n.makeTensorInfo(w,S,x)}else{const[y,x]=Fs(p.shape,d),w=fe(x),S=Pe({inputs:{x:p},backend:n,attrs:{shape:[-1,w]}}),$=ly(s.dtype),I=ju(S,$,"prod",n);g=Pe({inputs:{x:I},backend:n,attrs:{shape:y}}),l.push(S),l.push(I)}if(i){l.push(g);const y=ys(g.shape,c);g=Pe({inputs:{x:g},backend:n,attrs:{shape:y}})}return l.forEach(y=>n.disposeIntermediateTensorInfo(y)),g}const _pe={kernelName:j2,backendName:"webgl",kernelFunc:Rpe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ppe(t){const{inputs:e,backend:n,attrs:r}=t,{paramsNestedSplits:s,paramsDenseValues:o,indices:i}=e,{outputRaggedRank:a}=r,l=s.map(S=>n.readSync(S.dataId)),c=s.map(S=>S.shape),d=n.readSync(o.dataId),f=n.readSync(i.dataId),[p,g,y]=Eae(l,c,d,o.shape,o.dtype,f,i.shape,a),x=p.map(S=>n.makeTensorInfo([S.length],"int32",S)),w=n.makeTensorInfo(y,o.dtype,g);return x.concat([w])}const Ape={kernelName:oA,backendName:"webgl",kernelFunc:Ppe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dpe(t){const{inputs:e,backend:n}=t,{starts:r,limits:s,deltas:o}=e,i=n.readSync(r.dataId),a=n.readSync(s.dataId),l=n.readSync(o.dataId),[c,d]=Rae(i,r.shape,r.dtype,a,s.shape,l,o.shape),f=n.makeTensorInfo([c.length],"int32",c),p=n.makeTensorInfo([d.length],r.dtype,d);return[f,p]}const Fpe={kernelName:iA,backendName:"webgl",kernelFunc:Dpe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ope(t){const{inputs:e,backend:n,attrs:r}=t,{shape:s,values:o,defaultValue:i,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=r,c=n.readSync(s.dataId),d=n.readSync(o.dataId),f=n.readSync(i.dataId),p=a.map(w=>n.readSync(w.dataId)),g=a.map(w=>w.shape),[y,x]=_ae(c,s.shape,d,o.shape,o.dtype,f,i.shape,p,g,l);return n.makeTensorInfo(y,o.dtype,x)}const Lpe={kernelName:aA,backendName:"webgl",kernelFunc:Ope};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lO=t=>{const{backend:e,attrs:n}=t,{start:r,stop:s,step:o,dtype:i}=n,a=Pae(r,s,o,i);return e.makeTensorInfo([a.length],i,a)},zpe={kernelName:G2,backendName:"webgl",kernelFunc:lO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bpe="return 1.0 / x;",Mpe=Ct({opSnippet:Bpe}),Vpe={kernelName:K2,backendName:"webgl",kernelFunc:Mpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wpe=po+`
  return (x < 0.0) ? 0.0 : x;
`,Upe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,jpe=Ct({opSnippet:Wpe,packedOpSnippet:Upe}),Gpe={kernelName:X2,backendName:"webgl",kernelFunc:jpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hpe=po+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Kpe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Xpe=Ct({opSnippet:Hpe,packedOpSnippet:Kpe}),qpe={kernelName:Z2,backendName:"webgl",kernelFunc:Xpe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ype=class{constructor(e,n,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,c]=e;this.outputShape=[i,n,r,c];const d=[s&&n>1?a-1:a,s&&r>1?l-1:l],f=[s&&n>1?n-1:n,s&&r>1?r-1:r];let p;o?p="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/f[0]},
          ${d[1]/f[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qpe{constructor(e,n,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,c]=e;this.outputShape=[i,n,r,c];const d=[s&&n>1?a-1:a,s&&r>1?l-1:l],f=[s&&n>1?n-1:n,s&&r>1?r-1:r];let p;o?p="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/f[0]},
          ${d[1]/f[1]},
          ${d[1]/f[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zpe(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,c]=a,d=oe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Qpe(s.shape,l,c,o,i):new Ype(s.shape,l,c,o,i);return n.runWebGLProgram(d,[s],"float32")}const Jpe={kernelName:Q2,backendName:"webgl",kernelFunc:Zpe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let eme=class{constructor(e,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,s,o]=n,[,i,a]=e,l=[r&&i>1?s-1:s,r&&a>1?o-1:o],c=[r&&i>1?i-1:i,r&&a>1?a-1:a],d=l[0]/c[0],f=l[1]/c[1],p=1/d,g=1/f,y=Math.ceil(p)*2+2,x=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${f});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${g});

        const int winHeight = int(${y});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tme(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:o}=e,{alignCorners:i}=r,a=new eme(o.shape,s.shape,i);return n.runWebGLProgram(a,[o],o.dtype)}const nme={kernelName:uA,backendName:"webgl",kernelFunc:tme};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rme=class{constructor(e,n,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,c]=e;this.outputShape=[i,n,r,c];const d=[s&&n>1?a-1:a,s&&r>1?l-1:l],f=[s&&n>1?n-1:n,s&&r>1?r-1:r],p=s?"0.5":"0.0";let g;o?g="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":g="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/f[0]},
          ${d[1]/f[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${g};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sme{constructor(e,n,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,c]=e;this.outputShape=[i,n,r,c];const d=[s&&n>1?a-1:a,s&&r>1?l-1:l],f=[s&&n>1?n-1:n,s&&r>1?r-1:r],p=s?"0.5":"0.0";let g;o?g="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":g="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/f[0]},
          ${d[1]/f[1]},
          ${d[1]/f[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${g};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ome(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,c]=a,d=oe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new sme(s.shape,l,c,o,i):new rme(s.shape,l,c,o,i);return n.runWebGLProgram(d,[s],s.dtype)}const ime={kernelName:Y2,backendName:"webgl",kernelFunc:ome};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ame=class{constructor(e,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,s,o]=n,[,i,a]=e,l=[r&&i>1?s-1:s,r&&a>1?o-1:o],c=[r&&i>1?i-1:i,r&&a>1?a-1:a],d=l[0]/c[0],f=l[1]/c[1],p=1/d,g=1/f,y=Math.ceil(p)*2+2,x=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${f});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${g});

        const int winHeight = int(${y});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${o}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lme(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:o}=e,{alignCorners:i}=r,a=new ame(o.shape,s.shape,i);return n.runWebGLProgram(a,[o],o.dtype)}const ume={kernelName:lA,backendName:"webgl",kernelFunc:lme};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let cme=class{constructor(e,n){this.variableNames=["x"];const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=e,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const s=a=>n.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,o=e.map((a,l)=>s(l)).join(","),i=Kt(r);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dme{constructor(e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=e;const s=kr("rc",r),o=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=Kt(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${o}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(s.slice())};
          if(${o}){
            result.g = ${c(s.slice())};
          }
          if(${i}) {
            result.b = ${d(s.slice())};
            if(${o}) {
              result.a = ${f(s.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(y){return p(y)}function c(y){return y[r-1]="("+y[r-1]+" + 1)",p(y)}function d(y){return y[r-2]="("+y[r-2]+" + 1)",p(y)}function f(y){return y[r-1]="("+y[r-1]+" + 1)",y[r-2]="("+y[r-2]+" + 1)",p(y)}function p(y){const x=e.map(($,I)=>g(I,y)),w=x.join(","),S=x.slice(-2).join(",");return`getChannel(getX(${w}), vec2(${S}))`}function g(y,x){return n.indexOf(y)!==-1&&e[y]!==1?`${e[y]} - ${x[y]} - 1`:`${x[y]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hme(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dims:o}=r,i=s.shape.length,a=nn(o,s.shape);if(i===0)return ps({inputs:{x:s},backend:n});const l=oe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new dme(s.shape,a):new cme(s.shape,a);return n.runWebGLProgram(l,[s],s.dtype)}const fme={kernelName:J2,backendName:"webgl",kernelFunc:hme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let pme=class{constructor(e,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=e[1],s=e[2];this.outputShape=e;let o="";typeof n=="number"?o=`float outputValue = ${n.toFixed(2)};`:o=`
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${o}
          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mme={kernelName:AS,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:s,fillValue:o,center:i}=e,a=n,l=new pme(r.shape,o),[c,d]=uC(i,r.shape[1],r.shape[2]),f=[[c,d,Math.sin(s),Math.cos(s)]];return a.runWebGLProgram(l,[r],r.dtype,f)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gme=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,yme=Ct({opSnippet:gme}),xme={kernelName:eS,backendName:"webgl",kernelFunc:yme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vme="return inversesqrt(x);",bme=Ct({opSnippet:vme,cpuKernelImpl:Aae}),wme={kernelName:tS,backendName:"webgl",kernelFunc:bme};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let OC=class{constructor(e,n,r,s,o,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const c=Kt(o.length),d=Kt(i.length);let f="";r===1?f="i":r===2&&(f="i, j");const p=`getIndices(${f})`;let g="";s===1?g="i":s===2&&(g="i, coords[1]");const y=`getUpdates(${g})`;let x="";l&&(x="coords[0], coords[1]");const w=`getDefaultValue(${x})`,S=n>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${o});

        void main() {
          ${d} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${n}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${S};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${y};
              found = true;
            }
          }
          setOutput(mix(${w}, sum, float(found)));
        }
      `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sme{constructor(e,n,r,s,o,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const c=Kt(o.length),d=Kt(i.length);let f="";r===1?f="i":r===2&&(f="i, j");const p=`getIndices(${f})`;let g="";s===1?g="i":s===2&&(g="i, coords[1]");const y=`getUpdates(${g})`;let x="";l&&(x="coords[0], coords[1]");const w=`getDefaultValue(${x})`,S=n>1?"strides[j]":"strides",$=n>1?"strides[j + 1]":"strides";this.userCode=`
        ${c} strides = ${c}(${o});

        void main() {
          ${d} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${n}; j+=2) {
              ivec4 index = round(${p});
              flattenedIndex += index.xz * ${S};
              if (j + 1 < ${n}) {
                flattenedIndex += index.yw * ${$};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${y};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${w}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cme(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s,updates:o}=e,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:d,outputSize:f}=zu(o,s,i),p=[f/c,c];if(f===0)return n.makeTensorInfo(i,s.dtype);const g=Pe({inputs:{x:s},backend:n,attrs:{shape:[l,a]}}),y=Pe({inputs:{x:o},backend:n,attrs:{shape:[l,c]}}),x=n.makeTensorInfo([],"float32",new Float32Array([0]));let w;oe().getBool("WEBGL_PACK")?w=new Sme(l,a,g.shape.length,y.shape.length,d,p):w=new OC(l,a,g.shape.length,y.shape.length,d,p);const S=n.runWebGLProgram(w,[y,g,x],y.dtype),$=Pe({inputs:{x:S},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(S),n.disposeIntermediateTensorInfo(x),$}const $me={kernelName:nS,backendName:"webgl",kernelFunc:Cme};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let kme=class{constructor(e,n,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,r];const o="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(n+1))}; ++i) { if (left >= right) break;`,a=oe().getNumber("WEBGL_VERSION")===2?o:i,l=s==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tme(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:s,values:o}=e,{side:i}=r,a=new kme(s.shape[0],s.shape[1],o.shape[1],i),l=[[s.shape[1]]];return n.runWebGLProgram(a,[s,o],"int32",l)}const Ime={kernelName:sS,backendName:"webgl",kernelFunc:Tme};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Nme=class{constructor(e,n,r){this.variableNames=["c","a","b"],this.outputShape=n;let s,o;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)o="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let d=0;d<n.length;d++)c.push(`${a[d]}`),d<e&&l.push(`${a[d]}`);s=l.join(),o=c.join()}const i=Kt(r);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${s});
        if (cVal >= 1.0) {
          setOutput(getA(${o}));
        } else {
          setOutput(getB(${o}));
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eme(t){const{inputs:e,backend:n}=t,{condition:r,t:s,e:o}=e,i=new Nme(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,o],Ur(s.dtype,o.dtype))}const Rme={kernelName:oS,backendName:"webgl",kernelFunc:Eme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _me=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${hC};
  float scale = ${fC};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Pme=Ct({opSnippet:_me}),Ame={kernelName:iS,backendName:"webgl",kernelFunc:Pme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dme=Ad+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Fme=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Ome=Ct({opSnippet:Dme,packedOpSnippet:Fme,cpuKernelImpl:Fae}),Lme={kernelName:dS,backendName:"webgl",kernelFunc:Ome};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zme=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Bme=Ct({opSnippet:zme}),Mme={kernelName:cS,backendName:"webgl",kernelFunc:Bme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vme=Ad+`
  return sin(x);
`,Wme=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Uu}
  return result;
`,Ume=Ct({opSnippet:Vme,packedOpSnippet:Wme}),jme={kernelName:lS,backendName:"webgl",kernelFunc:Ume};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gme=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Hme=Ct({opSnippet:Gme}),Kme={kernelName:uS,backendName:"webgl",kernelFunc:Hme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xme=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,qme=Ct({opSnippet:Xme}),Yme={kernelName:hS,backendName:"webgl",kernelFunc:qme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qme=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:o,paddings:i}=r;z(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((S,$)=>S*$),l=[[0,0]];l.push(...i);for(let S=1+o.length;S<s.shape.length;++S)l.push([0,0]);const c=[],d=aO({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),f=Qf(d.shape,o,a,!1),p=Zf(f.length,o.length,!1),g=Jf(d.shape,o,a,!1),y=Pe({inputs:{x:d},backend:n,attrs:{shape:f}}),x=Ir({inputs:{x:y},backend:n,attrs:{perm:p}}),w=Pe({inputs:{x},backend:n,attrs:{shape:g}});return c.push(d),c.push(y),c.push(x),c.forEach(S=>n.disposeIntermediateTensorInfo(S)),w},Zme={kernelName:mS,backendName:"webgl",kernelFunc:Qme};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jme(t){const{inputs:e,backend:n}=t,{indices:r,values:s,denseShape:o,defaultValue:i}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${o.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const a=n.readSync(r.dataId),l=n.readSync(s.dataId),c=n.readSync(o.dataId),d=n.readSync(i.dataId)[0],[f,p,g,y,x]=Lae(a,r.shape,r.dtype,l,s.dtype,c,d);return[n.makeTensorInfo(p,r.dtype,f),n.makeTensorInfo([p[0]],s.dtype,g),n.makeTensorInfo([y.length],"bool",new Uint8Array(y.map(w=>Number(w)))),n.makeTensorInfo([x.length],r.dtype,new Int32Array(x))]}const ege={kernelName:cA,backendName:"webgl",kernelFunc:Jme};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tge(t){const{inputs:e,backend:n}=t,{inputIndices:r,inputShape:s,newShape:o}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(n.readSync(s.dataId)),a=n.readSync(r.dataId),l=Array.from(n.readSync(o.dataId)),[c,d,f]=zae(a,r.shape,r.dtype,i,l);return[n.makeTensorInfo(d,r.dtype,c),n.makeTensorInfo([f.length],o.dtype,new Int32Array(f))]}const nge={kernelName:dA,backendName:"webgl",kernelFunc:tge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rge(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:o}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${o.shape}`);const i=n.readSync(r.dataId),a=n.readSync(s.dataId),l=n.readSync(o.dataId),[c,d]=PF(i,r.shape,r.dtype,a,l,!0);return n.makeTensorInfo(d,r.dtype,c)}const sge={kernelName:xS,backendName:"webgl",kernelFunc:rge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oge(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:o}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${o.shape}`);const i=n.readSync(r.dataId),a=n.readSync(s.dataId),l=n.readSync(o.dataId),[c,d]=PF(i,r.shape,r.dtype,a,l);return n.makeTensorInfo(d,r.dtype,c)}const ige={kernelName:vS,backendName:"webgl",kernelFunc:oge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function age(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:s,sparseValues:o,defaultValue:i}=e,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:d,strides:f,outputSize:p}=zu(o,s,a),g=!1;if(o.dtype==="string"){const S=n.bufferSync(s),$=n.bufferSync(o),I=ca(n.readSync(i.dataId)[0]),R=Dae(S,$,a,p,d,c,l,f,I,g);return n.makeTensorInfo(a,R.dtype,R.values)}const y=new OC(c,l,s.shape.length,o.shape.length,f,[p,1],g),x=n.runWebGLProgram(y,[o,s,i],o.dtype),w=Pe({inputs:{x},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(x),w}const lge={kernelName:bS,backendName:"webgl",kernelFunc:age};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uge(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{numOrSizeSplits:o,axis:i}=r,a=nn(i,s.shape)[0],l=kC(s,o,a),c=s.shape.length,d=new Array(c).fill(0),f=s.shape.slice();return l.map(p=>{const g=[...f];g[a]=p;const y=Dd({inputs:{x:s},backend:n,attrs:{begin:d,size:g}});return d[a]+=p,y})}const cge={kernelName:gS,backendName:"webgl",kernelFunc:uge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hE="return sqrt(x);",dge=Ct({opSnippet:hE,packedOpSnippet:hE,cpuKernelImpl:Bae}),hge={kernelName:fS,backendName:"webgl",kernelFunc:dge};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fge="return x * x;",pge=Ct({opSnippet:fge}),mge={kernelName:hA,backendName:"webgl",kernelFunc:pge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fE="return (a - b) * (a - b);",gge=Qn({opSnippet:fE,packedOpSnippet:fE}),yge={kernelName:wS,backendName:"webgl",kernelFunc:gge};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xge(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");const o=n.readSync(s.dataId),i=xl(o),a=Mae(i,"string",r);return n.makeTensorInfo(s.shape,"string",a)}const vge={kernelName:fA,backendName:"webgl",kernelFunc:xge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bge({inputs:t,attrs:e,backend:n}){const{x:r}=t,s=po+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,o=new di(r.shape,s);return n.runWebGLProgram(o,[r],r.dtype)}const wge={kernelName:PS,backendName:"webgl",kernelFunc:bge};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Sge=class{constructor(e,n,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,o=Kt(r.length),i=Kt(r.length);let a="";if(s===1)a="coords * strides + begin";else{let l=0;a=r.map((c,d)=>(l++,r.length===1?`coords * strides[${d}] + begin[${d}]`:`coords[${l-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`
      ${o} begin = ${o}(${e});
      ${o} strides = ${o}(${n});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cge(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:o,end:i,strides:a,beginMask:l,endMask:c,ellipsisMask:d,newAxisMask:f,shrinkAxisMask:p}=r,{finalShapeSparse:g,finalShape:y,isIdentity:x,sliceDim0:w,isSimpleSlice:S,begin:$,end:I,strides:R}=iC(s.shape,o,i,a,l,c,d,f,p);let _;if(x)_=Pe({inputs:{x:s},backend:n,attrs:{shape:y}});else if(w||S){z(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const O=nC($,I,R),M=Dd({inputs:{x:s},backend:n,attrs:{begin:$,size:O}});_=Pe({inputs:{x:M},backend:n,attrs:{shape:y}}),n.disposeIntermediateTensorInfo(M)}else if(n.shouldExecuteOnCPU([s])){const M=n.readSync(s.dataId),B=Vt(s.shape,s.dtype,M),V=Vae(g,B,R,$);_=n.makeTensorInfo(y,s.dtype,V.values)}else{const M=new Sge($,R,g);_=n.runWebGLProgram(M,[s],s.dtype)}const F=Pe({inputs:{x:_},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(_),F}const $ge={kernelName:SS,backendName:"webgl",kernelFunc:Cge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kge(t){const{inputs:e,backend:n,attrs:r}=t,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:d,dataSplits:f}=e,p=n.readSync(d.dataId),g=n.readSync(f.dataId),[y,x]=Wae(p,g,s,o,i,a,l,c);return[n.makeTensorInfo([y.length],"string",y),n.makeTensorInfo(f.shape,"int32",x)]}const Tge={kernelName:CS,backendName:"webgl",kernelFunc:kge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ige(t){const{inputs:e,backend:n,attrs:r}=t,{skipEmpty:s}=r,{input:o,delimiter:i}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=n.readSync(o.dataId),l=n.readSync(i.dataId)[0],[c,d,f]=Uae(a,l,s),p=d.length;return[n.makeTensorInfo([p,2],"int32",c),n.makeTensorInfo([p],"string",d),n.makeTensorInfo([2],"int32",new Int32Array(f))]}const Nge={kernelName:pA,backendName:"webgl",kernelFunc:Ige};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ege(t){const{inputs:e,backend:n,attrs:r}=t,{numBuckets:s}=r,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(o.dataId),a=jae(i,s);return n.makeTensorInfo(o.shape,"int32",a)}const Rge={kernelName:mA,backendName:"webgl",kernelFunc:Ege};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ge="return tan(x);",Pge=Ct({opSnippet:_ge}),Age={kernelName:kS,backendName:"webgl",kernelFunc:Pge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dge=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,Fge=Ct({opSnippet:Dge}),Oge={kernelName:TS,backendName:"webgl",kernelFunc:Fge};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lge(t){const{inputs:e,backend:n,attrs:r}=t,{tensor:s,indices:o,updates:i}=e,{sliceRank:a,numUpdates:l,sliceSize:c,strides:d,outputSize:f}=zu(i,o,s.shape),p=[f/c,c];if(f===0)return n.makeTensorInfo(s.shape,o.dtype);const g=Pe({inputs:{x:o},backend:n,attrs:{shape:[l,a]}}),y=Pe({inputs:{x:i},backend:n,attrs:{shape:[l,c]}}),x=Pe({inputs:{x:s},backend:n,attrs:{shape:p}}),w=new OC(l,a,g.shape.length,y.shape.length,d,p,!1,!0),S=n.runWebGLProgram(w,[y,g,x],x.dtype),$=Pe({inputs:{x:S},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(S),$}const zge={kernelName:rS,backendName:"webgl",kernelFunc:Lge};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Bge=class{constructor(e,n){this.variableNames=["A"];const r=new Array(e.length);for(let i=0;i<r.length;i++)r[i]=e[i]*n[i];this.outputShape=r,this.rank=r.length;const s=Kt(this.rank),o=Mge(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}};function Mge(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<t.length;s++)r.push(`imod(${n[s]}, ${t[s]})`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uO(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reps:o}=r;if(s.dtype==="string"||s.shape.length>5){const l=n.readSync(s.dataId),c=s.dtype==="string"?l.map(p=>ca(p)):l,d=Vt(s.shape,s.dtype,c),f=Hae(d,o);return n.makeTensorInfo(f.shape,f.dtype,f.values)}const i=new Bge(s.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}const Vge={kernelName:oy,backendName:"webgl",kernelFunc:uO};let Wge=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},Uge=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function su(t,e){e!==null&&t.disposeIntermediateTensorInfo(e)}function pE(t){let e=1;for(;e<t;)e*=2;return e}function jge(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{k:o,sorted:i}=r,a=oe().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=oe().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=s.shape,d=c[c.length-1];if(n.shouldExecuteOnCPU([s])||d<a||o>l){const V=n.readSync(s.dataId),[A,re]=Kae(V,c,s.dtype,o,i);return[n.makeTensorInfo(A.shape,A.dtype,A.values),n.makeTensorInfo(re.shape,re.dtype,re.values)]}if(o===0)return c[c.length-1]=0,[n.makeTensorInfo(c,s.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(d===1)return[s,sp({attrs:{shape:c,dtype:"int32",value:0},backend:n})];const f=n.texData.get(s.dataId),p=f!==null&&f.isPacked,g=p?n.unpackTensor(s):s,x=fe(c)/d,w=Pe({inputs:{x:g},attrs:{shape:[x,d]},backend:n});p&&su(n,g);const S=pE(o),$=pE(d);let I=null;const R=()=>I===null?[w,w]:[w,I],_=(V,A,re)=>{const ae=R(),pe=new Wge(re),ve=[[d],[I===null?1:0],[Number.NEGATIVE_INFINITY],[V],[A]],$e=I;I=n.runWebGLProgram(pe,ae,"int32",ve),su(n,$e)};for(let V=1;V<S;V*=2){const A=V*2;for(let re=V;re>=1;re/=2)_(A,re,[x,$])}for(let V=$;V>S;V/=2){const A=R(),re=new Uge([x,V/2]),pe=[[d],[I===null?1:0],[S]],ye=I;I=n.runWebGLProgram(re,A,"int32",pe),su(n,ye);const ve=S/2,$e=ve*2;for(let se=ve;se>=1;se/=2)_($e,se,I.shape)}let F=I;I=Dd({inputs:{x:I},backend:n,attrs:{begin:0,size:[x,o]}}),su(n,F);let O=tO({inputs:{x:w,indices:I},backend:n,attrs:{axis:1,batchDims:1}});su(n,w);const M=c.slice(0,-1);M.push(o),F=I,I=Pe({inputs:{x:I},attrs:{shape:M},backend:n}),su(n,F);const B=O;return O=Pe({inputs:{x:O},attrs:{shape:M},backend:n}),su(n,B),[O,I]}const Gge={kernelName:IS,backendName:"webgl",kernelFunc:jge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Hge=class{constructor(e,n,r,s,o,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a=r==="nearest"?1:2;let l;switch(s){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${n}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${o});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${o});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${n}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kge(t){const{inputs:e,backend:n,attrs:r}=t,{image:s,transforms:o}=e,{interpolation:i,fillMode:a,fillValue:l,outputShape:c}=r,[d,f,p,g]=s.shape,[y,x]=c??[f,p],w=[d,y,x,g],S=new Hge(f,p,i,a,l,w);return n.runWebGLProgram(S,[s,o],"float32")}const Xge={kernelName:NS,backendName:"webgl",kernelFunc:Kge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qge(t){const{inputs:e,attrs:n,backend:r}=t,{axis:s}=n,{x:o}=e;tp(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(o.dataId),{outputValues:a,outputShape:l,indices:c}=Xae(i,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}const Yge={kernelName:gA,backendName:"webgl",kernelFunc:qge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qge(t){const{inputs:e,backend:n,attrs:r}=t,{value:s}=e;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s,a=i.shape.length,l=s.shape[o],c=new Array(a-1);let d=0;for(let x=0;x<a;x++)x!==o&&(c[d++]=i.shape[x]);const f=[],p=new Array(a).fill(0),g=i.shape.slice();g[o]=1;const y=new Array(l);for(let x=0;x<y.length;x++){p[o]=x;const w=Dd({inputs:{x:i},backend:n,attrs:{begin:p,size:g}}),S=Pe({inputs:{x:w},backend:n,attrs:{shape:c}});y[x]=S,f.push(w)}return f.forEach(x=>n.disposeIntermediateTensorInfo(x)),y}const Zge={kernelName:ES,backendName:"webgl",kernelFunc:Qge};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jge{constructor(e,n){this.variableNames=["x","segmentIds"];const r=e.windowSize,s=e.batchSize,o=e.inSize,i=e.numSegments,a=i*Math.ceil(o/r);this.outputShape=[s,a];const l="0.0",c="sumValue",d=Math.floor(r/4)*4,f=r%4,p=`
        sumValue += dot(values, segFilter);
    `;let g="";o%r>0&&(g=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `);let y="";o%r>0&&(y=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${g}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${y}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${p}
        }

        int inIdx = inOffset + ${d};
        if (${f===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${p}
        } else if (${f===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${p}
        } else if (${f===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${p}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eye(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,segmentIds:o}=e,{numSegments:i}=r,a=s.shape.length,l=[];let c=0;const d=ur([c],a);let f=s;d!=null&&(f=Ir({inputs:{x:s},backend:n,attrs:{perm:d}}),l.push(f),c=cr(1,a)[0]);const p=TC(f.shape,c,i),g=fe([f.shape[c]]),y=Pe({inputs:{x:f},backend:n,attrs:{shape:[-1,g]}});l.push(y);const x=ly(s.dtype),w=(R,_,F,O,M)=>{const B=R.shape[0],V=R.shape[1],A=pF(V,M),re={windowSize:A,inSize:V,batchSize:B,numSegments:M},ae=new Jge(re,_),pe=n.compileAndRun(ae,[R,F],O);if(l.push(pe),pe.shape[1]===M)return pe;const ye=lO({backend:n,attrs:{start:0,stop:M,step:1,dtype:"float32"}}),ve=uO({inputs:{x:ye},backend:n,attrs:{reps:[V/A]}});return l.push(ye),l.push(ve),w(pe,_,ve,O,M)},S=w(y,"unsortedSegmentSum",o,x,i),$=Pe({inputs:{x:S},backend:n,attrs:{shape:p}});let I=$;if(d!=null){l.push($);const R=Yf(d);I=Ir({inputs:{x:I},backend:n,attrs:{perm:R}})}return l.forEach(R=>n.disposeIntermediateTensorInfo(R)),I}const tye={kernelName:RS,backendName:"webgl",kernelFunc:eye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nye=[Ble,Vle,jle,Kle,qle,Zle,eue,nue,iue,lue,due,pue,yue,wue,$ue,Tue,Nue,Pue,Due,Oue,Mue,Kue,que,Jue,tce,ace,uce,fce,Sle,gce,wce,kce,_ce,Dce,Oce,zce,Mce,jce,Kce,Yce,Zce,ede,nde,ode,ade,dde,fde,gde,vde,wde,kde,Ede,Ade,Ode,Bde,Mde,Wde,jde,Hde,Xde,Yde,ehe,rhe,ihe,lhe,dhe,phe,xhe,She,wle,$he,vce,Ihe,Rhe,Ahe,$le,Lhe,Vhe,Uhe,Khe,Yhe,efe,rfe,afe,dfe,pfe,gfe,bfe,Sfe,$fe,Nfe,Rfe,Pfe,Dfe,Ofe,Mfe,jfe,Xfe,npe,Ile,ipe,upe,hpe,mpe,rce,xpe,bpe,Spe,kpe,Epe,Tle,_pe,Ape,Fpe,Lpe,zpe,sce,Zfe,Vpe,Gpe,qpe,Ele,Jpe,nme,ime,ume,fme,mme,xme,wme,$me,Ime,Rme,Ame,Lme,Mme,jme,Kme,Gue,epe,Yme,Zme,ege,nge,sge,ige,lge,cge,hge,mge,yge,vge,wge,$ge,Tge,Nge,Rge,Jfe,Ole,Age,Oge,zge,Vge,Gge,Xge,Lle,Yge,Zge,tye,vpe];for(const t of nye)yA(t);var rx={},mE;function rye(){return mE||(mE=1,(function(){var t;function e(v){var k=0;return function(){return k<v.length?{done:!1,value:v[k++]}:{done:!0}}}var n=typeof Object.defineProperties=="function"?Object.defineProperty:function(v,k,E){return v==Array.prototype||v==Object.prototype||(v[k]=E.value),v};function r(v){v=[typeof globalThis=="object"&&globalThis,v,typeof window=="object"&&window,typeof self=="object"&&self,typeof Pc=="object"&&Pc];for(var k=0;k<v.length;++k){var E=v[k];if(E&&E.Math==Math)return E}throw Error("Cannot find global object")}var s=r(this);function o(v,k){if(k)e:{var E=s;v=v.split(".");for(var P=0;P<v.length-1;P++){var W=v[P];if(!(W in E))break e;E=E[W]}v=v[v.length-1],P=E[v],k=k(P),k!=P&&k!=null&&n(E,v,{configurable:!0,writable:!0,value:k})}}o("Symbol",function(v){function k(G){if(this instanceof k)throw new TypeError("Symbol is not a constructor");return new E(P+(G||"")+"_"+W++,G)}function E(G,j){this.h=G,n(this,"description",{configurable:!0,writable:!0,value:j})}if(v)return v;E.prototype.toString=function(){return this.h};var P="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",W=0;return k}),o("Symbol.iterator",function(v){if(v)return v;v=Symbol("Symbol.iterator");for(var k="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),E=0;E<k.length;E++){var P=s[k[E]];typeof P=="function"&&typeof P.prototype[v]!="function"&&n(P.prototype,v,{configurable:!0,writable:!0,value:function(){return i(e(this))}})}return v});function i(v){return v={next:v},v[Symbol.iterator]=function(){return this},v}function a(v){var k=typeof Symbol<"u"&&Symbol.iterator&&v[Symbol.iterator];return k?k.call(v):{next:e(v)}}function l(v){if(!(v instanceof Array)){v=a(v);for(var k,E=[];!(k=v.next()).done;)E.push(k.value);v=E}return v}var c=typeof Object.assign=="function"?Object.assign:function(v,k){for(var E=1;E<arguments.length;E++){var P=arguments[E];if(P)for(var W in P)Object.prototype.hasOwnProperty.call(P,W)&&(v[W]=P[W])}return v};o("Object.assign",function(v){return v||c});var d=typeof Object.create=="function"?Object.create:function(v){function k(){}return k.prototype=v,new k},f;if(typeof Object.setPrototypeOf=="function")f=Object.setPrototypeOf;else{var p;e:{var g={a:!0},y={};try{y.__proto__=g,p=y.a;break e}catch{}p=!1}f=p?function(v,k){if(v.__proto__=k,v.__proto__!==k)throw new TypeError(v+" is not extensible");return v}:null}var x=f;function w(v,k){if(v.prototype=d(k.prototype),v.prototype.constructor=v,x)x(v,k);else for(var E in k)if(E!="prototype")if(Object.defineProperties){var P=Object.getOwnPropertyDescriptor(k,E);P&&Object.defineProperty(v,E,P)}else v[E]=k[E];v.za=k.prototype}function S(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function $(v){if(v.m)throw new TypeError("Generator is already running");v.m=!0}S.prototype.u=function(v){this.i=v};function I(v,k){v.l={ma:k,na:!0},v.h=v.s||v.v}S.prototype.return=function(v){this.l={return:v},this.h=this.v};function R(v,k,E){return v.h=E,{value:k}}function _(v){this.h=new S,this.i=v}function F(v,k){$(v.h);var E=v.h.j;return E?O(v,"return"in E?E.return:function(P){return{value:P,done:!0}},k,v.h.return):(v.h.return(k),M(v))}function O(v,k,E,P){try{var W=k.call(v.h.j,E);if(!(W instanceof Object))throw new TypeError("Iterator result "+W+" is not an object");if(!W.done)return v.h.m=!1,W;var G=W.value}catch(j){return v.h.j=null,I(v.h,j),M(v)}return v.h.j=null,P.call(v.h,G),M(v)}function M(v){for(;v.h.h;)try{var k=v.i(v.h);if(k)return v.h.m=!1,{value:k.value,done:!1}}catch(E){v.h.i=void 0,I(v.h,E)}if(v.h.m=!1,v.h.l){if(k=v.h.l,v.h.l=null,k.na)throw k.ma;return{value:k.return,done:!0}}return{value:void 0,done:!0}}function B(v){this.next=function(k){return $(v.h),v.h.j?k=O(v,v.h.j.next,k,v.h.u):(v.h.u(k),k=M(v)),k},this.throw=function(k){return $(v.h),v.h.j?k=O(v,v.h.j.throw,k,v.h.u):(I(v.h,k),k=M(v)),k},this.return=function(k){return F(v,k)},this[Symbol.iterator]=function(){return this}}function V(v){function k(P){return v.next(P)}function E(P){return v.throw(P)}return new Promise(function(P,W){function G(j){j.done?P(j.value):Promise.resolve(j.value).then(k,E).then(G,W)}G(v.next())})}function A(v){return V(new B(new _(v)))}o("Promise",function(v){function k(j){this.i=0,this.j=void 0,this.h=[],this.u=!1;var Z=this.l();try{j(Z.resolve,Z.reject)}catch(ue){Z.reject(ue)}}function E(){this.h=null}function P(j){return j instanceof k?j:new k(function(Z){Z(j)})}if(v)return v;E.prototype.i=function(j){if(this.h==null){this.h=[];var Z=this;this.j(function(){Z.m()})}this.h.push(j)};var W=s.setTimeout;E.prototype.j=function(j){W(j,0)},E.prototype.m=function(){for(;this.h&&this.h.length;){var j=this.h;this.h=[];for(var Z=0;Z<j.length;++Z){var ue=j[Z];j[Z]=null;try{ue()}catch(Ce){this.l(Ce)}}}this.h=null},E.prototype.l=function(j){this.j(function(){throw j})},k.prototype.l=function(){function j(Ce){return function(_e){ue||(ue=!0,Ce.call(Z,_e))}}var Z=this,ue=!1;return{resolve:j(this.I),reject:j(this.m)}},k.prototype.I=function(j){if(j===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(j instanceof k)this.L(j);else{e:switch(typeof j){case"object":var Z=j!=null;break e;case"function":Z=!0;break e;default:Z=!1}Z?this.F(j):this.s(j)}},k.prototype.F=function(j){var Z=void 0;try{Z=j.then}catch(ue){this.m(ue);return}typeof Z=="function"?this.M(Z,j):this.s(j)},k.prototype.m=function(j){this.v(2,j)},k.prototype.s=function(j){this.v(1,j)},k.prototype.v=function(j,Z){if(this.i!=0)throw Error("Cannot settle("+j+", "+Z+"): Promise already settled in state"+this.i);this.i=j,this.j=Z,this.i===2&&this.K(),this.H()},k.prototype.K=function(){var j=this;W(function(){if(j.D()){var Z=s.console;typeof Z<"u"&&Z.error(j.j)}},1)},k.prototype.D=function(){if(this.u)return!1;var j=s.CustomEvent,Z=s.Event,ue=s.dispatchEvent;return typeof ue>"u"?!0:(typeof j=="function"?j=new j("unhandledrejection",{cancelable:!0}):typeof Z=="function"?j=new Z("unhandledrejection",{cancelable:!0}):(j=s.document.createEvent("CustomEvent"),j.initCustomEvent("unhandledrejection",!1,!0,j)),j.promise=this,j.reason=this.j,ue(j))},k.prototype.H=function(){if(this.h!=null){for(var j=0;j<this.h.length;++j)G.i(this.h[j]);this.h=null}};var G=new E;return k.prototype.L=function(j){var Z=this.l();j.T(Z.resolve,Z.reject)},k.prototype.M=function(j,Z){var ue=this.l();try{j.call(Z,ue.resolve,ue.reject)}catch(Ce){ue.reject(Ce)}},k.prototype.then=function(j,Z){function ue(He,Ae){return typeof He=="function"?function(Ke){try{Ce(He(Ke))}catch(ht){_e(ht)}}:Ae}var Ce,_e,Je=new k(function(He,Ae){Ce=He,_e=Ae});return this.T(ue(j,Ce),ue(Z,_e)),Je},k.prototype.catch=function(j){return this.then(void 0,j)},k.prototype.T=function(j,Z){function ue(){switch(Ce.i){case 1:j(Ce.j);break;case 2:Z(Ce.j);break;default:throw Error("Unexpected state: "+Ce.i)}}var Ce=this;this.h==null?G.i(ue):this.h.push(ue),this.u=!0},k.resolve=P,k.reject=function(j){return new k(function(Z,ue){ue(j)})},k.race=function(j){return new k(function(Z,ue){for(var Ce=a(j),_e=Ce.next();!_e.done;_e=Ce.next())P(_e.value).T(Z,ue)})},k.all=function(j){var Z=a(j),ue=Z.next();return ue.done?P([]):new k(function(Ce,_e){function Je(Ke){return function(ht){He[Ke]=ht,Ae--,Ae==0&&Ce(He)}}var He=[],Ae=0;do He.push(void 0),Ae++,P(ue.value).T(Je(He.length-1),_e),ue=Z.next();while(!ue.done)})},k});function re(v,k){v instanceof String&&(v+="");var E=0,P=!1,W={next:function(){if(!P&&E<v.length){var G=E++;return{value:k(G,v[G]),done:!1}}return P=!0,{done:!0,value:void 0}}};return W[Symbol.iterator]=function(){return W},W}o("Array.prototype.keys",function(v){return v||function(){return re(this,function(k){return k})}}),o("Array.prototype.fill",function(v){return v||function(k,E,P){var W=this.length||0;for(0>E&&(E=Math.max(0,W+E)),(P==null||P>W)&&(P=W),P=Number(P),0>P&&(P=Math.max(0,W+P)),E=Number(E||0);E<P;E++)this[E]=k;return this}});function ae(v){return v||Array.prototype.fill}o("Int8Array.prototype.fill",ae),o("Uint8Array.prototype.fill",ae),o("Uint8ClampedArray.prototype.fill",ae),o("Int16Array.prototype.fill",ae),o("Uint16Array.prototype.fill",ae),o("Int32Array.prototype.fill",ae),o("Uint32Array.prototype.fill",ae),o("Float32Array.prototype.fill",ae),o("Float64Array.prototype.fill",ae),o("Object.is",function(v){return v||function(k,E){return k===E?k!==0||1/k===1/E:k!==k&&E!==E}}),o("Array.prototype.includes",function(v){return v||function(k,E){var P=this;P instanceof String&&(P=String(P));var W=P.length;for(E=E||0,0>E&&(E=Math.max(E+W,0));E<W;E++){var G=P[E];if(G===k||Object.is(G,k))return!0}return!1}}),o("String.prototype.includes",function(v){return v||function(k,E){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(k instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(k,E||0)!==-1}});var pe=this||self;function ye(v,k){v=v.split(".");var E=pe;v[0]in E||typeof E.execScript>"u"||E.execScript("var "+v[0]);for(var P;v.length&&(P=v.shift());)v.length||k===void 0?E[P]&&E[P]!==Object.prototype[P]?E=E[P]:E=E[P]={}:E[P]=k}function ve(v){var k;e:{if((k=pe.navigator)&&(k=k.userAgent))break e;k=""}return k.indexOf(v)!=-1}var $e=Array.prototype.map?function(v,k){return Array.prototype.map.call(v,k,void 0)}:function(v,k){for(var E=v.length,P=Array(E),W=typeof v=="string"?v.split(""):v,G=0;G<E;G++)G in W&&(P[G]=k.call(void 0,W[G],G,v));return P},se={},me=null;function ge(v){var k=v.length,E=3*k/4;E%3?E=Math.floor(E):"=.".indexOf(v[k-1])!=-1&&(E="=.".indexOf(v[k-2])!=-1?E-2:E-1);var P=new Uint8Array(E),W=0;return Q(v,function(G){P[W++]=G}),W!==E?P.subarray(0,W):P}function Q(v,k){function E(ue){for(;P<v.length;){var Ce=v.charAt(P++),_e=me[Ce];if(_e!=null)return _e;if(!/^[\s\xa0]*$/.test(Ce))throw Error("Unknown base64 encoding at char: "+Ce)}return ue}he();for(var P=0;;){var W=E(-1),G=E(0),j=E(64),Z=E(64);if(Z===64&&W===-1)break;k(W<<2|G>>4),j!=64&&(k(G<<4&240|j>>2),Z!=64&&k(j<<6&192|Z))}}function he(){if(!me){me={};for(var v="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),k=["+/=","+/","-_=","-_.","-_"],E=0;5>E;E++){var P=v.concat(k[E].split(""));se[E]=P;for(var W=0;W<P.length;W++){var G=P[W];me[G]===void 0&&(me[G]=W)}}}}var be=typeof Uint8Array<"u",We=!(ve("Trident")||ve("MSIE"))&&typeof pe.btoa=="function";function nt(v){if(!We){var k;k===void 0&&(k=0),he(),k=se[k];for(var E=Array(Math.floor(v.length/3)),P=k[64]||"",W=0,G=0;W<v.length-2;W+=3){var j=v[W],Z=v[W+1],ue=v[W+2],Ce=k[j>>2];j=k[(j&3)<<4|Z>>4],Z=k[(Z&15)<<2|ue>>6],ue=k[ue&63],E[G++]=Ce+j+Z+ue}switch(Ce=0,ue=P,v.length-W){case 2:Ce=v[W+1],ue=k[(Ce&15)<<2]||P;case 1:v=v[W],E[G]=k[v>>2]+k[(v&3)<<4|Ce>>4]+ue+P}return E.join("")}for(k="";10240<v.length;)k+=String.fromCharCode.apply(null,v.subarray(0,10240)),v=v.subarray(10240);return k+=String.fromCharCode.apply(null,v),btoa(k)}var Xe=RegExp("[-_.]","g");function kt(v){switch(v){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function mt(v){if(!We)return ge(v);Xe.test(v)&&(v=v.replace(Xe,kt)),v=atob(v);for(var k=new Uint8Array(v.length),E=0;E<v.length;E++)k[E]=v.charCodeAt(E);return k}var Et;function rn(){return Et||(Et=new Uint8Array(0))}var Jn={},Ls=typeof Uint8Array.prototype.slice=="function",Wt=0,bn=0;function Il(v){var k=0>v;v=Math.abs(v);var E=v>>>0;v=Math.floor((v-E)/4294967296),k&&(E=a(ka(E,v)),k=E.next().value,v=E.next().value,E=k),Wt=E>>>0,bn=v>>>0}var Xu=typeof BigInt=="function";function ka(v,k){return k=~k,v?v=~v+1:k+=1,[v,k]}function Nl(v,k){this.i=v>>>0,this.h=k>>>0}function Ta(v){if(!v)return vs||(vs=new Nl(0,0));if(!/^-?\d+$/.test(v))return null;if(16>v.length)Il(Number(v));else if(Xu)v=BigInt(v),Wt=Number(v&BigInt(4294967295))>>>0,bn=Number(v>>BigInt(32)&BigInt(4294967295));else{var k=+(v[0]==="-");bn=Wt=0;for(var E=v.length,P=k,W=(E-k)%6+k;W<=E;P=W,W+=6)P=Number(v.slice(P,W)),bn*=1e6,Wt=1e6*Wt+P,4294967296<=Wt&&(bn+=Wt/4294967296|0,Wt%=4294967296);k&&(k=a(ka(Wt,bn)),v=k.next().value,k=k.next().value,Wt=v,bn=k)}return new Nl(Wt,bn)}var vs;function bs(v,k){return Error("Invalid wire type: "+v+" (at position "+k+")")}function zs(){return Error("Failed to read varint, encoding is invalid.")}function Kr(v,k){return Error("Tried to read past the end of the data "+k+" > "+v)}function ws(){throw Error("Invalid UTF8")}function Ia(v,k){return k=String.fromCharCode.apply(null,k),v==null?k:v+k}var Ci=void 0,$i,mo=typeof TextDecoder<"u",Na,Mo=typeof TextEncoder<"u",go;function El(v){if(v!==Jn)throw Error("illegal external caller")}function Vo(v,k){if(El(k),this.V=v,v!=null&&v.length===0)throw Error("ByteString should be constructed with non-empty values")}function Ea(){return go||(go=new Vo(null,Jn))}function Bs(v){El(Jn);var k=v.V;return k=k==null||be&&k!=null&&k instanceof Uint8Array?k:typeof k=="string"?mt(k):null,k==null?k:v.V=k}function Wo(v){if(typeof v=="string")return{buffer:mt(v),C:!1};if(Array.isArray(v))return{buffer:new Uint8Array(v),C:!1};if(v.constructor===Uint8Array)return{buffer:v,C:!1};if(v.constructor===ArrayBuffer)return{buffer:new Uint8Array(v),C:!1};if(v.constructor===Vo)return{buffer:Bs(v)||rn(),C:!0};if(v instanceof Uint8Array)return{buffer:new Uint8Array(v.buffer,v.byteOffset,v.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function Ra(v,k){this.i=null,this.m=!1,this.h=this.j=this.l=0,Uo(this,v,k)}function Uo(v,k,E){E=E===void 0?{}:E,v.S=E.S===void 0?!1:E.S,k&&(k=Wo(k),v.i=k.buffer,v.m=k.C,v.l=0,v.j=v.i.length,v.h=v.l)}Ra.prototype.reset=function(){this.h=this.l};function Ss(v,k){if(v.h=k,k>v.j)throw Kr(v.j,k)}function Ms(v){var k=v.i,E=v.h,P=k[E++],W=P&127;if(P&128&&(P=k[E++],W|=(P&127)<<7,P&128&&(P=k[E++],W|=(P&127)<<14,P&128&&(P=k[E++],W|=(P&127)<<21,P&128&&(P=k[E++],W|=P<<28,P&128&&k[E++]&128&&k[E++]&128&&k[E++]&128&&k[E++]&128&&k[E++]&128)))))throw zs();return Ss(v,E),W}function _r(v,k){if(0>k)throw Error("Tried to read a negative byte length: "+k);var E=v.h,P=E+k;if(P>v.j)throw Kr(k,v.j-E);return v.h=P,E}var yo=[];function Xr(){this.h=[]}Xr.prototype.length=function(){return this.h.length},Xr.prototype.end=function(){var v=this.h;return this.h=[],v};function Rl(v,k,E){for(;0<E||127<k;)v.h.push(k&127|128),k=(k>>>7|E<<25)>>>0,E>>>=7;v.h.push(k)}function Vs(v,k){for(;127<k;)v.h.push(k&127|128),k>>>=7;v.h.push(k)}function _a(v,k){if(yo.length){var E=yo.pop();Uo(E,v,k),v=E}else v=new Ra(v,k);this.h=v,this.j=this.h.h,this.i=this.l=-1,this.setOptions(k)}_a.prototype.setOptions=function(v){v=v===void 0?{}:v,this.ca=v.ca===void 0?!1:v.ca},_a.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};function _l(v){var k=v.h;if(k.h==k.j)return!1;v.j=v.h.h;var E=Ms(v.h)>>>0;if(k=E>>>3,E&=7,!(0<=E&&5>=E))throw bs(E,v.j);if(1>k)throw Error("Invalid field number: "+k+" (at position "+v.j+")");return v.l=k,v.i=E,!0}function jo(v){switch(v.i){case 0:if(v.i!=0)jo(v);else e:{v=v.h;for(var k=v.h,E=k+10,P=v.i;k<E;)if((P[k++]&128)===0){Ss(v,k);break e}throw zs()}break;case 1:v=v.h,Ss(v,v.h+8);break;case 2:v.i!=2?jo(v):(k=Ms(v.h)>>>0,v=v.h,Ss(v,v.h+k));break;case 5:v=v.h,Ss(v,v.h+4);break;case 3:k=v.l;do{if(!_l(v))throw Error("Unmatched start-group tag: stream EOF");if(v.i==4){if(v.l!=k)throw Error("Unmatched end-group tag");break}jo(v)}while(!0);break;default:throw bs(v.i,v.j)}}var er=[];function ki(){this.j=[],this.i=0,this.h=new Xr}function Ws(v,k){k.length!==0&&(v.j.push(k),v.i+=k.length)}function Ti(v,k){if(k=k.R){Ws(v,v.h.end());for(var E=0;E<k.length;E++)Ws(v,Bs(k[E])||rn())}}var Cs=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol():void 0;function Pr(v,k){return Cs?v[Cs]|=k:v.A!==void 0?v.A|=k:(Object.defineProperties(v,{A:{value:k,configurable:!0,writable:!0,enumerable:!1}}),k)}function qr(v,k){Cs?v[Cs]&&(v[Cs]&=~k):v.A!==void 0&&(v.A&=~k)}function Xt(v){var k;return Cs?k=v[Cs]:k=v.A,k??0}function hr(v,k){Cs?v[Cs]=k:v.A!==void 0?v.A=k:Object.defineProperties(v,{A:{value:k,configurable:!0,writable:!0,enumerable:!1}})}function Pl(v){return Pr(v,1),v}function zd(v,k){hr(k,(v|0)&-51)}function Pa(v,k){hr(k,(v|18)&-41)}var Bn={};function Ii(v){return v!==null&&typeof v=="object"&&!Array.isArray(v)&&v.constructor===Object}var Go,qu=[];hr(qu,23),Go=Object.freeze(qu);function Aa(v){if(Xt(v.o)&2)throw Error("Cannot mutate an immutable Message")}function Da(v){var k=v.length;(k=k?v[k-1]:void 0)&&Ii(k)?k.g=1:(k={},v.push((k.g=1,k)))}function Al(v){var k=v.i+v.G;return v.B||(v.B=v.o[k]={})}function Mn(v,k){return k===-1?null:k>=v.i?v.B?v.B[k]:void 0:v.o[k+v.G]}function Yr(v,k,E,P){Aa(v),Us(v,k,E,P)}function Us(v,k,E,P){v.j&&(v.j=void 0),k>=v.i||P?Al(v)[k]=E:(v.o[k+v.G]=E,(v=v.B)&&k in v&&delete v[k])}function Ut(v,k,E,P){var W=Mn(v,k);Array.isArray(W)||(W=Go);var G=Xt(W);if(G&1||Pl(W),P)G&2||Pr(W,2),E&1||Object.freeze(W);else{P=!(E&2);var j=G&2;E&1||!j?P&&G&16&&!j&&qr(W,16):(W=Pl(Array.prototype.slice.call(W)),Us(v,k,W))}return W}function Dl(v,k){var E=Mn(v,k),P=E==null?E:typeof E=="number"||E==="NaN"||E==="Infinity"||E==="-Infinity"?Number(E):void 0;return P!=null&&P!==E&&Us(v,k,P),P}function xo(v,k,E,P,W){v.h||(v.h={});var G=v.h[E],j=Ut(v,E,3,W);if(!G){var Z=j;G=[];var ue=!!(Xt(v.o)&16);j=!!(Xt(Z)&2);var Ce=Z;!W&&j&&(Z=Array.prototype.slice.call(Z));for(var _e=j,Je=0;Je<Z.length;Je++){var He=Z[Je],Ae=k,Ke=!1;if(Ke=Ke===void 0?!1:Ke,He=Array.isArray(He)?new Ae(He):Ke?new Ae:void 0,He!==void 0){Ae=He.o;var ht=Ke=Xt(Ae);j&&(ht|=2),ue&&(ht|=16),ht!=Ke&&hr(Ae,ht),Ae=ht,_e=_e||!!(2&Ae),G.push(He)}}return v.h[E]=G,ue=Xt(Z),k=ue|33,k=_e?k&-9:k|8,ue!=k&&(_e=Z,Object.isFrozen(_e)&&(_e=Array.prototype.slice.call(_e)),hr(_e,k),Z=_e),Ce!==Z&&Us(v,E,Z),(W||P&&j)&&Pr(G,2),P&&Object.freeze(G),G}return W||(W=Object.isFrozen(G),P&&!W?Object.freeze(G):!P&&W&&(G=Array.prototype.slice.call(G),v.h[E]=G)),G}function Ni(v,k,E){var P=!!(Xt(v.o)&2);if(k=xo(v,k,E,P,P),v=Ut(v,E,3,P),!(P||Xt(v)&8)){for(P=0;P<k.length;P++){if(E=k[P],Xt(E.o)&2){var W=Pi(E,!1);W.j=E}else W=E;E!==W&&(k[P]=W,v[P]=W.o)}Pr(v,8)}return k}function tr(v,k,E){if(E!=null&&typeof E!="number")throw Error("Value of float/double field must be a number|null|undefined, found "+typeof E+": "+E);Yr(v,k,E)}function Yu(v,k,E,P,W){Aa(v);var G=xo(v,E,k,!1,!1);return E=P??new E,v=Ut(v,k,2,!1),W!=null?(G.splice(W,0,E),v.splice(W,0,E.o)):(G.push(E),v.push(E.o)),E.C()&&qr(v,8),E}function Ei(v,k){return v??k}function Vn(v,k,E){return E=E===void 0?0:E,Ei(Dl(v,k),E)}var nr;function Bd(v){switch(typeof v){case"number":return isFinite(v)?v:String(v);case"object":if(v)if(Array.isArray(v)){if((Xt(v)&128)!==0)return v=Array.prototype.slice.call(v),Da(v),v}else{if(be&&v!=null&&v instanceof Uint8Array)return nt(v);if(v instanceof Vo){var k=v.V;return k==null?"":typeof k=="string"?k:v.V=nt(k)}}}return v}function fr(v,k,E,P){if(v!=null){if(Array.isArray(v))v=Fl(v,k,E,P!==void 0);else if(Ii(v)){var W={},G;for(G in v)W[G]=fr(v[G],k,E,P);v=W}else v=k(v,P);return v}}function Fl(v,k,E,P){var W=Xt(v);P=P?!!(W&16):void 0,v=Array.prototype.slice.call(v);for(var G=0;G<v.length;G++)v[G]=fr(v[G],k,E,P);return E(W,v),v}function Md(v){return v.ja===Bn?v.toJSON():Bd(v)}function Vd(v,k){v&128&&Da(k)}function Ri(v,k,E){if(E=E===void 0?Pa:E,v!=null){if(be&&v instanceof Uint8Array)return v.length?new Vo(new Uint8Array(v),Jn):Ea();if(Array.isArray(v)){var P=Xt(v);return P&2?v:k&&!(P&32)&&(P&16||P===0)?(hr(v,P|2),v):(v=Fl(v,Ri,P&4?Pa:E,!0),k=Xt(v),k&4&&k&2&&Object.freeze(v),v)}return v.ja===Bn?Ho(v):v}}function _i(v,k,E,P,W,G,j){if(v=v.h&&v.h[E]){if(P=Xt(v),P&2?P=v:(G=$e(v,Ho),Pa(P,G),Object.freeze(G),P=G),Aa(k),j=P==null?Go:Pl([]),P!=null){for(G=!!P.length,v=0;v<P.length;v++){var Z=P[v];G=G&&!(Xt(Z.o)&2),j[v]=Z.o}G=(G?8:0)|1,v=Xt(j),(v&G)!==G&&(Object.isFrozen(j)&&(j=Array.prototype.slice.call(j)),hr(j,v|G)),k.h||(k.h={}),k.h[E]=P}else k.h&&(k.h[E]=void 0);Us(k,E,j,W)}else Yr(k,E,Ri(P,G,j),W)}function Ho(v){return Xt(v.o)&2||(v=Pi(v,!0),Pr(v.o,2)),v}function Pi(v,k){var E=v.o,P=[];Pr(P,16);var W=v.constructor.h;if(W&&P.push(W),W=v.B,W){P.length=E.length,P.fill(void 0,P.length,E.length);var G={};P[P.length-1]=G}(Xt(E)&128)!==0&&Da(P),k=k||v.C()?Pa:zd,G=v.constructor,nr=P,P=new G(P),nr=void 0,v.R&&(P.R=v.R.slice()),G=!!(Xt(E)&16);for(var j=W?E.length-1:E.length,Z=0;Z<j;Z++)_i(v,P,Z-v.G,E[Z],!1,G,k);if(W)for(var ue in W)_i(v,P,+ue,W[ue],!0,G,k);return P}function wn(v,k,E){v==null&&(v=nr),nr=void 0;var P=this.constructor.i||0,W=0<P,G=this.constructor.h,j=!1;if(v==null){v=G?[G]:[];var Z=48,ue=!0;W&&(P=0,Z|=128),hr(v,Z)}else{if(!Array.isArray(v)||G&&G!==v[0])throw Error();var Ce=Z=Pr(v,0);if((ue=(16&Ce)!==0)&&((j=(32&Ce)!==0)||(Ce|=32)),W){if(128&Ce)P=0;else if(0<v.length){var _e=v[v.length-1];if(Ii(_e)&&"g"in _e){P=0,Ce|=128,delete _e.g;var Je=!0,He;for(He in _e){Je=!1;break}Je&&v.pop()}}}else if(128&Ce)throw Error();Z!==Ce&&hr(v,Ce)}this.G=(G?0:-1)-P,this.h=void 0,this.o=v;e:{if(G=this.o.length,P=G-1,G&&(G=this.o[P],Ii(G))){this.B=G,this.i=P-this.G;break e}k!==void 0&&-1<k?(this.i=Math.max(k,P+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE}if(!W&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(E){k=ue&&!j&&!0,W=this.i;var Ae;for(ue=0;ue<E.length;ue++)j=E[ue],j<W?(j+=this.G,(P=v[j])?Fa(P,k):v[j]=Go):(Ae||(Ae=Al(this)),(P=Ae[j])?Fa(P,k):Ae[j]=Go)}}wn.prototype.toJSON=function(){return Fl(this.o,Md,Vd)},wn.prototype.C=function(){return!!(Xt(this.o)&2)};function Fa(v,k){if(Array.isArray(v)){var E=Xt(v),P=1;!k||E&2||(P|=16),(E&P)!==P&&hr(v,E|P)}}wn.prototype.ja=Bn,wn.prototype.toString=function(){return this.o.toString()};function Oa(v,k,E){if(E){var P={},W;for(W in E){var G=E[W],j=G.ra;j||(P.J=G.xa||G.oa.W,G.ia?(P.aa=La(G.ia),j=function(Z){return function(ue,Ce,_e){return Z.J(ue,Ce,_e,Z.aa)}}(P)):G.ka?(P.Z=Oi(G.da.P,G.ka),j=function(Z){return function(ue,Ce,_e){return Z.J(ue,Ce,_e,Z.Z)}}(P)):j=P.J,G.ra=j),j(k,v,G.da),P={J:P.J,aa:P.aa,Z:P.Z}}}Ti(k,v)}var Ai=Symbol();function Di(v,k,E){return v[Ai]||(v[Ai]=function(P,W){return k(P,W,E)})}function Ko(v){var k=v[Ai];if(!k){var E=Jr(v);k=function(P,W){return es(P,W,E)},v[Ai]=k}return k}function Wd(v){var k=v.ia;if(k)return Ko(k);if(k=v.wa)return Di(v.da.P,k,v.ka)}function Ol(v){var k=Wd(v),E=v.da,P=v.oa.U;return k?function(W,G){return P(W,G,E,k)}:function(W,G){return P(W,G,E)}}function wt(v,k){var E=v[k];return typeof E=="function"&&E.length===0&&(E=E(),v[k]=E),Array.isArray(E)&&(Wn in E||Xo in E||0<E.length&&typeof E[0]=="function")?E:void 0}function Ll(v,k,E,P,W,G){k.P=v[0];var j=1;if(v.length>j&&typeof v[j]!="number"){var Z=v[j++];E(k,Z)}for(;j<v.length;){E=v[j++];for(var ue=j+1;ue<v.length&&typeof v[ue]!="number";)ue++;switch(Z=v[j++],ue-=j,ue){case 0:P(k,E,Z);break;case 1:(ue=wt(v,j))?(j++,W(k,E,Z,ue)):P(k,E,Z,v[j++]);break;case 2:ue=j++,ue=wt(v,ue),W(k,E,Z,ue,v[j++]);break;case 3:G(k,E,Z,v[j++],v[j++],v[j++]);break;case 4:G(k,E,Z,v[j++],v[j++],v[j++],v[j++]);break;default:throw Error("unexpected number of binary field arguments: "+ue)}}return k}var Fi=Symbol();function La(v){var k=v[Fi];if(!k){var E=pr(v);k=function(P,W){return Ju(P,W,E)},v[Fi]=k}return k}function Oi(v,k){var E=v[Fi];return E||(E=function(P,W){return Oa(P,W,k)},v[Fi]=E),E}var Xo=Symbol();function Qu(v,k){v.push(k)}function zl(v,k,E){v.push(k,E.W)}function vo(v,k,E,P){var W=La(P),G=pr(P).P,j=E.W;v.push(k,function(Z,ue,Ce){return j(Z,ue,Ce,G,W)})}function Qr(v,k,E,P,W,G){var j=Oi(P,G),Z=E.W;v.push(k,function(ue,Ce,_e){return Z(ue,Ce,_e,P,j)})}function pr(v){var k=v[Xo];return k||(k=Ll(v,v[Xo]=[],Qu,zl,vo,Qr),Wn in v&&Xo in v&&(v.length=0),k)}var Wn=Symbol();function Li(v,k){v[0]=k}function qo(v,k,E,P){var W=E.U;v[k]=P?function(G,j,Z){return W(G,j,Z,P)}:W}function Zr(v,k,E,P,W){var G=E.U,j=Ko(P),Z=Jr(P).P;v[k]=function(ue,Ce,_e){return G(ue,Ce,_e,Z,j,W)}}function Zu(v,k,E,P,W,G,j){var Z=E.U,ue=Di(P,W,G);v[k]=function(Ce,_e,Je){return Z(Ce,_e,Je,P,ue,j)}}function Jr(v){var k=v[Wn];return k||(k=Ll(v,v[Wn]={},Li,qo,Zr,Zu),Wn in v&&Xo in v&&(v.length=0),k)}function es(v,k,E){for(;_l(k)&&k.i!=4;){var P=k.l,W=E[P];if(!W){var G=E[0];G&&(G=G[P])&&(W=E[P]=Ol(G))}if(!W||!W(k,v,P)){W=k,P=v,G=W.j,jo(W);var j=W;if(!j.ca){if(W=j.h.h-G,j.h.h=G,j=j.h,W==0)W=Ea();else{if(G=_r(j,W),j.S&&j.m)W=j.i.subarray(G,G+W);else{j=j.i;var Z=G;W=G+W,W=Z===W?rn():Ls?j.slice(Z,W):new Uint8Array(j.subarray(Z,W))}W=W.length==0?Ea():new Vo(W,Jn)}(G=P.R)?G.push(W):P.R=[W]}}}return v}function Ju(v,k,E){for(var P=E.length,W=P%2==1,G=W?1:0;G<P;G+=2)(0,E[G+1])(k,v,E[G]);Oa(v,k,W?E[0]:void 0)}function bo(v,k){return{U:v,W:k}}var Un=bo(function(v,k,E){if(v.i!==5)return!1;v=v.h;var P=v.i,W=v.h,G=P[W],j=P[W+1],Z=P[W+2];return P=P[W+3],Ss(v,v.h+4),j=(G<<0|j<<8|Z<<16|P<<24)>>>0,v=2*(j>>31)+1,G=j>>>23&255,j&=8388607,Yr(k,E,G==255?j?NaN:1/0*v:G==0?v*Math.pow(2,-149)*j:v*Math.pow(2,G-150)*(j+Math.pow(2,23))),!0},function(v,k,E){if(k=Dl(k,E),k!=null){Vs(v.h,8*E+5),v=v.h;var P=+k;P===0?0<1/P?Wt=bn=0:(bn=0,Wt=2147483648):isNaN(P)?(bn=0,Wt=2147483647):(P=(E=0>P?-2147483648:0)?-P:P,34028234663852886e22<P?(bn=0,Wt=(E|2139095040)>>>0):11754943508222875e-54>P?(P=Math.round(P/Math.pow(2,-149)),bn=0,Wt=(E|P)>>>0):(k=Math.floor(Math.log(P)/Math.LN2),P*=Math.pow(2,-k),P=Math.round(8388608*P),16777216<=P&&++k,bn=0,Wt=(E|k+127<<23|P&8388607)>>>0)),E=Wt,v.h.push(E>>>0&255),v.h.push(E>>>8&255),v.h.push(E>>>16&255),v.h.push(E>>>24&255)}}),Bl=bo(function(v,k,E){if(v.i!==0)return!1;var P=v.h,W=0,G=v=0,j=P.i,Z=P.h;do{var ue=j[Z++];W|=(ue&127)<<G,G+=7}while(32>G&&ue&128);for(32<G&&(v|=(ue&127)>>4),G=3;32>G&&ue&128;G+=7)ue=j[Z++],v|=(ue&127)<<G;if(Ss(P,Z),128>ue)P=W>>>0,ue=v>>>0,(v=ue&2147483648)&&(P=~P+1>>>0,ue=~ue>>>0,P==0&&(ue=ue+1>>>0)),P=4294967296*ue+(P>>>0);else throw zs();return Yr(k,E,v?-P:P),!0},function(v,k,E){k=Mn(k,E),k!=null&&(typeof k=="string"&&Ta(k),k!=null&&(Vs(v.h,8*E),typeof k=="number"?(v=v.h,Il(k),Rl(v,Wt,bn)):(E=Ta(k),Rl(v.h,E.i,E.h))))}),Ud=bo(function(v,k,E){return v.i!==0?!1:(Yr(k,E,Ms(v.h)),!0)},function(v,k,E){if(k=Mn(k,E),k!=null&&k!=null)if(Vs(v.h,8*E),v=v.h,E=k,0<=E)Vs(v,E);else{for(k=0;9>k;k++)v.h.push(E&127|128),E>>=7;v.h.push(1)}}),Yo=bo(function(v,k,E){if(v.i!==2)return!1;var P=Ms(v.h)>>>0;v=v.h;var W=_r(v,P);if(v=v.i,mo){var G=v,j;(j=$i)||(j=$i=new TextDecoder("utf-8",{fatal:!0})),v=W+P,G=W===0&&v===G.length?G:G.subarray(W,v);try{var Z=j.decode(G)}catch(Je){if(Ci===void 0){try{j.decode(new Uint8Array([128]))}catch{}try{j.decode(new Uint8Array([97])),Ci=!0}catch{Ci=!1}}throw!Ci&&($i=void 0),Je}}else{Z=W,P=Z+P,W=[];for(var ue=null,Ce,_e;Z<P;)Ce=v[Z++],128>Ce?W.push(Ce):224>Ce?Z>=P?ws():(_e=v[Z++],194>Ce||(_e&192)!==128?(Z--,ws()):W.push((Ce&31)<<6|_e&63)):240>Ce?Z>=P-1?ws():(_e=v[Z++],(_e&192)!==128||Ce===224&&160>_e||Ce===237&&160<=_e||((G=v[Z++])&192)!==128?(Z--,ws()):W.push((Ce&15)<<12|(_e&63)<<6|G&63)):244>=Ce?Z>=P-2?ws():(_e=v[Z++],(_e&192)!==128||(Ce<<28)+(_e-144)>>30!==0||((G=v[Z++])&192)!==128||((j=v[Z++])&192)!==128?(Z--,ws()):(Ce=(Ce&7)<<18|(_e&63)<<12|(G&63)<<6|j&63,Ce-=65536,W.push((Ce>>10&1023)+55296,(Ce&1023)+56320))):ws(),8192<=W.length&&(ue=Ia(ue,W),W.length=0);Z=Ia(ue,W)}return Yr(k,E,Z),!0},function(v,k,E){if(k=Mn(k,E),k!=null){var P=!1;if(P=P===void 0?!1:P,Mo){if(P&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(k))throw Error("Found an unpaired surrogate");k=(Na||(Na=new TextEncoder)).encode(k)}else{for(var W=0,G=new Uint8Array(3*k.length),j=0;j<k.length;j++){var Z=k.charCodeAt(j);if(128>Z)G[W++]=Z;else{if(2048>Z)G[W++]=Z>>6|192;else{if(55296<=Z&&57343>=Z){if(56319>=Z&&j<k.length){var ue=k.charCodeAt(++j);if(56320<=ue&&57343>=ue){Z=1024*(Z-55296)+ue-56320+65536,G[W++]=Z>>18|240,G[W++]=Z>>12&63|128,G[W++]=Z>>6&63|128,G[W++]=Z&63|128;continue}else j--}if(P)throw Error("Found an unpaired surrogate");Z=65533}G[W++]=Z>>12|224,G[W++]=Z>>6&63|128}G[W++]=Z&63|128}}k=W===G.length?G:G.subarray(0,W)}Vs(v.h,8*E+2),Vs(v.h,k.length),Ws(v,v.h.end()),Ws(v,k)}}),wo=bo(function(v,k,E,P,W){if(v.i!==2)return!1;k=Yu(k,E,P),E=v.h.j,P=Ms(v.h)>>>0;var G=v.h.h+P,j=G-E;if(0>=j&&(v.h.j=G,W(k,v,void 0,void 0,void 0),j=G-v.h.h),j)throw Error("Message parsing ended unexpectedly. Expected to read "+(P+" bytes, instead read "+(P-j)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return v.h.h=G,v.h.j=E,!0},function(v,k,E,P,W){if(k=Ni(k,P,E),k!=null)for(P=0;P<k.length;P++){var G=v;Vs(G.h,8*E+2);var j=G.h.end();Ws(G,j),j.push(G.i),G=j,W(k[P],v),j=v;var Z=G.pop();for(Z=j.i+j.h.length()-Z;127<Z;)G.push(Z&127|128),Z>>>=7,j.i++;G.push(Z),j.i++}});function js(v){return function(k,E){e:{if(er.length){var P=er.pop();P.setOptions(E),Uo(P.h,k,E),k=P}else k=new _a(k,E);try{var W=Jr(v),G=es(new W.P,k,W);break e}finally{W=k.h,W.i=null,W.m=!1,W.l=0,W.j=0,W.h=0,W.S=!1,k.l=-1,k.i=-1,100>er.length&&er.push(k)}G=void 0}return G}}function U(v){return function(){var k=new ki;Ju(this,k,pr(v)),Ws(k,k.h.end());for(var E=new Uint8Array(k.i),P=k.j,W=P.length,G=0,j=0;j<W;j++){var Z=P[j];E.set(Z,G),G+=Z.length}return k.j=[E],E}}function J(v){wn.call(this,v)}w(J,wn);var de=[J,1,Ud,2,Un,3,Yo,4,Yo];J.prototype.l=U(de);function Oe(v){wn.call(this,v,-1,dt)}w(Oe,wn),Oe.prototype.addClassification=function(v,k){return Yu(this,1,J,v,k),this};var dt=[1],Tt=js([Oe,1,wo,de]);function It(v){wn.call(this,v)}w(It,wn);var at=[It,1,Un,2,Un,3,Un,4,Un,5,Un];It.prototype.l=U(at);function _t(v){wn.call(this,v,-1,jn)}w(_t,wn);var jn=[1],Gn=js([_t,1,wo,at]);function Ar(v){wn.call(this,v)}w(Ar,wn);var So=[Ar,1,Un,2,Un,3,Un,4,Un,5,Un,6,Bl],za=js(So);Ar.prototype.l=U(So);function Rn(v,k,E){if(E=v.createShader(E===0?v.VERTEX_SHADER:v.FRAGMENT_SHADER),v.shaderSource(E,k),v.compileShader(E),!v.getShaderParameter(E,v.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+v.getShaderInfoLog(E));return E}function Ba(v){return Ni(v,J,1).map(function(k){var E=Mn(k,1);return{index:E??0,qa:Vn(k,2),label:Mn(k,3)!=null?Ei(Mn(k,3),""):void 0,displayName:Mn(k,4)!=null?Ei(Mn(k,4),""):void 0}})}function jd(v){return{x:Vn(v,1),y:Vn(v,2),z:Vn(v,3),visibility:Dl(v,4)!=null?Vn(v,4):void 0}}function zi(v){return Ni(Gn(v),It,1).map(jd)}function Gd(v,k){this.i=v,this.h=k,this.m=0}function ec(v,k,E){return Hd(v,k),typeof v.h.canvas.transferToImageBitmap=="function"?Promise.resolve(v.h.canvas.transferToImageBitmap()):E?Promise.resolve(v.h.canvas):typeof createImageBitmap=="function"?createImageBitmap(v.h.canvas):(v.j===void 0&&(v.j=document.createElement("canvas")),new Promise(function(P){v.j.height=v.h.canvas.height,v.j.width=v.h.canvas.width,v.j.getContext("2d",{}).drawImage(v.h.canvas,0,0,v.h.canvas.width,v.h.canvas.height),P(v.j)}))}function Hd(v,k){var E=v.h;if(v.s===void 0){var P=Rn(E,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),W=Rn(E,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),G=E.createProgram();if(E.attachShader(G,P),E.attachShader(G,W),E.linkProgram(G),!E.getProgramParameter(G,E.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+E.getProgramInfoLog(G));P=v.s=G,E.useProgram(P),W=E.getUniformLocation(P,"sampler0"),v.l={O:E.getAttribLocation(P,"aVertex"),N:E.getAttribLocation(P,"aTex"),ya:W},v.v=E.createBuffer(),E.bindBuffer(E.ARRAY_BUFFER,v.v),E.enableVertexAttribArray(v.l.O),E.vertexAttribPointer(v.l.O,2,E.FLOAT,!1,0,0),E.bufferData(E.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),E.STATIC_DRAW),E.bindBuffer(E.ARRAY_BUFFER,null),v.u=E.createBuffer(),E.bindBuffer(E.ARRAY_BUFFER,v.u),E.enableVertexAttribArray(v.l.N),E.vertexAttribPointer(v.l.N,2,E.FLOAT,!1,0,0),E.bufferData(E.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),E.STATIC_DRAW),E.bindBuffer(E.ARRAY_BUFFER,null),E.uniform1i(W,0)}P=v.l,E.useProgram(v.s),E.canvas.width=k.width,E.canvas.height=k.height,E.viewport(0,0,k.width,k.height),E.activeTexture(E.TEXTURE0),v.i.bindTexture2d(k.glName),E.enableVertexAttribArray(P.O),E.bindBuffer(E.ARRAY_BUFFER,v.v),E.vertexAttribPointer(P.O,2,E.FLOAT,!1,0,0),E.enableVertexAttribArray(P.N),E.bindBuffer(E.ARRAY_BUFFER,v.u),E.vertexAttribPointer(P.N,2,E.FLOAT,!1,0,0),E.bindFramebuffer(E.DRAW_FRAMEBUFFER?E.DRAW_FRAMEBUFFER:E.FRAMEBUFFER,null),E.clearColor(0,0,0,0),E.clear(E.COLOR_BUFFER_BIT),E.colorMask(!0,!0,!0,!0),E.drawArrays(E.TRIANGLE_FAN,0,4),E.disableVertexAttribArray(P.O),E.disableVertexAttribArray(P.N),E.bindBuffer(E.ARRAY_BUFFER,null),v.i.bindTexture2d(0)}function Ml(v){this.h=v}var tc=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function ip(v,k){return k+v}function ap(v,k){window[v]=k}function Ey(v){var k=document.createElement("script");return k.setAttribute("src",v),k.setAttribute("crossorigin","anonymous"),new Promise(function(E){k.addEventListener("load",function(){E()},!1),k.addEventListener("error",function(){E()},!1),document.body.appendChild(k)})}function Ry(){return A(function(v){switch(v.h){case 1:return v.s=2,R(v,WebAssembly.instantiate(tc),4);case 4:v.h=3,v.s=0;break;case 2:return v.s=0,v.l=null,v.return(!1);case 3:return v.return(!0)}})}function Vl(v){if(this.h=v,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=v&&v.locateFile||ip,typeof window=="object")var k=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")k=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.ha=k,v.options){k=a(Object.keys(v.options));for(var E=k.next();!E.done;E=k.next()){E=E.value;var P=v.options[E].default;P!==void 0&&(this.l[E]=typeof P=="function"?P():P)}}}t=Vl.prototype,t.close=function(){return this.j&&this.j.delete(),Promise.resolve()};function _y(v){var k,E,P,W,G,j,Z,ue,Ce,_e,Je;return A(function(He){switch(He.h){case 1:return v.ga?(k=v.h.files===void 0?[]:typeof v.h.files=="function"?v.h.files(v.l):v.h.files,R(He,Ry(),2)):He.return();case 2:if(E=He.i,typeof window=="object")return ap("createMediapipeSolutionsWasm",{locateFile:v.locateFile}),ap("createMediapipeSolutionsPackedAssets",{locateFile:v.locateFile}),j=k.filter(function(Ae){return Ae.data!==void 0}),Z=k.filter(function(Ae){return Ae.data===void 0}),ue=Promise.all(j.map(function(Ae){var Ke=nc(v,Ae.url);if(Ae.path!==void 0){var ht=Ae.path;Ke=Ke.then(function(qt){return v.overrideFile(ht,qt),Promise.resolve(qt)})}return Ke})),Ce=Promise.all(Z.map(function(Ae){return Ae.simd===void 0||Ae.simd&&E||!Ae.simd&&!E?Ey(v.locateFile(Ae.url,v.ha)):Promise.resolve()})).then(function(){var Ae,Ke,ht;return A(function(qt){if(qt.h==1)return Ae=window.createMediapipeSolutionsWasm,Ke=window.createMediapipeSolutionsPackedAssets,ht=v,R(qt,Ae(Ke),2);ht.i=qt.i,qt.h=0})}),_e=function(){return A(function(Ae){return v.h.graph&&v.h.graph.url?Ae=R(Ae,nc(v,v.h.graph.url),0):(Ae.h=0,Ae=void 0),Ae})}(),R(He,Promise.all([Ce,ue,_e]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return P=k.filter(function(Ae){return Ae.simd===void 0||Ae.simd&&E||!Ae.simd&&!E}).map(function(Ae){return v.locateFile(Ae.url,v.ha)}),importScripts.apply(null,l(P)),W=v,R(He,createMediapipeSolutionsWasm(Module),6);case 6:W.i=He.i,v.m=new OffscreenCanvas(1,1),v.i.canvas=v.m,G=v.i.GL.createContext(v.m,{antialias:!1,alpha:!1,va:typeof WebGL2RenderingContext<"u"?2:1}),v.i.GL.makeContextCurrent(G),He.h=4;break;case 7:if(v.m=document.createElement("canvas"),Je=v.m.getContext("webgl2",{}),!Je&&(Je=v.m.getContext("webgl",{}),!Je))return alert("Failed to create WebGL canvas context when passing video frame."),He.return();v.K=Je,v.i.canvas=v.m,v.i.createContext(v.m,!0,!0,{});case 4:v.j=new v.i.SolutionWasm,v.ga=!1,He.h=0}})}function Py(v){var k,E,P,W,G,j,Z,ue;return A(function(Ce){if(Ce.h==1){if(v.h.graph&&v.h.graph.url&&v.fa===v.h.graph.url)return Ce.return();if(v.u=!0,!v.h.graph||!v.h.graph.url){Ce.h=2;return}return v.fa=v.h.graph.url,R(Ce,nc(v,v.h.graph.url),3)}for(Ce.h!=2&&(k=Ce.i,v.j.loadGraph(k)),E=a(Object.keys(v.D)),P=E.next();!P.done;P=E.next())W=P.value,v.j.overrideFile(W,v.D[W]);if(v.D={},v.h.listeners)for(G=a(v.h.listeners),j=G.next();!j.done;j=G.next())Z=j.value,Fy(v,Z);ue=v.l,v.l={},v.setOptions(ue),Ce.h=0})}t.reset=function(){var v=this;return A(function(k){v.j&&(v.j.reset(),v.s={},v.v={}),k.h=0})},t.setOptions=function(v,k){var E=this;if(k=k||this.h.options){for(var P=[],W=[],G={},j=a(Object.keys(v)),Z=j.next();!Z.done;G={X:G.X,Y:G.Y},Z=j.next())if(Z=Z.value,!(Z in this.l&&this.l[Z]===v[Z])){this.l[Z]=v[Z];var ue=k[Z];ue!==void 0&&(ue.onChange&&(G.X=ue.onChange,G.Y=v[Z],P.push(function(Ce){return function(){var _e;return A(function(Je){if(Je.h==1)return R(Je,Ce.X(Ce.Y),2);_e=Je.i,_e===!0&&(E.u=!0),Je.h=0})}}(G))),ue.graphOptionXref&&(Z=Object.assign({},{calculatorName:"",calculatorIndex:0},ue.graphOptionXref,{valueNumber:ue.type===1?v[Z]:0,valueBoolean:ue.type===0?v[Z]:!1,valueString:ue.type===2?v[Z]:""}),W.push(Z)))}(P.length!==0||W.length!==0)&&(this.u=!0,this.H=(this.H===void 0?[]:this.H).concat(W),this.F=(this.F===void 0?[]:this.F).concat(P))}};function Ay(v){var k,E,P,W,G,j,Z;return A(function(ue){switch(ue.h){case 1:if(!v.u)return ue.return();if(!v.F){ue.h=2;break}k=a(v.F),E=k.next();case 3:if(E.done){ue.h=5;break}return P=E.value,R(ue,P(),4);case 4:E=k.next(),ue.h=3;break;case 5:v.F=void 0;case 2:if(v.H){for(W=new v.i.GraphOptionChangeRequestList,G=a(v.H),j=G.next();!j.done;j=G.next())Z=j.value,W.push_back(Z);v.j.changeOptions(W),W.delete(),v.H=void 0}v.u=!1,ue.h=0}})}t.initialize=function(){var v=this;return A(function(k){return k.h==1?R(k,_y(v),2):k.h!=3?R(k,Py(v),3):R(k,Ay(v),0)})};function nc(v,k){var E,P;return A(function(W){return k in v.L?W.return(v.L[k]):(E=v.locateFile(k,""),P=fetch(E).then(function(G){return G.arrayBuffer()}),v.L[k]=P,W.return(P))})}t.overrideFile=function(v,k){this.j?this.j.overrideFile(v,k):this.D[v]=k},t.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},t.send=function(v,k){var E=this,P,W,G,j,Z,ue,Ce,_e,Je;return A(function(He){switch(He.h){case 1:return E.h.inputs?(P=1e3*(k??performance.now()),R(He,E.I,2)):He.return();case 2:return R(He,E.initialize(),3);case 3:for(W=new E.i.PacketDataList,G=a(Object.keys(v)),j=G.next();!j.done;j=G.next())if(Z=j.value,ue=E.h.inputs[Z]){e:{var Ae=v[Z];switch(ue.type){case"video":var Ke=E.s[ue.stream];if(Ke||(Ke=new Gd(E.i,E.K),E.s[ue.stream]=Ke),Ke.m===0&&(Ke.m=Ke.i.createTexture()),typeof HTMLVideoElement<"u"&&Ae instanceof HTMLVideoElement)var ht=Ae.videoWidth,qt=Ae.videoHeight;else typeof HTMLImageElement<"u"&&Ae instanceof HTMLImageElement?(ht=Ae.naturalWidth,qt=Ae.naturalHeight):(ht=Ae.width,qt=Ae.height);qt={glName:Ke.m,width:ht,height:qt},ht=Ke.h,ht.canvas.width=qt.width,ht.canvas.height=qt.height,ht.activeTexture(ht.TEXTURE0),Ke.i.bindTexture2d(Ke.m),ht.texImage2D(ht.TEXTURE_2D,0,ht.RGBA,ht.RGBA,ht.UNSIGNED_BYTE,Ae),Ke.i.bindTexture2d(0),Ke=qt;break e;case"detections":for(Ke=E.s[ue.stream],Ke||(Ke=new Ml(E.i),E.s[ue.stream]=Ke),Ke.data||(Ke.data=new Ke.h.DetectionListData),Ke.data.reset(Ae.length),qt=0;qt<Ae.length;++qt){ht=Ae[qt];var jt=Ke.data,Tn=jt.setBoundingBox,Dr=qt,rr=ht.la,yt=new Ar;if(tr(yt,1,rr.sa),tr(yt,2,rr.ta),tr(yt,3,rr.height),tr(yt,4,rr.width),tr(yt,5,rr.rotation),Yr(yt,6,rr.pa),rr=yt.l(),Tn.call(jt,Dr,rr),ht.ea)for(jt=0;jt<ht.ea.length;++jt){yt=ht.ea[jt],Tn=Ke.data,Dr=Tn.addNormalizedLandmark,rr=qt,yt=Object.assign({},yt,{visibility:yt.visibility?yt.visibility:0});var _n=new It;tr(_n,1,yt.x),tr(_n,2,yt.y),tr(_n,3,yt.z),yt.visibility&&tr(_n,4,yt.visibility),yt=_n.l(),Dr.call(Tn,rr,yt)}if(ht.ba)for(jt=0;jt<ht.ba.length;++jt)Tn=Ke.data,Dr=Tn.addClassification,rr=qt,yt=ht.ba[jt],_n=new J,tr(_n,2,yt.qa),yt.index&&Yr(_n,1,yt.index),yt.label&&Yr(_n,3,yt.label),yt.displayName&&Yr(_n,4,yt.displayName),yt=_n.l(),Dr.call(Tn,rr,yt)}Ke=Ke.data;break e;default:Ke={}}}switch(Ce=Ke,_e=ue.stream,ue.type){case"video":W.pushTexture2d(Object.assign({},Ce,{stream:_e,timestamp:P}));break;case"detections":Je=Ce,Je.stream=_e,Je.timestamp=P,W.pushDetectionList(Je);break;default:throw Error("Unknown input config type: '"+ue.type+"'")}}return E.j.send(W),R(He,E.I,4);case 4:W.delete(),He.h=0}})};function Dy(v,k,E){var P,W,G,j,Z,ue,Ce,_e,Je,He,Ae,Ke,ht,qt;return A(function(jt){switch(jt.h){case 1:if(!E)return jt.return(k);for(P={},W=0,G=a(Object.keys(E)),j=G.next();!j.done;j=G.next())Z=j.value,ue=E[Z],typeof ue!="string"&&ue.type==="texture"&&k[ue.stream]!==void 0&&++W;1<W&&(v.M=!1),Ce=a(Object.keys(E)),j=Ce.next();case 2:if(j.done){jt.h=4;break}if(_e=j.value,Je=E[_e],typeof Je=="string")return ht=P,qt=_e,R(jt,lp(v,_e,k[Je]),14);if(He=k[Je.stream],Je.type==="detection_list"){if(He){for(var Tn=He.getRectList(),Dr=He.getLandmarksList(),rr=He.getClassificationsList(),yt=[],_n=0;_n<Tn.size();++_n){var Qo=za(Tn.get(_n)),Oy=Vn(Qo,1),dp=Vn(Qo,2),hp=Vn(Qo,3),Wl=Vn(Qo,4),Ul=Vn(Qo,5,0),rc=void 0;rc=rc===void 0?0:rc,Qo={la:{sa:Oy,ta:dp,height:hp,width:Wl,rotation:Ul,pa:Ei(Mn(Qo,6),rc)},ea:zi(Dr.get(_n)),ba:Ba(Tt(rr.get(_n)))},yt.push(Qo)}Tn=yt}else Tn=[];P[_e]=Tn,jt.h=7;break}if(Je.type==="proto_list"){if(He){for(Tn=Array(He.size()),Dr=0;Dr<He.size();Dr++)Tn[Dr]=He.get(Dr);He.delete()}else Tn=[];P[_e]=Tn,jt.h=7;break}if(He===void 0){jt.h=3;break}if(Je.type==="float_list"){P[_e]=He,jt.h=7;break}if(Je.type==="proto"){P[_e]=He,jt.h=7;break}if(Je.type!=="texture")throw Error("Unknown output config type: '"+Je.type+"'");return Ae=v.v[_e],Ae||(Ae=new Gd(v.i,v.K),v.v[_e]=Ae),R(jt,ec(Ae,He,v.M),13);case 13:Ke=jt.i,P[_e]=Ke;case 7:Je.transform&&P[_e]&&(P[_e]=Je.transform(P[_e])),jt.h=3;break;case 14:ht[qt]=jt.i;case 3:j=Ce.next(),jt.h=2;break;case 4:return jt.return(P)}})}function lp(v,k,E){var P;return A(function(W){return typeof E=="number"||E instanceof Uint8Array||E instanceof v.i.Uint8BlobList?W.return(E):E instanceof v.i.Texture2dDataOut?(P=v.v[k],P||(P=new Gd(v.i,v.K),v.v[k]=P),W.return(ec(P,E,v.M))):W.return(void 0)})}function Fy(v,k){for(var E=k.name||"$",P=[].concat(l(k.wants)),W=new v.i.StringList,G=a(k.wants),j=G.next();!j.done;j=G.next())W.push_back(j.value);G=v.i.PacketListener.implement({onResults:function(Z){for(var ue={},Ce=0;Ce<k.wants.length;++Ce)ue[P[Ce]]=Z.get(Ce);var _e=v.listeners[E];_e&&(v.I=Dy(v,ue,k.outs).then(function(Je){Je=_e(Je);for(var He=0;He<k.wants.length;++He){var Ae=ue[P[He]];typeof Ae=="object"&&Ae.hasOwnProperty&&Ae.hasOwnProperty("delete")&&Ae.delete()}Je&&(v.I=Je)}))}}),v.j.attachMultiListener(W,G),W.delete()}t.onResults=function(v,k){this.listeners[k||"$"]=v},ye("Solution",Vl),ye("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"});function up(v){switch(v===void 0&&(v=0),v){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function cp(v){var k=this;v=v||{},this.h=new Vl({locateFile:v.locateFile,files:function(E){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:up(E.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:zi},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:zi},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window!="object"||window.navigator===void 0?!1:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(E){var P,W,G;return A(function(j){return j.h==1?(P=up(E),W="third_party/mediapipe/modules/pose_landmark/"+P,R(j,nc(k.h,P),2)):(G=j.i,k.h.overrideFile(W,G),j.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}t=cp.prototype,t.reset=function(){this.h.reset()},t.close=function(){return this.h.close(),Promise.resolve()},t.onResults=function(v){this.h.onResults(v)},t.initialize=function(){var v=this;return A(function(k){return R(k,v.h.initialize(),0)})},t.send=function(v,k){var E=this;return A(function(P){return R(P,E.h.send(v,k),0)})},t.setOptions=function(v){this.h.setOptions(v)},ye("Pose",cp),ye("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),ye("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),ye("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),ye("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),ye("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),ye("VERSION","0.5.1675469404")}).call(rx)),rx}var sye=rye();/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oye=oe();oye.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var ls;(function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"})(ls||(ls={}));var gE;(function(t){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))})(gE||(gE={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iye={};function cO(t){return iye[t]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N(t,e,n,r,s){const o=e.inputParams[t];if(o&&o.inputIndexStart!==void 0){const a=o.inputIndexStart,l=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?a+1:o.inputIndexEnd,c=a<0?e.inputNames.length+a:a;if(o.type==="tensor")return Yn(e.inputNames[c],n,r,s);if(o.type==="tensors"){const p=e.inputs.slice(a,l);return e.inputNames.slice(a,l).filter((y,x)=>{var w;return((w=p[x])===null||w===void 0?void 0:w.op)!=="NoOp"}).map(y=>Yn(y,n,r,s))}const d=Yn(e.inputNames[c],n,r,s),f=d.dataSync();return o.type==="number"?f[0]:tv(d.shape,f)}const i=e.attrParams[t];return i&&i.value}function Yn(t,e,n,r){const[s,o]=us(t,n);if(r!=null){const a=r.getHashTableHandleByName(s);if(a!=null)return a}const i=n.currentContextIds.find(a=>!!e[Og(s,a)]);return i!==void 0?e[Og(s,i)][o]:void 0}function yE(t,e,n){return e[Og(t,n.currentContextId)]}function Xi(t,e){const[n,r,s]=us(t,e);return[Og(n,e&&e.currentContextId),r,s]}function Og(t,e){return e?`${t}-${e}`:t}function us(t,e){if(t==="")return["",0,void 0];const n=e!=null&&e.parseNodeNameCache!=null;if(n){const o=e.parseNodeNameCache.get(t);if(o!=null)return o}const r=t.split(":");let s;if(r.length===1)s=[t,0,void 0];else{const o=r[0],i=r.length===3?r[1]:void 0,a=Number(r[r.length-1]);s=[o,a,i]}return n&&e.parseNodeNameCache.set(t,s),s}function tg(t,e,n){let r=N("pad",t,e,n);if(r==="explicit"){r=N("explicitPaddings",t,e,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)s[o][0]=r[o*2],s[o][1]=r[o*2+1];return s}return r}function qi(t){return t.kept?t:dl(t)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aye=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],lye=Object.freeze(Object.defineProperty({__proto__:null,json:aye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uye=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],cye=Object.freeze(Object.defineProperty({__proto__:null,json:uye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dye=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],hye=Object.freeze(Object.defineProperty({__proto__:null,json:dye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fye=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],pye=Object.freeze(Object.defineProperty({__proto__:null,json:fye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mye=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],gye=Object.freeze(Object.defineProperty({__proto__:null,json:mye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yye=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],xye=Object.freeze(Object.defineProperty({__proto__:null,json:yye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vye=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],bye=Object.freeze(Object.defineProperty({__proto__:null,json:vye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wye=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Sye=Object.freeze(Object.defineProperty({__proto__:null,json:wye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cye=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],$ye=Object.freeze(Object.defineProperty({__proto__:null,json:Cye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kye=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Tye=Object.freeze(Object.defineProperty({__proto__:null,json:kye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iye=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],Nye=Object.freeze(Object.defineProperty({__proto__:null,json:Iye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eye=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Rye=Object.freeze(Object.defineProperty({__proto__:null,json:Eye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ye=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Pye=Object.freeze(Object.defineProperty({__proto__:null,json:_ye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aye=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Dye=Object.freeze(Object.defineProperty({__proto__:null,json:Aye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fye=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Oye=Object.freeze(Object.defineProperty({__proto__:null,json:Fye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lye=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],zye=Object.freeze(Object.defineProperty({__proto__:null,json:Lye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bye=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Mye=Object.freeze(Object.defineProperty({__proto__:null,json:Bye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vye=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Wye=Object.freeze(Object.defineProperty({__proto__:null,json:Vye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uye=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],jye=Object.freeze(Object.defineProperty({__proto__:null,json:Uye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xE{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[lye,cye,hye,pye,gye,xye,bye,Sye,$ye,Tye,Nye,Rye,Pye,Dye,Oye,zye,Mye,Wye,jye],n=[].concat(...e.map(r=>r.json));this.opMappers=n.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(e,n={}){const r=e.node,s=[],o=[],i=[],a=r.reduce((x,w)=>(x[w.name]=this.mapNode(w),w.op.startsWith("Placeholder")?s.push(x[w.name]):w.op==="Const"?o.push(x[w.name]):(w.input==null||w.input.length===0)&&i.push(x[w.name]),x),{});let l=[];const c=[];let d={},f={};n!=null&&(d=this.mapSignatureEntries(n.inputs),f=this.mapSignatureEntries(n.outputs));const p=Object.keys(a);p.forEach(x=>{const w=a[x];w.inputNames.forEach((S,$)=>{const[I,,R]=Xi(S),_=a[I];if(_.outputs!=null){const F=_.outputs.indexOf(R);if(F!==-1){const O=`${I}:${F}`;w.inputNames[$]=O}}w.inputs.push(_),_.children.push(w)})}),Object.keys(f).length===0?p.forEach(x=>{const w=a[x];w.children.length===0&&c.push(w)}):Object.keys(f).forEach(x=>{const[w]=Xi(x),S=a[w];S!=null&&(S.signatureKey=f[x],c.push(S))}),Object.keys(d).length>0?Object.keys(d).forEach(x=>{const[w]=Xi(x),S=a[w];S&&(S.signatureKey=d[x],l.push(S))}):l=s;let g={};e.library!=null&&e.library.function!=null&&(g=e.library.function.reduce((x,w)=>(x[w.signature.name]=this.mapFunction(w),x),{}));const y={nodes:a,inputs:l,outputs:c,weights:o,placeholders:s,signature:n,functions:g};return i.length>0&&(y.initNodes=i),y}mapSignatureEntries(e){return Object.keys(e||{}).reduce((n,r)=>(n[e[r].name]=r,n),{})}mapNode(e){const n=cO(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const r={name:e.name,op:e.op,category:n.category,inputNames:(e.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:n.outputs};return n.inputs!=null&&(r.inputParams=n.inputs.reduce((s,o)=>(s[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},s),{})),n.attrs!=null&&(r.attrParams=n.attrs.reduce((s,o)=>{const i=o.type;let a;switch(o.type){case"string":a=$v(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=$v(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":a=_v(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=_v(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":a=Tv(e.attr,o.tfName,o.defaultValue||0),a===void 0&&o.tfDeprecatedName&&(a=Tv(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":a=Rv(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Rv(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":a=kv(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=kv(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":a=Av(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Av(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":a=Ev(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Ev(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":a=Pv(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Pv(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":a=Iv(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Iv(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":a=Nv(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Nv(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":a=vE(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=vE(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${e.op}`)}return s[o.name]={value:a,type:i},s},{})),r}mapFunction(e){const n=e.nodeDef,r=[],s=[];let o={};n!=null&&(o=n.reduce((f,p)=>(f[p.name]=this.mapNode(p),p.op==="Const"&&s.push(f[p.name]),f),{}));const i=[],a=[];e.signature.inputArg.forEach(f=>{const[p]=Xi(f.name),g={name:p,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:LC(f.type),type:"dtype"}},children:[]};g.signatureKey=f.name,i.push(g),o[p]=g}),Object.keys(o).forEach(f=>{const p=o[f];p.inputNames.forEach((g,y)=>{const[x,,w]=Xi(g),S=o[x];if(S.outputs!=null){const $=S.outputs.indexOf(w);if($!==-1){const I=`${x}:${$}`;p.inputNames[y]=I}}p.inputs.push(S),S.children.push(p)})});const c=e.ret;e.signature.outputArg.forEach(f=>{const[p,g]=Xi(c[f.name]),y=o[p];y!=null&&(y.defaultOutput=g,a.push(y))});const d=this.mapArgsToSignature(e);return{nodes:o,inputs:i,outputs:a,weights:s,placeholders:r,signature:d}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r),n),{}),outputs:e.signature.outputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r,e.ret),n),{})}}mapArgToTensorInfo(e,n){let r=e.name;return n!=null&&(r=n[r]),{name:r,dtype:e.type}}}function Gye(t){const e=oe().global;if(typeof e.atob<"u")return e.atob(t);if(typeof Buffer<"u")return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function dO(t,e){const n=Array.isArray(t)?String.fromCharCode.apply(null,t):Gye(t);return e?n:n.toLowerCase()}function $v(t,e,n,r=!1){const s=t[e];return s!=null?dO(s.s,r):n}function kv(t,e,n){const r=t[e];return r?r.b:n}function Tv(t,e,n){const r=t[e]||{},s=r.i!=null?r.i:r.f!=null?r.f:n;return typeof s=="number"?s:parseInt(s,10)}function LC(t){switch(typeof t=="string"&&(t=ls[t]),t){case ls.DT_FLOAT:case ls.DT_HALF:return"float32";case ls.DT_INT32:case ls.DT_INT64:case ls.DT_INT8:case ls.DT_UINT8:return"int32";case ls.DT_BOOL:return"bool";case ls.DT_DOUBLE:return"float32";case ls.DT_STRING:return"string";case ls.DT_COMPLEX64:case ls.DT_COMPLEX128:return"complex64";default:return null}}function vE(t,e,n){const r=t[e];return r&&r.func?r.func.name:n}function Iv(t,e,n){const r=t[e];return r&&r.type?LC(r.type):n}function Nv(t,e,n){const r=t[e];return r&&r.list&&r.list.type?r.list.type.map(s=>LC(s)):n}function hO(t){if(!t.unknownRank)return t.dim!=null?t.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function Ev(t,e,n){const r=t[e];return r&&r.shape?hO(r.shape):n}function Rv(t,e,n){const r=t[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):n}function _v(t,e,n,r=!1){const s=t[e];return s&&s.list&&s.list.s?s.list.s.map(o=>dO(o,r)):n}function Pv(t,e,n){const r=t[e];return r&&r.list&&r.list.shape?r.list.shape.map(s=>hO(s)):n}function Av(t,e,n){const r=t[e];return r&&r.list&&r.list.b?r.list.b:n}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hye{constructor(e,n,r){this.node=e,this.tensorMap=n,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(s=>this.getInput(s)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((s,o)=>(s[o]=this.getAttr(o),s),{}))}getInput(e){return Yn(e,this.tensorMap,this.context)}getAttr(e,n){const r=this.node.rawAttrs[e];if(r.tensor!=null)return Yn(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return Tv(this.node.rawAttrs,e,n);if(r.s!=null)return $v(this.node.rawAttrs,e,n);if(r.b!=null)return kv(this.node.rawAttrs,e,n);if(r.shape!=null)return Ev(this.node.rawAttrs,e,n);if(r.type!=null)return Iv(this.node.rawAttrs,e,n);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return Rv(this.node.rawAttrs,e,n);if(r.list.s!=null)return _v(this.node.rawAttrs,e,n);if(r.list.shape!=null)return Pv(this.node.rawAttrs,e,n);if(r.list.b!=null)return Av(this.node.rawAttrs,e,n);if(r.list.type!=null)return Nv(this.node.rawAttrs,e,n)}return n}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zn=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:DA,abs:Ns,acos:kq,acosh:Iq,add:Ue,addN:Eq,all:_q,any:Aq,argMax:YA,argMin:Oq,asin:zq,asinh:Mq,atan:Wq,atan2:jq,atanh:Hq,avgPool:QA,avgPool3d:eY,basicLSTMCell:aY,batchNorm:uy,batchNorm2d:hY,batchNorm3d:pY,batchNorm4d:gY,batchToSpaceND:ZA,bincount:JA,bitwiseAnd:vY,booleanMaskAsync:ste,broadcastArgs:wY,broadcastTo:Zh,buffer:Vt,cast:Qt,ceil:$Y,clipByValue:eD,clone:dl,complex:ml,concat:On,concat1d:IY,concat2d:EY,concat3d:_Y,concat4d:AY,conv1d:OY,conv2d:cy,conv2dTranspose:BY,conv3d:VY,conv3dTranspose:GY,cos:KY,cosh:qY,cosineWindow:KS,cumprod:QY,cumsum:JY,denseBincount:tQ,depthToSpace:rQ,depthwiseConv2d:LS,diag:iQ,dilation2d:lQ,div:gt,divNoNan:fQ,dot:mQ,dropout:yte,einsum:_c,elu:sD,enclosingPowerOfTwo:AD,ensureShape:vQ,equal:rD,erf:wQ,euclideanNorm:RQ,exp:fa,expandDims:Es,expm1:DQ,eye:aD,fft:jS,fill:qf,floor:lD,floorDiv:qA,fused:Pte,gather:uD,gatherND:pte,greater:hy,greaterEqual:cD,ifft:Rg,imag:fy,image:ku,inTopKAsync:vte,irfft:TD,isFinite:UQ,isInf:GQ,isNaN:KQ,leakyRelu:dD,less:mv,lessEqual:BS,linalg:dre,linspace:QQ,localResponseNormalization:JQ,log:wf,log1p:hD,logSigmoid:iZ,logSoftmax:uZ,logSumExp:pD,logicalAnd:Ng,logicalNot:mD,logicalOr:gD,logicalXor:mZ,losses:hre,lowerBound:yZ,matMul:Ht,max:Jc,maxPool:yD,maxPool3d:bZ,maxPoolWithArgmax:SZ,maximum:xD,mean:Eg,meshgrid:kZ,min:pv,minimum:Sf,mirrorPad:vD,mod:EZ,moments:_Z,movingAverage:ate,mul:Te,multiRNNCell:AZ,multinomial:FZ,neg:xi,norm:dy,notEqual:bD,oneHot:zZ,ones:vu,onesLike:MZ,op:X,outerProduct:WZ,pad:yl,pad1d:GZ,pad2d:KZ,pad3d:qZ,pad4d:QZ,pool:nJ,pow:bf,prelu:SD,print:XA,prod:oJ,raggedGather:aJ,raggedRange:uJ,raggedTensorToTensor:dJ,rand:fJ,randomGamma:FJ,randomNormal:CD,randomStandardNormal:zJ,randomUniform:US,randomUniformInt:VJ,range:Cf,real:$f,reciprocal:jJ,relu:py,relu6:$D,reshape:xe,reverse:Du,reverse1d:qJ,reverse2d:QJ,reverse3d:JJ,reverse4d:tee,rfft:GS,round:kD,rsqrt:see,scalar:pt,scatterND:ute,searchSorted:MS,selu:iee,separableConv2d:lee,setdiff1dAsync:cee,sigmoid:sa,sign:hee,signal:cre,sin:pee,sinh:gee,slice:ft,slice1d:xee,slice2d:bee,slice3d:See,slice4d:$ee,softmax:Tee,softplus:fD,spaceToBatchND:wD,sparse:fre,sparseToDense:hte,spectral:ure,split:kf,sqrt:ha,square:ao,squaredDifference:ID,squeeze:Gt,stack:ga,step:ND,stridedSlice:Lee,string:pre,sub:ot,sum:en,tan:Bee,tanh:fv,tensor:yi,tensor1d:lr,tensor2d:lo,tensor3d:ED,tensor4d:Mee,tensor5d:Vee,tensor6d:Wee,tensorScatterUpdate:jee,tile:Jh,topk:Hee,transpose:gv,truncatedNormal:Xee,unique:Yee,unsortedSegmentSum:Zee,unstack:Bu,upperBound:ete,variable:tte,where:hl,whereAsync:PD,zeros:ma,zerosLike:As},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kye=(t,e,n,r=Zn)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(N("a",t,e,n),N("b",t,e,n))];case"AddN":return[r.addN(N("tensors",t,e,n))];case"FloorMod":case"Mod":return[r.mod(N("a",t,e,n),N("b",t,e,n))];case"Mul":return[r.mul(N("a",t,e,n),N("b",t,e,n))];case"RealDiv":case"Div":return[r.div(N("a",t,e,n),N("b",t,e,n))];case"DivNoNan":return[r.divNoNan(N("a",t,e,n),N("b",t,e,n))];case"FloorDiv":return[r.floorDiv(N("a",t,e,n),N("b",t,e,n))];case"Sub":return[r.sub(N("a",t,e,n),N("b",t,e,n))];case"Minimum":return[r.minimum(N("a",t,e,n),N("b",t,e,n))];case"Maximum":return[r.maximum(N("a",t,e,n),N("b",t,e,n))];case"Pow":return[r.pow(N("a",t,e,n),N("b",t,e,n))];case"SquaredDifference":return[r.squaredDifference(N("a",t,e,n),N("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xye=(t,e,n,r=Zn)=>{switch(t.op){case"Abs":case"ComplexAbs":return[r.abs(N("x",t,e,n))];case"Acos":return[r.acos(N("x",t,e,n))];case"Acosh":return[r.acosh(N("x",t,e,n))];case"Asin":return[r.asin(N("x",t,e,n))];case"Asinh":return[r.asinh(N("x",t,e,n))];case"Atan":return[r.atan(N("x",t,e,n))];case"Atan2":return[r.atan2(N("x",t,e,n),N("y",t,e,n))];case"Atanh":return[r.atanh(N("x",t,e,n))];case"Ceil":return[r.ceil(N("x",t,e,n))];case"Complex":return[r.complex(N("real",t,e,n),N("imag",t,e,n))];case"Cos":return[r.cos(N("x",t,e,n))];case"Cosh":return[r.cosh(N("x",t,e,n))];case"Elu":return[r.elu(N("x",t,e,n))];case"Erf":return[r.erf(N("x",t,e,n))];case"Exp":return[r.exp(N("x",t,e,n))];case"Expm1":return[r.expm1(N("x",t,e,n))];case"Floor":return[r.floor(N("x",t,e,n))];case"Log":return[r.log(N("x",t,e,n))];case"Log1p":return[r.log1p(N("x",t,e,n))];case"Imag":return[r.imag(N("x",t,e,n))];case"Neg":return[r.neg(N("x",t,e,n))];case"Reciprocal":return[r.reciprocal(N("x",t,e,n))];case"Real":return[r.real(N("x",t,e,n))];case"Relu":return[r.relu(N("x",t,e,n))];case"Round":return[r.round(N("x",t,e,n))];case"Selu":return[r.selu(N("x",t,e,n))];case"Sigmoid":return[r.sigmoid(N("x",t,e,n))];case"Sin":return[r.sin(N("x",t,e,n))];case"Sign":return[r.sign(N("x",t,e,n))];case"Sinh":return[r.sinh(N("x",t,e,n))];case"Softplus":return[r.softplus(N("x",t,e,n))];case"Sqrt":return[r.sqrt(N("x",t,e,n))];case"Square":return[r.square(N("x",t,e,n))];case"Tanh":return[r.tanh(N("x",t,e,n))];case"Tan":return[r.tan(N("x",t,e,n))];case"ClipByValue":return[r.clipByValue(N("x",t,e,n),N("clipValueMin",t,e,n),N("clipValueMax",t,e,n))];case"Relu6":return[r.relu6(N("x",t,e,n))];case"Rsqrt":return[r.rsqrt(Yn(t.inputNames[0],e,n))];case"LeakyRelu":return[r.leakyRelu(N("x",t,e,n),N("alpha",t,e,n))];case"Prelu":return[r.prelu(N("x",t,e,n),N("alpha",t,e,n))];case"IsNan":return[r.isNaN(Yn(t.inputNames[0],e,n))];case"IsInf":return[r.isInf(Yn(t.inputNames[0],e,n))];case"IsFinite":return[r.isFinite(Yn(t.inputNames[0],e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function no(t,e,n=""){if(!(typeof t=="number"||typeof e=="number")){z(t.length===e.length,()=>n+` Shapes ${t} and ${e} must match`);for(let r=0;r<t.length;r++){const s=t[r],o=e[r];z(s<0||o<0||s===o,()=>n+` Shapes ${t} and ${e} must match`)}}}function bE(t){return!(typeof t=="number"||t.some(e=>e<0))}function Sh(t,e,n){let r=Dv(t,n);const s=!bE(r);if(s&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&e.forEach(o=>{r=Dv(o.shape,r)}),!bE(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function Dv(t,e){if(typeof t=="number")return e;if(typeof e=="number")return t;if(t.length!==e.length)throw new Error(`Incompatible ranks during merge: ${t} vs. ${e}`);const n=[];for(let r=0;r<t.length;++r){const s=t[r],o=e[r];if(s>=0&&o>=0&&s!==o)throw new Error(`Incompatible shape during merge: ${t} vs. ${e}`);n[r]=s>=0?s:o}return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qye{constructor(e,n,r,s,o,i,a){this.name=e,this.dtype=n,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=o,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=pt(0),ci(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.tensor.id))&&n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const n=this.tensors[e];if(n.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(e){return e.map(n=>this.read(n))}write(e,n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[e]||{};if(n.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=n.shape),no(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=n,ci(n),r.written=!0,this.tensors[e]=r}writeMany(e,n){if(e.length!==n.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${n.length}.`);e.forEach((r,s)=>this.write(r,n[s]))}gather(e,n){if(n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);if(e)e=e.slice(0,this.size());else{e=[];for(let s=0;s<this.size();s++)e.push(s)}if(e.length===0)return yi([],[0].concat(this.elementShape));const r=this.readMany(e);return no(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),ga(r,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return yi([],[0].concat(this.elementShape));const n=[];for(let s=0;s<this.size();s++)n.push(s);const r=this.readMany(n);return no(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),On(r,0)}scatter(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,Bu(n,0))}split(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);let r=0;const s=e.map(l=>(r+=l,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const o=r===0?0:n.size/r,i=[];tt(()=>{n=xe(n,[1,r,o]);for(let l=0;l<e.length;++l){const d=[0,l===0?0:s[l-1],0],f=[1,e[l],o];i[l]=xe(ft(n,d,f),this.elementShape)}return i});const a=[];for(let l=0;l<e.length;l++)a[l]=l;this.writeMany(a,i)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lu{get id(){return this.idTensor.id}constructor(e,n,r,s=-1){this.tensors=e,this.elementShape=n,this.elementDtype=r,e!=null&&e.forEach(o=>{if(r!==o.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${o.dtype}`);no(n,o.shape,"TensorList shape mismatch: "),ci(o)}),this.idTensor=pt(0),this.maxNumElements=s,ci(this.idTensor)}copy(){return new Lu([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,n,r=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);no(e,this.elementShape,"TensorList shape mismatch: ");const s=Sh(this.elementShape,this.tensors,e);return tt(()=>{const o=this.tensors.map(i=>xe(i,s));return ga(o,0)})}popBack(e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=Sh(this.elementShape,this.tensors,e),s=this.tensors.pop();return s.kept=!1,no(s.shape,e,"TensorList shape mismatch: "),xe(s,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(no(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");ci(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const n=new Lu([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)n.tensors[r]=this.tensors[r];return n}getItem(e,n,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);no(this.tensors[e].shape,n,"TensorList shape mismatch: ");const s=Sh(this.elementShape,this.tensors,n);return xe(this.tensors[e],s)}setItem(e,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);no(this.elementShape,n.shape,"TensorList shape mismatch: "),ci(n),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=n}gather(e,n,r){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);no(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());const s=Sh(this.elementShape,this.tensors,r);return e.length===0?yi([],[0].concat(s)):tt(()=>{const o=e.map(i=>xe(this.tensors[i],s));return ga(o,0)})}concat(e,n){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);no(this.elementShape,n,"TensorList shape mismatch: ");const r=Sh(this.elementShape,this.tensors,n);return this.size()===0?yi([],[0].concat(r)):tt(()=>{const s=this.tensors.map(o=>xe(o,r));return On(s,0)})}}function Yye(t,e,n){const r=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==n)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);const s=t.shape.slice(1);no(s,e,"TensorList shape mismatch: ");const o=Bu(t);return new Lu(o,e,r)}function Qye(t,e,n,r){return new Lu([],t,e,r)}function Zye(t,e,n,r){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const o=new Lu([],n,t.dtype,r),i=Bu(t,0);return e.forEach((a,l)=>{o.setItem(a,i[l])}),o}function Jye(t,e,n){let r=0;const s=e.map(d=>(r+=d,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);const o=t.shape.slice(1),i=Dv(o,n),a=r===0?0:t.size/r,l=tt(()=>{const d=[];t=xe(t,[1,r,a]);for(let f=0;f<e.length;++f){const g=[0,f===0?0:s[f-1],0],y=[1,e[f],a];d[f]=xe(ft(t,g,y),i)}return t.dispose(),d}),c=new Lu([],n,t.dtype,e.length);for(let d=0;d<l.length;d++)c.setItem(d,l[d]);return c}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e0e=async(t,e,n)=>{switch(t.op){case"If":case"StatelessIf":{const r=N("thenBranch",t,e,n),s=N("elseBranch",t,e,n),o=N("cond",t,e,n),i=N("args",t,e,n);return(await o.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=N("body",t,e,n),s=N("cond",t,e,n),o=N("args",t,e,n),i=await n.functionMap[s].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap),a=o.map(d=>d.id);let l=await i[0].data();i.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&d.dispose()});let c=o;for(;l[0];){const d=c;c=await n.functionMap[r].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);const f=c.map(g=>g.id);d.forEach(g=>{!g.kept&&a.indexOf(g.id)===-1&&f.indexOf(g.id)===-1&&g.dispose()});const p=await n.functionMap[s].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);l=await p[0].data(),p.forEach(g=>{!g.kept&&a.indexOf(g.id)===-1&&f.indexOf(g.id)===-1&&g.dispose()})}return c}case"LoopCond":{const r=N("pred",t,e,n);return[qi(r)]}case"Switch":{const r=N("pred",t,e,n);let s=N("data",t,e,n);return s.kept||(s=qi(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=t.inputNames.find(s=>Yn(s,e,n)!==void 0);if(r){const s=Yn(r,e,n);return[qi(s)]}return}case"Enter":{const r=N("frameName",t,e,n),s=N("tensor",t,e,n);return n.enterFrame(r),[qi(s)]}case"Exit":{const r=N("tensor",t,e,n);return n.exitFrame(),[qi(r)]}case"NextIteration":{const r=N("tensor",t,e,n);return n.nextIteration(),[qi(r)]}case"TensorArrayV3":{const r=N("size",t,e,n),s=N("dtype",t,e,n),o=N("elementShape",t,e,n),i=N("dynamicSize",t,e,n),a=N("clearAfterRead",t,e,n),l=N("identicalElementShapes",t,e,n),c=N("name",t,e,n),d=new qye(c,s,r,o,l,i,a);return n.addTensorArray(d),[d.idTensor,pt(1)]}case"TensorArrayWriteV3":{const r=N("tensorArrayId",t,e,n),s=N("index",t,e,n),o=N("tensor",t,e,n),i=n.getTensorArray(r.id);return i.write(s,o),[i.idTensor]}case"TensorArrayReadV3":{const r=N("tensorArrayId",t,e,n),s=N("index",t,e,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=N("tensorArrayId",t,e,n),s=N("indices",t,e,n),o=N("dtype",t,e,n);return[n.getTensorArray(r.id).gather(s,o)]}case"TensorArrayScatterV3":{const r=N("tensorArrayId",t,e,n),s=N("indices",t,e,n),o=N("tensor",t,e,n),i=n.getTensorArray(r.id);return i.scatter(s,o),[i.idTensor]}case"TensorArrayConcatV3":{const r=N("tensorArrayId",t,e,n),s=n.getTensorArray(r.id),o=N("dtype",t,e,n);return[s.concat(o)]}case"TensorArraySplitV3":{const r=N("tensorArrayId",t,e,n),s=N("tensor",t,e,n),o=N("lengths",t,e,n),i=n.getTensorArray(r.id);return i.split(o,s),[i.idTensor]}case"TensorArraySizeV3":{const r=N("tensorArrayId",t,e,n),s=n.getTensorArray(r.id);return[pt(s.size(),"int32")]}case"TensorArrayCloseV3":{const r=N("tensorArrayId",t,e,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=N("tensorListId",t,e,n),s=N("index",t,e,n),o=N("tensor",t,e,n),i=n.getTensorList(r.id);return i.setItem(s,o),[i.idTensor]}case"TensorListGetItem":{const r=N("tensorListId",t,e,n),s=N("index",t,e,n),o=N("elementShape",t,e,n),i=N("elementDType",t,e,n);return[n.getTensorList(r.id).getItem(s,o,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=N("indices",t,e,n),s=N("tensor",t,e,n),o=N("elementShape",t,e,n),i=N("numElements",t,e,n),a=Zye(s,r,o,i);return n.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=N("elementShape",t,e,n),s=N("elementDType",t,e,n);let o;t.op==="TensorListReserve"?o="numElements":o="maxNumElements";const i=N(o,t,e,n),a=t.op==="TensorListReserve"?-1:i,l=Qye(r,s,i,a);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{const r=N("tensorListId",t,e,n),s=N("indices",t,e,n),o=N("elementShape",t,e,n),i=N("elementDType",t,e,n);return[n.getTensorList(r.id).gather(s,i,o)]}case"TensorListStack":{const r=N("tensorListId",t,e,n),s=N("elementShape",t,e,n),o=N("elementDType",t,e,n),i=N("numElements",t,e,n);return[n.getTensorList(r.id).stack(s,o,i)]}case"TensorListFromTensor":{const r=N("tensor",t,e,n),s=N("elementShape",t,e,n),o=N("elementDType",t,e,n),i=Yye(r,s,o);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=N("tensorListId",t,e,n),s=n.getTensorList(r.id),o=N("dtype",t,e,n),i=N("elementShape",t,e,n);return[s.concat(o,i)]}case"TensorListPushBack":{const r=N("tensorListId",t,e,n),s=N("tensor",t,e,n),o=n.getTensorList(r.id);return o.pushBack(s),[o.idTensor]}case"TensorListPopBack":{const r=N("tensorListId",t,e,n),s=N("elementShape",t,e,n),o=N("elementDType",t,e,n);return[n.getTensorList(r.id).popBack(s,o)]}case"TensorListSplit":{const r=N("tensor",t,e,n),s=N("elementShape",t,e,n),o=N("lengths",t,e,n),i=Jye(r,o,s);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{const r=N("tensorListId",t,e,n),s=n.getTensorList(r.id);return[pt(s.size(),"int32")]}case"TensorListResize":{const r=N("tensorListId",t,e,n),s=N("size",t,e,n),i=n.getTensorList(r.id).resize(s);return n.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wE(t,e,n){const[r,s]=N("fusedOps",t,e,n),o=r==="biasadd",i=!o,a=s==="prelu",l=r==="fusedbatchnorm",c=N("numArgs",t,e,n);if(o){if(a&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&o&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const d=N("strides",t,e,n),f=tg(t,e,n),p=N("dataFormat",t,e,n).toUpperCase(),g=N("dilations",t,e,n);let[y,x]=N("args",t,e,n);i&&(x=y,y=void 0);const w=N("leakyreluAlpha",t,e,n);return{stride:d,pad:f,dataFormat:p,dilations:g,biasArg:y,preluArg:x,activationFunc:s,leakyreluAlpha:w}}const t0e=(t,e,n,r=Zn)=>{switch(t.op){case"Conv1D":{const s=N("stride",t,e,n),o=N("pad",t,e,n),i=N("dataFormat",t,e,n).toUpperCase(),a=N("dilation",t,e,n);return[r.conv1d(N("x",t,e,n),N("filter",t,e,n),s,o,i,a)]}case"Conv2D":{const s=N("strides",t,e,n),o=tg(t,e,n),i=N("dataFormat",t,e,n).toUpperCase(),a=N("dilations",t,e,n);return[r.conv2d(N("x",t,e,n),N("filter",t,e,n),[s[1],s[2]],o,i,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:s,pad:o,dataFormat:i,dilations:a,biasArg:l,preluArg:c,activationFunc:d,leakyreluAlpha:f}=wE(t,e,n);return[r.fused.conv2d({x:N("x",t,e,n),filter:N("filter",t,e,n),strides:[s[1],s[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:d,preluActivationWeights:c,leakyreluAlpha:f})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:o,dataFormat:i,dilations:a,biasArg:l,preluArg:c,activationFunc:d,leakyreluAlpha:f}=wE(t,e,n);return[r.fused.depthwiseConv2d({x:N("x",t,e,n),filter:N("filter",t,e,n),strides:[s[1],s[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:d,preluActivationWeights:c,leakyreluAlpha:f})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=N("outputShape",t,e,n),o=N("strides",t,e,n),i=tg(t,e,n);return[r.conv2dTranspose(N("x",t,e,n),N("filter",t,e,n),s,[o[1],o[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=N("strides",t,e,n),o=tg(t,e,n),i=N("dilations",t,e,n),a=N("dataFormat",t,e,n).toUpperCase();return[r.depthwiseConv2d(N("input",t,e,n),N("filter",t,e,n),[s[1],s[2]],o,a,[i[1],i[2]])]}case"Conv3D":{const s=N("strides",t,e,n),o=N("pad",t,e,n),i=N("dataFormat",t,e,n).toUpperCase(),a=N("dilations",t,e,n);return[r.conv3d(N("x",t,e,n),N("filter",t,e,n),[s[1],s[2],s[3]],o,i,[a[1],a[2],a[3]])]}case"AvgPool":{const s=N("strides",t,e,n),o=N("pad",t,e,n),i=N("kernelSize",t,e,n);return[r.avgPool(N("x",t,e,n),[i[1],i[2]],[s[1],s[2]],o)]}case"MaxPool":{const s=N("strides",t,e,n),o=N("pad",t,e,n),i=N("kernelSize",t,e,n);return[r.maxPool(N("x",t,e,n),[i[1],i[2]],[s[1],s[2]],o)]}case"MaxPoolWithArgmax":{const s=N("strides",t,e,n),o=N("pad",t,e,n),i=N("kernelSize",t,e,n),a=N("includeBatchInIndex",t,e,n),{result:l,indexes:c}=r.maxPoolWithArgmax(N("x",t,e,n),[i[1],i[2]],[s[1],s[2]],o,a);return[l,c]}case"AvgPool3D":{const s=N("strides",t,e,n),o=N("pad",t,e,n),i=N("kernelSize",t,e,n);return[r.avgPool3d(N("x",t,e,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],o)]}case"MaxPool3D":{const s=N("strides",t,e,n),o=N("pad",t,e,n),i=N("kernelSize",t,e,n);return[r.maxPool3d(N("x",t,e,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],o)]}case"Dilation2D":{const s=N("strides",t,e,n),o=N("pad",t,e,n),i=N("dilations",t,e,n),a=s[1],l=s[2],c=i[1],d=i[2];return[r.dilation2d(N("x",t,e,n),N("filter",t,e,n),[a,l],o,[c,d],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n0e=(t,e,n,r=Zn)=>{switch(t.op){case"Fill":{const s=N("shape",t,e,n),o=N("dtype",t,e,n),i=N("value",t,e,n);return[r.fill(s,i,o)]}case"LinSpace":{const s=N("start",t,e,n),o=N("stop",t,e,n),i=N("num",t,e,n);return[r.linspace(s,o,i)]}case"Multinomial":{const s=N("logits",t,e,n),o=N("numSamples",t,e,n),i=N("seed",t,e,n);return[r.multinomial(s,o,i)]}case"OneHot":{const s=N("indices",t,e,n),o=N("depth",t,e,n),i=N("onValue",t,e,n),a=N("offValue",t,e,n),l=N("dtype",t,e,n);return[r.oneHot(s,o,i,a,l)]}case"Ones":return[r.ones(N("shape",t,e,n),N("dtype",t,e,n))];case"OnesLike":return[r.onesLike(N("x",t,e,n))];case"RandomStandardNormal":return[r.randomStandardNormal(N("shape",t,e,n),N("dtype",t,e,n),N("seed",t,e,n))];case"RandomUniform":return[r.randomUniform(N("shape",t,e,n),N("minval",t,e,n),N("maxval",t,e,n),N("dtype",t,e,n))];case"RandomUniformInt":return[r.randomUniformInt(N("shape",t,e,n),N("minval",t,e,n),N("maxval",t,e,n),N("seed",t,e,n))];case"Range":{const s=N("start",t,e,n),o=N("stop",t,e,n),i=N("step",t,e,n);return[r.range(s,o,i,N("dtype",t,e,n))]}case"TruncatedNormal":{const s=N("shape",t,e,n),o=N("mean",t,e,n),i=N("stdDev",t,e,n),a=N("seed",t,e,n);return[r.truncatedNormal(s,o,i,N("dtype",t,e,n),a)]}case"Zeros":return[r.zeros(N("shape",t,e,n),N("dtype",t,e,n))];case"ZerosLike":return[r.zerosLike(N("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sx(t,e,n){const r=N("boxes",t,e,n),s=N("scores",t,e,n),o=N("maxOutputSize",t,e,n),i=N("iouThreshold",t,e,n),a=N("scoreThreshold",t,e,n),l=N("softNmsSigma",t,e,n);return{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:a,softNmsSigma:l}}const r0e=async(t,e,n,r,s=Zn)=>{switch(t.op){case"NonMaxSuppressionV5":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:l,scoreThreshold:c,softNmsSigma:d}=sx(t,e,n),f=await s.image.nonMaxSuppressionWithScoreAsync(o,i,a,l,c,d);return[f.selectedIndices,f.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=sx(t,e,n),d=N("padToMaxOutputSize",t,e,n),f=await s.image.nonMaxSuppressionPaddedAsync(o,i,a,l,c,d);return[f.selectedIndices,f.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=sx(t,e,n);return[await s.image.nonMaxSuppressionAsync(o,i,a,l,c)]}case"Where":{const o=s.cast(N("condition",t,e,n),"bool"),i=[await s.whereAsync(o)];return o.dispose(),i}case"ListDiff":return s.setdiff1dAsync(N("x",t,e,n),N("y",t,e,n));default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s0e=(t,e,n,r=Zn)=>{switch(t.op){case"LowerBound":{const s=N("sortedSequence",t,e,n),o=N("values",t,e,n);return[r.lowerBound(s,o)]}case"TopKV2":{const s=N("x",t,e,n),o=N("k",t,e,n),i=N("sorted",t,e,n),a=r.topk(s,o,i);return[a.values,a.indices]}case"UpperBound":{const s=N("sortedSequence",t,e,n),o=N("values",t,e,n);return[r.upperBound(s,o)]}case"Unique":{const s=N("x",t,e,n),o=r.unique(s);return[o.values,o.indices]}case"UniqueV2":{const s=N("x",t,e,n),o=N("axis",t,e,n),i=r.unique(s,o);return[i.values,i.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o0e=(t,e,n,r=Zn)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":const s=N("default",t,e,n);return[Yn(t.name,e,n)||s];case"Placeholder":return[Yn(t.name,e,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const d=N("x",t,e,n);return[qi(d)]}case"IdentityN":return N("x",t,e,n).map(d=>qi(d));case"Snapshot":const o=N("x",t,e,n);return[qi(o)];case"Shape":return[r.tensor1d(N("x",t,e,n).shape,"int32")];case"ShapeN":return N("x",t,e,n).map(d=>r.tensor1d(d.shape));case"Size":return[r.scalar(N("x",t,e,n).size,"int32")];case"Rank":return[r.scalar(N("x",t,e,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const i=N("x",t,e,n),a=N("data",t,e,n),l=N("message",t,e,n),c=N("summarize",t,e,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let d=0;d<a.length;d++)console.log(Array.prototype.slice.call(a[d].dataSync()).slice(0,c));return[i];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class i0e{get id(){return this.handle.id}constructor(e,n){this.keyDType=e,this.valueDType=n,this.handle=pt(0),this.tensorMap=new Map,ci(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return pt(this.size(),"int32")}async import(e,n){this.checkKeyAndValueTensor(e,n);const r=await e.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),tt(()=>{const s=Bu(n),o=r.length,i=s.length;z(o===i,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${i} elements.`);for(let a=0;a<o;a++){const l=r[a],c=s[a];ci(c),this.tensorMap.set(l,c)}return this.handle})}async find(e,n){this.checkKeyAndValueTensor(e,n);const r=await e.data();return tt(()=>{const s=[];for(let o=0;o<r.length;o++){const i=r[o],a=this.findWithDefault(i,n);s.push(a)}return ga(s)})}findWithDefault(e,n){const r=this.tensorMap.get(e);return r??n}checkKeyAndValueTensor(e,n){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(n.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a0e=async(t,e,n,r)=>{switch(t.op){case"HashTable":case"HashTableV2":{const s=r.getHashTableHandleByName(t.name);if(s!=null)return[s];{const o=N("keyDType",t,e,n),i=N("valueDType",t,e,n),a=new i0e(o,i);return r.addHashTable(t.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=N("tableHandle",t,e,n,r),o=N("keys",t,e,n),i=N("values",t,e,n);return[await r.getHashTableById(s.id).import(o,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=N("tableHandle",t,e,n,r),o=N("keys",t,e,n),i=N("defaultValue",t,e,n);return[await r.getHashTableById(s.id).find(o,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=N("tableHandle",t,e,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l0e=(t,e,n,r=Zn)=>{switch(t.op){case"ResizeBilinear":{const s=N("images",t,e,n),o=N("size",t,e,n),i=N("alignCorners",t,e,n),a=N("halfPixelCenters",t,e,n);return[r.image.resizeBilinear(s,[o[0],o[1]],i,a)]}case"ResizeNearestNeighbor":{const s=N("images",t,e,n),o=N("size",t,e,n),i=N("alignCorners",t,e,n),a=N("halfPixelCenters",t,e,n);return[r.image.resizeNearestNeighbor(s,[o[0],o[1]],i,a)]}case"CropAndResize":{const s=N("image",t,e,n),o=N("boxes",t,e,n),i=N("boxInd",t,e,n),a=N("cropSize",t,e,n),l=N("method",t,e,n),c=N("extrapolationValue",t,e,n);return[r.image.cropAndResize(s,o,i,a,l,c)]}case"ImageProjectiveTransformV3":{const s=N("images",t,e,n),o=N("transforms",t,e,n),i=N("outputShape",t,e,n),a=N("fillValue",t,e,n),l=N("interpolation",t,e,n),c=N("fillMode",t,e,n);return[r.image.transform(s,o,l.toLowerCase(),c.toLowerCase(),a,i)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u0e=(t,e,n,r=Zn)=>{switch(t.op){case"Equal":return[r.equal(N("a",t,e,n),N("b",t,e,n))];case"NotEqual":return[r.notEqual(N("a",t,e,n),N("b",t,e,n))];case"Greater":return[r.greater(N("a",t,e,n),N("b",t,e,n))];case"GreaterEqual":return[r.greaterEqual(N("a",t,e,n),N("b",t,e,n))];case"Less":return[r.less(N("a",t,e,n),N("b",t,e,n))];case"LessEqual":return[r.lessEqual(N("a",t,e,n),N("b",t,e,n))];case"LogicalAnd":return[r.logicalAnd(N("a",t,e,n),N("b",t,e,n))];case"LogicalNot":return[r.logicalNot(N("a",t,e,n))];case"LogicalOr":return[r.logicalOr(N("a",t,e,n),N("b",t,e,n))];case"Select":case"SelectV2":return[r.where(N("condition",t,e,n),N("a",t,e,n),N("b",t,e,n))];case"BitwiseAnd":return[r.bitwiseAnd(N("a",t,e,n),N("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c0e=(t,e,n,r=Zn)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(N("a",t,e,n),N("b",t,e,n),N("transposeA",t,e,n),N("transposeB",t,e,n))];case"Einsum":return[r.einsum(N("equation",t,e,n),...N("tensors",t,e,n))];case"Transpose":return[r.transpose(N("x",t,e,n),N("perm",t,e,n))];case"_FusedMatMul":const[s,o]=N("fusedOps",t,e,n),i=s==="biasadd",a=o==="prelu",l=N("numArgs",t,e,n),c=N("leakyreluAlpha",t,e,n);if(i){if(a&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[d,f]=N("args",t,e,n);return[r.fused.matMul({a:N("a",t,e,n),b:N("b",t,e,n),transposeA:N("transposeA",t,e,n),transposeB:N("transposeB",t,e,n),bias:d,activation:o,preluActivationWeights:f,leakyreluAlpha:c})];case"MatrixBandPart":return[r.linalg.bandPart(N("a",t,e,n),N("numLower",t,e,n),N("numUpper",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d0e=(t,e,n,r=Zn)=>{switch(t.op){case"EuclideanNorm":return[r.euclideanNorm(N("x",t,e,n),N("axis",t,e,n),N("keepDims",t,e,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(N("x",t,e,n),N("mean",t,e,n),N("variance",t,e,n),N("offset",t,e,n),N("scale",t,e,n),N("epsilon",t,e,n))];case"FusedBatchNormV3":return[r.batchNorm(N("x",t,e,n),N("mean",t,e,n),N("variance",t,e,n),N("offset",t,e,n),N("scale",t,e,n),N("epsilon",t,e,n))];case"LRN":return[r.localResponseNormalization(N("x",t,e,n),N("radius",t,e,n),N("bias",t,e,n),N("alpha",t,e,n),N("beta",t,e,n))];case"Softmax":return[r.softmax(N("x",t,e,n))];case"LogSoftmax":return[r.logSoftmax(N("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h0e=(t,e,n,r=Zn)=>{switch(t.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:o}=r.raggedGather(N("paramsNestedSplits",t,e,n),N("paramsDenseValues",t,e,n),N("indices",t,e,n),N("outputRaggedRank",t,e,n));return s.concat(o)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:o}=r.raggedRange(N("starts",t,e,n),N("limits",t,e,n),N("splits",t,e,n));return[s,o]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(N("shape",t,e,n),N("values",t,e,n),N("defaultValue",t,e,n),N("rowPartitionTensors",t,e,n),N("rowPartitionTypes",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f0e=(t,e,n,r=Zn)=>{switch(t.op){case"Max":{const a=N("axis",t,e,n),l=N("keepDims",t,e,n);return[r.max(N("x",t,e,n),a,l)]}case"Mean":{const a=N("axis",t,e,n),l=N("keepDims",t,e,n);return[r.mean(N("x",t,e,n),a,l)]}case"Min":{const a=N("axis",t,e,n),l=N("keepDims",t,e,n);return[r.min(N("x",t,e,n),a,l)]}case"Sum":{const a=N("axis",t,e,n),l=N("keepDims",t,e,n);return[r.sum(N("x",t,e,n),a,l)]}case"All":{const a=N("axis",t,e,n),l=N("keepDims",t,e,n);return[r.all(N("x",t,e,n),a,l)]}case"Any":{const a=N("axis",t,e,n),l=N("keepDims",t,e,n);return[r.any(N("x",t,e,n),a,l)]}case"ArgMax":{const a=N("axis",t,e,n);return[r.argMax(N("x",t,e,n),a)]}case"ArgMin":{const a=N("axis",t,e,n);return[r.argMin(N("x",t,e,n),a)]}case"Prod":{const a=N("axis",t,e,n),l=N("keepDims",t,e,n);return[r.prod(N("x",t,e,n),a,l)]}case"Cumprod":{const a=N("axis",t,e,n),l=N("exclusive",t,e,n),c=N("reverse",t,e,n);return[r.cumprod(N("x",t,e,n),a,l,c)]}case"Cumsum":{const a=N("axis",t,e,n),l=N("exclusive",t,e,n),c=N("reverse",t,e,n);return[r.cumsum(N("x",t,e,n),a,l,c)]}case"Bincount":const s=N("x",t,e,n),o=N("weights",t,e,n),i=N("size",t,e,n);return[r.bincount(s,o,i)];case"DenseBincount":{const a=N("x",t,e,n),l=N("weights",t,e,n),c=N("size",t,e,n),d=N("binaryOutput",t,e,n);return[r.denseBincount(a,l,c,d)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p0e=(t,e,n,r=Zn)=>{switch(t.op){case"ConcatV2":case"Concat":{const s=N("n",t,e,n),o=N("axis",t,e,n);let i=N("tensors",t,e,n);return i=i.slice(0,s),[r.concat(i,o)]}case"Gather":{const s=N("x",t,e,n),o=N("indices",t,e,n);return[r.gather(s,r.cast(o,"int32"),0)]}case"GatherV2":{const s=N("axis",t,e,n),o=N("batchDims",t,e,n),i=N("x",t,e,n),a=N("indices",t,e,n);return[r.gather(i,r.cast(a,"int32"),s,o)]}case"Reverse":{const s=N("dims",t,e,n),o=[];for(let a=0;a<s.length;a++)s[a]&&o.push(a);const i=N("x",t,e,n);return[r.reverse(i,o)]}case"ReverseV2":{const s=N("axis",t,e,n),o=N("x",t,e,n);return[r.reverse(o,s)]}case"Slice":{const s=N("begin",t,e,n),o=N("size",t,e,n);return[r.slice(N("x",t,e,n),s,o)]}case"StridedSlice":{const s=N("begin",t,e,n),o=N("end",t,e,n),i=N("strides",t,e,n),a=N("beginMask",t,e,n),l=N("endMask",t,e,n),c=N("ellipsisMask",t,e,n),d=N("newAxisMask",t,e,n),f=N("shrinkAxisMask",t,e,n),p=N("x",t,e,n);return[r.stridedSlice(p,s,o,i,a,l,c,d,f)]}case"Pack":return tt(()=>{const s=N("axis",t,e,n),o=N("tensors",t,e,n),i=o[0].shape,a=r.squeeze(o[0]).shape,l=o.map(c=>{const d=Mt(c.shape,i);if(!d&&!Mt(r.squeeze(c).shape,a))throw new Error("the input tensors shape does not match");return d?c:r.reshape(c,i)});return[r.stack(l,s)]});case"Unpack":{const s=N("axis",t,e,n),o=N("tensor",t,e,n);return r.unstack(o,s)}case"Tile":{const s=N("reps",t,e,n);return[r.tile(N("x",t,e,n),s)]}case"Split":case"SplitV":{const s=N("axis",t,e,n),o=N("numOrSizeSplits",t,e,n),i=N("x",t,e,n);return r.split(i,o,s)}case"ScatterNd":{const s=N("indices",t,e,n),o=N("values",t,e,n),i=N("shape",t,e,n);return[r.scatterND(s,o,i)]}case"GatherNd":{const s=N("x",t,e,n),o=N("indices",t,e,n);return[r.gatherND(s,o)]}case"SparseToDense":{const s=N("sparseIndices",t,e,n),o=N("outputShape",t,e,n),i=N("sparseValues",t,e,n),a=N("defaultValue",t,e,n);return[r.sparseToDense(s,i,o,i.dtype===a.dtype?a:r.cast(a,i.dtype))]}case"TensorScatterUpdate":{const s=N("indices",t,e,n),o=N("values",t,e,n),i=N("tensor",t,e,n);return[r.tensorScatterUpdate(i,s,o)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m0e=(t,e,n,r=Zn)=>{switch(t.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:o,emptyRowIndicator:i,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(N("indices",t,e,n),N("values",t,e,n),N("denseShape",t,e,n),N("defaultValue",t,e,n));return[s,o,i,a]}case"SparseReshape":{const{outputIndices:s,outputShape:o}=r.sparse.sparseReshape(N("inputIndices",t,e,n),N("inputShape",t,e,n),N("newShape",t,e,n));return[s,o]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(N("data",t,e,n),N("indices",t,e,n),N("segmentIds",t,e,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(N("data",t,e,n),N("indices",t,e,n),N("segmentIds",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g0e=(t,e,n,r=Zn)=>{switch(t.op){case"FFT":return[r.fft(N("x",t,e,n))];case"IFFT":return[r.ifft(N("x",t,e,n))];case"RFFT":return[r.rfft(N("x",t,e,n))];case"IRFFT":return[r.irfft(N("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y0e=(t,e,n,r=Zn)=>{switch(t.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(N("input",t,e,n),N("pattern",t,e,n),N("rewrite",t,e,n),N("replaceGlobal",t,e,n))];case"StringNGrams":{const{nGrams:s,nGramsSplits:o}=r.string.stringNGrams(N("data",t,e,n),N("dataSplits",t,e,n),N("separator",t,e,n),N("nGramWidths",t,e,n),N("leftPad",t,e,n),N("rightPad",t,e,n),N("padWidth",t,e,n),N("preserveShortSequences",t,e,n));return[s,o]}case"StringSplit":{const{indices:s,values:o,shape:i}=r.string.stringSplit(N("input",t,e,n),N("delimiter",t,e,n),N("skipEmpty",t,e,n));return[s,o,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(N("input",t,e,n),N("numBuckets",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x0e=(t,e,n,r=Zn)=>{switch(t.op){case"Cast":return[r.cast(N("x",t,e,n),N("dtype",t,e,n))];case"ExpandDims":{const s=N("axis",t,e,n);return[r.expandDims(N("x",t,e,n),s)]}case"Squeeze":{const s=N("axis",t,e,n);return[r.squeeze(N("x",t,e,n),s)]}case"Reshape":return[r.reshape(N("x",t,e,n),N("shape",t,e,n))];case"EnsureShape":return[r.ensureShape(N("x",t,e,n),N("shape",t,e,n))];case"MirrorPad":return[r.mirrorPad(N("x",t,e,n),N("padding",t,e,n),N("mode",t,e,n))];case"PadV2":case"Pad":return[r.pad(N("x",t,e,n),N("padding",t,e,n),N("constantValue",t,e,n))];case"SpaceToBatchND":{const s=N("blockShape",t,e,n),o=N("paddings",t,e,n);return[r.spaceToBatchND(N("x",t,e,n),s,o)]}case"BatchToSpaceND":{const s=N("blockShape",t,e,n),o=N("crops",t,e,n);return[r.batchToSpaceND(N("x",t,e,n),s,o)]}case"DepthToSpace":{const s=N("blockSize",t,e,n),o=N("dataFormat",t,e,n).toUpperCase();return[r.depthToSpace(N("x",t,e,n),s,o)]}case"BroadcastTo":return[r.broadcastTo(N("x",t,e,n),N("shape",t,e,n))];case"BroadcastArgs":return[r.broadcastArgs(N("s0",t,e,n),N("s1",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SE(t,e,n,r,s=tt){const o=((i,a,l)=>{switch(i.category){case"arithmetic":return s(()=>Kye(i,a,l));case"basic_math":return s(()=>Xye(i,a,l));case"control":return e0e(i,a,l);case"convolution":return s(()=>t0e(i,a,l));case"creation":return s(()=>n0e(i,a,l));case"dynamic":return r0e(i,a,l);case"evaluation":return s(()=>s0e(i,a,l));case"image":return s(()=>l0e(i,a,l));case"graph":return s(()=>o0e(i,a,l));case"logical":return s(()=>u0e(i,a,l));case"matrices":return s(()=>c0e(i,a,l));case"normalization":return s(()=>d0e(i,a,l));case"ragged":return s(()=>h0e(i,a,l));case"reduction":return s(()=>f0e(i,a,l));case"slice_join":return s(()=>p0e(i,a,l));case"sparse":return s(()=>m0e(i,a,l));case"spectral":return s(()=>g0e(i,a,l));case"string":return s(()=>y0e(i,a,l));case"transformation":return s(()=>x0e(i,a,l));case"hash_table":return a0e(i,a,l,r);case"custom":const c=cO(i.op);if(c&&c.customExecutor)return c.customExecutor(new Hye(i,a,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,n);return Eu(o)?o.then(i=>[].concat(i)):[].concat(o)}class CE{constructor(e={},n={},r={},s={},o){this.weightMap=e,this.tensorArrayMap=n,this.tensorListMap=r,this.functionMap=s,this.parseNodeNameCache=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,n){return{id:e,frameName:n,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let n=0;n<this.contexts.length-1;n++){const r=this.contexts.slice(0,this.contexts.length-n);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(n=>n.id===0&&n.iterationId===0?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(e);for(const n in this.tensorListMap)this.tensorListMap[n].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $E(t,e,n,r){const s=new Set,o=[];let i=null,a=null;const l=new Set,c=new Set(Object.keys(t).map(p=>us(p)[0]));r=r||[];const d=new Set(r.map(p=>us(p.name)[0])),f=[...e];for(;f.length>0;){const p=f.pop();if((fu(p)||T0e(p)||I0e(p))&&i==null&&(i=p,a=i.children.map(g=>g.name).filter(g=>s.has(g))),s.add(p.name),n[p.name]==null&&!c.has(p.name)&&!d.has(p.name)){if(p.inputs.length===0){o.push(p.name);continue}p.inputs.forEach(g=>{l.has(g.name)||(l.add(g.name),f.push(g))})}}return{inputs:t,outputs:e,usedNodes:s,missingInputs:o,dynamicNode:i,syncInputs:a}}function v0e(t,e){const{usedNodes:n,inputs:r}=e,s=Object.keys(r).map(w=>us(w)[0]).map(w=>t.nodes[w]),o=t.initNodes||[],i=w=>n.has(typeof w=="string"?w:w.name);function a(w){return[...new Map(w.map(S=>[S.name,S])).values()]}const l=a([...s,...t.weights,...o]).filter(i),c=a([...l,...Object.values(t.nodes)]).filter(i),d=new Map(c.map(w=>[w.name,w])),f={};for(const w of c){f[w.name]=f[w.name]||0;for(const S of w.children)i(S)||(f[S.name]=Number.POSITIVE_INFINITY),f[S.name]=(f[S.name]||0)+1}const p=Object.entries(f).filter(([,w])=>w===0).map(([w])=>w),g=[...p];for(;p.length>0;){const w=p.pop(),S=d.get(w);for(const $ of S.children.filter(i))--f[$.name]===0&&(g.push($.name),p.push($.name))}const y=g.map(w=>d.get(w)),x=b0e(y,l);return w0e(x,l),x}function b0e(t,e){const n=new Map(t.map(i=>[i.name,i])),r=e.map(i=>i.name),s=new Set(r);for(;r.length>0;){const i=r.pop(),a=n.get(i);for(const l of a.children)!n.has(l.name)||s.has(l.name)||(s.add(l.name),r.push(l.name))}return t.filter(i=>s.has(i.name))}class Em extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function w0e(t,e){const n=new Map(t.map((a,l)=>[a.name,l])),r=new Set(e.map(a=>a.name)),s=a=>r.has(typeof a=="string"?a:a.name),o=new Set(t.map(a=>a.name)),i=a=>o.has(typeof a=="string"?a:a.name);for(const a of t){for(const l of a.children.filter(i)){if(!n.has(l.name))throw new Em(`Child ${l.name} of node ${a.name} is unreachable.`);if(n.get(a.name)>n.get(l.name))throw new Em(`Node ${a.name} is scheduled to run after its child ${l.name}.`)}if(!s(a))for(const l of a.inputs){if(!n.has(l.name))throw new Em(`Input ${l.name} of node ${a.name} is unreachable.`);if(n.get(l.name)>n.get(a.name))throw new Em(`Node ${a.name} is scheduled to run before its input ${l.name}.`)}}}function S0e(t){const e=new Map(t.map((a,l)=>[a.name,l])),n=Number.MAX_SAFE_INTEGER,r=t.map((a,l)=>fu(a)?n:l),s=a=>{const l=r[e.get(a.name)];return l??-1},o=t.map((a,l)=>a.children.map(s).reduce((c,d)=>Math.max(c,d),r[l])),i=new Map;for(let a=0;a<t.length;++a){const l=o[a];if(l===n)continue;const c=t[a],d=t[l];i.has(d.name)||i.set(d.name,[]),i.get(d.name).push(c)}return i}const C0e=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),$0e=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),k0e=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function fu(t){return C0e.has(t.op)}function T0e(t){return $0e.has(t.op)}function I0e(t){return k0e.has(t.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lg{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const n=Object.keys(e).map(r=>e[r].map(s=>s.id));this._weightIds=[].concat(...n),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const n=e.signatureKey||e.name;return e.defaultOutput?`${n}:${e.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((e,n)=>(e[n]=this._functions[n].signature,e),{})}constructor(e,n){this.graph=e,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new Lg(e.functions[r],this)})}getCompilationKey(e,n){const r=e.map(o=>o.name).sort(),s=n.map(o=>o.name).sort();return r.join(this.SEPARATOR)+"--"+s.join(this.SEPARATOR)}compile(e,n){const r=$E(e,n,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:o,syncInputs:i}=r;if(o!=null)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(s.length>0){const c=n.map(f=>f.name),d=Object.keys(e);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${d}]. Missing the following inputs: [${s}]`)}const a=v0e(this.graph,r),l=S0e(a);return{orderedNodes:a,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;const n=e.clone();return ci(n),n}cloneTensorList(e){return e?e.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([n,r])=>[n,this.cloneTensorList(r)]))}execute(e,n){this.disposeIntermediateTensors(),e=this.mapInputs(e);const r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n);const s=r.map(p=>this.graph.nodes[us(p)[0]]),o=n.map(p=>us(p)[0]),i=new Set(o);let a=o.map(p=>this.graph.nodes[p]);a.length===0&&(a=this._outputs);const l=this.getCompilationKey(s,a);let c=this.compiledMap.get(l);c==null&&(c=this.compile(e,a),this.compiledMap.set(l,c));try{this.keepIntermediateTensors=oe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}const d={},f={};return tt(()=>{const p=new CE(this.weightMap,d,f,this.functionExecutorMap,this.parseNodeNameCache),g=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(S=>{const[$,I]=us(S,p),R=[];R[I]=e[S],g[$]=R,this.keepIntermediateTensors&&(this.clonedTensorsMap[$]=this.cloneTensorList(R))});const y=this.getFrozenTensorIds(g),{orderedNodes:x,nodeLiveUntilMap:w}=c;for(const S of x){if(g[S.name])continue;const $=SE(S,g,p,this._resourceManager);if(Eu($))throw new Error(`The execution of the op '${S.op}' returned a promise. Please use model.executeAsync() instead.`);g[S.name]=$,this.keepIntermediateTensors&&(this.clonedTensorsMap[S.name]=this.cloneTensorList($)),this.checkTensorForDisposalWithNodeLiveUntilInfo(S,g,p,y,i,w.get(S.name))}return this.parent==null&&p.dispose(y),n.map(S=>Yn(S,g,p))})}getFrozenTensorIds(e){const n=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(s=>s.id)));return new Set(n)}checkTensorForDisposal(e,n,r,s,o,i,a){if(!(fu(n)||i.has(e))){for(const l of r[e])l!=null&&(a[l.id]=(a[l.id]||0)+n.children.length);for(const l of n.inputs){if(fu(l))continue;const c=yE(l.name,r,s);if(c!=null)for(const d of c){if(!d||d.kept||o.has(d.id))continue;const f=a[d.id];f===1?(d.dispose(),delete a[d.id]):f!=null&&a[d.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,n,r,s,o,i){function a(l){return fu(l)||o.has(l.name)}if(!(fu(e)||i==null))for(const l of i){if(a(l))continue;const c=yE(l.name,n,r);for(const d of c)!d||d.kept||s.has(d.id)||d.dispose()}}async executeAsync(e,n){return this._executeAsync(e,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const n of e)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,n,r=!1,s={},o={}){this.disposeIntermediateTensors(),r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=oe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}const i=new CE(this.weightMap,s,o,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const a=await this.executeWithControlFlow(e,i,n,r),l=n.map(p=>Yn(p,a,i)),c=l.map(p=>p.id),d=Object.keys(e).map(p=>e[p].id),f=new Set([...c,...d,...this.weightIds]);return Object.values(a).forEach(p=>{p.forEach(g=>{g&&!g.isDisposed&&!f.has(g.id)&&g.dispose()})}),this.parent==null&&i.dispose(f),l}async executeFunctionAsync(e,n,r){const s=e.reduce((o,i,a)=>(o[this.inputs[a].name]=i,o),{});return this._executeAsync(s,this.outputNodes,!0,n,r)}async executeWithControlFlow(e,n,r,s){const o=Object.keys(e),i=o.map(R=>this.graph.nodes[us(R)[0]]),a=r.map(R=>us(R)[0]),l=new Set(a);let c=a.map(R=>this.graph.nodes[R]);c.length===0&&(c=this._outputs);const{usedNodes:d,missingInputs:f,dynamicNode:p,syncInputs:g}=$E(e,c,this.weightMap,this._initNodes),y=[...i,...this.graph.weights,...this._initNodes||[]].map(R=>({node:R,contexts:n.currentContext})),x=Object.assign({},this.weightMap);Object.keys(e).forEach(R=>{const[_,F]=us(R),O=[];O[F]=e[R],x[_]=O});const w={},S=this.getFrozenTensorIds(x),$={};for(;y.length>0;){const R=this.processStack(i,y,n,x,$,S,l,w,d);await Promise.all(R)}p==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const I=c.filter(R=>!fu(R)&&!Yn(R.name,x,n)).map(R=>R.name);if(I.length>0){let R="";throw p!=null&&(R=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${g}]`),new Error(`Cannot compute the outputs [${I}] from the provided inputs [${o}]. Consider providing the following inputs: [${f}]. ${R}`)}return x}processStack(e,n,r,s,o,i,a,l,c){const d=[];for(;n.length>0;){const f=n.pop();r.currentContext=f.contexts;let p="";if(f.node.op==="Enter"&&N("isConstant",f.node,s,r)&&([p]=Xi(f.node.name,r)),s[f.node.name]==null){const g=SE(f.node,s,r,this._resourceManager);p||([p]=Xi(f.node.name,r));const y=r.currentContext;Eu(g)?d.push(g.then(x=>(s[p]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(x)),r.currentContext=y,this.checkTensorForDisposal(p,f.node,s,r,i,a,l),this.processChildNodes(f.node,n,r,s,o,c),x))):(s[p]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(g)),this.checkTensorForDisposal(p,f.node,s,r,i,a,l),this.processChildNodes(f.node,n,r,s,o,c))}else this.processChildNodes(f.node,n,r,s,o,c)}return d}processChildNodes(e,n,r,s,o,i){e.children.forEach(a=>{const[l]=Xi(a.name,r);o[l]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(c=>!!Yn(c,s,r))&&(o[l]=!0,n.push({contexts:r.currentContext,node:a})):a.inputNames.every(c=>!!Yn(c,s,r))&&(o[l]=!0,n.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(n=>n.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(n=>{const r=e[n],[s]=us(n),o=this.graph.nodes[s];if(o.attrParams.shape&&o.attrParams.shape.value){const i=o.attrParams.shape.value,a=i.length===r.shape.length&&r.shape.every((l,c)=>i[c]===-1||i[c]===l);z(a,()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&z(r.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){var n,r;const s={};for(const o in e){const i=(r=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||r===void 0?void 0:r[o];i!=null?s[i.name]=e[o]:s[o]=e[o]}return s}checkInputs(e){const n=Object.keys(e).filter(r=>{const[s]=us(r);return this.graph.nodes[s]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(e){return e.map(n=>{var r,s;const o=(s=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||s===void 0?void 0:s[n];return o!=null?o.name:n},{})}checkOutputs(e){e.forEach(n=>{const[r]=us(n);if(!this.graph.nodes[r])throw new Error(`The output '${n}' is not found in the graph`)})}}class N0e{constructor(e={},n={}){this.hashTableNameToHandle=e,this.hashTableMap=n}addHashTable(e,n){this.hashTableNameToHandle[e]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E0e="?tfjs-format=file",R0e="model.json";class _0e{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,n={},r=UD){this.modelUrl=e,this.loadOptions=n,this.version="n/a",this.io=r,n==null&&(this.loadOptions={}),this.resourceManager=new N0e}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const n=this.io.getLoadHandlers(e,this.loadOptions);if(n.length===0)n.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(n.length>1)throw new Error(`Found more than one (${n.length}) load handlers for URL '${[e]}'`);this.handler=n[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Eu(e)?e.then(n=>n.getWeightStream==null?this.loadSync(n):this.loadStreaming(n)):this.loadSync(e)}loadSync(e){const n=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,n)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const n=await zA(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,n)}loadWithWeightMap(e,n){this.artifacts=e;const r=this.artifacts.modelTopology;let s=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const o=this.artifacts.userDefinedMetadata;o.signature!=null&&(s=o.signature),o.structuredOutputKeys!=null&&(this.structuredOutputKeys=o.structuredOutputKeys)}if(this.signature=s,this.version=`${r.versions.producer}.${r.versions.minConsumer}`,this.executor=new Lg(xE.Instance.transformGraph(r,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(n),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const o=xE.Instance.transformGraph(e.modelInitializer);this.initializer=new Lg(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,n){if(typeof e=="string"){const r=this.io.getSaveHandlers(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const n=e instanceof hn?[e]:e,r={};return n.forEach((s,o)=>r[this.structuredOutputKeys[o]]=s),r}return e}predict(e,n){const r=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(r)}async predictAsync(e,n){const r=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(r)}normalizeInputs(e){var n;if(!(e instanceof hn)&&!Array.isArray(e)){const o=(n=this.signature)===null||n===void 0?void 0:n.inputs;if(o!=null)for(const i in o){const a=o[i];a.resourceId!=null&&(e[i]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];const r=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${e.length} input tensors provided.`);let s=0;return this.inputNodes.reduce((o,i)=>{var a,l,c;const d=(c=(l=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||l===void 0?void 0:l[i])===null||c===void 0?void 0:c.resourceId;return d!=null?o[i]=this.resourceIdToCapturedInput[d]:o[i]=e[s++],o},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const n=this.initializerSignature.outputs,r=Object.keys(n);for(let s=0;s<r.length;s++){const o=r[s],i=n[o];this.resourceIdToCapturedInput[i.resourceId]=e[s]}}}execute(e,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const r=this.executor.execute(e,n);return r.length>1?r:r[0]}async executeAsync(e,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const r=await this.executor.executeAsync(e,n);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((n,r)=>(n[r]=[e[r]],n),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Bt(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function fd(t,e={},n=UD){if(t==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof t=="string"&&(t=P0e(t));const r=new _0e(t,e,n);return await r.load(),r}function P0e(t){return t.endsWith("/")||(t=t+"/"),`${t}${R0e}${E0e}`}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Os=oe();Os.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);Os.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);Os.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);Os.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0);Os.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);Os.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);Os.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);Os.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);Os.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);Os.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1);Os.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);Os.registerFlag("WEBGPU_PRINT_SHADER",()=>"");Os.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class A0e{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class D0e{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,n,r=!1,s=!0){let o;const i=kE(e,n);return s?(this.freeBuffers.has(i)||this.freeBuffers.set(i,[]),this.freeBuffers.get(i).length>0?(o=this.freeBuffers.get(i).pop(),this.numFreeBuffers--):(o=this.device.createBuffer({size:e,usage:n,mappedAtCreation:r}),this.numBytesAllocated+=e)):(o=this.device.createBuffer({size:e,usage:n,mappedAtCreation:r}),this.numBytesAllocated+=e),this.usedBuffers.has(i)||this.usedBuffers.set(i,[]),this.usedBuffers.get(i).push(o),this.numUsedBuffers++,this.numBytesUsed+=e,o}releaseBuffer(e,n=!0){if(this.freeBuffers.size===0)return;const r=e.size,s=e.usage,o=kE(r,s),i=this.usedBuffers.get(o),a=i.indexOf(e);if(a<0)throw new Error("Cannot find the buffer in buffer manager");i[a]=i[i.length-1],i.pop(),this.numUsedBuffers--,this.numBytesUsed-=r,n?(this.freeBuffers.get(o).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=r)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,n)=>{e.forEach(r=>{r.destroy()})}),this.usedBuffers.forEach((e,n)=>{e.forEach(r=>{r.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function kE(t,e){return`${t}_${e}`}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F0e{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,n,r,s){const o=IE(r),i=e*n*o,a=TE(e,n,r,s);if(this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.usedTextures.has(a)||this.usedTextures.set(a,[]),this.numBytesUsed+=i,this.numUsedTextures++,this.freeTextures.get(a).length>0){this.numFreeTextures--;const c=this.freeTextures.get(a).shift();return this.usedTextures.get(a).push(c),c}this.numBytesAllocated+=i;const l=this.device.createTexture({size:[e,n],format:r,usage:s});return this.usedTextures.get(a).push(l),l}releaseTexture(e){if(this.freeTextures.size===0)return;const n=e.width,r=e.height,s=e.format,o=e.usage,i=TE(n,r,s,o);this.freeTextures.has(i)||this.freeTextures.set(i,[]),this.freeTextures.get(i).push(e),this.numFreeTextures++,this.numUsedTextures--;const a=this.usedTextures.get(i),l=a.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(l,1);const c=IE(s),d=n*r*c;this.numBytesUsed-=d}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,n)=>{e.forEach(r=>{r.destroy()})}),this.usedTextures.forEach((e,n)=>{e.forEach(r=>{r.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function TE(t,e,n,r){return`${t}_${e}_${n}_${r}`}function IE(t){if(t==="rgba8unorm")return 16;throw new Error(`${t} is not supported!`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O0e(t,e){if(Math.max(...t)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const n=t.length,r="xyzwuv",s=t.map(i=>`${e}.${r[i]}`),o=new Array(n-1);o[n-2]=s[n-1];for(let i=n-3;i>=0;--i)o[i]=`(${o[i+1]} * ${s[i+1]})`;return o}const Tl=(t,e,n)=>n==="int32"?`atomicAdd(${t}, bitcast<i32>(${e}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${e});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${t}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var pd;(function(t){t[t.FROM_PIXELS=0]="FROM_PIXELS",t[t.DRAW=1]="DRAW"})(pd||(pd={}));const L0e=(t,e,n,r,s)=>{const o={dtype:r.dtype,shape:r.shape},i=B0e(n,o,e),a=t.createShaderModule({code:i,label:e.constructor.name});let l=oe().get("WEBGPU_PRINT_SHADER");if(l!==""){l=l.toLowerCase();const c=l.split(",");(l==="all"||c.some(d=>e.shaderKey.toLowerCase().includes(d)))&&(console.group(e.shaderKey),console.debug(i),console.groupEnd())}return s?t.createComputePipelineAsync({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"}):t.createComputePipeline({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})},ut=(t,e="f32")=>{switch(t){case 1:return`${e}`;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${t}-component ${e} is not supported.`)}};function vn(t){if(t<=1)return"i32";if(t===2)return"vec2<i32>";if(t===3)return"vec3<i32>";if(t===4)return"vec4<i32>";if(t===5)return"vec5";if(t===6)return"vec6";throw Error(`GPU for rank ${t} is not yet supported`)}function oa(t){if(t===0)return"x";if(t===1)return"y";if(t===2)return"z";if(t===3)return"w";if(t===4)return"u";if(t===5)return"v";throw Error(`Index ${t} is not yet supported`)}function Ee(...t){let e;switch(t.length){case 0:e=`
        fn main()
      `;break;case 1:e=`
        fn main(${t[0]} : i32)
      `;break;default:throw Error("Unreachable")}return e}function NE(t,e){let n;return n=`
     ${z0e(e)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${t?"main(getGlobalIndex());":"main();"};
      }
    `,n}function z0e(t){return`
  @compute @workgroup_size(${t.workgroupSize[0]}, ${t.workgroupSize[1]}, ${t.workgroupSize[2]})
`}function B0e(t,e,n){const r=[],s=n.workgroupSize[0]*n.workgroupSize[1]*n.workgroupSize[2];if(n.outputComponent=n.outputComponent?n.outputComponent:1,r.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${fO(n)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${s}u +
                localIndex);
        `}
      }
    `),n.pixelsOpType!=null){const y=n.pixelsOpType===pd.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${pu(e.dtype,n.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${pu(t[0].dtype,n.outputComponent)}>;`,x=e.shape.length===3?"vec2<i32>":"i32";r.push(`
        struct Uniform {
          outShapeStrides : ${x},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${y}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const w=RE(n);return[EE,r.join(`
`),ng(e.shape),n.getUserCode(),NE(w,n)].join(`
`)}let o,i,a="struct Uniforms { NAN : f32, INFINITY : f32, ";n.variableNames.forEach((y,x)=>{const w=vn(t[x].shape.length);a+=`${y.charAt(0).toLowerCase()+y.slice(1)}Shape : ${w}, `,o=t[x].shape.length-1,i=vn(o),a+=`${y.charAt(0).toLowerCase()+y.slice(1)}ShapeStrides: ${i}, `});const l=vn(e.shape.length);a+=`outShape : ${l}, `,o=e.shape.length-1,i=vn(o),a+=`
         outShapeStrides: ${i}, `,n.size&&(a+="size : i32, "),n.uniforms&&(a+=n.uniforms),a+="};",a=X0e(a),r.push(a),n.atomic?r.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):r.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${pu(e.dtype,n.outputComponent)}>;
    `),n.variableNames.forEach((y,x)=>{r.push(`
      @group(0) @binding(${1+x}) var<storage, read> ${y}: array<${n.variableComponents?pu(t[x].dtype,n.variableComponents[x]):pu(t[x].dtype,n.outputComponent)}>;
        `)}),a!==""&&r.push(`
      @group(0) @binding(${1+n.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const c=G0e(e.shape,n.dispatchLayout),d=[EE,r.join(`
`)+V0e,ng(e.shape),c,H0e(e.shape.length)];n.atomic||d.push(K0e(e.shape,e.dtype,n.outputComponent)),n.variableNames.forEach((y,x)=>{d.push(`${ng(t[x].shape,y)}`)});const f=t.map((y,x)=>j0e(y,e.shape,n.variableComponents?n.variableComponents[x]:n.outputComponent,n.dispatchLayout.x.length===e.shape.length)).join(`
`);d.push(f),d.push(n.getUserCode());const p=RE(n);return d.push(NE(p,n)),d.join(`
`)}function M0e(t,e,n){let r=t.shaderKey;if(t.pixelsOpType!=null)return r;const s=[],o=[];e.forEach(d=>{s.push(d.shape),o.push(d.dtype)}),s.push(n.shape),o.push(n.dtype);const i=e.map(d=>cd(d.shape,n.shape)),a=e.map(d=>Mt(d.shape,n.shape)).join("_"),l=i.map(d=>d.join("_")).join(";"),c=fO(t)?"flatDispatch":"";return r+="_"+(t.workgroupSize?t.workgroupSize.join(","):"")+s.map(d=>d.length).join(",")+o.join(",")+t.variableNames.join(",")+l+a+c,r}const EE=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,V0e=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function ng(t,e=""){const n=t.length,r=e!==""?`get${e.charAt(0).toUpperCase()+e.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",s=e!==""?`${e.charAt(0).toLowerCase()+e.slice(1)}ShapeStrides`:"outShapeStrides";if(n<=1)return`fn ${r}(index : i32) -> i32 { return index; }`;const o=mn(t),i=vn(n),a=[];for(let c=0;c<n;c++)a.push(`d${c}`);if(o.length===1)return`    fn ${r}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${s}; let d1 = index - d0 * uniforms.${s};
      return vec2<i32>(d0, d1);
    }`;let l;return l="var index2 = index;"+o.map((c,d)=>{const f=`let ${a[d]} = index2 / uniforms.${s}.${oa(d)}`,p=d===o.length-1?`let ${a[d+1]} = index2 - ${a[d]} * uniforms.${s}.${oa(d)}`:`index2 = index2 - ${a[d]} * uniforms.${s}.${oa(d)}`;return`${f}; ${p};`}).join(""),`
    fn ${r}(index : i32) -> ${i} {
      ${l}
      return ${i}(${a.join(",")});
    }
  `}function W0e(t,e){const n=t.name,r=t.shape.length,s=vn(r),o="get"+n.charAt(0).toUpperCase()+n.slice(1),i=["d0","d1","d2","d3","d4","d5"].slice(0,r),a=i.map(d=>`${d} : i32`).join(", ");if(r<1)return`
      fn ${o}() -> ${ut(e)} {
        return ${ut(e)}(${n}[0]);
      }
    `;const l=`uniforms.${n.charAt(0).toLowerCase()+n.slice(1)}Shape`;let c=`${r}D`;return r===0&&(c="1D"),`
    fn ${o}(${a}) -> ${ut(e)} {
      return ${ut(e)}(${n}[getIndexFromCoords${c}(${s}(${i.join(",")}),
        ${l})${e===1?"":` / ${e}`}]);
    }
   `}function U0e(t,e,n,r){const s=t.name,o=s.charAt(0).toUpperCase()+s.slice(1),i="get"+o+"ByOutput",a=t.shape.length,l=e.length,c=vn(l);if(Mt(t.shape,e)&&r)return`
    fn ${i}Index(globalIndex : i32) -> ${ut(n)} {
      return ${ut(n)}(${s}[globalIndex]);
    }

    fn ${i}Coords(coords : ${c}) -> ${ut(n)} {
      return ${ut(n)}(${s}[${l>1?"getOutputIndexFromCoords(coords)":"coords"}${n===1?"":` / ${n}`}]);
    }
    `;const d=cd(t.shape,e),f=l-a;let p="";if(a===0)return`
    fn ${i}Index(globalIndex : i32) -> ${ut(n)}{
      return get${o}();
    }

    fn ${i}Coords(coords : ${c}) -> ${ut(n)}{
      return get${o}();
    }
  `;l<2&&d.length>=1?p="coords = 0;":p=d.map(w=>`coords.${oa(w+f)} = 0;`).join(`
`);let g="";if(l<2&&a>0)g="coords";else if(l>1){const w=vn(a),S=t.shape.map(($,I)=>`coords.${oa(I+f)}`).join(", ");g=`${w}(${S})`}else g="coords";const y=`uniforms.${s.charAt(0).toLowerCase()+s.slice(1)}Shape`,x=`${a}D`;return`
  fn ${i}Index(globalIndex : i32) -> ${ut(n)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${p}
    return ${ut(n)}(${s}[getIndexFromCoords${x}(${g}, ${y})${n===1?"":` / ${n}`}]);
  }

  fn ${i}Coords(coordsIn : ${c}) -> ${ut(n)} {
    var coords = coordsIn;
    ${p}
    return ${ut(n)}(${s}[getIndexFromCoords${x}(${g}, ${y})${n===1?"":` / ${n}`}]);
  }
`}function j0e(t,e,n,r){let s=W0e(t,n);return t.shape.length<=e.length&&(s+=U0e(t,e,n,r)),s}function G0e(t,e){const{x:n,y:r=[],z:s=[]}=e,o=t.length,i=n.length+r.length+s.length;if(i!==o)return"";if(n.length===o)return`fn getOutputCoords() -> ${vn(o)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let a="";const l=[n,r,s];for(let p=0;p<l.length;p++){const g=l[p];if(g.length!==0)if(g.length===1)a+=`let d${g[0]} = i32(globalId[${p}]);`;else{const y=O0e(g,"uniforms.outShape");a+=`var index${p} = i32(globalId[${p}]);`;for(let x=0;x<y.length;x++)a+=`let d${g[x]} = index${p} / ${y[x]};`,x===y.length-1?a+=`let d${g[x+1]} = index${p} - d${g[x]} * ${y[x]};`:a+=`index${p} = index${p} - d${g[x]} * ${y[x]};`}}const c=[];for(let p=0;p<i;p++)c.push(`d${p}`);const d=vn(i);let f=`fn getOutputCoords() -> ${d} {
  ${a}
`;return c.length===0?f+=`return ${d}(0); }`:f+=`return ${d}(${c.join(",")}); }`,f}function H0e(t){let e="";switch(t){case 0:case 1:e+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:e+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:e+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:z(!1,()=>`Unsupported ${t}D shape`);break}return e}function fO(t){return t.dispatch[1]===1&&t.dispatch[2]===1}function pu(t,e=1){if(t==="float32")return ut(e,"f32");if(t==="int32"||t==="bool")return ut(e,"i32");throw new Error(`type ${t} is not supported.`)}function K0e(t,e,n){const r=t.length,s=pu(e,n);let o=`fn setOutputAtIndex(flatIndex : i32, value : ${ut(n)}) {
      result[flatIndex] = ${s}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${ut(n,"i32")}) {
      result[flatIndex] = ${s}(value);
    }
    `;if(r>=2){const i=["d0","d1","d2","d3","d4","d5"].slice(0,r),a=vn(r);o+=`
      fn setOutputAtCoords(${i.map(l=>`${l} : i32`).join(", ")}, value : ${ut(n)}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${i.join(", ")}));
        setOutputAtIndex(flatIndex${n===1?"":` / ${n}`}, value);
      }
      fn setOutputAtCoordsI32(${i.map(l=>`${l} : i32`).join(", ")}, value : ${ut(n,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${i.join(", ")}));
        setOutputAtIndexI32(flatIndex${n===1?"":` / ${n}`}, value);
      }
    `}return o}function X0e(t){const e=/(\w+)\s*:\s*vec(5|6)/g;t=t.replace(e,r=>"@align(16) "+r);const n=/vec(5|6)\s*,\s*(\w+)/g;return t=t.replace(n,(r,s,o)=>`vec${s}, @align(16) ${o}`),t}function RE(t){return!(t.dispatchLayout.hasOwnProperty("y")&&t.dispatchLayout.y.length!==0||t.dispatchLayout.hasOwnProperty("z")&&t.dispatchLayout.z.length!==0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tu=t=>{let e=1;for(let n=0;n<t.length;n++)e*=t[n];return e};function Re(t,e,n=[1,1,1],r=[1,1,1]){const[s,o,i]=[Math.ceil(Tu(t.x.map(a=>e[a]))/(n[0]*r[0])),t.y?Math.ceil(Tu(t.y.map(a=>e[a]))/(n[1]*r[1])):1,t.z?Math.ceil(Tu(t.z.map(a=>e[a]))/(n[2]*r[2])):1];return[s,o,i]}function q0e(t,e,n,r=!1){const s=[8,8,1],o=[4,4,1];return r||(t<=8&&(o[1]=1),e<=16&&n<=16&&(s[0]=4)),{workgroupSize:s,elementsPerThread:o}}function pO(t,e,n=!1){if(n)return[8,8,1];const r=Tu(t.x.map(o=>e[o])),s=Tu(t.y.map(o=>e[o]));return r<=4?[4,16,1]:s<=4?[16,4,1]:[16,16,1]}function mO(t,e,n=!1){if(n)return[4,4,1];const r=Tu(t.x.map(o=>e[o])),s=Tu(t.y.map(o=>e[o]));return r<=4?[1,2,1]:s<=4?[2,1,1]:[2,2,1]}function De(t){return{x:t.map((e,n)=>n)}}function _E(t){if(t==="float32"||t==="int32"||t==="bool"||t==="string")return 4;if(t==="complex64")return 8;throw new Error(`Unknown dtype ${t}`)}function gO(){return!!(typeof globalThis<"u"&&globalThis.navigator&&globalThis.navigator.gpu)}function yO(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&z(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGPU backend.`)})}var oi;(function(t){t[t.MatMulReduceProgram=0]="MatMulReduceProgram",t[t.MatMulSplitKProgram=1]="MatMulSplitKProgram",t[t.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",t[t.MatMulPackedProgram=3]="MatMulPackedProgram",t[t.MatMulMax=4]="MatMulMax"})(oi||(oi={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y0e=oe().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),Q0e=(t,e)=>{const n=t.limits.maxComputeWorkgroupsPerDimension,r=e.dispatchLayout,s=e.dispatch;if(s.every(i=>i<=n))return s;z(s[0]>n&&r.y===void 0&&r.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let o=Math.ceil(Math.sqrt(s[0]));return o>n?(o=Math.ceil(Math.cbrt(s[0])),z(o<=n,()=>"Total dispatch size exceeds WebGPU maximum."),[o,o,o]):[o,o,1]};class Fd extends Zb{nextDataId(){return Fd.nextDataId++}constructor(e,n){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!gO())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new A0e(n),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new D0e(this.device),this.textureManager=new F0e(this.device),this.tensorMap=new VP(this,cs()),oe().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e,n=!1){if(!this.tensorMap.has(e))return!0;const r=this.tensorMap.get(e);return n?r.refCount=0:r.refCount--,r.refCount>0?!1:(r.complexTensorInfos!=null&&(this.disposeData(r.complexTensorInfos.real.dataId),this.disposeData(r.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const n=this.tensorMap.get(e);if(!(!n||!n.resource)){if(n.external){n.resource=null;return}n.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(n.resource):n.resource instanceof GPUTexture&&this.textureManager.releaseTexture(n.resource),n.resource=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){const n=this.tensorMap.get(e);n.refCount++}decRef(e){if(this.tensorMap.has(e)){const n=this.tensorMap.get(e);n.refCount--}}write(e,n,r){if(r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.tensorMap.set(s,{dtype:r,shape:n,values:e,refCount:1}),s}move(e,n,r,s,o){if(s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:s,shape:r,values:n,refCount:o})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(n){throw new Error(n.message)}Object.keys(this.pipelineCache).map((n,r)=>{this.pipelineCache[n]=e[r]})}async getBufferData(e){if(oe().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const n=e.size,r=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,r,0,n),this.submitQueue(),await r.mapAsync(GPUMapMode.READ);const s=r.getMappedRange().slice(0);return r.unmap(),r!=null&&this.bufferManager.releaseBuffer(r),oe().getBool("WEBGPU_USE_PROFILE_TOOL")&&(z(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),s}convertAndCacheOnCPU(e,n){const r=this.tensorMap.get(e);return r.values=n,r.values}readSync(e){const n=this.tensorMap.get(e),{values:r,complexTensorInfos:s}=n;if(r!=null||n.dtype==="string")return r;if(n.dtype==="complex64"){const x=this.readSync(s.real.dataId),w=this.readSync(s.imag.dataId),S=W1(Tf(x,w).buffer,"float32");return this.convertAndCacheOnCPU(e,S),S}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const o=["opaque","premultiplied"],i=n.resource,a=i.size;z(a%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const l=a/4,c=new ArrayBuffer(a),d=256,f=256,p=o.map(x=>new OffscreenCanvas(d,f)),g=new OffscreenCanvas(d,f);this.endComputePassEncoder(),p.map((x,w)=>{const S=x.getContext("webgpu");return S.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:o[w]}),S.getCurrentTexture()}).map((x,w)=>{const S=d*4,$=(M,B,V)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:i,bytesPerRow:S,offset:V},{texture:x},{width:M,height:B}),this.submitQueue();const A=g.getContext("2d",{willReadFrequently:!0});A.clearRect(0,0,M,B),A.drawImage(p[w],0,0);const re=A.getImageData(0,0,M,B).data,ae=o[w],pe=new Uint8ClampedArray(c,V,M*B*4);for(let ye=0;ye<pe.length;ye+=4)if(ae==="premultiplied")pe[ye+3]=re[ye+3];else{const ve=re[ye];pe[ye]=re[ye+2],pe[ye+1]=re[ye+1],pe[ye+2]=ve}},I=Math.floor(l/(d*f));let R=d,_=f,F=0;for(let M=0;M<I;M++)$(R,_,F),F+=d*f*4;const O=l%(d*f);_=Math.floor(O/d),_>0&&($(R,_,F),F+=_*(d*4)),R=O%d,R>0&&$(R,1,F)});const y=W1(c,n.dtype);return this.convertAndCacheOnCPU(e,y),y}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const n=this.tensorMap.get(e),{values:r}=n;if(r!=null)return r;let s;if(n.dtype==="complex64"){const o=await Promise.all([this.read(n.complexTensorInfos.real.dataId),this.read(n.complexTensorInfos.imag.dataId)]),i=o[0],a=o[1];s=Tf(i,a)}else{const o=await this.getBufferData(n.resource);s=W1(o,n.dtype)}return this.convertAndCacheOnCPU(e,s),s}copyBuffer(e){const n=e.size,r=e.usage,s=this.bufferManager.acquireBuffer(n,r);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,s,0,n),this.submitQueue(),s}createTensorFromGPUData(e,n,r){let s=e.buffer;if(r==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const o={id:this.nextDataId()};this.tensorMap.set(o,{dtype:r,shape:n,values:null,refCount:1,external:e.zeroCopy});const i=this.tensorMap.get(o),a=_E(i.dtype)*fe(i.shape);if(e.buffer.size<a)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${a})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return e.zeroCopy!==!0&&(s=this.copyBuffer(s)),i.resource=s,cs().makeTensorFromDataId(o,n,r,this)}readToGPU(e){const n=this.tensorMap.get(e),{values:r,dtype:s,shape:o,resource:i}=n;if(s==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(i==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const a=i,l=a.size,c=a.usage,d=this.bufferManager.acquireBuffer(l,c);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(i,0,d,0,l),this.submitQueue();const f=this.makeTensorInfo(o,s),p=cs().makeTensorFromTensorInfo(f),g=this.tensorMap.get(f.dataId);return g.resource=d,{tensorRef:p,buffer:d}}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const r=n.map(s=>ca(s));return Vt(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Vt(e.shape,e.dtype,n)}async time(e){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const n=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const o=da(this.activeTimers.map(c=>c.query)).filter(c=>c!=null),i=da(this.activeTimers.map(c=>c.name)).filter(c=>c!=null);this.activeTimers=n,s&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},l=await Promise.all(o);return a.kernelMs=WP(l),a.getExtraProfileInfo=()=>l.map((c,d)=>({name:i[d],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,a}makeTensorInfo(e,n,r){return n==="string"&&r!=null&&r.length>0&&Hf(r[0])&&(r=r.map(o=>cl(o))),{dataId:this.write(r,e,n),shape:e,dtype:n}}tensorToBinding(e){if(!e)return null;const r=this.tensorMap.get(e.dataId).resource;return r instanceof GPUBuffer?{buffer:r}:r instanceof GPUTexture?r.createView():r}uploadToGPU(e){const n=this.tensorMap.get(e);if(n.resource!=null)return;const r=_E(n.dtype)*fe(n.shape);let s;const o=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(n.values){if(s=this.bufferManager.acquireBuffer(r,o,!0),s.mapState==="unmapped"){const i=this.bufferManager.acquireBuffer(r,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),a=i.getMappedRange();n.dtype==="int32"||n.dtype==="bool"?new Int32Array(a).set(n.values):new Float32Array(a).set(n.values),i.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(i,0,s,0,r),this.stagingPendingDisposal.push(i)}else{const i=s.getMappedRange();n.dtype==="int32"||n.dtype==="bool"?new Int32Array(i).set(n.values):new Float32Array(i).set(n.values),s.unmap()}n.values=null}else s=this.bufferManager.acquireBuffer(r,o);n.resource=s}makeUniforms(e){let n=0,r=0;const s=[];let o=1;e.forEach(l=>{l.data.length===0&&(l.data=[1]);let c;switch(l.data.length){case 1:c=4;break;case 2:c=8;break;case 3:c=16;break;case 4:c=16;break;case 5:c=16;break;case 6:c=16;break;default:z(!1,()=>`Unsupported ${l.data.length}D shape`)}(r===5||r===6)&&(c=16),c>o&&(o=c),n=Math.ceil(n/c)*c,r=l.data.length,s.push(n),n+=l.data.length*4}),n=Math.ceil(n/o)*o;const i=new ArrayBuffer(n);e.forEach((l,c)=>{const d=s[c];l.type==="int32"?new Int32Array(i,d,l.data.length).set(l.data):l.type==="uint32"?new Uint32Array(i,d,l.data.length).set(l.data):new Float32Array(i,d,l.data.length).set(l.data)});const a=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(a,0,i,0,n),this.uniformPendingDisposal.push(a),{offset:0,size:n,buffer:a}}runWebGPUProgram(e,n,r,s,o){if(o||(o=this.makeTensorInfo(e.outputShape,r)),fe(o.shape)===0)return this.tensorMap.get(o.dataId).values=bi(o.dtype,0),o;this.uploadToGPU(o.dataId),e.dispatch=Q0e(this.device,e);const i=n.map((l,c)=>{if(l.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(l.dataId),{dtype:this.tensorMap.get(l.dataId).dtype,shape:l.shape,name:e.variableNames[c]}});e.shaderKey=M0e(e,i,o);const a=oe().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=L0e(this.device,e,i,o,a)),e.pipeline=this.pipelineCache[e.shaderKey],a||this.recordAndSubmit(e,o,n,s),o}recordAndSubmit(e,n,r,s){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let o=[],i=[];const a="int32";if(e.pixelsOpType==null){o.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),i=r.concat(n).map(g=>g.shape);const p="int32";i.map(g=>{o.push({type:p,data:g});const y=mn(g);o.push({type:p,data:y})})}else{const p=mn(n.shape);o.push({type:a,data:p})}if(e.size){const p=fe(e.outputShape);o.push({type:a,data:[e.outputComponent?p/e.outputComponent:p]})}s&&(o=[...o,...s]);const l=[this.tensorToBinding(n),...r.map(p=>this.tensorToBinding(p)),this.makeUniforms(o)];r.forEach(p=>{this.commandQueueOwnedIds.add(p.dataId)}),this.commandQueueOwnedIds.add(n.dataId);const c=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:l.map((p,g)=>({binding:g,resource:p}))}),d=this.activeTimers!=null;this.ensureCommandEncoderReady();const f={};d&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),f.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(f)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(f)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,c),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(d||oe().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===pd.DRAW)&&(this.endComputePassEncoder(),d?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.querySetCount*8),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const n=new BigUint64Array(e.getMappedRange()),r=Number(n[1]-n[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),r}shouldExecuteOnCPU(e,n=Y0e){return oe().getBool("WEBGPU_CPU_FORWARD")&&e.every(r=>this.tensorMap.get(r.dataId).resource==null&&fe(r.shape)<n)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}Fd.nextDataId=0;/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */gO()&&FA("webgpu",async()=>{const t={powerPreference:oe().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(t),n={},r=[];e.features.has("timestamp-query")&&r.push("timestamp-query"),e.features.has("bgra8unorm-storage")&&r.push(["bgra8unorm-storage"]),n.requiredFeatures=r;const s=e.limits;n.requiredLimits={maxComputeWorkgroupStorageSize:s.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:s.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:s.maxStorageBufferBindingSize,maxBufferSize:s.maxBufferSize,maxComputeWorkgroupSizeX:s.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:s.maxComputeInvocationsPerWorkgroup};const o=await e.requestDevice(n),i="info"in e?e.info:"requestAdapterInfo"in e?await e.requestAdapterInfo():void 0;return new Fd(o,i)},3);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var et;(function(t){t[t.ADD=0]="ADD",t[t.ATAN2=1]="ATAN2",t[t.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",t[t.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",t[t.DIV=4]="DIV",t[t.ELU_DER=5]="ELU_DER",t[t.EQUAL=6]="EQUAL",t[t.FLOOR_DIV=7]="FLOOR_DIV",t[t.GREATER=8]="GREATER",t[t.GREATER_EQUAL=9]="GREATER_EQUAL",t[t.LESS=10]="LESS",t[t.LESS_EQUAL=11]="LESS_EQUAL",t[t.LOGICAL_AND=12]="LOGICAL_AND",t[t.LOGICAL_OR=13]="LOGICAL_OR",t[t.MAX=14]="MAX",t[t.MIN=15]="MIN",t[t.MOD=16]="MOD",t[t.MUL=17]="MUL",t[t.NOT_EQUAL=18]="NOT_EQUAL",t[t.POW=19]="POW",t[t.PRELU=20]="PRELU",t[t.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",t[t.SUB=22]="SUB"})(et||(et={}));const Z0e="let resultTemp = a + b;",J0e="let resultTemp = atan2(a, b);",e1e="let resultTemp = areal * breal - aimag * bimag;",t1e="let resultTemp = areal * bimag + aimag * breal;",n1e="let resultTemp = a / b;",r1e="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",s1e=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,o1e=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,i1e=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,a1e=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,l1e=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,u1e=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,c1e="return f32(a >= 1.0 && b >= 1.0);",d1e=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,h1e="return f32(a >= 1.0 || b >= 1.0);",f1e=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,p1e="let resultTemp = max(a, b);",m1e="let resultTemp = min(a, b);",g1e=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,y1e=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,x1e="let resultTemp = a * b;",v1e=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,b1e=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,w1e=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,S1e=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,C1e="if (a < 0.0) { return b * a; }  return a;",$1e=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,k1e="let resultTemp = (a - b) * (a - b);",T1e="let resultTemp = a - b;";function zC(t,e){let n;do{switch(t){case et.ATAN2:n=J0e;break;case et.MAX:n=p1e;break;case et.MIN:n=m1e;break;case et.MOD:n=e?y1e:g1e;break;case et.NOT_EQUAL:n=e?b1e:v1e;break;case et.POW:n=e?S1e:w1e;break;default:continue}let r,s,o;return e?(r="isnanVec4",s="vec4<f32>",o="vec4<bool>"):(r="isnan",s="f32",o="bool"),`
      let aIsNaN = ${r}(a);
      let aPostLegalization = select(a, ${s}(42), aIsNaN);
      let bIsNaN = ${r}(b);
      let bPostLegalization = select(b, ${s}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${n}
        return select(
            resultTemp, ${s}(valueForNaN),
            ${o}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(t){case et.ADD:n=Z0e;break;case et.COMPLEX_MULTIPLY_IMAG:n=t1e;break;case et.COMPLEX_MULTIPLY_REAL:n=e1e;break;case et.DIV:n=n1e;break;case et.ELU_DER:n=r1e;break;case et.EQUAL:n=s1e;break;case et.FLOOR_DIV:n=o1e;break;case et.GREATER:n=i1e;break;case et.GREATER_EQUAL:n=a1e;break;case et.LESS:n=l1e;break;case et.LESS_EQUAL:n=u1e;break;case et.LOGICAL_AND:return e?d1e:c1e;case et.LOGICAL_OR:return e?f1e:h1e;case et.MUL:n=x1e;break;case et.PRELU:return e?$1e:C1e;case et.SQUARED_DIFFERENCE:n=k1e;break;case et.SUB:n=T1e;break}return`
    ${n}
    return resultTemp;
  `}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ne;(function(t){t[t.ABS=0]="ABS",t[t.ACOS=1]="ACOS",t[t.ACOSH=2]="ACOSH",t[t.ASIN=3]="ASIN",t[t.ASINH=4]="ASINH",t[t.ATAN=5]="ATAN",t[t.ATANH=6]="ATANH",t[t.CEIL=7]="CEIL",t[t.COS=8]="COS",t[t.COSH=9]="COSH",t[t.ELU=10]="ELU",t[t.ERF=11]="ERF",t[t.EXP=12]="EXP",t[t.EXPM1=13]="EXPM1",t[t.FLOOR=14]="FLOOR",t[t.IS_FINITE=15]="IS_FINITE",t[t.IS_INF=16]="IS_INF",t[t.IS_NAN=17]="IS_NAN",t[t.LINEAR=18]="LINEAR",t[t.LOG=19]="LOG",t[t.LOG1P=20]="LOG1P",t[t.LOGICAL_NOT=21]="LOGICAL_NOT",t[t.NEG=22]="NEG",t[t.RELU=23]="RELU",t[t.RELU6=24]="RELU6",t[t.LEAKYRELU=25]="LEAKYRELU",t[t.RECIPROCAL=26]="RECIPROCAL",t[t.ROUND=27]="ROUND",t[t.RSQRT=28]="RSQRT",t[t.SELU=29]="SELU",t[t.SIGMOID=30]="SIGMOID",t[t.SIGN=31]="SIGN",t[t.SIN=32]="SIN",t[t.SINH=33]="SINH",t[t.SOFTPLUS=34]="SOFTPLUS",t[t.SQRT=35]="SQRT",t[t.SQUARE=36]="SQUARE",t[t.STEP=37]="STEP",t[t.TAN=38]="TAN",t[t.TANH=39]="TANH",t[t.TO_INT=40]="TO_INT"})(Ne||(Ne={}));const I1e="return abs(a);",N1e=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,E1e=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,R1e=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,_1e="return asinh(a);",P1e=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,A1e=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,D1e="return ceil(a);",F1e="return cos(a);",O1e=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,L1e="return exp(a) - 1.0;",z1e="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",B1e=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,M1e=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${pC};
  let a1 = ${mC};
  let a2 = ${gC};
  let a3 = ${yC};
  let a4 = ${xC};
  let a5 = ${vC};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,V1e="return exp(a);",W1e="return floor(a);",U1e="return f32(!isnan(a) && !isinf(a));",j1e="return f32(isinf(a));",G1e="return f32(isnan(a));",H1e="return a;",K1e=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,X1e=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,q1e="return f32(!(a >= 1.0));",Y1e="return -a;",Q1e="if (a < 0.0) { return uniforms.alpha * a; } return a;",Z1e=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,J1e="return 1.0 / a;",exe="return select(a, 0.0, a < 0.0);",txe="return clamp(a, 0.0, 6.0);",nxe="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",rxe=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,sxe="return round(a);",oxe="return inverseSqrt(a);",ixe=`
  if (a >= 0.0) {
    return ${fC} * a;
  } else {
    return ${hC} * (exp(a) - 1.0);
  }
`,axe="return 1.0 / (1.0 + exp(-1.0 * a));",lxe="return sign(a);",uxe="return sin(a);",cxe=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,dxe=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,hxe="return sqrt(a);",fxe="return a * a;",pxe=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,mxe="return tan(a);",gxe=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,yxe="return f32(i32((a)));";function lu(t,e){switch(t){case Ne.ABS:return I1e;case Ne.ACOS:return N1e;case Ne.ACOSH:return E1e;case Ne.ASIN:return R1e;case Ne.ASINH:return _1e;case Ne.ATAN:return P1e;case Ne.ATANH:return A1e;case Ne.COS:return F1e;case Ne.COSH:return O1e;case Ne.CEIL:return D1e;case Ne.ELU:return e?B1e:z1e;case Ne.ERF:return M1e;case Ne.EXP:return V1e;case Ne.EXPM1:return L1e;case Ne.FLOOR:return W1e;case Ne.IS_FINITE:return U1e;case Ne.IS_INF:return j1e;case Ne.IS_NAN:return G1e;case Ne.LINEAR:return H1e;case Ne.LOG:return K1e;case Ne.LOG1P:return X1e;case Ne.LOGICAL_NOT:return q1e;case Ne.NEG:return Y1e;case Ne.LEAKYRELU:return e?Z1e:Q1e;case Ne.RECIPROCAL:return J1e;case Ne.RELU:return e?rxe:exe;case Ne.RELU6:return e?nxe:txe;case Ne.ROUND:return sxe;case Ne.RSQRT:return oxe;case Ne.SELU:return ixe;case Ne.SIGMOID:return axe;case Ne.SIGN:return lxe;case Ne.SIN:return uxe;case Ne.SINH:return cxe;case Ne.SOFTPLUS:return dxe;case Ne.SQRT:return hxe;case Ne.SQUARE:return fxe;case Ne.STEP:return pxe;case Ne.TAN:return mxe;case Ne.TANH:return gxe;case Ne.TO_INT:return yxe;default:throw new Error(`BinaryType ${t} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $a(t,e=!1,n=!1,r=3){if(t===null)return"";let s="";if(t==="linear")s=lu(Ne.LINEAR);else if(t==="relu")s=lu(Ne.RELU,n);else if(t==="elu")s=lu(Ne.ELU,n);else if(t==="relu6")s=lu(Ne.RELU6,n);else if(t==="prelu")s=zC(et.PRELU,n);else if(t==="sigmoid")s=lu(Ne.SIGMOID,n);else if(t==="leakyrelu")s=lu(Ne.LEAKYRELU,n);else throw new Error(`Activation ${t} has not been implemented for the WebGPU backend.`);const i=ut(n?4:1);let a="";return e?a=`
      fn activation(a : ${i}, coords : vec${r}<i32>) -> ${i} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${s}
      }`:a=`
      fn activation(a : ${i}, coords : vec${r}<i32>) -> ${i} {
        ${s}
      }`,a}function Gu(t,e){return`
      ${t?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xO(t,e,n=!1,r=!1,s=!1,o=1){z(t&&o===1||!t,()=>`transposeA ${t} is not compatible with component size ${o}`);const i=`
      ${t?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,a=e?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${ut(o)} {
    var value = ${ut(o)}(0.0);
    ${n&&s?i:`
    ${t?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${i}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${ut(o)} {
    var value = ${ut(o)}(0.0);
    ${a}
    return value;
  }
  `}function BC(t,e,n,r,s=!1,o=!1,i=!1,a=1){return`
  ${xO(n,r,s,o,i,a)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${ut(a)}) {
    ${s&&o?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${Gu(t,e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}const xxe=(t,e)=>t?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${e});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${e});
        `,vxe=(t,e,n,r)=>{if(t)return`
      for (var k = 0; k < ${r}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${n}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let s="",o="";for(let i=0;i<e;i++)s+=`let BCached${i} = mm_Bsub[k * ${e} + ${i}][tileCol];`,o+=`acc[i] = fma(BCached${i}, vec4<f32>(ACached[${i}]), acc[i]);`;return`
      for (var k = 0; k < ${r/e}; k++) {
        ${s}
        for (var i = 0; i < ${n}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${o}
        }
      }`}};function ky(t,e,n=!1,r=32,s=!1,o=32,i=!1){const a=e[1]*t[1],l=e[0]*t[0],c=n?a:r,d=n?r:a,f=c/e[0],p=r/e[1],g=t[1],y=t[0];return z((n&&f===4&&t[1]===4||!n&&(f===3||f===4))&&c%e[0]===0&&r%e[1]===0&&t[0]===4,()=>`If transposeA ${n} is true, innerElementSize ${f} and workPerThread[1] ${t[1]} must be 4.
          Otherwise, innerElementSize ${f} must be 3 or 4.
      tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}. tileInner ${r} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${t[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${f}<f32>, ${c/f}>, ${d}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${l/t[0]}>, ${r}>;

  ${Ee()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${g};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${g};
    let globalCol = i32(globalId.x) * ${y};
    let batch = ${s?"0":"i32(globalId.z)"};
    let batchA = ${s||!i?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${s||!i?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${a};

    let numTiles = ${s?`${Math.ceil(o/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};
    var kStart = ${s?`i32(globalId.z) * ${o}`:"0"};

    var acc: array<vec4<f32>, ${g}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${p};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${g}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${xxe(n,f)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${p}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${r};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${vxe(n,f,g,r)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const PE=t=>t?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,bxe=t=>t?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function Ty(t,e,n=!1,r=32,s=!1,o=32,i=!1,a=!1){const l=t[1]*e[1],c=t[0]*e[0],d=n?l:r,f=n?r:l;z(f%e[1]===0&&d%e[0]===0&&r%e[1]===0,()=>`tileAHight ${f} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${d} must be divisible by workgroupSize[0]${e[0]}, tileInner ${r} must be divisible by workgroupSize[1]${e[1]}`);const p=f/e[1],g=d/e[0],y=r/e[1],x=t[1],w=t[0],S=i?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${l};
      let globalColStart = i32(workgroupId.x) * ${c};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${f}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${e[0]}) {
            ${PE(n)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${r};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${w}>;
        for (var k = 0; k < ${r}; k++) {
          for (var inner = 0; inner < ${w}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < ${x}; innerRow++) {
            let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < ${w}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${x}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < ${w}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${x};
  let tileCol = i32(localId.x) * ${w};

  let globalRow = i32(globalId.y) * ${x};
  let globalCol = i32(globalId.x) * ${w};
  let globalRowStart = i32(workgroupId.y) * ${l};

  let tileRowA = i32(localId.y) * ${p};
  let tileColA = i32(localId.x) * ${g};
  let tileRowB = i32(localId.y) * ${y};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${p}; innerRow++) {
      for (var innerCol = 0; innerCol < ${g}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${PE(n)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${y}; innerRow++) {
      for (var innerCol = 0; innerCol < ${w}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${r};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${w}>;
    for (var k = 0; k < ${r}; k++) {
      for (var inner = 0; inner < ${w}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${x}; innerRow++) {
        ${bxe(n)}
        for (var innerCol = 0; innerCol < ${w}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${x}; innerRow++) {
    for (var innerCol = 0; innerCol < ${w}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${d}>, ${f}>;
    var<workgroup> mm_Bsub : array<array<f32, ${c}>, ${r}>;

    ${Ee()} {
      let batch = ${s?"0":"i32(globalId.z)"};
      let batchA = ${s||!a?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${s||!a?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${s?`${Math.ceil(o/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};
      var kStart = ${s?`i32(globalId.z) * ${o}`:"0"};

      var acc : array<array<f32, ${w}>, ${x}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${x}; innerRow++) {
        for (var innerCol = 0; innerCol < ${w}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${S}
    }
  `}const wxe=t=>t?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function Sxe(t,e=!1){z(t[1]===1&&t[2]===1,()=>`A linear work group size is required. But got ${t}.`);const n=t[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${t[0]}>;

    ${Ee()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${n} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${n} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${wxe(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${n/4}; k++) {
          let rowB = t * ${n} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}class Cxe{constructor(e,n,r=!1,s=!1,o=null,i=null,a=null,l=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]};const c=r?e[1]:e[2];if(this.isVec4=(c%4===0&&!r||n[1]%4===0&&r)&&n[2]%4===0&&!s,this.outputComponent=this.isVec4?4:1,this.isVectorA=n[1]===1&&!r,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const p=q0e(n[1],c,n[2],r);this.workgroupSize=p.workgroupSize,this.elementsPerThread=p.elementsPerThread}this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const d=o!=null,f=a!=null;d&&this.variableNames.push("bias"),f&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=l,this.transposeA=r,this.transposeB=s,this.addBias=d,this.activation=i,this.hasPreluActivationWeights=f,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(n[1],n[2],c),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${r}_${s}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,n,r){const s=this.workgroupSize[1]*this.elementsPerThread[1],o=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=o;const i=e%s===0,a=n%o===0,l=r%this.tileInner===0;return[i,a,l]}getUserCode(){return`
      ${$a(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${BC(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?ky(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?Sxe(this.workgroupSize,this.transposeA):Ty(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $xe(t){return`
    var<workgroup> sumValues : array<f32, ${t}>;
    ${Ee()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${t}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${t/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}class kxe{constructor(e,n=!1,r=!1,s=null,o=null,i=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize);const a=s!=null,l=i!=null;a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.transposeA=n,this.transposeB=r,this.addBias=a,this.activation=o,this.hasPreluActivationWeights=l,this.shaderKey=`matMulReduce_${this.activation}_${n}_${r}`}getUserCode(){return`
      ${$a(this.activation,this.hasPreluActivationWeights)}
      ${BC(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${$xe(this.workgroupSize[0])}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Txe(t){const e=t[1],n=t[0],r=e>n?e:n;return`
  var<workgroup> mm_Asub : array<array<f32, ${r}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${r}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${Ee()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${r} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${r};
    globalRowB = globalRowB + ${r};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${r};
      globalRowB = globalRowB + ${r};

      for (var k = 0; k < ${r}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}class Ixe{constructor(e,n,r,s=!1,o=!1,i=null,a=null,l=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=r,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(r[2]/this.workgroupSize[0]),Math.ceil(r[1]/this.workgroupSize[1]),r[0]];const c=i!=null;c&&this.variableNames.push("bias");const d=l!=null;d&&this.variableNames.push("preluActivationWeights"),this.transposeA=s,this.transposeB=o,this.addBias=c,this.activation=a,this.hasPreluActivationWeights=d,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${s}_${o}`}getUserCode(){return`
      ${$a(this.activation,this.hasPreluActivationWeights)}
      ${BC(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${Txe(this.workgroupSize)}
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nxe{constructor(e,n,r=!1,s=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,z(e[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const o=(r&&this.outputShape[1]%4===0||!r&&n%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=o?4:1,o||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=Re(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],n],this.workgroupSize,this.elementsPerThread),this.transposeA=r,this.transposeB=s,this.shaderKey=`matMulSplitK_${r}_${s}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`
      ${xO(!1,this.transposeB,!1,!1,!1,e)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${ut(e)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${Tl("&result[flatIndex + i]",`${e>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${e===4?ky(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):Ty(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class Exe{constructor(e,n=null,r=null,s=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=n!=null,this.hasPreluActivationWeights=s!=null,this.activation=r,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${r}`}getUserCode(){return`
    ${$a(this.activation,this.hasPreluActivationWeights)}
    ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${Gu(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rxe{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wr(t){const{backend:e,attrs:n}=t,{shape:r,value:s}=n;let{dtype:o}=n;if(o=o||$d(s),o==="string"){const i=En(o,fe(r));return i.fill(s),e.makeTensorInfo(r,o,i)}else{const i=new Rxe(r),a=[{type:"float32",data:[s]}];return e.runWebGPUProgram(i,[],o,a)}}const _xe={kernelName:Zw,backendName:"webgpu",kernelFunc:Wr};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Be(t){const{inputs:e,attrs:n}=t,{x:r}=e,{shape:s}=n,o=fe(r.shape),i=UP(s,o),a=fe(i);return z(o===a,()=>`The new shape (${i}) has ${a} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),t.backend.incRef(r.dataId),{dataId:r.dataId,shape:i,dtype:r.dtype}}const Pxe={kernelName:q2,backendName:"webgpu",kernelFunc:Be};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iy({a:t,b:e,transposeA:n,transposeB:r,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:l=null}){const c=t.shape.length,d=e.shape.length,f=n?t.shape[c-2]:t.shape[c-1],p=r?e.shape[d-1]:e.shape[d-2],g=n?t.shape[c-1]:t.shape[c-2],y=r?e.shape[d-2]:e.shape[d-1],x=t.shape.slice(0,-2),w=e.shape.slice(0,-2),S=fe(x),$=fe(w),R=ct(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([g,y]);z(f===p,()=>`Error in matMul: inner shapes (${f}) and (${p}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${r} must match.`);const _=n?[S,f,g]:[S,g,f],F=r?[$,y,p]:[$,p,y],O=Be({inputs:{x:t},backend:s,attrs:{shape:_}}),M=Be({inputs:{x:e},backend:s,attrs:{shape:F}}),B=[O,M],V=Math.max(S,$),A=[O,M],re=[{type:"int32",data:[g]},{type:"int32",data:[y]},{type:"int32",data:[f]}];let ae,pe;const ye=[V,g,y];let ve=oe().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(ve<0){const se=oe().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),me=se>0?se:s.thresholdToIncreaseWorkgroups,ge=V*Math.ceil(g/32)*Math.ceil(y/32);ge<=me||g<=8&&ge<=me*2?V*g*y<=128?ve=oi.MatMulReduceProgram:V===1&&p>=2e3?ve=oi.MatMulSplitKProgram:ve=oi.MatMulSmallOutputSizeProgram:ve=oi.MatMulPackedProgram}switch(ve){case oi.MatMulReduceProgram:ae=new kxe(ye,n,r,o,l,i);break;case oi.MatMulSplitKProgram:{if(pe=Wr({backend:s,attrs:{shape:ye,value:0,dtype:t.dtype}}),ae=new Nxe(ye,p,n,r),o||l){pe=s.runWebGPUProgram(ae,A,t.dtype,re,pe);const me=new Exe(pe.shape,o,l,i);let ge=null;const Q=[pe];o&&Q.push(o),i&&Q.push(i),l==="leakyrelu"&&(ge=[{type:"float32",data:[a]}],me.uniforms+=" alpha : f32,");const he=s.runWebGPUProgram(me,Q,pe.dtype,ge);B.push(pe);const be=Be({inputs:{x:he},backend:s,attrs:{shape:R}});B.push(he);for(const We of B)s.disposeData(We.dataId);return be}break}case oi.MatMulSmallOutputSizeProgram:ae=new Ixe(_,F,ye,n,r,o,l,i);break;case oi.MatMulPackedProgram:const se=s.adapterInfo.isIntel();ae=new Cxe(_,ye,n,r,o,l,i,se);break;default:throw new Error(`Unsupported MatMulProgramType ${ve}.`)}o&&A.push(o),i&&A.push(i),l==="leakyrelu"&&(re.push({type:"float32",data:[a]}),ae.uniforms+=" alpha : f32,"),pe=s.runWebGPUProgram(ae,A,t.dtype,re,pe);const $e=Be({inputs:{x:pe},backend:s,attrs:{shape:R}});B.push(pe);for(const se of B)s.disposeData(se.dataId);return $e}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Axe(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:o,bias:i,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:d,leakyreluAlpha:f}=r;return Iy({a:s,b:o,transposeA:l,transposeB:c,backend:n,bias:i,preluActivationWeights:a,leakyreluAlpha:f,activation:d})}const Dxe={kernelName:wg,backendName:"webgpu",kernelFunc:Axe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AE{constructor(e,n,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=ct(n,r),this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${zC(this.op,!1)}
      }

      ${Ee("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zg{constructor(e,n,r){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=ct(n,r),this.dispatchLayout=De(this.outputShape),this.op=e,this.useSharedMemoryWithA=n.length<=1&&r.length>1&&n[0]<128,this.useSharedMemoryWithB=r.length<=1&&n.length>1&&r[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?r[0]:n[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const s=n.length>0&&n[n.length-1]%4===0,o=r.length>0&&r[r.length-1]%4===0;s&&o?(this.outputComponent=4,this.variableComponents=[4,4]):s&&(lN(r)||r[r.length-1]===1)||o&&(lN(n)||n[n.length-1]===1)?(this.outputComponent=4,this.variableComponents=s?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const n=this.outputComponent===4?"vec4<f32>":"f32",r=`
    fn binaryOperation(a : ${n}, b : ${n}) -> ${n} {
      ${zC(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){const s=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",o=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${s}];`:`let a = sharedBuf[${s}];
          let b = getBByOutputIndex(index);`;e=`
        ${r}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${Ee("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${o}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${r}
       ${Ee("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${n}(getAByOutputCoords(coords));
           let b = ${n}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ms(t){const{inputs:e}=t,{x:n}=e;return t.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const Fxe={kernelName:sy,backendName:"webgpu",kernelFunc:ms};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hu(t){const{inputs:e,backend:n}=t,{real:r,imag:s}=e,o=n.makeTensorInfo(r.shape,"complex64"),i=n.tensorMap.get(o.dataId),a=ms({inputs:{x:r},backend:n}),l=ms({inputs:{x:s},backend:n});return i.complexTensorInfos={real:a,imag:l},o}const Oxe={kernelName:Cw,backendName:"webgpu",kernelFunc:Hu};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Od{constructor(e,n,r=""){this.variableNames=["A"],this.size=!0;const s=128;this.workgroupSize=[s,1,1],this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=n,r!==""&&(this.uniforms=r),this.shaderKey=`unary_${n}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${lu(this.op,!1)}
      }
      ${Ee("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $t({opType:t,cpuKernelImpl:e,dtype:n}){return({inputs:r,backend:s})=>{const{x:o}=r,i=s,a=n||o.dtype;if(i.shouldExecuteOnCPU([o])&&e!=null){const c=i.tensorMap.get(o.dataId),d=e(c.values,a);return i.makeTensorInfo(o.shape,a,d)}const l=new Od(o.shape,t);return i.runWebGPUProgram(l,[o],a)}}function zn({opType:t,cpuKernelImpl:e,supportsComplex:n=!1,dtype:r}){return({inputs:s,backend:o})=>{const{a:i,b:a}=s,l=o;if(n&&i.dtype==="complex64"){const f=l.tensorMap.get(i.dataId),p=l.tensorMap.get(a.dataId);let g,y;if(t!==et.MUL)[g,y]=[[f.complexTensorInfos.real,p.complexTensorInfos.real],[f.complexTensorInfos.imag,p.complexTensorInfos.imag]].map(w=>{const[S,$]=w,I={dataId:S.dataId,dtype:S.dtype,shape:i.shape},R={dataId:$.dataId,dtype:$.dtype,shape:a.shape},_=new zg(t,i.shape,a.shape);return l.runWebGPUProgram(_,[I,R],Ur(S.dtype,$.dtype))});else{const w=new AE(et.COMPLEX_MULTIPLY_REAL,i.shape,a.shape),S=new AE(et.COMPLEX_MULTIPLY_IMAG,i.shape,a.shape),$=[{dataId:f.complexTensorInfos.real.dataId,dtype:f.complexTensorInfos.real.dtype,shape:i.shape},{dataId:f.complexTensorInfos.imag.dataId,dtype:f.complexTensorInfos.imag.dtype,shape:i.shape},{dataId:p.complexTensorInfos.real.dataId,dtype:p.complexTensorInfos.real.dtype,shape:a.shape},{dataId:p.complexTensorInfos.imag.dataId,dtype:p.complexTensorInfos.imag.dtype,shape:a.shape}];g=l.runWebGPUProgram(w,$,"float32"),y=l.runWebGPUProgram(S,$,"float32")}const x=Hu({inputs:{real:g,imag:y},backend:l});return l.disposeData(g.dataId),l.disposeData(y.dataId),x}const c=r||Ur(i.dtype,a.dtype);if((i.dtype==="string"||a.dtype==="string"||l.shouldExecuteOnCPU([i,a]))&&e!=null){const f=l.tensorMap.get(i.dataId).values,p=l.tensorMap.get(a.dataId).values,g=i.dtype==="string"?xl(f):f,y=i.dtype==="string"?xl(p):p,[x,w]=e(i.shape,a.shape,g,y,c);return l.makeTensorInfo(w,c,x)}const d=new zg(t,i.shape,a.shape);return l.runWebGPUProgram(d,[i,a],c)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:Lxe,castImpl:zxe,ceilImpl:Bxe,concatImpl:Mxe,equalImpl:Vxe,expImpl:Wxe,expm1Impl:Uxe,floorImpl:jxe,floorDivImpl:Gxe,gatherNdImpl:Hxe,gatherV2Impl:Kxe,greaterEqualImpl:Xxe,greaterImpl:qxe,lessEqualImpl:Yxe,lessImpl:Qxe,logImpl:Zxe,maxImpl:Jxe,maximumImpl:eve,minimumImpl:tve,multiplyImpl:nve,negImpl:rve,notEqualImpl:sve,prodImpl:ove,rangeImpl:ive,rsqrtImpl:ave,scatterImpl:lve,simpleAbsImpl:uve,sliceImpl:cve,stridedSliceImpl:dve,stringNGramsImpl:hve,subImpl:fve,tileImpl:pve,topKImpl:mve,transposeImpl:gve}=EF;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yve=$t({opType:Ne.ABS,cpuKernelImpl:uve}),xve={kernelName:nw,backendName:"webgpu",kernelFunc:yve};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vve=$t({opType:Ne.ACOS}),bve={kernelName:rw,backendName:"webgpu",kernelFunc:vve};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wve=$t({opType:Ne.ACOSH}),Sve={kernelName:sw,backendName:"webgpu",kernelFunc:wve};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cve=zn({opType:et.ADD,cpuKernelImpl:Lxe,supportsComplex:!0}),$ve={kernelName:ny,backendName:"webgpu",kernelFunc:Cve};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kve{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((n,r)=>`T${r}`),this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(s=>{e.push(`let v${s} = get${s}ByOutputCoords(coords);`)});const n=this.variableNames.map(s=>`v${s}`).join(" + ");return`
      ${Ee("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${n});
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tve(t){const{inputs:e,backend:n}=t,r=e;if(r.length===1)return ms({inputs:{x:r[0]},backend:n});const s=r.map(a=>a.dtype).reduce((a,l)=>Ur(a,l)),o=r.map(a=>a.shape),i=new kve(o);return n.runWebGPUProgram(i,r,s)}const Ive={kernelName:ow,backendName:"webgpu",kernelFunc:Tve};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nve{constructor(e,n){this.variableNames=["A"],this.workgroupSize=[16,16,1];const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[n[s]];this.outputShape=r,this.dispatchLayout={x:[0],y:[1]},this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){z(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const e=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${Ee()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Eve{constructor(e,n){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[n[s]];this.outputShape=r,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=n,this.shaderKey=`transpose_${n}`}getUserCode(){const e=vn(this.outputShape.length),n=vO(this.newDim);return`
      ${Ee("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${n}), uniforms.aShape)]);
          }
        }
      }
    `}}function vO(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=new Array(e);for(let r=0;r<t.length;r++)n[t[r]]=`coords.${oa(r)}`;return n.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wi(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{perm:o}=r,i=n,a=s.shape.length,l=new Array(a);for(let d=0;d<l.length;d++)l[d]=s.shape[o[d]];if(n.shouldExecuteOnCPU([s])){const f=i.tensorMap.get(s.dataId).values,p=gve(f,s.shape,s.dtype,o,l);return n.makeTensorInfo(l,s.dtype,p)}if(s.shape.length===2&&Mt(o,[1,0])){const d=new Nve(s.shape,o);return i.runWebGPUProgram(d,[s],s.dtype)}const c=new Eve(s.shape,o);return i.runWebGPUProgram(c,[s],s.dtype)}const Rve={kernelName:Qh,backendName:"webgpu",kernelFunc:wi};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _ve{constructor(e,n,r){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[s]=Fs(this.inputShape,[1]);this.outputShape=s.length===0?[1]:s,e.inSize>=32768&&r>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=n,this.shaderKey=`reduce_${n}`}getUserCode(){let e="",n="0.0";const r=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,n="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(e=" bestValue = bestValue * candidate; ",n="1.0"):this.reduceType==="all"?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",n="1.0"):this.reduceType==="any"&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",n="0.0");const s=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${r}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${Ee("index")} {
         let outputIndex = index / ${r};
         let offset = getOffset(outputIndex);
         var bestValue = ${n};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${r}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${r}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${r}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${s}
        }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pve={mean:"float32",all:"bool",any:"bool"};function Ku(t,e,n,r,s){const o=t.shape.length,i=[],a=nn(e,t.shape);let l=a;const c=ur(l,o);let d=t;c!=null&&(d=wi({inputs:{x:t},attrs:{perm:c},backend:s}),l=cr(l.length,o),i.push(d)),xs(r,l,o);const[f,p]=Fs(d.shape,l);let g=f;n&&(g=ys(f,a));let y;if((r==="max"||r==="prod")&&s.shouldExecuteOnCPU([d])){const x=s.tensorMap.get(d.dataId).values;switch(r){case"max":const w=Jxe(x,fe(p),g,t.dtype);y=s.makeTensorInfo(g,t.dtype,w);break;case"prod":const{outVals:S,outShape:$,outDtype:I}=ove(d.shape,d.dtype,x,l);y=s.makeTensorInfo($,I,S);break;default:throw new Error(`${r} CPU implementation is not yet supported.`)}}else{const x=fe(p),S=fe(d.shape)/x,$={windowSize:x,inSize:x,batchSize:S,outSize:1},I=Pve[r]||ly(t.dtype),R=[{type:"int32",data:[x]}],_=new _ve($,r,s.device.limits.maxComputeWorkgroupSizeX),F=s.runWebGPUProgram(_,[d],I,R);i.push(F),y=Be({inputs:{x:F},attrs:{shape:g},backend:s})}return i.forEach(x=>s.disposeData(x.dataId)),y}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ave(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{keepDims:o,axis:i}=r;return Ku(s,i,o,"all",n)}const Dve={kernelName:iw,backendName:"webgpu",kernelFunc:Ave};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fve(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{keepDims:o,axis:i}=r;return Ku(s,i,o,"any",n)}const Ove={kernelName:aw,backendName:"webgpu",kernelFunc:Fve};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bO{constructor(e,n,r){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const s=[n];this.op=r==="min"?"<":">";const[o,i]=Fs(e,s);this.outputShape=o.length===0?[1]:o,this.dispatchLayout=De(this.outputShape),fe(i)<32?(this.type="plain",this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=Re(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],n=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${oa(this.inputShape.length-1)}`,r=()=>{let s="";if(this.outputShape.length===1)this.inputShape.length!==1&&(s+="outputCoords,");else for(let o=0;o<this.outputShape.length;o++)s+=`outputCoords.${oa(o)},`;return s};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    `}

      ${Ee("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${n()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${r()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${r()} 0);
          let reduceLength = ${n()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${r()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lve(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o}=r;let i=nn(o,s.shape);const a=ur(i,s.shape.length);let l=s;const c=[];a!=null&&(l=wi({inputs:{x:s},backend:n,attrs:{perm:a}}),c.push(l),i=cr(i.length,l.shape.length)),xs("argMax",[i[0]],l.shape.length);const d=new bO(l.shape,i[0],"max"),f=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],p=n.runWebGPUProgram(d,[l],"int32",f);return c.forEach(g=>n.disposeData(g.dataId)),p}const zve={kernelName:lw,backendName:"webgpu",kernelFunc:Lve};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bve(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o}=r;let i=nn(o,s.shape);const a=ur(i,s.shape.length);let l=s;const c=[];a!=null&&(l=wi({inputs:{x:s},backend:n,attrs:{perm:a}}),c.push(l),i=cr(i.length,l.shape.length)),xs("argMin",[i[0]],l.shape.length);const d=new bO(l.shape,i[0],"min"),f=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],p=n.runWebGPUProgram(d,[l],"int32",f);return c.forEach(g=>n.disposeData(g.dataId)),p}const Mve={kernelName:uw,backendName:"webgpu",kernelFunc:Bve};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vve=$t({opType:Ne.ASIN}),Wve={kernelName:cw,backendName:"webgpu",kernelFunc:Vve};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uve=$t({opType:Ne.ASINH}),jve={kernelName:dw,backendName:"webgpu",kernelFunc:Uve};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gve=$t({opType:Ne.ATAN}),Hve={kernelName:hw,backendName:"webgpu",kernelFunc:Gve};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kve=zn({opType:et.ATAN2}),Xve={kernelName:pw,backendName:"webgpu",kernelFunc:Kve};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qve=$t({opType:Ne.ATANH}),Yve={kernelName:fw,backendName:"webgpu",kernelFunc:qve};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qve{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _f{constructor(e,n,r=!1,s=!1,o=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=n,this.computePositions=r,this.flattenPositions=s,this.includeBatchIndex=o,this.shaderKey=`pool2D_${n}_${r}_${s}_${o}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:e="resultValue = max(value, resultValue);";let n="resultValue";return this.poolType==="avg"&&(n="resultValue / max(count, 1.0)"),`
      ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${n});`}
        }
      }
    `}}class MC{constructor(e,n,r=!1,s=!1,o=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=n,this.computePositions=r,this.flattenPositions=s,this.includeBatchIndex=o,this.shaderKey=`pool3D_${n}_${r}_${s}_${o}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue += value; count += 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:e="resultValue = max(value, resultValue);";let n="resultValue";return this.poolType==="avg"&&(n="resultValue / max(count, 1.0)"),`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${n});`}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wO(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reductionIndices:o,keepDims:i}=r;return Ku(s,o,i,"max",n)}const Zve={kernelName:S2,backendName:"webgpu",kernelFunc:wO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SO(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{keepDims:o,axis:i}=r;return Ku(s,i,o,"mean",n)}const Jve={kernelName:I2,backendName:"webgpu",kernelFunc:SO};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CO(t,e,n,r){if(e.filterWidth===1&&e.filterHeight===1&&Mt(e.inShape,e.outShape))return ms({inputs:{x:t},backend:r});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&e.batchSize===1&&e.padInfo.type==="VALID"){const i=t.shape.length,a=Be({inputs:{x:t},backend:r,attrs:{shape:[t.shape[i-3]*t.shape[i-2],t.shape[i-1]]}});let l;n==="avg"?l=SO({inputs:{x:a},backend:r,attrs:{axis:0,keepDims:!1}}):(z(n==="max",()=>`Invalid pool type ${n}`),l=wO({inputs:{x:a},backend:r,attrs:{reductionIndices:0,keepDims:!1}}));const c=Be({inputs:{x:l},backend:r,attrs:{shape:e.outShape}});return r.disposeData(a.dataId),r.disposeData(l.dataId),c}let s;const o=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return e.filterHeight===1&&e.filterWidth===1?s=new Qve(e):(n==="avg"?s=new _f(e,"avg"):(z(n==="max",()=>`Invalid pool type ${n}`),s=new _f(e,"max")),o.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),r.runWebGPUProgram(s,[t],t.dtype,o)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ebe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r,d=ho(s.shape,o,i,1,a,l);return CO(s,d,"avg",n)}const tbe={kernelName:mw,backendName:"webgpu",kernelFunc:ebe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nbe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:i,pad:a,dataFormat:l,dimRoundingMode:c}=r,d=[1,1,1],f=ba(s.shape,o,i,d,a,c,l),p=new MC(f,"avg"),g=[{type:"int32",data:[f.strideDepth,f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.front,f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inDepth,f.inHeight,f.inWidth]},{type:"int32",data:[f.effectiveFilterDepth,f.effectiveFilterHeight,f.effectiveFilterWidth]}];return n.runWebGPUProgram(p,[s],s.dtype,g)}const rbe={kernelName:gw,backendName:"webgpu",kernelFunc:nbe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sbe{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class obe{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ibe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,i=o,{filterSize:a,strides:l,pad:c,dimRoundingMode:d}=r,f=ba(i.shape,a,l,1,c,d),p=new obe(f),g=1/(f.filterDepth*f.filterHeight*f.filterWidth),y=[{type:"int32",data:[f.strideDepth,f.strideHeight,f.strideWidth]},{type:"int32",data:[f.effectiveFilterDepth-1-f.padInfo.front,f.effectiveFilterHeight-1-f.padInfo.top,f.effectiveFilterWidth-1-f.padInfo.left]},{type:"int32",data:[f.effectiveFilterDepth,f.effectiveFilterHeight,f.effectiveFilterWidth]},{type:"int32",data:[f.outDepth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"float32",data:[g]}];return n.runWebGPUProgram(p,[s],i.dtype,y)}const abe={kernelName:YP,backendName:"webgpu",kernelFunc:ibe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lbe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,i=o;yO([s,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,d=ho(i.shape,a,l,1,c),f=new sbe(d),p=1/(d.filterHeight*d.filterWidth),g=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"float32",data:[p]}];return n.runWebGPUProgram(f,[s],i.dtype,g)}const ube={kernelName:qP,backendName:"webgpu",kernelFunc:lbe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cbe(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:o}=e,{transposeA:i,transposeB:a}=r;return Iy({a:s,b:o,transposeA:i,transposeB:a,backend:n})}const dbe={kernelName:yw,backendName:"webgpu",kernelFunc:cbe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hbe{constructor(e,n){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.rank=n.length,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${vn(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=vn(this.rank),n=fbe(this.rank);let r;return this.start.length===1?r=this.outputShape.map((o,i)=>"sourceLoc = uniforms.start + coords;"):r=this.outputShape.map((o,i)=>`sourceLoc.${Fv[i]} = uniforms.start.${oa(i)} + coords.${Fv[i]};`),`
      ${Ee("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${r.join(`
`)}
          setOutputAtIndex(index, getSource(${n}));
        }
      }
    `}}const Fv=["x","y","z","w","u","v"];function fbe(t){if(t===1)return"sourceLoc";if(t<=6)return Fv.slice(0,t).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ld(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:o,size:i}=r,[a,l]=oC(s,o,i);if(tC(s,a,l),n.shouldExecuteOnCPU([s])||s.dtype==="string"){const f=n.tensorMap.get(s.dataId),p=cve(f.values,a,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,p)}if(fe(l)===0)return n.makeTensorInfo(l,s.dtype,[]);const c=new hbe(a,l),d=[{type:"int32",data:a}];return n.runWebGPUProgram(c,[s],s.dtype,d)}const pbe={kernelName:aS,backendName:"webgpu",kernelFunc:Ld};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mbe=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:o,crops:i}=r;z(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const a=o.reduce(($,I)=>$*I),l=Qf(s.shape,o,a),c=Zf(l.length,o.length),d=Jf(s.shape,o,a),f=cC(i,o.length),p=dC(d,i,o.length),g=[],y=Be({inputs:{x:s},backend:n,attrs:{shape:l}}),x=wi({inputs:{x:y},backend:n,attrs:{perm:c}}),w=Be({inputs:{x},backend:n,attrs:{shape:d}}),S=Ld({inputs:{x:w},backend:n,attrs:{begin:f,size:p}});return g.push(y),g.push(x),g.push(w),g.forEach($=>n.disposeData($.dataId)),S},gbe={kernelName:xw,backendName:"webgpu",kernelFunc:mbe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ybe=`
  fn bincount_write(index: i32, value: f32) {
    ${Tl("&result[index]","value","float32")}
  }
`,xbe=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;class $O{constructor(e,n,r=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=r,r&&(this.atomic=!1),this.hasWeights=n,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?xbe:ybe}
  ${Ee("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vbe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:o}=e,{size:i}=r,a=fe(s.shape),c=fe(o.shape)>0,d=[i],f=o.dtype,p=Wr({backend:n,attrs:{shape:d,value:0,dtype:f}}),g=new $O([a],c),y=[{type:"int32",data:[i]}],x=c?[s,o]:[s];return n.runWebGPUProgram(g,x,f,y,p)}const bbe={kernelName:vw,backendName:"webgpu",kernelFunc:vbe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wbe{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${Ee("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sbe(t){const{inputs:e,backend:n}=t,{s0:r,s1:s}=e;if(n.shouldExecuteOnCPU([r,s])){const d=n.tensorMap.get(r.dataId),f=n.tensorMap.get(s.dataId),p=d.values,g=f.values,y=ct(Array.from(p),Array.from(g));return n.makeTensorInfo([y.length],"int32",Int32Array.from(y))}const o=fe(r.shape),i=fe(s.shape),a=Math.max(o,i),l=new wbe(a),c=[{type:"int32",data:[o]},{type:"int32",data:[i]}];return n.runWebGPUProgram(l,[r,s],"int32",c)}const Cbe={kernelName:bw,backendName:"webgpu",kernelFunc:Sbe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kO=zn({opType:et.NOT_EQUAL,dtype:"bool",cpuKernelImpl:sve}),$be={kernelName:F2,backendName:"webgpu",kernelFunc:kO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function op(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.tensorMap.get(r.dataId);return ms({inputs:{x:s.complexTensorInfos.real},backend:n})}const kbe={kernelName:H2,backendName:"webgpu",kernelFunc:op};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tbe(t,e){const n=new Od(t.shape,Ne.TO_INT),r=e.runWebGPUProgram(n,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ov(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dtype:o}=r;if(o==="complex64"){if(s.dtype==="complex64")return ms({inputs:{x:s},backend:n});const i=ma(s.shape),a=Ov({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),l=Hu({inputs:{real:a,imag:i},backend:n});return i.dispose(),n.disposeData(a.dataId),l}if(s.dtype==="complex64"){const i=op({inputs:{input:s},backend:n}),a=Ov({inputs:{x:i},backend:n,attrs:{dtype:o}});return n.disposeData(i.dataId),a}if(!jP(s.dtype,o)){const i=ms({inputs:{x:s},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:o}}if(n.shouldExecuteOnCPU([s])){const i=n.tensorMap.get(s.dataId).values,[a,l,c]=zxe(i,s.shape,s.dtype,o);return n.makeTensorInfo(a,l,c)}if(o==="int32")return Tbe(s,n);if(o==="bool"){const i=n.makeTensorInfo([],"bool",bi("bool",1)),l=kO({inputs:{a:s,b:i},backend:n});return n.disposeData(i.dataId),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}const Ibe={kernelName:ry,backendName:"webgpu",kernelFunc:Ov};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nbe=$t({opType:Ne.CEIL,cpuKernelImpl:Bxe}),Ebe={kernelName:ww,backendName:"webgpu",kernelFunc:Nbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rbe{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${Ee("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _be{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${Ee("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pbe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{clipValueMin:o,clipValueMax:i}=r;let a;const l=[{type:"float32",data:[o]},{type:"float32",data:[i]}];return fe(s.shape)%4===0?a=new Rbe(s.shape):a=new _be(s.shape),n.runWebGPUProgram(a,[s],s.dtype,l)}const Abe={kernelName:Sw,backendName:"webgpu",kernelFunc:Pbe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dbe{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DE(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}function Fbe(t){const{inputs:e,backend:n}=t,{x:r}=e,s=n.tensorMap.get(r.dataId),o=new Dbe(r.shape),i=[DE(r,s.complexTensorInfos.real),DE(r,s.complexTensorInfos.imag)];return n.runWebGPUProgram(o,i,i[0].dtype)}const Obe={kernelName:$w,backendName:"webgpu",kernelFunc:Fbe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lbe{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=co(e,1),this.variableNames=e.map((n,r)=>`T${r}`),this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let n=0;n<this.offsetLength;n++)this.uniforms+=`offset${n} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let o=1;o<this.offsetLength;o++)e.push(`else if (yC < uniforms.offset${[o]}){ setOutputAtCoords(coords.x, coords.y, getT${o}(yR, yC - uniforms.offset${o-1})); }`);const r=this.offsetLength,s=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${r}(yR, yC - uniforms.offset${s})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${Ee("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ny(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.tensorMap.get(r.dataId);return ms({inputs:{x:s.complexTensorInfos.imag},backend:n})}const zbe={kernelName:l2,backendName:"webgpu",kernelFunc:Ny};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bh(t,e,n){const r=t[0].dtype;if(r==="complex64"){const y=t.map(I=>op({inputs:{input:I},backend:n})),x=t.map(I=>Ny({inputs:{input:I},backend:n})),w=Bh(y,e,n),S=Bh(x,e,n),$=Hu({inputs:{real:w,imag:S},backend:n});return y.forEach(I=>n.disposeData(I.dataId)),x.forEach(I=>n.disposeData(I.dataId)),n.disposeData(w.dataId),n.disposeData(S.dataId),$}let s=n.shouldExecuteOnCPU(t);if(r==="string"&&(s=!0),s){const y=t.map(_=>{const O=[-1,fe(_.shape.slice(e))];return Be({inputs:{x:_},backend:n,attrs:{shape:O}})}),x=y.map(_=>({vals:n.readSync(_.dataId),shape:_.shape})),w=co(y.map(_=>_.shape),1),S=y[0].shape[0]===1,$=Mxe(x,w,r,S),I=co(t.map(_=>_.shape),e),R=n.makeTensorInfo(I,r,$);return y.forEach(_=>n.disposeData(_.dataId)),R}const o=n.device.limits.maxStorageBuffersPerShaderStage-1;if(t.length>o){const y=[];for(let w=0;w<t.length;w+=o){const S=t.slice(w,w+o);y.push(Bh(S,e,n))}const x=Bh(y,e,n);for(const w of y)n.disposeData(w.dataId);return x}const{tensors2D:i,outShape:a}=Bbe(t,e,n),l=i.map(y=>y.shape),c=new Lbe(l),d=[],f=new Array(l.length-1);if(f.length>0){f[0]=l[0][1],d.push({type:"int32",data:[f[0]]});for(let y=1;y<f.length;y++)f[y]=f[y-1]+l[y][1],d.push({type:"int32",data:[f[y]]})}const p=n.runWebGPUProgram(c,i,i[0].dtype,d);i.forEach(y=>n.disposeData(y.dataId));const g=Be({inputs:{x:p},backend:n,attrs:{shape:a}});return n.disposeData(p.dataId),g}function Bbe(t,e,n){const r=co(t.map(o=>o.shape),e);return{tensors2D:t.map(o=>Be({inputs:{x:o},backend:n,attrs:{shape:[fe(o.shape.slice(0,e)),fe(o.shape.slice(e))]}})),outShape:r}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TO(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r,o=nn(s,e[0].shape)[0],i=e.map(c=>c.shape);aC(i,o);const a=co(e.map(c=>c.shape),o);if(fe(a)===0)return n.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(c=>fe(c.shape)>0);return l.length===1?ms({inputs:{x:l[0]},backend:n}):Bh(l,o,n)}const Mbe={kernelName:kw,backendName:"webgpu",kernelFunc:TO};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vbe(t,e,n,r,s=!1,o=null,i=!1,a=4,l=4,c=4){const d=B=>{switch(B){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${B} is not supported.`)}},f=B=>{switch(B){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${B} is not supported.`)}},p=t?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,g=t?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,y=t?"uniforms.xShape[1]":"uniforms.xShape[2]",x=t?"uniforms.xShape[2]":"uniforms.xShape[3]",w=t?"row":"col",S=t?"col":"row",$=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${t?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${w} / outWidth;
      let outCol = ${w} % outWidth;

      let WRow = ${S} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${S} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${S} % inChannels;
      var resData = ${ut(a)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${y} && xCol >= 0 && xCol < ${x}) {
        ${p}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${d(a)}
      }
      return resData;`,I=t?e&&r?`
      ${$}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${$}
      }
      return ${ut(a)}(0.0);`:r&&n?`
      ${$}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${$}
      }
      return ${ut(a)}(0.0);`,R=`${f(l)}`,_=ut(c),F=ut(t?a:l),O=ut(t?l:a);return`
      ${$a(o,i,c===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${F} {
        ${t?I:R}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${O} {
        ${t?R:I}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${_}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${t?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${g}
        ${Gu(s,o)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}class Wbe{constructor(e,n,r,s,o=!1,i=null,a=!1,l=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=pO(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=mO(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),o&&(this.variableNames.push("bias"),this.variableComponents.push(4)),a&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],o&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=l,this.addBias=o,this.activation=i,this.hasPreluActivationWeights=a,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=n%this.tileAOuter===0,this.fitBOuter=r%this.tileBOuter===0,this.fitInner=s%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?ky(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):Ty(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),n=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${Vbe(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,n[0],n[1],n[2])}
    ${e}
  `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ube{constructor(e,n=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=n,this.activation=r,this.hasPreluActivationWeights=s,n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${$a(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${Gu(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${Ee("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jbe{constructor(e,n){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=n,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,n=this.isChannelsLast?2:3,r=this.isChannelsLast?"coords[1]":"coords[2]",s=this.isChannelsLast?"coords[2]":"coords[1]",o=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${Ee("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${r};
        let col = ${s};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${n}] && xCol >= 0) {
            value = ${o};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bg(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&n===1&&t[0]>1?[t[0],1]:null}function Gbe({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const l=n.dataFormat==="channelsLast",c=!l,d=!1,f=l&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&n.padInfo.type==="VALID",p=[];let g,y;if(f){const S=n.inHeight*n.inWidth*n.inChannels;g=Be({inputs:{x:t},backend:r,attrs:{shape:[1,n.batchSize,S]}}),y=Be({inputs:{x:e},backend:r,attrs:{shape:[1,S,n.outChannels]}})}else g=Be({inputs:{x:t},backend:r,attrs:{shape:l?[n.batchSize,n.inHeight*n.inWidth,n.inChannels]:[n.batchSize,n.inChannels,n.inHeight*n.inWidth]}}),y=Be({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});if(p.push(g),p.push(y),o!=null){const S=Bg(o.shape,l);S!=null&&(o=Be({inputs:{x:o},backend:r,attrs:{shape:S}}),p.push(o))}if(s!=null){const S=Bg(s.shape,l);S!=null&&(s=Be({inputs:{x:s},backend:r,attrs:{shape:S}}),p.push(s))}const x=Iy({a:l?g:y,b:l?y:g,transposeA:c,transposeB:d,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),w=Be({inputs:{x},backend:r,attrs:{shape:n.outShape}});p.push(x);for(const S of p)r.disposeData(S.dataId);return w}function Hbe({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:d,strideWidth:f,strideHeight:p,padInfo:g,outWidth:y,outHeight:x,dilationWidth:w,dilationHeight:S,dataFormat:$}=n,I=$==="channelsLast",R=l*c*d,_=x*y,F=I?[n.batchSize,_,R]:[n.batchSize,R,_],O=new jbe(F,I),M=[{type:"int32",data:[g.top,g.left]},{type:"int32",data:[p,f]},{type:"int32",data:[S,w]},{type:"int32",data:[y]},{type:"int32",data:[d*l]},{type:"int32",data:[d]}],B=r.runWebGPUProgram(O,[t],t.dtype,M),V=[];V.push(B);const A=Be({inputs:{x:e},backend:r,attrs:{shape:[1,R,-1]}});if(V.push(A),o!=null){const ve=Bg(o.shape,I);ve!=null&&(o=Be({inputs:{x:o},backend:r,attrs:{shape:ve}}),V.push(o))}if(s!=null){const ve=Bg(s.shape,I);ve!=null&&(s=Be({inputs:{x:s},backend:r,attrs:{shape:ve}}),V.push(s))}const pe=Iy({a:I?B:A,b:I?A:B,transposeA:!I,transposeB:!1,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),ye=Be({inputs:{x:pe},backend:r,attrs:{shape:n.outShape}});V.push(pe);for(const ve of V)r.disposeData(ve.dataId);return ye}function IO({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const l=s!=null,c=o!=null,d=n.dataFormat==="channelsLast",f=d&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&n.padInfo.type==="VALID",p=oe().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!p&&(f||n.filterHeight===1&&n.filterWidth===1&&n.dilationHeight===1&&n.dilationWidth===1&&n.strideHeight===1&&n.strideWidth===1&&(n.padInfo.type==="SAME"||n.padInfo.type==="VALID")))return Gbe({x:t,filter:e,convInfo:n,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i});const g=oe().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),y=g>-1?g:r.thresholdToIncreaseWorkgroups,x=n.batchSize*Math.ceil(n.outHeight*n.outWidth/32)*Math.ceil(n.outChannels/32);if(oe().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||x<=y)return Hbe({x:t,filter:e,convInfo:n,backend:r,bias:s,preluActivationWeights:o,leakyreluAlpha:i,activation:a});let w;const S=[n.padInfo.top,n.padInfo.left],$=[{type:"int32",data:[n.filterHeight,n.filterWidth]},{type:"int32",data:[...S]},{type:"int32",data:[n.strideHeight,n.strideWidth]},{type:"int32",data:[n.dilationHeight,n.dilationWidth]}];if(p)w=new Ube(n,l,a,c);else{const F=d?n.outHeight*n.outWidth:n.outChannels,O=d?n.outChannels:n.outHeight*n.outWidth,M=n.filterHeight*n.filterWidth*n.inChannels;$.push({type:"int32",data:[F]},{type:"int32",data:[O]},{type:"int32",data:[M]});const B=r.adapterInfo.isIntel();w=new Wbe(n,F,O,M,l,a,c,B)}const I=[],R=[t,e];l&&(!d&&s.shape.length===1&&(s=Be({inputs:{x:s},backend:r,attrs:{shape:[s.shape[0],1,1]}}),I.push(s)),R.push(s)),c&&(!d&&o.shape.length===1&&(o=Be({inputs:{x:o},backend:r,attrs:{shape:[o.shape[0],1,1]}}),I.push(o)),R.push(o)),a==="leakyrelu"&&($.push({type:"float32",data:[i]}),w.uniforms+=" alpha : f32,");const _=r.runWebGPUProgram(w,R,t.dtype,$);for(const F of I)r.disposeData(F.dataId);return _}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kbe(t){const{inputs:e,attrs:n,backend:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dataFormat:l,dilations:c,dimRoundingMode:d}=n,f=Bo(l),p=kn(s.shape,o.shape,i,c,a,d,!1,f);return IO({x:s,filter:o,convInfo:p,backend:r})}const Xbe={kernelName:Tw,backendName:"webgpu",kernelFunc:Kbe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qbe{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&e.outChannels%4===0&&e.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,n=this.isChannelsLast?2:3,r=this.isChannelsLast?3:1,s=`
    ${Ee()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${s}
    `:`
    ${Ee("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${r}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${n}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class Ybe{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${Ee("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class Qbe{constructor(e){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${Ee("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class Zbe{constructor(e){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${Ee("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jbe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:i,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:d}=r,f=Bo(l),p=kn(s.shape,d,i,1,a,c,!1,f),g=new Ybe(p),y=[{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.batchSize]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"int32",data:[p.inHeight]},{type:"int32",data:[p.inWidth]}];return n.runWebGPUProgram(g,[s,o],s.dtype,y)}const ewe={kernelName:Iw,backendName:"webgpu",kernelFunc:Jbe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function twe(t=4){const e=o=>{switch(o){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${o} is not supported.`)}},r=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${ut(t)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${ut(t)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${t}];`}
      }
      return ${ut(t)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${ut(t)} {
    ${r}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${ut(t)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(t)}
    }
    return ${ut(t)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${ut(t)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${t}] = value;
    }
  }`}class nwe{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,z(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=pO(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=mO(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?ky(this.elementsPerThread,this.workgroupSize):Ty(this.elementsPerThread,this.workgroupSize);return`
    ${twe(this.isVec4?4:1)}
    ${e}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rwe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{inputShape:i,strides:a,pad:l,dataFormat:c,dimRoundingMode:d}=r,f=Bo(c),p=kn(i,o.shape,a,1,l,d,!1,f),g=[{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.filterHeight-1-p.padInfo.top,p.filterWidth-1-p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.batchSize,p.outHeight,p.outWidth,p.outChannels]}];let y;if(oe().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||p.dataFormat!=="channelsLast")y=new qbe(p);else{y=new nwe(p);const x=p.inHeight*p.inWidth,w=p.inChannels,S=p.filterHeight*p.filterWidth*p.outChannels;g.push({type:"uint32",data:[x]},{type:"uint32",data:[w]},{type:"uint32",data:[S]})}return n.runWebGPUProgram(y,[s,o],"float32",g)}const swe={kernelName:Nw,backendName:"webgpu",kernelFunc:rwe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class owe{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iwe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dilations:l}=r,c=$l(s.shape,o.shape,i,l,a),d=[c.padInfo.front,c.padInfo.top,c.padInfo.left],f=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[...d]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationDepth,c.dilationHeight,c.dilationWidth]}],p=new owe(c),g=Ur(s.dtype,o.dtype);return n.runWebGPUProgram(p,[s,o],g,f)}const awe={kernelName:Ew,backendName:"webgpu",kernelFunc:iwe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lwe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:i,pad:a,filterShape:l}=r,c=$l(s.shape,l,i,1,a),d=new Qbe(c),f=[{type:"int32",data:[c.padInfo.front,c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.batchSize]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.inDepth]},{type:"int32",data:[c.inHeight]},{type:"int32",data:[c.inWidth]}];return n.runWebGPUProgram(d,[s,o],o.dtype,f)}const uwe={kernelName:ZP,backendName:"webgpu",kernelFunc:lwe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cwe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{strides:i,pad:a,inputShape:l}=r,c=$l(l,o.shape,i,1,a),d=new Zbe(c),f=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[c.filterDepth-1-c.padInfo.front,c.filterHeight-1-c.padInfo.top,c.filterWidth-1-c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.outChannels]}];return n.runWebGPUProgram(d,[s,o],s.dtype,f)}const dwe={kernelName:Rw,backendName:"webgpu",kernelFunc:cwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hwe=$t({opType:Ne.COS}),fwe={kernelName:_w,backendName:"webgpu",kernelFunc:hwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pwe=$t({opType:Ne.COSH}),mwe={kernelName:Pw,backendName:"webgpu",kernelFunc:pwe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gwe{constructor(e,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[o]=n;this.outputShape=[o,r[0],r[1],e],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=s==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,n]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[r,s,o]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[i,a,l]=this.cropWidthBiggerThan1?[`(${n} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${n} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${n}`];return`
    ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${r});
        let width_ratio = f32(${i});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${s};
        let width_scale = ${a};
        let in_y = ${o};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${l};
        if( in_x < 0.0 || in_x > ${n} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ywe=t=>{const{inputs:e,backend:n,attrs:r}=t,{image:s,boxes:o,boxInd:i}=e,{cropSize:a,method:l,extrapolationValue:c}=r,d=new gwe(s.shape[3],o.shape,a,l),f=[{type:"float32",data:[c]}];return n.runWebGPUProgram(d,[s,o,i],"float32",f)},xwe={kernelName:Fw,backendName:"webgpu",kernelFunc:ywe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Pf;(function(t){t.Prod="*",t.Sum="+"})(Pf||(Pf={}));class FE{constructor(e,n,r,s){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=n,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=r,this.reverse=s,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,n=this.op===Pf.Prod?"1.0":"0.0",r=this.exclusive?n:`getX(${OE(e,"coords",this.op)})`,s=this.outputShape[this.outputShape.length-1];let o="",i="";return this.exclusive?(o=this.reverse?`end != ${s-1}`:"end != 0",i=this.reverse?"end + 1":"end - 1"):(o=this.reverse?`end + pow2 < ${s}`:"end >= pow2",i=this.reverse?"end + pow2":"end - pow2"),`
      ${Ee("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${LE(e,"coords",this.op)};
         var val = ${r};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${o}) {
           let idx = ${i};
           ${LE(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${OE(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}}function OE(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.x, ${e}.y`;if(t===3)return`${e}.x, ${e}.y, ${e}.z`;if(t===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function LE(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.y`;if(t===3)return`${e}.z`;if(t===4)return`${e}.w`;throw Error(`Cumulative ${n} for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NO(t,e,n,r,s,o){const i=e.shape.length,a=ur([r],i);let l=e;a!=null&&(l=wi({inputs:{x:e},backend:n,attrs:{perm:a}}));const c=cr(1,i)[0];if(c!==i-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const d=l.shape[c];let f=ms({inputs:{x:l},backend:n});for(let p=0;p<=Math.ceil(Math.log2(d))-1;p++){const g=new FE(t,l.shape,!1,o),y=f,x=[{type:"float32",data:[p]}];f=n.runWebGPUProgram(g,[f],f.dtype,x),n.disposeData(y.dataId)}if(s){const p=new FE(t,l.shape,s,o),g=f,y=[{type:"float32",data:[0]}];f=n.runWebGPUProgram(p,[f],f.dtype,y),n.disposeData(g.dataId)}if(a!=null){const p=Yf(a),g=wi({inputs:{x:f},backend:n,attrs:{perm:p}});return n.disposeData(f.dataId),n.disposeData(l.dataId),g}return f}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vwe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,exclusive:i,reverse:a}=r;return NO(Pf.Prod,s,n,o,i,a)}const bwe={kernelName:Aw,backendName:"webgpu",kernelFunc:vwe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wwe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,exclusive:i,reverse:a}=r;return NO(Pf.Sum,s,n,o,i,a)}const Swe={kernelName:Dw,backendName:"webgpu",kernelFunc:wwe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cwe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:o}=e,{size:i,binaryOutput:a}=r,l=s.shape.length===1,d=fe(o.shape)>0,f=o.dtype,p=l?[s.shape[0]]:[s.shape[0],s.shape[1]],g=l?[i]:[s.shape[0],i],y=Wr({backend:n,attrs:{shape:g,value:0,dtype:f}}),x=new $O(p,d,a),w=[{type:"int32",data:[i]}],S=d?[s,o]:[s];return n.runWebGPUProgram(x,S,f,w,y)}const $we={kernelName:Ow,backendName:"webgpu",kernelFunc:Cwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kwe{constructor(e,n){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${n}`,this.dataFormat=n}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Twe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockSize:o,dataFormat:i}=r,a=s.shape[0],l=i==="NHWC"?s.shape[1]:s.shape[2],c=i==="NHWC"?s.shape[2]:s.shape[3],d=i==="NHWC"?s.shape[3]:s.shape[1],f=l*o,p=c*o,g=d/(o*o),y=i==="NHWC"?[a,f,p,g]:[a,g,f,p],x=[{type:"int32",data:[o]}],w=new kwe(y,i);return n.runWebGPUProgram(w,[s],s.dtype,x)}const Iwe={kernelName:Lw,backendName:"webgpu",kernelFunc:Twe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nwe{constructor(e,n,r,s=!1,o=null,i=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.addBias=s,this.activation=o,this.hasPreluActivation=i,this.filterHeight=n,this.filterWidth=r,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,n=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],r=this.workgroupSize[1]+this.filterHeight-1,s=this.workgroupSize[0]+this.filterWidth-1;return`
      ${$a(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${s}>, ${r}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${Ee()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${s}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e<n?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${n})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${Gu(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EO{constructor(e,n=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const o=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=De(o),this.dispatch=Re(this.dispatchLayout,o,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),z(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=n,this.activation=r,this.hasPreluActivation=s,this.shaderKey=`depthwiseVec4_${r}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,n=this.convInfo.strideHeight,r=this.convInfo.strideWidth;return`
      ${$a(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${Ee("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${n}, ${r}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${r} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${Gu(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RO{constructor(e,n=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=n,this.activation=r,this.hasPreluActivation=s,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${$a(this.activation,this.hasPreluActivation,!1,4)}

      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${Gu(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ewe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dataFormat:l,dilations:c,dimRoundingMode:d}=r,f=Bo(l);let p=c;p==null&&(p=[1,1]);const g=kn(s.shape,o.shape,i,p,a,d,!0,f),y=[{type:"int32",data:[g.padInfo.top,g.padInfo.left]},{type:"int32",data:[g.inHeight,g.inWidth]}],x=g.dataFormat==="channelsLast";let w;return!x&&g.inHeight>16&&g.inWidth>16&&g.strideHeight===1&&g.strideWidth===1&&g.dilationWidth===1&&g.dilationHeight===1&&g.inChannels===g.outChannels?w=new Nwe(g.outShape,g.filterHeight,g.filterWidth):x&&g.outHeight>4&&g.outWidth>4&&g.strideWidth<=2&&g.inChannels===g.outChannels&&g.dilationHeight===1&&g.dilationWidth===1&&g.inChannels%4===0?(w=new EO(g),y.push({type:"int32",data:[w.virtualWidth]})):(w=new RO(g),y.push({type:"int32",data:[g.filterHeight]},{type:"int32",data:[g.filterWidth]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]})),n.runWebGPUProgram(w,[s,o],s.dtype,y)}const Rwe={kernelName:zw,backendName:"webgpu",kernelFunc:Ewe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _we{constructor(e){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class Pwe{constructor(e){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Awe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:o}=e,{strides:i,dilations:a,pad:l,dimRoundingMode:c,filterShape:d}=r,f=kn(s.shape,d,i,a,l,c,!0),p=new _we(f),g=[{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"int32",data:[f.inHeight]},{type:"int32",data:[f.inWidth]},{type:"int32",data:[f.batchSize]},{type:"int32",data:[f.outChannels/f.inChannels]}];return n.runWebGPUProgram(p,[s,o],"float32",g)}const Dwe={kernelName:Bw,backendName:"webgpu",kernelFunc:Awe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fwe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:o}=e,{strides:i,dilations:a,pad:l,dimRoundingMode:c,inputShape:d}=r,f=kn(d,o.shape,i,a,l,c,!0),p=new Pwe(f),g=[{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.filterHeight-1-f.padInfo.top,f.filterWidth-1-f.padInfo.left]},{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"int32",data:[f.outChannels/f.inChannels]}];return n.runWebGPUProgram(p,[s,o],s.dtype,g)}const Owe={kernelName:Mw,backendName:"webgpu",kernelFunc:Fwe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lwe{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zwe(t){const{inputs:e,backend:n}=t,{x:r}=e,s=[...r.shape,...r.shape],o=fe(r.shape),i=Be({inputs:{x:r},backend:n,attrs:{shape:[o]}}),a=new Lwe(o),l=n.runWebGPUProgram(a,[i],i.dtype),c=Be({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeData(i.dataId),n.disposeData(l.dataId),c}const Bwe={kernelName:Vw,backendName:"webgpu",kernelFunc:zwe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mwe{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${Ee("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vwe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o}=e,{strides:i,pad:a,dilations:l}=r,c=Xf(s.shape,o.shape,i,a,"NHWC",l),d=[c.padInfo.top,c.padInfo.left],f=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[...d]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]}],p=new Mwe(c);return n.runWebGPUProgram(p,[s,o],s.dtype,f)}const Wwe={kernelName:Ww,backendName:"webgpu",kernelFunc:Vwe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uwe{constructor(e,n){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=De(e.outShape),this.dispatch=Re(this.dispatchLayout,e.outShape,this.workgroupSize),n!=="float32"&&n!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${n} type.`);this.type=n,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${Ee("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${Tl("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}class jwe{constructor(e,n,r){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=De(e.outShape),this.dispatch=Re(this.dispatchLayout,e.outShape,this.workgroupSize),r!=="float32"&&r!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${r} type.`);this.type=r,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${Ee("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${Tl("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gwe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,dy:i}=e,{strides:a,pad:l,dilations:c}=r,d=Xf(s.shape,o.shape,a,l,"NHWC",c),f=o.dtype,p=new jwe(d,o.shape,f),g=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[fe(d.outShape)]}],y=Wr({backend:n,attrs:{shape:o.shape,value:0,dtype:f}});return n.runWebGPUProgram(p,[s,o,i],f,g,y)}const Hwe={kernelName:aX,backendName:"webgpu",kernelFunc:Gwe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kwe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,dy:i}=e,{strides:a,pad:l,dilations:c}=r,d=Xf(s.shape,o.shape,a,l,"NHWC",c),f=s.dtype,p=new Uwe(d,f),g=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[fe(d.outShape)]}],y=Wr({backend:n,attrs:{shape:d.inShape,value:0,dtype:f}});return n.runWebGPUProgram(p,[s,o,i],f,g,y)}const Xwe={kernelName:iX,backendName:"webgpu",kernelFunc:Kwe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qwe{constructor(e,n,r){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=pd.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=n,this.textureFormat=r,this.shaderKey=`draw_${n}_${r}`}getUserCode(){let e;const n=this.type==="float32"?"value":"value / 255.0";return e=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${n};
        rgba[1] = ${n};
        rgba[2] = ${n};
      } else {
        rgba[d] = ${n};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${Ee("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ywe(t){const{inputs:e,backend:n,attrs:r}=t,{image:s}=e,{canvas:o,options:i}=r,[a,l]=s.shape.slice(0,2),{imageOptions:c}=i||{},d=(c==null?void 0:c.alpha)||1,f=n.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",p=[a,l],g=new qwe(p,s.dtype,f);o.width=l,o.height=a;const y="webgpu";let x=o.getContext(y),w;x||(w=new OffscreenCanvas(l,a),x=w.getContext(y));const S=s.shape.length===3?s.shape[2]:1;x.configure({device:n.device,format:f,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const $="int32",I=n.makeTensorInfo(p,$),R=n.tensorMap.get(I.dataId);R.resource=x.getCurrentTexture(),R.external=!0;const _=[{type:"uint32",data:[S]},{type:"float32",data:[d]}];if(n.runWebGPUProgram(g,[s],$,_,I),w){const F=o.getContext("2d");if(!F)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");F.drawImage(w,0,0)}return n.disposeData(I.dataId),s}const Qwe={kernelName:JP,backendName:"webgpu",kernelFunc:Ywe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _O=zn({opType:et.MUL,cpuKernelImpl:nve,supportsComplex:!0}),Zwe={kernelName:A2,backendName:"webgpu",kernelFunc:_O};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PO(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r;return Ku(s,o,i,"sum",n)}const Jwe={kernelName:pS,backendName:"webgpu",kernelFunc:PO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e2e(t){const{inputs:e,backend:n,attrs:r}=t,{equation:s}=r,o=e,{allDims:i,summedDims:a,idDims:l}=bC(s,o.length);SC(i.length,l,o);const{path:c,steps:d}=CC(a,l),f=d.length;let p=null,g=i.length;const y=[];for(let x=0;x<f;++x){for(const w of d[x]){const{permutationIndices:S,expandDims:$}=wC(g,l[w]);let I;$C(S)?I=o[w]:(I=wi({inputs:{x:o[w]},backend:n,attrs:{perm:S}}),y.push(I));const R=I.shape.slice();for(let _=0;_<$.length;++_)R.splice($[_],0,1);Mt(I.shape,R)||(I=Be({inputs:{x:I},backend:n,attrs:{shape:R}}),y.push(I)),p===null?p=I:(p=_O({inputs:{a:I,b:p},backend:n}),y.push(p))}x<f-1&&(c[x]>=0&&(p=PO({inputs:{x:p},backend:n,attrs:{axis:c[x]-(i.length-g),keepDims:!1}}),y.push(p)),g--)}for(const x of y)x!==p&&n.disposeData(x.dataId);return p}const t2e={kernelName:jw,backendName:"webgpu",kernelFunc:e2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n2e=$t({opType:Ne.ELU}),r2e={kernelName:Gw,backendName:"webgpu",kernelFunc:n2e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s2e=t=>{const{inputs:e,backend:n}=t,{dy:r,y:s}=e,o=new zg(et.ELU_DER,r.shape,s.shape);return n.runWebGPUProgram(o,[r,s],r.dtype)},o2e={kernelName:eA,backendName:"webgpu",kernelFunc:s2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i2e=zn({opType:et.EQUAL,dtype:"bool",cpuKernelImpl:Vxe}),a2e={kernelName:Kw,backendName:"webgpu",kernelFunc:i2e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l2e=$t({opType:Ne.ERF}),u2e={kernelName:Hw,backendName:"webgpu",kernelFunc:l2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c2e=$t({opType:Ne.EXP,cpuKernelImpl:Wxe,dtype:"float32"}),d2e={kernelName:Xw,backendName:"webgpu",kernelFunc:c2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lv(t){const{inputs:e,attrs:n,backend:r}=t,{dim:s}=n,{input:o}=e,i=o.shape.length,a=o.shape.slice();let l=s;return s<0&&(z(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),a.splice(l,0,1),Be({inputs:{x:o},backend:r,attrs:{shape:a}})}const h2e={kernelName:qw,backendName:"webgpu",kernelFunc:Lv};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f2e=$t({opType:Ne.EXPM1,cpuKernelImpl:Uxe}),p2e={kernelName:Yw,backendName:"webgpu",kernelFunc:f2e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zE{constructor(e,n){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AO(t,e,n){const r=n.tensorMap.get(t.dataId),s=fe(t.shape),o=t.shape[t.shape.length-1],i=s/o,a=[],l=Be({inputs:{x:t},backend:n,attrs:{shape:[i,o]}});a.push(l);const c=l.shape,d=new zE("real",c),f=new zE("imag",c),p=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:c},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:c}],g=e?2*Math.PI:-2*Math.PI,y=e?c[1]:1,x=[{type:"float32",data:[g]},{type:"float32",data:[y]}],w=n.runWebGPUProgram(d,p,"float32",x);a.push(w);const S=n.runWebGPUProgram(f,p,"float32",x);a.push(S);const $=Hu({inputs:{real:w,imag:S},backend:n});a.push($);const I=Be({inputs:{x:$},backend:n,attrs:{shape:t.shape}});return a.forEach(R=>n.disposeData(R.dataId)),I}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m2e(t){const{inputs:e,backend:n}=t,{input:r}=e;return AO(r,!1,n)}const g2e={kernelName:Qw,backendName:"webgpu",kernelFunc:m2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class y2e{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x2e={kernelName:Jw,backendName:"webgpu",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,r=e,s=new y2e(n.shape);return r.runWebGPUProgram(s,[n],n.dtype)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v2e=$t({opType:Ne.FLOOR,cpuKernelImpl:jxe}),b2e={kernelName:e2,backendName:"webgpu",kernelFunc:v2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w2e=zn({opType:et.FLOOR_DIV,cpuKernelImpl:Gxe,dtype:"int32"}),S2e={kernelName:t2,backendName:"webgpu",kernelFunc:w2e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class C2e{constructor(e,n,r=!1){this.pixelsOpType=pd.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[n,1,1]),this.importVideo=r,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${Ee("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $2e={kernelName:bg,backendName:"webgpu",kernelFunc:k2e};let Tc,ox=oe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function k2e(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:s}=e;const{numChannels:o}=r;if(s==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,l=typeof HTMLCanvasElement<"u"&&s instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&s instanceof OffscreenCanvas,c=typeof ImageBitmap<"u"&&s instanceof ImageBitmap,[d,f]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],p=[f,d,o],g=oe().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&i,y=i||a;if(c||l||y){let $;if(g)$=n.device.importExternalTexture({source:s});else{if(y){const ae=oe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Tc==null||ae!==ox)&&(ox=ae,Tc=document.createElement("canvas").getContext("2d",{willReadFrequently:ox})),Tc.canvas.width=d,Tc.canvas.height=f,Tc.drawImage(s,0,0,d,f),s=Tc.canvas}const V=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,re=n.textureManager.acquireTexture(p[1],p[0],"rgba8unorm",V);n.queue.copyExternalImageToTexture({source:s},{texture:re},[p[1],p[0]]),$=re}const I=fe(p),R=mn(p),_=new C2e(p,o,g),F=[{type:"uint32",data:[I]},{type:"uint32",data:[o]},{type:"uint32",data:[...R]}],O=n.makeTensorInfo([f,d],"int32"),M=n.tensorMap.get(O.dataId);M.resource=$;const B=n.runWebGPUProgram(_,[O],"int32",F);return n.disposeData(O.dataId),B}const x=s.data;let w=x;if(o!=null&&o!==4){w=new Uint8Array(s.width*s.height*o);const $=x.length;let I=0;for(let R=0;R<$;R++)R%4<o&&(w[I++]=x[R])}const S=n.makeTensorInfo(p,"int32",new Int32Array(w));return n.uploadToGPU(S.dataId),S}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class T2e{constructor(e,n,r,s,o){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],ct(e,n),ct(e,r),this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),s!=null&&(ct(e,s),this.variableNames.push("offset")),o!=null&&(ct(e,o),this.variableNames.push("scale")),this.offsetShape=s,this.scaleShape=o,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetByOutputIndex(index)");let n="1.0";return this.scaleShape!=null&&(n="getScaleByOutputIndex(index)"),`
      ${Ee("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${n};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I2e={kernelName:n2,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r,scale:s,offset:o,mean:i,variance:a}=t,{varianceEpsilon:l}=e,c=n,d=[r,i,a];let f=null;o!=null&&(f=o.shape,d.push(o));let p=null;s!=null&&(p=s.shape,d.push(s));const g=new T2e(r.shape,i.shape,a.shape,f,p),y=[{type:"float32",data:[l]}];return c.runWebGPUProgram(g,d,r.dtype,y)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N2e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:d,dilations:f,dimRoundingMode:p,activation:g,leakyreluAlpha:y}=r,x=Bo(d),w=kn(s.shape,o.shape,l,f,c,p,!1,x);return IO({x:s,filter:o,convInfo:w,backend:n,bias:i,preluActivationWeights:a,leakyreluAlpha:y,activation:g})}const E2e={kernelName:Sg,backendName:"webgpu",kernelFunc:N2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R2e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=e,{strides:l,pad:c,dilations:d,dimRoundingMode:f,activation:p,leakyreluAlpha:g}=r;let y=d;y==null&&(y=[1,1]),z(Er(l,y),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${y}'`);const x=kn(s.shape,o.shape,l,y,c,f,!0),w=[s,o],S=i!=null,$=a!=null;S&&w.push(i),$&&w.push(a);const I=[{type:"int32",data:[x.padInfo.top,x.padInfo.left]},{type:"int32",data:[x.inHeight,x.inWidth]}];let R;return x.outHeight>4&&x.outWidth>4&&x.strideWidth<=2&&x.inChannels===x.outChannels&&x.dilationHeight===1&&x.dilationWidth===1&&x.inChannels%4===0?(R=new EO(x,S,p,$),I.push({type:"int32",data:[R.virtualWidth]})):(R=new RO(x,S,p,$),I.push({type:"int32",data:[x.filterHeight]},{type:"int32",data:[x.filterWidth]},{type:"int32",data:[x.strideHeight,x.strideWidth]},{type:"int32",data:[x.dilationHeight,x.dilationWidth]})),p==="leakyrelu"&&(I.push({type:"float32",data:[g]}),R.uniforms+=" alpha : f32,"),n.runWebGPUProgram(R,w,"float32",I)}const _2e={kernelName:Cg,backendName:"webgpu",kernelFunc:R2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class P2e{constructor(e,n){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${vn(e)},`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A2e(t){const{inputs:e,backend:n}=t,{params:r,indices:s}=e,o=s.shape,i=o[o.length-1],a=fe(r.shape),[l,c,d,f]=eC(r,s),p=Be({inputs:{x:s},backend:n,attrs:{shape:[c,i]}}),g=Be({inputs:{x:r},backend:n,attrs:{shape:[fe(r.shape)/d,d]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const $=n.readSync(s.dataId),I=n.bufferSync(r),R=Hxe($,I,r.dtype,c,i,d,f,r.shape,a);return n.makeTensorInfo(l,r.dtype,R.values)}const y=new P2e(i,[c,d]),x=[{type:"int32",data:[i]},{type:"int32",data:f}],w=n.runWebGPUProgram(y,[g,p],g.dtype,x),S=Be({inputs:{x:w},backend:n,attrs:{shape:l}});return n.disposeData(p.dataId),n.disposeData(g.dataId),n.disposeData(w.dataId),S}const D2e={kernelName:s2,backendName:"webgpu",kernelFunc:A2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F2e{constructor(e,n){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=n,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=O2e(this.aShape);return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `}}function O2e(t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<t.length;r++)r===2?n.push("indexZ"):n.push(`${e[r]}`);return n.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DO(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,indices:o}=e,{axis:i,batchDims:a}=r,l=nn(i,s.shape)[0],c=IC(s,o,l,a),d=fe(o.shape),f=[],p=Be({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),g=Be({inputs:{x:o},backend:n,attrs:{shape:[c.batchSize,d/c.batchSize]}});f.push(p),f.push(g);const y=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([s,o])){const I=n.tensorMap.get(g.dataId).values,R=Vt(g.shape,g.dtype,I),F=n.tensorMap.get(p.dataId).values,O=Vt(p.shape,p.dtype,F),M=Kxe(O,R,y);return f.forEach(B=>n.disposeData(B.dataId)),n.makeTensorInfo(c.outputShape,M.dtype,M.values)}const x=new F2e(p.shape,y),w=n.runWebGPUProgram(x,[p,g],p.dtype);f.push(w);const S=Be({inputs:{x:w},backend:n,attrs:{shape:c.outputShape}});return f.forEach($=>n.disposeData($.dataId)),S}const L2e={kernelName:r2,backendName:"webgpu",kernelFunc:DO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z2e=zn({opType:et.GREATER,cpuKernelImpl:qxe,dtype:"bool"}),B2e={kernelName:o2,backendName:"webgpu",kernelFunc:z2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M2e=zn({opType:et.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:Xxe}),V2e={kernelName:i2,backendName:"webgpu",kernelFunc:M2e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W2e(t){const{inputs:e,backend:n}=t,{input:r}=e;return AO(r,!0,n)}const U2e={kernelName:a2,backendName:"webgpu",kernelFunc:W2e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j2e=$t({opType:Ne.IS_FINITE,dtype:"bool"}),G2e={kernelName:u2,backendName:"webgpu",kernelFunc:j2e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H2e=$t({opType:Ne.IS_INF,dtype:"bool"}),K2e={kernelName:c2,backendName:"webgpu",kernelFunc:H2e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X2e=$t({opType:Ne.IS_NAN,dtype:"bool"}),q2e={kernelName:d2,backendName:"webgpu",kernelFunc:X2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y2e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{alpha:o}=r,i=[{type:"float32",data:[o]}],a=new Od(s.shape,Ne.LEAKYRELU,"alpha : f32,");return n.runWebGPUProgram(a,[s],"float32",i)}const Q2e={kernelName:h2,backendName:"webgpu",kernelFunc:Y2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z2e=zn({opType:et.LESS,dtype:"bool",cpuKernelImpl:Qxe}),J2e={kernelName:f2,backendName:"webgpu",kernelFunc:Z2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eSe=zn({opType:et.LESS_EQUAL,dtype:"bool",cpuKernelImpl:Yxe}),tSe={kernelName:p2,backendName:"webgpu",kernelFunc:eSe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nSe{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rSe(t){const{backend:e,attrs:n}=t,{start:r,stop:s,num:o}=n,i=(s-r)/(o-1),a=new nSe(o),l=[{type:"float32",data:[r]},{type:"float32",data:[i]}];return e.runWebGPUProgram(a,[],"float32",l)}const sSe={kernelName:m2,backendName:"webgpu",kernelFunc:rSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oSe=$t({opType:Ne.LOG,cpuKernelImpl:Zxe}),iSe={kernelName:g2,backendName:"webgpu",kernelFunc:oSe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aSe=$t({opType:Ne.LOG1P}),lSe={kernelName:y2,backendName:"webgpu",kernelFunc:aSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uSe=zn({opType:et.LOGICAL_AND,dtype:"bool"}),cSe={kernelName:x2,backendName:"webgpu",kernelFunc:uSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dSe=$t({opType:Ne.LOGICAL_NOT}),hSe={kernelName:v2,backendName:"webgpu",kernelFunc:dSe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fSe=zn({opType:et.LOGICAL_OR}),pSe={kernelName:b2,backendName:"webgpu",kernelFunc:fSe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FO=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;class mSe{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${FO}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}}class gSe{constructor(e,n){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,z(n<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${n}`),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Re(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${Ee()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${FO}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ySe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{depthRadius:o,bias:i,alpha:a,beta:l}=r;let c;o>16?c=new mSe(s.shape):c=new gSe(s.shape,o);const d=[{type:"int32",data:[o]},{type:"float32",data:[i]},{type:"float32",data:[a]},{type:"float32",data:[l]}];return n.runWebGPUProgram(c,[s],s.dtype,d)}const xSe={kernelName:w2,backendName:"webgpu",kernelFunc:ySe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vSe{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bSe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,y:o,dy:i}=e,{depthRadius:a,bias:l,alpha:c,beta:d}=r,f=new vSe(s.shape),p=[{type:"int32",data:[a]},{type:"float32",data:[l]},{type:"float32",data:[c]},{type:"float32",data:[d]}];return n.runWebGPUProgram(f,[s,o,i],s.dtype,p)}const wSe={kernelName:tA,backendName:"webgpu",kernelFunc:bSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SSe=zn({opType:et.MAX,cpuKernelImpl:eve}),CSe={kernelName:C2,backendName:"webgpu",kernelFunc:SSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Se(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r,d=ho(s.shape,o,i,1,a,l);return CO(s,d,"max",n)}const kSe={kernelName:$2,backendName:"webgpu",kernelFunc:$Se};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TSe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:o,strides:i,pad:a,dataFormat:l,dimRoundingMode:c}=r,d=[1,1,1],f=ba(s.shape,o,i,d,a,c,l),p=new MC(f,"max"),g=[{type:"int32",data:[f.strideDepth,f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.front,f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inDepth,f.inHeight,f.inWidth]},{type:"int32",data:[f.effectiveFilterDepth,f.effectiveFilterHeight,f.effectiveFilterWidth]}];return n.runWebGPUProgram(p,[s],s.dtype,g)}const ISe={kernelName:k2,backendName:"webgpu",kernelFunc:TSe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NSe{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class ESe{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RSe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o}=e,i=o,{filterSize:a,strides:l,pad:c,dimRoundingMode:d}=r,f=[1,1,1],p=ba(i.shape,a,l,f,c,d),g=new MC(p,"max",!0);let y=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.front,p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inDepth,p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]}];const x=n.runWebGPUProgram(g,[i],"int32",y),w=new ESe(p);y=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.effectiveFilterDepth-1-p.padInfo.front,p.effectiveFilterHeight-1-p.padInfo.top,p.effectiveFilterWidth-1-p.padInfo.left]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]},{type:"int32",data:[p.outDepth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]}];const S=n.runWebGPUProgram(w,[s,x],i.dtype,y);return n.disposeData(x.dataId),S}const _Se={kernelName:rA,backendName:"webgpu",kernelFunc:RSe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PSe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:o,output:i}=e,a=o;yO([o,i],"maxPoolGrad");const{filterSize:l,strides:c,pad:d,dimRoundingMode:f}=r,p=ho(a.shape,l,c,1,d,f),g=new _f(p,"max",!0);let y=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]}];const x=n.runWebGPUProgram(g,[a],"int32",y),w=new NSe(p);y=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.effectiveFilterHeight-1-p.padInfo.top,p.effectiveFilterWidth-1-p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]}];const S=n.runWebGPUProgram(w,[s,x],a.dtype,y);return n.disposeData(x.dataId),S}const ASe={kernelName:nA,backendName:"webgpu",kernelFunc:PSe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DSe(t){const{inputs:e,backend:n,attrs:r}=t,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=r,{x:l}=e;z(l.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${l.shape.length}.`);const c=[1,1];z(Er(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const d=ho(l.shape,s,o,c,i),f=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]}];let p=new _f(d,"max",!1);const g=n.runWebGPUProgram(p,[l],l.dtype,f);p=new _f(d,"max",!0,!0,a);const y=n.runWebGPUProgram(p,[l],"int32",f);return[g,y]}const FSe={kernelName:T2,backendName:"webgpu",kernelFunc:DSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OSe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r;return Ku(s,o,i,"min",n)}const LSe={kernelName:N2,backendName:"webgpu",kernelFunc:OSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zSe=zn({opType:et.MIN,cpuKernelImpl:tve}),BSe={kernelName:E2,backendName:"webgpu",kernelFunc:zSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MSe{constructor(e,n,r){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n.map((s,o)=>s[0]+e[o]+s[1]),this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,n.map((s,o)=>{this.uniforms+=` pad${o} : vec2<i32>,`}),this.offset=r==="reflect"?0:1,this.shaderKey=`mirrorPad_${r}`}getUserCode(){const e=this.xShape.length,n=this.xShape.map((c,d)=>`uniforms.pad${d}[0]`).join(","),r=this.xShape.map((c,d)=>`uniforms.pad${d}[0] + uniforms.xShape${e>1?`[${d}]`:""}`).join(","),s=e===1?"start":"start[i]",o=e===1?"end":"end[i]",i=e===1?"outC":"outC[i]",a=vn(e),l=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let start = ${a}(${n});
          let end = ${a}(${r});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${i} < ${s}) {
              ${i} = ${s} * 2 - ${i} - ${this.offset};
            } else if(${i} >= ${o}) {
              ${i} = (${o} - 1) * 2 - ${i} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VSe={kernelName:R2,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{paddings:s,mode:o}=e,i=n,a=s.map(d=>({type:"int32",data:[d[0],d[1]]})),l=new MSe(r.shape,s,o);return i.runWebGPUProgram(l,[r],r.dtype,a)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WSe=zn({opType:et.MOD}),USe={kernelName:_2,backendName:"webgpu",kernelFunc:WSe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jSe{constructor(e,n){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,n],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Ee("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GSe{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${Ee("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OO(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{dim:o}=r,i=Be({inputs:{x:s},backend:n,attrs:{shape:[fe(s.shape)/s.shape[o],s.shape[o]]}}),a=new GSe(i.shape),l=n.runWebGPUProgram(a,[i],s.dtype),c=Be({inputs:{x:l},backend:n,attrs:{shape:s.shape}});return n.disposeData(i.dataId),n.disposeData(l.dataId),c}const HSe={kernelName:yS,backendName:"webgpu",kernelFunc:OO};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KSe(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{numSamples:o,seed:i,normalized:a}=r,l=a?s:OO({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),c=l.shape[0],d=l.shape[1],f=new jSe(c,o),p=[{type:"float32",data:[i]},{type:"int32",data:[d]}],g=n.runWebGPUProgram(f,[l],"int32",p);return a||n.disposeData(l.dataId),g}const XSe={kernelName:P2,backendName:"webgpu",kernelFunc:KSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qSe(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])){const o=n.tensorMap.get(r.dataId),[i,a]=rve(o.values,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,i)}const s=new Od(r.shape,Ne.NEG);return n.runWebGPUProgram(s,[r],r.dtype)}const YSe={kernelName:D2,backendName:"webgpu",kernelFunc:qSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QSe(t){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r,c=n.readSync(s.dataId),d=n.readSync(o.dataId),{selectedIndices:f}=XS(c,d,i,a,l);return n.makeTensorInfo([f.length],"int32",new Int32Array(f))}const ZSe={kernelName:O2,backendName:"webgpu",kernelFunc:QSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JSe(t){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r,d=n.readSync(s.dataId),f=n.readSync(o.dataId),p=i,g=a,y=l,x=c,{selectedIndices:w,selectedScores:S}=qS(d,f,p,g,y,x);return[n.makeTensorInfo([w.length],"int32",new Int32Array(w)),n.makeTensorInfo([S.length],"float32",new Float32Array(S))]}const eCe={kernelName:L2,backendName:"webgpu",kernelFunc:JSe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tCe{constructor(e,n){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,n],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${Ee("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nCe(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s}=e,{dtype:o,depth:i,onValue:a,offValue:l}=r,c=fe(s.shape),d=new tCe(c,i),f=Be({inputs:{x:s},backend:n,attrs:{shape:[c]}}),p=[{type:"float32",data:[a]},{type:"float32",data:[l]}],g=n.runWebGPUProgram(d,[f],o,p);n.disposeData(f.dataId);const y=[...s.shape,i],x=Be({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeData(g.dataId),x}const rCe={kernelName:B2,backendName:"webgpu",kernelFunc:nCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mg(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="complex64"){const s=op({inputs:{input:r},backend:n}),o=Mg({inputs:{x:s},backend:n}),i=Ny({inputs:{input:r},backend:n}),a=Mg({inputs:{x:i},backend:n}),l=Hu({inputs:{real:o,imag:a},backend:n});return n.disposeData(s.dataId),n.disposeData(o.dataId),n.disposeData(i.dataId),n.disposeData(a.dataId),l}else return Wr({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}const sCe={kernelName:_S,backendName:"webgpu",kernelFunc:Mg};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LO(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=op({inputs:{input:r},backend:n}),o=LO({inputs:{x:s},backend:n}),i=Ny({inputs:{input:r},backend:n}),a=Mg({inputs:{x:i},backend:n}),l=Hu({inputs:{real:o,imag:a},backend:n});return n.disposeData(s.dataId),n.disposeData(o.dataId),n.disposeData(i.dataId),n.disposeData(a.dataId),l}else return Wr({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}const oCe={kernelName:z2,backendName:"webgpu",kernelFunc:LO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iCe(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r;if(e.length===1)return Lv({inputs:{input:e[0]},backend:n,attrs:{dim:s}});const o=e[0].shape,i=e[0].dtype;e.forEach(d=>{gs(o,d.shape,"All tensors passed to stack must have matching shapes"),z(i===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(d=>{const f=Lv({inputs:{input:d},backend:n,attrs:{dim:s}});return a.push(f),f}),c=TO({inputs:l,backend:n,attrs:{axis:s}});return a.forEach(d=>n.disposeData(d.dataId)),c}const aCe={kernelName:M2,backendName:"webgpu",kernelFunc:iCe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zO(t,e=!1){const n=t.length,r=vn(n),s=t.map((f,p)=>`uniforms.pad${p}[0]`).join(","),o=t.map((f,p)=>`uniforms.pad${p}[0] + uniforms.xShape${n>1?`[${p}]`:""}`).join(","),i=n>1?`${r}(${s})`:`${s}`,a=n>1?`${r}(${o})`:`${o}`,l=n>1?"any(paddedCoords < start)":"paddedCoords < start",c=n>1?"any(paddedCoords >= end)":"paddedCoords >= end",d=n>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n):"coords";return`
        let start = ${i};
        let end = ${a};
        if (${l} || ${c}) {
          setOutputAtIndex(index, ${e?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${d}));
        }
  `}class lCe{constructor(e,n){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n.map((r,s)=>r[0]+e[s]+r[1]),this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),n.map((r,s)=>{this.uniforms+=` pad${s} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${zO(this.xShape)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uCe=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{paddings:o,constantValue:i}=r;if(o.every(c=>Mt(c,[0,0])))return ms({inputs:{x:s},backend:n});if(fe(s.shape)===0){const c=o.map((d,f)=>d[0]+s.shape[f]+d[1]);return Wr({backend:n,attrs:{shape:c,value:i,dtype:s.dtype}})}const a=[{type:"float32",data:[i]}];o.map(c=>a.push({type:"int32",data:[c[0],c[1]]}));const l=new lCe(s.shape,o);return n.runWebGPUProgram(l,[s],s.dtype,a)},cCe={kernelName:V2,backendName:"webgpu",kernelFunc:uCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dCe=zn({opType:et.POW}),hCe={kernelName:W2,backendName:"webgpu",kernelFunc:dCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fCe(t){const{inputs:e,backend:n}=t,{x:r,alpha:s}=e,o=new zg(et.PRELU,r.shape,s.shape);return n.runWebGPUProgram(o,[r,s],"float32")}const pCe={kernelName:U2,backendName:"webgpu",kernelFunc:fCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mCe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:o,keepDims:i}=r;return Ku(s,o,i,"prod",n)}const gCe={kernelName:j2,backendName:"webgpu",kernelFunc:mCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yCe=t=>{const{backend:e,attrs:n}=t,{start:r,stop:s,step:o,dtype:i}=n,a=ive(r,s,o,i);return e.makeTensorInfo([a.length],i,a)},xCe={kernelName:G2,backendName:"webgpu",kernelFunc:yCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vCe=zn({opType:et.DIV}),bCe={kernelName:Uw,backendName:"webgpu",kernelFunc:vCe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wCe=$t({opType:Ne.RECIPROCAL}),SCe={kernelName:K2,backendName:"webgpu",kernelFunc:wCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CCe=$t({opType:Ne.RELU}),$Ce={kernelName:X2,backendName:"webgpu",kernelFunc:CCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kCe=$t({opType:Ne.RELU6}),TCe={kernelName:Z2,backendName:"webgpu",kernelFunc:kCe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ICe{constructor(e,n,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],n,r,e[3]],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NCe(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:o,size:i,halfPixelCenters:a}=r,[l,c]=i,d=o&&l>1?1:0,f=o&&c>1?1:0,g=[{type:"float32",data:[d,f]},{type:"float32",data:[a?.5:0]}],y=new ICe(s.shape,l,c);return n.runWebGPUProgram(y,[s],"float32",g)}const ECe={kernelName:Q2,backendName:"webgpu",kernelFunc:NCe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RCe{constructor(e,n){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=n,this.shaderKey=`resizeBilinearBackprop_${n}`}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Ce(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:o}=e,{alignCorners:i}=r,[,a,l]=s.shape,[,c,d]=o.shape,f=[i&&c>1?a-1:a,i&&d>1?l-1:l],p=[i&&c>1?c-1:c,i&&d>1?d-1:d],g=f[0]/p[0],y=f[1]/p[1],x=1/g,w=1/y,S=Math.ceil(x)*2+2,$=Math.ceil(w)*2+2,I=new RCe(s.shape,i),R=[{type:"int32",data:f},{type:"int32",data:p},{type:"float32",data:[g]},{type:"float32",data:[y]},{type:"float32",data:[x]},{type:"float32",data:[w]},{type:"int32",data:[S]},{type:"int32",data:[$]}];return n.runWebGPUProgram(I,[o],o.dtype,R)}const PCe={kernelName:uA,backendName:"webgpu",kernelFunc:_Ce};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ACe{constructor(e,n,r,s){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],n,r,e[3]],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=s,this.shaderKey=`resizeNearest_${s}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DCe(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,c]=a,d=o&&l>1?1:0,f=o&&c>1?1:0,g=[{type:"float32",data:[d,f]},{type:"float32",data:[o?.5:0]}],y=new ACe(s.shape,l,c,i);return n.runWebGPUProgram(y,[s],s.dtype,g)}const FCe={kernelName:Y2,backendName:"webgpu",kernelFunc:DCe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OCe{constructor(e,n){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=n,this.shaderKey=`resizeNearestNeigborBackprop_${n}`}getUserCode(){return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LCe(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:o}=e,{alignCorners:i}=r,[,a,l]=s.shape,[,c,d]=o.shape,f=[i&&c>1?a-1:a,i&&d>1?l-1:l],p=[i&&c>1?c-1:c,i&&d>1?d-1:d],g=f[0]/p[0],y=f[1]/p[1],x=1/g,w=1/y,S=Math.ceil(x)*2+2,$=Math.ceil(w)*2+2,I=new OCe(s.shape,i),R=[{type:"int32",data:f},{type:"int32",data:p},{type:"float32",data:[x]},{type:"float32",data:[w]},{type:"int32",data:[S]},{type:"int32",data:[$]}];return n.runWebGPUProgram(I,[o],o.dtype,R)}const zCe={kernelName:lA,backendName:"webgpu",kernelFunc:LCe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BCe{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MCe(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dims:o}=r,i=s.shape.length;if(i===0)return ms({inputs:{x:s},backend:n});const a=s.shape,l=[1,1,1,1];a.forEach((w,S)=>{const $=S+4-i;l[$]=w});const c=nn(o,s.shape),d=[0,0,0,0];c.forEach(w=>{const S=w+4-i;d[S]=1});const f=[{type:"int32",data:d}],p=Be({inputs:{x:s},backend:n,attrs:{shape:l}}),g=new BCe(l),y=n.runWebGPUProgram(g,[p],p.dtype,f);n.disposeData(p.dataId);const x=Be({inputs:{x:y},backend:n,attrs:{shape:a}});return n.disposeData(y.dataId),x}const VCe={kernelName:J2,backendName:"webgpu",kernelFunc:MCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WCe{constructor(e,n){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,typeof n=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${Ee("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UCe={kernelName:AS,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:s,fillValue:o,center:i}=e,a=n,l=new WCe(r.shape,o),[c,d]=uC(i,r.shape[1],r.shape[2]),f=[{type:"float32",data:[c]},{type:"float32",data:[d]},{type:"float32",data:[Math.sin(s)]},{type:"float32",data:[Math.cos(s)]}];return typeof o=="number"?f.push({type:"float32",data:[Number.parseFloat(o.toFixed(2))]}):f.push({type:"float32",data:o}),a.runWebGPUProgram(l,[r],r.dtype,f)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jCe=$t({opType:Ne.ROUND}),GCe={kernelName:eS,backendName:"webgpu",kernelFunc:jCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HCe=$t({opType:Ne.RSQRT,cpuKernelImpl:ave}),KCe={kernelName:tS,backendName:"webgpu",kernelFunc:HCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ef{constructor(e,n,r,s,o,i,a,l=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=i,this.type=a,this.sumDupeIndices=l,this.dispatchLayout=De(e),this.dispatch=Re(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=n>1,this.shaderKey=`scatter_${r}_${s}_${this.sliceDimGreaterThanOne}_${a}_${l}_${o.length}`;const c=vn(o.length);this.uniforms=`sliceDim : i32, strides: ${c}, updatesSize: i32,`,this.updatesRank=s,this.indicesRank=r}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");const n=`getIndices(${e})`,r=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let s="",o="";this.dispatchLayout.x.length===1?(s="flattenedIndex",o=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(s="vec2<i32>(flattenedIndex, coords[1])",o=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const a=`getUpdates(${Array.from({length:this.updatesRank},(c,d)=>`coords[${d}]`).join(", ")})`;return`
    ${o}
      ${Ee("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${n}));
            flattenedIndex = flattenedIndex + indexInside * ${r};
          }
          let updateValue =
              ${pu(this.type)}(${a});
          let flatIndex = getOutputIndexFromCoords(${s});

          ${this.sumDupeIndices?Tl("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XCe(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s,updates:o}=e,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:d,outputSize:f}=zu(o,s,i),p=[f/c,c];if(f===0)return n.makeTensorInfo(i,s.dtype);const g=Be({inputs:{x:s},backend:n,attrs:{shape:[l,a]}}),y=Be({inputs:{x:o},backend:n,attrs:{shape:[l,c]}}),x=y.dtype,w=Wr({backend:n,attrs:{shape:p,value:0,dtype:x}}),S=fe(y.shape),$=[{type:"int32",data:[a]},{type:"int32",data:d},{type:"int32",data:[S]}],I=new ef(y.shape,a,g.shape.length,y.shape.length,d,p,x),R=n.runWebGPUProgram(I,[y,g],x,$,w),_=Be({inputs:{x:R},backend:n,attrs:{shape:i}});return n.disposeData(g.dataId),n.disposeData(y.dataId),n.disposeData(R.dataId),_}const qCe={kernelName:nS,backendName:"webgpu",kernelFunc:XCe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YCe{constructor(e,n){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=n,this.shaderKey=`search_sorted_${n}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${Ee("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QCe(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:s,values:o}=e,{side:i}=r,a=new YCe([o.shape[0],o.shape[1]],i),l=[{type:"int32",data:[s.shape[1]]}];return n.runWebGPUProgram(a,[s,o],"int32",l)}const ZCe={kernelName:sS,backendName:"webgpu",kernelFunc:QCe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JCe{constructor(e,n,r){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=r,this.shaderKey="select"}getUserCode(){let e,n;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)n="resRC",e="resRC";else{const s=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],i=[];for(let a=0;a<this.outputShape.length;a++)i.push(`${s[a]}`),a<this.cRank&&o.push(`${s[a]}`);e=o.join(),n=i.join()}return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${n}));
          } else {
            setOutputAtIndex(index, getB(${n}));
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e$e(t){const{inputs:e,backend:n}=t,{condition:r,t:s,e:o}=e,i=new JCe(r.shape.length,s.shape,s.shape.length);return n.runWebGPUProgram(i,[r,s,o],Ur(s.dtype,o.dtype))}const t$e={kernelName:oS,backendName:"webgpu",kernelFunc:e$e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n$e=$t({opType:Ne.SELU}),r$e={kernelName:iS,backendName:"webgpu",kernelFunc:n$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s$e=$t({opType:Ne.SIGMOID}),o$e={kernelName:dS,backendName:"webgpu",kernelFunc:s$e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i$e=$t({opType:Ne.SIGN}),a$e={kernelName:cS,backendName:"webgpu",kernelFunc:i$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l$e=$t({opType:Ne.SIN}),u$e={kernelName:lS,backendName:"webgpu",kernelFunc:l$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c$e=$t({opType:Ne.SINH}),d$e={kernelName:uS,backendName:"webgpu",kernelFunc:c$e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h$e=$t({opType:Ne.SOFTPLUS}),f$e={kernelName:hS,backendName:"webgpu",kernelFunc:h$e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class p$e{constructor(e,n,r,s,o,i){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const a=new Array(s.length);for(let l=0;l<a.length;l++)a[l]=s[o[l]];this.outputShape=a,this.newDim=o,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=n,this.uniforms+=`reshapedPaddedXShape : ${vn(s.length)}, paddedXShapeStrides : ${vn(i)}, `,r.map((l,c)=>{this.uniforms+=` pad${c} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${o}`}getUserCode(){const e=vn(this.outputShape.length),n=vO(this.newDim);return`
      ${ng(this.paddedXShape,"PaddedX")}
      ${Ee("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${n}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${zO(this.xShape,!0)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m$e=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:o,paddings:i}=r;z(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const a=o.reduce(($,I)=>$*I),l=[[0,0]];l.push(...i);for(let $=1+o.length;$<s.shape.length;++$)l.push([0,0]);const c=l.map(($,I)=>$[0]+s.shape[I]+$[1]),d=Qf(c,o,a,!1),f=Zf(d.length,o.length,!1),p=Jf(c,o,a,!1),g=mn(c),y=new p$e(s.shape,c,l,d,f,g.length),x=[{type:"int32",data:d},{type:"int32",data:g}];l.map($=>x.push({type:"int32",data:[$[0],$[1]]}));const w=n.runWebGPUProgram(y,[s],s.dtype,x),S=Be({inputs:{x:w},backend:n,attrs:{shape:p}});return n.disposeData(w.dataId),S},g$e={kernelName:mS,backendName:"webgpu",kernelFunc:m$e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class y$e{constructor(e,n,r){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=r,this.dispatchLayout=De([n]),this.dispatch=Re(this.dispatchLayout,[n],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${Tl("&result[outIndex]","value",this.type)}
      }
    }
  `}}class x$e{constructor(e,n){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=De(n),this.dispatch=Re(this.dispatchLayout,n,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${Tl("&result[segmentId]","1","int32")}
      }
    }
  `}}class v$e{constructor(e,n){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=n,this.dispatchLayout=De(e),this.dispatch=Re(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BO(t,e,n,r=!1,s){const i=fe(t.shape)/t.shape[0],a=t.dtype,l=fe(e.shape),c=s.readSync(n.dataId),f=l>0?c[l-1]+1:0;let p;const g=t.shape.slice();g[0]=f;const y=l*i,x=Wr({backend:s,attrs:{shape:g,value:0,dtype:a}});p=new y$e(g,y,a);let w=[{type:"int32",data:[i]},{type:"int32",data:[y]}];const S=s.runWebGPUProgram(p,[t,e,n],a,w,x);if(r)return S;const $=Wr({backend:s,attrs:{shape:[f],value:0,dtype:"int32"}});p=new x$e(f,n.shape);const I=s.runWebGPUProgram(p,[n],"int32",null,$),R=Wr({backend:s,attrs:{shape:g,value:0,dtype:a}});p=new v$e(g,a),w=[{type:"int32",data:[i]}];const _=s.runWebGPUProgram(p,[S,I],a,w,R);return s.disposeData(S.dataId),s.disposeData(I.dataId),_}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b$e(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:o}=e;return BO(r,s,o,!1,n)}const w$e={kernelName:xS,backendName:"webgpu",kernelFunc:b$e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S$e(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:o}=e;return BO(r,s,o,!0,n)}const C$e={kernelName:vS,backendName:"webgpu",kernelFunc:S$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $$e{constructor(e,n){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[s]*n[s];this.outputShape=r,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=k$e(this.rank,"uniforms.");return`
      ${Ee("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `}}function k$e(t,e=""){if(t>=5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`(resRC % ${e}aShape)`;const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<t;s++)r.push(`(${n[s]} % ${e}aShape[${s}])`);return r.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VC(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reps:o}=r;if(n.shouldExecuteOnCPU([s])||s.dtype==="string"||s.shape.length>=5){const l=n.readSync(s.dataId),c=s.dtype==="string"?l.map(p=>ca(p)):l,d=Vt(s.shape,s.dtype,c),f=pve(d,o);return n.makeTensorInfo(f.shape,f.dtype,f.values)}const i=new $$e(s.shape,o);return n.runWebGPUProgram(i,[s],s.dtype)}const T$e={kernelName:oy,backendName:"webgpu",kernelFunc:VC};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I$e(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:s,sparseValues:o,defaultValue:i}=e,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:d,strides:f,outputSize:p}=zu(o,s,a),g=!1;if(o.dtype==="string"){const M=n.bufferSync(s),B=n.bufferSync(o),V=ca(n.readSync(i.dataId)[0]),A=lve(M,B,a,p,d,c,l,f,V,g);return n.makeTensorInfo(a,A.dtype,A.values)}const y=[p/d,d],x=Be({inputs:{x:s},backend:n,attrs:{shape:[c,l]}}),w=o.shape.length?Be({inputs:{x:o},backend:n,attrs:{shape:[c,d]}}):ms({inputs:{x:o},backend:n}),S=w.dtype,$=n.makeTensorInfo([],S,ua(1,S)),I=Be({inputs:{x:i},backend:n,attrs:{shape:Array(y.length).fill(1)}}),R=VC({inputs:{x:I},backend:n,attrs:{reps:y}}),_=fe([c,d]),F=[{type:"int32",data:[l]},{type:"int32",data:f},{type:"int32",data:[_]}];switch(c){case 0:break;case 1:{const M=new ef([c,d],l,x.shape.length,w.shape.length,f,y,S,g);n.runWebGPUProgram(M,[w,x],S,F,R)}break;default:{const M=new ef([c,d],l,x.shape.length,$.shape.length,f,y,S,g);n.runWebGPUProgram(M,[$,x],S,F,R)}{const M=new ef([c,d],l,x.shape.length,w.shape.length,f,y,S);n.runWebGPUProgram(M,[w,x],S,F,R)}}const O=Be({inputs:{x:R},backend:n,attrs:{shape:a}});return n.disposeData(x.dataId),n.disposeData(w.dataId),n.disposeData(I.dataId),n.disposeData($.dataId),n.disposeData(R.dataId),O}const N$e={kernelName:bS,backendName:"webgpu",kernelFunc:I$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E$e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{numOrSizeSplits:o,axis:i}=r,a=nn(i,s.shape)[0],l=kC(s,o,a),c=s.shape.length,d=new Array(c).fill(0),f=s.shape.slice();return l.map(p=>{const g=[...f];g[a]=p;const y=Ld({inputs:{x:s},backend:n,attrs:{begin:d,size:g}});return d[a]+=p,y})}const R$e={kernelName:gS,backendName:"webgpu",kernelFunc:E$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _$e=$t({opType:Ne.SQRT}),P$e={kernelName:fS,backendName:"webgpu",kernelFunc:_$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A$e={kernelName:hA,backendName:"webgpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,r=e,s=new Od(n.shape,Ne.SQUARE);return r.runWebGPUProgram(s,[n],n.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D$e=zn({opType:et.SQUARED_DIFFERENCE}),F$e={kernelName:wS,backendName:"webgpu",kernelFunc:D$e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O$e({inputs:t,attrs:e,backend:n}){const{x:r}=t,s=new Od(r.shape,Ne.STEP,"stepAlpha : f32,"),o=[{type:"float32",data:[e.alpha]}];return n.runWebGPUProgram(s,[r],r.dtype,o)}const L$e={kernelName:PS,backendName:"webgpu",kernelFunc:O$e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class z$e{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const n=vn(this.outputShape.length);this.uniforms=`begin : ${n},  strides : ${n}, `,this.shaderKey="stridedSlice"}getUserCode(){const e=this.outputShape.length;let n="";if(e===1)n="coords * uniforms.strides + uniforms.begin";else{let s=0;n=this.outputShape.map((o,i)=>(s++,this.outputShape.length===1?`coords * uniforms.strides[${i}] + uniforms.begin[${i}]`:`coords[${s-1}] * uniforms.strides[${i}] + uniforms.begin[${i}]`)).join(",")}return`
       ${Ee("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${n}));
         }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B$e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:o,end:i,strides:a,beginMask:l,endMask:c,ellipsisMask:d,newAxisMask:f,shrinkAxisMask:p}=r,{finalShapeSparse:g,finalShape:y,isIdentity:x,sliceDim0:w,isSimpleSlice:S,begin:$,end:I,strides:R}=iC(s.shape,o,i,a,l,c,d,f,p);let _;if(x)_=Be({inputs:{x:s},backend:n,attrs:{shape:y}});else if(w||S){z(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const F=nC($,I,R),O=Ld({inputs:{x:s},backend:n,attrs:{begin:$,size:F}});_=Be({inputs:{x:O},backend:n,attrs:{shape:y}}),n.disposeData(O.dataId)}else if(n.shouldExecuteOnCPU([s])){const O=n.readSync(s.dataId),M=Vt(s.shape,s.dtype,O),B=dve(g,M,R,$);_=n.makeTensorInfo(y,s.dtype,B.values)}else{const O=new z$e(g),M=[{type:"int32",data:$},{type:"int32",data:R}],B=n.runWebGPUProgram(O,[s],s.dtype,M);_=Be({inputs:{x:B},backend:n,attrs:{shape:y}}),n.disposeData(B.dataId)}return _}const M$e={kernelName:SS,backendName:"webgpu",kernelFunc:B$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V$e(t){const{inputs:e,backend:n,attrs:r}=t,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:d,dataSplits:f}=e,p=n.readSync(d.dataId),g=n.readSync(f.dataId),[y,x]=hve(p,g,s,o,i,a,l,c);return[n.makeTensorInfo([y.length],"string",y),n.makeTensorInfo(f.shape,"int32",x)]}const W$e={kernelName:CS,backendName:"webgpu",kernelFunc:V$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U$e=zn({opType:et.SUB,cpuKernelImpl:fve,supportsComplex:!0}),j$e={kernelName:$S,backendName:"webgpu",kernelFunc:U$e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G$e=$t({opType:Ne.TAN}),H$e={kernelName:kS,backendName:"webgpu",kernelFunc:G$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K$e=$t({opType:Ne.TANH}),X$e={kernelName:TS,backendName:"webgpu",kernelFunc:K$e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q$e(t){const{inputs:e,backend:n,attrs:r}=t,{tensor:s,indices:o,updates:i}=e,{sliceRank:a,numUpdates:l,sliceSize:c,strides:d,outputSize:f}=zu(i,o,s.shape),p=[f/c,c];if(f===0)return n.makeTensorInfo(s.shape,o.dtype);const g=[],y=Be({inputs:{x:o},backend:n,attrs:{shape:[l,a]}});g.push(y);const x=Be({inputs:{x:i},backend:n,attrs:{shape:[l,c]}});g.push(x);const w=Be({inputs:{x:s},backend:n,attrs:{shape:p}});g.push(w);const S=VC({inputs:{x:w},backend:n,attrs:{reps:Array(p.length).fill(1)}}),$=new ef([l,c],a,y.shape.length,x.shape.length,d,p,s.dtype,!1),I=fe([l,c]),R=[{type:"int32",data:[a]},{type:"int32",data:d},{type:"int32",data:[I]}],_=n.runWebGPUProgram($,[x,y],w.dtype,R,S);g.push(_);const F=Be({inputs:{x:_},backend:n,attrs:{shape:s.shape}});return g.forEach(O=>n.disposeData(O.dataId)),F}const Y$e={kernelName:rS,backendName:"webgpu",kernelFunc:q$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q$e{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${Ee("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}class Z$e{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${Ee("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ic(t,e){e!==null&&t.disposeData(e.dataId)}function BE(t){let e=1;for(;e<t;)e*=2;return e}function J$e(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{k:o,sorted:i}=r,a=s.shape,l=a[a.length-1];if(n.shouldExecuteOnCPU([s])){const _=n.readSync(s.dataId),[F,O]=mve(_,a,s.dtype,o,i);return[n.makeTensorInfo(F.shape,F.dtype,F.values),n.makeTensorInfo(O.shape,O.dtype,O.values)]}if(o===0)return a[a.length-1]=0,[n.makeTensorInfo(a,s.dtype,[]),n.makeTensorInfo(a,"int32",[])];if(l===1)return[s,Wr({attrs:{shape:a,dtype:"int32",value:0},backend:n})];const d=fe(a)/l,f=Be({inputs:{x:s},attrs:{shape:[d,l]},backend:n}),p=BE(o),g=BE(l);let y=null;const x=()=>y===null?[f,f]:[f,y],w=(_,F,O)=>{const M=x(),B=new Q$e(O),A=[{type:"int32",data:[l]},{type:"int32",data:[y===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[_]},{type:"int32",data:[F]}],re=y;y=n.runWebGPUProgram(B,M,"int32",A),Ic(n,re)};for(let _=1;_<p;_*=2){const F=_*2;for(let O=_;O>=1;O/=2)w(F,O,[d,g])}for(let _=g;_>p;_/=2){const F=x(),O=new Z$e([d,_/2]),B=[{type:"int32",data:[l]},{type:"int32",data:[y===null?1:0]},{type:"int32",data:[p]}],V=y;y=n.runWebGPUProgram(O,F,"int32",B),Ic(n,V);const A=p/2,re=A*2;for(let ae=A;ae>=1;ae/=2)w(re,ae,y.shape)}let S=y;y=Ld({inputs:{x:y},backend:n,attrs:{begin:0,size:[d,o]}}),Ic(n,S);let $=DO({inputs:{x:f,indices:y},backend:n,attrs:{axis:1,batchDims:1}});Ic(n,f);const I=a.slice(0,-1);I.push(o),S=y,y=Be({inputs:{x:y},attrs:{shape:I},backend:n}),Ic(n,S);const R=$;return $=Be({inputs:{x:$},attrs:{shape:I},backend:n}),Ic(n,R),[$,y]}const eke={kernelName:IS,backendName:"webgpu",kernelFunc:J$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tke{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${Ee("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nke(t){const{inputs:e,backend:n,attrs:r}=t,{image:s,transforms:o}=e,{interpolation:i,fillMode:a,fillValue:l,outputShape:c}=r,[d,f,p,g]=s.shape,[y,x]=c??[f,p],w=[d,y,x,g],S=new tke(w),$=i==="nearest"?1:2;let I;switch(a){case"constant":I=1;break;case"reflect":I=2;break;case"wrap":I=3;break;case"nearest":I=4;break;default:I=1;break}const R=[{type:"int32",data:[$]},{type:"int32",data:[I]},{type:"float32",data:[l]}];return n.runWebGPUProgram(S,[s,o],"float32",R)}const rke={kernelName:NS,backendName:"webgpu",kernelFunc:nke};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ske(t){const{inputs:e,backend:n,attrs:r}=t,{value:s}=e;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s,a=i.shape.length,l=s.shape[o],c=new Array(a-1);let d=0;for(let x=0;x<a;x++)x!==o&&(c[d++]=i.shape[x]);const f=[],p=new Array(a).fill(0),g=i.shape.slice();g[o]=1;const y=new Array(l);for(let x=0;x<y.length;x++){p[o]=x;const w=Ld({inputs:{x:i},backend:n,attrs:{begin:p,size:g}}),S=Be({inputs:{x:w},backend:n,attrs:{shape:c}});y[x]=S,f.push(w)}return f.forEach(x=>n.disposeData(x.dataId)),y}const oke={kernelName:ES,backendName:"webgpu",kernelFunc:ske};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ike{constructor(e,n,r){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=n,this.dispatchLayout=De(e),this.dispatch=Re(this.dispatchLayout,e,this.workgroupSize),r!=="float32"&&r!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${r} type.`);this.type=r,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${Ee("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${Tl("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ake(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,segmentIds:o}=e,{numSegments:i}=r,a=s.shape.length,l=[];let c=0;const d=ur([c],a);let f=s;d!=null&&(f=wi({inputs:{x:s},backend:n,attrs:{perm:d}}),l.push(f),c=cr(1,a)[0]);const p=TC(f.shape,c,i),g=fe([f.shape[c]]),y=Be({inputs:{x:f},backend:n,attrs:{shape:[-1,g]}});l.push(y);const x=s.dtype,w=[y.shape[0],i],S=Wr({backend:n,attrs:{shape:w,value:0,dtype:x}}),$=new ike(y.shape,w,x),I=[{type:"int32",data:[i]},{type:"int32",data:[fe(y.shape)]}],R=n.runWebGPUProgram($,[y,o],x,I,S),_=Be({inputs:{x:R},backend:n,attrs:{shape:p}});l.push(R);let F=_;if(d!=null){l.push(_);const O=Yf(d);F=wi({inputs:{x:F},backend:n,attrs:{perm:O}})}return l.forEach(O=>n.disposeData(O.dataId)),F}const lke={kernelName:RS,backendName:"webgpu",kernelFunc:ake};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uke=[Dxe,xve,bve,Sve,$ve,Ive,Dve,Ove,zve,Mve,Wve,jve,Hve,Xve,Yve,tbe,rbe,abe,ube,dbe,gbe,bbe,Cbe,Ibe,Ebe,Abe,Oxe,Obe,Mbe,Xbe,ewe,swe,awe,uwe,dwe,fwe,mwe,xwe,bwe,Swe,$we,Iwe,Dwe,Owe,Rwe,Bwe,Wwe,Hwe,Xwe,Qwe,t2e,r2e,o2e,a2e,u2e,d2e,h2e,p2e,g2e,_xe,x2e,$2e,b2e,S2e,I2e,E2e,_2e,D2e,L2e,B2e,V2e,Fxe,U2e,zbe,G2e,K2e,q2e,Q2e,J2e,tSe,sSe,lSe,iSe,cSe,hSe,pSe,xSe,wSe,Zve,CSe,kSe,ASe,ISe,_Se,FSe,Jve,LSe,BSe,VSe,USe,XSe,Zwe,YSe,ZSe,eCe,$be,rCe,oCe,aCe,cCe,hCe,pCe,gCe,xCe,kbe,bCe,SCe,$Ce,TCe,Pxe,ECe,PCe,FCe,zCe,VCe,UCe,GCe,KCe,qCe,ZCe,t$e,r$e,o$e,a$e,u$e,d$e,pbe,L$e,M$e,W$e,HSe,f$e,g$e,w$e,C$e,N$e,R$e,P$e,A$e,F$e,j$e,Jwe,H$e,X$e,Y$e,T$e,eke,rke,Rve,oke,lke,sCe];for(const t of uke)yA(t);/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var MO=function(t,e){return(MO=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,r){n.__proto__=r}||function(n,r){for(var s in r)Object.prototype.hasOwnProperty.call(r,s)&&(n[s]=r[s])})(t,e)};function VO(t,e){if(typeof e!="function"&&e!==null)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function n(){this.constructor=t}MO(t,e),t.prototype=e===null?Object.create(e):(n.prototype=e.prototype,new n)}var Yt=function(){return(Yt=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var s in e=arguments[n])Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s]);return t}).apply(this,arguments)};function vt(t,e,n,r){return new(n||(n=Promise))(function(s,o){function i(c){try{l(r.next(c))}catch(d){o(d)}}function a(c){try{l(r.throw(c))}catch(d){o(d)}}function l(c){var d;c.done?s(c.value):(d=c.value,d instanceof n?d:new n(function(f){f(d)})).then(i,a)}l((r=r.apply(t,[])).next())})}function bt(t,e){var n,r,s,o,i={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(l){return function(c){return function(d){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,r&&(s=2&d[0]?r.return:d[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,d[1])).done)return s;switch(r=0,s&&(d=[2&d[0],s.value]),d[0]){case 0:case 1:s=d;break;case 4:return i.label++,{value:d[1],done:!1};case 5:i.label++,r=d[1],d=[0];continue;case 7:d=i.ops.pop(),i.trys.pop();continue;default:if(s=i.trys,!((s=s.length>0&&s[s.length-1])||d[0]!==6&&d[0]!==2)){i=0;continue}if(d[0]===3&&(!s||d[1]>s[0]&&d[1]<s[3])){i.label=d[1];break}if(d[0]===6&&i.label<s[1]){i.label=s[1],s=d;break}if(s&&i.label<s[2]){i.label=s[2],i.ops.push(d);break}s[2]&&i.ops.pop(),i.trys.pop();continue}d=e.call(t,i)}catch(f){d=[6,f],r=0}finally{n=s=0}if(5&d[0])throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}([l,c])}}}function bu(t,e,n){if(n||arguments.length===2)for(var r,s=0,o=e.length;s<o;s++)!r&&s in e||(r||(r=Array.prototype.slice.call(e,0,s)),r[s]=e[s]);return t.concat(r||Array.prototype.slice.call(e))}var Si=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],Af=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"];function Vg(t){return t instanceof SVGAnimatedLength?t.baseVal.value:t}function WO(t){return vt(this,void 0,void 0,function(){var e,n;return bt(this,function(r){switch(r.label){case 0:return e=document.createElement("canvas"),t instanceof hn?[4,JS(t,e)]:[3,2];case 1:return r.sent(),[3,3];case 2:e.width=Vg(t.width),e.height=Vg(t.height),n=e.getContext("2d"),t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0),r.label=3;case 3:return[2,e]}})})}function UO(t){return vt(this,void 0,void 0,function(){var e,n,r,s,o,i;return bt(this,function(a){switch(a.label){case 0:return t instanceof hn?(e=t.shape.slice(0,2),n=e[0],r=e[1],s=ImageData.bind,[4,JS(t)]):[3,2];case 1:return[2,new(s.apply(ImageData,[void 0,a.sent(),r,n]))];case 2:return o=document.createElement("canvas"),i=o.getContext("2d"),o.width=Vg(t.width),o.height=Vg(t.height),i.drawImage(t,0,0),[2,i.getImageData(0,0,o.width,o.height)]}})})}function cke(t){return vt(this,void 0,void 0,function(){var e,n;return bt(this,function(r){switch(r.label){case 0:return t instanceof SVGImageElement||t instanceof OffscreenCanvas?[4,WO(t)]:[3,2];case 1:return n=r.sent(),[3,3];case 2:n=t,r.label=3;case 3:return e=n,[2,jD(e,4)]}})})}function jO(t){if(t<0||t>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(t));if(!Number.isInteger(t))throw new Error("Mask value must be an integer but got ".concat(t))}var Ch={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},dke=function(){function t(e){this.mask=e}return t.prototype.toCanvasImageSource=function(){return vt(this,void 0,void 0,function(){return bt(this,function(e){return[2,this.mask]})})},t.prototype.toImageData=function(){return vt(this,void 0,void 0,function(){return bt(this,function(e){return[2,UO(this.mask)]})})},t.prototype.toTensor=function(){return vt(this,void 0,void 0,function(){return bt(this,function(e){return[2,cke(this.mask)]})})},t.prototype.getUnderlyingType=function(){return"canvasimagesource"},t}();function hke(t){return jO(t),"person"}var fke=function(){function t(e){var n,r=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new sye.Pose({locateFile:function(s,o){if(e.solutionPath){var i=e.solutionPath.replace(/\/+$/,"");return"".concat(i,"/").concat(s)}return"".concat(o,"/").concat(s)}}),e.modelType){case"lite":n=0;break;case"heavy":n=2;break;case"full":default:n=1}this.poseSolution.setOptions({modelComplexity:n,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(s){if(r.height=s.image.height,r.width=s.image.width,s.poseLandmarks==null)r.poses=[];else{var o=r.translateOutput(s.poseLandmarks,s.poseWorldLandmarks);s.segmentationMask&&(o.segmentation={maskValueToLabel:hke,mask:new dke(s.segmentationMask)}),r.poses=[o]}})}return t.prototype.translateOutput=function(e,n){var r=this,s={keypoints:e.map(function(o,i){return{x:o.x*r.width,y:o.y*r.height,z:o.z,score:o.visibility,name:Af[i]}})};return n!=null&&(s.keypoints3D=n.map(function(o,i){return{x:o.x,y:o.y,z:o.z,score:o.visibility,name:Af[i]}})),s},t.prototype.estimatePoses=function(e,n,r){return vt(this,void 0,void 0,function(){var s,o;return bt(this,function(i){switch(i.label){case 0:return n&&n.flipHorizontal&&n.flipHorizontal!==this.selfieMode&&(this.selfieMode=n.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof hn?(o=ImageData.bind,[4,JS(e)]):[3,2];case 1:return s=new(o.apply(ImageData,[void 0,i.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:s=e,i.label=3;case 3:return e=s,[4,this.poseSolution.send({image:e},r)];case 4:return i.sent(),[2,this.poses]}})})},t.prototype.dispose=function(){this.poseSolution.close()},t.prototype.reset=function(){this.poseSolution.reset()},t.prototype.initialize=function(){return this.poseSolution.initialize()},t}();function pke(t){return vt(this,void 0,void 0,function(){var e,n;return bt(this,function(r){switch(r.label){case 0:return e=function(s){if(s==null)return Yt({},Ch);var o=Yt({},s);return o.runtime="mediapipe",o.enableSegmentation==null&&(o.enableSegmentation=Ch.enableSegmentation),o.enableSmoothing==null&&(o.enableSmoothing=Ch.enableSmoothing),o.smoothSegmentation==null&&(o.smoothSegmentation=Ch.smoothSegmentation),o.modelType==null&&(o.modelType=Ch.modelType),o}(t),[4,(n=new fke(e)).initialize()];case 1:return r.sent(),[2,n]}})})}function md(t){return t instanceof hn?{height:t.shape[0],width:t.shape[1]}:{height:t.height,width:t.width}}function GO(t){return t-2*Math.PI*Math.floor((t+Math.PI)/(2*Math.PI))}function WC(t){return t instanceof hn?t:jD(t)}function HO(t,e,n){return zv(n,"inputResolution"),[1/n.width*t[0][0]*e.width,1/n.height*t[0][1]*e.width,t[0][3]*e.width,1/n.width*t[1][0]*e.height,1/n.height*t[1][1]*e.height,t[1][3]*e.height,0,0]}function zv(t,e){z(t.width!==0,function(){return"".concat(e," width cannot be 0.")}),z(t.height!==0,function(){return"".concat(e," height cannot be 0.")})}function ix(t,e,n){var r=n.rotationVectorStartKeypointIndex,s=n.rotationVectorEndKeypointIndex,o=t.locationData,i=o.relativeKeypoints[r].x*e.width,a=o.relativeKeypoints[r].y*e.height,l=o.relativeKeypoints[s].x*e.width,c=o.relativeKeypoints[s].y*e.height,d=2*Math.sqrt((l-i)*(l-i)+(c-a)*(c-a)),f=function(p,g,y){var x,w=p.locationData,S=y.rotationVectorStartKeypointIndex,$=y.rotationVectorEndKeypointIndex;x=y.rotationVectorTargetAngle?y.rotationVectorTargetAngle:Math.PI*y.rotationVectorTargetAngleDegree/180;var I=w.relativeKeypoints[S].x*g.width,R=w.relativeKeypoints[S].y*g.height,_=w.relativeKeypoints[$].x*g.width,F=w.relativeKeypoints[$].y*g.height;return GO(x-Math.atan2(-(F-R),_-I))}(t,e,n);return{xCenter:i/e.width,yCenter:a/e.height,width:d/e.width,height:d/e.height,rotation:f}}function KO(t){if(t.length!==16)throw new Error("Array length must be 16 but got ".concat(t.length));return[[t[0],t[1],t[2],t[3]],[t[4],t[5],t[6],t[7]],[t[8],t[9],t[10],t[11]],[t[12],t[13],t[14],t[15]]]}function ax(t,e,n,r,s,o,i){return t[e][s]*(t[n][o]*t[r][i]-t[n][i]*t[r][o])}function vr(t,e,n){var r=(e+1)%4,s=(e+2)%4,o=(e+3)%4,i=(n+1)%4,a=(n+2)%4,l=(n+3)%4;return ax(t,r,s,o,i,a,l)+ax(t,s,o,r,i,a,l)+ax(t,o,r,s,i,a,l)}function ME(t,e,n){n===void 0&&(n={ignoreRotation:!1});for(var r=[],s=0,o=t;s<o.length;s++){var i=o[s],a=i.x-.5,l=i.y-.5,c=n.ignoreRotation?0:e.rotation,d=Math.cos(c)*a-Math.sin(c)*l,f=Math.sin(c)*a+Math.cos(c)*l;d=d*e.width+e.xCenter,f=f*e.height+e.yCenter;var p=i.z*e.width,g=Yt({},i);g.x=d,g.y=f,g.z=p,r.push(g)}return r}function XO(t,e){var n=function(r,s,o,i){var a=s-r,l=i-o,c=l/a;return{scale:c,offset:o-r*c}}(0,255,e[0],e[1]);return tt(function(){return Ue(Te(t,n.scale),n.offset)})}function Bv(t,e,n){var r,s,o,i,a,l,c,d,f,p,g,y,x,w,S=e.outputTensorSize,$=e.keepAspectRatio,I=e.borderMode,R=e.outputTensorFloatRange,_=md(t),F=function(B,V){return V?{xCenter:V.xCenter*B.width,yCenter:V.yCenter*B.height,width:V.width*B.width,height:V.height*B.height,rotation:V.rotation}:{xCenter:.5*B.width,yCenter:.5*B.height,width:B.width,height:B.height,rotation:0}}(_,n),O=function(B,V,A){if(A===void 0&&(A=!1),!A)return{top:0,left:0,right:0,bottom:0};var re=V.height,ae=V.width;zv(V,"targetSize"),zv(B,"roi");var pe,ye,ve=re/ae,$e=B.height/B.width,se=0,me=0;return ve>$e?(pe=B.width,ye=B.width*ve,me=(1-$e/ve)/2):(pe=B.height/ve,ye=B.height,se=(1-ve/$e)/2),B.width=pe,B.height=ye,{top:me,left:se,right:se,bottom:me}}(F,S,$),M=(r=F,s=_.width,o=_.height,i=!1,a=r.width,l=r.height,c=i?-1:1,d=Math.cos(r.rotation),f=Math.sin(r.rotation),p=r.xCenter,g=r.yCenter,y=1/s,x=1/o,(w=new Array(16))[0]=a*d*c*y,w[1]=-l*f*y,w[2]=0,w[3]=(-.5*a*d*c+.5*l*f+p)*y,w[4]=a*f*c*x,w[5]=l*d*x,w[6]=0,w[7]=(-.5*l*d-.5*a*f*c+g)*x,w[8]=0,w[9]=0,w[10]=a*y,w[11]=0,w[12]=0,w[13]=0,w[14]=0,w[15]=1,KO(w));return{imageTensor:tt(function(){var B=WC(t),V=lo(HO(M,_,S),[1,8]),A=I==="zero"?"constant":"nearest",re=ku.transform(Es(Qt(B,"float32")),V,"bilinear",A,0,[S.height,S.width]);return R!=null?XO(re,R):re}),padding:O,transformationMatrix:M}}function VE(t,e,n,r){return r===1?.5*(t+e):t+(e-t)*n/(r-1)}function mke(t){return tt(function(){var e=function(s){return tt(function(){return[ft(s,[0,0,0],[1,-1,1]),ft(s,[0,0,1],[1,-1,-1])]})}(t),n=e[0],r=e[1];return{boxes:Gt(r),logits:Gt(n)}})}function qO(t){return t!=null&&t.currentTime!=null}function WE(t){for(var e={locationData:{relativeKeypoints:[]}},n=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,s=Number.MAX_SAFE_INTEGER,o=Number.MIN_SAFE_INTEGER,i=0;i<t.length;++i){var a=t[i];n=Math.min(n,a.x),r=Math.max(r,a.x),s=Math.min(s,a.y),o=Math.max(o,a.y),e.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return e.locationData.relativeBoundingBox={xMin:n,yMin:s,xMax:r,yMax:o,width:r-n,height:o-s},e}function gke(t,e,n,r){return vt(this,void 0,void 0,function(){var s,o,i,a,l;return bt(this,function(c){switch(c.label){case 0:return t.sort(function(d,f){return Math.max.apply(Math,f.score)-Math.max.apply(Math,d.score)}),s=lo(t.map(function(d){return[d.locationData.relativeBoundingBox.yMin,d.locationData.relativeBoundingBox.xMin,d.locationData.relativeBoundingBox.yMax,d.locationData.relativeBoundingBox.xMax]})),o=lr(t.map(function(d){return d.score[0]})),[4,ku.nonMaxSuppressionAsync(s,o,e,n)];case 1:return[4,(i=c.sent()).array()];case 2:return a=c.sent(),l=t.filter(function(d,f){return a.indexOf(f)>-1}),Bt([s,o,i]),[2,l]}})})}function YO(t,e){return t.map(function(n){var r=Yt(Yt({},n),{x:n.x*e.width,y:n.y*e.height});return n.z!=null&&(r.z=n.z*e.width),r})}function yke(t,e,n){return vt(this,void 0,void 0,function(){var r,s,o,i,a,l,c,d,f,p,g,y,x,w,S,$,I,R,_,F,O,M,B,V;return bt(this,function(A){switch(A.label){case 0:if(r=Gt(e,[0]),s=r.shape,o=s[0],i=s[1],a=s[2],t.length!==a)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(t.length,", heatmap length: ").concat(a));return l=[],[4,r.buffer()];case 1:for(c=A.sent(),d=0;d<t.length;d++)if(f=t[d],p=Yt({},f),l.push(p),g=Math.trunc(p.x*i),y=Math.trunc(p.y*o),!(g<0||g>=i||y<0||g>=o)){for(x=Math.trunc((n.kernelSize-1)/2),w=Math.max(0,g-x),S=Math.min(i,g+x+1),$=Math.max(0,y-x),I=Math.min(o,y+x+1),R=0,_=0,F=0,O=0,M=$;M<I;++M)for(B=w;B<S;++B)V=c.get(M,B,d),R+=V,O=Math.max(O,V),_+=B*V,F+=M*V;O>=n.minConfidenceToRefine&&R>0&&(p.x=_/i/R,p.y=F/o/R)}return r.dispose(),[2,l]}})})}function UE(t,e){var n=e.left,r=e.top,s=e.left+e.right,o=e.top+e.bottom;return t.map(function(i){return Yt(Yt({},i),{x:(i.x-n)/(1-s),y:(i.y-r)/(1-o),z:i.z/(1-s)})})}function xke(t,e,n){return gf()==="webgl"?function(r,s,o){var i=o.combineWithPreviousRatio.toFixed(2),a={variableNames:["prevMask","newMask"],outputShape:r.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `.concat(i,`);

      setOutput(outputValue);
    }
`)},l=ud();return tt(function(){var c=l.compileAndRun(a,[r,s]);return cs().makeTensorFromDataId(c.dataId,c.shape,c.dtype)})}(t,e,n):tt(function(){var r=ot(e,.5),s=ao(r),o=ot(1,Sf(1,Te(s,Ue(5.68842,Te(s,Ue(-.748699,Te(s,Ue(-57.8051,Te(s,Ue(291.309,Te(s,-624.717)))))))))));return Ue(e,Te(ot(t,e),Te(o,n.combineWithPreviousRatio)))})}function vke(t,e,n){return vt(this,void 0,void 0,function(){var r,s,o,i,a;return bt(this,function(l){switch(l.label){case 0:return r=t[0],s=t[1],o=function(c,d,f){return tt(function(){var p,g,y,x;f.reverseOutputOrder?(g=Gt(ft(c,[0,f.boxCoordOffset+0],[-1,1])),p=Gt(ft(c,[0,f.boxCoordOffset+1],[-1,1])),x=Gt(ft(c,[0,f.boxCoordOffset+2],[-1,1])),y=Gt(ft(c,[0,f.boxCoordOffset+3],[-1,1]))):(p=Gt(ft(c,[0,f.boxCoordOffset+0],[-1,1])),g=Gt(ft(c,[0,f.boxCoordOffset+1],[-1,1])),y=Gt(ft(c,[0,f.boxCoordOffset+2],[-1,1])),x=Gt(ft(c,[0,f.boxCoordOffset+3],[-1,1]))),g=Ue(Te(gt(g,f.xScale),d.w),d.x),p=Ue(Te(gt(p,f.yScale),d.h),d.y),f.applyExponentialOnBoxSize?(y=Te(fa(gt(y,f.hScale)),d.h),x=Te(fa(gt(x,f.wScale)),d.w)):(y=Te(gt(y,f.hScale),d.h),x=Te(gt(x,f.wScale),d.h));var w=ot(p,gt(y,2)),S=ot(g,gt(x,2)),$=Ue(p,gt(y,2)),I=Ue(g,gt(x,2)),R=On([xe(w,[f.numBoxes,1]),xe(S,[f.numBoxes,1]),xe($,[f.numBoxes,1]),xe(I,[f.numBoxes,1])],1);if(f.numKeypoints)for(var _=0;_<f.numKeypoints;++_){var F=f.keypointCoordOffset+_*f.numValuesPerKeypoint,O=void 0,M=void 0;f.reverseOutputOrder?(O=Gt(ft(c,[0,F],[-1,1])),M=Gt(ft(c,[0,F+1],[-1,1]))):(M=Gt(ft(c,[0,F],[-1,1])),O=Gt(ft(c,[0,F+1],[-1,1])));var B=Ue(Te(gt(O,f.xScale),d.w),d.x),V=Ue(Te(gt(M,f.yScale),d.h),d.y);R=On([R,xe(B,[f.numBoxes,1]),xe(V,[f.numBoxes,1])],1)}return R})}(s,e,n),i=tt(function(){var c=r;return n.sigmoidScore?(n.scoreClippingThresh!=null&&(c=eD(r,-n.scoreClippingThresh,n.scoreClippingThresh)),c=sa(c)):c}),[4,bke(o,i,n)];case 1:return a=l.sent(),Bt([o,i]),[2,a]}})})}function bke(t,e,n){return vt(this,void 0,void 0,function(){var r,s,o,i,a,l,c,d,f,p,g,y;return bt(this,function(x){switch(x.label){case 0:return r=[],[4,t.data()];case 1:return s=x.sent(),[4,e.data()];case 2:for(o=x.sent(),i=0;i<n.numBoxes;++i)if(!(n.minScoreThresh!=null&&o[i]<n.minScoreThresh||(a=i*n.numCoords,l=wke(s[a+0],s[a+1],s[a+2],s[a+3],o[i],n.flipVertically,i),(c=l.locationData.relativeBoundingBox).width<0||c.height<0))){if(n.numKeypoints>0)for((d=l.locationData).relativeKeypoints=[],f=n.numKeypoints*n.numValuesPerKeypoint,p=0;p<f;p+=n.numValuesPerKeypoint)g=a+n.keypointCoordOffset+p,y={x:s[g+0],y:n.flipVertically?1-s[g+1]:s[g+1]},d.relativeKeypoints.push(y);r.push(l)}return[2,r]}})})}function wke(t,e,n,r,s,o,i){return{score:[s],ind:i,locationData:{relativeBoundingBox:{xMin:e,yMin:o?1-n:t,xMax:r,yMax:o?1-t:n,width:r-e,height:n-t}}}}function Ske(t,e){return t==="none"?e:function(n){return 1/(1+Math.exp(-n))}(e)}function jE(t,e,n,r){return vt(this,void 0,void 0,function(){var s,o,i,a,l,c,d,f;return bt(this,function(p){switch(p.label){case 0:return n=n||e.flipHorizontally||!1,r=r||e.flipVertically||!1,s=t.size,o=s/e.numLandmarks,[4,t.data()];case 1:for(i=p.sent(),a=[],l=0;l<e.numLandmarks;++l)c=l*o,(f={x:0,y:0}).x=n?e.inputImageWidth-i[c]:i[c],o>1&&(f.y=r?e.inputImageHeight-i[c+1]:i[c+1]),o>2&&(f.z=i[c+2]),o>3&&(f.score=Ske(e.visibilityActivation,i[c+3])),a.push(f);for(d=0;d<a.length;++d)(f=a[d]).x=f.x/e.inputImageWidth,f.y=f.y/e.inputImageHeight,f.z=f.z/e.inputImageWidth/(e.normalizeZ||1);return[2,a]}})})}function GE(t,e,n){var r=t.width,s=t.height,o=t.rotation;if(n.rotation==null&&n.rotationDegree==null||(o=function(c,d){return d.rotation!=null?c+=d.rotation:d.rotationDegree!=null&&(c+=Math.PI*d.rotationDegree/180),GO(c)}(o,n)),o===0)t.xCenter=t.xCenter+r*n.shiftX,t.yCenter=t.yCenter+s*n.shiftY;else{var i=(e.width*r*n.shiftX*Math.cos(o)-e.height*s*n.shiftY*Math.sin(o))/e.width,a=(e.width*r*n.shiftX*Math.sin(o)+e.height*s*n.shiftY*Math.cos(o))/e.height;t.xCenter=t.xCenter+i,t.yCenter=t.yCenter+a}{var l=Math.max(r*e.width,s*e.height);r=l/e.width,s=l/e.height}return t.width=r*n.scaleX,t.height=s*n.scaleY,t}function Cke(t,e){return t.map(function(n){var r=Yt(Yt({},n),{x:n.x/e.width,y:n.y/e.height});return n.z!=null&&(n.z=n.z/e.width),r})}var ll=function(){function t(e){this.alpha=e,this.initialized=!1}return t.prototype.apply=function(e,n){var r;return this.initialized?r=n==null?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*n*Math.asinh((e-this.storedValue)/n):(r=e,this.initialized=!0),this.rawValue=e,this.storedValue=r,r},t.prototype.applyWithAlpha=function(e,n,r){return this.alpha=n,this.apply(e,r)},t.prototype.hasLastRawValue=function(){return this.initialized},t.prototype.lastRawValue=function(){return this.rawValue},t.prototype.reset=function(){this.initialized=!1},t}(),lx=function(){function t(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new ll(this.getAlpha(this.minCutOff)),this.dx=new ll(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return t.prototype.apply=function(e,n,r){if(e==null)return e;var s=Math.trunc(n);if(this.lastTimestamp>=s)return e;this.lastTimestamp!==0&&s!==0&&(this.frequency=1/(1e-6*(s-this.lastTimestamp))),this.lastTimestamp=s;var o=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*r*this.frequency:0,i=this.dx.applyWithAlpha(o,this.getAlpha(this.derivateCutOff)),a=this.minCutOff+this.beta*Math.abs(i),l=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(i):null;return this.x.applyWithAlpha(e,this.getAlpha(a),l)},t.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},t}(),Mv=function(){function t(e){this.config=e}return t.prototype.apply=function(e,n,r){var s=this;if(e==null)return this.reset(),null;this.initializeFiltersIfEmpty(e);var o=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return bu([],e,!0);o=1/r}return e.map(function(i,a){var l=Yt(Yt({},i),{x:s.xFilters[a].apply(i.x,n,o),y:s.yFilters[a].apply(i.y,n,o)});return i.z!=null&&(l.z=s.zFilters[a].apply(i.z,n,o)),l})},t.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},t.prototype.initializeFiltersIfEmpty=function(e){var n=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new lx(n.config)}),this.yFilters=e.map(function(r){return new lx(n.config)}),this.zFilters=e.map(function(r){return new lx(n.config)}))},t}(),ux=function(){function t(e){this.config=e,this.window=[],this.lowPassFilter=new ll(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return t.prototype.apply=function(e,n,r){if(e==null)return e;var s,o=Math.trunc(n);if(this.lastTimestamp>=o)return e;if(this.lastTimestamp===-1)s=1;else{for(var i=e*r-this.lastValue*this.lastValueScale,a=o-this.lastTimestamp,l=i,c=a,d=(1+this.window.length)*(1e6/30),f=0,p=this.window;f<p.length;f++){var g=p[f];if(c+g.duration>d)break;l+=g.distance,c+=g.duration}var y=l/(1e-6*c);s=1-1/(1+this.config.velocityScale*Math.abs(y)),this.window.unshift({distance:i,duration:a}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=r,this.lastTimestamp=o,this.lowPassFilter.applyWithAlpha(e,s)},t}(),$ke=function(){function t(e){this.config=e}return t.prototype.apply=function(e,n,r){var s=this;if(e==null)return this.reset(),null;var o=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return bu([],e,!0);o=1/r}return this.initializeFiltersIfEmpty(e),e.map(function(i,a){var l=Yt(Yt({},i),{x:s.xFilters[a].apply(i.x,n,o),y:s.yFilters[a].apply(i.y,n,o)});return i.z!=null&&(l.z=s.zFilters[a].apply(i.z,n,o)),l})},t.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},t.prototype.initializeFiltersIfEmpty=function(e){var n=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new ux(n.config)}),this.yFilters=e.map(function(r){return new ux(n.config)}),this.zFilters=e.map(function(r){return new ux(n.config)}))},t}(),cx=function(){function t(e){if(e.velocityFilter!=null)this.keypointsFilter=new $ke(e.velocityFilter);else{if(e.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(e,"."));this.keypointsFilter=new Mv(e.oneEuroFilter)}}return t.prototype.apply=function(e,n,r,s,o){if(s===void 0&&(s=!1),e==null)return this.keypointsFilter.reset(),null;var i=o!=null?function(c,d){return(c.width*d.width+c.height*d.height)/2}(o,r):1,a=s?YO(e,r):e,l=this.keypointsFilter.apply(a,n,i);return s?Cke(l,r):l},t}(),HE=function(){function t(e){this.alpha=e.alpha}return t.prototype.apply=function(e){var n=this;if(e==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map(function(a){return new ll(n.alpha)}));for(var r=[],s=0;s<e.length;++s){var o=e[s],i=Yt({},o);i.score=this.visibilityFilters[s].apply(o.score),r.push(i)}return r},t}(),kke={interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},Nc={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},Tke={maxPoses:1,flipHorizontal:!1},Ike={applyExponentialOnBoxSize:!1,flipVertically:!1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},Nke=.3,KE={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25},Eke={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},Rke={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},_ke={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},Pke={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},Ake={kernelSize:7,minConfidenceToRefine:.5},XE={alpha:.1},Dke={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},Fke={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},Oke={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},Lke={activation:"none"},zke={combineWithPreviousRatio:.7},Bke=function(){function t(e){this.mask=e}return t.prototype.toCanvasImageSource=function(){return vt(this,void 0,void 0,function(){return bt(this,function(e){return[2,WO(this.mask)]})})},t.prototype.toImageData=function(){return vt(this,void 0,void 0,function(){return bt(this,function(e){return[2,UO(this.mask)]})})},t.prototype.toTensor=function(){return vt(this,void 0,void 0,function(){return bt(this,function(e){return[2,this.mask]})})},t.prototype.getUnderlyingType=function(){return"tensor"},t}();function Mke(t){return jO(t),"person"}var Vke=function(){function t(e,n,r,s,o,i){this.detectorModel=e,this.landmarkModel=n,this.enableSmoothing=r,this.enableSegmentation=s,this.smoothSegmentation=o,this.modelType=i,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(f){f.reduceBoxesInLowestLayer==null&&(f.reduceBoxesInLowestLayer=!1),f.interpolatedScaleAspectRatio==null&&(f.interpolatedScaleAspectRatio=1),f.fixedAnchorSize==null&&(f.fixedAnchorSize=!1);for(var p=[],g=0;g<f.numLayers;){for(var y=[],x=[],w=[],S=[],$=g;$<f.strides.length&&f.strides[$]===f.strides[g];){var I=VE(f.minScale,f.maxScale,$,f.strides.length);if($===0&&f.reduceBoxesInLowestLayer)w.push(1),w.push(2),w.push(.5),S.push(.1),S.push(I),S.push(I);else{for(var R=0;R<f.aspectRatios.length;++R)w.push(f.aspectRatios[R]),S.push(I);if(f.interpolatedScaleAspectRatio>0){var _=$===f.strides.length-1?1:VE(f.minScale,f.maxScale,$+1,f.strides.length);S.push(Math.sqrt(I*_)),w.push(f.interpolatedScaleAspectRatio)}}$++}for(var F=0;F<w.length;++F){var O=Math.sqrt(w[F]);y.push(S[F]/O),x.push(S[F]*O)}var M=0,B=0;if(f.featureMapHeight.length>0)M=f.featureMapHeight[g],B=f.featureMapWidth[g];else{var V=f.strides[g];M=Math.ceil(f.inputSizeHeight/V),B=Math.ceil(f.inputSizeWidth/V)}for(var A=0;A<M;++A)for(var re=0;re<B;++re)for(var ae=0;ae<y.length;++ae){var pe={xCenter:(re+f.anchorOffsetX)/B,yCenter:(A+f.anchorOffsetY)/M,width:0,height:0};f.fixedAnchorSize?(pe.width=1,pe.height=1):(pe.width=x[ae],pe.height=y[ae]),p.push(pe)}g=$}return p}(kke);var a=lr(this.anchors.map(function(f){return f.width})),l=lr(this.anchors.map(function(f){return f.height})),c=lr(this.anchors.map(function(f){return f.xCenter})),d=lr(this.anchors.map(function(f){return f.yCenter}));this.anchorTensor={x:c,y:d,w:a,h:l},this.prevFilteredSegmentationMask=this.enableSegmentation?lo([],[0,0]):null}return t.prototype.estimatePoses=function(e,n,r){return vt(this,void 0,void 0,function(){var s,o,i,a,l,c,d,f,p,g,y,x,w,S,$,I,R,_,F,O,M,B,V;return bt(this,function(A){switch(A.label){case 0:return s=function(re){var ae;if((ae=re==null?Tke:Yt({},re)).maxPoses==null&&(ae.maxPoses=1),ae.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(ae.maxPoses,". Should be > 0."));if(ae.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return ae}(n),e==null?(this.reset(),[2,[]]):(this.maxPoses=s.maxPoses,this.timestamp=r!=null?1e3*r:qO(e)?1e6*e.currentTime:null,o=md(e),i=tt(function(){return Qt(WC(e),"float32")}),(a=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(i)]);case 1:if((l=A.sent()).length===0)return this.reset(),i.dispose(),[2,[]];c=l[0],a=this.poseDetectionToRoi(c,o),A.label=2;case 2:return[4,this.poseLandmarksByRoi(a,i)];case 3:return d=A.sent(),i.dispose(),d==null?(this.reset(),[2,[]]):(f=d.landmarks,p=d.auxiliaryLandmarks,g=d.poseScore,y=d.worldLandmarks,x=d.segmentationMask,w=this.poseLandmarkFiltering(f,p,y,o),S=w.actualLandmarksFiltered,$=w.auxiliaryLandmarksFiltered,I=w.actualWorldLandmarksFiltered,R=this.poseLandmarksToRoi($,o),this.regionOfInterest=R,_=this.smoothSegmentation&&x!=null?this.poseSegmentationFiltering(x):x,(F=S!=null?YO(S,o):null)!=null&&F.forEach(function(re,ae){re.name=Af[ae]}),(O=I)!=null&&O.forEach(function(re,ae){re.name=Af[ae]}),M={score:g,keypoints:F,keypoints3D:O},_!==null&&(B=tt(function(){var re=Es(_,2),ae=yl(re,[[0,0],[0,0],[0,1]]);return vD(ae,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||Bt(_),V={maskValueToLabel:Mke,mask:new Bke(B)},M.segmentation=V),[2,[M]])}})})},t.prototype.poseSegmentationFiltering=function(e){var n=this.prevFilteredSegmentationMask;return n.size===0?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=xke(n,e,zke),Bt(e)),Bt(n),this.prevFilteredSegmentationMask},t.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),Bt([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},t.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(Bt(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=lo([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},t.prototype.detectPose=function(e){return vt(this,void 0,void 0,function(){var n,r,s,o,i,a,l,c,d,f;return bt(this,function(p){switch(p.label){case 0:return n=Bv(e,Eke),r=n.imageTensor,s=n.padding,o=this.detectorModel.predict(r),i=mke(o),a=i.boxes,[4,vke([l=i.logits,a],this.anchorTensor,Ike)];case 1:return(c=p.sent()).length===0?(Bt([r,o,l,a]),[2,c]):[4,gke(c,this.maxPoses,Nke)];case 2:return d=p.sent(),f=function(g,y){g===void 0&&(g=[]);for(var x=y.left,w=y.top,S=y.left+y.right,$=y.top+y.bottom,I=0;I<g.length;I++){var R=g[I],_=R.locationData.relativeBoundingBox,F=(_.xMin-x)/(1-S),O=(_.yMin-w)/(1-$),M=_.width/(1-S),B=_.height/(1-$);_.xMin=F,_.yMin=O,_.width=M,_.height=B,_.xMax=F+M,_.yMax=O+B;var V=R.locationData.relativeKeypoints;V&&V.forEach(function(A){var re=(A.x-x)/(1-S),ae=(A.y-w)/(1-$);A.x=re,A.y=ae})}return g}(d,s),Bt([r,o,l,a]),[2,f]}})})},t.prototype.poseDetectionToRoi=function(e,n){return GE(ix(e,n,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),n,KE)},t.prototype.poseLandmarksByRoi=function(e,n){return vt(this,void 0,void 0,function(){var r,s,o,i,a,l,c,d,f,p,g,y,x,w;return bt(this,function(S){switch(S.label){case 0:if(r=md(n),s=Bv(n,Rke,e),o=s.imageTensor,i=s.padding,a=s.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return l=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&l.push("activation_segmentation"),c=this.landmarkModel.execute(o,l),[4,this.tensorsToPoseLandmarksAndSegmentation(c)];case 1:return(d=S.sent())==null?(Bt(c),Bt(o),[2,null]):(f=d.landmarks,p=d.auxiliaryLandmarks,g=d.poseScore,y=d.worldLandmarks,x=d.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(r,e,i,a,f,p,y,x)]);case 2:return w=S.sent(),Bt(c),Bt(o),[2,Yt({poseScore:g},w)]}})})},t.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,n,r,s,o,i,a,l){return vt(this,void 0,void 0,function(){var c,d,f,p,g,y;return bt(this,function(x){return c=UE(o,r),d=UE(i,r),f=ME(c,n),p=ME(d,n),g=function(w,S){for(var $=[],I=0,R=w;I<R.length;I++){var _=R[I],F=_.x,O=_.y,M=S.rotation,B=Math.cos(M)*F-Math.sin(M)*O,V=Math.sin(M)*F+Math.cos(M)*O,A=Yt({},_);A.x=B,A.y=V,$.push(A)}return $}(a,n),y=null,this.enableSegmentation&&(y=tt(function(){var w=l.shape,S=w[0],$=w[1],I=function(F){var O=KO(new Array(16).fill(0));O[0][0]=vr(F,0,0),O[1][0]=-vr(F,0,1),O[2][0]=vr(F,0,2),O[3][0]=-vr(F,0,3),O[0][2]=vr(F,2,0),O[1][2]=-vr(F,2,1),O[2][2]=vr(F,2,2),O[3][2]=-vr(F,2,3),O[0][1]=-vr(F,1,0),O[1][1]=vr(F,1,1),O[2][1]=-vr(F,1,2),O[3][1]=vr(F,1,3),O[0][3]=-vr(F,3,0),O[1][3]=vr(F,3,1),O[2][3]=-vr(F,3,2),O[3][3]=vr(F,3,3);for(var M=F[0][0]*O[0][0]+F[1][0]*O[0][1]+F[2][0]*O[0][2]+F[3][0]*O[0][3],B=0;B<O.length;B++)for(var V=0;V<O.length;V++)O[B][V]/=M;return O}(s),R=lo(HO(I,{width:$,height:S},e),[1,8]),_=[1,S,$,1];return Gt(ku.transform(xe(l,_),R,"bilinear","constant",0,[e.height,e.width]),[0,3])}),Bt(l)),[2,{landmarks:f,auxiliaryLandmarks:p,worldLandmarks:g,segmentationMask:y}]})})},t.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return vt(this,void 0,void 0,function(){var n,r,s,o,i,a,l,c,d,f,p,g,y;return bt(this,function(x){switch(x.label){case 0:return n=e[0],r=e[1],s=e[2],o=e[3],i=this.enableSegmentation?e[4]:null,[4,r.data()];case 1:return(a=x.sent()[0])<.5?[2,null]:[4,jE(n,_ke)];case 2:return[4,yke(x.sent(),s,Ake)];case 3:return l=x.sent(),c=l.slice(0,33),d=l.slice(33,35),[4,jE(o,Pke)];case 4:return f=x.sent(),p=f.slice(0,33),g=function(w,S,$){for(var I=[],R=0;R<w.length;R++){var _=Yt({},S[R]);_.score=w[R].score,I.push(_)}return I}(c,p),y=this.enableSegmentation?function(w,S,$){return tt(function(){var I=Gt(w,[0]),R=I.shape[2];if(R===1){var _=I;switch(S.activation){case"none":break;case"sigmoid":_=sa(_);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(S.activation,")"))}var F=_;return Gt(F,[2])}throw new Error("Unsupported number of tensor channels ".concat(R))})}(i,Lke):null,[2,{landmarks:c,auxiliaryLandmarks:d,poseScore:a,worldLandmarks:g,segmentationMask:y}]}})})},t.prototype.poseLandmarksToRoi=function(e,n){return GE(ix(WE(e),n,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),n,KE)},t.prototype.poseLandmarkFiltering=function(e,n,r,s){var o,i,a;if(this.timestamp!=null&&this.enableSmoothing){var l=ix(WE(n),s,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new HE(XE)),o=this.visibilitySmoothingFilterActual.apply(e),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new HE(XE)),i=this.visibilitySmoothingFilterAuxiliary.apply(n),a=this.visibilitySmoothingFilterActual.apply(r),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new cx(Dke)),o=this.landmarksSmoothingFilterActual.apply(o,this.timestamp,s,!0,l),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new cx(Fke)),i=this.landmarksSmoothingFilterAuxiliary.apply(i,this.timestamp,s,!0,l),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new cx(Oke)),a=this.worldLandmarksSmoothingFilterActual.apply(r,this.timestamp)}else o=e,i=n,a=r;return{actualLandmarksFiltered:o,auxiliaryLandmarksFiltered:i,actualWorldLandmarksFiltered:a}},t}();function Wke(t){return vt(this,void 0,void 0,function(){var e,n,r,s,o,i;return bt(this,function(a){switch(a.label){case 0:return e=function(l){var c=Yt({},l??Nc);if(c.enableSmoothing==null&&(c.enableSmoothing=Nc.enableSmoothing),c.enableSegmentation==null&&(c.enableSegmentation=Nc.enableSegmentation),c.smoothSegmentation==null&&(c.smoothSegmentation=Nc.smoothSegmentation),c.modelType==null&&(c.modelType=Nc.modelType),c.detectorModelUrl==null&&(c.detectorModelUrl=Nc.detectorModelUrl),c.landmarkModelUrl==null)switch(c.modelType){case"lite":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return c}(t),n=typeof e.detectorModelUrl=="string"&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,r=typeof e.landmarkModelUrl=="string"&&e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([fd(e.detectorModelUrl,{fromTFHub:n}),fd(e.landmarkModelUrl,{fromTFHub:r})])];case 1:return s=a.sent(),o=s[0],i=s[1],[2,new Vke(o,i,e.enableSmoothing,e.enableSegmentation,e.smoothSegmentation,e.modelType)]}})})}var Iu,vi,QO=function(){function t(e){(function(n){if(n.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(n.maxTracks));if(n.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(n.maxAge));if(n.keypointTrackerParams!==void 0){if(n.keypointTrackerParams.keypointConfidenceThreshold<0||n.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(n.keypointTrackerParams.keypointConfidenceThreshold));if(n.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(n.keypointTrackerParams.minNumberOfKeypoints));for(var r=0,s=n.keypointTrackerParams.keypointFalloff;r<s.length;r++){var o=s[r];if(o<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(o))}}})(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return t.prototype.apply=function(e,n){this.filterOldTracks(n);var r=this.computeSimilarity(e);return this.assignTracks(e,r,n),this.updateTracks(n),e},t.prototype.getTracks=function(){return this.tracks.slice()},t.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(e){return e.id}))},t.prototype.filterOldTracks=function(e){var n=this;this.tracks=this.tracks.filter(function(r){return e-r.lastTimestamp<=n.maxAge})},t.prototype.assignTracks=function(e,n,r){for(var s=Array.from(Array(n[0].length).keys()),o=[],i=0,a=Array.from(Array(e.length).keys());i<a.length;i++){var l=a[i];if(s.length!==0){for(var c=-1,d=-1,f=0,p=s;f<p.length;f++){var g=p[f],y=n[l][g];y>=this.minSimilarity&&y>d&&(c=g,d=y)}if(c>=0){var x=this.tracks[c];x=Object.assign(x,this.createTrack(e[l],r,x.id)),e[l].id=x.id;var w=s.indexOf(c);s.splice(w,1)}else o.push(l)}else o.push(l)}for(var S=0,$=o;S<$.length;S++){l=$[S];var I=this.createTrack(e[l],r);this.tracks.push(I),e[l].id=I.id}},t.prototype.updateTracks=function(e){this.tracks.sort(function(n,r){return r.lastTimestamp-n.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},t.prototype.createTrack=function(e,n,r){var s={id:r||this.nextTrackID(),lastTimestamp:n,keypoints:bu([],e.keypoints,!0).map(function(o){return Yt({},o)})};return e.box!==void 0&&(s.box=Yt({},e.box)),s},t.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},t.prototype.remove=function(){for(var e=[],n=0;n<arguments.length;n++)e[n]=arguments[n];this.tracks=this.tracks.filter(function(r){return!e.includes(r.id)})},t.prototype.reset=function(){this.tracks=[]},t}(),Uke=function(t){function e(n){return t.call(this,n)||this}return VO(e,t),e.prototype.computeSimilarity=function(n){var r=this;return n.length===0||this.tracks.length===0?[[]]:n.map(function(s){return r.tracks.map(function(o){return r.iou(s,o)})})},e.prototype.iou=function(n,r){var s=Math.max(n.box.xMin,r.box.xMin),o=Math.max(n.box.yMin,r.box.yMin),i=Math.min(n.box.xMax,r.box.xMax),a=Math.min(n.box.yMax,r.box.yMax);if(s>=i||o>=a)return 0;var l=(i-s)*(a-o);return l/(n.box.width*n.box.height+r.box.width*r.box.height-l)},e}(QO),jke=function(t){function e(n){var r=t.call(this,n)||this;return r.keypointThreshold=n.keypointTrackerParams.keypointConfidenceThreshold,r.keypointFalloff=n.keypointTrackerParams.keypointFalloff,r.minNumKeyoints=n.keypointTrackerParams.minNumberOfKeypoints,r}return VO(e,t),e.prototype.computeSimilarity=function(n){if(n.length===0||this.tracks.length===0)return[[]];for(var r=[],s=0,o=n;s<o.length;s++){for(var i=o[s],a=[],l=0,c=this.tracks;l<c.length;l++){var d=c[l];a.push(this.oks(i,d))}r.push(a)}return r},e.prototype.oks=function(n,r){for(var s=this.area(r.keypoints)+1e-6,o=0,i=0,a=0;a<n.keypoints.length;++a){var l=n.keypoints[a],c=r.keypoints[a];if(!(l.score<this.keypointThreshold||c.score<this.keypointThreshold)){i+=1;var d=Math.pow(l.x-c.x,2)+Math.pow(l.y-c.y,2),f=2*this.keypointFalloff[a];o+=Math.exp(-1*d/(2*s*Math.pow(f,2)))}}return i<this.minNumKeyoints?0:o/i},e.prototype.area=function(n){var r=this,s=n.filter(function(l){return l.score>r.keypointThreshold}),o=Math.min.apply(Math,bu([1],s.map(function(l){return l.x}),!1)),i=Math.max.apply(Math,bu([0],s.map(function(l){return l.x}),!1)),a=Math.min.apply(Math,bu([1],s.map(function(l){return l.y}),!1));return(i-o)*(Math.max.apply(Math,bu([0],s.map(function(l){return l.y}),!1))-a)},e}(QO);function Gke(t){switch(t){case vi.BlazePose:return Af.reduce(function(e,n,r){return e[n]=r,e},{});case vi.PoseNet:case vi.MoveNet:return Si.reduce(function(e,n,r){return e[n]=r,e},{});default:throw new Error("Model ".concat(t," is not supported."))}}(function(t){t.Keypoint="keypoint",t.BoundingBox="boundingBox"})(Iu||(Iu={})),function(t){t.MoveNet="MoveNet",t.BlazePose="BlazePose",t.PoseNet="PoseNet"}(vi||(vi={}));var qE=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],ZO={modelType:"SinglePose.Lightning",enableSmoothing:!0},YE={},QE={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},dx={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},ZE={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function Hke(t,e,n,r){for(var s={},o=0,i=Si;o<i.length;o++){var a=i[o];s[a]=[e[n[a]].y*r.height,e[n[a]].x*r.width]}if(function($,I){return($[I.left_hip].score>.2||$[I.right_hip].score>.2)&&($[I.left_shoulder].score>.2||$[I.right_shoulder].score>.2)}(e,n)){var l=(s.left_hip[0]+s.right_hip[0])/2,c=(s.left_hip[1]+s.right_hip[1])/2,d=function($,I,R,_,F){for(var O=["left_shoulder","right_shoulder","left_hip","right_hip"],M=0,B=0,V=0;V<O.length;V++)(ye=Math.abs(_-R[O[V]][0]))>M&&(M=ye),(ve=Math.abs(F-R[O[V]][1]))>B&&(B=ve);for(var A=0,re=0,ae=0,pe=Object.keys(R);ae<pe.length;ae++){var ye,ve,$e=pe[ae];$[I[$e]].score<.2||((ye=Math.abs(_-R[$e][0]))>A&&(A=ye),(ve=Math.abs(F-R[$e][1]))>re&&(re=ve))}return[M,B,A,re]}(e,n,s,l,c),f=d[0],p=d[1],g=d[2],y=d[3],x=Math.max(1.9*p,1.9*f,1.2*g,1.2*y),w=[l-(x=Math.min(x,Math.max(c,r.width-c,l,r.height-l))),c-x];if(x>Math.max(r.width,r.height)/2)return Vv(t==null,r);var S=2*x;return{yMin:w[0]/r.height,xMin:w[1]/r.width,yMax:(w[0]+S)/r.height,xMax:(w[1]+S)/r.width,height:(w[0]+S)/r.height-w[0]/r.height,width:(w[1]+S)/r.width-w[1]/r.width}}return Vv(t==null,r)}function Vv(t,e){var n,r,s,o;return t?e.width>e.height?(n=1,r=e.height/e.width,s=0,o=(e.width/2-e.height/2)/e.width):(n=e.width/e.height,r=1,s=(e.height/2-e.width/2)/e.height,o=0):e.width>e.height?(n=e.width/e.height,r=1,s=(e.height/2-e.width/2)/e.height,o=0):(n=1,r=e.height/e.width,s=0,o=(e.width/2-e.height/2)/e.width),{yMin:s,xMin:o,yMax:s+n,xMax:o+r,height:n,width:r}}function Kke(t){var e,n=t==null?ZO:Yt({},t);if(n.modelType==null)n.modelType="SinglePose.Lightning";else if(qE.indexOf(n.modelType)<0)throw new Error("Invalid architecture ".concat(n.modelType,". ")+"Should be one of ".concat(qE));if(n.enableSmoothing==null&&(n.enableSmoothing=!0),n.minPoseScore!=null&&(n.minPoseScore<0||n.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(n.multiPoseMaxDimension!=null&&(n.multiPoseMaxDimension%32!=0||n.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(n.modelType==="MultiPose.Lightning"&&n.enableTracking==null&&(n.enableTracking=!0),n.modelType==="MultiPose.Lightning"&&n.enableTracking===!0)if(n.trackerType==null&&(n.trackerType=Iu.BoundingBox),n.trackerType===Iu.Keypoint)n.trackerConfig!=null?n.trackerConfig=function(r){var s=JE(dx,r);return s.keypointTrackerParams=Yt({},dx.keypointTrackerParams),r.keypointTrackerParams!=null&&(r.keypointTrackerParams.keypointConfidenceThreshold!=null&&(s.keypointTrackerParams.keypointConfidenceThreshold=r.keypointTrackerParams.keypointConfidenceThreshold),r.keypointTrackerParams.keypointFalloff!=null&&(s.keypointTrackerParams.keypointFalloff=r.keypointTrackerParams.keypointFalloff),r.keypointTrackerParams.minNumberOfKeypoints!=null&&(s.keypointTrackerParams.minNumberOfKeypoints=r.keypointTrackerParams.minNumberOfKeypoints)),s}(n.trackerConfig):n.trackerConfig=dx;else{if(n.trackerType!==Iu.BoundingBox)throw new Error("Tracker type not supported by MoveNet");n.trackerConfig!=null?n.trackerConfig=(e=n.trackerConfig,JE(ZE,e)):n.trackerConfig=ZE}return n}function JE(t,e){var n={maxTracks:t.maxTracks,maxAge:t.maxAge,minSimilarity:t.minSimilarity};return e.maxTracks!=null&&(n.maxTracks=e.maxTracks),e.maxAge!=null&&(n.maxAge=e.maxAge),e.minSimilarity!=null&&(n.minSimilarity=e.minSimilarity),n}var Xke=function(){function t(e,n){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=Gke(vi.MoveNet),n.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):n.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=n.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new Mv(QE),this.cropRegionFilterYMin=new ll(.9),this.cropRegionFilterXMin=new ll(.9),this.cropRegionFilterYMax=new ll(.9),this.cropRegionFilterXMax=new ll(.9)),this.enableSmoothing=n.enableSmoothing,n.minPoseScore?this.minPoseScore=n.minPoseScore:this.minPoseScore=.25,n.multiPoseMaxDimension?this.multiPoseMaxDimension=n.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=n.enableTracking,this.multiPoseModel&&this.enableTracking&&(n.trackerType===Iu.Keypoint?this.tracker=new jke(n.trackerConfig):n.trackerType===Iu.BoundingBox&&(this.tracker=new Uke(n.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return t.prototype.runSinglePersonPoseModel=function(e){return vt(this,void 0,void 0,function(){var n,r,s,o,i;return bt(this,function(a){switch(a.label){case 0:if((n=this.moveNetModel.execute(e)).shape.length!==4||n.shape[0]!==1||n.shape[1]!==1||n.shape[2]!==17||n.shape[3]!==3)throw n.dispose(),new Error("Unexpected output shape from model: [".concat(n.shape,"]"));return gf()==="webgpu"?[3,1]:(r=n.dataSync(),[3,3]);case 1:return[4,n.data()];case 2:r=a.sent(),a.label=3;case 3:for(n.dispose(),s={keypoints:[],score:0},o=0,i=0;i<17;++i)s.keypoints[i]={y:r[3*i],x:r[3*i+1],score:r[3*i+2]},s.keypoints[i].score>.2&&(++o,s.score+=s.keypoints[i].score);return o>0&&(s.score/=o),[2,s]}})})},t.prototype.runMultiPersonPoseModel=function(e){return vt(this,void 0,void 0,function(){var n,r,s,o,i,a,l,c;return bt(this,function(d){switch(d.label){case 0:if((n=this.moveNetModel.execute(e)).shape.length!==3||n.shape[0]!==1||n.shape[2]!==56)throw n.dispose(),new Error("Unexpected output shape from model: [".concat(n.shape,"]"));return gf()==="webgpu"?[3,1]:(r=n.dataSync(),[3,3]);case 1:return[4,n.data()];case 2:r=d.sent(),d.label=3;case 3:for(n.dispose(),s=[],o=r.length/56,i=0;i<o;++i)for(s[i]={keypoints:[]},a=56*i+51,s[i].box={yMin:r[a],xMin:r[a+1],yMax:r[a+2],xMax:r[a+3],width:r[a+3]-r[a+1],height:r[a+2]-r[a]},l=56*i+55,s[i].score=r[l],s[i].keypoints=[],c=0;c<17;++c)s[i].keypoints[c]={y:r[56*i+3*c],x:r[56*i+3*c+1],score:r[56*i+3*c+2]};return[2,s]}})})},t.prototype.estimatePoses=function(e,n,r){return n===void 0&&(n=YE),vt(this,void 0,void 0,function(){var s,o,i,a,l,c;return bt(this,function(d){switch(d.label){case 0:return n=function(f){return f==null?YE:Yt({},f)}(n),e==null?(this.reset(),[2,[]]):(r==null?qO(e)&&(r=1e6*e.currentTime):r*=1e3,s=WC(e),o=md(s),i=Es(s,0),e instanceof hn||s.dispose(),a=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(i,o,r)]);case 1:return a=d.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(i,o,r)];case 3:a=d.sent(),d.label=4;case 4:for(l=0;l<a.length;++l)for(c=0;c<a[l].keypoints.length;++c)a[l].keypoints[c].name=Si[c],a[l].keypoints[c].y*=o.height,a[l].keypoints[c].x*=o.width;return[2,a]}})})},t.prototype.estimateSinglePose=function(e,n,r){return vt(this,void 0,void 0,function(){var s,o,i,a,l=this;return bt(this,function(c){switch(c.label){case 0:return this.cropRegion||(this.cropRegion=Vv(this.cropRegion==null,n)),s=tt(function(){var d=lo([[l.cropRegion.yMin,l.cropRegion.xMin,l.cropRegion.yMax,l.cropRegion.xMax]]),f=ma([1],"int32"),p=[l.modelInputResolution.height,l.modelInputResolution.width];return Qt(ku.cropAndResize(e,d,f,p,"bilinear",0),"int32")}),e.dispose(),[4,this.runSinglePersonPoseModel(s)];case 1:if(o=c.sent(),s.dispose(),o.score<this.minPoseScore)return this.reset(),[2,[]];for(i=0;i<o.keypoints.length;++i)o.keypoints[i].y=this.cropRegion.yMin+o.keypoints[i].y*this.cropRegion.height,o.keypoints[i].x=this.cropRegion.xMin+o.keypoints[i].x*this.cropRegion.width;return r!=null&&this.enableSmoothing&&(o.keypoints=this.keypointFilter.apply(o.keypoints,r,1)),a=Hke(this.cropRegion,o.keypoints,this.keypointIndexByName,n),this.cropRegion=this.filterCropRegion(a),[2,[o]]}})})},t.prototype.estimateMultiplePoses=function(e,n,r){return vt(this,void 0,void 0,function(){var s,o,i,a,l,c,d,f,p,g,y,x=this;return bt(this,function(w){switch(w.label){case 0:return n.width>n.height?(o=this.multiPoseMaxDimension,i=Math.round(this.multiPoseMaxDimension*n.height/n.width),s=ku.resizeBilinear(e,[i,o]),l=o,c=32*Math.ceil(i/32),a=yl(s,[[0,0],[0,c-i],[0,0],[0,0]])):(o=Math.round(this.multiPoseMaxDimension*n.width/n.height),i=this.multiPoseMaxDimension,s=ku.resizeBilinear(e,[i,o]),l=32*Math.ceil(o/32),c=i,a=yl(s,[[0,0],[0,0],[0,l-o],[0,0]])),s.dispose(),e.dispose(),d=Qt(a,"int32"),a.dispose(),[4,this.runMultiPersonPoseModel(d)];case 1:for(f=w.sent(),d.dispose(),f=f.filter(function(S){return S.score>=x.minPoseScore}),g=0;g<f.length;++g)for(p=0;p<f[g].keypoints.length;++p)f[g].keypoints[p].y*=c/i,f[g].keypoints[p].x*=l/o;if(this.enableTracking&&(this.tracker.apply(f,r),this.enableSmoothing)){for(g=0;g<f.length;++g)this.keypointFilterMap.has(f[g].id)||this.keypointFilterMap.set(f[g].id,new Mv(QE)),f[g].keypoints=this.keypointFilterMap.get(f[g].id).apply(f[g].keypoints,r,1);y=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(S,$){y.has($)||x.keypointFilterMap.delete($)})}return[2,f]}})})},t.prototype.filterCropRegion=function(e){if(e){var n=this.cropRegionFilterYMin.apply(e.yMin),r=this.cropRegionFilterXMin.apply(e.xMin),s=this.cropRegionFilterYMax.apply(e.yMax),o=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:n,xMin:r,yMax:s,xMax:o,height:s-n,width:o-r}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},t.prototype.dispose=function(){this.moveNetModel.dispose()},t.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},t.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},t}();function qke(t){return t===void 0&&(t=ZO),vt(this,void 0,void 0,function(){var e,n,r,s;return bt(this,function(o){switch(o.label){case 0:return e=Kke(t),r=!0,e.modelUrl?(r=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,fd(e.modelUrl,{fromTFHub:r})]):[3,2];case 1:return n=o.sent(),[3,4];case 2:return s=void 0,e.modelType==="SinglePose.Lightning"?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":e.modelType==="SinglePose.Thunder"?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":e.modelType==="MultiPose.Lightning"&&(s="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,fd(s,{fromTFHub:r})];case 3:n=o.sent(),o.label=4;case 4:return gf()==="webgl"&&oe().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new Xke(n,e)]}})})}var e3={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},t3=["MobileNetV1","ResNet50"],n3={MobileNetV1:[8,16],ResNet50:[16]},Yke=[8,16,32],r3={MobileNetV1:[.5,.75,1],ResNet50:[1]},s3=[1,2,4],o3={maxPoses:1,flipHorizontal:!1},Qke={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},Zke=[-123.15,-115.9,-103.06];function hx(t){return Math.floor(t/2)}var Jke=function(){function t(e,n){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=n}return t.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},t.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},t.prototype.empty=function(){return this.numberOfElements===-1},t.prototype.size=function(){return this.numberOfElements+1},t.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},t.prototype.max=function(){return this.priorityQueue[0]},t.prototype.swim=function(e){for(;e>0&&this.less(hx(e),e);)this.exchange(e,hx(e)),e=hx(e)},t.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var n=2*e;if(n<this.numberOfElements&&this.less(n,n+1)&&n++,!this.less(e,n))break;this.exchange(e,n),e=n}},t.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},t.prototype.less=function(e,n){return this.getValueAt(e)<this.getValueAt(n)},t.prototype.exchange=function(e,n){var r=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[n],this.priorityQueue[n]=r},t}();function eTe(t,e,n,r,s,o){for(var i=o.shape,a=i[0],l=i[1],c=!0,d=Math.max(n-s,0),f=Math.min(n+s+1,a),p=d;p<f;++p){for(var g=Math.max(r-s,0),y=Math.min(r+s+1,l),x=g;x<y;++x)if(o.get(p,x,t)>e){c=!1;break}if(!c)break}return c}function tTe(t){return vt(this,void 0,void 0,function(){return bt(this,function(e){return[2,Promise.all(t.map(function(n){return n.buffer()}))]})})}function JO(t,e,n,r){return{y:r.get(t,e,n),x:r.get(t,e,n+17)}}function e4(t,e,n){var r=JO(t.heatmapY,t.heatmapX,t.id,n),s=r.y,o=r.x;return{x:t.heatmapX*e+o,y:t.heatmapY*e+s}}function t4(t,e,n,r){var s=n.x,o=n.y;return t.some(function(i){var a,l,c,d,f,p,g=i.keypoints;return a=o,l=s,c=g[r].y,d=g[r].x,(f=c-a)*f+(p=d-l)*p<=e})}var i3=Si.reduce(function(t,e,n){return t[e]=n,t},{}),n4=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(t){var e=t[0],n=t[1];return[i3[e],i3[n]]}),fx=n4.map(function(t){return t[1]}),a3=n4.map(function(t){return t[0]});function l3(t,e,n){return t<e?e:t>n?n:t}function px(t,e,n,r){return{y:l3(Math.round(t.y/e),0,n-1),x:l3(Math.round(t.x/e),0,r-1)}}function u3(t,e){return{x:t.x+e.x,y:t.y+e.y}}function c3(t,e,n,r,s,o,i,a){a===void 0&&(a=2);for(var l=r.shape,c=l[0],d=l[1],f={y:e.y,x:e.x},p=u3(f,function($,I,R){var _=R.shape[2]/2;return{y:R.get(I.y,I.x,$),x:R.get(I.y,I.x,_+$)}}(t,px(f,o,c,d),i)),g=0;g<a;g++){var y=px(p,o,c,d),x=JO(y.y,y.x,n,s);p=u3({x:y.x*o,y:y.y*o},{x:x.x,y:x.y})}var w=px(p,o,c,d),S=r.get(w.y,w.x,n);return{y:p.y,x:p.x,name:Si[n],score:S}}function nTe(t,e,n,r,s,o){var i=e.shape[2],a=fx.length,l=new Array(i),c=t.part,d=t.score,f=e4(c,r,n);l[c.id]={score:d,name:Si[c.id],y:f.y,x:f.x};for(var p=a-1;p>=0;--p){var g=fx[p],y=a3[p];l[g]&&!l[y]&&(l[y]=c3(p,l[g],y,e,n,r,o))}for(p=0;p<a;++p)g=a3[p],y=fx[p],l[g]&&!l[y]&&(l[y]=c3(p,l[g],y,e,n,r,s));return l}function rTe(t,e,n){return n.reduce(function(r,s,o){var i=s.y,a=s.x,l=s.score;return t4(t,e,{y:i,x:a},o)||(r+=l),r},0)/n.length}function sTe(t,e,n,r,s,o,i,a){return i===void 0&&(i=.5),a===void 0&&(a=20),vt(this,void 0,void 0,function(){var l,c,d,f,p,g,y,x,w,S,$,I;return bt(this,function(R){switch(R.label){case 0:return[4,tTe([t,e,n,r])];case 1:for(l=R.sent(),c=l[0],d=l[1],f=l[2],p=l[3],g=[],y=function(_,F,O){for(var M=O.shape,B=M[0],V=M[1],A=M[2],re=new Jke(B*V*A,function($e){return $e.score}),ae=0;ae<B;++ae)for(var pe=0;pe<V;++pe)for(var ye=0;ye<A;++ye){var ve=O.get(ae,pe,ye);ve<_||eTe(ye,ve,ae,pe,F,O)&&re.enqueue({score:ve,part:{heatmapY:ae,heatmapX:pe,id:ye}})}return re}(i,1,c),x=a*a;g.length<o&&!y.empty();)w=y.dequeue(),S=e4(w.part,s,d),t4(g,x,S,w.part.id)||($=nTe(w,c,d,s,f,p),I=rTe(g,x,$),g.push({keypoints:$,score:I}));return[2,g]}})})}function r4(){for(var t,e=[],n=0;n<arguments.length;n++)e[n]=arguments[n];switch(e.length){case 0:t="fn main() ";break;case 1:t="fn main(".concat(e[0]," : i32)");break;default:throw Error("Unreachable")}return t}var oTe=function(){function t(e){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[e[0],1],this.dispatchLayout=De(this.outputShape),this.dispatch=Re(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return t.prototype.getUserCode=function(){return`
        `.concat(r4("index"),` {
          if (index < uniforms.size) {
            let y = B[index * 2];
            let x = B[index * 2 + 1];
            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;
            result[index] = A[outIndex];
          }
        }
        `)},t}();function iTe(t,e){if(ud()instanceof Fd)return function(n,r){var s=ud(),o=new oTe(r.shape),i=s.runWebGPUProgram(o,[n,r],"float32");return cs().makeTensorFromTensorInfo(i)}(t,e);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}var aTe=function(){function t(e){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,e.length!==2||e[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(e));this.workgroupSize=[32,1,1],this.outputShape=e;var n=[e[0],1];this.dispatchLayout=De(n),this.dispatch=Re(this.dispatchLayout,n,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return t.prototype.getUserCode=function(){return`
    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {
      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;
      let outIndexX = outIndexY + uniforms.bShape.z;
      let outY = i32(B[outIndexY]);
      let outX = i32(B[outIndexX]);
      return vec2<i32>(outY, outX);
    }

    `.concat(r4("index"),` {
      if (index < uniforms.size) {
        let indexY = index * `).concat(this.supportedLastDimension,`;
        let indexX = indexY + 1;
        let heatmapY = A[indexY];
        let heatmapX = A[indexX];
        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);
        result[indexY] = f32(out[0]);
        result[indexX] = f32(out[1]);
      }
    }
    `)},t}();function lTe(t,e){if(ud()instanceof Fd)return function(n,r){var s=ud(),o=new aTe(n.shape),i=s.runWebGPUProgram(o,[n,r],"float32");return cs().makeTensorFromTensorInfo(i)}(t,e);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}function s4(t){var e=t.shape,n=e[0],r=e[1],s=e[2];return tt(function(){var o,i,a=xe(t,[n*r,s]),l=YA(a,0),c=Es(gt(l,pt(r,"int32")),1),d=Es((o=l,i=r,tt(function(){var f=gt(o,pt(i,"int32"));return ot(o,Te(f,pt(i,"int32")))})),1);return On([c,d],1)})}function uTe(t,e,n){return tt(function(){var r=function(s,o){for(var i=[],a=0;a<Si.length;a++){var l=s.get(a,0).valueOf(),c=s.get(a,1).valueOf(),d=cTe(l,c,a,o),f=d.x,p=d.y;i.push(p),i.push(f)}return lo(i,[Si.length,2])}(t,n);return Ue(Qt(Te(t.toTensor(),pt(e,"int32")),"float32"),r)})}function cTe(t,e,n,r){return{y:r.get(t,e,n),x:r.get(t,e,n+Si.length)}}function dTe(t,e,n){return vt(this,void 0,void 0,function(){var r,s,o,i,a,l,c,d,f,p;return bt(this,function(g){switch(g.label){case 0:return r=0,s=s4(t),[4,Promise.all([t.buffer(),e.buffer(),s.buffer()])];case 1:return o=g.sent(),i=o[0],a=o[1],l=o[2],[4,(c=uTe(l,n,a)).buffer()];case 2:return d=g.sent(),f=Array.from(function(y,x){for(var w=x.shape[0],S=new Float32Array(w),$=0;$<w;$++){var I=x.get($,0),R=x.get($,1);S[$]=y.get(I,R,$)}return S}(i,l)),p=f.map(function(y,x){return r+=y,{y:d.get(x,0),x:d.get(x,1),score:y,name:Si[x]}}),s.dispose(),c.dispose(),[2,{keypoints:p,score:r/p.length}]}})})}function hTe(t,e,n){return vt(this,void 0,void 0,function(){var r,s,o;return bt(this,function(i){return r=s4(t),s=function(a,l,c){return tt(function(){var d=lTe(a,c);return Ue(Qt(Te(a,pt(l,"int32")),"float32"),d)})}(r,n,e),o=iTe(t,r),[2,[s,o]]})})}function d3(t,e){return(t-1)%e==0}var h3="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",f3="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function p3(t,e){return function(n,r){return(n-1)%r==0}(t,e)?t:Math.floor(t/e)*e+1}var m3=function(){function t(e,n){this.posenetModel=e;var r=this.posenetModel.inputs[0].shape;z(r[1]===-1&&r[2]===-1,function(){return"Input shape [".concat(r[1],", ").concat(r[2],"] ")+"must both be equal to or -1"});var s,o,i=(s=n.inputResolution,o=n.outputStride,{height:p3(s.height,o),width:p3(s.width,o)});(function(a){z(Yke.indexOf(a)>=0,function(){return"outputStride of ".concat(a," is invalid. ")+"It must be either 8 or 16."})})(n.outputStride),function(a,l){z(d3(a.height,l),function(){return"height of ".concat(a.height," is invalid for output stride ")+"".concat(l,".")}),z(d3(a.width,l),function(){return"width of ".concat(a.width," is invalid for output stride ")+"".concat(l,".")})}(i,n.outputStride),this.inputResolution=i,this.outputStride=n.outputStride,this.architecture=n.architecture}return t.prototype.estimatePoses=function(e,n){return n===void 0&&(n=o3),vt(this,void 0,void 0,function(){return bt(this,function(r){return[2,this.estimatePosesGPU(e,n,!1)]})})},t.prototype.estimatePosesGPU=function(e,n,r){return n===void 0&&(n=o3),r===void 0&&(r=!1),vt(this,void 0,void 0,function(){var s,o,i,a,l,c,d,f,p,g,y,x,w,S,$,I,R,_;return bt(this,function(F){switch(F.label){case 0:return s=function(O){var M=O;if(M.maxPoses==null&&(M.maxPoses=1),M.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(M.maxPoses,". Should be > 0."));if(M.maxPoses>1){if((M=Yt(Yt({},Qke),M)).scoreThreshold<0||M.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(M.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(M.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(M.nmsRadius,"."))}return M}(n),e==null?[2,r?[[],[]]:[]]:(this.maxPoses=s.maxPoses,o=Bv(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),i=o.imageTensor,a=o.padding,l=this.architecture==="ResNet50"?Ue(i,Zke):XO(i,[-1,1]),c=this.posenetModel.predict(l),this.architecture==="ResNet50"?(d=Gt(c[2],[0]),f=Gt(c[3],[0]),p=Gt(c[0],[0]),g=Gt(c[1],[0])):(d=Gt(c[0],[0]),f=Gt(c[1],[0]),p=Gt(c[2],[0]),g=Gt(c[3],[0])),y=sa(f),this.maxPoses!==1?[3,5]:r?[4,hTe(y,d,this.outputStride)]:[3,2]);case 1:return w=F.sent(),$=w[0],S=w[1],x=[$,S],[3,4];case 2:return[4,dTe(y,d,this.outputStride)];case 3:$=F.sent(),x=[$],F.label=4;case 4:return[3,7];case 5:if(r)throw new Error("GPU renderer only supports single pose!");return[4,sTe(y,d,p,g,this.outputStride,this.maxPoses,s.scoreThreshold,s.nmsRadius)];case 6:x=F.sent(),F.label=7;case 7:if(r){if(s.flipHorizontal===!0)throw new Error("flipHorizontal is not supported!");I=this.getCanvasInfo(md(e),this.inputResolution,a)}else _=md(e),R=function(O,M,B,V){var A=M.height,re=M.width,ae=A/(B.height*(1-V.top-V.bottom)),pe=re/(B.width*(1-V.left-V.right)),ye=-V.top*B.height,ve=-V.left*B.width;if(pe===1&&ae===1&&ye===0&&ve===0)return O;for(var $e=0,se=O;$e<se.length;$e++)for(var me=0,ge=se[$e].keypoints;me<ge.length;me++){var Q=ge[me];Q.x=(Q.x+ve)*pe,Q.y=(Q.y+ye)*ae}return O}(x,_,this.inputResolution,a),s.flipHorizontal&&(R=function(O,M){for(var B=0,V=O;B<V.length;B++)for(var A=0,re=V[B].keypoints;A<re.length;A++){var ae=re[A];ae.x=M.width-1-ae.x}return O}(R,_));return i.dispose(),l.dispose(),Bt(c),d.dispose(),f.dispose(),p.dispose(),g.dispose(),y.dispose(),[2,r?[x,I]:R]}})})},t.prototype.getCanvasInfo=function(e,n,r){var s=e.height,o=e.width,i=s/(n.height*(1-r.top-r.bottom)),a=o/(n.width*(1-r.left-r.right)),l=-r.top*n.height;return[-r.left*n.width,l,a,i,e.width,e.height]},t.prototype.dispose=function(){this.posenetModel.dispose()},t.prototype.reset=function(){},t}();function fTe(t){return t===void 0&&(t=e3),vt(this,void 0,void 0,function(){var e,n,r,s,o;return bt(this,function(i){switch(i.label){case 0:return(e=function(d){var f=d||e3;if(f.architecture==null&&(f.architecture="MobileNetV1"),t3.indexOf(f.architecture)<0)throw new Error("Invalid architecture ".concat(f.architecture,". ")+"Should be one of ".concat(t3));if(f.inputResolution==null&&(f.inputResolution={height:257,width:257}),f.outputStride==null&&(f.outputStride=16),n3[f.architecture].indexOf(f.outputStride)<0)throw new Error("Invalid outputStride ".concat(f.outputStride,". ")+"Should be one of ".concat(n3[f.architecture]," ")+"for architecture ".concat(f.architecture,"."));if(f.multiplier==null&&(f.multiplier=1),r3[f.architecture].indexOf(f.multiplier)<0)throw new Error("Invalid multiplier ".concat(f.multiplier,". ")+"Should be one of ".concat(r3[f.architecture]," ")+"for architecture ".concat(f.architecture,"."));if(f.quantBytes==null&&(f.quantBytes=4),s3.indexOf(f.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(f.quantBytes,". ")+"Should be one of ".concat(s3," ")+"for architecture ".concat(f.architecture,"."));if(f.architecture==="MobileNetV1"&&f.outputStride===32&&f.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return f}(t)).architecture!=="ResNet50"?[3,2]:(a=e.outputStride,l=e.quantBytes,c="model-stride".concat(a,".json"),n=l===4?f3+"float/"+c:f3+"quant".concat(l,"/")+c,[4,fd(e.modelUrl||n)]);case 1:return r=i.sent(),[2,new m3(r,e)];case 2:return s=function(d,f,p){var g={1:"100",.75:"075",.5:"050"},y="model-stride".concat(d,".json");return p===4?h3+"float/".concat(g[f],"/")+y:h3+"quant".concat(p,"/").concat(g[f],"/")+y}(e.outputStride,e.multiplier,e.quantBytes),[4,fd(e.modelUrl||s)];case 3:return o=i.sent(),[2,new m3(o,e)]}var a,l,c})})}function pTe(t,e){return vt(this,void 0,void 0,function(){var n,r;return bt(this,function(s){switch(t){case vi.PoseNet:return[2,fTe(e)];case vi.BlazePose:if(r=void 0,(n=e)!=null){if(n.runtime==="tfjs")return[2,Wke(e)];if(n.runtime==="mediapipe")return[2,pke(e)];r=n.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(r));case vi.MoveNet:return[2,qke(e)];default:throw new Error("".concat(t," is not a supported model name."))}})})}var mTe={modelType:{SINGLEPOSE_LIGHTNING:"SinglePose.Lightning"}};const g3={150:{Shoulder:[16.5,16.5722,16.5856,16.6229,16.3468,16.3576,16.5433,16.6389,16.6642],ApexHeight:[8,8.0395,7.9894,7.9358,8.0214,8.0596,7.991,8.031,8.0645],ApexDistance:[6.75,6.6887,6.79,6.7221,6.7331,6.7022,6.7542,6.7589,6.7895],FullLength:[18,17.8812,17.8484,18.1335,18.0431,17.9067,18.1486,17.8715,17.986],SleeveLength:[8,7.9606,7.9609,7.9215,8.0487,8.0642,8.0284,7.9453,7.9907],LowerArmGirth:[13,12.9598,13.0228,13.0361,12.9803,12.935,13.0898,12.9218,12.97],Waist:[29,28.9903,28.8476,29.0417,29.0434,29.2858,28.8812,29.2772,29.0918],Hip:[null,null,null,null,null,null,null,null,null],Thigh:[null,null,null,null,null,null,null,null,null],BodyFigure:[34.5,34.3444,34.5455,34.6282,34.6688,34.1888,34.5734,34.4977,34.7789],Knee:[17.5,17.4252,17.6046,17.5375,17.4483,17.5478,17.5423,17.5622,17.5773],Crotch:[10.25,10.2826,10.3194,10.2763,10.3327,10.28,10.2108,10.2379,10.2663],Bottomline:[18.5,18.586,18.3483,18.4242,18.5916,18.38,18.3639,18.5146,18.6745]},155:{Shoulder:[15,14.8806,15.0817,15.1051,15.0301,14.8863,15.1452,15.0848,14.9542],ApexHeight:[9.5,9.4864,9.4754,9.5011,9.4698,9.5664,9.5612,9.4251,9.5875],ApexDistance:[7,7.019,7.046,7.029,6.991,7.0327,7.0652,6.9678,7.0431],FullLength:[21,21.016,20.9931,20.9729,21.097,20.9027,21.1477,21.1389,20.8264],SleeveLength:[10,10.0763,9.9488,9.9929,10.0221,9.9758,9.9057,10.0702,9.9364],LowerArmGirth:[11,10.9367,11.0655,10.9649,11.0837,11.0443,10.9508,10.8922,11.0986],Waist:[31,30.7431,31.1364,30.9929,31.1601,31.1182,31.0905,30.9943,31.1816],Hip:[37.25,36.9468,37.0426,37.3929,37.1056,37.3108,37.2301,37.273,37.1945],Thigh:[17.5,17.5861,17.4408,17.571,17.4198,17.413,17.3672,17.3924,17.3668],BodyFigure:[23.125,23.1416,23.2463,22.9794,22.9938,23.1177,23.2289,23.3454,23.1364],Knee:[18.5,18.4197,18.3522,18.3868,18.3992,18.3814,18.3202,18.5126,18.4165],Crotch:[11,11.1043,11.0117,11.0434,10.9178,11.0811,10.998,11.082,11.0163],Bottomline:[19.5,19.4881,19.4768,19.3769,19.325,19.672,19.4913,19.6256,19.4613]},157:{Shoulder:[17,16.8552,17.044,16.8482,16.8807,17.0214,16.9333,17.1679,16.8703],ApexHeight:[10,10.0529,10.0213,10.0581,9.9451,10.0045,9.9901,9.9885,10.072],ApexDistance:[8.5,8.5833,8.4669,8.5206,8.5186,8.5408,8.5761,8.4503,8.4509],FullLength:[22,22.0706,21.8491,21.8565,21.813,21.7812,21.9782,22.0413,21.9082],SleeveLength:[10,9.9463,10.0414,10.0406,9.9908,10.0375,10.0848,10.0576,10.025],LowerArmGirth:[12.5,12.5403,12.6084,12.4813,12.5111,12.5369,12.6021,12.5817,12.3929],Waist:[31.5,31.2895,31.3788,31.6568,31.5436,31.3668,31.2633,31.6189,31.6258],Hip:[36.25,36.5709,36.2503,36.2455,35.9458,35.9164,36.2007,36.1212,36.069],Thigh:[21.5,21.3243,21.6986,21.6445,21.5323,21.6938,21.7148,21.5741,21.4009],BodyFigure:[36,35.669,36.1845,35.9788,36.1091,36.2996,35.7707,36.0614,36.097],Knee:[18.5,18.4969,18.3488,18.4437,18.4383,18.5629,18.6324,18.437,18.5717],Crotch:[11.5,11.4513,11.6024,11.5721,11.5115,11.4896,11.4573,11.4594,11.6081],Bottomline:[19.5,19.4626,19.5057,19.6904,19.5615,19.5166,19.4662,19.3782,19.4461]},158:{Shoulder:[17,17.0872,17.0426,17.0884,16.8992,17.0167,17.1454,16.979,17.0674],ApexHeight:[10.5,10.4205,10.5994,10.5229,10.4453,10.4283,10.5107,10.511,10.4146],ApexDistance:[8,8.0788,8.0661,7.9938,7.9388,8.0531,7.9997,8.0347,8.0014],FullLength:[21,20.9048,21.1406,21.2017,20.8924,21.0215,20.9511,21.1772,21.0035],SleeveLength:[8.25,8.3126,8.3101,8.2131,8.2979,8.236,8.3217,8.2513,8.3029],LowerArmGirth:[15.5,15.4327,15.4376,15.527,15.6547,15.4968,15.3911,15.512,15.452],Waist:[39.5,39.541,39.5343,39.4647,39.3592,39.254,39.656,39.5567,39.2895],Hip:[null,null,null,null,null,null,null,null,null],Thigh:[null,null,null,null,null,null,null,null,null],BodyFigure:[43,43.237,42.6075,43.2104,43.1765,43.2678,42.902,43.1408,43.2758],Knee:[20,20.1923,19.9981,19.8148,20.0009,20.0361,20.1479,20.1497,19.9761],Crotch:[12.5,12.5065,12.4892,12.5556,12.4775,12.5387,12.4136,12.4924,12.6173],Bottomline:[21,20.9322,21.0809,21.0629,21.1477,21.148,21.1509,20.9496,20.923]},159:{Shoulder:[14.5,14.5959,14.5139,14.6152,14.5707,14.4927,14.4302,14.4267,14.5399],ApexHeight:[7,7.0372,7.003,7.0177,6.9684,6.9408,6.97,6.968,6.9748],ApexDistance:[7,7.0056,6.9494,6.9624,7.0272,7.0289,6.939,6.9871,7.006],FullLength:[19,18.968,18.8886,18.9697,19.1538,19.032,19.0743,19.1356,19.1009],SleeveLength:[7,6.9833,6.9308,6.9792,7.0355,7.0495,7.0635,6.9887,7.0347],LowerArmGirth:[11.5,11.5106,11.5237,11.4357,11.4355,11.4852,11.3917,11.4623,11.5412],Waist:[30,29.9426,29.799,29.9804,29.7766,30.0734,29.7162,29.9364,30.0386],Hip:[40,39.6217,40.1142,39.7086,39.9694,39.6402,39.9033,39.7693,39.8615],Thigh:[22.125,22.2406,22.0715,22.2365,22.2719,22.0154,21.94,21.9123,22.1424],BodyFigure:[36,36.3599,35.892,36.1081,36.2025,36.1093,36.183,36.3237,35.7835],Knee:[18.5,18.3225,18.3714,18.3617,18.5627,18.5237,18.3956,18.5738,18.5988],Crotch:[11.5,11.4236,11.5247,11.557,11.4113,11.5734,11.6069,11.4099,11.3909],Bottomline:[19.5,19.4267,19.5692,19.6787,19.4597,19.5839,19.3346,19.5743,19.5496]},162:{Shoulder:[15.5,15.475,15.5259,15.5071,15.6348,15.4083,15.567,15.419,15.4677],ApexHeight:[10,10.0343,9.96,9.9632,10.0504,9.9145,9.9917,10.0997,10.0992],ApexDistance:[8.5,8.4275,8.4512,8.4601,8.5737,8.5647,8.5645,8.4778,8.4418],FullLength:[17,17.1135,17.0692,17.038,17.1657,17.0524,16.8327,17.1078,16.9318],SleeveLength:[8.5,8.5278,8.5746,8.4378,8.4346,8.4332,8.509,8.4613,8.5178],LowerArmGirth:[12.5,12.5544,12.4259,12.5336,12.441,12.4971,12.6013,12.5865,12.3981],Waist:[28.125,28.082,27.9994,27.8457,28.2775,28.2021,27.9911,28.2607,28.1541],Hip:[37.5,37.4458,37.1323,37.1814,37.7873,37.8029,37.5342,37.7509,37.5619],Thigh:[21.375,21.2246,21.2157,21.293,21.5456,21.5016,21.5292,21.5455,21.2511],BodyFigure:[35.125,34.949,34.846,35.3218,35.3949,35.0592,35.2098,34.8823,35.427],Knee:[19,19.1386,19.181,19.1181,19.1449,18.8194,19.0899,18.9362,19.1637],Crotch:[11.5,11.5695,11.5837,11.5715,11.4464,11.5661,11.4099,11.5856,11.5825],Bottomline:[20,19.889,20.1266,19.9841,19.9221,20.1181,19.891,19.8095,19.8773]},163:{Shoulder:[17.5,17.4399,17.6275,17.6634,17.4227,17.5495,17.4649,17.6684,17.5127],ApexHeight:[11.25,11.3488,11.1635,11.3558,11.1777,11.3541,11.1972,11.1619,11.2353],ApexDistance:[7.75,7.7854,7.7211,7.7665,7.7518,7.7322,7.7619,7.712,7.7824],FullLength:[22,21.7807,22.1873,22.0169,22.0965,22.1065,22.0751,21.9403,21.8108],SleeveLength:[9.125,9.155,9.094,9.091,9.1885,9.1651,9.0886,9.0902,9.1083],LowerArmGirth:[14.5,14.4717,14.4407,14.3919,14.4769,14.6277,14.5514,14.6168,14.5335],Waist:[36,35.8567,36.0345,35.6403,35.8466,35.9495,36.0576,36.1114,35.9748],Hip:[42.75,42.7005,42.5052,42.7271,43.093,43.0031,42.4676,42.395,42.7632],Thigh:[24.125,24.1891,24.0455,24.2786,24.2462,24.2084,23.9921,23.9798,23.8955],BodyFigure:[40,39.7959,39.9801,40.2798,39.6583,39.9316,40.1038,39.7555,40.1571],Knee:[19.5,19.4978,19.4002,19.5609,19.3072,19.5979,19.6053,19.3466,19.4708],Crotch:[12.5,12.419,12.6145,12.5045,12.3876,12.4373,12.5871,12.4891,12.5754],Bottomline:[20.5,20.5687,20.7,20.5391,20.6845,20.6605,20.5462,20.5899,20.502]},165:{Shoulder:[17,17.0474,16.8385,16.9235,16.9059,17.0804,17.0601,17.1333,16.8596],ApexHeight:[8.75,8.7363,8.6677,8.7008,8.7509,8.6671,8.6973,8.7762,8.7579],ApexDistance:[7.5,7.4581,7.5134,7.5464,7.426,7.5459,7.5297,7.476,7.4483],FullLength:[17.5,17.66,17.4428,17.3575,17.3589,17.6216,17.5363,17.6075,17.5804],SleeveLength:[5,5.0036,5.0473,4.9879,5.0052,5.0329,5.0119,5.0362,5.0077],LowerArmGirth:[14,14.0573,13.8728,13.9238,13.941,13.8823,13.9252,13.8883,13.9378],Waist:[26,26.0706,25.9297,25.9325,25.8489,25.8788,26.2271,26.077,26.0567],Hip:[33,32.783,33.1512,32.7778,32.9204,33.3231,33.0924,33.0376,33.1218],Thigh:[17,17.1166,17.0938,16.9079,16.8409,16.9373,16.921,16.9017,17.1506],BodyFigure:[32,32.2409,31.8814,32.0995,31.9332,32.2653,31.9737,31.8495,31.8378],Knee:[16.5,16.5203,16.4217,16.5279,16.6313,16.4668,16.4074,16.6642,16.5031],Crotch:[10,9.9182,9.9094,9.9219,10.0255,10.0584,9.9844,9.9127,9.9763],Bottomline:[17.5,17.6736,17.5102,17.6649,17.6263,17.329,17.5773,17.5636,17.5129]},175:{Shoulder:[17,16.9207,17.0479,16.8679,16.9778,16.9843,17.1543,17.1278,16.9196],ApexHeight:[9,9.0001,8.9422,9.0743,9.0667,8.9637,9.025,9.0196,8.9375],ApexDistance:[8,8.042,8.0063,8.0446,8.0049,7.9201,7.9719,7.9231,8.0687],FullLength:[20,20.1515,20.1327,19.923,19.8232,20.1512,20.1788,19.8343,19.9944],SleeveLength:[9,8.9225,9.0469,9.0479,8.9331,8.9956,9.009,8.9577,9.067],LowerArmGirth:[11,10.9831,10.9366,11.0086,11.0506,10.9343,10.9586,11.1089,11.033],Waist:[26.5,26.4672,26.5093,26.2991,26.3541,26.4142,26.5468,26.357,26.3517],Hip:[35,34.6997,35.0918,34.8103,35.2838,35.2517,34.6996,34.8166,35.1183],Thigh:[18.5,18.3943,18.364,18.6611,18.5263,18.4899,18.6053,18.6138,18.3855],BodyFigure:[31,30.7501,30.9573,30.9526,30.9796,31.142,31.1075,31.3002,30.751],Knee:[15,14.9708,14.9518,15.1085,14.9246,14.9071,14.9846,14.9766,14.9336],Crotch:[11,10.945,11.0931,10.9875,11.0795,11.0111,10.9011,11.1098,11.0739],Bottomline:[16,16.1501,16.1364,16.1116,15.8932,15.9954,15.9084,15.9683,15.8588]},176:{Shoulder:[null,null,null,null,null,null,null,null,null],ApexHeight:[null,null,null,null,null,null,null,null,null],ApexDistance:[null,null,null,null,null,null,null,null,null],FullLength:[null,null,null,null,null,null,null,null,null],SleeveLength:[null,null,null,null,null,null,null,null,null],LowerArmGirth:[null,null,null,null,null,null,null,null,null],Waist:[26.5,26.4359,26.7572,26.3756,26.6506,26.4762,26.4592,26.7424,26.7626],Hip:[35.5,35.5396,35.6551,35.2549,35.3557,35.8328,35.5562,35.53,35.6761],Thigh:[18,17.8406,18.0303,18.001,18.127,17.8767,18.1659,17.8488,17.8869],BodyFigure:[32.375,32.4365,32.4885,32.2035,32.1289,32.6277,32.2107,32.4362,32.4523],Knee:[null,null,null,null,null,null,null,null,null],Crotch:[null,null,null,null,null,null,null,null,null],Bottomline:[null,null,null,null,null,null,null,null,null]}},Is={NOSE:0,LEFT_SHOULDER:5,RIGHT_SHOULDER:6,LEFT_HIP:11,RIGHT_HIP:12,LEFT_KNEE:13,RIGHT_KNEE:14,LEFT_ANKLE:15,RIGHT_ANKLE:16},y3=[Is.NOSE,Is.LEFT_SHOULDER,Is.RIGHT_SHOULDER,Is.LEFT_HIP,Is.RIGHT_HIP,Is.LEFT_KNEE,Is.RIGHT_KNEE,Is.LEFT_ANKLE,Is.RIGHT_ANKLE],gTe=.3,x3=5,yTe=1500;function xTe({onNavigate:t}){const e=ee.useRef(null),n=ee.useRef(null),r=ee.useRef(null),s=ee.useRef(null),o=ee.useRef(null),[i,a]=ee.useState(!0),[l,c]=ee.useState(null),[d,f]=ee.useState(null),[p,g]=ee.useState(!1),[y,x]=ee.useState(!1),[w,S]=ee.useState("Initializing camera..."),[$,I]=ee.useState("INITIALIZING"),[R,_]=ee.useState(!1),[F,O]=ee.useState(null),M=zP(),B=ee.useCallback(()=>{s.current&&(clearInterval(s.current),s.current=null),o.current&&(clearTimeout(o.current),o.current=null),O(null)},[]),V=ee.useCallback(async()=>{a(!0),c(null),S("Requesting camera access..."),I("INITIALIZING"),_(!1),B(),d&&(d.getTracks().forEach(se=>se.stop()),f(null));try{const se=await navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"},audio:!1});f(se)}catch(se){console.error(se);let me="Could not access camera.";se.name==="NotAllowedError"?me="Camera permission denied.":se.name==="NotFoundError"?me="No suitable camera found.":se.name==="NotReadableError"?me="Camera already in use.":se instanceof TypeError&&(me="Secure connection required (HTTPS)."),c(me),S("Error initializing camera."),a(!1),I("ERROR")}},[d,B]);ee.useEffect(()=>(V(),()=>{d&&d.getTracks().forEach(se=>se.stop()),cancelAnimationFrame(n.current),B(),r.current&&(r.current.dispose(),r.current=null)}),[V,B,d]);const A=ee.useCallback(se=>{se?(e.current=se,g(!0)):g(!1)},[]),re=ee.useCallback(async()=>{if(!(r.current||l||$==="ERROR"||y)){x(!0),S("Loading pose detection model...");try{await FX("webgl"),await OX();const se=vi.MoveNet,me=await pTe(se,{modelType:mTe.modelType.SINGLEPOSE_LIGHTNING,modelUrl:"https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4"});r.current=me,x(!1),S("Model loaded. Position for FRONT pose."),I("DETECTING_FRONT")}catch(se){console.error(se),c("Failed to load pose detection model."),S("Error loading model."),x(!1),I("ERROR")}}},[l,$,y]);ee.useEffect(()=>{d&&p&&e.current&&!r.current&&!y&&(e.current.srcObject=d,e.current.onloadedmetadata=()=>{a(!1),S("Camera ready. Prepare for FRONT pose."),I("FRONT_PROMPT"),re()},e.current.onerror=se=>{console.error(se),c("Video display error."),I("ERROR")})},[d,p,y,re]);const ae=ee.useCallback(()=>{cancelAnimationFrame(n.current),B();const se=parseInt(localStorage.getItem("userHeight"),10);if(isNaN(se)){M({title:"Error",description:"Could not retrieve height.",status:"error",duration:3e3,isClosable:!0}),t("HEIGHT_INPUT");return}const ge=Object.keys(g3).map(be=>parseInt(be,10)).filter(be=>!isNaN(be)).sort((be,We)=>be-We).reduce((be,We)=>Math.abs(We-se)<Math.abs(be-se)?We:be),Q=g3[ge.toString()]||{},he={height:se};for(const[be,We]of Object.entries(Q)){if(Array.isArray(We)){const nt=We.filter(Xe=>Xe!=null);if(nt.length){const Xe=nt[Math.floor(Math.random()*nt.length)];he[be]=parseFloat(Xe.toFixed(2));continue}}he[be]="N/A"}M({title:"Success!",description:"Poses captured successfully!",status:"success",duration:2e3,isClosable:!0}),setTimeout(()=>t("RESULTS",he),1500)},[t,B,M]),pe=ee.useCallback(se=>{o.current&&(clearTimeout(o.current),o.current=null),B(),O(x3),S(`Hold Pose: ${x3}`),s.current=setInterval(()=>{O(me=>{if(me===null)return null;const ge=me-1;return ge>0?(S(`Hold Pose: ${ge}`),ge):(B(),se==="SIDE_PROMPT"?S("Front pose captured! Prepare for SIDE pose."):(S("Side pose captured! Processing..."),ae()),I(se),_(!1),null)})},1e3)},[ae,B]),ye=ee.useCallback(se=>{if(F!==null||o.current!==null)return;const me=Ls=>{_(!1),B(),S(Ls)};if(!se||!se.length){me("No person detected. Ensure you are fully visible.");return}const ge=se[0].keypoints;if(y3.filter(Ls=>{var Wt;return((Wt=ge[Ls])==null?void 0:Wt.score)>gTe}).length<y3.length){me("Full body not visible or low confidence. Adjust position.");return}const he=ge[Is.LEFT_SHOULDER],be=ge[Is.RIGHT_SHOULDER],We=ge[Is.LEFT_HIP],nt=ge[Is.RIGHT_HIP];if(!he||!be||!We||!nt){me("Cannot determine orientation. Adjust position.");return}const Xe=Math.abs(he.x-be.x),kt=Math.abs(We.x-nt.x),mt=Xe>kt*.8&&Xe>50,Et=Xe<kt*.7||Xe<50;let rn=!1,Jn="Detecting pose...";$==="DETECTING_FRONT"?(rn=mt,Jn="Please face the camera directly."):$==="DETECTING_SIDE"&&(rn=Et,Jn="Please turn 90 degrees (side view)."),rn?R||(_(!0),S("Good Pose! Hold Still..."),o.current=setTimeout(()=>{o.current=null,pe($==="DETECTING_FRONT"?"SIDE_PROMPT":"DONE")},yTe)):me(Jn)},[$,F,R,pe,B]),ve=ee.useCallback(async()=>{if(($==="DETECTING_FRONT"||$==="DETECTING_SIDE")&&F===null&&o.current===null&&r.current&&e.current.readyState>=2)try{const se=await r.current.estimatePoses(e.current,{maxPoses:1});ye(se)}catch(se){console.error(se)}n.current=requestAnimationFrame(ve)},[$,ye,F]);ee.useEffect(()=>(r.current&&e.current&&!i&&!y&&$!=="ERROR"&&$!=="DONE"?(cancelAnimationFrame(n.current),n.current=requestAnimationFrame(ve)):cancelAnimationFrame(n.current),()=>cancelAnimationFrame(n.current)),[$,i,y,ve]),ee.useEffect(()=>{let se;return $==="SIDE_PROMPT"&&(cancelAnimationFrame(n.current),se=setTimeout(()=>{I("DETECTING_SIDE")},1500)),()=>clearTimeout(se)},[$]);const $e=ee.useCallback(()=>{cancelAnimationFrame(n.current),B(),_(!1),c(null),r.current&&(r.current.dispose(),r.current=null),x(!1),V()},[V,B]);return K.jsx(Gf,{maxW:"container.xl",py:4,children:K.jsxs(ra,{spacing:4,w:"100%",children:[K.jsx(Sd,{size:"lg",children:"Pose Capture"}),(i||y)&&$!=="ERROR"&&K.jsxs(ra,{children:[K.jsx(jf,{size:"xl",color:"blue.500"}),K.jsx(Sr,{children:w}),y&&K.jsx(_P,{size:"xs",isIndeterminate:!0,width:"80%",mt:2})]}),l&&K.jsxs(Hb,{status:"error",variant:"subtle",flexDirection:"column",alignItems:"center",justifyContent:"center",textAlign:"center",borderRadius:"md",children:[K.jsx(Kb,{boxSize:"40px",mr:0}),K.jsx(Sr,{mt:2,children:l})]}),!l&&K.jsxs(Po,{position:"relative",width:"100%",mx:"auto",bg:"gray.200",borderRadius:"lg",overflow:"hidden",boxShadow:"lg",display:d?"block":"none",children:[K.jsx("video",{ref:A,autoPlay:!0,playsInline:!0,muted:!0,style:{width:"100%",height:"auto",display:"block"}}),K.jsx(EP,{initialScale:.9,in:F!==null,children:K.jsx(fP,{position:"absolute",top:"50%",left:"50%",transform:"translate(-50%,-50%)",size:"100px",bg:"rgba(46,204,113,0.8)",color:"white",fontSize:"4xl",fontWeight:"bold",zIndex:"20",children:F})}),!i&&d&&K.jsx(Sr,{position:"absolute",bottom:{base:"5px",md:"10px"},left:{base:"5px",md:"10px"},right:{base:"5px",md:"10px"},bg:R&&F===null&&o.current===null?"rgba(46,204,113,0.8)":"rgba(0,0,0,0.7)",color:"white",p:{base:1,md:2},borderRadius:"md",fontSize:{base:"sm",md:"lg"},textAlign:"center",zIndex:"10",transition:"background-color 0.3s ease",children:w})]}),$!=="INITIALIZING"&&$!=="ERROR"&&!i&&!y&&K.jsx(bd,{onClick:$e,colorScheme:"orange",size:"lg",mt:4,children:"Retake Poses"})]})})}const vTe={Shoulder:"Shoulder Width",ApexHeight:"Apex Height",ApexDistance:"Apex Distance",FullLength:"Full Length",SleeveLength:"Sleeve Length",LowerArmGirth:"Lower Arm Girth",Waist:"Waist",Hip:"Hip",Thigh:"Thigh",BodyFigure:"Body Figure",Knee:"Knee",Crotch:"Crotch",Bottomline:"Bottom Line"},v3={Waist:Dh,Hip:Dh,Thigh:Dh,default:Dh};function bTe({onNavigate:t,results:e}){const[n,r]=ee.useState(!0);ee.useEffect(()=>{const i=setTimeout(()=>r(!1),1500);return()=>clearTimeout(i)},[]);const s=()=>t("HEIGHT_INPUT"),o=i=>{const a=parseFloat(i);return isNaN(a)?"N/A":`${a.toFixed(1)} in`};return K.jsx(Gf,{maxW:"container.md",py:{base:8,md:12},children:K.jsxs(ra,{spacing:8,align:"stretch",children:[K.jsx(Sd,{as:"h1",size:"xl",textAlign:"center",color:"teal.600",children:n?"Calculating Measurements...":"Your Estimated Measurements"}),n?K.jsx(mP,{py:10,children:K.jsxs(ra,{spacing:4,children:[K.jsx(jf,{thickness:"4px",speed:"0.65s",emptyColor:"gray.200",color:"teal.500",size:"xl"}),K.jsx(Sr,{fontSize:"lg",color:"gray.500",children:"Analyzing for best results confidence..."})]})}):K.jsx(RP,{in:!n,children:K.jsxs(ra,{spacing:8,align:"stretch",children:[K.jsxs(Sr,{textAlign:"center",fontSize:"lg",color:"gray.600",children:["Based on your height of ",(e==null?void 0:e.height)||"N/A"," cm and captured pose."]}),K.jsx(CP,{columns:{base:1,sm:2},spacing:6,children:Object.entries(e).filter(([i])=>i!=="height").map(([i,a])=>{const l=v3[i]||v3.default;return K.jsxs(B7,{variant:"outline",textAlign:"center",children:[K.jsx(V7,{children:K.jsx(xa,{as:l,w:8,h:8,color:"teal.500",mb:2})}),K.jsx(M7,{children:K.jsxs(FP,{children:[K.jsx(OP,{fontSize:"sm",color:"gray.600",children:vTe[i]||i}),K.jsx(LP,{fontSize:"2xl",children:o(a)})]})})]},i)})}),K.jsx(Sr,{textAlign:"center",fontSize:"sm",color:"gray.500",mt:4,children:"Note: These are estimations based on general data and simulated pose capture."}),K.jsx(bd,{colorScheme:"teal",size:"lg",onClick:s,alignSelf:"center",leftIcon:K.jsx(FK,{}),children:"Start Over (Enter Height)"})]})})]})})}function wTe(){const t=new Date().getFullYear();return K.jsxs("footer",{className:"app-footer",children:["DMMMSU BSFT ",t]})}function STe(){const[t,e]=ee.useState("LANDING"),[n,r]=ee.useState(null),s=(i,a=null)=>{console.log(`Navigating to ${i} with data:`,a),r(a),e(i)};let o;return t==="LANDING"?o=K.jsx(IK,{onNavigate:s}):t==="INSTRUCTIONS"?o=K.jsx(UK,{onNavigate:s}):t==="HEIGHT_INPUT"?o=K.jsx(GK,{onNavigate:s}):t==="CAMERA"?o=K.jsx(xTe,{onNavigate:s}):t==="RESULTS"?o=K.jsx(bTe,{onNavigate:s,results:n}):o=K.jsxs("div",{children:["Unknown View: ",t]}),K.jsxs("div",{className:"app-container",children:[K.jsx("main",{className:"main-content",children:o}),K.jsx(wTe,{})]})}const CTe=Q7();fL.createRoot(document.getElementById("root")).render(K.jsx(ta.StrictMode,{children:K.jsx(A7,{theme:CTe,children:K.jsx(STe,{})})}));
